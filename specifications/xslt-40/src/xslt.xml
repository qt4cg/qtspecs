<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE spec SYSTEM "../schema/xsltspec.dtd">
<!-- 
   Draft A. xsl:if, xsl:when/xsl:otherwise, xsl:switch
--><spec xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" xmlns:t="http://www.w3.org/2008/XSL/Spec/TreeDiagram" xmlns:g="http://www.martin-loetzsch.de/DOTML" w3c-doctype="rec" status="int-review"><!--role="editors-copy"--> 
 
   <header>
      <title>XSL Transformations (XSLT)</title>
      <version>Version 4.0</version>
      <w3c-designation>REC-xslt-40</w3c-designation>
      <w3c-doctype>W3C Editor's Draft</w3c-doctype>
      <pubdate>
         <!-- The value from the build.xml file is used in preference -->
         <day>8</day>
         <month>June</month>
         <year>2017</year>
      </pubdate> 
      <publoc>
         <loc href="https://www.w3.org/TR/yyyy/WD-xslt-40-yyyymmdd/">https://www.w3.org/TR/yyyy/WD-xslt-40-yyyymmdd/</loc>
      </publoc>
      <altlocs>
         <loc href="Overview.html">Normative specification in HTML format</loc>
         <loc href="Overview-diff.html">HTML with revision markings (non-normative)</loc>
         <loc href="schema-for-xslt40.xsd">XSD 1.1 Schema for XSLT 4.0 Stylesheets (non-normative)</loc>
         <loc href="schema-for-xslt40.rnc">Relax-NG Schema for XSLT 4.0 Stylesheets (non-normative)</loc>
         <loc href="schema-for-json.xsd">XSD 1.0 Schema for the XML representation of JSON used by
            fn:json-to-xml (non-normative)</loc>
         <loc href="xml-to-json.xsl">Stylesheet for XML-to-JSON conversion (non-normative)</loc>
      </altlocs>
      <latestloc>
         <loc href="https://www.w3.org/TR/xslt-40/"/>
      </latestloc>
      <!--<prevlocs>
         <loc href="https://www.w3.org/TR/2017/PR-xslt-30-20170418/">https://www.w3.org/TR/2017/PR-xslt-30-20170418/</loc>
      </prevlocs>-->
      <authlist>
         <author>
            <name>Michael Kay</name>
            <affiliation>Saxonica</affiliation>
            <email href="http://www.saxonica.com/">http://www.saxonica.com/</email>
         </author>
      </authlist>
      <!--<errataloc href="http://www.w3.org/XML/2017/qt-errata/xslt-30-errata.html"/>
      <translationloc href="https://www.w3.org/2003/03/Translations/byTechnology?technology=xslt-30"/>-->
      <status>
         <p><emph>This section describes the status of this document at the time of its publication.
               Other documents may supersede this document. A list of current W3C publications and
               the latest revision of this technical report can be found in the <loc href="https://www.w3.org/TR/">W3C technical reports index at
                  https://www.w3.org/TR/.</loc></emph></p>
         
         <p>This document has no official standing. It is produced by the editor as a proposal for community review.
         Insofar as it copies large amounts of text from the W3C XSLT 3.0 Recommendation, W3C copyright and similar provisions
         apply.</p>

         <!--<p>This document is governed by the <loc id="w3c_process_revision" href="https://www.w3.org/2017/Process-20170301/">1 March 2017 W3C Process Document</loc>.</p>

         <p>This is a <loc href="https://www.w3.org/2017/Process-20170301/#rec-publication">Recommendation</loc> of the W3C. It was developed by the W3C <loc href="https://www.w3.org/Style/XSL/">XSLT Working
               Group</loc>.</p>
         
         <p>This Recommendation specifies XSLT version 4.0. Changes since <loc href="https://www.w3.org/TR/xslt20">XSLT 3.0</loc> 
            are listed in <specref ref="changes-since-3.0"/>. The only incompatibilities with XSLT 2.0 relate to the way in which certain error
            conditions are handled: the details are given in <specref ref="incompatibilities"/>.</p>
         
         <p>No substantive changes have been made to this specification since its publication as a Proposed Recommendation. A few corrections
            and clarifications have been made to non-normative text: these are listed in <specref ref="changes-since-apr-2017"/>.</p>
         
         <p>This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, 
            and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material 
            or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and 
            to promote its widespread deployment. This enhances the functionality and interoperability of the Web.</p>
         
         <p>A test suite for XSLT 4.0, containing over 11,000 test cases, is available at <loc href="https://dvcs.w3.org/hg/xslt30-test/"/>. The metadata
            for each test case describes any dependencies on optional or implementation-defined features of the specification, and provides
            expected results for each test. Documentation on how to run tests is available within the test suite. New tests may be added from time to
            time, and contributions are welcome.</p>
         
         <p>An <loc href="https://dvcs.w3.org/hg/xslt30-test/raw-file/tip/report/simpleReportOut.html">implementation report</loc>  
            is available detailing test results for various implementations. This link points to the latest
            version of the report; older versions are available within the repository. New submissions of test results
            are welcome. Submitted test results and a stylesheet for generating the reports can be found within the
            repository.</p>

         <p>This specification has been developed in conjunction with
               <bibref ref="xpath-30"/> and other documents that underpin both XSLT and XQuery. XSLT
            3.0 <rfc2119>requires</rfc2119> support for XPath 3.0 augmented by a selection of
            features from XPath 3.1 which are described in <specref ref="map"/> and <specref ref="json"/>. XSLT 3.0 in addition allows a processor to support the whole of XPath
            3.1, in which case it must do so as described in <specref ref="xpath31-feature"/>. In
            the event that future versions of XPath are defined beyond XPath 3.1, this specification
            allows XSLT 3.0 processors to provide support for such versions, but leaves it <termref def="dt-implementation-defined"/> how this is done. References in this document to
            XPath and related specifications are by default to the 3.0 versions, but such references
            should be treated as version-agnostic unless the relevant prose indicates otherwise.</p>

         <p><emph>XSLT 3.0 specifies extensions to the XDM 3.0 data
               model, to the XPath 3.0 language syntax, and to the XPath 3.0 function library to
               underpin the introduction of maps, which were found necessary to support some
               XSLT streaming use cases, to enable XSLT to process JSON data, and to make many other
               processing tasks easier. These
               extensions have been incorporated into XDM 3.1 and XPath 3.1. Although XDM 3.1 and XPath 3.1 
               have reached Recommendation status, XSLT 3.0 
               has not been made dependent on XPath 3.1, other than those features needed to meet the XSLT 3.0 requirements.
            </emph></p>



         <p>Please report errors in this document using W3C’s <loc href="https://www.w3.org/Bugs/Public/">public Bugzilla system</loc> (instructions can
            be found at <loc href="https://www.w3.org/XML/2005/04/qt-bugzilla"/>). If access to that
            system is not feasible, you may send your comments to the W3C XSLT/XPath/XQuery public
            comments mailing list, <loc href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</loc>. It will be very helpful if you include the string
            “[XSLT30]” in the subject line of your report, whether made in Bugzilla or in email.
            Please use multiple Bugzilla entries (or, if necessary, multiple email messages) if you
            have more than one comment to make. Archives of the comments and responses are available
            at <loc href="https://lists.w3.org/Archives/Public/public-qt-comments/"/>.</p>
         
         <p>The same mechanism may be used for reporting errors in the test suite.</p>

         <p>This document was produced by a group operating under the <loc href="https://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C
               Patent Policy</loc>. W3C maintains a <loc rel="disclosure" href="https://www.w3.org/2004/01/pp-impl/19552/status#disclosures">public list of any
               patent disclosures</loc> made in connection with the deliverables of the group; that
            page also includes instructions for disclosing a patent. An individual who has actual
            knowledge of a patent which the individual believes contains <loc href="https://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
               Claim(s)</loc> must disclose the information in accordance with <loc href="https://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6
               of the W3C Patent Policy</loc>.</p>-->

      </status>
      <abstract>
         <p>This specification defines the syntax and semantics of XSLT 4.0, a language designed
               primarily for transforming XML documents into other XML documents.</p>
         <p>XSLT 4.0 is a revised version of the XSLT 3.0 Recommendation <bibref ref="xslt30"/>
            published on 8 June 2017.</p>
         <p>The changes in this version of the language are relatively minor usability enhancements. There
         are no changes to the data model or processing model. Instead, the specification attempts to fill
         a number of gaps in functionality resulting from feedback from XSLT 3.0 users. The main areas
         covered are:</p>
         <ulist>
            <item><p>Enhancements to the type system to allow more expressive constraints, especially
            for maps and atomic values.</p></item>
            <item><p>Additional functionality for processing arrays.</p></item>
            <item><p>Exploitation of the power afforded by first-class function items.</p></item>
         </ulist>
         <p>XSLT 4.0 is designed to be used in conjunction with XPath 4.0, which is defined in
               <bibref ref="xpath-40"/>. XSLT shares the same data model as XPath 4.0, which is
            defined in <bibref ref="xpath-datamodel-30"/>, and it uses the library of functions and
            operators defined in <bibref ref="xpath-functions-40"/>. XPath 4.0 and the underlying
            function library introduce a number of enhancements, for example the availability of
            union and record types. </p>
         
 
         <p>XSLT 4.0 also includes optional facilities to serialize the results of a transformation,
            by means of an interface to the serialization component described in 
            <bibref ref="xslt-xquery-serialization-31"/>.
         </p>
         <p>
            <emph>This document contains hyperlinks to specific sections or definitions within other
               documents in this family of specifications. These links are indicated visually by a
               superscript identifying the target specification: for example XP40 for XPath 4.0,
               DM30 for the XDM data model version 3.0, FO40 for Functions and Operators version
               4.0.</emph>
         </p>
         
      </abstract>
      <langusage>
         <language id="EN">English</language>
      </langusage>
      <revisiondesc>
         <slist>
            <sitem>((not used)).</sitem>
         </slist>
      </revisiondesc>
   </header>
   <body>
      <div1 id="introduction">
         <head>Introduction</head>
         <div2 id="what-is-xslt">
            <head>What is XSLT?</head>
            <p>This specification defines the syntax and semantics of the XSLT 4.0 language.</p>
            <p>A transformation in the XSLT language is expressed in the
               form of a <term>stylesheet</term>. A stylesheet is made up of one or more well-formed
               XML <bibref ref="REC-xml"/> documents conforming to the Namespaces in XML
               Recommendation <bibref ref="xml-names"/>. </p>
            <p>A stylesheet generally includes elements that are defined by XSLT as well as elements
               that are not defined by XSLT. XSLT-defined elements are distinguished by use of the
               namespace <code>http://www.w3.org/1999/XSL/Transform</code> (see <specref ref="xslt-namespace"/>), which is referred to in this specification as the
                  <termref def="dt-xslt-namespace">XSLT namespace</termref>. Thus this specification
               is a definition of the syntax and semantics of the XSLT namespace.</p>
            <p>The term <termref def="dt-stylesheet">stylesheet</termref> reflects the fact that one
               of the important roles of XSLT is to add styling information to an XML source
               document, by transforming it into a document consisting of XSL formatting objects
               (see <bibref ref="xsl11"/>), or into another presentation-oriented format such as
               HTML, XHTML, or SVG. However, XSLT is used for a wide range of transformation tasks,
               not exclusively for formatting and presentation applications.</p>
            <p>A transformation expressed in XSLT describes rules for transforming  input data into output data. The inputs and outputs
                  will all be instances of the XDM data model, described in <bibref ref="xpath-datamodel-30"/>. In the simplest and most common case, the input is
                  an XML document referred to as the source tree, and the output is an XML document
                  referred to as the result tree. It is also possible to process multiple source
                  documents, to generate multiple result documents, and to handle formats other than
                  XML.
                The transformation is achieved by a set of
                  <termref def="dt-template-rule">template rules</termref>. A template rule
               associates a <termref def="dt-pattern">pattern</termref>, which typically matches nodes in the source document, with a
                  <termref def="dt-sequence-constructor">sequence constructor</termref>. In many
               cases, evaluating the sequence constructor will cause new nodes to be constructed,
               which can be used to produce part of a result tree. The structure of the result trees
               can be completely different from the structure of the source trees. In constructing a
               result tree, nodes from the source trees can be filtered and reordered, and arbitrary
               structure can be added. This mechanism allows a <termref def="dt-stylesheet">stylesheet</termref> to be applicable to a wide class of documents that have
               similar source tree structures.</p>



            <p>Stylesheets have a modular structure; they may contain several packages developed
               independently of each other, and each package may consist of several stylesheet
               modules. </p>

            <p><termdef id="dt-stylesheet" term="stylesheet">A
                     <term>stylesheet</term> consists of one or more packages: specifically, one
                     <termref def="dt-top-level-package">top-level package</termref> and zero or
                  more <termref def="dt-library-package">library packages</termref>.</termdef></p>

            <p><termdef id="dt-top-level-package" term="top-level package">For a given transformation, one <termref def="dt-package">package</termref> functions as the <term>top-level package</term>. The
                  complete <termref def="dt-stylesheet">stylesheet</termref> is assembled by finding
                  the packages referenced directly or indirectly from the top-level package using
                     <elcode>xsl:use-package</elcode> declarations: see <specref ref="package-dependencies"/>.</termdef></p>

            <p><termdef id="dt-library-package" term="library package">Every <termref def="dt-package">package</termref> within a <termref def="dt-stylesheet">stylesheet</termref>, other than the <termref def="dt-top-level-package">top-level package</termref>, is referred to as a
                     <term>library package</term>.</termdef></p>

            <p><termdef id="dt-principal-stylesheet-module" term="principal stylesheet module">Within a <termref def="dt-package">package</termref>, one <termref def="dt-stylesheet-module"/> functions as the
                     <term>principal stylesheet module</term>. The complete package is assembled by
                  finding the stylesheet modules referenced directly or indirectly from the
                  principal stylesheet module using <elcode>xsl:include</elcode> and
                     <elcode>xsl:import</elcode> elements: see <specref ref="include"/> and <specref ref="import"/>.</termdef></p>


         </div2>
         <div2 id="whats-new-in-xslt4">
            <head>What’s New in XSLT 4.0?</head>
            <!--<p>A major focus for enhancements in XSLT 3.0 is the requirement to enable streaming of
               source documents. This is needed when source documents become too large to hold in
               main memory, and also for applications where it is important to start delivering
               results before the entire source document is available.</p>
            <p>While implementations of XSLT that use streaming have always been theoretically
               possible, the nature of the language has made it very difficult to achieve this in
               practice. The approach adopted in this specification is twofold: it identifies a set
               of restrictions which, if followed by stylesheet authors, will enable implementations
               to adopt a streaming mode of operation without placing excessive demands on the
               optimization capabilities of the processor; and it provides new constructs to
               indicate that streaming is required, or to express transformations in a way that
               makes it easier for the processor to adopt a streaming execution plan.</p>
            <p>Capabilities provided in this category include:</p>
            <ulist>
               <item>
                  <p>A new <elcode>xsl:source-document</elcode> instruction, which reads and processes a
                     source document, optionally in streaming mode;</p>
               </item>
               <item>
                  <p>The ability to declare that a <termref def="dt-mode">mode</termref> is a
                     streaming mode, in which case all the template rules using that mode must be
                     streamable;</p>
               </item>
               <item>
                  <p>A new <elcode>xsl:iterate</elcode> instruction, which iterates over the items
                     in a sequence, allowing parameters for the processing of one item to be set
                     during the processing of the previous item;</p>
               </item>
               <item>
                  <p>A new <elcode>xsl:merge</elcode> instruction, allowing multiple input streams
                     to be merged into a single output stream;</p>
               </item>
               <item>
                  <p>A new <elcode>xsl:fork</elcode> instruction, allowing multiple computations to
                     be performed in parallel during a single pass through an input document;</p>
               </item>
               <item>
                  <p><termref def="dt-accumulator-function">Accumulators</termref>, which allow a
                     value to be computed progressively during streamed processing of a document,
                     and accessed as a function of a node in the document, without compromise to the
                     functional nature of the XSLT language.</p>
               </item>
            </ulist>
            <p>A second focus for enhancements in XSLT 3.0 is the introduction of a new mechanism
               for stylesheet modularity, called the package. Unlike the stylesheet modules of XSLT
               1.0 and 2.0 (which remain available), a package defines an interface that regulates
               which functions, variables, templates and other components are visible outside the
               package, and which can be overridden. There are two main goals for this facility: it
               is designed to deliver software engineering benefits by improving the reusability and
               maintainability of code, and it is intended to streamline stylesheet deployment by
               allowing packages to be compiled independently of each other, and compiled instances
               of packages to be shared between multiple applications.</p>

            <p>Other significant features in XSLT 3.0 include:</p>
            <ulist>
               <item>
                  <p>An <elcode>xsl:evaluate</elcode> instruction allowing evaluation of XPath
                     expressions that are dynamically constructed as strings, or that are read from
                     a source document;</p>
               </item>
               <item>
                  <p>Enhancements to the syntax of <termref def="dt-pattern">patterns</termref>, in
                     particular enabling the matching of atomic values as well as nodes;</p>
               </item>
               <item>
                  <p>An <elcode>xsl:try</elcode> instruction to allow recovery from dynamic
                     errors;</p>
               </item>
               <item>
                  <p>The element <elcode>xsl:global-context-item</elcode>, used to declare the
                     stylesheet’s expectations of the global context item (notably, its
                     type);</p>
               </item>
               <item>
                  <p>A new instruction <elcode>xsl:assert</elcode> to assist developers in producing
                     correct and robust code.</p>
               </item>
            </ulist>
            <p>XSLT 3.0 also delivers enhancements made to the XPath language and to the standard
               function library, including the following:</p>
            <ulist>
               <item>
                  <p>Variables can now be bound in XPath using the <code>let</code> expression.</p>
               </item>
               <item>
                  <p>Functions are now first class values, and can be passed as arguments to other
                     (higher-order) functions, making XSLT a fully-fledged functional programming
                     language.</p>
               </item>
               <item>
                  <p>A number of new functions are available, for example trigonometric functions,
                     and the functions <xfunction>parse-xml</xfunction> and
                        <xfunction>serialize</xfunction> to convert between lexical and tree
                     representations of XML.</p>
               </item>
            </ulist>
            <p>XSLT 3.0 also includes support for maps (a data structure
               consisting of key/value pairs, sometimes referred to in other programming languages
               as dictionaries, hashes, or associative arrays). This feature extends the data model,
               provides new syntax in XPath, and adds a number of new functions and operators. 
               Initially developed as XSLT-specific extensions, maps have now been integrated
               into XPath 3.1 (see <bibref ref="xpath-31"/>). XSLT 3.0 does not require implementations
               to support XPath 3.1 in its entirety, but it does requires support for these specific
               features.</p>-->
            
            <p>A full list of changes is at <specref ref="changes-since-3.0"/>.</p>
         </div2>
      </div1>
      <div1 id="concepts">
         <head>Concepts</head>
         <div2 id="terminology">
            <head>Terminology</head>
            <p>For a full glossary of terms, see <specref ref="glossary"/>.</p>
            <p>
               <termdef id="dt-processor" term="processor">The software responsible for transforming
                  source trees into result trees using an XSLT stylesheet is referred to as the
                     <term>processor</term>. This is sometimes expanded to <emph>XSLT
                     processor</emph> to avoid any confusion with other processors, for example an
                  XML processor.</termdef>
            </p>
            <p>
               <termdef id="dt-implementation" term="implementation">A specific product that
                  performs the functions of an <termref def="dt-processor">XSLT processor</termref>
                  is referred to as an <term>implementation</term>.</termdef></p>
            <p>
               <termdef id="dt-tree" term="tree">The term <term>tree</term> is used (as in <bibref ref="xpath-datamodel-30"/>) to refer to the aggregate consisting of a
                  parentless node together with all its descendant nodes, plus all their attributes
                  and namespaces.</termdef>
            </p>
               <note>
                  <p>The use of the term <term>tree</term> in this document does not imply the use
                     of a data structure in memory that holds the entire contents of the document at
                     one time. It implies rather a logical view of the XML input and output in which
                     elements have a hierarchic relationship to each other. When a source document
                     is being processed in a streaming manner, access to the nodes in this tree is
                     constrained, but it is still viewed and described as a tree.</p>
               </note>
            
            <p>The output of a transformation consists of the
               following:</p>
            <olist>
               <item>
                  <p><termdef id="dt-principal-result" term="principal result">A <term>principal
                           result</term>: this can be any sequence of items (as defined in <bibref ref="xpath-datamodel-30"/>).</termdef> The principal result is the value
                     returned by the function or template in the stylesheet that is nominated as the
                     entry point, as described in <specref ref="initiating"/>.</p>
               </item>
               <item>
                  <p><termdef id="dt-secondary-result" term="secondary result">Zero or more
                           <term>secondary results</term>: each secondary result can be any sequence
                        of items (as defined in <bibref ref="xpath-datamodel-30"/>).</termdef> A
                     secondary result is the value returned by evaluating the body of an
                        <elcode>xsl:result-document</elcode> instruction.</p>
               </item>
               <item>
                  <p>Zero or more messages. Messages are generated by the
                        <elcode>xsl:message</elcode> and <elcode>xsl:assert</elcode> instructions, and are described in <specref ref="message"/> and <specref ref="assertions"/>.</p>
               </item>
               <item>
                  <p>Static or dynamic errors: see <specref ref="errors"/>. </p>
               </item>
            </olist>
            <p>The <termref def="dt-principal-result"/> and the <termref def="dt-secondary-result">secondary results</termref> may be post-processed as
               described in <specref ref="post-processing"/>.</p>
            <p>
               <termdef id="dt-result-tree" term="result tree">The term <term>result tree</term> is
                  used to refer to any <termref def="dt-tree">tree</termref> constructed by <termref def="dt-instruction">instructions</termref> in the stylesheet. A result tree is
                  either a <termref def="dt-final-result-tree">final result tree</termref> or a
                     <termref def="dt-temporary-tree">temporary tree</termref>.</termdef>
            </p>
            <p>
               <termdef id="dt-final-result-tree" term="final result tree">A <term>final result
                     tree</term> is a <termref def="dt-result-tree">result tree</termref> that forms
                  part of the output of a transformation: specifically, a tree built by post-processing the items in the <termref def="dt-principal-result"/> or in a <termref def="dt-secondary-result"/>. Once created, the contents of a final result tree are not
                  accessible within the stylesheet itself.</termdef>
                Any final result tree
                  <rfc2119>may</rfc2119> be serialized as described in <specref ref="serialization"/>.</p>
            <p>
               <termdef id="dt-source-tree" term="source tree">The term <term>source tree</term>
                  means any tree provided as input to the transformation. This includes the document
                  containing the <termref def="dt-global-context-item"/> if any, documents containing
                     nodes present in the <termref def="dt-initial-match-selection"/>,
                  documents containing nodes supplied as the values of <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, documents
                  obtained from the results of functions such as <function>document</function>,
                     <xfunction>doc</xfunction>, and <xfunction>collection</xfunction>, documents read using the <elcode>xsl:source-document</elcode>
                     instruction, and documents returned by extension functions or
                  extension instructions. In the context of a particular XSLT instruction, the term
                     <term>source tree</term> means any tree provided as input to that instruction;
                  this may be a source tree of the transformation as a whole, or it may be a
                     <termref def="dt-temporary-tree">temporary tree</termref> produced during the
                  course of the transformation.</termdef>
            </p>
            <p>
               <termdef id="dt-temporary-tree" term="temporary tree">The term <term>temporary
                     tree</term> means any tree that is neither a <termref def="dt-source-tree">source tree</termref> nor a <termref def="dt-final-result-tree">final result
                     tree</termref>.</termdef> Temporary trees are used to hold intermediate results
               during the execution of the transformation.</p>
            <p>The use of the term “tree” in phrases such as <term>source
                  tree</term>, <term>result tree</term>, and <term>temporary tree</term> is not
               confined to documents that the processor materializes in memory in their entirety.
               The processor <rfc2119>may</rfc2119>, and in some cases <rfc2119>must</rfc2119>, use
               streaming techniques to limit the amount of memory used to hold source and result
               documents. When streaming is used, the nodes of the tree may never all be in memory
               at the same time, but at an abstract level the information is still modeled as a tree
               of nodes, and the document is therefore still described as a tree. Unless otherwise stated, the term “tree” refers to a tree rooted
                  at a parentless node: that is, the term does not include subtrees of larger trees.
                  Every node therefore belongs to exactly one tree.</p>
            <p>In this specification the phrases <rfc2119>must</rfc2119>, <rfc2119>must
                  not</rfc2119>, <rfc2119>should</rfc2119>, <rfc2119>should not</rfc2119>,
                  <rfc2119>may</rfc2119>, <rfc2119>required</rfc2119>, and
                  <rfc2119>recommended</rfc2119>, when used in normative
                  text and rendered in capitals, are to be interpreted as described in
                  <bibref ref="rfc2119"/>.</p>
            <p>Where the phrase <rfc2119>must</rfc2119>, <rfc2119>must not</rfc2119>, or
                  <rfc2119>required</rfc2119> relates to the behavior of the XSLT processor, then an
               implementation is not conformant unless it behaves as specified, subject to the more
               detailed rules in <specref ref="conformance"/>. </p>
            <p>Where the phrase <rfc2119>must</rfc2119>, <rfc2119>must not</rfc2119>, or
                  <rfc2119>required</rfc2119> relates to a stylesheet then the processor
                  <rfc2119>must</rfc2119> enforce this constraint on stylesheets by reporting an
               error if the constraint is not satisfied.</p>
            <p>Where the phrase <rfc2119>should</rfc2119>, <rfc2119>should not</rfc2119>, or
                  <rfc2119>recommended</rfc2119> relates to a stylesheet then a processor
                  <rfc2119>may</rfc2119> produce warning messages if the constraint is not
               satisfied, but <rfc2119>must not</rfc2119> treat this as an error.</p>
            <p>
               <termdef id="dt-implementation-defined" term="implementation-defined">In this
                  specification, the term <term>implementation-defined</term> refers to a feature
                  where the implementation is allowed some flexibility, and where the choices made
                  by the implementation <rfc2119>must</rfc2119> be described in documentation that
                  accompanies any conformance claim.</termdef>
            </p>
            <p>
               <termdef id="dt-implementation-dependent" term="implementation-dependent">The term
                     <term>implementation-dependent</term> refers to a feature where the behavior
                     <rfc2119>may</rfc2119> vary from one implementation to another, and where the
                  vendor is not expected to provide a full specification of the behavior.</termdef>
               (This might apply, for example, to limits on the size of source documents that can be
               transformed.)</p>
            <p>In all cases where this specification leaves the behavior implementation-defined or
               implementation-dependent, the implementation has the option of providing mechanisms
               that allow the user to influence the behavior.</p>
            <p>A paragraph labeled as a <term>Note</term> or described as an <term>example</term> is
               non-normative.</p>
            <p>Many terms used in this document are defined in the XPath specification <bibref ref="xpath-30"/> or the XDM specification <bibref ref="xpath-datamodel-30"/>.
               Particular attention is drawn to the following:</p>
            <ulist>
               <item>
                  <p>
                     <termdef id="dt-atomization" term="atomize">The term <term>atomization</term>
                        is defined in <!--<bibref ref="xpath-30"/>--><xspecref spec="XP40" ref="id-atomization"/>. It is a process that takes as input a sequence of
                           items, and returns a sequence of
                        atomic values, in which the nodes are replaced by their typed values as
                        defined in <bibref ref="xpath-datamodel-30"/>. 
                        <phrase diff="del" at="A">If the XPath 3.1 feature is implemented,
                        then</phrase> Arrays (see <specref ref="arrays"/>) are atomized by atomizing their
                        members, recursively.</termdef> For some items (for example, elements with element-only
                     content, function items, and maps, atomization
                     generates a <termref def="dt-dynamic-error">dynamic error</termref>.</p>
               </item>
               <item>
                  <p>
                     <termdef id="dt-typed-value" term="typed value">The term <term>typed
                           value</term> is defined in <xspecref spec="DM30" ref="dm-typed-value"/>.
                        Every node, other than an element whose type
                           annotation identifies it as having element-only content, has a
                           <termref def="dt-string-value">typed value</termref>. For example, the
                           <termref def="dt-typed-value">typed value</termref> of an attribute of
                        type <code>xs:IDREFS</code> is a sequence of zero or more
                           <code>xs:IDREF</code> values.</termdef>
                  </p>
               </item>
               <item>
                  <p>
                     <termdef id="dt-string-value" term="string value">The term <term>string
                           value</term> is defined in
                           <!--<bibref ref="xpath-datamodel-30"/>--><xspecref spec="DM30" ref="dm-string-value"/>. Every node has a <termref def="dt-string-value">string value</termref>. For example, the <termref def="dt-string-value">string value</termref> of an element is the concatenation of the
                           <termref def="dt-string-value">string values</termref> of all its
                        descendant text nodes.</termdef>
                  </p>
               </item>
               <item>
                  <p>
                     <termdef id="dt-xpath-compat-mode" term="XPath 1.0 compatibility mode">The term
                           <term>XPath 1.0 compatibility mode</term> is defined in <xspecref spec="XP40" ref="static_context"/>. This is a setting in the static
                        context of an XPath expression; it has two values, <code>true</code> and
                           <code>false</code>. When the value is set to true, the semantics of
                        function calls and certain other operations are adjusted to give a greater
                        degree of backwards compatibility between XPath
                           3.0 and XPath 1.0.</termdef>
                  </p>


               </item>
            </ulist>
            
         </div2>
         <div2 id="notation">
            <head>Notation</head>
            <p>
               <termdef id="dt-xslt-element" term="XSLT element">An <term>XSLT element</term> is an
                  element in the <termref def="dt-xslt-namespace">XSLT namespace</termref> whose
                  syntax and semantics are defined in this specification.</termdef> For a
               non-normative list of XSLT elements, see <specref ref="element-syntax-summary"/>.</p>
            <p>In this document the specification of each <termref def="dt-xslt-element">XSLT
                  element</termref> is preceded by a summary of its syntax in the form of a model
               for elements of that element type. A full list of all these specifications can be
               found in <specref ref="element-syntax-summary"/>. The meaning of the syntax summary
               notation is as follows:</p>
            <ulist>
               <item>
                  <p>An attribute that is <rfc2119>required</rfc2119> is shown with its name in
                     bold. An attribute that may be omitted is shown with a question mark following
                     its name.</p>
               </item>
               <item>
                  <p>An attribute that is <termref def="dt-deprecated">deprecated</termref> is shown
                     in a grayed font within square brackets.</p>
               </item>
               <item>
                  <p>The string that occurs in the place of an attribute value specifies the allowed
                     values of the attribute. If this is surrounded by curly brackets
                        (<code>{...}</code>), then the attribute value is treated as an <termref def="dt-attribute-value-template">attribute value template</termref>, and
                     the string occurring within curly brackets specifies the allowed values of the
                     result of evaluating the attribute value template. Alternative allowed values
                     are separated by <code>|</code>. A quoted string indicates a value equal to
                     that specific string. An unquoted, italicized name specifies a particular type
                     of value.</p>
                  <p>The types used, and their meanings, are as follows:</p>
                  
                  <glist>
                     <gitem>
                        <label>
                           <code>boolean</code>
                        </label>
                        <def>
                           <p>One of the strings <code>"yes"</code>,
                              <code>"true"</code>, or <code>"1"</code> to indicate the value
                              <code>true</code>, or one of the strings <code>"no"</code>,
                              <code>"false"</code>, or <code>"0"</code> to indicate the value
                              <code>false</code>. Note: the values are synonyms; where this
                              specification uses a phrase such as “If <code>required='yes'</code> is
                              specified ...” this is to be interpreted as meaning “If the attribute
                              named <code>required</code> is present, and has the value
                              <code>yes</code>, <code>true</code>, or <code>1</code> (after
                              stripping leading and trailing whitespace) ...”.
                           </p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>string</code></label>
                        <def>
                           <p>Any string</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>expression</code></label>
                        <def>
                           <p>An XPath <termref def="dt-expression">expression</termref></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>pattern</code></label>
                        <def>
                           <p>A <termref def="dt-pattern">pattern</termref> as described in
                                 <specref ref="patterns"/>.</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>item-type</code></label>
                        <def>
                           <p>An <xnt spec="XP40" ref="prod-xpath40-ItemType">ItemType</xnt> as defined in the XPath
                              <phrase diff="chg" at="A">4.0</phrase> specification.</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>sequence-type</code></label>
                        <def>
                           <p>A <xnt spec="XP40" ref="prod-xpath40-SequenceType">SequenceType</xnt>
                              as defined in the XPath <phrase diff="chg" at="A">4.0</phrase> specification.</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>uri; uris</code></label>
                        <def>
                           <p>A URI, for example a namespace URI or a collation URI; a
                              whitespace-separated list of URIs</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>qname</code></label>
                        <def>
                           <p>A <termref def="dt-lexical-qname">lexical QName</termref> as defined
                              in <specref ref="qname"/></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>eqname; eqnames</code></label>
                        <def>
                           <p>An <termref def="dt-eqname">EQName</termref> as defined in <specref ref="qname"/>; a whitespace-separated list of EQNames</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>token; tokens</code></label>
                        <def>
                           <p>A string containing no significant whitespace; a whitespace-separated
                              list of such strings</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>nmtoken; nmtokens</code></label>
                        <def>
                           <p>A string conforming to the XML schema rules for the type
                                 <code>xs:NMTOKEN</code>; a whitespace-separated list of such
                              strings.</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>char</code></label>
                        <def>
                           <p>A string comprising a single Unicode character</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>integer</code></label>
                        <def>
                           <p>An integer, that is a string <phrase diff="chg" at="B">that is castable to</phrase> the schema type
                                 <code>xs:integer</code></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>decimal</code></label>
                        <def>
                           <p>A decimal value, that is a string <phrase diff="chg" at="B">that is castable to</phrase> the schema
                              type <code>xs:decimal</code></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>ncname;</code> <phrase diff="add" at="A"><code>ncnames</code></phrase></label>
                        <def>
                           <p>An unprefixed name: a string <phrase diff="chg" at="B">that is castable to</phrase> the schema type
                                 <code>xs:NCName</code>; <phrase diff="add" at="A">a whitespace-separated list of such strings</phrase></p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>prefix</code></label>
                        <def>
                           <p>An <code>xs:NCName</code> representing a namespace prefix, which must
                              be in scope for the element on which it appears</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label><code>id</code></label>
                        <def>
                           <p>An <code>xs:NCName</code> used as a unique identifier for an element
                              in the containing XML document</p>
                        </def>
                     </gitem>
                  </glist>
                  <!--Text replaced by erratum E2 change 1"-->
                  <p>Except where the set of allowed values of an attribute is specified using the
                     italicized name <emph>string</emph> or <emph>char</emph>, leading and trailing
                     whitespace in the attribute value is ignored. In the case of an <termref def="dt-attribute-value-template">attribute value template</termref>, this
                     applies to the <termref def="dt-effective-value">effective value</termref>
                     obtained when the attribute value template is expanded.</p>
                  <!--End of text replaced by erratum E2-->
                  <p>XPath comments (delimited by <code>(: ... :)</code>)
                  are permitted anywhere that inter-token whitespace is permitted in attributes whose
                  type is given as <emph>expression</emph>, <emph>pattern</emph>, <emph>item-type</emph>, 
                     or <emph>sequence-type</emph>, and are not permitted in attributes of other types
                     (other than within expressions enclosed by curly braces within an <termref def="dt-attribute-value-template"/>).</p>
               </item>
               <item>
                  <p>Unless the element is <rfc2119>required</rfc2119> to be empty, the model
                     element contains a comment specifying the allowed content. The allowed content
                     is specified in a similar way to an element type declaration in XML;
                        <emph>sequence constructor</emph> means that any mixture of text nodes,
                        <termref def="dt-literal-result-element">literal result elements</termref>,
                        <termref def="dt-extension-instruction">extension instructions</termref>,
                     and <termref def="dt-xslt-element">XSLT elements</termref> from the <termref def="dt-instruction">instruction</termref> category is allowed;
                        <emph>other-declarations</emph> means that any mixture of XSLT elements from
                     the <termref def="dt-declaration">declaration</termref> category is allowed, together with <termref def="dt-data-element">user-defined data elements</termref>.</p>
               </item>
               <item>
                  <p>The element is prefaced by comments indicating if it belongs to the
                        <code>instruction</code> category or <code>declaration</code> category or
                     both. The category of an element only affects whether it is allowed in the
                     content of elements that allow a <termref def="dt-sequence-constructor">sequence constructor</termref> or <emph>other-declarations</emph>.</p>
               </item>
            </ulist>
            <example>
               <head>Syntax Notation</head>
               <p>This example illustrates the notation used to describe <termref def="dt-xslt-element">XSLT elements</termref>.</p>
               <e:element-syntax name="example-element">
                  <e:in-category name="instruction"/>
                  <e:attribute name="select" required="yes">
                     <e:data-type name="expression"/>
                  </e:attribute>
                  <e:attribute name="debug">
                     <e:data-type name="boolean"/>
                  </e:attribute>
                  <e:attribute name="validation">
                     <e:attribute-value-template>
                        <e:constant value="strict"/>
                        <e:constant value="lax"/>
                     </e:attribute-value-template>
                  </e:attribute>
                  <e:sequence>
                     <e:choice repeat="zero-or-more">
                        <e:element name="variable"/>
                        <e:element name="param"/>
                     </e:choice>
                     <e:element name="sequence"/>
                  </e:sequence>
                  <e:allowed-parents>
                     <e:parent-category name="sequence-constructor"/>
                  </e:allowed-parents>
               </e:element-syntax>
               <p>This example defines a (non-existent) element <code>xsl:example-element</code>.
                  The element is classified as an instruction. It takes the following
                  attributes:</p>

               <olist>
                  <item>
                     <p>A mandatory <code>select</code> attribute, whose value is an XPath <termref def="dt-expression">expression</termref></p>
                  </item>
                  <item>
                     <p>An optional <code>debug</code> attribute, whose
                        value <rfc2119>must</rfc2119> be <code>yes</code>, <code>true</code>, or
                           <code>1</code> to indicate <code>true</code>, or <code>no</code>,
                           <code>false</code>, or <code>0</code> to indicate <code>false</code>.</p>
                  </item>
                  <item>
                     <p>An optional <code>validation</code> attribute, whose value must be
                           <code>strict</code> or <code>lax</code>; the curly brackets indicate that
                        the value can be defined as an <termref def="dt-attribute-value-template">attribute value template</termref>, allowing a value such as
                           <code>validation="{$val}"</code>, where the <termref def="dt-variable">variable</termref>
                        <code>val</code> is evaluated to yield <code>"strict"</code> or
                           <code>"lax"</code> at run-time.</p>
                  </item>
               </olist>
               <p>The content of an <code>xsl:example-element</code> instruction is defined to be a
                  sequence of zero or more <elcode>xsl:variable</elcode> and
                     <elcode>xsl:param</elcode> elements, followed by an
                     <elcode>xsl:sequence</elcode> element.</p>
            </example>
            <p>
               <error spec="XT" type="static" class="SE" code="0010">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                     XSLT-defined element is used in a context where it is not permitted, if a
                        <rfc2119>required</rfc2119> attribute is omitted, or if the content of the
                     element does not correspond to the content that is allowed for the element.</p>
               </error>
            </p>
            <p>The rules in the element syntax summary (both for the
               element structure and for its attributes) apply to the stylesheet content after
               preprocessing as described in <specref ref="preprocessing"/>.</p>
            <p>Attributes are validated as follows. These rules apply to the value of the attribute
               after removing leading and trailing whitespace.</p>
            <ulist>
               <item>
                  <p>
                     <error spec="XT" type="static" class="SE" code="0020">
                        <p>It is a <termref def="dt-static-error">static error</termref> if an
                           attribute (other than an attribute written using curly brackets in a
                           position where an <termref def="dt-attribute-value-template">attribute
                              value template</termref> is permitted) contains a value that is not
                           one of the permitted values for that attribute.</p>
                     </error>
                  </p>
               </item>
               <item>
                  <p>
                     <error spec="XT" type="dynamic" class="DE" code="0030">
                        <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the <termref def="dt-effective-value">effective value</termref> of an attribute
                           written using curly brackets, in a position where an <termref def="dt-attribute-value-template">attribute value template</termref>
                           is permitted, is a value that is not one of the permitted values for that
                           attribute. If the processor is able to detect the error statically (for
                           example, when any XPath expressions within the curly brackets can be
                           evaluated statically), then the processor may optionally signal this as a
                           static error.</p>
                     </error>
                  </p>
               </item>
            </ulist>
            <p>Special rules apply if the construct appears in part of the <termref def="dt-stylesheet">stylesheet</termref> that is processed with <termref def="dt-forwards-compatible-behavior"/>: see <specref ref="forwards"/>.</p>
            <p>
               <termdef id="dt-deprecated" term="deprecated">Some constructs defined in this
                  specification are described as being <term>deprecated</term>. The use of this term
                  implies that stylesheet authors <rfc2119>should not</rfc2119> use the construct,
                  and that the construct may be removed in a later version of this
                  specification.</termdef></p>
            <note>
               <p>This specification includes a non-normative XML Schema for XSLT <termref def="dt-stylesheet-module">stylesheet modules</termref> (see <specref ref="schema-for-xslt"/>). The syntax summaries described in this section are
                  normative.</p>
            </note>
            <p>XSLT defines a set of standard functions which are additional to those defined in
                  <bibref ref="xpath-functions-40"/>. A list of these
                  functions appears in <specref ref="XSLT-defined-functions"/>. The
               signatures of these functions are described using the same notation as used in
                  <bibref ref="xpath-functions-40"/>. The names of many
                  of these functions are in the <termref def="dt-standard-function-namespace">standard function namespace</termref>.</p>
         </div2>


         <div2 id="initiating">
            <head>Initiating a Transformation</head>
            <p>This document does not specify any application programming interfaces or other
               interfaces for initiating a transformation. This section, however, describes the
               information that is supplied when a transformation is initiated. Except where
               otherwise indicated, the information is <rfc2119>required</rfc2119>.</p>
            <p>The execution of a stylesheet necessarily involves two activities: static analysis
               and dynamic evaluation. Static analysis consists of those tasks that can be performed
               by inspection of the stylesheet alone, including the
                  binding of <termref def="dt-static-variable">static variables</termref>,
               the evaluation of <code>[xsl:]use-when</code> expressions (see <specref ref="conditional-inclusion"/>), and shadow attributes
                  (see <specref ref="shadow-attributes"/>) and detection of <termref def="dt-static-error">static errors</termref>. Dynamic evaluation consists of
               tasks which in general cannot be carried out until a source document is
               available.</p>
            <p>Dynamic evaluation is further divided into two activities:
                  <term>priming</term> the stylesheet, and <term>invoking</term> a selected
               component. </p>
            <ulist>
               <item>
                  <p>Priming the stylesheet provides the dynamic context for evaluation, and
                     supplies all the information needed to establish the values of global
                     variables.</p>
               </item>
               <item>
                  <p>Invoking a component (such as a template or function) causes evaluation of that
                     template or function to produce a result, which is an arbitrary XDM value.</p>
                  <p><termdef id="dt-raw-result" term="raw result">The result of invoking the
                        selected component, after any required conversion to the declared result
                        type of the component, is referred to as the <term>raw
                        result</term>.</termdef></p>
                  <p>The <termref def="dt-raw-result"/> of the invocation
                  is the <termref def="dt-immediate-result"/> of evaluating the <termref def="dt-sequence-constructor"/>
                  contained in the target template or function, modified by applying the <termref def="dt-coercion-rules"/>
                     to convert the <termref def="dt-immediate-result"/> to the type declared in the <code>as</code>
                  attribute of the <elcode>xsl:template</elcode> or <elcode>xsl:function</elcode> declaration, if present.</p>
                  <p>This raw result may optionally be post-processed to construct a result tree, to
                     serialize the result, or both, as described in <specref ref="post-processing"/>.</p>
               </item>
            </ulist>

            <p>Implementations <rfc2119>may</rfc2119> allow static analysis and dynamic evaluation
               to be initiated independently, so that the cost of static analysis can be amortized
               over multiple transformations using the same stylesheet. Implementations <rfc2119>may</rfc2119> also allow priming of a stylesheet and
                  invocation of components to be initiated independently, in which case a single act
                  of priming the stylesheet may be followed by a series of independent component
                  invocations. Although this specification does not require such a separation, this
                  section distinguishes information that is needed before static analysis can
                  proceed, information that is needed to prime the stylesheet, and information that
                  is needed when invoking components.</p>
            <p>The language is designed to allow the static analysis of each
                  <termref def="dt-package"/> to be performed independently of other packages, with
               only basic knowledge of the properties of components made available by used packages.
               Beyond this, the specification leaves it to implementations to decide how to organize
               this process. When packages are not used explicitly, the entire stylesheet is treated
               as a single package.</p>
            <div3 id="info-for-static-analysis">
               <head>Information needed for Static Analysis</head>
               <p>The following information is needed prior to static analysis
                     of a package:</p>
               <ulist>
                  <item>
                     <p>The location of the <termref def="dt-package-manifest"/>,
                        or in the absence of a package manifest, the <termref def="dt-stylesheet-module">stylesheet module</termref> that is to act as
                        the <termref def="dt-principal-stylesheet-module">principal stylesheet
                           module</termref>
                        of the <termref def="dt-package"/>. The complete <termref def="dt-package">package</termref> is
                        assembled by recursively expanding the <elcode>xsl:import</elcode> and
                           <elcode>xsl:include</elcode> declarations in the principal stylesheet
                        module, as described in <specref ref="include"/> and <specref ref="import"/>. </p>
                  </item>
                  <item>
                     <p>Information about the packages referenced from this
                        package using <elcode>xsl:use-package</elcode> declarations. The information
                        needed will include the names and signatures of public components exported
                        by the referenced package.</p>
                  </item>
                  <item>
                     <p>A set (possibly empty) of values for <termref def="dt-static-parameter">static parameters</termref> (see <specref ref="global-variables"/>). These values are available for use within
                           <termref def="dt-static-expression">static expressions</termref> (notably
                        in <code>[xsl:]use-when</code> expressions and shadow attributes) as well as
                        non-static expressions in the <termref def="dt-stylesheet">stylesheet</termref>. As a minimum, values <rfc2119>must</rfc2119> be
                        supplied for any static parameters declared with the attribute
                           <code>required="yes"</code>.</p>
                  </item>
               </ulist>
               <p>Conceptually, the output of the static analysis of a package is
                  an object which might be referred to (without constraining the implementation) as
                  a compiled package. Prior to dynamic evaluation, all the compiled packages needed
                  for execution must be checked for consistency, and component references must be
                  resolved. This process may be referred to, again without constraining the
                  implementation, as linking.</p>

            </div3>
            <div3 id="priming-stylesheet">
               <head>Priming a Stylesheet</head>


               <p>The information needed when priming a stylesheet is as
                  follows:</p>
               <ulist>
                  <item>
                     <p>A set (possibly empty) of values for non-static
                        <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> (see
                           <specref ref="global-variables"/>). These values are available for use
                        within <termref def="dt-expression">expressions</termref> in the <termref def="dt-stylesheet">stylesheet</termref>. As a minimum, values
                           <rfc2119>must</rfc2119> be supplied for any parameters declared with the
                        attribute <code>required="yes"</code>.</p>

                     <p>A supplied value is converted if necessary to the declared
                        type of the stylesheet parameter using the <termref def="dt-coercion-rules"/>.</p>

                     <note>
                        <p>Non-static stylesheet parameters are implicitly
                           <code>public</code>, which ensures that all the parameters in the
                           stylesheet for which values can be supplied externally have distinct
                           names. Static parameters, by contrast,
                              are local to a package.</p>
                     </note>
                  </item>
                  <item>
                     <p>
                        <termdef id="dt-global-context-item" term="global context item">An item that acts as the <term>global
                                 context item</term> for the transformation. This item acts
                           as the <termref def="dt-context-item"/> when evaluating
                            the <code>select</code> expression or <termref def="dt-sequence-constructor"/> of a
                                 <termref def="dt-global-variable"/> <phrase diff="chg" at="A">whose declaration is</phrase>
                           within the <termref def="dt-top-level-package"/>, as described in <specref ref="focus"/>. The global context item may also be available in a <termref def="dt-named-template"/>
                        when the stylesheet is invoked as described in <specref ref="invoking-initial-template"/></termdef>.
                        <phrase diff="add" at="A">[XSLT 3.0 Erratum E7, bug 30179].</phrase></p>

                     <note>
                        <p>In previous releases of this specification, a single node was typically
                           supplied to represent the source document for the transformation. This
                           node was used as the target node for the implicit call on
                              <elcode>xsl:apply-templates</elcode> used to start the transformation
                           process (now called the <termref def="dt-initial-match-selection"/>), and
                           the root node of the containing tree was used as the context item for
                           evaluation of global variables (now called the <termref def="dt-global-context-item"/>). This relationship between the
                              <termref def="dt-initial-match-selection"/> and the <termref def="dt-global-context-item"/> is likely to be found for compatibility
                           reasons in a transformation API designed to work with earlier versions of
                           this specification, but it is no longer a necessary relationship; the two
                           values can in principle be completely independent of each other.</p>
                        <p>Stylesheet authors wanting to write code that can be invoked using legacy
                           APIs should not rely on the caller being able to supply different values
                           for the <termref def="dt-initial-match-selection"/> and the <termref def="dt-global-context-item"/>.</p>
                     </note>
                     
                     <p>The value given to the <termref def="dt-global-context-item"/>
                        (and the values given to <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>)
                     cannot be nodes in a streamed document. This rule ensures that all global variables can freely
                     navigate within the relevant tree, with no constraints imposed by the streamability rules.</p>

                     

                     <p>The <termref def="dt-global-context-item"/> is potentially
                        used when initializing global variables and parameters. If the
                        initialization of any <termref def="dt-global-variable">global
                           variables</termref> or <termref def="dt-stylesheet-parameter">parameter</termref> depends on the context item, a dynamic error can
                        occur if the context item is absent. It is <termref def="dt-implementation-defined"/> whether this error occurs during
                        priming of the stylesheet or subsequently when the variable is referenced;
                        and it is <termref def="dt-implementation-defined"/> whether the error
                        occurs at all if the variable or parameter is never referenced. The error
                        can be suppressed by use of <elcode>xsl:try</elcode> and
                           <elcode>xsl:catch</elcode> within the sequence constructor used to initialize the variable or parameter. It
                           cannot be suppressed by use of <elcode>xsl:try</elcode> around a
                           reference to the global variable.
                     </p>

                     <imp-def-feature id="idf-api-globalcontext">If the initialization of any
                           <termref def="dt-global-variable">global variables</termref> or <termref def="dt-stylesheet-parameter">parameter</termref> depends on the context
                        item, a dynamic error can occur if the context item is absent. It is
                           <termref def="dt-implementation-defined"/> whether this error occurs
                        during priming of the stylesheet or subsequently when the variable is
                        referenced; and it is <termref def="dt-implementation-defined"/> whether the
                        error occurs at all if the variable or parameter is never referenced. </imp-def-feature>


                     
                     <p>In a <termref def="dt-library-package"/>,
                           the <termref def="dt-context-item">context item</termref>, <termref def="dt-context-position">context position</termref>, and <termref def="dt-context-size">context size</termref> used for evaluation of
                           global variables will be <termref def="dt-absent">absent</termref>, and
                           the evaluation of any expression that references these values will result
                           in a dynamic error. 
                        This will also be the case in the
                              <termref def="dt-top-level-package"/> if no <termref def="dt-global-context-item"/> is supplied.</p>
                     <note>
                        <p>If a context item is available within a global variable declaration, then
                           the <termref def="dt-context-position">context position</termref> and
                              <termref def="dt-context-size">context size</termref> will always be 1
                           (one).</p>
                     </note>
                     <note>
                        <p>For maximum reusability of code, it is best to avoid use of the context
                           item when initializing global variables and parameters. Instead, all
                           external information should be supplied using named <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>.
                           Especially when these use namespaces to avoid conflicts, there is then no
                           risk of confusion between the information supplied externally to
                           different packages.</p>
                        <p>When a stylesheet parameter is defined in a library package, it is
                           possible for a using package to supply a value for the parameter by
                           overriding the parameter declaration within an
                              <elcode>xsl:override</elcode> element. If the using package is the
                              <termref def="dt-top-level-package"/> then the overriding declaration
                           can refer to the <termref def="dt-global-context-item"/>.</p>
                     </note>

                  </item>
                  <item>
                     <p>A mechanism for obtaining a document node and a media type, given an
                        absolute URI. The total set of available documents (modeled as a mapping
                        from URIs to document nodes) forms part of the context for evaluating XPath
                        expressions, specifically the <xfunction>doc</xfunction> function. The XSLT
                           <function>document</function> function additionally requires the media
                        type of the resource representation, for use in interpreting any fragment
                        identifier present within a URI Reference.</p>
                     <note>
                        <p>The set of documents that are available to the stylesheet is <termref def="dt-implementation-dependent">implementation-dependent</termref>,
                           as is the processing that is carried out to construct a tree representing
                           the resource retrieved using a given URI. Some possible ways of
                           constructing a document (specifically, rules for constructing a document
                           from an Infoset or from a PSVI) are described in <bibref ref="xpath-datamodel-30"/>.</p>
                     </note>
                  </item>
               </ulist>
               <p>Once a stylesheet is primed, the values of global variables
                  remain stable through all component invocations. In addition, priming a stylesheet
                  creates an <xtermref spec="FO40" ref="execution-scope">execution scope</xtermref>
                  during which the dynamic context and all calls
                     on <xtermref spec="FO40" ref="dt-deterministic">deterministic</xtermref>
                     functions remain stable; for example two calls on the
                     <xfunction>current-dateTime</xfunction> function within an execution scope are
                  defined to return the same result.</p>

               <p>Parameters passed to the transformation by the client application when a stylesheet is primed are matched against
                     <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> (see
                     <specref ref="global-variables"/>), not against the <termref def="dt-template-parameter">template parameters</termref> of any template
                  executed during the course of the transformation. </p>

               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0050">
                     <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if a
                        stylesheet declares a visible <termref def="dt-stylesheet-parameter">stylesheet parameter</termref>
                        that is <termref def="dt-explicitly-mandatory">explicitly</termref> or <termref def="dt-implicitly-mandatory">implicitly</termref> mandatory,
                        and no value for this parameter is supplied when the stylesheet is primed. A
                        stylesheet parameter is visible if it is not masked by another global
                        variable or parameter with the same name and higher <termref def="dt-import-precedence">import precedence</termref>. If the parameter is a <termref def="dt-static-parameter"/> then the value <rfc2119>must</rfc2119> be
                           supplied prior to the static analysis phase.</p>
                  </error>
               </p>

               <imp-def-feature id="idf-api-input">The way in which an XSLT processor is invoked,
                  and the way in which values are supplied for the source document, starting node,
                     <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, and
                     <termref def="dt-base-output-uri">base output URI</termref>, are
                  implementation-defined.</imp-def-feature>


            </div3>
            <div3 id="invoking-initial-mode">
               <head>Apply-Templates Invocation</head>

               <p><termdef id="dt-initial-match-selection" term="initial match selection">A stylesheet may be evaluated by supplying a
                     value to be processed, together with an <termref def="dt-initial-mode"/>. The
                     value (which can be any sequence of items) is referred to as the <term>initial
                        match selection</term>. The processing then corresponds to the effect of the
                        <elcode>xsl:apply-templates</elcode> instruction.</termdef></p>

               <p>The <termref def="dt-initial-match-selection"/> will
                  often be a single document node, traditionally called the source document of the
                  transformation; but in general, it can be any sequence. If the initial match selection is an empty sequence, the result of the
                     transformation will be empty, since no template rules are
                  evaluated.</p>

               <p>Processing proceeds by finding the <termref def="dt-template-rule">template rules</termref> that match the items in the
                     <termref def="dt-initial-match-selection"/>, and evaluating these template
                  rules with a <termref def="dt-focus"/> based on the <termref def="dt-initial-match-selection"/>. The template rules are evaluated in
                     <termref def="dt-final-output-state"/>.</p>
               <p>The following information is needed when dynamic evaluation is
                  to start with a <termref def="dt-template-rule"/>:</p>

               <ulist>
                  <item>
                     <p>The <termref def="dt-initial-match-selection"/>.
                        An API that chooses to maintain compatibility with previous versions of this
                        specification <rfc2119>should</rfc2119> allow a method of invocation in which a singleton node is
                        provided, which is then used in two ways: the node itself acts as the
                           <termref def="dt-initial-match-selection"/>, and the root node of the
                        containing tree acts as the <termref def="dt-global-context-item"/>. </p>
                     
                  </item>
                  <item>
                     <p>Optionally, an initial <termref def="dt-mode">mode</termref>.</p>
                     
                     <p><termdef id="dt-initial-mode" term="initial mode">The <term>initial mode</term>
                        is the <termref def="dt-mode">mode</termref> used to select <termref def="dt-template-rule">template rules</termref>
                     for processing items in the <termref def="dt-initial-match-selection"/> when
                     apply-templates invocation is used to initiate a transformation.</termdef></p>
                     
                     
                     <p><!--<termdef id="dt-initial-mode" term="initial mode">The initial mode, if
                           specified, <rfc2119>must</rfc2119> either be the <phrase diff="chg"
                              at="R">unnamed</phrase> mode, or a mode that is explicitly named
                              <phrase diff="add" at="P-bug23343">either in an
                                 <elcode>xsl:mode</elcode> declaration, or</phrase> in the
                              <code>mode</code> attribute of an <elcode>xsl:template</elcode>
                           declaration within the stylesheet<phrase diff="add" at="S-bug28453">, or
                              in the <code>default-mode</code> attribute of an
                                 <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode>
                              element</phrase>. -->In searching
                           for the <termref def="dt-template-rule">template rule</termref> that best
                           matches the items in the <termref def="dt-initial-match-selection"/>, the processor
                           considers only those rules that apply to the <termref def="dt-initial-mode"/>.</p>
                     <p>If no <termref def="dt-initial-mode"/> is supplied explicitly, then the initial mode is that named in the
                              <code>default-mode</code> attribute of the (explicit or implicit) <elcode>xsl:package</elcode>
                              element of the <termref def="dt-top-level-package"/> or in
                           the absence of such an attribute, the <termref def="dt-unnamed-mode"/>.</p>
                     
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0044">
                           <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the
                              invocation of the <termref def="dt-stylesheet">stylesheet</termref>
                              specifies an <termref def="dt-initial-mode"/> when no <termref def="dt-initial-match-selection"/> is
                                 supplied (either explicitly, or defaulted to the <termref def="dt-global-context-item"/>).</p>
                        </error>
                     </p>
                     
                     <p>A (named or unnamed) <termref def="dt-mode"/> <var>M</var> is <term>eligible as an initial mode</term> if one of the
                        following conditions applies, where <var>P</var> is the <termref def="dt-top-level-package"/> of the stylesheet:</p>
                     <olist>

                        <item><p><var>M</var> is explicitly declared in an <elcode>xsl:mode</elcode> declaration
                           within <var>P</var>, and has <code>public</code> or <code>final</code> <termref def="dt-visibility"/> (either by virtue
                           of its <code>visibility</code> attribute, or by virtue of an <elcode>xsl:expose</elcode> declaration).</p></item>
                        <item><p><var>M</var> is the unnamed mode.</p></item>
                        <item><p><var>M</var> is named in the <code>default-mode</code> attribute of the (explicit or implicit) 
                           <elcode>xsl:package</elcode> element of <var>P</var>.</p></item>
                        <item><p><var>M</var> is declared in a package used by <var>P</var>, and is given <code>public</code> or <code>final</code>
                           <termref def="dt-visibility"/> in <var>P</var> by means of an <elcode>xsl:accept</elcode> declaration.</p></item>
                        <item><p>The effective value of the <code>declared-modes</code> attribute of the explicit or implicit
                        <elcode>xsl:package</elcode> element of <var>P</var> is <code>no</code>, and <var>M</var> appears as 
                        a mode-name in the <code>mode</code> attribute of a <termref def="dt-template-rule"/> declared within <var>P</var>.</p></item>
                     </olist>
                                                           
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0045">
                           <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the
                              invocation of the <termref def="dt-stylesheet">stylesheet</termref>
                              specifies an <termref def="dt-initial-mode"/> and the
                              specified mode is not eligible as an initial mode (as defined above).</p>
                        </error>
                     </p>
                     
                  </item>
                  
                  <item>
                     <p>Parameters, which will be passed to the template rules
                        used to process items in the input sequence. The parameters consist of two
                        sets of (QName, value) pairs, one set for <termref def="dt-tunnel-parameter">tunnel parameters</termref> and one for non-tunnel parameters, in which
                        the QName identifies the name of a parameter and the value provides the
                        value of the parameter. Either or both sets of parameters may be empty. The
                        effect is the same as when a template is invoked using
                           <elcode>xsl:apply-templates</elcode> with an
                           <elcode>xsl:with-param</elcode> child specifying
                           <code>tunnel="yes"</code> or <code>tunnel="no"</code> as appropriate. If
                        a parameter is supplied that is not declared or used, the value is simply
                        ignored. These parameters are <emph>not</emph> used to set <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>.</p>

                     <p>A supplied value is converted if necessary to the declared
                        type of the template parameter using the <termref def="dt-coercion-rules"/>.</p>
                  </item>
                  <item>
                     <p>Details of how the result of the initial template is to be returned.
                     For details, see <specref ref="post-processing"/></p>
                  </item>
               </ulist>

               <p>The <termref def="dt-raw-result"/> of the invocation is the
                  result of processing the supplied input sequence as if by a call on
                     <elcode>xsl:apply-templates</elcode> in the specified mode: specifically, each
                  item in the input sequence is processed by selecting and evaluating the best
                  matching template rule, and converting the result (if necessary) to the type
                  declared in the <code>as</code> attribute of that template using the <termref def="dt-coercion-rules"/>; and the results of processing each item
                  are then concatenated into a single sequence, respecting the order of items in the
                  input sequence.</p>

               <note>
                  
                  <p>If the initial mode is <termref def="dt-declared-streamable"/>,
                     then a streaming processor <rfc2119>should</rfc2119> allow some or all of the items
                     in the <termref def="dt-initial-match-selection"/> to be nodes supplied in streamable form,
                     and any nodes that are supplied in this form <rfc2119>must</rfc2119> then be processed using streaming.</p>
                  
                  <p>Since the <termref def="dt-global-context-item"/> cannot be a streamed node,
                  in cases where the transformation is to proceed by applying streamable templates
                  to a streamed input document, the <termref def="dt-global-context-item"/> must
                  either be absent, or must be something that differs from the <termref def="dt-initial-match-selection"/>.</p>
               </note>
               <note>
                  <p>The design of the API for invoking a transformation should provide some means
                     for users to designate the <termref def="dt-unnamed-mode"/> as the <termref def="dt-initial-mode"/> in cases where it is not the default mode.</p>
               </note>

               
              <!-- 
               <note diff="add" at="T-bug29234">
                  <p>Or to put it another way: (a) if a named initial mode is specified, then
                  it must exist as a public mode in the top-level package, declared implicitly or explicitly; 
                  (b) if the unnamed initial mode is specified and <code>declared-modes="yes"</code>, then there
                  must be an <elcode>xsl:mode</elcode> declaration for the unnamed mode.</p>
               </note>-->

               <p>It is a <termref def="dt-dynamic-error"/>
                  <errorref spec="XT" type="dynamic" class="DE" code="0700"/> if the <termref def="dt-template-rule"/> selected for processing any item in the <termref def="dt-initial-match-selection"/> defines a <termref def="dt-template-parameter"/> that specifies <code>required="yes"</code>
                  and no value is supplied for that
                  parameter.</p>

               <note>
                  <p>A <termref def="dt-stylesheet">stylesheet</termref> can process further source
                     documents in addition to those supplied when the transformation is invoked.
                     These additional documents can be loaded using the functions
                        <function>document</function> (see <specref ref="func-document"/>) or
                        <xfunction>doc</xfunction> or <xfunction>collection</xfunction> (see <bibref ref="xpath-functions-40"/>), or using the
                           <elcode>xsl:source-document</elcode> instruction; alternatively, they can
                     be supplied as <termref def="dt-stylesheet-parameter">stylesheet
                        parameters</termref> (see <specref ref="global-variables"/>), or returned as
                     the result of an <termref def="dt-extension-function">extension
                        function</termref> (see <specref ref="extension-functions"/>).</p>
               </note>




            </div3>
            <div3 id="invoking-initial-template">
               <head>Call-Template Invocation</head>


               <p><termdef id="dt-initial-named-template" term="initial named template">A stylesheet may be evaluated by selecting a
                     named template to be evaluated; this is referred to as the <term>initial named
                        template</term>.</termdef> The effect is analogous to the effect of
                  executing an <elcode>xsl:call-template</elcode> instruction. The following
                  information is needed in this case:</p>

               <ulist>
                  <item>
                     <p>Optionally, the name of the <termref def="dt-initial-named-template">initial
                           named template</termref> which is to be executed as the entry point to
                        the transformation. If no template name is
                           supplied, the default template name is
                           <code>xsl:initial-template</code>. The selected template
                           <rfc2119>must</rfc2119> exist within the <termref def="dt-stylesheet">stylesheet</termref>. </p>
                  </item>

                  <item>
                     <p>Optionally, a context item for evaluation of this named
                        template, defaulting to the <termref def="dt-global-context-item"/> if it
                        exists. This is constrained by any
                              <elcode>xsl:context-item</elcode> element appearing within the
                           selected <elcode>xsl:template</elcode> element. The initial named
                           template is evaluated with a <termref def="dt-singleton-focus"/> based on
                           this context item if it exists, or with an <termref def="dt-absent"/>
                           focus otherwise.</p>
                  </item>

                  <item>
                     <p>Parameters, which will be passed to the selected template
                        rule. The parameters consist of two sets of (QName, value) pairs, one set
                        for <termref def="dt-tunnel-parameter">tunnel parameters</termref> and one
                        for non-tunnel parameters, in which the QName identifies the name of a
                        parameter and the value provides the value of the parameter. Either or both
                        sets of parameters may be empty. The effect is the same as when a template
                        is invoked using <elcode>xsl:call-template</elcode> with an
                           <elcode>xsl:with-param</elcode> child specifying
                           <code>tunnel="yes"</code> or <code>tunnel="no"</code> as appropriate. If
                        a parameter is supplied that is not declared or used, the value is simply
                        ignored. These parameters are <emph>not</emph> used to set <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>.</p>

                     <p>A supplied value is converted if necessary to the declared
                        type of the template parameter using the <termref def="dt-coercion-rules"/>.</p>
                  </item>

                  <item>
                     <p>Details of how the result of the initial named template is to be returned.
                        For details, see <specref ref="post-processing"/></p>
                  </item>

               </ulist>

               <p>The <termref def="dt-raw-result"/> of the invocation is the
                  result of evaluating the <termref def="dt-initial-named-template"/>, after
                  conversion of the result to the type declared in the <code>as</code> attribute of
                  that template using the <termref def="dt-coercion-rules"/>, if such
                  conversion is necessary.</p>

               <p>The <termref def="dt-initial-named-template"/> is
                  evaluated in <termref def="dt-final-output-state"/>.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0040">
                     <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the invocation of
                        the <termref def="dt-stylesheet">stylesheet</termref> specifies a template
                        name that does not match the <termref def="dt-expanded-qname">expanded
                           QName</termref> of a named template defined in the <termref def="dt-stylesheet">stylesheet</termref>, whose
                           visibility is <code>public</code> or <code>final</code>.</p>
                  </error>
               </p>
               
               <note diff="add" at="A">
                  <p>When the top-level package is rooted at an <elcode>xsl:stylesheet</elcode> or 
                     <elcode>xsl:transform</elcode> element, named templates having no explicit 
                     <code>visibility</code> attribute are automatically exposed as public components. 
                     (This is a consequence of the transformation applied to a package written using 
                     "simplified syntax", described in <specref ref="packages"/>.) [XSLT 3.0 Erratum E8, bug 30181].</p>
               </note>

               

               


               <p> It is a <termref def="dt-dynamic-error"> dynamic error</termref>
                  <errorref spec="XT" type="dynamic" class="DE" code="0700"/> if the <termref def="dt-initial-named-template">initial named template</termref>, or any of the template rules invoked to
                  process items in the <termref def="dt-initial-match-selection"/>, defines a
                     <termref def="dt-template-parameter">template parameter</termref> that
                  specifies <code>required="yes"</code>
                  and no value is supplied for that parameter.
               </p>




            </div3>
            <div3 id="invoking-initial-function">
               <head>Function Call Invocation</head>

               <p><termdef id="dt-initial-function" term="initial function">A stylesheet may be evaluated by calling a named
                        <termref def="dt-stylesheet-function"/>, referred to as the <term>initial
                        function</term>.</termdef> The following additional information is needed in
                  this case:</p>

               <ulist>
                  <item>
                     <p>The name and arity of a <termref def="dt-stylesheet-function"/> which is to
                        be executed as the entry point to the transformation.</p>
                     <note>
                        <p>In the design of a concrete API, the arity may be inferred from the
                           length of the parameter list.</p>
                     </note>
                  </item>

                  <item>
                     <p>A list of values to act as parameters to the <termref def="dt-initial-function"/>. The number of values in the list must be the
                        same as the arity of the function.</p>

                     <p>A supplied value is converted if necessary to the declared
                        type of the function parameter using the <termref def="dt-coercion-rules"/>.</p>
                  </item>

                  <item>
                     <p>Details of how the result of the initial function is to be returned.
                        For details, see <specref ref="post-processing"/></p>
                  </item>

               </ulist>

               <p>The <termref def="dt-raw-result"/> of the invocation is the
                  result of evaluating the <termref def="dt-initial-function"/>, after conversion of
                  the result to the type declared in the <code>as</code> attribute of that function
                  using the <termref def="dt-coercion-rules"/>, if such conversion is
                  necessary.</p>

               <note>
                  <p> The <termref def="dt-initial-function"/> (like all stylesheet functions) is
                     evaluated with an <termref def="dt-absent"/>
                     <termref def="dt-focus"/>.</p>
               </note>
               
               <p>If the <termref def="dt-initial-function"/> is 
                  <termref def="dt-declared-streamable"/>, a streaming processor <rfc2119>should</rfc2119> 
                  allow the value of the first argument to be supplied in streamable form, and if it is 
                  supplied in this form, then it <rfc2119>must</rfc2119> be processed using streaming.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0041">
                     <p>It is a <termref def="dt-dynamic-error"/> if the invocation of the <termref def="dt-stylesheet">stylesheet</termref> specifies a function name and
                        arity that does not match the <termref def="dt-expanded-qname">expanded
                           QName</termref> and arity of a named <termref def="dt-stylesheet-function"/> defined in the <termref def="dt-stylesheet">stylesheet</termref>, whose visibility is
                           <code>public</code> or <code>final</code>.</p>
                  </error>
               </p>

               


               <p>When a transformation is invoked by calling an <termref def="dt-initial-function"/>, the entire transformation executes in <termref def="dt-temporary-output-state"/>, which means that calls on
                     <elcode>xsl:result-document</elcode> are not permitted.</p>

            </div3>
            <div3 id="post-processing">
               <head>Post-processing the Raw Result</head>
               
               <p>There are three ways the result of a transformation
               may be delivered. (This applies both to the principal result, described here, and
               also to secondary results, generated using <elcode>xsl:result-document</elcode>.)</p>
               
               <olist>
                  <item><p>The <termref def="dt-raw-result"/> (a sequence of values) may be returned
                  directly to the calling application.</p></item>
                  <item><p>A result tree may be constructed from the <termref def="dt-raw-result"/>.
                     By default, a result tree is constructed if the <code>build-tree</code>
                     attribute of the unnamed <termref def="dt-output-definition"/>
                     has the effective value <code>yes</code>. An API for invoking transformations <rfc2119>may</rfc2119>
                     allow this setting to be overridden by the calling application. If result tree construction
                     is requested, it is performed as described in <specref ref="result-tree-construction"/>.
                   </p></item>
                  <item><p>Alternatively, the <termref def="dt-raw-result"/> may be serialized
                  as described in <specref ref="result-serialization"/>. The decision whether or not to
                  serialize the result is determined by the rules of transformation API provided by the
                  <termref def="dt-processor"/>, and is not influenced by anything in the stylesheet.</p></item>
               </olist>
               
               <note>
                  <p>This specification does not constrain the design of application programming
                     interfaces or the choice of defaults. In previous versions of this
                     specification, result tree construction was a mandatory process, while
                     serialization was optional. When invoking stylesheet functions directly,
                     however, result tree construction and serialization may be inappropriate as
                     defaults. These considerations may affect the design of APIs.</p>
                  <p>In previous versions of XSLT, results were delivered either
                  in serialized form (as a character or byte stream), or as a tree. In the latter case processors
                  typically would use either their own tree representation, or a standardized tree
                  representation such as the W3C Document Object Model (DOM) (see <bibref ref="DOM-Level-2-Core"/>),
                     adapted to the data structures offered by the programming language in which the API is defined.
                  To deliver a raw result, processors need to define a representation not only of XDM nodes but
                  also of sequences, atomic values, maps and even functions. As with the return of a simple tree, 
                  this may involve a trade-off between strict fidelity to the XDM data model and usability in the particular 
                  programming language environment. It is <emph>not</emph> a requirement that an API should return results 
                     in a way that exposes every property of the XDM data model; for example there may be APIs that do not expose
                  the precise type annotation of a returned node or atomic value, or that fail to expose the base URI
                  or document URI of a node, or that provide no way of determining whether two nodes in the result
                  sequence are the same node in the sense of the XPath <code>is</code> operator.
                     The way in which maps, arrays, and functions 
                  are returned requires careful design choices. It is <rfc2119>recommended</rfc2119> that an API should be capable
                  of returning any XDM value without error, and that there should be minimal loss of information if
                  the raw results output by one transformation are subsequently used as input to another transformation.</p>
               </note>
 
 <div4 id="result-tree-construction">
    <head>Result Tree Construction</head>
    
    <p>If a result tree is to be constructed from the <termref def="dt-raw-result"/>, then this is done
    by applying the rules for the process of <xtermref spec="SER30" ref="sequence-normalization"/> as defined in 
       <bibref ref="xslt-xquery-serialization-30"/>. This process takes as input the serialization parameters defined in the
    unnamed <termref def="dt-output-definition"/> of the <termref def="dt-top-level-package"/>; though the only parameter
    that is actually used by this process is <code>item-separator</code>. <phrase diff="del" at="A">In particular, sequence normalization is carried
       out regardless of any <code>method</code> attribute in the unnamed <termref def="dt-output-definition"/>.</phrase>
    <phrase diff="add" at="A">[XSLT 3.0 Erratum E14, bug 30208].</phrase></p>
    
    <p>The sequence normalization process either returns a document node, or raises
    a serialization error. The content of the document node is not necessarily well-formed (the document node may have any number
    of element or text nodes among its children).</p>
    
    <note><p>More specifically, the process raises a serialization error if any item in the <termref def="dt-raw-result"/> is
    an attribute node, a namespace node, or a function (including a map, but not an array: arrays are flattened).</p></note>
    
    <p>The tree that is constructed is referred to as a <termref def="dt-final-result-tree">final result tree</termref>.</p>
    
    <p>If the <termref def="dt-raw-result"/> is an empty sequence, the <termref def="dt-final-result-tree"/> will consist
    of a document node with no children.</p>
    
    <p>The base URI of the document node is set to the <termref def="dt-base-output-uri"/>.</p>
    
    <note>
       <p>The <code>item-separator</code> property has no effect if the raw result of the transformation is a sequence
       of length zero or one, which in practice will often be the case, especially in a traditional scenario such as
       transformation of an XML document to HTML.</p>
       <p>If there is no <code>item-separator</code>, then a single space is inserted between adjacent atomic values;
       for example if the raw result is the sequence <code>1 to 5</code>, then sequence normalization produces a tree
       comprising a document node with a single child, the child being a text node with the string value 
       <code>1 2 3 4 5</code>.</p>
       <p>If there is an <code>item-separator</code>, then it is used not only between adjacent atomic values,
       but between any pair of items in the raw result. For example if the raw result is a sequence of two
       element nodes <code>A</code> and <code>B</code>, and the <code>item-separator</code> is a comma,
       then the result of sequence normalization will be a document node with three children: a copy of <code>A</code>,
       a text node whose string value is a single comma, and a copy of <code>B</code>.</p>
    </note>
 
              <!--       <p>If the raw result is non-empty, then it is used to construct an implicit
                           <termref def="dt-final-result-tree">final result tree</termref>,
                        following the rules described in <specref ref="constructing-complex-content"
                        />: the effect is as if the raw result <var>R</var> were processed by the
                        following function:</p>
                     <eg xml:space="preserve" role="xslt-declaration xmlns:f='f'"><![CDATA[
<xsl:function name="f:construct-result-tree" as="document-node()">
  <xsl:param name="R" as="item()*"/>
  <xsl:document validation="preserve">
    <xsl:sequence select="$R"/>
  </xsl:document>  
</xsl:function>]]></eg>
                     <p>An implicit result tree is also created when the raw result is empty,
                        provided that no <elcode>xsl:result-document</elcode> instruction has been
                        evaluated during the course of the transformation <phrase diff="add"
                           at="R-bug24690">(which will always be the case if the stylesheet is
                           invoked by calling an initial function)</phrase>. In this situation the
                        implicit result tree will consist of a document node with no children.</p>
                     <note>
                        <p diff="chg" at="Q">This means that there is always at least one result
                           tree. It also means that <phrase diff="add" at="R-bug24690">when
                              stylesheet invocation is by supplying an <termref
                                 def="dt-initial-mode"/> (see <specref ref="invoking-initial-mode"
                              />) or a named template (see <specref ref="invoking-initial-template"
                              />), and</phrase> the content of the <termref
                              def="dt-initial-named-template"/> is a single
                              <elcode>xsl:result-document</elcode> instruction, as in the example
                              <phrase diff="chg" at="R-bug24690">template with
                                 <code>name="IMPLICIT"</code> shown in <specref
                                 ref="executing-a-transformation"/></phrase>, then only one result
                           tree is produced, not two. It is useful to make the result document
                           explicit as this is a convenient way of invoking document-level
                           validation. (Validation of the implicit result document can also be
                           achieved by adding an <elcode>xsl:document</elcode> instruction to the
                           initial template.) </p>
                        <p>If the result of the <termref def="dt-initial-named-template"/> is
                           non-empty, and an explicit <elcode>xsl:result-document</elcode>
                           instruction has been evaluated with the empty attribute
                              <code>href=""</code>, then an error will occur <errorref spec="XT"
                              class="DE" code="1490"/>, since it is not possible to create two final
                           result trees with the same URI.</p>
                     </note>
                     -->
 </div4>
               <div4 id="result-serialization">
                     <head>Serializing the Result</head>
                     <p>See <specref ref="parsing-and-serialization"/>.</p>
                     <p>The <termref def="dt-raw-result"/>
                        may optionally be serialized as described in <specref ref="serialization"/>. The serialization is controlled by the serialization
                     parameters defined in the unnamed <termref def="dt-output-definition"/> of the
                     <termref def="dt-top-level-package"/>.</p>
                  
                  <note>
                     <p>The first phase of serialization, called <xtermref spec="SER30" ref="sequence-normalization"/>,
                     takes place for some output methods but not others. For example, if the <code>json</code> output method
                        (defined in <bibref ref="xslt-xquery-serialization-31"/>) is selected, then the process of constructing
                     a tree is bypassed.</p>
                  </note>
                  
                  <p>The effect of serialization is to generate a sequence of octets, representing the serialized result
                     in some character encoding. The processor’s API may define mechanisms enabling this sequence of octets
                  to be written to persistent storage at some location. The default location is the location identified
                  by the <termref def="dt-base-output-uri"/>.</p>
                  
                     

                  <p>In previous versions of this specification it was stated that
                  when the <termref def="dt-raw-result"/> of the initial template or function is an empty sequence,
                  a result tree should be produced if and only if the transformation generates no secondary results
                  (that is, if it does not invoke <elcode>xsl:result-document</elcode>). This provision is most likely
                  to have a noticeable effect if the transformation produces serialized results, and these results
                  are written to persistent storage: the effect is then that a transformation producing an empty
                  principal result will overwrite any existing content at the base output URI location if and only
                  if the transformation produces no other output. Processor APIs offering backwards compatibility
                  with earlier versions of XSLT must respect this behavior, but there is no requirement for new
                  processor APIs to do so.</p>

               <p><termdef id="dt-base-output-uri" term="base output URI"> The <term>base output URI</term> is a URI to be used as the base URI when
                     resolving a relative URI reference allocated
                     to a <termref def="dt-final-result-tree">final result tree</termref>. If the
                     transformation generates more than one final result tree, then typically each
                     one will be allocated a URI relative to this base URI.</termdef> The way in
                  which a base output URI is established is <termref def="dt-implementation-defined">implementation-defined</termref>. Each invocation of the stylesheet may supply
                  a different base output URI. It is acceptable for the base output URI to be
                     <termref def="dt-absent"/>, provided no constructs (such as
                     <elcode>xsl:result-document</elcode>) are evaluated that depend on the value of
                  the base output URI.</p>
               <note>
                  <p>It will often be convenient for the base output URI to be the same as the
                     location to which the principal result document is serialized, but this
                     relationship is not a necessary one.</p>
               </note>

               <imp-def-feature id="idf-api-baseoutputuri">The way in which a <termref def="dt-base-output-uri"/> is established is <termref def="dt-implementation-defined">implementation-defined</termref></imp-def-feature>

 
               </div4>
            </div3>

         </div2>
         
         <div2 id="executing-a-transformation">
            <head>Instructions</head>
            
            <p>The main executable components of a stylesheet are templates and functions. The body of
            a template or function is a <termref def="dt-sequence-constructor"/>, which is a sequence of elements
            and text nodes that can be evaluated to produce a result.</p>
            
            
            <p>A <termref def="dt-sequence-constructor"/> is a sequence of sibling nodes in the
               stylesheet, each of which is either an <termref def="dt-xslt-instruction">XSLT
                  instruction</termref>, a <termref def="dt-literal-result-element">literal result
                     element</termref>, a text node, or an <termref def="dt-extension-instruction">extension instruction</termref>.</p>
            <p>
               <termdef id="dt-instruction" term="instruction">An <term>instruction</term> is either
                  an <termref def="dt-xslt-instruction">XSLT instruction</termref> or an <termref def="dt-extension-instruction">extension instruction</termref>.</termdef>
            </p>
            <p>
               <termdef id="dt-xslt-instruction" term="XSLT instruction">An <term>XSLT
                  instruction</term> is an <termref def="dt-xslt-element">XSLT element</termref>
                  whose syntax summary in this specification contains the annotation <code>&lt;!--
                     category: instruction --&gt;</code>.</termdef>
            </p>
            <p>
               <termref def="dt-extension-instruction">Extension instructions</termref> are
               described in <specref ref="extension-instruction"/>.</p>
            <p>The main categories of <termref def="dt-xslt-instruction">XSLT instruction</termref>
               are as follows:</p>
            <ulist>
               <item>
                  <p>instructions that create new nodes: <elcode>xsl:document</elcode>,
                     <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                     <elcode>xsl:processing-instruction</elcode>, <elcode>xsl:comment</elcode>,
                     <elcode>xsl:value-of</elcode>, <elcode>xsl:text</elcode>,
                     <elcode>xsl:namespace</elcode>;</p>
               </item>
               <item>
                  <p>instructions that copy nodes: <elcode>xsl:copy</elcode>,
                     <elcode>xsl:copy-of</elcode>;</p>
               </item>
               <item>
                  <p>an instruction that returns an arbitrary sequence by evaluating an XPath
                     expression: <elcode>xsl:sequence</elcode>;</p>
               </item>
               <item>
                  <p>instructions that cause conditional or repeated evaluation of nested
                     instructions: <elcode>xsl:if</elcode>, <elcode>xsl:choose</elcode>, <elcode>xsl:try</elcode>,
                     <elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>, <elcode>xsl:fork</elcode>, <elcode>xsl:iterate</elcode>
                        and its subordinate instructions <elcode>xsl:next-iteration</elcode> and
                        <elcode>xsl:break</elcode>;</p>
               </item>
               <item>
                  <p>instructions that generate output conditionally if elements are or are not
                     empty: <elcode>xsl:on-empty</elcode>, <elcode>xsl:on-non-empty</elcode>,
                     <elcode>xsl:where-populated</elcode>;</p>
               </item>
               <item>
                  <p>instructions that invoke templates: <elcode>xsl:apply-templates</elcode>,
                     <elcode>xsl:apply-imports</elcode>, <elcode>xsl:call-template</elcode>,
                     <elcode>xsl:next-match</elcode>;</p>
               </item>
               <item>
                  <p>Instructions that declare variables: <elcode>xsl:variable</elcode>;</p>
               </item>
               <item>
                  <p>Instructions to assist debugging: <elcode>xsl:message</elcode>,
                     <elcode>xsl:assert</elcode>;</p>
               </item>
               <item>
                  <p>other specialized instructions: <elcode>xsl:number</elcode>,
                     <elcode>xsl:analyze-string</elcode>, <elcode>xsl:fork</elcode>, 
                     <elcode>xsl:result-document</elcode>, <elcode>xsl:source-document</elcode>, <elcode>xsl:perform-sort</elcode>,
                        <elcode>xsl:merge</elcode>.</p>
               </item>
            </ulist>
         </div2>
         <div2 id="rule-based-processing">
            <head>Rule-Based Processing</head>
            
            
            <p>The classic method of executing an XSLT transformation is to apply
               template rules to the root node of an input document (see <specref ref="invoking-initial-mode"/>).
               The operation of applying templates to a node searches the stylesheet for the best matching template
               rule for that node. This template rule is then evaluated. A common coding pattern, especially when XSLT
               is used to convert XML documents into display formats such as HTML, is to have one template rule 
               for each kind of element in the source document, and for that template rule to generate some 
               appropriate markup elements, and to apply templates recursively to its own children. The effect is to 
               perform a recursive traversal of the source tree, in which each node is processed using the best-fit 
               template rule for that node. The final result of the transformation is then the tree produced by this 
               recursive process. This result can then be optionally serialized (see <specref ref="post-processing"/>). 
            </p>
            <example id="rule-based-processing-example">
               <head>Example of Rule-Based Processing</head>
               <p>This example uses rule-based processing to convert a simple XML input document into an HTML
               output document.</p>
               <p>The input document takes the form:</p>
               <eg role="xml" xml:space="preserve">

  &lt;PERSONAE PLAY="OTHELLO"&gt;
    &lt;TITLE&gt;Dramatis Personae&lt;/TITLE&gt;
    &lt;PERSONA&gt;DUKE OF VENICE&lt;/PERSONA&gt;
    &lt;PERSONA&gt;BRABANTIO, a senator.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;Other Senators.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;GRATIANO, brother to Brabantio.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;LODOVICO, kinsman to Brabantio.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;OTHELLO, a noble Moor in the service of the Venetian state.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;CASSIO, his lieutenant.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;IAGO, his ancient.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;RODERIGO, a Venetian gentleman.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;MONTANO, Othello's predecessor in the government of Cyprus.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;Clown, servant to Othello. &lt;/PERSONA&gt;
    &lt;PERSONA&gt;DESDEMONA, daughter to Brabantio and wife to Othello.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;EMILIA, wife to Iago.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;BIANCA, mistress to Cassio.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;Sailor, Messenger, Herald, Officers, 
             Gentlemen, Musicians, and Attendants.&lt;/PERSONA&gt;
  &lt;/PERSONAE&gt;</eg>
               
               <p>The stylesheet to render this as HTML can be written as a set of template rules:</p>
               
               <eg role="xslt" xml:space="preserve">
 &lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    version="3.0"
    expand-text="yes"&gt;
    
 &lt;xsl:strip-space elements="PERSONAE"/&gt;   
    
 &lt;xsl:template match="PERSONAE"&gt;
   &lt;html&gt;
     &lt;head&gt;
       &lt;title&gt;The Cast of {@PLAY}&lt;/title&gt;
     &lt;/head&gt;
     &lt;body&gt;
       &lt;xsl:apply-templates/&gt;
     &lt;/body&gt;
   &lt;/html&gt;
 &lt;/xsl:template&gt;
 
 &lt;xsl:template match="TITLE"&gt;
   &lt;h1&gt;{.}&lt;/h1&gt;
 &lt;/xsl:template&gt;
 
 &lt;xsl:template match="PERSONA[count(tokenize(., ',') = 2]"&gt;
   &lt;p&gt;&lt;b&gt;{substring-before(., ',')}&lt;/b&gt;: {substring-after(., ',')}&lt;/p&gt;
 &lt;/xsl:template&gt; 

 &lt;xsl:template match="PERSONA"&gt;
   &lt;p&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/p&gt;
 &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
               
               <p>There are four template rules here:</p>
               <ulist>
                  <item><p>The first rule matches the outermost element, named <code>PERSONAE</code> (it could equally
                  have used <code>match="/"</code> to match the document node). The effect of this rule is to create
                  the skeleton of the output HTML page. Technically, the body of the template is a sequence constructor
                  comprising a single <termref def="dt-literal-result-element"/> (the <code>html</code> element); this
                  in turn contains a sequence constructor comprising two literal result elements (the <code>head</code>
                  and <code>body</code> elements). The <code>head</code> element is populated with a literal <code>title</code>
                     element whose content is computed as a mixture of fixed and variable text using a <termref def="dt-text-value-template"/>. 
                     The <code>body</code> element is populated by evaluating an <elcode>xsl:apply-templates</elcode>
                  instruction.</p>
                     <p>The effect of the <elcode>xsl:apply-templates</elcode> instruction is to process the children of
                     the <code>PERSONAE</code> element in the source tree: that is, the <code>TITLE</code> and
                     <code>PERSONA</code> elements. (It would also process any whitespace text node children, but these
                     have been stripped by virtue of the <elcode>xsl:strip-space</elcode> declaration.) Each of these
                     child elements is processed by the best matching template rule for that element, which will be one 
                     of the other three rules in the stylesheet.</p></item>
                  <item><p>The template rule for the <code>TITLE</code> element outputs an <code>h1</code> element
                  to the HTML result document, and populates this with the value of ".", the context item. That is,
                  it copies the text content of the <code>TITLE</code> element to the output <code>h1</code> element.</p></item>
                  <item><p>The last two rules match <code>PERSONA</code> element. The first rule matches <code>PERSONA</code>
                  elements whose text content contains exactly one comma; the second rule matches all <code>PERSONA</code> elements,
                     but it has lower priority than the first rule, so in practice it only applies to <code>PERSONA</code>
                  elements that contain no comma or multiple commas.</p>
                  <p>For both rules the body of the rule is a sequence constructor containing a single literal result element,
                  the <code>p</code> element. These literal result elements contain
                  further sequence constructors comprising literal result elements and text nodes. 
                  In each of these examples the text nodes are in the form of a <termref def="dt-text-value-template"/>:
                  in general this is a combination of fixed text together with XPath expressions enclosed in curly braces, which 
                  are evaluated to form the content of the containing literal result element. </p></item>
               </ulist>
               
            </example>
            <p>
               <termdef id="dt-template-rule" term="template rule">A stylesheet contains a set of
                  <term>template rules</term> (see <specref ref="rules"/>). A template rule has
                  three parts: a <termref def="dt-pattern">pattern</termref> that is matched against
                  selected items (often but not necessarily nodes), a (possibly empty) set of <termref def="dt-template-parameter">template
                     parameters</termref>, and a <termref def="dt-sequence-constructor">sequence
                        constructor</termref> that is evaluated to produce a sequence of
                  items.</termdef> In many cases these items are newly constructed nodes, which are
               then written to a <termref def="dt-result-tree">result tree</termref>.</p>
            
            
         </div2>

         
         <div2 id="context">
            <head>The Evaluation Context</head>
            <p>The results of some expressions and instructions in a stylesheet may depend on
               information provided contextually. This context information is divided into two
               categories: the static context, which is known during static analysis of the
               stylesheet, and the dynamic context, which is not known until the stylesheet is
               evaluated. Although information in the static context is known at analysis time, it
               is sometimes used during stylesheet evaluation.</p>
            <p>Some context information can be set by means of declarations within the stylesheet
               itself. For example, the namespace bindings used for any XPath expression are
               determined by the namespace declarations present in containing elements in the
               stylesheet. Other information may be supplied externally or implicitly: an example is
               the current date and time.</p>
            <p>The context information used in processing an XSLT stylesheet includes as a subset
               all the context information required when evaluating XPath expressions. The XPath 3.0 specification defines a static and dynamic
               context that the host language (in this case, XSLT) may initialize, which affects the
               results of XPath expressions used in that context. XSLT augments the context with
               additional information: this additional information is used firstly by XSLT
               constructs outside the scope of XPath (for example, the <elcode>xsl:sort</elcode>
               element), and secondly, by functions that are defined in the XSLT specification (such
               as <function>key</function> and <function>current-group</function>) that are
               available for use in XPath expressions appearing within a stylesheet.</p>
            <p>The static context for an expression or other construct in a stylesheet is determined
               by the place in which it appears lexically. The details vary for different components
               of the static context, but in general, elements within a stylesheet module affect the
               static context for their descendant elements within the same stylesheet module.</p>
            <p>The dynamic context is maintained as a stack. When an instruction or expression is
               evaluated, it may add dynamic context information to the stack; when evaluation is
               complete, the dynamic context reverts to its previous state. An expression that
               accesses information from the dynamic context always uses the value at the top of the
               stack.</p>
            <p>The most commonly used component of the dynamic context is the <termref def="dt-context-item">context item</termref>. This is an implicit variable whose
               value is the item currently being processed (it may be a node, an atomic value,
                  or a function item). The value of the context
               item can be referenced within an XPath expression using the expression <code>.</code>
               (dot).</p>
            <p>Full details of the static and dynamic context are provided in <specref ref="static-and-dynamic-context"/>.</p>
         </div2>
         <div2 id="parsing-and-serialization">
            <head>Parsing and Serialization</head>
            

            <p>An XSLT <termref def="dt-stylesheet">stylesheet</termref>
               describes a process that constructs a set of results from a set of inputs. The inputs
               are the data provided at stylesheet invocation, as described in <specref ref="initiating"/>. The results include the <termref def="dt-principal-result"/>
               (an arbitrary sequence), which is the result of the initial component invocation,
               together with any <termref def="dt-secondary-result">secondary results</termref>
               produced using <elcode>xsl:result-document</elcode> instructions. </p>


            <p>The <termref def="dt-stylesheet">stylesheet</termref> does not describe how a
                  <termref def="dt-source-tree">source tree</termref> is constructed. Some possible
               ways of constructing source trees are described in <bibref ref="xpath-datamodel-30"/>. Frequently an <termref def="dt-implementation">implementation</termref> will
               operate in conjunction with an XML parser (or more strictly, in the terminology of
                  <bibref ref="REC-xml"/>, an <emph>XML processor</emph>), to build a source tree
               from an input XML document. An implementation <rfc2119>may</rfc2119> also provide an
               application programming interface allowing the tree to be constructed directly, or
               allowing it to be supplied in the form of a DOM Document object (see <bibref ref="DOM-Level-2-Core"/>). This is outside the scope of this specification. Users
               should be aware, however, that since the input to the transformation is a tree
               conforming to the XDM data model as described in <bibref ref="xpath-datamodel-30"/>,
               constructs that might exist in the original XML document, or in the DOM, but which
               are not within the scope of the data model, cannot be processed by the <termref def="dt-stylesheet">stylesheet</termref> and cannot be guaranteed to remain
               unchanged in the transformation output. Such constructs include CDATA section
               boundaries, the use of entity references, and the DOCTYPE declaration and internal
               DTD subset.</p>
            <p>
               <termdef id="dt-serialization" term="serialization">A frequent requirement is to
                  output a <termref def="dt-final-result-tree">final result tree</termref> as an XML
                  document (or in other formats such as HTML). This process is referred to as
                     <term>serialization</term>.</termdef>
            </p>
            <p>Like parsing, serialization is not part of the transformation process, and it is not
                  <rfc2119>required</rfc2119> that an XSLT processor <rfc2119>must</rfc2119> be able
               to perform serialization. However, for pragmatic reasons, this specification
               describes declarations (the <elcode>xsl:output</elcode> element and the
                  <elcode>xsl:character-map</elcode> declarations, see <specref ref="serialization"/>), and attributes on the <elcode>xsl:result-document</elcode> instruction, that
               allow a <termref def="dt-stylesheet">stylesheet</termref> to specify the desired
               properties of a serialized output file. When serialization is not being performed,
               either because the implementation does not support the serialization option, or
               because the user is executing the transformation in a way that does not invoke
               serialization, then the content of the <elcode>xsl:output</elcode> and
                  <elcode>xsl:character-map</elcode> declarations has no effect. Under these
               circumstances the processor <rfc2119>may</rfc2119> report any errors in an
                  <elcode>xsl:output</elcode> or <elcode>xsl:character-map</elcode> declaration, or
               in the serialization attributes of <elcode>xsl:result-document</elcode>, but is not
                  <rfc2119>required</rfc2119> to do so.</p>
         </div2>
         <div2 id="packages-and-modules">
            <head>Packages and Modules</head>
            <p>In XSLT 1.0 and 2.0 it was possible to structure a
               stylesheet as a collection of modules, using the <elcode>xsl:include</elcode> and
                  <elcode>xsl:import</elcode> declarations to express the dependency of one module on
               others.</p>
            <p>In XSLT 3.0 an additional layer of modularization of stylesheet code was enabled
               through the introduction of <termref def="dt-package">packages</termref>. A package
               is a collection of stylesheet modules with a controlled interface to the packages
               that use it: for example, it defines which functions and templates defined in the
               package are visible to callers, which are purely internal, and which are not only
               public but capable of being overridden by other functions and templates supplied by
               the using package.</p>
            <p>Packages are introduced with several motivations, which broadly divide into two
               categories:</p>
            <olist>
               <item>
                  <p>Software engineering benefits: greater re-use of code, greater robustness
                     through ease of testing, controlled evolution of code in response to new
                     requirements, ability to deliver code that users cannot see or modify.</p>
               </item>
               <item>
                  <p>Efficiency benefits: the ability to avoid compiling libraries repeatedly when
                     they are used in multiple stylesheets, and to avoid holding multiple copies of
                     the same library in memory simultaneously.</p>
               </item>
            </olist>
            <p>Packages are designed to allow separate compilation: that is, a package can be
               compiled independently of the packages that use it. This specification does not
               define a process model for compilation, or expand on what it means to compile
               different packages independently. Nor does it mandate that implementations offer any
               feature along these lines. It merely defines language features that are designed to
               make separate compilation of packages possible.</p>
            <p>To achieve this, packages (unlike modules):</p>
            <ulist>
               <item>
                  <p>Must not contain unresolved references to functions, templates, or variables
                     declared in other packages;</p>
               </item>
               <item>
                  <p>Have strict rules governing the ability to override declarations in a <termref def="dt-library-package">library package</termref> with declarations in a
                     package that uses the library;</p>
               </item>
               <item>
                  <p>Constrain the visibility of component names and of context declarations such as
                     the declarations of keys and decimal formats;</p>
               </item>
               <item>
                  <p>Can declare a mode (a collection of template rules) as final, which disallows
                     the addition of new overriding template rules in a using package;</p>
               </item>
               <item>
                  <p>Require explicit disambiguation where naming conflicts arise, for example when
                     a package uses two other packages that both export like-named components;</p>
               </item>
               <item>
                  <p>Allow multiple specializations of library components to coexist in the same
                     application.</p>
               </item>
            </ulist>

            <p>A package is defined in XSLT
               by means of an XML document whose
               outermost element is an <elcode>xsl:package</elcode> element. This is referred to as
               the <termref def="dt-package-manifest"/>. The <elcode>xsl:package</elcode> element
               has optional child elements <elcode>xsl:use-package</elcode> and
                  <elcode>xsl:expose</elcode> describing properties of the package. The package
               manifest may refer to an external top-level stylesheet module using an
                  <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode> declaration, or it may
               contain the body of a stylesheet module inline (the two approaches can also be
               mixed).</p>
            
            <p>Although this specification defines packages as constructs 
               written using a defined XSLT syntax, implementations <rfc2119>may</rfc2119> provide mechanisms that allow 
               packages to be written using other languages (for example, XQuery).</p>   

            <p>When no packages are explicitly defined, the entire
               stylesheet is treated as a single package; the effect is as if the
                  <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element of the
                  <termref def="dt-principal-stylesheet-module">principal stylesheet
                  module</termref> were replaced by an <elcode>xsl:package</elcode> element with no
               other information in the package manifest.</p>

         </div2>
         <div2 id="extensibility">
            <head>Extensibility</head>
            <p>XSLT defines a number of features that allow the language to be extended by
               implementers, or, if implementers choose to provide the capability, by users. These
               features have been designed, so far as possible, so that they can be used without
               sacrificing interoperability. Extensions other than those explicitly defined in this
               specification are not permitted.</p>
            <p>These features are all based on XML namespaces; namespaces are used to ensure that
               the extensions provided by one implementer do not clash with those of a different
               implementer.</p>
            <p>The most common way of extending the language is by providing additional functions,
               which can be invoked from XPath expressions. These are known as 
               <termref def="dt-extension-function">extension functions</termref>, and are described in
                  <specref ref="extension-functions"/>.</p>
            <p>It is also permissible to extend the language by providing new <termref def="dt-instruction">instructions</termref>. 
               These are referred to as <termref def="dt-extension-instruction">extension instructions</termref>, and are described
               in <specref ref="extension-instruction"/>. A stylesheet that uses extension
               instructions in a particular namespace must declare that it is doing so by using the
                  <code>[xsl:]extension-element-prefixes</code> attribute.</p>
            <p>Extension instructions and extension functions defined according to these rules
                  <rfc2119>may</rfc2119> be provided by the implementer of the XSLT processor, and
               the implementer <rfc2119>may</rfc2119> also provide facilities to allow users to
               create further extension instructions and extension functions.</p>
            <p>This specification defines how extension instructions and extension functions are
               invoked, but the facilities for creating new extension instructions and extension
               functions are <termref def="dt-implementation-defined">implementation-defined</termref>. 
               For further details, see <specref ref="extension"/>.</p>
            <imp-def-feature id="idf-ext-mechanisms">The mechanisms for creating new <termref def="dt-extension-instruction">extension instructions</termref> and <termref def="dt-extension-function">extension functions</termref> are <termref def="dt-implementation-defined"/>. It is not <rfc2119>required</rfc2119> that
               implementations provide any such mechanism.</imp-def-feature>
            <p>The XSLT language can also be extended by the use of <termref def="dt-extension-attribute">extension attributes</termref> (see <specref ref="extension-attributes"/>), and by means of <termref def="dt-data-element">user-defined data elements</termref> (see <specref ref="user-defined-top-level"/>).</p>
         </div2>
         <div2 id="stylesheets-and-schemas">
            <head>Stylesheets and XML Schemas</head>
            <p>An XSLT <termref def="dt-stylesheet">stylesheet</termref> can make use of information
               from a schema. An XSLT transformation can take place in the absence of a schema (and,
               indeed, in the absence of a DTD), but where the source document has undergone schema
               validity assessment, the XSLT processor has access to the type information associated
               with individual nodes, not merely to the untyped text.</p>
            <p>Information from a schema can be used both statically (when the <termref def="dt-stylesheet">stylesheet</termref> is compiled), and dynamically (during
               evaluation of the stylesheet to transform a source document).</p>
            <p>There are places within a <termref def="dt-stylesheet">stylesheet</termref>, and
               within XPath <termref def="dt-expression">expressions</termref> and <termref def="dt-pattern">patterns</termref> in a <termref def="dt-stylesheet">stylesheet</termref>, where it is possible to refer to named type definitions in
               a schema, or to element and attribute declarations. For example, it is possible to
               declare the types expected for the parameters of a function. This is done using
               a <termref def="dt-sequence-type"/>.</p>
            <p><termdef id="dt-sequence-type" term="SequenceType">A <term>SequenceType</term>
            constrains the type and number of items in a sequence. The term is used both to denote the
            concept, and to refer to the syntactic form in which sequence types are expressed in the
            XPath grammar: specifically <xnt spec="XP40" ref="prod-xpath40-SequenceType">SequenceType</xnt> in
                <bibref ref="xpath-30"/>.</termdef><phrase diff="del" at="A">, or <xnt spec="XP40" ref="prod-xpath31-SequenceType">SequenceType</xnt> in
                <bibref ref="xpath-31"/>, depending on whether or not the XPath 3.1 feature
            is implemented.</phrase></p>
            <p>
               <termdef id="dt-schema-component" term="schema component">Type definitions and
                  element and attribute declarations are referred to collectively as <term>schema
                     components</term>.</termdef>
            </p>
            <p>
               <termdef id="dt-in-scope-schema-component" term="in-scope schema component">The
                     <termref def="dt-schema-component">schema components</termref> that may be
                  referenced by name in a <termref def="dt-package">package</termref> are referred to as the
                     <term>in-scope schema components</term>.</termdef></p>

            <p>The set of in-scope schema components may vary between
               one package and another, but as explained in <specref ref="import-schema"/>, the
               schema components used in different packages must be consistent with each other.</p>

            <p>The conformance rules for XSLT 4.0, defined in
                  <specref ref="conformance"/>, distinguish between a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> and a <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>. As the
               names suggest, a basic XSLT processor does not support the features of XSLT that
               require access to schema information, either statically or dynamically. A <termref def="dt-stylesheet">stylesheet</termref> that works with a basic XSLT processor
               will produce the same results with a schema-aware XSLT processor provided that the
               source documents are untyped (that is, they are not validated against a schema).
               However, if source documents are validated against a schema then the results may be
               different from the case where they are not validated. Some constructs that work on
               untyped data may fail with typed data (for example, an attribute of type
                  <code>xs:date</code> cannot be used as an argument of the
                  <xfunction>substring</xfunction> function) and other constructs may produce
               different results depending on the datatype (for example, given the element
                  <code>&lt;product price="10.00" discount="2.00"/&gt;</code>, the expression
                  <code>@price gt @discount</code> will return true if the attributes have type
                  <code>xs:decimal</code>, but will return false if they are untyped).</p>
            <p>There is a standard set of type definitions that are always available as <termref def="dt-in-scope-schema-component">in-scope schema components</termref> in every
               stylesheet. These are defined in <specref ref="built-in-types"/>. </p>
            <p>The remainder of this section describes facilities that are available only with a
                  <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                  processor</termref>.</p>
            <p>Additional <termref def="dt-schema-component">schema components</termref> (type
               definitions, element declarations, and attribute declarations) may be added to the
                  <termref def="dt-in-scope-schema-component">in-scope schema components</termref>
               by means of the <elcode>xsl:import-schema</elcode> declaration in a stylesheet.</p>
            <p>The <elcode>xsl:import-schema</elcode> declaration may reference an external schema
               document by means of a URI, or it may contain an inline <code>xs:schema</code>
               element.</p>
            <p>It is only necessary to import a schema explicitly if one or more of its <termref def="dt-schema-component">schema components</termref> are referenced explicitly by
               name in the <termref def="dt-stylesheet">stylesheet</termref>; it is not necessary to
               import a schema merely because the stylesheet is used to process a source document
               that has been assessed against that schema. It is possible to make use of the
               information resulting from schema assessment (for example, the fact that a particular
               attribute holds a date) even if no schema has been imported by the stylesheet.</p>
            <p>Importing a schema does not of itself say anything about the type of the source
               document that the <termref def="dt-stylesheet">stylesheet</termref> is expected to
               process. The imported type definitions can be used for temporary nodes or for nodes
               on a <termref def="dt-result-tree">result tree</termref> just as much as for nodes in
               source documents. It is possible to make assertions about the type of an input
               document by means of tests within the <termref def="dt-stylesheet">stylesheet</termref>. For example:</p>
            <example>
               <head>Asserting the Required Type of the Source Document</head>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:mode typed="lax"/&gt;
&lt;xsl:global-context-item use="required"
            as="document-node(schema-element(my:invoice))"/&gt;</eg>
               <p>This example will cause the transformation to fail with an error message, unless
                  the <termref def="dt-global-context-item"/> is valid against the top-level element
                  declaration <code>my:invoice</code>, and has been annotated as such.</p>
               <p>The setting <code>typed="lax"</code> further ensures that in any
                  match pattern for a template rule in this mode, an element name that corresponds
                  to the name of an element declaration in the schema is taken as referring to
                  elements validated against that declaration: for example,
                     <code>match="employee"</code> will only match a validated <code>employee</code>
                  element. Selecting this option enables the XSLT processor to do more compile-time
                  type-checking against the schema, for example it allows the processor to produce
                  warning or error messages when path expressions contain misspelt element names, or
                  confuse an element with an attribute.</p>
            </example>
            <p>It is also true that importing a schema does not of itself say
               anything about the structure of the result tree. It is possible to request validation
               of a result tree against the schema by using the <elcode>xsl:result-document</elcode>
               instruction, for example:</p>
            <example>
               <head>Requesting Validation of the Result Document</head>
               <eg role="xslt-declaration xmlns:xhtml='xhtml'" xml:space="preserve">&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xhtml:html&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xhtml:html&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
               </eg>
               <p>This example will cause the transformation to fail with an error message unless
                  the document element of the result document is valid against the top-level element
                  declaration <code>xhtml:html</code>.</p>
            </example>

            <p>It is possible that a source document may contain nodes whose <termref def="dt-type-annotation">type annotation</termref> is not one of the types
               imported by the stylesheet. This creates a potential problem because in the case of
               an expression such as <code>data(.) instance of xs:integer</code> the system needs to
               know whether the type named in the type annotation of the context node is derived by
               restriction from the type <code>xs:integer</code>. This information is not explicitly
               available in an XDM tree, as defined in <bibref ref="xpath-datamodel-30"/>. The
               implementation may choose one of several strategies for dealing with this
               situation:</p>
            <olist>
               <item>
                  <p>The processor may signal a <termref def="dt-dynamic-error"> dynamic error</termref> if a source
                     document is found to contain a <termref def="dt-type-annotation"/> that is not
                     known to the processor.</p>
               </item>
               <item>
                  <p>The processor may maintain additional metadata, beyond that described in
                        <bibref ref="xpath-datamodel-30"/>, that allows the source document to be
                     processed as if all the necessary schema information had been imported using
                        <elcode>xsl:import-schema</elcode>. Such metadata might be held in the data
                     structure representing the source document itself, or it might be held in a
                     system catalog or repository.</p>
               </item>
               <item>
                  <p>The processor may be configured to use a fixed set of schemas, which are
                     automatically used to validate all source documents before they can be supplied
                     as input to a transformation. In this case it is impossible for a source
                     document to have a <termref def="dt-type-annotation"/> that the processor is
                     not aware of.</p>
               </item>
               <item>
                  <p>The processor may be configured to treat the source document as if no schema
                     processing had been performed, that is, effectively to strip all type
                     annotations from elements and attributes on input, marking them instead as
                     having type <code>xs:untyped</code> and <code>xs:untypedAtomic</code>
                     respectively.</p>
               </item>
            </olist>
            <p>Where a stylesheet author chooses to make assertions about the types of nodes or of
                  <termref def="dt-variable">variables</termref> and <termref def="dt-parameter">parameters</termref>, it is possible for an XSLT processor to perform static
               analysis of the <termref def="dt-stylesheet">stylesheet</termref> (that is, analysis
               in the absence of any source document). Such analysis <rfc2119>may</rfc2119> reveal
               errors that would otherwise not be discovered until the transformation is actually
               executed. An XSLT processor is not <rfc2119>required</rfc2119> to perform such static
               type-checking. Under some circumstances (see <specref ref="errors"/>) type errors
               that are detected early <rfc2119>may</rfc2119> be reported as static errors. In
               addition an implementation <rfc2119>may</rfc2119> report any condition found during
               static analysis as a warning, provided that this does not prevent the stylesheet
               being evaluated as described by this specification.</p>
            <p>A <termref def="dt-stylesheet">stylesheet</termref> can also control the <termref def="dt-type-annotation">type annotations</termref> of nodes that it constructs in
               a <termref def="dt-result-tree">result
                     tree</termref>. This can be done in a number of ways.</p>
            <ulist>
               <item>
                  <p>It is possible to request explicit validation of a complete document, that is,
                     a <termref def="dt-result-tree">result
                           tree</termref> rooted at a document node.  Validation
                     is either strict or lax, as described in <bibref ref="xmlschema-1"/>. If
                     validation of a <termref def="dt-result-tree">result tree</termref> fails
                     (strictly speaking, if the outcome of the validity assessment is
                        <code>invalid</code>), then the transformation fails, but in all other
                     cases, the element and attribute nodes of the tree will be annotated with the
                     names of the types to which these nodes conform. These <termref def="dt-type-annotation">type annotations</termref> will be discarded if the
                     result tree is serialized as an XML document, but they remain available when
                     the result tree is passed to an application (perhaps another <termref def="dt-stylesheet">stylesheet</termref>) for further processing.</p>
               </item>
               <item>
                  <p>It is also possible to validate individual element and attribute nodes as they
                     are constructed. This is done using the <code>type</code> and
                        <code>validation</code> attributes of the <elcode>xsl:element</elcode>,
                        <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>, and
                        <elcode>xsl:copy-of</elcode> instructions, or the <code>xsl:type</code> and
                        <code>xsl:validation</code> attributes of a literal result element.</p>
               </item>
               <item>
                  <p>When elements, attributes, or document nodes are copied, either explicitly
                     using the <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode>
                     instructions, or implicitly when nodes in a sequence are attached to a new
                     parent node, the options <code>validation="strip"</code> and
                        <code>validation="preserve"</code> are available, to control whether
                     existing <termref def="dt-type-annotation">type annotations</termref> are to be
                     retained or not.</p>
               </item>
            </ulist>
            <p>When nodes in a <termref def="dt-temporary-tree">temporary tree</termref> are
               validated, type information is available for use by operations carried out on the
               temporary tree, in the same way as for a source document that has undergone schema
               assessment.</p>
            <p>For details of how validation of element and attribute nodes works, see <specref ref="validation"/>.</p>
         </div2>
         <div2 id="streaming-concepts">
            <head>Streaming</head>
            <p><termdef id="dt-streaming" term="streaming">The term <term>streaming</term> refers to
                  a manner of processing in which XML documents (such as source and result documents)
                  are not represented by a complete tree of nodes occupying memory proportional to
                  document size, but instead are processed “on the fly” as a sequence of events,
                  similar in concept to the stream of events notified by an XML parser to represent
                  markup in lexical XML.</termdef></p>

            <p><termdef id="dt-streamed-document" term="streamed document">A <term>streamed
                     document</term> is a <termref def="dt-source-tree">source tree</termref> that
                  is processed using streaming, that is, without constructing a complete tree of
                  nodes in memory.</termdef></p>

            <p><termdef id="dt-streamed-node" term="streamed node">A <term>streamed
                     node</term> is a node in a <termref def="dt-streamed-document">streamed
                     document</termref>.</termdef></p>

            <p>Many processors implementing earlier versions of this specification adopted an
               architecture that allowed streaming of the <termref def="dt-result-tree">result
                  tree</termref> directly to a serializer, without first materializing the complete
               result tree in memory. Streaming of the <termref def="dt-source-tree">source
                  tree</termref>, however, has proved to be more difficult without subsetting the
               language. This has created a situation where documents exceeding the capacity of
               virtual memory could not be transformed. XSLT 3.0 therefore introduced facilities
               allowing stylesheets to be written in a way that makes streaming of source documents
               possible, without excessive reliance on processor-specific optimization
               techniques.</p>

            <p>Streaming achieves two important objectives: it allows large documents to be
               transformed without requiring correspondingly large amounts of memory; and it allows
               the processor to start producing output before it has finished receiving its input,
               thus reducing latency.</p>

            <p>This specification does not attempt to legislate precisely which implementation
               techniques fall under the definition of streaming, and which do not. A number of
               techniques are available that reduce memory requirements, while still requiring a
               degree of buffering, or allocation of memory to partial results. A stylesheet that
               requests streaming of a source document is indicating that the processor should avoid
               assuming that the entire source document will fit in memory; in return, the
               stylesheet must be written in a way that makes streaming possible. This specification
               does not attempt to describe the algorithms that the processor should actually use,
               or to impose quantitative constraints on the resources that these algorithms should
               consume.</p>

            <p>Nothing in this specification, nor in its predecessors <bibref ref="xslt"/> and
                  <bibref ref="xslt20"/>, prevents a processor using streaming whenever it sees an
               opportunity to do so. However, experience has shown that in order to achieve
               streaming, it is often necessary to write stylesheet code in such a way as to make
               this possible. Therefore, XSLT provides explicit constructs allowing the
               stylesheet author to request streaming, and defines explicit static constraints on
               the structure of the code which are designed to make streaming possible.</p>

            <p>A processor that claims conformance with the streaming option offers a guarantee that
               when streaming is requested for a source document, and when the stylesheet conforms
               to the rules that make the processing <termref def="dt-guaranteed-streamable"/>, then
               an algorithm will be adopted in which memory consumption is either completely
               independent of document size, or increases only very slowly as document size
               increases, allowing documents to be processed that are orders-of-magnitude larger
               than the physical memory available. A processor that does not claim conformance with
               the streaming option must still process a stylesheet and deliver the correct results,
               but is not required to use streaming algorithms, and may therefore fail with
               out-of-memory errors when presented with large source documents.</p>

            <p>Apart from the fact that there are constructs to request streaming, and rules that
               must be followed to guarantee that streaming is possible, the language has been
               designed so there are as few differences as possible between streaming and
               non-streaming evaluation. The semantics of the language continue to be expressed in
               terms of the XDM data model, which is substantively unchanged; but readers must take
               care to observe that when terms like “node” and “axis” are used, the concepts are
               completely abstract and may have no direct representation in the run-time execution
               environment.</p>
            <p>Streamed processing of a document can be initiated in one of three ways:</p>
            <ulist>
               <item>
                  <p>The <termref def="dt-initial-mode">initial mode</termref> can be declared as a
                        <termref def="dt-streamable-mode">streamable mode</termref>. In this case
                     the <termref def="dt-initial-match-selection"/> will generally be a document node (or
                        sequence of document nodes), supplied by the calling application in
                     a form that allows streaming (that is, in some form other than a tree in
                     memory; for example, as a reference to a push or pull XML parser primed to
                     deliver a stream of events). The type of
                        these nodes can be constrained by using the attribute
                           <code>on-no-match="fail"</code> on the <termref def="dt-initial-mode"/>,
                        and using this mode only for processing the top-level nodes.
                     </p>
               </item>
               <item>
                  <p>Streamed processing of any document can be initiated using the
                        <elcode>xsl:source-document</elcode> instruction. This has an attribute  
                        <code>href</code> whose value is the URI of a document to be processed,
                     and an attribute <code>streamable</code> that
                     indicates whether it is to be processed using
                     streaming; the actual processing to be applied is defined by the
                     instructions written as children of the <elcode>xsl:source-document</elcode>
                     instruction. </p>
               </item>
               <item>
                  <p>Streamed merging of a set of input documents can be initiated using the
                        <elcode>xsl:merge</elcode> instruction.</p>
               </item>
            </ulist>
            <p>The rules for streamability, which are defined in detail in <specref ref="streamability"/>, impose two main constraints:</p>
            <ulist>
               <item>
                  <p>The only nodes reachable from the node that is currently being processed are
                     its attributes and namespaces, its ancestors and their attributes and
                     namespaces, and its descendants and their attributes and namespaces. The
                     siblings of the node, and the siblings of its ancestors, are not reachable in
                     the tree, and any attempt to use their values is a <termref def="dt-static-error">static error</termref>. </p>
               </item>
               <item>
                  <p>When processing a given node in the tree, each descendant node can only be
                     visited once. Essentially this allows two styles of processing: either visit
                     each of the children once, and then process that child with the same
                     restrictions applied; or process all the descendants in a single pass, in which
                     case it is not possible while processing a descendant to make any further
                     downward selection.</p>
               </item>
            </ulist>
            <p>The second restriction, that only one visit to the children is
               allowed, means that XSLT code that was not designed with streaming in mind will often
               need to be rewritten to make it streamable. In many cases it is possible to do this
               using a technique sometimes called <emph>windowing</emph> or <emph>burst-mode
                  streaming</emph> (note this is not quite the same meaning as
                  <emph>windowing</emph> in XQuery 3.0). Many XML documents consist of a large
               number of elements, each of manageable size, representing transactions or business
               objects where each such element can be processed independently: in such cases, an
               effective design pattern is to write a streaming transformation that takes a snapshot
               of each element in turn, processing the snapshot using the full power of the XSLT
               language. Each snapshot is a tree built in memory and is therefore fully navigable.
               For details see the <function>snapshot</function> and <function>copy-of</function>
               functions.</p>

            <p>The new facility of <emph>accumulators</emph> allows applications
               complete control over how much information is retained (and by implication, how much
               memory is required) in the course of a pass over a <termref def="dt-streamed-document"/>. An accumulator computes a value for every node in a
               streamed document: or more accurately, two values, one for the first visit to a node
               (before visiting its descendants), and a second value for the second visit to the
               node (after visiting the descendants). The computation is structured in such a way
               that the value for a given node can depend only on the value for the previous node in
               document order together with the data available when positioned at the current node
               (for example, the attribute values). Based on the well-established fold operation of
               functional programming languages, accumulators provide the convenience and economy of
               mutable variables while remaining within the constraints of a purely declarative
               processing model.</p>

            <p>When streaming is initiated, for example using the
                  <elcode>xsl:source-document</elcode> instruction, it is necessary to declare which
               accumulators are applicable to the streamed document.</p>


            <p>Streaming applications often fall into one of the following categories:</p>
            <ulist>
               <item>
                  <p>Aggregation applications, where a single aggregation operation (perhaps
                        <xfunction>count</xfunction>, <xfunction>sum</xfunction>,
                        <xfunction>exists</xfunction>, or <xfunction>distinct-values</xfunction>) is
                     applied to a set of elements selected from the streamed source document by
                     means of a path expression.</p>
               </item>
               <item>
                  <p>Record-at-a-time applications, where the source document consists of a long
                     sequence of elements with similar structure (“records”), and each “record” is
                     processed using the same logic, independently of any other “records”. This kind
                     of processing is facilitated using the <function>snapshot</function> and
                        <function>copy-of</function> function mentioned earlier.</p>
               </item>
               <item>
                  <p>Grouping applications, where the output follows the structure of the input,
                     except that an extra layer of hierarchy is added. For example, the input might
                     be a flat series of banking transactions in date/time order, and the output
                     might contain the same transactions grouped by date.</p>
               </item>
               <item>
                  <p>Accumulator applications, which are the same as record-at-a-time applications,
                     except that the processing of one “record” might depend on data encountered
                     earlier in the document. A classic example is processing a sequence of banking
                     transactions in which the input transaction contains a debit or credit amount,
                     and the output adds a running total (the account balance). The
                        <elcode>xsl:iterate</elcode> instruction has been introduced to facilitate
                     this style of processing.</p>
               </item>
               <item>
                  <p>Isomorphic transformations, in which there is an ordered (often largely
                     one-to-one) relationship between the nodes of the source tree and the nodes of
                     the result tree: for example, transformations that involve only the renaming or
                     selective deletion of nodes, or scalar manipulations of the values held in the
                     leaf nodes. Such transformations are most conveniently expressed using
                     recursive application of template rules. This is possible with a streamed input
                     document only if all the template rules adhere to the constraints required for
                     streamability. To enforce these rules, while still allowing unrestricted
                     processing of other documents within the same transformation, all streaming
                     evaluation must be carried out using a specific <termref def="dt-mode">mode</termref>, which is declared to be a streaming mode by means of an
                        <elcode>xsl:mode</elcode> declaration in the stylesheet.</p>
               </item>
            </ulist>
            <p>There are important classes of application in which streaming is possible only if
               multiple streams can be processed in parallel. This specification therefore provides
               facilities:</p>
            <olist>
               <item>
                  <p>allowing multiple sorted input sequences to be merged into one sorted output
                     sequence (the <elcode>xsl:merge</elcode> instruction)</p>
               </item>
               <item>
                  <p>allowing multiple output sequences to be generated during a single pass of an
                     input sequence (the <elcode>xsl:fork</elcode> instruction).</p>
               </item>
            </olist>
            <p>These facilities have been designed in such a way that they can readily be
               implemented using streaming, that is, without materializing the input or output
               sequences in memory.</p>

         </div2>
         <div2 id="streamed-validation">
            <head>Streamed Validation</head>
            
            <p>Streaming can be combined with schema-aware processing: that is, the streamed input to a transformation 
               can be subjected to on-the-fly validation, a process which typically accepts an input stream from the 
               XML parser and delivers an output stream (of type-annotated nodes) to the transformation processor. 
               The XSD specification is designed so that validation is, with one or two exceptions, a streamable process. 
               The exceptions include:
            </p>
            
            <ulist>
               <item><p>There may be a need to allocate memory to hold keys, in order to enforce uniqueness and 
                  referential integrity constraints (<code>xs:unique</code>, <code>xs:key</code>, <code>xs:keyref</code>).
               </p></item>
               <item><p>In XSD 1.1, assertions can be defined by means of XPath expressions. These are not constrained 
                  to be streamable; in the general case, any subtree of the document that is validated using an assertion 
                  may need to be buffered in memory while the assertion is processed.
               </p></item>
            </ulist>

            <p>Applications that need to run in finite memory may therefore need to avoid these XSD features, 
               or to use them with care.
            </p>
            
            <p>XSD is designed so that the intended type of an element (the “governing type”) can be determined as soon 
               as the start tag of the element is encountered: the process of validation checks whether the content of 
               the element actually conforms to this type, and by the time the end tag is encountered, the process will 
               have established either that the element is valid against the governing type, or that it is invalid. 
            </p>
            
            <p>By default, dynamic errors occurring during streamed processing are fatal: they typically cause the 
               transformation to fail immediately. XSLT 3.0 introduced the ability to catch dynamic errors and recover 
               from them. Schema invalidity, however, is treated as a dynamic error of the instruction that 
               processes the entire input stream, so after a validation failure, no further processing of that input stream 
               is possible.
            </p>
            
            <p>In consequence, a streamed validator that is running in tandem with a streamed transformation 
               can present the transformer with element nodes that carry a provisional type annotation representing 
               the type that the element will have if it turns out to be valid. As soon as a node is encountered that 
               violates this assumption, the validator should stop the flow of data to the transformer, so that the 
               transformer never sees invalid data. This allows the stylesheet code to be compiled with the assumption 
               of type-safety: at run-time, all nodes seen by the transformation will conform to their XSLT-declared types
               (for example, a type declared implicitly using <code>match="schema-element(invoice)"</code> on an 
               <elcode>xsl:template</elcode> element).
            </p>
            
            <p>A streamed transformation that only accesses part of the input document (for example, a header
               at the start of a document) is not required to continue reading once the data it needs 
               has been read. This means that XML well-formedness or validity errors occurring in the unread part 
               of the input stream may go undetected.
            </p>
            
            
            
            
            
         </div2>
         <div2 id="streaming-non-xml">
            <head>Streaming of non-XML data</head>
            <p>The facilities in this specification designed to enable large data sets to be processed in a streaming
            manner are oriented almost entirely to XML data. This does not mean that there is never a requirement
            to stream non-XML data, or that the Working Group has ignored this requirement; rather, the Working Group
            has concluded that for the most part, streaming of non-XML data can be achieved by implementations without
            the need for specific language features in XSLT.</p>
            
            <p>To make streamed processing of unparsed text files easier, the function <xfunction>unparsed-text-lines</xfunction>
            has been introduced. This is not only more convenient for stylesheet authors than reading the entire input
            using the <xfunction>unparsed-text</xfunction> function and then tokenizing the result, it is also easier for implementations
            to optimize, allowing each line of text to be discarded from memory after it has been processed.</p>
            
            <p>For all functions that access external data, including <function>document</function>, <xfunction>doc</xfunction>,
            <xfunction>collection</xfunction>, <xfunction>unparsed-text</xfunction>, <xfunction>unparsed-text-lines</xfunction>,
            and <xfunction spec="FO40">json-doc</xfunction>, the requirements on determinism can now
            be relaxed using <termref def="dt-implementation-defined"/> configuration options. This is significant
            because it means that when a transformation reads the same external resource more than once, it becomes
            legitimate for the contents of the resource to be different on different invocations, and this eliminates
            the need for the processor to cache the contents of the resource in memory.</p>
            
            <p>In the XDM data model, every value is a sequence, and (as with most functional programming languages),
            processing of sequences of items is pervasive throughout the XSLT and XPath languages and their function
            library. Good performance of a functional programming language often depends on sequence-based operations
            being pipelined, and being evaluated in a lazy fashion (that is, many operations process items in a sequence
            one at a time, in order; and many operations can deliver a result without processing the entire sequence).
            The semantics of XSLT and XPath permit pipelined and lazy evaluation (for example, the error handling semantics
            are carefully written to ensure this), but they do not require it: the details are left to implementations.
            Pipelined processing of a sequence is not the same thing as streamed processing of a tree, and where the XSLT
            specification talks of operations being “guaranteed streamable”, this is always referring to processing of
            trees, not of sequences.</p>
            
            <p>The facilities for streaming of XML trees include operations such as <function>copy-of</function>
            and <function>snapshot</function> which are able to take a sequence of streamed nodes as input, 
               and produce a sequence of in-memory (unstreamed) nodes as output. It is also possible to generate
               a sequence of strings or other atomic values through the process of <termref def="dt-atomization">atomization</termref>.
               The actual memory usage of a streamed
            XSLT application may depend significantly on whether the processing of the resulting sequence of in-memory
            nodes or atomic values is pipelined or not. The specification, however, has nothing to say on this matter: 
            it is considered an area where implementers can exercise their discretion and ingenuity.</p>
            
            <p>Streaming of JSON input receives little attention in this specification. One can envisage an implementation
            of the <function>json-to-xml</function> function in which the XML delivered by the function consists of
            streamed nodes; but the Working Group has not researched the feasibility of such an implementation in any detail.</p>
         </div2>
         <div2 id="errors">
            <head>Error Handling</head>
            <!--Text replaced by erratum E5 change 1"-->
            <p>
               <termdef id="dt-static-error" term="static error">An error that can be detected by
                  examining a <termref def="dt-stylesheet">stylesheet</termref> before execution
                  starts (that is, before the source document and values of stylesheet parameters
                  are available) is referred to as a <term>static error</term>.</termdef>
            </p>
            
            
            <p>Generally, errors in the structure of the <termref def="dt-stylesheet">stylesheet</termref>, or in the syntax of XPath <termref def="dt-expression">expressions</termref> contained in the stylesheet, are classified as <termref def="dt-static-error">static errors</termref>. Where this specification states
               that an element in the stylesheet <rfc2119>must</rfc2119> or <rfc2119>must
                  not</rfc2119> appear in a certain position, or that it <rfc2119>must</rfc2119> or
                  <rfc2119>must not</rfc2119> have a particular attribute, or that an attribute
                  <rfc2119>must</rfc2119> or <rfc2119>must not</rfc2119> have a value satisfying
               specified conditions, then any contravention of this rule is a static error unless
               otherwise specified. </p>
            
            <p>A processor <rfc2119>must</rfc2119> provide a mode of operation 
               that takes a (possibly erroneous) stylesheet <termref def="dt-package">package</termref> as 
               input and enables the user to determine whether or not that package contains any
               <termref def="dt-static-error">static errors</termref>.
            </p>
            
            <note>
            <p>The manner in which static errors are reported, and the behavior when there are multiple
               static errors, are left as design choices for the implementer. It is <rfc2119>recommended</rfc2119> 
               that the error codes defined in this specification should be made available in any diagnostics.
            </p></note>
            
            <p>A processor <rfc2119>may</rfc2119> also provide a mode of operation in which 
               <termref def="dt-static-error">static errors</termref> in parts of the stylesheet that 
               are not evaluated can go unreported.
            </p>
            
            <note><p>For example, when operating in this mode, a processor might report static errors 
               in a template rule only if the input document contains nodes that match that template rule. 
               Such a mode of operation can provide performance benefits when large and well-tested stylesheets 
               are used to process source documents that might only use a small part of the XML vocabulary 
               that the stylesheet is designed to handle.
            </p></note>
            <p>
               <termdef id="dt-dynamic-error" term="dynamic error">An error that is not 
                  capable of detection
                  until a source document is being transformed is referred to as a <term>dynamic
                     error</term>.</termdef>
            </p>
            <p>When a <termref def="dt-dynamic-error"/> occurs, and is not caught
               using <elcode>xsl:catch</elcode>, the <termref def="dt-processor">processor</termref>
               <rfc2119>must</rfc2119> signal the error, and the transformation fails.</p>
            
            

            
            
            
            <p>Because different implementations may optimize execution of the <termref def="dt-stylesheet">stylesheet</termref> in different ways, the detection of
               dynamic errors is to some degree <termref def="dt-implementation-dependent">implementation-dependent</termref>. In cases where an implementation is able to
               produce a <termref def="dt-principal-result"/> or
                     <termref def="dt-secondary-result"/>
                without evaluating a particular construct, the
               implementation is never <rfc2119>required</rfc2119> to evaluate that construct solely
               in order to determine whether doing so causes a dynamic error. For example, if a
                  <termref def="dt-variable">variable</termref> is declared but never referenced, an
               implementation <rfc2119>may</rfc2119> choose whether or not to evaluate the variable
               declaration, which means that if evaluating the variable declaration causes a dynamic
               error, some implementations will signal this error and others will not.</p>
            <p>There are some cases where this specification requires that a construct <rfc2119>must
                  not</rfc2119> be evaluated: for example, the content of an <elcode>xsl:if</elcode>
               instruction <rfc2119>must not</rfc2119> be evaluated if the test condition is false.
               This means that an implementation <rfc2119>must not</rfc2119> signal any dynamic
               errors that would arise if the construct were evaluated.</p>
            <p>An implementation <rfc2119>may</rfc2119> signal a <termref def="dt-dynamic-error">dynamic error</termref> before any source document is available, but only if it
               can determine that the error would be signaled for every possible source document and
               every possible set of parameter values. For example, some <termref def="dt-circularity">circularity</termref> errors fall into this category: see
                  <specref ref="circularity"/>.</p>
            <p>There are also some <termref def="dt-dynamic-error">dynamic
                  errors</termref> where the specification gives a processor license to signal the
               error during the analysis phase even if the construct might never be executed; an
               example is the use of an invalid QName as a literal argument to a function such as
                  <function>key</function>, or the use of an invalid regular expression in the
                  <code>regex</code> attribute of the <elcode>xsl:analyze-string</elcode>
               instruction.</p>
            <p>A <termref def="dt-dynamic-error"/>
               is also signaled during the static
               analysis phase if the error occurs during evaluation of a <termref def="dt-static-expression"/>.</p>
            <p>The XPath specification states (see <xspecref spec="XP40" ref="id-kinds-of-errors"/>)
               that if any expression (at any level) can be evaluated during the analysis phase
               (because all its explicit operands are known and it has no dependencies on the
               dynamic context), then any error in performing this evaluation <rfc2119>may</rfc2119>
               be reported as a static error. For XPath expressions used in an XSLT stylesheet,
               however, any such errors <rfc2119>must not</rfc2119> be reported as static errors in
               the stylesheet unless they would occur in every possible evaluation of that
               stylesheet; instead, they must be signaled as dynamic errors, and signaled only if
               the XPath expression is actually evaluated.</p>
            <example>
               <head>Errors in Constant Subexpressions</head>
               <p>An XPath processor may report statically that the expression <code>1 div 0</code>
                  fails with a “divide by zero” error. But suppose this XPath expression occurs in
                  an XSLT construct such as:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:choose&gt;
  &lt;xsl:when test="system-property('xsl:version') = '1.0'"&gt;
    &lt;xsl:value-of select="1 div 0"/&gt;
  &lt;/xsl:when&gt;
  &lt;xsl:otherwise&gt;
    &lt;xsl:value-of select="xs:double('INF')"/&gt;
  &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;</eg>
               <p>Then the XSLT processor must not report an error, because the relevant XPath
                  construct appears in a context where it will never be executed by an XSLT 2.0
                     or 3.0 processor. (An XSLT 1.0 processor
                  will execute this code successfully, returning positive infinity, because it uses
                  double arithmetic rather than decimal arithmetic.)</p>
            </example>
            <p>
               <termdef id="dt-type-error" term="type error">Certain errors are classified as
                     <term>type errors</term>. A type error occurs when the value supplied as input
                  to an operation is of the wrong type for that operation, for example when an
                  integer is supplied to an operation that expects a node.</termdef> If a type error
               occurs in an instruction that is actually evaluated, then it <rfc2119>must</rfc2119>
               be signaled in the same way as a <termref def="dt-dynamic-error"> dynamic error</termref>. Alternatively, an
               implementation <rfc2119>may</rfc2119> signal a type error during the analysis phase
               in the same way as a <termref def="dt-static-error">static error</termref>, even if
               it occurs in part of the stylesheet that is never evaluated, provided it can
               establish that execution of a particular construct would never succeed.</p>
            <p>It is <termref def="dt-implementation-defined"/> whether type errors are signaled
               statically.</p>
            <imp-def-feature id="idf-err-statictypechecking">It is <termref def="dt-implementation-defined"/> whether type errors are signaled
               statically.</imp-def-feature>
            <example>
               <head>A Type Error</head>
               <p>The following construct contains a type error, because
                     <code>42</code> is not allowed as the value of the <code>select</code>
                  expression of the <elcode>xsl:number</elcode> instruction (it must be a node). An
                  implementation <rfc2119>may</rfc2119> optionally signal this as a static error,
                  even though the offending instruction will never be evaluated, and the type error
                  would therefore never be signaled as a dynamic error.</p>
               <eg role="error" xml:space="preserve">&lt;xsl:if test="false()"&gt;
  &lt;xsl:number select="42"/&gt;
&lt;/xsl:if&gt;</eg>
               <p>On the other hand, in the following example it is not possible to determine
                  statically whether the operand of <elcode>xsl:number</elcode> will have a suitable dynamic type. An
                  implementation <rfc2119>may</rfc2119> produce a warning in such cases, but it
                     <rfc2119>must not</rfc2119> treat it as an error.</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:template match="para"&gt;
  &lt;xsl:param name="p" as="item()"/&gt;
  &lt;xsl:number select="$p"/&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <p>If more than one error arises, an implementation is not <rfc2119>required</rfc2119>
               to signal any errors other than the first one that it detects. It is <termref def="dt-implementation-dependent">implementation-dependent</termref> which of the
               several errors is signaled. This applies both to static errors and to dynamic errors.
               An implementation is allowed to signal more than one error, but if any errors have
               been signaled, it <rfc2119>must not</rfc2119> finish as if the transformation were
               successful.</p>
            <p>When a transformation signals one or more dynamic errors, the final state of any
               persistent resources updated by the transformation is <termref def="dt-implementation-dependent">implementation-dependent</termref>.
               Implementations are not <rfc2119>required</rfc2119> to restore such resources to
               their initial state. In particular, where a transformation produces multiple result
               documents, it is possible that one or more serialized result documents
                  <rfc2119>may</rfc2119> be written successfully before the transformation
               terminates, but the application cannot rely on this behavior.</p>
            <p>Everything said above about error handling applies equally to errors in evaluating
               XSLT instructions, and errors in evaluating XPath <termref def="dt-expression">expressions</termref>. Static errors and dynamic errors may occur in both
               cases.</p>
            <p>
               <termdef id="dt-serialization-error" term="serialization error">If a transformation
                  has successfully produced a <termref def="dt-principal-result"/> or <termref def="dt-secondary-result"/>, it is
                     still possible that errors may occur in serializing that result
                  . For example, it may be impossible to
                  serialize the result  using the
                  encoding selected by the user. Such an error is referred to as a
                     <term>serialization error</term>.</termdef> If the processor performs
               serialization, then it <rfc2119>must</rfc2119> do so as specified in <specref ref="serialization"/>, and in particular it <rfc2119>must</rfc2119> signal any
               serialization errors that occur.</p>
            <p>Errors are identified by a QName. For errors defined in this specification, the
               namespace of the QName is always <code>http://www.w3.org/2005/xqt-errors</code> (and
               is therefore not given explicitly), while the local part is an 8-character code in
               the form <var>PPSSNNNN</var>. Here <var>PP</var> is always <code>XT</code> (meaning
               XSLT), and <var>SS</var> is one of <code>SE</code> (static error), <code>DE</code>
               (dynamic error),  or <code>TE</code>
               (type error). Note that the allocation of an error to one of these categories is
               purely for convenience and carries no normative implications about the way the error
               is handled. Many errors, for example, can be reported either dynamically or
               statically. These error codes are used to label error conditions in this
               specification, and are summarized in <specref ref="error-summary"/>. </p>
            <p>Errors defined in related specifications (<bibref ref="xpath-40"/>, <bibref ref="xpath-functions-40"/>
               <bibref ref="xslt-xquery-serialization-30"/>) use QNames with a similar structure, in
               the same namespace. When errors occur in processing XPath expressions, an XSLT
               processor <rfc2119>should</rfc2119> use the original error code reported by the XPath
               processor, unless a more specific XSLT error code is available.</p>
            <p>Implementations <rfc2119>must</rfc2119> use the codes
               defined in these specifications when signaling dynamic errors, to ensure that
                     <elcode>xsl:catch</elcode> behaves in an interoperable way across
                  implementations. Stylesheet authors should note, however, that there are many
                  examples of errors where more than one rule in this specification is violated, and
                  where the processor therefore has discretion in deciding which error code to
                  associate with the condition: there is therefore no guarantee that different
                  processors will always use the same error code for the same erroneous
                  input.</p>
            <p>Additional errors defined by an implementation (or by an application)
                  <rfc2119>may</rfc2119> use QNames in an implementation-defined (or user-defined)
               namespace without risk of collision.</p>

         </div2>
      </div1>
      <div1 id="stylesheet-structure">
         <head>Stylesheet Structure</head>
         <p>This section describes the overall structure of a stylesheet as a collection of XML
            documents.</p>
         <div2 id="xslt-namespace">
            <head>XSLT Namespace</head>
            <p>
               <termdef id="dt-xslt-namespace" term="XSLT namespace">The <term>XSLT namespace</term>
                  has the URI <code>http://www.w3.org/1999/XSL/Transform</code>. It is used to
                  identify elements, attributes, and other names that have a special meaning defined
                  in this specification.</termdef>
            </p>
            <note>
               <p>The <code>1999</code> in the URI indicates the year in which the URI was allocated
                  by the W3C. It does not indicate the version of XSLT being used, which is
                  specified by attributes (see <specref ref="stylesheet-element"/> and <specref ref="simplified-stylesheet"/>).</p>
            </note>
            <p>XSLT <termref def="dt-processor">processors</termref>
               <rfc2119>must</rfc2119> use the XML namespaces mechanism <bibref ref="xml-names"/> to
               recognize elements and attributes from this namespace. Elements from the XSLT
               namespace are recognized only in the <termref def="dt-stylesheet">stylesheet</termref> and not in the source document. The complete list of
               XSLT-defined elements is specified in <specref ref="element-syntax-summary"/>.
                  <termref def="dt-implementation">Implementations</termref>
               <rfc2119>must not</rfc2119> extend the XSLT namespace with additional elements or
               attributes. Instead, any extension <rfc2119>must</rfc2119> be in a separate
               namespace. Any namespace that is used for additional instruction elements
                  <rfc2119>must</rfc2119> be identified by means of the <termref def="dt-extension-instruction">extension instruction</termref> mechanism specified
               in <specref ref="extension-instruction"/>.</p>
            
            <p>Except where the rules for <termref def="dt-forwards-compatible-behavior"/>
                  dictate otherwise, it is a <termref def="dt-static-error">static error</termref>
                  for any element in the stylesheet to be in the XSLT namespace unless it is an element defined in this
                  specification <errorref spec="XT" class="SE" code="0010"/>.</p>
            
            <p>This specification uses a prefix of <code>xsl:</code> for referring to elements in
               the XSLT namespace. However, XSLT stylesheets are free to use any prefix, provided
               that there is a namespace declaration that binds the prefix to the URI of the XSLT
               namespace.</p>
            <note>
               <p>Throughout this specification, an element or attribute that is in no namespace, or
                  an <termref def="dt-expanded-qname">expanded QName</termref> whose namespace part
                  is an empty sequence, is referred to as having a <term>null namespace
                  URI</term>.</p>
            </note>
            <note>
               <p>By convention, the names of <termref def="dt-xslt-element">XSLT
                     elements</termref>, attributes and functions are all lower-case;
                  they use hyphens to separate words, and they use abbreviations only if these already appear
                  in the syntax of a related language such as XML or HTML. Names of types defined in
                  XML Schema are regarded as single words and are capitalized exactly as in XML
                  Schema. This sometimes leads to composite function names such as
                     <xfunction>current-dateTime</xfunction>.</p>
            </note>
         </div2>

         <div2 id="extension-attributes">
            <head>Extension Attributes</head>
            <p>
               <termdef id="dt-extension-attribute" term="extension attribute">An element from the
                  XSLT namespace may have any attribute not from the XSLT namespace, provided that
                  the <termref def="dt-expanded-qname">expanded QName</termref> (see <bibref ref="xpath-30"/>) of the attribute has a non-null namespace URI. These
                  attributes are referred to as <term>extension attributes</term>.</termdef> The
               presence of an extension attribute <rfc2119>must not</rfc2119> cause the <termref def="dt-principal-result"/> or any <termref def="dt-secondary-result"/> of the transformation to be different from the
                  results
                that a conformant XSLT 4.0
               processor might produce. They <rfc2119>must not</rfc2119> cause the processor to fail
               to signal an error that a conformant processor is required to signal. This means that
               an extension attribute <rfc2119>must not</rfc2119> change the effect of any <termref def="dt-instruction">instruction</termref> except to the extent that the effect is
                  <termref def="dt-implementation-defined">implementation-defined</termref> or
                  <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
            <p>Furthermore, if serialization is performed using one of the serialization methods
                   described in <bibref ref="xslt-xquery-serialization-30"/>, the presence of an extension attribute must
               not cause the serializer to behave in a way that is inconsistent with the mandatory
               provisions of that specification.</p>
            <note>
               <p>
                  <termref def="dt-extension-attribute">Extension attributes</termref> may be used
                  to modify the behavior of <termref def="dt-extension-function">extension
                     functions</termref> and <termref def="dt-extension-instruction">extension
                     instructions</termref>. They may be used to select processing options in cases
                  where the specification leaves the behavior <termref def="dt-implementation-defined">implementation-defined</termref> or <termref def="dt-implementation-dependent">implementation-dependent</termref>. They may
                  also be used for optimization hints, for diagnostics, or for documentation.</p>
               <p>
                  <termref def="dt-extension-attribute">Extension attributes</termref> may also be
                  used to influence the behavior of the serialization methods <code>xml</code>,
                     <code>xhtml</code>, <code>html</code>, or <code>text</code>, to the extent that
                  the behavior of the serialization method is <termref def="dt-implementation-defined"/> or <termref def="dt-implementation-dependent">implementation-dependent</termref>. For example, an extension attribute might
                  be used to define the amount of indentation to be used when
                     <code>indent="yes"</code> is specified. If a serialization method other than
                  one of these four is requested (using a prefixed QName in the method parameter)
                  then extension attributes may influence its behavior in arbitrary ways. Extension
                  attributes must not be used to cause the  standard serialization methods to
                  behave in a non-conformant way, for example by failing to report serialization
                  errors that a serializer is required to report. An implementation that wishes to
                  provide such options must create a new serialization method for the purpose.</p>
               <p>An implementation that does not recognize the name of an extension attribute, or
                  that does not recognize its value, must perform the transformation as if the
                  extension attribute were not present. As always, it is permissible to produce
                  warning messages.</p>
               <p>The namespace used for an extension attribute will be copied to the <termref def="dt-result-tree">result tree</termref> in the normal way if it is in scope
                  for a <termref def="dt-literal-result-element">literal result element</termref>.
                  This can be prevented using the <code>[xsl:]exclude-result-prefixes</code>
                  attribute.</p>
            </note>
            <example>
               <head>An Extension Attribute for <code>xsl:message</code>
               </head>
               <p>The following code might be used to indicate to a particular implementation that
                  the <elcode>xsl:message</elcode> instruction is to ask the user for confirmation
                  before continuing with the transformation:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:message abc:pause="yes"
    xmlns:abc="http://vendor.example.com/xslt/extensions"&gt;
       Phase 1 complete
&lt;/xsl:message&gt;
</eg>
               <p>Implementations that do not recognize the namespace
                     <code>http://vendor.example.com/xslt/extensions</code> will simply ignore the
                  extra attribute, and evaluate the <elcode>xsl:message</elcode> instruction in the
                  normal way.</p>
            </example>
            <p>
               <error spec="XT" type="static" class="SE" code="0090">
                  <p>It is a <termref def="dt-static-error">static error</termref> for an element
                     from the XSLT namespace to have an attribute whose namespace is either null
                     (that is, an attribute with an unprefixed name) or the XSLT namespace, other
                     than attributes defined for the element in this document.</p>
               </error>
            </p>
         </div2>
         <div2 id="xslt-media-type">
            <head>XSLT Media Type</head>
            <p>The media type <code>application/xslt+xml</code>
               has been registered for XSLT stylesheet
               modules.</p>
            <p>The definition of the media type is at <bibref ref="XSLT-Mime-Type"/>.</p>
            <p>This media type <rfc2119>should</rfc2119> be used for an XML document containing a
                  <termref def="dt-standard-stylesheet-module">standard stylesheet module</termref>
               at its top level, and it <rfc2119>may</rfc2119> also be used for a <termref def="dt-simplified-stylesheet-module">simplified stylesheet module</termref>. It
                  <rfc2119>should not</rfc2119> be used for an XML document containing an <termref def="dt-embedded-stylesheet-module">embedded stylesheet module</termref>.</p>
         </div2>
         <div2 id="standard-attributes">
            <head>Standard Attributes</head>
            <p>
               <termdef id="dt-standard-attributes" term="standard attributes">There are a number of
                     <term>standard attributes</term> that may appear on any <termref def="dt-xslt-element">XSLT element</termref>: specifically
                     <code>default-collation</code>, 
                     <code diff="add" at="A">default-element-namespace</code>, 
                     <code>default-mode</code>,
                     <code diff="add" at="A">default-type-namespace</code>, 
                     <code>default-validation</code>,
                     <code>exclude-result-prefixes</code>, <code>expand-text</code>, <code>extension-element-prefixes</code>,
                     <code>use-when</code>, <code>version</code>, and
                     <code>xpath-default-namespace</code>.</termdef>
            </p>
            <p>These attributes may also appear on a <termref def="dt-literal-result-element">literal result element</termref>, but in this case, to distinguish them from
               user-defined attributes, the names of the attributes are in the <termref def="dt-xslt-namespace">XSLT namespace</termref>. They are thus typically written
               as <code>xsl:default-collation</code>,
               <code diff="add" at="A">xsl:default-element-namespace</code>,
               <code>xsl:default-mode</code>, 
               <code diff="add" at="A">xsl:default-type-namespace</code>,
               <code>xsl:default-validation</code>,
                  <code>xsl:exclude-result-prefixes</code>, <code>xsl:expand-text</code>, 
               <code>xsl:extension-element-prefixes</code>, <code>xsl:use-when</code>,
                  <code>xsl:version</code>, or <code>xsl:xpath-default-namespace</code>.</p>
            <p>It is <rfc2119>recommended</rfc2119> that all these attributes should also be
               permitted on <termref def="dt-extension-instruction">extension
               instructions</termref>, but this is at the discretion of the implementer of each
               extension instruction. They <rfc2119>may</rfc2119> also be permitted on <termref def="dt-data-element">user-defined data elements</termref>, though they will only
               have any useful effect in the case of data elements that are designed to behave like
               XSLT declarations or instructions.</p>
            <p>In the following descriptions, these attributes are referred to generically as
                  <code>[xsl:]version</code>, and so on.</p>
            <p>These attributes all affect the element they appear on, together with any elements
               and attributes that have that element as an ancestor. The two forms with and without
               the XSLT namespace have the same effect; the XSLT namespace is used for the attribute
               if and only if its parent element is <emph>not</emph> in the XSLT namespace.</p>
            <p>In the case of <code>[xsl:]default-collation</code>, 
               <code diff="add" at="A">[xsl:]default-element-namespace</code>,
               <code diff="add" at="A">[xsl:]default-type-namespace</code>, 
               <code>[xsl:]expand-text</code>, 
               <code>[xsl:]version</code>, and <code>[xsl:]xpath-default-namespace</code>, the value
               can be overridden by a different value for the same attribute appearing on a
               descendant element. The effective value of the attribute for a particular stylesheet
               element is determined by the innermost ancestor-or-self element on which the
               attribute appears.</p>
            <p>In an <termref def="dt-embedded-stylesheet-module">embedded stylesheet
                  module</termref>, <termref def="dt-standard-attributes">standard
                  attributes</termref> appearing on ancestors of the outermost element of the
               stylesheet module have no effect.</p>
            <p>In the case of <code>[xsl:]exclude-result-prefixes</code> and
                  <code>[xsl:]extension-element-prefixes</code> the values are cumulative. For these
               attributes, the value is given as a whitespace-separated list of namespace prefixes,
               and the effective value for an element is the combined set of namespace URIs
               designated by the prefixes that appear in this attribute for that element and any of
               its ancestor elements. Again, the two forms with and without the XSLT namespace are
               equivalent.</p>
            <p>The effect of the <code>[xsl:]use-when</code> attribute is described in <specref ref="conditional-inclusion"/>.</p>
            <p>Because these attributes may appear on any <termref def="dt-xslt-element">XSLT
                  element</termref>, they are not listed in the syntax summary of each individual
               element. Instead they are listed and described in the entry for the
                  <elcode>xsl:stylesheet</elcode>, <elcode>xsl:transform</elcode>, and <elcode>xsl:package</elcode> elements only. This
               reflects the fact that these attributes are often used on the outermost element of the stylesheet, in which case they apply to
               the entire <termref def="dt-stylesheet-module"/>
               or <termref def="dt-package-manifest"/>.</p>
            <p>Note that the effect of these attributes does <emph>not</emph> extend to <termref def="dt-stylesheet-module">stylesheet modules</termref> referenced by
                  <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode> declarations, nor to packages referenced using
                     <elcode>xsl:use-package</elcode>.</p>
            <p>For the detailed effect of each attribute, see the following sections:</p>
            <glist>
               <gitem>
                  <label>
                     <code>[xsl:]default-collation</code>
                  </label>
                  <def>
                     <p>see <specref ref="default-collation-attribute"/>
                     </p>
                  </def>
               </gitem>
               <gitem diff="add" at="A">
                  <label>
                     <code>[xsl:]default-element-namespace</code>
                  </label>
                  <def>
                     <p>see <specref ref="unprefixed-qnames"/>
                     </p>
                  </def>
               </gitem>
               
               <gitem>
                  <label>
                     <code>[xsl:]default-mode</code>
                  </label>
                  <def>
                     <p>see <specref ref="default-mode"/>
                     </p>
                  </def>
               </gitem>
               <gitem diff="add" at="A">
                  <label>
                     <code>[xsl:]default-type-namespace</code>
                  </label>
                  <def>
                     <p>see <specref ref="unprefixed-qnames"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]default-validation</code>
                  </label>
                  <def>
                     <p>see <specref ref="validation"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]exclude-result-prefixes</code>
                  </label>
                  <def>
                     <p>see <specref ref="lre-namespaces"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]expand-text</code>
                  </label>
                  <def>
                     <p>see <specref ref="text-value-templates"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]extension-element-prefixes</code>
                  </label>
                  <def>
                     <p>see <specref ref="extension-instruction"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]use-when</code>
                  </label>
                  <def>
                     <p>see <specref ref="conditional-inclusion"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]version</code>
                  </label>
                  <def>
                     <p>see <specref ref="backwards"/> and <specref ref="forwards"/>
                     </p>
                  </def>
               </gitem>
               <gitem>
                  <label>
                     <code>[xsl:]xpath-default-namespace</code>
                  </label>
                  <def>
                     <p>see <specref ref="unprefixed-qnames"/>
                     </p>
                  </def>
               </gitem>

            </glist>
         </div2>
         <div2 id="packages">
            <head>Packages</head>

            <p><termdef id="dt-package" term="package">An explicit <term>package</term> is
                  represented by an <elcode>xsl:package</elcode> element, which will generally be
                  the outermost element of an XML document. When the
                        <elcode>xsl:package</elcode> element is not used explicitly, the entire
                     stylesheet comprises a single implicit package.</termdef> (This
               specification does not preclude the <elcode>xsl:package</elcode> being embedded in
               another XML document, but it will never have any other XSLT element as an
               ancestor).</p>

            <?element xsl:package?>

            <p><termdef id="dt-package-manifest" term="package manifest">The content of the
                     <elcode>xsl:package</elcode> element is referred to as the <term>package
                     manifest</term></termdef>.</p>

            <p>The <code>version</code> attribute indicates the
               version of the XSLT language specification to which the package manifest conforms.
                  The value <rfc2119>should</rfc2119> normally be
                     <code>3.0</code>. If the value is numerically less than <code>3.0</code>, the
                  content of the <elcode>xsl:package</elcode> element is processed using the rules
                  for <termref def="dt-backwards-compatible-behavior">backwards compatible
                     behavior</termref> (see <specref ref="backwards"/>). If the value is
                  numerically greater than <code>3.0</code>, it is processed using the rules for
                     <termref def="dt-forwards-compatible-behavior"/> (see <specref ref="forwards"/>).</p>


            <p>A package typically has a name, given in its <code>name</code>
               attribute, which <rfc2119>must</rfc2119> be an absolute URI. Unnamed packages are
               allowed, but they can only be used as the “top level” of an application; they cannot
               be the target of an <elcode>xsl:use-package</elcode> declaration in another
               package.</p>

            <p>A package may have a version identifier, given in
               its <code>package-version</code> attribute. This is used to distinguish different
               versions of a package. The value of the version
                  attribute, after trimming leading and trailing whitespace, <rfc2119>must</rfc2119>
                  conform to the syntax given in <specref ref="package-versions"/>. If no version
                  number is specified for a package, version <code>1</code> is assumed.</p>

            <p>The attributes <code>default-collation</code>, <code>default-mode</code>, <code>default-validation</code>,
                  <code>exclude-result-prefixes</code>, <code>expand-text</code>,
                  <code>extension-element-prefixes</code>, <code>use-when</code>,
                  <code>version</code>, and <code>xpath-default-namespace</code> are standard
               attributes that can appear on any XSLT element, and potentially affect all descendant
               elements. Their meaning is described in <specref ref="standard-attributes"/>.</p>

            <p>The package manifest contains the following
                  elements, arbitrarily ordered:</p>
            <olist>
               <item>
                  <p>Zero or more <elcode>xsl:expose</elcode> declarations that define the interface
                     offered by this package to the outside world. An <elcode>xsl:expose</elcode>
                  declaration may appear only as a child of <elcode>xsl:package</elcode>.</p>
               </item>
               <item>
                  <p>Zero or more additional <termref def="dt-declaration">declarations</termref>.
                     These are the same as the declarations permitted as children of <elcode>xsl:stylesheet</elcode>
                     or <elcode>xsl:transform</elcode>.</p> 
                  <p>Some declarations of particular relevance to packages include:</p>
                  <olist>
                     <item><p>The <elcode>xsl:use-package</elcode> declaration, which declares the names and
                     versions of the packages on which this package is dependant.</p></item>
                     <item>
                        <p>The optional <elcode>xsl:global-context-item</elcode> element; if present this
                           element defines constraints on the existence and type of the <termref def="dt-global-context-item"/>.</p>
                     </item>
                     <item><p>Zero or more <elcode>xsl:include</elcode> and <elcode>xsl:import</elcode>
                     declarations, which define additional stylesheet modules to be incorporated into this package.</p></item>
                     <item><p>Zero or more ordinary <termref def="dt-declaration">declarations</termref>, that is,
                        elements that are permitted as children of <elcode>xsl:stylesheet</elcode> or
                        <elcode>xsl:transform</elcode>. One possible coding style is to include in
                        the package manifest just a single <elcode>xsl:import</elcode> or
                        <elcode>xsl:include</elcode> declaration as a reference to the effective
                        top-level stylesheet module; this approach is particularly suitable when
                        writing code that is required to run under earlier releases of XSLT as well as
                        under XSLT 3.0. Another approach is to include the substance of the top-level
                        stylesheet module inline within the package manifest.</p></item>
                  </olist>
               </item>

            </olist>

            <example>
               <head>An example package</head>
               <p>The following example shows a package that offers a number of functions for
                  manipulating complex numbers. A complex number is represented as a map with two
                  entries, the keys being 0 for the real part, and 1 for the imaginary part.</p>
               

               <eg role="xslt-document" xml:space="preserve">
&lt;xsl:package
  name="http://example.org/complex-arithmetic.xsl"
  package-version="1.0"
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:f="http://example.org/complex-arithmetic.xsl"&gt;
  
  &lt;xsl:function name="f:complex-number" 
                as="map(xs:integer, xs:double)" visibility="public"&gt;
    &lt;xsl:param name="real" as="xs:double"/&gt;
    &lt;xsl:param name="imaginary" as="xs:double"/&gt;
    &lt;xsl:sequence select="map{ 0:$real, 1:$imaginary }"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:real" 
                as="xs:double" visibility="public"&gt;
    &lt;xsl:param name="complex" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="$complex(0)"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:imag" 
                as="xs:double" visibility="public"&gt;
    &lt;xsl:param name="complex" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="$complex(1)"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:add" 
                as="map(xs:integer, xs:double)" visibility="public"&gt;
    &lt;xsl:param name="x" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:param name="y" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="
         f:complex-number(
           f:real($x) + f:real($y), 
           f:imag($x) + f:imag($y))"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:multiply" 
                as="map(xs:integer, xs:double)" visibility="public"&gt;
    &lt;xsl:param name="x" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:param name="y" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="
         f:complex-number(
           f:real($x)*f:real($y) - f:imag($x)*f:imag($y),
           f:real($x)*f:imag($y) + f:imag($x)*f:real($y))"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;!-- etc. --&gt;
  
&lt;/xsl:package&gt;</eg>

               <p>A more complex package might include private or abstract functions as well as
                  public functions; it might expose components other than functions (for example,
                  templates or global variables), and it might contain
                     <elcode>xsl:use-package</elcode> elements to allow it to call on the services
                  of other packages.</p>

               <note>
                  <p>In this example, the way in which complex numbers are represented is exposed to
                     users of the package. It would be possible to hide the representation by
                     declaring the types on public functions simply as <code>item()</code>; but this
                     would be at the cost of type safety.</p>
               </note>
            </example>



            <p>A package that does not itself expose any components  may be written
               using a simplified syntax: the <elcode>xsl:package</elcode> element is omitted, and
               the <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element is now
               the outermost element of the stylesheet module. For compatibility reasons, all the
               named templates and modes declared in the package are made public. More formally, the
               principal stylesheet module of the <termref def="dt-top-level-package">top-level
                  package</termref> may be expressed as an <elcode>xsl:stylesheet</elcode> or
                  <elcode>xsl:transform</elcode> element, which is equivalent to the package represented
               by the output of the following transformation, preserving the base URI of the
               source:</p>

            <eg role="xslt-document" xml:space="preserve">
 &lt;xsl:transform version="3.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:t="http://www.w3.org/1999/XSL/TransformAlias"&gt;
 
    &lt;xsl:namespace-alias stylesheet-prefix="t" result-prefix="xsl"/&gt;
    
    &lt;xsl:template match="xsl:stylesheet|xsl:transform"&gt;
      &lt;t:package declared-modes="no"&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        &lt;t:expose component="mode" names="*" visibility="public"/&gt;
        &lt;t:expose component="template" names="*" visibility="public"/&gt;
        &lt;xsl:copy-of select="node()"/&gt;
      &lt;/t:package&gt;
    &lt;/xsl:template&gt;
 &lt;/xsl:transform&gt;
       </eg>

            <p>The effect of the <code>input-type-annotations</code>
               attribute is defined in <specref ref="stripping-annotations"/>.</p>


            <p>A more extensive example of a package, illustrating how components
               in a package can be overridden in a client package, is given in <specref ref="packages-csv-library-example"/>.</p>


            <div3 id="package-versions">
               <head>Versions of a Package</head>

               <p>If a package has a version number, the version number must conform to the
                  grammar:</p>

               <eg role="non-xml" xml:space="preserve">
        PackageVersion   ::= NumericPart ( "-" NamePart )?
        NumericPart      ::= IntegerLiteral ( "." IntegerLiteral )*
        NamePart         ::= NCName
               </eg>

 

               <p>Here <xnt ref="prod-xpath40-IntegerLiteral" spec="XP40">IntegerLiteral</xnt> and <code>NCName</code> are as defined in
                     the XPath 3.0 grammar productions of the same name (including rules on
                     limits). Leading and trailing whitespace is ignored; no other
                  whitespace is allowed.</p>
               <p>Examples of valid version numbers are <code>2.0.5</code> or
                     <code>3.10-alpha</code>.</p>
               <p><termdef id="dt-portion" term="portion">The integer literals and the optional
                        <code>NamePart</code> within the version number are referred to as the
                        <term>portions</term> of the version number.</termdef></p>

               <note>
                  <p>This means that <code>1-alpha-2</code> is a valid version number, with two
                        <termref def="dt-portion">portions</termref>: <code>1</code> and
                        <code>alpha-2</code>. The second hyphen is part of the <code>NCName</code>,
                     it does not act as a portion separator.</p>
               </note>

               <p>Versions are ordered. When comparing two versions:</p>
               <olist>
                  <item>
                     <p>Trailing zero <termref def="dt-portion">portions</termref> (that is, any
                        zero-valued integer that is not followed by another integer) are
                        discarded.</p>
                  </item>
                  <item>
                     <p>Comparison proceeds by comparing <termref def="dt-portion">portions</termref> pairwise from the left.</p>
                  </item>
                  <item>
                     <p>If both versions have the same number of <termref def="dt-portion">portions</termref> and all <termref def="dt-portion">portions</termref>
                        compare equal (under the rules of the
                           XPath <code>eq</code> operator using the Unicode codepoint
                           collation), then the versions compare equal.</p>
                  </item>
                  <item>
                     <p>If the number of <termref def="dt-portion">portions</termref> in the two
                        versions <var>V1</var> and <var>V2</var> is <var>N1</var> and <var>N2</var>,
                        with <var>N1</var>&lt;<var>N2</var>, and if all <termref def="dt-portion">portions</termref> in positions 1 to <var>N</var> compare equal, then
                           <var>V1</var> is less than <var>V2</var> if the <termref def="dt-portion"/> of <var>V2</var> in position <var>N1+1</var> is an integer, and is
                        greater than <var>V2</var> if this <termref def="dt-portion"/> is an
                           <code>NCName</code>. For example, <code>1.2</code> is less than
                           <code>1.2.5</code>, while <code>2.0</code> is greater than
                           <code>2.0-rc1</code>.</p>
                  </item>
                  <item>
                     <p><termref def="dt-portion">Portions</termref> are compared as follows:</p>
                     <olist>
                        <item>
                           <p>If both <termref def="dt-portion">portions</termref> are integers,
                              they are compared using the rules
                                 of XPath value comparisons.</p>
                        </item>
                        <item>
                           <p>If both <termref def="dt-portion">portions</termref> are NCNames, they
                              are compared using the rules of
                                 XPath value comparisons, using the Unicode Codepoint
                              Collation.</p>
                        </item>
                        <item>
                           <p>If one <termref def="dt-portion"/> is an integer and the other is an
                                 <code>NCName</code>, the <code>NCName</code> comes first.</p>
                        </item>
                     </olist>
                  </item>

               </olist>

               <p>For example, the following shows a possible ordered sequence of version
                  numbers:</p>

               <eg role="non-xml" xml:space="preserve">0-rc1 &lt; 0-rc2 &lt; 0 &lt; 1 = 1.0 &lt; 1.0.2 
   &lt; 1.0.3-rc1 &lt; 1.0.3 &lt; 1.0.3.2 &lt; 1.0.10</eg>

               <note>
                  <p>The version number format defined here is designed to be general enough to
                     accommodate a variety of conventions in common use, and to allow useful
                     semantics for matching of versions and ranges of versions, without being
                     over-prescriptive. It is influenced by <bibref ref="SemVer"/>, but is not as
                     prescriptive, and it imposes no assumptions about backwards compatibility of
                     packages between successive versions.</p>
               </note>
               
               <p>Implementations <rfc2119>may</rfc2119> impose limits on the values
               used in a version number (or a version range: see below). Such limits are
               <termref def="dt-implementation-defined"/>. As a minimum, 
               a processor <rfc2119>must</rfc2119> accept version numbers including:</p>
               
               <ulist>
                  <item><p>A numeric part containing four integers;</p></item>
                  <item><p>Each integer being in the range 0 to 999999;</p></item>
                  <item><p>An <code>NCName</code> of up to 100 characters</p></item>
               </ulist>

               <p>Dependencies between packages may specify a version range (see <specref ref="package-dependencies"/>). A version range represents a set of accepted
                  versions. The syntax of a version range is
                     shown below. Whitespace is permitted only where indicated, using the terminal
                     symbol <var>S</var>.</p>

               <eg role="non-xml" xml:space="preserve">
        PackageVersionRange    ::=  AnyVersion | VersionRanges
        AnyVersion             ::=  "*"
        VersionRanges          ::=  VersionRange (S? "," S? VersionRange)*
        VersionRange           ::=  PackageVersion | VersionPrefix | 
                                      VersionFrom | VersionTo | VersionFromTo
        VersionPrefix          ::=  PackageVersion ".*"
        VersionFrom            ::=  PackageVersion "+"
        VersionTo              ::=  "to" S (PackageVersion | VersionPrefix)
        VersionFromTo          ::=  PackageVersion S "to" S (PackageVersion | VersionPrefix)     
               </eg>

               

               <p>The meanings of the various forms of version range are
                  defined below:</p>

               <ulist>
                  <item>
                     <p>The range <code>AnyVersion</code> matches any version.</p>
                  </item>

                  <item>
                     <p>The range <code>VersionRanges</code> matches a version if any constituent
                           <code>VersionRange</code> matches that version.</p>
                     <p>For example, <code>9.5.0.8, 9.6.1.2</code>
                        matches those specific versions only, while <code>9.5.0.8, 9.6+</code>
                        matches either version 9.5.0.8 or any version from 9.6 onwards.</p>
                  </item>

                  <item>
                     <p>A range that is a <code>PackageVersion</code> matches that version only.</p>
                  </item>

                  <item>
                     <p>The range <code>VersionPrefix</code> matches any version whose leading
                           <termref def="dt-portion">portions</termref> are the same as the <termref def="dt-portion">portions</termref> in the <code>PackageVersion</code> part of the
                              <code>VersionPrefix</code>.</p>
                     <p>For example, <code>1.3.*</code> matches <code>1.3</code>, 
                           <code>1.3.5</code>,  <code>1.3.10.2</code>,  and
                           <code>1.3-beta</code>
                        (but not <code>1</code> or
                              <code>1.4</code>).</p>

                     <note>
                        <p>The <code>.*</code> indicates that additional <termref def="dt-portion">portions</termref> may follow; it does not indicate a substring match
                           on the final <termref def="dt-portion">portion</termref>. So
                              <code>1.3.*</code> does not match <code>1.35</code>, and
                              <code>3.3-beta.*</code> does not match <code>3.3-beta12</code>. Also,
                              <code>3.3-beta.*</code> does not match <code>3.3-beta.5</code>: this
                           is because the last dot is not a portion separator, but is part of the
                           final <code>NCName</code>. In fact, using <code>.*</code> after a version
                           number that includes an <code>NCName</code> portion is pointless, because
                           an <code>NCName</code> portion can never be followed by further
                           portions.</p>
                     </note>

                  </item>

                  <item>
                     <p>The range <code>VersionFrom</code> matches any version that is greater than
                        or equal to the version supplied.</p>
                     <p>For example <code>1.3+</code> matches
                           <code>1.3</code>,  <code>1.3.2</code>,  <code>1.4</code>, 
                        and <code>2.1</code> (but not <code>1.3-beta</code> or <code>1.2</code>).
                        And <code>1.3-beta+</code> matches <code>1.3-beta</code>, 
                           <code>1.3-gamma</code>,  <code>1.3.0</code>,  <code>1.4</code>,
                        and <code>8.0</code>, but not <code>1.3-alpha</code> or
                        <code>1.2</code>.</p>
                  </item>

                  <item>
                     <p>The range <code>VersionTo</code> matches any version that is less than or
                        equal to some version that matches the <code>VersionPrefix</code>.</p>
                     <p>For example, <code>to 4.0</code> matches <code>1.5</code>, 
                           <code>2.3</code>,  <code>3.8</code>,  <code>4.0</code>, 
                        and <code>4.0-beta</code> (but not <code>4.0.1</code>), while <code>to
                           3.3.*</code> matches <code>1.5</code> or <code>2.0.6</code> or
                           <code>3.3.4621</code>, but not <code>3.4.0</code> or
                           <code>3.4.0-beta</code>. </p>
                  </item>

                  <item>
                     <p>The range <code>VersionFromTo</code> matches any version that is greater
                        than or equal to the starting <code>PackageVersion</code>, and less than or
                        equal to some version that matches the <code>VersionPrefix</code>.</p>
                     <p>For example, <code>1 to 5</code> matches <code>1.1</code>, 
                           <code>2.1</code>,  <code>3.1</code>,  or <code>5.0</code> (but
                        not <code>5.1</code>), while <code>1 to 5.*</code> matches all of these,
                        plus versions such as <code>5.7.2</code> (but not <code>6.0</code> or
                           <code>6.0-beta</code>). Similarly,
                              <code>1.0-beta to 1.0</code> matches <code>1.0-beta</code>,
                              <code>1.0-beta.2</code>, <code>1.0-gamma</code>, and <code>1.0</code>,
                           but not <code>1.0-alpha</code> or <code>1.0.1</code>.</p>
                  </item>

               </ulist>



            </div3>

            <div3 id="package-dependencies">
               <head>Dependencies between Packages</head>

               <p>When <termref def="dt-component">components</termref> in one <termref def="dt-package"/> reference components in another, the dependency of the first
                  package on the second must be represented by an <elcode>xsl:use-package</elcode>
                  element. This may appear in the <termref def="dt-principal-stylesheet-module"/>
               of the first package (which may be a <termref def="dt-package-manifest"/>), or
               it may appear in a <termref def="dt-stylesheet-module"/> that is referenced from
                  the <termref def="dt-principal-stylesheet-module"/> via one or more
               <elcode>xsl:include</elcode> declarations; however it must not be referenced
               via <elcode>xsl:import</elcode> declarations (this is to avoid complications
                     caused by multiple <elcode>xsl:use-package</elcode> declarations with
                     different <termref def="dt-import-precedence"/>).</p>

               <p><termdef id="dt-use" term="use">If a package <var>Q</var> contains an
                        <elcode>xsl:use-package</elcode> element that references package
                        <var>P</var>, then package <var>Q</var> is said to <term>use</term> package
                        <var>P</var>. In this relationship package <var>Q</var> is referred to as
                     the <term>using</term> package, package <var>P</var> as the <term>used</term>
                     package.</termdef></p>

               <p>The phrase <term>directly uses</term> is synonymous with <term>uses</term> as
                  defined above, while <term>directly or indirectly uses</term> refers to the
                  transitive closure of this relationship.</p>



               <?element xsl:use-package?>

               <p>A <termref def="dt-package">package</termref> may be <termref def="dt-use">used</termref> by more than one other package, but the relationship
                     <rfc2119>must not</rfc2119> be cyclic. It is possible, but by no means
                  inevitable, that using the same package in more than one place within a stylesheet
                  will cause static errors due to the presence of conflicting components according
                  to the above rules. Where a package is successfully used by more than one other
                  package, its components may be overridden in different ways by different using
                  packages.</p>



               <p>The <code>name</code> and <code>package-version</code> attributes together
                  identify the used package. The value of the
                        <code>package-version</code> attribute, if present, must conform to the
                     rules for a <code>PackageVersionRange</code> given in <specref ref="package-versions"/>; if omitted the value <code>*</code> is assumed,
                     which matches any version. The used package must have a name that is an exact
                     match for the name in the <code>name</code> attribute (using codepoint
                     comparison), and its explicit or implicit <code>package-version</code> must
                     match the version range given in the <code>package-version</code>
                     attribute.</p>

               

               <p>This specification does not define how the implementation locates a package given
                  its name and version. If several matching
                     versions of a package are available, it does not define which of them is
                     chosen. Nor does it define whether this process locates source code or
                  some other representation of the package contents. Such mechanisms are <termref def="dt-implementation-defined"/>. Use of the package name as a dereferenceable
                  URI is <rfc2119>not recommended</rfc2119>, because the intent of the packaging
                  feature is to allow a package to be distributed as reusable code and therefore to
                  exist in many different locations.</p>

               <imp-def-feature id="idf-api-packageversions">It is <termref def="dt-implementation-defined"/> how a package is located given its name and
                  version, and which version of a package is chosen if several are
                  available.</imp-def-feature>

               <p><error spec="XT" type="static" class="SE" code="3000">
                     <p>It is a <termref def="dt-static-error"/> if no package matching the package
                        name and version specified in an <elcode>xsl:use-package</elcode>
                        declaration can be located.</p>
                  </error></p>

               <p><error spec="XT" type="static" class="SE" code="3005">
                     <p>It is a <termref def="dt-static-error"/> if a package is dependent on
                        itself, where package <var>A</var> is defined as being dependent on package
                           <var>B</var> if <var>A</var> contains an <elcode>xsl:use-package</elcode>
                        declaration that references <var>B</var>, or if <var>A</var> contains an
                           <elcode>xsl:use-package</elcode> declaration that references a package
                           <var>C</var> that is itself dependent on <var>B</var>.</p>
                  </error></p>
               
               <p><error spec="XT" type="static" class="SE" code="3008">
                  <p>It is a <termref def="dt-static-error"/> if an <elcode>xsl:use-package</elcode>
                  declaration appears in a <termref def="dt-stylesheet-module"/> that is not in the
                  same <termref def="dt-stylesheet-level"/> as the <termref def="dt-principal-stylesheet-module"/>
                  of the <termref def="dt-package"/>.</p>
               </error></p>

               <note>
                  <p>Depending on the implementation architecture, there may be a need to locate
                     used packages both during static analysis (for example, to get information
                     about the names and type signatures of the components exposed by the used
                     package), and also at evaluation time (to link to the implementation of these
                     components so they can be invoked). A failure to locate a package may cause an
                     error at either stage.</p>
               </note>



               <p>The <elcode>xsl:accept</elcode> and <elcode>xsl:override</elcode> elements are
                  used to modify the visibility or behavior of components acquired from the used
                  package; they are described in <specref ref="accepting-components"/> below.</p>

               
               
               <note>
                  <p>It is not intrinsically an error to have two 
                  <elcode>xsl:use-package</elcode> declarations that identify the same package
                  (or different versions of the same package). This has the same effect as
                  having two declarations that identify packages with different names but
                  identical content. In most cases it will result in an error (<errorref spec="XT" class="SE" code="3050"/>)
                  due to the presence of multiple components with the same name; but 
                  no error would occur, for example, if the used package is empty, or if the 
                  two <elcode>xsl:use-package</elcode> declarations use <elcode>xsl:accept</elcode>
                  to accept non-overlapping subsets of the components in the used package.</p>
               </note>

            </div3>

            <div3 id="named-components">
               <head>Named Components in Packages</head>

               <p>This section discusses the use of named components in packages.</p>

               <p>The components which can be declared in one package and
                  referenced in another are: <termref def="dt-stylesheet-function">functions</termref>, <termref def="dt-named-template">named
                     templates</termref>, <termref def="dt-attribute-set">attribute sets</termref>,
                     <termref def="dt-mode">modes</termref>,  and <termref def="dt-global-variable">global variables</termref> and <termref def="dt-stylesheet-parameter">parameters</termref>.</p>

               <p>In addition, <termref def="dt-key">keys</termref> and <termref def="dt-accumulator">accumulators</termref>
                  are classified as named components because they can contain references to
                  components in another package, even though they cannot themselves be referenced
                  from outside the package.</p>



               <p>Named and unnamed <termref def="dt-mode">modes</termref> come within the scope of this section, but there are
                  differences noted in <specref ref="modes-and-packages"/>.</p>

               <p>Not all <termref def="dt-declaration">declarations</termref> result in <termref def="dt-component">components</termref>:</p>

               <ulist>
                  <item>
                     <p>Named <termref def="dt-declaration">declarations</termref> that can neither be referenced from outside their
                        containing package, nor can contain references to components in other
                        packages (examples are <elcode>xsl:output</elcode>,
                           <elcode>xsl:character-map</elcode>, and
                           <elcode>xsl:decimal-format</elcode>) are not considered to be components
                        and are therefore outside the scope of this section.</p>
                  </item>
                  <item>
                     <p>Some declarations, such as <elcode>xsl:decimal-format</elcode> and
                           <elcode>xsl:strip-space</elcode>, declare aspects of the processing
                        context which are not considered to be components as defined here.</p>
                  </item>
                  <item>
                     <p><termref def="dt-template-rule">Template rules</termref>
                           (<elcode>xsl:template</elcode> with a <code>match</code> attribute) are
                        also not considered to be components for the purposes of this section, which
                        is concerned only with components that are bound by name. However, when an
                           <elcode>xsl:template</elcode> has both a <code>match</code> attribute and
                        a <code>name</code> attribute, then it establishes both a template rule and
                        a <termref def="dt-named-template">named template</termref>, and in its role
                        as a named template it comes within the scope of this discussion.</p>
                  </item>
                  <item>
                     <p>A named declaration, for example a named template, a function, 
                         or a global
                        variable, may be overridden within the same package by another like-named
                        declaration having higher <termref def="dt-import-precedence">import
                           precedence</termref>. When a declaration is overridden in this way it cannot
                        be referenced by name either from within its containing package or
                        from outside that package. </p>
                  </item>
                  <item>
                     <p>In the case of <elcode>xsl:attribute-set</elcode>
                        and <elcode>xsl:key</elcode> declarations, several declarations combine to
                        form a single component.</p>
                  </item>
               </ulist>

               <p>The section is largely concerned with details of the rules that affect references
                  from one component to another by name, whether the components are in the same
                  package or in different packages. The rules are designed to meet a number of
                  requirements:</p>

               <ulist>
                  <item>
                     <p>A component defined in one package can be overridden by a component in
                        another package, provided the signatures are type-compatible.</p>
                  </item>
                  <item>
                     <p>The author of a package can declare whether the components in the package
                        are public or private (that is, whether or not they can be used from outside
                        the package) and whether they are final, overridable, or abstract (that is
                        whether they can or must be overridden by the using package).</p>
                  </item>
                  <item>
                     <p>Within an application, two packages can make use of a common library and
                        override its components in different ways.</p>
                  </item>
                  <item>
                     <p>Visibility of components can be defined either as part of the declaration of
                        the component, or in the package manifest.</p>
                  </item>
                  <item>
                     <p>An application that wishes to make use of a <termref def="dt-library-package">library package</termref> can be selective about
                        which components from the library it acquires, perhaps to avoid name clashes
                        between components acquired from different libraries.</p>
                  </item>
               </ulist>


               <p><termdef id="dt-component" term="component">The term <term>component</term> is
                     used to refer to any of the following: a <termref def="dt-stylesheet-function">stylesheet function</termref>, a <termref def="dt-named-template">named
                        template</termref>, a <termref def="dt-mode">mode</termref>, an <termref def="dt-accumulator-function">accumulator</termref>, an <termref def="dt-attribute-set">attribute set</termref>, a <termref def="dt-key">key</termref>, <termref def="dt-global-variable">global variable</termref>, or a <termref def="dt-mode">mode</termref>.</termdef></p>

               <p><termdef id="dt-symbolic-identifier" term="symbolic identifier">The <term>symbolic
                        identifier</term> of a <termref def="dt-component">component</termref> is a
                     composite name used to identify the component uniquely within a package. The
                     symbolic identifier comprises the kind of component (stylesheet function, named
                     template, accumulator, attribute set, global
                     variable, key, or mode), the <termref def="dt-expanded-qname">expanded
                        QName</termref> of the component (namespace URI plus local name), and in the
                     case of stylesheet functions, the <termref def="dt-arity">arity</termref>.</termdef></p>

               <note>
                  <p>In the case of the <termref def="dt-unnamed-mode"/>,
                     the expanded QName of the component may be considered to be some
                     system-allocated name different from any user-defined mode name.</p>
               </note>

               <p><termdef id="dt-homonymous" term="homonymous">Two <termref def="dt-component">components</termref> are said to be <term>homonymous</term> if they have
                     the same <termref def="dt-symbolic-identifier">symbolic
                     identifier</termref>.</termdef></p>

               <p>Every <termref def="dt-component">component</termref> has a <termref def="dt-declaration">declaration</termref> in some <termref def="dt-stylesheet-module"/> and therefore within some <termref def="dt-package">package</termref>. In the
                     case of <termref def="dt-attribute-set">attribute sets</termref> and <termref def="dt-key">keys</termref>, there may be several declarations. The
                  declaration is an element in an XDM tree representing the stylesheet module.
                  Declarations therefore have identity, based on XDM node identity.</p>





               <!--<p><termdef id="dt-original-identity" term="original identity">The <term>original identity</term>
            of a <termref def="dt-component">component</termref> is the XDM node identity of the element
               acting as the <termref def="dt-declaration">declaration</termref> of the component.</termdef></p>-->

               <!--<p>A component is originally declared within one package, and this declaration determines the original
            identity of the component. Each package that directly or indirectly uses this package contains 
            information about the component called a <termref def="dt-component-occurrence">component occurrence</termref>.
            </p>-->

               <p><termdef id="dt-declaring-package" term="declaring package">The <term>declaring
                        package</term> of a <termref def="dt-component">component</termref> is the
                     package that contains the declaration (or,
                        in the case of <elcode>xsl:attribute-set</elcode> and
                           <elcode>xsl:key</elcode>, multiple declarations) of the
                     component.</termdef></p>

               <p>When a <termref def="dt-component">component</termref> declared in one <termref def="dt-package">package</termref> is made available in another, the using
                  package will contain a separate component that can be regarded as a modified copy
                  of the original. The new component shares the same <termref def="dt-symbolic-identifier">symbolic identifier</termref> as the original, and
                  it has the same <termref def="dt-declaration">declaration</termref>, but it has
                  other properties such as its <termref def="dt-visibility">visibility</termref>
                  that may differ from the original.</p>

               <p><termdef id="dt-containing-package" term="containing package">A
                     component declaration results in multiple components, one in the package in
                     which the declaration appears, and potentially one in each package that uses
                     the declaring package, directly or indirectly, subject to the visibility of the
                     component. Each of these multiple components has the same <termref def="dt-declaring-package"/>, but each has a different <term>containing
                        package</term>. For the original component, the declaring package and the
                     containing package are the same; for a copy of a component made as a result of
                     an <elcode>xsl:use-package</elcode> declaration, the declaring package will be
                     the original package, and the containing package will be the package in which
                     the <elcode>xsl:use-package</elcode> declaration appears.</termdef></p>

               <note>
                  <p>Within this specification, we generally use the
                     notation <var>C/P</var> for a component named C whose declaring package and
                     containing package are both <var>P</var>; and the notation <var>C/PQ</var> for
                     a component whose containing package is <var>P</var> and whose declaring
                     package is <var>Q</var> (that is, a component in <var>P</var> that is derived
                     from a component <var>C/Q</var> in the used package <var>Q</var>).</p>
               </note>

               <!--<p><termdef id="dt-component-occurrence" term="component occurrence">A <term>component occurrence</term>
            represents the availability of a particular <termref def="dt-component">component</termref> within a 
            particular <termref def="dt-package">package</termref>; for every component, there is a <term>component occurrence</term>
            of the component in its <termref def="dt-declaring-package">declaring package</termref>, 
               and one in each package that directly or indirectly
            <termref def="dt-use">uses</termref> its declaring package.</termdef></p>-->

               <p>The properties of a <termref def="dt-component">component</termref> are as
                  follows:</p>

               <ulist>
                  <item>
                     <p>The original <termref def="dt-declaration">declaration</termref> of the
                        component.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-package">package</termref> to which the component
                        belongs (called its <term>containing</term> package, not to be confused with
                        the <termref def="dt-declaring-package">declaring package</termref>).</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-symbolic-identifier">symbolic identifier</termref> of
                        the component.</p>
                  </item>

                  <item>
                     <p>The <termref def="dt-visibility">visibility</termref> of the component,
                        which determines the way in which the component is seen by other components
                        within the same package and within using packages. This is one of
                           <code>public</code>, <code>private</code>, <code>abstract</code>,
                           <code>final</code>, or <code>hidden</code>. The visibility of components
                        is discussed further in <specref ref="visibility"/>.</p>
                  </item>
                  <item>
                     <p>A set of bindings for the <termref def="dt-symbolic-reference">symbolic
                           references</termref> in the component. The way in which these bindings
                        are established is discussed further in <specref ref="component-references"/>.</p>
                  </item>
               </ulist>

               <note>
                  <p>When a function <var>F</var> defined in a package <var>P</var> is acquired by
                     two using packages <var>Q</var> and <var>R</var>, we may think of <var>P</var>,
                     <var>Q</var>, and <var>R</var> as all providing access to the “same”
                     function. The detailed semantics, however, demand an understanding that there
                     is one function declaration, but three components. The three components
                     representing the function <var>F</var> within packages <var>P</var>,
                        <var>Q</var>, and <var>R</var> have some properties in common (the same
                     symbolic identifier, the same declaration), but other properties (the
                     visibility and the bindings of symbolic references) that may vary from one of
                     these components to another.</p>
               </note>


               <p><termdef id="dt-symbolic-reference" term="symbolic reference">The <termref def="dt-declaration">declaration</termref> of a component includes
                     constructs that can be interpreted as references to other <termref def="dt-component">components</termref> by means of their <termref def="dt-symbolic-identifier">symbolic identifiers</termref>. These
                     constructs are generically referred to as <term>symbolic references</term>.
                     Examples of constructs that give rise to symbolic references are the
                        <code>name</code> attribute of <elcode>xsl:call-template</elcode>; the
                        <code>[xsl:]use-attribute-sets</code> attribute of
                     <elcode>xsl:copy</elcode>, <elcode>xsl:element</elcode>, and <termref def="dt-literal-result-element">literal result elements</termref>; the
                        explicit or implicit
                     <code>mode</code> attribute of <elcode>xsl:apply-templates</elcode>; XPath
                     variable references referring to global variables; XPath static function calls (including partial function
                        applications) referring to <termref def="dt-stylesheet-function">stylesheet functions</termref>; and
                        named function references (example: <code>my:f#1</code>) referring to
                        stylesheet functions.
                     </termdef></p>

               <p>Symbolic references exist as properties of the <termref def="dt-declaration">declaration</termref> of a <termref def="dt-component">component</termref>.
                  The <termref def="dt-symbolic-identifier">symbolic identifier</termref> being
                  referred to can be determined straightforwardly from the syntactic form and
                  context of the reference: for example, the instruction <code>&lt;xsl:value-of
                     select="f:price($o)" xmlns:f="http://f.com/"/&gt;</code> contains a symbolic
                  reference to a function with expanded name <code>{http://f.com/}price</code> and
                  with arity=1. However, because there may be several (homonymous) function
                  components with this symbolic identifier, translating this symbolic reference into
                  a reference to a specific component (a process called “binding”) is less
                  straightforward, and is described in the text that follows. </p>

               <p>The process of assembling a stylesheet from its constituent packages is primarily
                  a process of binding these symbolic references to actual components. Within any
                     <termref def="dt-component">component</termref> whose <termref def="dt-declaration">declaration</termref> is <var>D</var>, there is a set of
                  bindings; each binding is an association between a <termref def="dt-symbolic-reference">symbolic reference</termref> in <var>D</var> and a
                     <termref def="dt-component">component</termref> whose <termref def="dt-symbolic-identifier">symbolic identifier</termref> matches the outward
                  reference. Outward references for which a component <var>C</var> contains a
                  binding are said to be <term>bound</term> in <var>C</var>; those for which
                     <var>C</var> contains no binding are said to be <term>unbound</term>.</p>

               <p>For example, suppose that in some package <var>Q</var>, function <var>A</var>
                  calls <var>B</var>, which in turn calls <var>C</var>, and that <var>B</var> is
                     <code>private</code>. Now suppose that in some package <var>P</var> which uses
                     <var>Q</var>, <var>C</var> is overridden. The effect of the binding process is
                  that <var>P</var> will contain three components corresponding to <var>A</var>,
                     <var>B</var>, and <var>C</var>, which we might call <var>A/P</var>,
                     <var>B/P</var>, and <var>C/P</var>. The <termref def="dt-declaration">declarations</termref> of <var>A/P</var> and <var>B/P</var> are in package
                     <var>Q</var>, but the declaration of <var>C/P</var> is in <var>P</var>. The
                  internal visibility of <var>B/P</var> will be <code>hidden</code> (meaning that it
                  cannot be referenced from within <var>P</var>), and <var>B/P</var> will contain a
                  binding for the component <var>C/P</var> that corresponds to the outward reference
                  from <var>B</var> to <var>C</var>. The effect is that when <var>A</var> calls
                     <var>B</var> and <var>B</var> calls <var>C</var>, it is the overriding version
                  of <var>C</var> that is executed.</p>

               <p>In another package <var>R</var> that uses <var>Q</var> without overriding
                     <var>C</var>, there will be three different components <var>A/R</var>,
                     <var>B/R</var>, and <var>C/R</var>. This time the declaration of all three
                  components is in the original package <var>Q</var>. Component <var>B/R</var> will
                  contain a binding to <var>C/R</var>, so in this package, the original version of
                     <var>C</var> is executed. The fact that one package <var>P</var> overrides
                     <var>C</var> thus has no effect on <var>R</var>, which does not override
                  it.</p>

               <p>The binding process outlined above is described in more detail in <specref ref="component-references"/>.</p>

               <p>Template rules are not components in their own right;
                  unlike named templates, they are never referenced by name. Component references
                  within a template rule (for example, references to functions, global variables, or
                  named templates) are treated as occurring within the component that represents the
                  containing mode. This includes component references within the match patterns of
                  template rules. If a template rule lists several modes, it is treated as if there
                  were multiple template rules one in each mode.</p>

               <p>An <elcode>xsl:apply-templates</elcode> instruction
                  with no <code>mode</code> attribute is treated as a reference to the default mode
                  defined for that <termref def="dt-instruction"/> (see <specref ref="default-mode"/>), which in turn defaults to the <termref def="dt-unnamed-mode"/>. An implicit
                  reference to the unnamed made is treated in the same way as any other <termref def="dt-symbolic-reference"/>. Note that there is an unnamed mode in every
                  package, and the unnamed mode always has private visibility.</p>

               <p>Where an <elcode>xsl:template</elcode> element has both
                  a <code>name</code> and a <code>match</code> attribute, it is treated as if there
                  were two separate <elcode>xsl:template</elcode> elements, one with a
                     <code>name</code> attribute and one with a <code>match</code> attribute. </p>

               <p><termref def="dt-key">Keys</termref>
                  and <termref def="dt-accumulator">accumulators</termref> behave rather differently from other
                  components. Their visibility is always private, which means they can only be used
                  within their declaring package. In addition, the component binding is generally
                  made dynamically rather than statically, by
                     virtue of a string passed as an argument to the function
                        <function>key</function>, <function>accumulator-before</function>, or
                        <function>accumulator-after</function>. (In the case of accumulators, there
                     can also be static references: see the <code>use-accumulators</code> attribute
                     of <elcode>xsl:source-document</elcode>, 
                     <elcode>xsl:merge-source</elcode>, and <elcode>xsl:mode</elcode>.) 
                     However, outward references from key
                  definitions and <termref def="dt-accumulator">accumulators</termref> to other components (such as global
                  variables and functions) behave in the same way as component references contained
                  in any other private component, in that they may be re-bound to an overriding
                  declaration of the target component.</p>

               <div4 id="visibility">
                  <head>Visibility of Components</head>


                  <p><termdef id="dt-visibility" term="visibility">The <term>visibility</term> of a
                           <termref def="dt-component">component</termref> is one of:
                           <code>private</code>, <code>public</code>, <code>abstract</code>,
                           <code>final</code>, or <code>hidden</code>.</termdef></p>

                  <p>The meanings of these visibility values is as follows:</p>
                  
                  <glist>
                     <gitem>
                        <label>public</label>
                        <def><p>The component can be referenced from other components in this package
                              or in any using package; it can be overridden by a different component
                              in any using package.</p></def>
                     </gitem>
                     <gitem>
                        <label>private</label>
                        <def><p>The component can be referenced from other components in this
                              package; it cannot be referenced or overridden within a using
                              package.</p></def>
                     </gitem>
                     <gitem>
                        <label>abstract</label>
                        <def><p>The component can be referenced from other components in this package
                              or in any using package; in a using package it can either remain
                              abstract or be overridden by a different component. </p></def>
                     </gitem>
                     <gitem>
                        <label>final</label>
                        <def><p>The component can be referenced from other components in this package
                              or in any using package; it cannot be overridden by a different
                              component in any using package.</p></def>
                     </gitem>
                     <gitem>
                        <label>hidden</label>
                        <def><p>The component cannot be referenced from other components in this
                              package; it cannot be referenced or overridden within a using
                              package.</p></def>
                     </gitem>
                  </glist>

                  <note>
                     <p>The visibility of a component in a package <var>P</var> primarily affects
                        how the component can be used in other packages, specifically, packages that
                        use <var>P</var>. There is one exception: if the visibility is
                           <code>hidden</code>, it also affects how the component can be used within
                           <var>P</var>.</p>
                  </note>

                  <p>When a component is declared within a particular
                     package, its <termref def="dt-visibility">visibility</termref>, which affects
                     how it can be used in other (using) packages, depends on two factors: the value
                     of the <code>visibility</code> declaration on the declaration itself (if
                     present), and the rules given in the <elcode>xsl:expose</elcode> declarations
                     of the package manifest.</p>

                  <p>The <elcode>xsl:function</elcode>, <elcode>xsl:template</elcode>,
                        <elcode>xsl:attribute-set</elcode>, <elcode>xsl:variable</elcode>, 
                      and
                        <elcode>xsl:mode</elcode>
                     <termref def="dt-declaration">declarations</termref> each have an optional
                        <code>visibility</code> attribute. The value is one of <code>private</code>,
                        <code>public</code>, <code>abstract</code>, or <code>final</code> (never
                        <code>hidden</code>). In the case of
                           an <elcode>xsl:param</elcode> element there is no explicit 
                           <code>visibility</code> attribute; rather the declaration has the
                           implicit attribute <code>visibility="public"</code>.</p>

                  <p>Any <elcode>xsl:expose</elcode> declarations that
                     appear as children of <elcode>xsl:package</elcode> define the visibility of
                     components whose declaration has no explicit <code>visibility</code> attribute,
                     and can also be used to reduce the visibility of components where this
                     attribute is present.</p>

                  <?element xsl:expose?>

                  <p>The <elcode>xsl:expose</elcode> element allows the <termref def="dt-visibility"/> of selected components within a package to be defined.</p>

                  <p>The components in question are identified using their <termref def="dt-symbolic-identifier">symbolic identifiers</termref>. The
                        <code>component</code> attribute defines the kind of component that is
                        selected.
                     The value <code>*</code> means “all component kinds”;
                        in this case the value of the <code>names</code> attribute must be a <xnt spec="XP40" ref="prod-xpath40-Wildcard">Wildcard</xnt>.</p>
                  
                  <p>An <elcode>xsl:expose</elcode> declaration has no effect on the 
                     <termref def="dt-unnamed-mode"/>, which is always private to a package.</p>
                     
                     <p>The <code>names</code> attribute selects a subset of these components by name
                     (and in the case of functions, arity); its value is a whitespace-separated
                     sequence of tokens each of which is either a <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTest</xnt> or a <xnt spec="XP40" ref="prod-xpath40-NamedFunctionRef">NamedFunctionRef</xnt>. (Examples are
                        <code>*</code>, <code>p:*</code>, <code>*:local</code>,
                     <code>p:local</code>, and <code>p:local#2</code>.)</p>

                  <p>The value may be a <code>NamedFunctionRef</code> only in the case of stylesheet
                     functions, and distinguishes functions with the same name and different
                     arity. <phrase diff="add" at="A">A <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTest</xnt>
                     on its own (that is, with no arity) cannot be used to identify a function. [XSLT 3.0 Erratum E36, bug 30323].</phrase></p>

                  <p>The visibility of a 
                     named template, function, variable, attribute set, or mode
                     declared within a package is the first of the following that applies, subject to consistency
                     constraints which are defined below:</p>

                  <olist>
                     <item>
                        <p>The visibility of a variable declared using
                           an <elcode>xsl:param</elcode> element is
                           always <code>public</code>. No <elcode>xsl:expose</elcode> element
                        ever matches an <elcode>xsl:param</elcode> component.</p>
                        <note><p>Attempting to match an <elcode>xsl:param</elcode> with
                        an explicit <code>EQName</code> will therefore always give an error, while
                        using a wildcard has no effect.</p></note>
                     </item>
                     <item>
                        <p>If the package manifest contains an <elcode>xsl:expose</elcode> element
                           that matches this component by virtue of an explicit <code>EQName</code>
                           or <code>NamedFunctionRef</code> (that is, not by virtue of a wildcard
                           match), then the value of the <code>visibility</code> attribute of the
                           last such <elcode>xsl:expose</elcode> element in document order (call
                           this the <term>explicit exposed visibility</term>).</p>
                     </item>

                     <item>
                        <p>If the declaration of the component has a <code>visibility</code>
                           attribute, then the value of this attribute (call this the <term>declared
                              visibility</term>).</p>
                     </item>

                     <item>
                        <p>If the package manifest contains an <elcode>xsl:expose</elcode> element
                           that matches this component by virtue of a wildcard match that specifies
                           either the namespace part of the component name or the local part of the
                           name (for example, <code>prefix:*</code> or <code>*:local</code> or
                              <code>Q{uri}*</code>), then the value of the <code>visibility</code>
                           attribute of the last such <elcode>xsl:expose</elcode> element in
                           document order.</p>
                     </item>

                     <item>
                        <p>If the package manifest contains an <elcode>xsl:expose</elcode> element
                           that matches this component by virtue of a wildcard match that matches
                           all names (that is, <code>*</code>), then the value of the
                              <code>visibility</code> attribute of the last such
                              <elcode>xsl:expose</elcode> element in document order.</p>
                     </item>

                     <item>
                        <p>Otherwise, <code>private</code>.</p>
                     </item>
                  </olist>
                  
                  <note><p>In the above rules, no distinction is made between declarations that specify
                  a specific component kind, and those that specify <code>component="*"</code>. If both match,
                  the value of the <code>component</code> attribute plays no role in deciding which 
                  declaration wins.</p></note>


                  <p>If both a declared visibility and an explicit
                     exposed visibility exist for the same component, then as mentioned above, they
                     must be consistent. This is determined by reference to the following table,
                     where the entry N/P means “not permitted”. (In cases where the combination is
                     permitted, the actual visibility is always the same as the visibility
                     determined by <elcode>xsl:expose</elcode>.)</p>


                  <table class="data">
                     <caption>Relationship of Exposed Visibility to Potential Visibility</caption>
                     <thead>
                        <tr>
                           <th rowspan="2" colspan="1">Explicit exposed visibility</th>
                           <th colspan="4" rowspan="1">Declared visibility</th>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">public</th>
                           <th rowspan="1" colspan="1">private</th>
                           <th rowspan="1" colspan="1">final</th>
                           <th rowspan="1" colspan="1">abstract</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <th rowspan="1" colspan="1">public</th>
                           <td rowspan="1" colspan="1">public</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">private</th>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">final</th>
                           <td rowspan="1" colspan="1">final</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">final</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">abstract</th>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">abstract</td>
                        </tr>

                     </tbody>
                  </table>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3010">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                           explicit exposed visibility of a component is inconsistent with its
                           declared visibility, as defined in the above table. (This error occurs
                           only when the component declaration has an explicit
                              <code>visibility</code> attribute, and the component is also listed
                           explicitly by name in an <elcode>xsl:expose</elcode> declaration.)</p>
                     </error>
                  </p>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3020">
                        <p>It is a <termref def="dt-static-error">static error</termref> if a token
                           in the <code>names</code> attribute of <elcode>xsl:expose</elcode>, other
                           than a wildcard, matches no component in the containing package.</p>
                     </error>
                  </p>
                  
                  <p>
                     <error spec="XT" type="static" class="SE" code="3022">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the 
                           <code>component</code> attribute of <elcode>xsl:expose</elcode> specifies <code>*</code>
                           (meaning all component kinds) and the <code>names</code> attribute is not a wildcard.</p>
                     </error>
                  </p>



                  <note>
                     <p>There is no ambiguity, and no error, if several tokens within the same
                           <elcode>xsl:expose</elcode> element match the same component.</p>
                  </note>
                  
                  <p>If the visibility of a component as established by the above rules
                  is <code>abstract</code>, then the component must have a declared visibility of <code>abstract</code>.</p>
                  
                  <note><p>In other words, the <elcode>xsl:expose</elcode> declaration cannot be used to make a component
                  abstract unless it was declared as abstract to start with.</p></note>
                  
                  <p>
                     <error spec="XT" type="static" class="SE" code="3025">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                           effect of an <elcode>xsl:expose</elcode> declaration would be to make a component
                           <code>abstract</code>, unless the component is already <code>abstract</code>
                           in the absence of the <elcode>xsl:expose</elcode> declaration.
                        </p>
                     </error>
                  </p>



                  <p>For a component accepted into a package <var>P</var>
                     from another package <var>Q</var>, the <termref def="dt-visibility">visibility</termref> of the component in <var>P</var> (which primarily
                     affects how it can be used in a package <var>R</var> that uses <var>P</var>)
                     depends on the visibility declared in the relevant <elcode>xsl:accept</elcode>
                     or <elcode>xsl:override</elcode> element in <var>P</var> (see <specref ref="accepting-components"/>); this in turn has a default that depends on
                     the visibility of the corresponding component in <var>Q</var>. In this case the
                     visibility is unaffected by any <elcode>xsl:expose</elcode> declaration in
                        <var>P</var>.</p>




               </div4>


               <div4 id="accepting-components">
                  <head>Accepting Components</head>

                  <p>When a package <var>P</var> uses a package <var>Q</var>, by virtue of an
                        <elcode>xsl:use-package</elcode> element in the <termref def="dt-package-manifest">package manifest</termref> of <var>P</var>, then
                        <var>P</var> will contain a <termref def="dt-component">component</termref>
                     corresponding to every component in <var>Q</var>. The <termref def="dt-visibility">visibility</termref> of the component within
                        <var>P</var> depends on the <termref def="dt-visibility">visibility</termref> of the component in <var>Q</var>, optionally modified
                     by two elements that may appear as children of the
                        <elcode>xsl:use-package</elcode> element, namely <elcode>xsl:accept</elcode>
                     and <elcode>xsl:override</elcode>.</p>

                  <p>For every component <var>C/Q</var> in package <var>Q</var> that is not matched
                     by any <elcode>xsl:override</elcode> or <elcode>xsl:accept</elcode> element in
                     the package manifest of <var>P</var>, there will be a corresponding component
                        <var>C/P</var> in package <var>P</var> that has the same <termref def="dt-symbolic-identifier">symbolic identifier</termref> and <termref def="dt-declaration">declaration</termref> as <var>C/Q</var>.</p>
                  
                     <p>If <var>C/Q</var> is an <elcode>xsl:param</elcode>
                        component, then the <termref def="dt-visibility"/> of <var>C/P</var> is
                        <code>public</code>.</p>
                     
                     <p>In other cases, the <termref def="dt-visibility"/> of <var>C/P</var> 
                        depends on the <termref def="dt-visibility"/> of <var>C/Q</var>, as defined by the following table:</p>
                  
                  <table class="data">
                     <caption>Visibility of Components in Used and Using Packages</caption>
                     <thead>
                        <tr>
                           <th rowspan="1" colspan="1">Visibility in used package <var>C/Q</var></th>
                           <th rowspan="1" colspan="1">Visibility in using package <var>C/P</var></th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td rowspan="1" colspan="1">public</td>
                           <td rowspan="1" colspan="1">private</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">final</td>
                           <td rowspan="1" colspan="1">private</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">hidden</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">hidden</td>
                           <td rowspan="1" colspan="1">hidden</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">abstract</td>
                           <td rowspan="1" colspan="1">hidden</td>
                        </tr>
                     </tbody>
                  </table>
                  
                  <note>
                     <p>The effect of these rules is as follows:</p>
                     <ulist>
                        <item><p>Components that are public or final in the used package <var>Q</var> become
                        private in the using package <var>P</var>. This means that they can be referenced
                        within <var>P</var> but are not (by default) visible within a package <var>R</var>
                        that uses <var>P</var>.</p></item>
                        <item><p>Components that are private or hidden in the used package <var>Q</var> become
                           hidden in the using package <var>P</var>. This means that they cannot be referenced
                           within <var>P</var>; but if they contain references to components that are overridden
                           in <var>P</var>, the hidden component’s references are bound to the overriding components
                        in <var>P</var>.</p></item>
                        <item><p>Components that are abstract in the used package <var>Q</var> become
                           hidden in the using package <var>P</var>. The hidden component in this case raises a dynamic
                           error if it is invoked. Such an invocation cannot originate within <var>P</var>,
                           because the component is not visible within <var>P</var>; but it can occur
                        if a public component in <var>Q</var> is invoked, which in turn invokes the abstract
                        component.</p></item>
                     </ulist>
                  </note>

                  

                  <!--<p>If there is a declaration of a component within <elcode>xsl:override</elcode>, then the 
                  component that is overridden remains in the using package with internal visibility 
                  <code>hidden</code> and this is supplemented by the overriding component which appears with the
                  visibility given in its declaration.
                  In this case any <elcode>xsl:accept</elcode> element that matches the component is ignored.
                  For more details of <elcode>xsl:override</elcode> see <specref ref="package-overriding-components"/>.</p>
                -->
                  <?element xsl:accept?>

                  <p>The <elcode>xsl:accept</elcode> element has very similar syntax and semantics
                     to <elcode>xsl:expose</elcode>. Whereas <elcode>xsl:expose</elcode> allows a
                     package to restrict the visibility of its own components to other (using)
                     packages, <elcode>xsl:accept</elcode> allows a package to restrict the
                     visibility of components exposed by a package that it uses. This may be
                     necessary if, for example, it uses two different packages whose component names
                     conflict. It may also simply be good practice if the package author knows that
                     only a small subset of the functionality of a used package is required.</p>

                  <p>The rules for determining whether an <elcode>xsl:accept</elcode> element
                     matches a particular component, and for which element to use if there are
                     several matches, are the same as the rules for the <elcode>xsl:expose</elcode>
                     element.</p>
                  
                  <p>No <elcode>xsl:accept</elcode> element
                     ever matches a variable declared using <elcode>xsl:param</elcode>.</p>
                  <note><p>Attempting to match an <elcode>xsl:param</elcode> with
                     an explicit <code>EQName</code> will therefore always give an error, while
                     using a wildcard has no effect.</p></note>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3030">
                        <p>It is a <termref def="dt-static-error">static error</termref> if a token
                           in the <code>names</code> attribute of <elcode>xsl:accept</elcode>, other
                           than a wildcard, matches no component in the used package.</p>
                     </error>
                  </p>
                  
                  <p>
                     <error spec="XT" type="static" class="SE" code="3032">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the 
                           <code>component</code> attribute of <elcode>xsl:accept</elcode> specifies <code>*</code>
                           (meaning all component kinds) and the <code>names</code> attribute is not a wildcard.</p>
                     </error>
                  </p>


                  <p>In the absence of a matching <elcode>xsl:override</elcode> element (see
                        <specref ref="package-overriding-components"/>), the <termref def="dt-visibility"/> of a component that matches an
                        <elcode>xsl:accept</elcode> element depends both on the
                        <code>visibility</code> attribute of the best-matching
                        <elcode>xsl:accept</elcode> element and on the <termref def="dt-visibility">visibility</termref> of the corresponding component in the used package,
                     according to the following table. In this table the entry “N/P” means “not
                     permitted”.</p>

                  <table class="data">
                     <caption>Relationship of the Visibility given in xsl:accept to Visibility in the Used Package</caption>
                     <thead>
                        <tr>
                           <th rowspan="2" colspan="1">Visibility in <elcode>xsl:accept</elcode> element</th>
                           <th colspan="4" rowspan="1">Visibility in used package</th>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">public</th>
                           <th rowspan="1" colspan="1">private</th>
                           <th rowspan="1" colspan="1">final</th>
                           <th rowspan="1" colspan="1">abstract</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <th rowspan="1" colspan="1">public</th>
                           <td rowspan="1" colspan="1">public</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">private</th>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">private</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">final</th>
                           <td rowspan="1" colspan="1">final</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">final</td>
                           <td rowspan="1" colspan="1">N/P</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">abstract</th>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">abstract</td>
                        </tr>
                        <tr>
                           <th rowspan="1" colspan="1">hidden</th>
                           <td rowspan="1" colspan="1">hidden</td>
                           <td rowspan="1" colspan="1">N/P</td>
                           <td rowspan="1" colspan="1">hidden</td>
                           <td rowspan="1" colspan="1">hidden</td>
                        </tr>

                     </tbody>
                  </table>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3040">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                           visibility assigned to a component by an <elcode>xsl:accept</elcode>
                           element is incompatible with the visibility of the corresponding
                           component in the used package, as defined by the above table, unless the
                           token that matches the component name is a wildcard, in which case the
                              <elcode>xsl:accept</elcode> element is treated as not matching that
                           component.</p>
                     </error>
                  </p>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3050">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                              <elcode>xsl:use-package</elcode> elements in a <termref def="dt-package-manifest">package manifest</termref> cause two or more
                              <termref def="dt-homonymous">homonymous</termref> components to be
                           accepted with a visibility other than <code>hidden</code>.</p>
                     </error>
                  </p>


                  <p>Conflicts between the components accepted from used packages and those declared
                     within the package itself are handled as follows:</p>

                  <olist>
                     <item>
                        <p>If the conflict is between two components both declared within the
                           package itself, then it is resolved by the rules relating to <termref def="dt-import-precedence">import precedence</termref> defined for
                           each kind of component.</p>
                     </item>
                     <item>
                        <p>If the conflict is between two components both accepted from used
                           packages, or between a component declared within the package and an
                           accepted component, then a static error occurs.</p>
                     </item>
                     <item>
                        <p>If a component is explicitly accepted from a used package (by name, rather
                           than by a matching wildcard), and if the same component is the subject
                           of an <elcode>xsl:override</elcode> declaration, then a static error
                        occurs (see below). There is no conflict, however, if a component declared
                        within <elcode>xsl:override</elcode> also matches a wildcard in an <elcode>xsl:accept</elcode>
                        element.</p>
                        <p>
                           <error spec="XT" type="static" class="SE" code="3051">
                              <p>It is a <termref def="dt-static-error">static error</termref> if
                                 a token in the <code>names</code> attribute of <elcode>xsl:accept</elcode>,
                                 other than a wildcard, matches the symbolic name of a component declared
                                 within an <elcode>xsl:override</elcode> child of the same
                                 <elcode>xsl:use-package</elcode> element.</p>
                           </error>
                        </p>
                     </item>
                  </olist>

                  
                  
                  <p>Where the used package <var>Q</var> contains a component whose
                     visibility is <code>abstract</code>, the using package <var>P</var> has three options:</p>
                  
                  <olist>
                     <item><p><var>P</var> can accept the component with <code>visibility="abstract"</code>.
                        In this case <var>P</var> can contain references to the component, but invocation via
                     these references will fail unless a non-abstract overriding component has
                     been supplied in some package <var>R</var> that (directly or indirectly) uses <var>P</var>.</p></item>
                     <item><p><var>P</var> can accept the component with <code>visibility="hidden"</code>.
                        In this case <var>P</var> cannot contain references to the component, and invocation via
                        references in <var>Q</var> will always fail with a dynamic error. This is the default
                     if <var>P</var> does not explicitly accept or override the component.</p></item>
                     <item><p><var>P</var> can provide a concrete implementation of the component
                     within an <elcode>xsl:override</elcode> element.</p></item>
                  </olist>

                  
                        <p>Any invocation of the absent component (typically from within its
                           declaring package) causes a dynamic error, as if the component were
                           overridden by a component that unconditionally raises a dynamic
                           error.</p>
                        <p>
                           <error spec="XT" type="dynamic" class="DE" code="3052">
                              <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if
                                 an invocation of an abstract component is evaluated.
                              </p>
                           </error>                          
                        </p>
                        <note><p>This can occur when a public component in the used package invokes
                           an abstract component in the used package, and the using package provides
                           no concrete implementation for the component in an <elcode>xsl:override</elcode>
                           element.</p></note>

                  <note>
                     <p>To override a component accepted from a used package, the overriding
                        declaration must appear as a child of the <elcode>xsl:override</elcode>
                        element.</p>
                  </note>

                  <note>
                     <p>There is no rule that prevents a function (say) being declared in the using
                        package with the same name as a <code>private</code> function in the used
                        package. This does not create a conflict, since all references in the used
                        package are bound to one function and all those in the using package are
                        bound to another.</p>
                  </note>



               </div4>

               <div4 id="package-overriding-components">
                  <head>Overriding Components from a Used Package</head>

                  <p><termdef id="dt-override" term="override">A component in a using package may
                           <term>override</term> a component in a used package, provided that the
                           <termref def="dt-visibility">visibility</termref> of the component in the
                        used package is either <code>abstract</code> or <code>public</code>. The
                        overriding declaration is written as a child of the
                           <elcode>xsl:override</elcode> element, which in turn appears as a child
                        of <elcode>xsl:use-package</elcode>.</termdef></p>

                  <?element xsl:override?>

                  <note>
                     <p>This mechanism is distinct from the mechanism for overriding declarations
                        within the same package by relying on <termref def="dt-import-precedence">import precedence</termref>. It imposes stricter rules: the overriding
                        component is required to be type-compatible with the component that it
                        overrides.</p>
                  </note>

                  <p>If the used package <var>Q</var> contains a <termref def="dt-component">component</termref>
                     <var>C/Q</var> and the <elcode>xsl:use-package</elcode> element contains an
                        <elcode>xsl:override</elcode> element which contains a declaration
                        <var>D</var> whose <termref def="dt-symbolic-identifier">symbolic
                        identifier</termref> matches the symbolic identifier of <var>C/Q</var>, then
                     the using package <var>P</var> will contain a component <var>C/P</var> whose
                     declaration is D, whose symbolic identifier is that of D, and whose <termref def="dt-visibility"/> is equal to the value of the <code>visibility</code>
                     attribute of <var>D</var>, or <code>private</code> if this is absent, 
                     except in the case
                           of <elcode>xsl:param</elcode>, which is implicitly
                           <code>public</code>.</p>

                  <p>The using package <var>P</var> will also contain a component <var>C/PQ</var>
                     whose body is the same as the body of <var>C/Q</var> and whose <termref def="dt-visibility">visibility</termref> is <code>hidden</code>. This
                     component is used as the target of a binding for the symbolic reference
                        <code>xsl:original</code> described below.</p>

                  <p>Other than its appearance as a child of <elcode>xsl:override</elcode>, the
                     overriding declaration is a normal <elcode>xsl:function</elcode>,
                        <elcode>xsl:template</elcode>, ,
                     <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>, or
                        <elcode>xsl:attribute-set</elcode> element. In the case of
                        <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode>, the variable
                     that is declared is a <termref def="dt-global-variable">global
                        variable</termref>.</p>

                  <p>The rules in the remainder of this section apply to
                     components having a <code>name</code> attribute (<term>named
                     components</term>). The only element with no <code>name</code> attribute that
                     can appear as a child of <elcode>xsl:override</elcode> is an
                        <elcode>xsl:template</elcode> declaration having a <code>match</code>
                     attribute (that is, a <termref def="dt-template-rule"/>). The rules for
                     overriding of template rules appear in <specref ref="modes-and-packages"/>. If
                     an <elcode>xsl:template</elcode> element has both a <code>name</code> attribute
                     and a <code>match</code> attribute, then it defines both a named component and
                     a template rule, and both sections apply.</p>
                  
                  <p diff="add" at="A">An <elcode>xsl:function</elcode> declaration that includes optional
                  parameters declares a number of functions, differing in arity. A function
                  declaration appearing within <elcode>xsl:override</elcode> may similarly
                  declare several functions differing in arity: these are considered individually
                  when considering which functions from the used package are overridden.</p>
                  
                  <note diff="add" at="A">
                     <p>Suppose the used package contains an <elcode>xsl:function</elcode>
                     declaration with name <code>f:x</code>, having two required parameters, 
                        followed by an optional parameter whose default value is an empty sequence. 
                        It thus declares two components,
                     <code>f:x#2</code> and <code>f:x#3</code>. A call on <code>f:x(a, b)</code>
                     is evaluated as a call on <code>f:x(a, b, ())</code>.</p>
                     <p>If an <code>xsl:override</code> element includes an <elcode>xsl:function</elcode>
                     declaration for <code>f:x</code> with two parameters, both mandatory, then this
                     overrides <code>f:x#2</code> but does not override <code>f:x#3</code>, which remains
                     available in its original form.</p>
                     <p>If the <code>xsl:override</code> element includes an <elcode>xsl:function</elcode>
                        declaration for <code>f:x</code> with three parameters, all mandatory, then this
                        overrides <code>f:x#3</code> but does not override <code>f:x#2</code>. A call on <code>f:x(a, b)</code>
                        is evaluated as a call on <code>f:x(a, b, ())</code>, which invokes the overriding
                     version of <code>f:x#3</code>. If the overriding declaration was intended to make the
                     optional parameter mandatory, then it failed to achieve this effect.</p>
                     <p>If the <code>xsl:override</code> element includes an <elcode>xsl:function</elcode>
                        declaration for <code>f:x</code> with three parameters, where the first two are required
                        and the third is optional, then this
                        overrides both <code>f:x#2</code> and <code>f:x#3</code>.</p>
                     <p>If the <code>xsl:override</code> element includes an <elcode>xsl:function</elcode>
                        declaration for <code>f:x</code> with three parameters, where the first is required
                        and the last two are declared optional, then this is an error: the declaration
                        is attempting to override <code>f:x#1</code>, but there is no such component.</p>
                     
                  </note>

                  


                  <p>
                     <error spec="XT" type="static" class="SE" code="3055">
                        <p>It is a <termref def="dt-static-error">static error</termref> if a
                           component declaration appearing as a child of
                              <elcode>xsl:override</elcode> is <termref def="dt-homonymous">homonymous</termref> with any other declaration in the using package,
                           regardless of <termref def="dt-import-precedence">import
                              precedence</termref>, including any other overriding declaration in
                           the package manifest of the using package.</p>
                     </error></p>

                  <note>
                     <p>When an attribute set is overridden, the
                        overriding attribute set must be defined using a single
                           <elcode>xsl:attribute-set</elcode> element. Attribute sets defined in
                        different packages are never merged by virtue of having the same name,
                        though they may be merged explicitly by using the
                           <code>use-attribute-sets</code> attribute.</p>
                  </note>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3058">
                        <p>It is a <termref def="dt-static-error">static error</termref> if a
                           component declaration appearing as a child of
                              <elcode>xsl:override</elcode> does not match (is not <termref def="dt-homonymous">homonymous</termref> with) some component in the
                           used package.</p>
                     </error></p>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3060">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                           component referenced by an <elcode>xsl:override</elcode> declaration has
                              <termref def="dt-visibility">visibility</termref> other than
                              <code>public</code> or <code>abstract</code></p>
                     </error>
                  </p>

                  <p>A package is executable if and only if it contains no <termref def="dt-component">component</termref> whose <termref def="dt-visibility">visibility</termref> is <code>abstract</code>. A package that is not
                     executable is not a <termref def="dt-stylesheet">stylesheet</termref>, and
                     therefore cannot be nominated as the stylesheet to be used when initiating a
                     transformation.</p>

                  <note>
                     <p>In other words, if a component is declared as abstract, then some package
                        that uses the declaring package of that component directly or indirectly
                        must override that component with one that is not abstract. It is not
                        necessary for the override to happen in the immediately using package.</p>
                  </note>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3070">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                           signature of an overriding component is not <termref def="dt-compatible">compatible</termref> with the signature of the component that it is
                           overriding.</p>
                     </error>
                  </p>



                  <p><termdef id="dt-compatible" term="compatible">The signatures of two <termref def="dt-component">components</termref> are <term>compatible</term> if
                        they present the same interface to the user of the component. The additional
                        rules depend on the kind of component.</termdef></p>

                  <p>Compatibility is only relevant when comparing two components that have the same
                        <termref def="dt-symbolic-identifier"/>. The compatibility rules for each
                     kind of component are as follows:</p>

                  <ulist>
                     <item>
                        <p>Two attribute sets with the same name are compatible if
                           and only if they satisfy the following rule:</p>
                        <olist>
                           <item>
                              <p>If the overridden attribute set specifies
                                    <code>streamable="yes"</code> then the overriding attribute set
                                 also specifies <code>streamable="yes"</code>.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>Two functions with the same name and arity are compatible if and only if
                           they satisfy all the following rules:</p>
                        <olist>
                           <item>
                              <p>The declared types of the arguments 
                                 (defaulting to <code>item()*</code>) are pairwise <termref def="dt-identical-types">identical</termref>.</p>
                           </item>
                           <item>
                              <p>The declared return types 
                                 (defaulting to <code>item()*</code>) are <termref def="dt-identical-types">identical</termref>.</p>
                           </item>
                           <item>
                              <p>The effective value of the 
                                 <code>new-each-time</code> 
                                 attribute on the overriding function is the same as its value on the overridden function.</p>
                           </item>
                           
                           <item>
                              <p diff="chg" at="A">If the overridden function has a <code>streamability</code> attribute with a value
                              other than <code>unspecified</code>, then the overriding function has a
                                 <code>streamability</code> attribute with the same value. [XSLT 3.0 Erratum E32, bug 30297]</p>
                           </item>
                        </olist>
                     </item>
                     
                     <item>
                        <p>Two named templates with the same name are compatible if and only if they
                           satisfy all the following rules:</p>
                        <olist>
                           <item>
                              <p>Their return types are <termref def="dt-identical-types">identical</termref>.</p>
                           </item>
                           <item>
                              <p>For every non-tunnel parameter on the overridden template, there is a
                                 non-tunnel parameter on the overriding template that has the same name, an
                                    <termref def="dt-identical-types">identical</termref> required
                                 type, and the same effective value for the <code>required</code> attributes.</p>
                           </item>
                           <item>
                              <p>For every tunnel parameter <var>P</var> on the overridden template, if there is a
                                 parameter <var>Q</var> on the overriding template that has the same name 
                                 as <var>P</var> then <var>Q</var> is also a tunnel parameter, and <var>P</var> and <var>Q</var> have
                                 <termref def="dt-identical-types">identical</termref> required
                                 types.</p>
                           </item>
                           <item>
                              <p>Any parameter on the overriding template for which there is no
                                 corresponding parameter on the overridden template specifies
                                    <code>required="no"</code>.</p>
                           </item>
                           <item>
                              <p>The two templates have equivalent
                                    <elcode>xsl:context-item</elcode> children, where equivalence
                                 means that the <code>use</code> attributes are the same and the
                                 required types are <termref def="dt-identical-types">identical</termref>; an absent
                                    <elcode>xsl:context-item</elcode> is equivalent to one that
                                 specifies <code>use="optional"</code> and
                                 <code>as="item()"</code>.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>Two variables (including parameters) with the same name are compatible if
                           and only if they satisfy all the following rules:</p>
                        <olist>
                           <item>
                              <p>Their declared types are <termref def="dt-identical-types">identical</termref>.
                              <phrase diff="add" at="A">For this purpose, the declared type is the first
                              of the following that applies:</phrase></p>
                              <ulist diff="add" at="A">
                                 <item><p>If there is an <code>as</code> attribute, then the type defined by that attribute.</p></item>
                                 <item><p>If there is a <code>select</code> attribute, then <code>item()*</code>.</p></item>
                                 <item><p>If there is a non-empty sequence constructor, then <code>document-node()</code>.</p></item>
                                 <item><p>Otherwise, <code>xs:string</code>. [XSLT 3.0 Erratum E35, bug 30313].</p></item>
                              </ulist>
                           </item>
                           
                        </olist>
                        <note>
                           <p>A variable may override a parameter or vice-versa, and the initial
                              value may differ.</p>
                           <p>Because static variables and parameters are
                              constrained to have visibility <code>private</code>
                              ,
                              they cannot be overridden in another package. The compatibility rules
                              therefore do not arise. The reason that such variables cannot be
                              overridden is that they are typically used during stylesheet
                              compilation (for example, in <code>[xsl:]use-when</code> expressions
                              and shadow attributes) and it is a design goal that packages should be
                              capable of independent compilation.</p>
                        </note>
                     </item>

                  </ulist>

                  <p><termdef id="dt-identical-types" term="identical (types)">Types S and T are considered <term>identical</term> for the purpose of
                        these rules if and only if <code>subtype(S, T)</code> and <code>subtype(T,
                           S)</code> both hold, where the subtype relation is defined in <xspecref spec="XP40" ref="id-seqtype-subtype"/>.</termdef></p>

                  <note>
                     <olist>
                        <item>
                           <p>One consequence of this rule is that two plain union types are
                              considered identical if they have the same set of member types, even
                              if the union types have different names or the ordering of the member
                              types is different.</p>
                           <p>Consider a function that accepts an argument
                           whose declared type is a union type with member types <code>xs:double</code>
                           and <code>xs:decimal</code>, in that order (we might write this as <code>union(xs:double, xs:decimal)</code>).
                           Using the same notation, this can be overridden by a function that declares the argument
                           type as <code>union(xs:decimal, xs:double)</code>. This does not affect type checking:
                              a function call that passes the type checking rules with one signature will also pass the
                              type checking rules with the other. It does however affect the way that the function
                           conversion rules work: a call that passes the <code>xs:untypedAtomic</code> value
                           <code>"93.7"</code> (or an untyped node with this as its string value) will be converted to 
                              an <code>xs:decimal</code> in one case and an <code>xs:double</code> in the other.</p>
                        </item>

                        <item>
                           <p>While this rule may appear formal, it is not as straightforward as
                              might be supposed, because the subtype relation in XPath has a
                              dependency on the “Type derivation OK (Simple)” relation in XML
                              Schema, which itself appeals to a judgement as to whether the two type
                              definitions being compared “are the same type definition”. Both XSD
                              1.0 and XSD 1.1 add the note “The wording of [this rule] appeals to a
                              notion of component identity which is only incompletely defined by
                              this version of this specification.” However, they go on to say that
                              component identity is well defined if the components are named simple
                              type definitions, which will always apply in this case. For named
                              atomic types, the final result of these rules is that two atomic types
                              are identical if and only if they have the same name.</p>
                        </item>
                     </olist>
                  </note>


                  <p>Modes are not overridable, so the <elcode>xsl:mode</elcode> declaration cannot
                     appear as a child of <elcode>xsl:override</elcode>.</p>
               </div4>
               <div4 id="refer-to-overridden">
                  <head>Referring to Overridden Components</head>


                  <p>Within the declaration of an overriding named <termref def="dt-component"/>
                     (that is, a component whose declaration is a child of
                        <elcode>xsl:override</elcode>, and has a <code>name</code> attribute), where
                     the overridden component has public <termref def="dt-visibility"/>, it is
                     possible to use the name <code>xsl:original</code> as a symbolic reference to
                     the overridden component. More specifically: </p>

                  <ulist>
                     <item>
                        <p>Within a <termref def="dt-named-template"/> appearing as a child of
                              <elcode>xsl:override</elcode>, the name <code>xsl:original</code>
                           may appear as the value of the <code>name</code> attribute of
                              <elcode>xsl:call-template</elcode>: for example,
                              <code>&lt;xsl:call-template name="xsl:original"/&gt;</code>. </p>
                     </item>
                     <item>
                        <p>Within a <termref def="dt-stylesheet-function"/> appearing as a child of
                              <elcode>xsl:override</elcode>, the static context for contained XPath
                           expressions (other than <termref def="dt-static-expression">static
                              expressions</termref>) is augmented as follows: the <term>statically
                              known function signatures</term> includes a mapping from the name
                              <code>xsl:original</code> to the signature of the overridden
                           function (which is the same as the signature of the overriding function).
                           This means that the name <code>xsl:original</code> can be used in static
                           function calls, including calls that use partial function application
                           (where one of the arguments is given as "?"), and also in named function
                           references. For example: <code>xsl:original($x)</code>,
                              <code>xsl:original($x, ?)</code>, <code>xsl:original#2</code>.</p>
                        <note>
                           <p>The result of calling <code>function-name(xsl:original#2)</code> is
                              the name of the overridden function, not
                              <code>xsl:original</code>.</p>
                        </note>
                        <p>Neither <code>xsl:original</code>, nor the overridden function, is added
                           to the <term>named functions</term> component of the dynamic context for
                           XPath expressions within the overriding function. This means that any
                           attempt to bind the function name <code>xsl:original</code> dynamically
                           (for example using <xfunction>function-lookup</xfunction>, or
                              <function>function-available</function>, or
                              <elcode>xsl:evaluate</elcode>) will fail, and any attempt to bind
                           the name of the overriding/overridden function dynamically will return
                           the overriding function. </p>
                     </item>
                     <item>
                        <p>Within a <termref def="dt-global-variable"/> or parameter appearing as a
                           child of <elcode>xsl:override</elcode>, the static context for contained
                           XPath expressions (other than <termref def="dt-static-expression">static
                              expressions</termref>) is augmented as follows: the <term>in-scope
                              variables</term> includes a mapping from the name
                              <code>xsl:original</code> to the declared type of the overridden
                           variable or parameter (which is the same as the type of the overriding
                           global variable or parameter). </p>
                     </item>
                     <item>
                        <p>Within an <termref def="dt-attribute-set"/> appearing as a child of
                              <elcode>xsl:override</elcode>, any
                              <code>[xsl:]use-attribute-sets</code> attribute (whether on the
                              <elcode>xsl:attribute-set</elcode> element itself, or on any
                           descendant element) may include the name <code>xsl:original</code> as a
                           reference to the overridden attribute set. </p>
                     </item>
                  </ulist>

                  <p>Within the overriding component <var>C/P</var>, the <termref def="dt-symbolic-reference"/>
                     <code>xsl:original</code> is bound to the hidden component <var>C/PQ</var>
                     described earlier, whose body is that of the component <var>C/Q</var> in the
                     used package. </p>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3075">
                        <p>It is a <termref def="dt-static-error">static error</termref> to use the
                           component reference <code>xsl:original</code> when the overridden
                           component has <code>visibility="abstract"</code>.</p>
                     </error>
                  </p>

                  <p>Modes are not overridable, so the name
                        <code>xsl:original</code> cannot be used to refer to a <termref def="dt-mode"/> (for example in the <code>mode</code> attribute of
                        <elcode>xsl:apply-templates</elcode>). </p>



                  <note>
                     <p>In the case of variables, templates, and attribute sets, the invocation of
                        the overridden component can occur only within the lexical scope of the
                        overriding component. With functions, however, there is greater flexibility.
                        The overriding component can obtain a reference to the overridden component
                        in the form of a function item, and can export this value by passing it to
                        other functions or returning it in its result. A dynamic invocation of this
                        function item (and hence, of the overridden function) can thus occur
                        anywhere. </p>
                  </note>




               </div4>

               <div4 id="component-references">
                  <head>Binding References to Components</head>
                  <p><termdef id="dt-reference-binding" term="reference binding">The process of
                        identifying the <termref def="dt-component">component</termref> to which a
                           <termref def="dt-symbolic-reference">symbolic reference</termref> applies
                        (possibly chosen from several <termref def="dt-homonymous">homonymous</termref> alternatives) is called <term>reference
                           binding</term>.</termdef>
                  </p>

                  <p>The process of <termref def="dt-reference-binding"/> in the presence of
                     overriding declarations is best illustrated by an example. The formal rules
                     follow later in the section.</p>
                  <example id="example-of-component-binding">
                     <head>Binding References to Named Components</head>


                     <p>Consider a package <var>Q</var> defined as follows:</p>

                     <eg role="xslt-document" xml:space="preserve">&lt;xsl:package name="Q"
        version="3.0"                
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:variable name="A" visibility="final" select="$B + 1"/&gt;
  &lt;xsl:variable name="B" visibility="private" select="$C * 2"/&gt;
  &lt;xsl:variable name="C" visibility="public" select="22"/&gt;
&lt;/xsl:package&gt;</eg>

                     <p>(The process is illustrated here using variables as the components, but the
                        logic would be the same if the example used functions, named templates, or
                        attribute sets.)</p>

                     <p>There are three components in this package, and their properties are
                        illustrated in the following table. (The ID column is an arbitrary component
                        identifier used only for the purposes of this exposition.)</p>

                     
                     <table class="data">
                        <caption>Components in the above Package and their Properties</caption>
                        <thead>
                           <tr>
                              <th rowspan="1" colspan="1">ID</th>
                              <th rowspan="1" colspan="1">Symbolic Name</th>
                              <th rowspan="1" colspan="1">Declaring Package</th>
                              <th rowspan="1" colspan="1">Containing Package</th>
                              <th rowspan="1" colspan="1">Visibility</th>
                              <th rowspan="1" colspan="1">Body</th>
                              <th rowspan="1" colspan="1">Bindings</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td rowspan="1" colspan="1"><var>A/Q</var></td>
                              <td rowspan="1" colspan="1">variable <var>A</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">final</td>
                              <td rowspan="1" colspan="1"><code>$B + 1</code></td>
                              <td rowspan="1" colspan="1">$B → <var>B/Q</var></td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>B/Q</var></td>
                              <td rowspan="1" colspan="1">variable <var>B</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">private</td>
                              <td rowspan="1" colspan="1"><code>$C * 2</code></td>
                              <td rowspan="1" colspan="1">$C → <var>C/Q</var></td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>C/Q</var></td>
                              <td rowspan="1" colspan="1">variable <var>C</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">public</td>
                              <td rowspan="1" colspan="1"><code>22</code></td>
                              <td rowspan="1" colspan="1">none</td>
                           </tr>

                        </tbody>
                     </table>

                     <p>Now consider a package <var>P</var> that uses <var>Q</var>, and that
                        overrides one of the variables declared in <var>Q</var>:</p>

                     <eg role="xslt-document" xml:space="preserve">&lt;xsl:package name="P"
        version="3.0"                
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:use-package name="Q"&gt;
    &lt;xsl:override&gt;
      &lt;xsl:variable name="C" visibility="private" select="$xsl:original + 3"/&gt;
    &lt;/xsl:override&gt;
  &lt;/xsl:use-package&gt;
  
  &lt;xsl:template name="T" visibility="public"&gt;
    &lt;xsl:value-of select="$A"/&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:package&gt;</eg>

                     <p>Package <var>P</var> has five components, whose properties are shown in the
                        following table:</p>

                     <table class="data">
                        <caption>Components in the above Package and their Properties</caption>
                        <thead>
                           <tr>
                              <th rowspan="1" colspan="1">ID</th>
                              <th rowspan="1" colspan="1">Symbolic Name</th>
                              <th rowspan="1" colspan="1">Declaring Package</th>
                              <th rowspan="1" colspan="1">Containing Package</th>
                              <th rowspan="1" colspan="1">Visibility</th>
                              <th rowspan="1" colspan="1">Body</th>
                              <th rowspan="1" colspan="1">Bindings</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td rowspan="1" colspan="1"><var>A/PQ</var></td>
                              <td rowspan="1" colspan="1">variable <var>A</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">final</td>
                              <td rowspan="1" colspan="1"><code>$B + 1</code></td>
                              <td rowspan="1" colspan="1">$B → <var>B/PQ</var></td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>B/PQ</var></td>
                              <td rowspan="1" colspan="1">variable <var>B</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">hidden</td>
                              <td rowspan="1" colspan="1"><code>$C * 2</code></td>
                              <td rowspan="1" colspan="1">$C → <var>C/P</var></td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>C/PQ</var></td>
                              <td rowspan="1" colspan="1">variable <var>C</var></td>
                              <td rowspan="1" colspan="1">Q</td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">hidden</td>
                              <td rowspan="1" colspan="1"><code>22</code></td>
                              <td rowspan="1" colspan="1">none</td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>C/P</var></td>
                              <td rowspan="1" colspan="1">variable <var>C</var></td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">private</td>
                              <td rowspan="1" colspan="1"><code>$xsl:original + 3</code></td>
                              <td rowspan="1" colspan="1">$xsl:original → <var>C/PQ</var></td>
                           </tr>
                           <tr>
                              <td rowspan="1" colspan="1"><var>T/P</var></td>
                              <td rowspan="1" colspan="1">template <var>T</var></td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">P</td>
                              <td rowspan="1" colspan="1">public</td>
                              <td rowspan="1" colspan="1"><code>value-of select="$A</code></td>
                              <td rowspan="1" colspan="1">$A → <var>A/PQ</var></td>
                           </tr>

                        </tbody>
                     </table>

                     <p>The effect of these bindings is that when template <var>T</var> is called,
                        the result is <code>51</code>. This is why:</p>

                     <olist>
                        <item>
                           <p>The result of <var>T</var> is the value of <var>A/PQ</var>.</p>
                        </item>
                        <item>
                           <p>The value of <var>A/PQ</var> is the value of <var>B/PQ</var> plus
                              1.</p>
                        </item>
                        <item>
                           <p>The value of <var>B/PQ</var> is the value of <var>C/P</var> times
                              2.</p>
                        </item>
                        <item>
                           <p>The value of <var>C/P</var> is the value of <var>C/PQ</var> plus
                              3.</p>
                        </item>
                        <item>
                           <p>The value of <var>C/PQ</var> is 22.</p>
                        </item>
                        <item>
                           <p>So the final result is ((22 + 3) * 2) + 1</p>
                        </item>
                     </olist>

                     <p>In this example, the components of <var>P</var> are established in three
                        different ways:</p>

                     <olist>
                        <item>
                           <p>Components <var>A/PQ</var>, <var>B/PQ</var>, and <var>C/PQ</var> are
                              modified copies of the corresponding component <var>A/Q</var>,
                                 <var>B/Q</var>, and <var>C/Q</var> in the used package
                              <var>Q</var>. The properties of these components are modified as
                              follows:</p>
                           <olist>
                              <item>
                                 <p>The <termref def="dt-symbolic-identifier"/>, <termref def="dt-declaring-package"/>, and body are unchanged.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-containing-package"/> is changed to
                                       <var>P</var>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-visibility"/> is changed according to the
                                    rules in <specref ref="accepting-components"/>: in particular,
                                       <code>visibility="private"</code> changes to
                                       <code>visibility="hidden"</code>.</p>
                              </item>
                              <item>
                                 <p>The references to other components are rebound as described in
                                    this section.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>Component <var>C/P</var> is the overriding component. Its properties
                              are exactly as if it were declared as a top-level component in
                                 <var>P</var> (outside the <elcode>xsl:use-package</elcode>
                              element), except that (a) it must adhere to the constraints on
                              overriding components (see <specref ref="package-overriding-components"/>), (b) it is allowed to use
                              the variable reference <code>$xsl:original</code>, and (c) the fact
                              that it overrides <var>C/Q</var> affects the way that references from
                              other components are rebound.</p>
                        </item>
                        <item>
                           <p>Component <var>T/P</var> is a new component declared locally in
                                 <var>P</var>.</p>
                        </item>
                     </olist>

                  </example>

                  <p>The general rules for <termref def="dt-reference-binding"/> can now be
                     stated:</p>

                  <olist>
                     <item>
                        <p>If the <termref def="dt-containing-package"/> of a component
                              <var>C/P</var> is <var>P</var>, then all <termref def="dt-symbolic-reference">symbolic references</termref> in
                              <var>C/P</var> are bound to components whose <termref def="dt-containing-package"/> is <var>P</var>.</p>
                     </item>
                     <item>
                        <p>When a package <var>P</var> uses a package <var>Q</var>, then for every
                           component <var>C/Q</var> in <var>Q</var>, there is a <term>corresponding
                              component</term>
                           <var>C/P</var> in <var>P</var>, as described in <specref ref="accepting-components"/>.</p>
                     </item>
                     <item>
                        <p>Given a component <var>C/P</var> whose <termref def="dt-containing-package"/> and <termref def="dt-declaring-package"/> are the same package <var>P</var>, then (as a consequence of rules
                           elsewhere in this specification) for every <termref def="dt-symbolic-reference"/>
                           <var>D</var> within <var>C/P</var>, other than a reference using the name
                              <code>xsl:original</code>, there will always be exactly one non-hidden
                           component <var>D/P</var> whose containing package is <var>P</var> and
                           whose <termref def="dt-symbolic-identifier"/> matches <var>D</var>
                           (otherwise a static error will have been reported). The reference is then
                           bound to <var>D/P</var>.</p>
                     </item>
                     <item>
                        <p>In the case of a component reference using the name
                              <code>xsl:original</code>, this will in general appear within a
                           component <var>C/P</var> that overrides a component <var>C/Q</var> whose
                           corresponding component in <var>P</var> is <var>C/PQ</var>, and the
                              <code>xsl:original</code> reference is bound to <var>C/PQ</var>.</p>
                     </item>
                     <item>
                        <p>Given a component <var>C/P</var> whose <termref def="dt-containing-package"/>
                           <var>P</var> is a different package from its <termref def="dt-declaring-package"/>
                           <var>R</var> (that is, <var>C/P</var> is present in <var>P</var> by
                           virtue of an <elcode>xsl:use-package</elcode> declaration referencing
                           package <var>Q</var>, which may or may not be the same as <var>R</var>),
                           then the component bindings in <var>C/P</var> are derived from the
                           component bindings in the corresponding component <var>C/Q</var> as
                           follows: if the component binding within <var>C/Q</var> is to a component
                              <var>D/Q</var>, then:</p>
                        <olist>
                           <item>
                              <p>If <var>D/Q</var> is overridden within <var>P</var> by a component
                                    <var>D/P</var>, then the reference is bound to
                                 <var>D/P</var>;</p>
                           </item>
                           <item>
                              <p>Otherwise, the reference is bound to the component <var>D/PQ</var>
                                 in <var>P</var> whose corresponding component in <var>Q</var> is
                                    <var>D/Q</var>.</p>
                           </item>
                        </olist>
                     </item>
                  </olist>


                  <p>When reference resolution is performed on a package that is intended to be used
                     as a <termref def="dt-stylesheet">stylesheet</termref> (that is, for the
                        <termref def="dt-top-level-package">top-level package</termref>), there must
                     be no symbolic references referring to components whose visibility is
                        <code>abstract</code> (that is, an implementation must be provided for every
                     abstract component). </p>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3080">
                        <p>It is a <termref def="dt-static-error">static error</termref> if a
                              <termref def="dt-top-level-package">top-level package</termref> (as
                           distinct from a <termref def="dt-library-package">library
                              package</termref>) contains 
                           components whose visibility is <code>abstract</code>.</p>
                     </error>
                  </p>

                  <note diff="chg" at="A">
                     <p>Abstract components in a used package by default become hidden in the using package, 
                        which means that a reference to the component in the top-level package will fail 
                        to resolve (resulting in a different static error). This particular error occurs 
                        only if the abstract component is declared within the top-level package.
                     [XSLT 3.0 Erratum E4, bug 30142].</p>
                  </note>

                  <note>
                     <p>Unresolved references are allowed at the module level but not at the package
                        level. A stylesheet module can contain references to components that are
                        satisfied only when the module is imported into another module that declares
                        the missing component.</p>
                  </note>


                  <note>
                     <p>The process of resolving references (or linking) is critical to an
                        implementation that uses separate compilation. One of the aims of these
                        rules is to ensure that when compiling a package, it is always possible to
                        determine the signature of called functions, templates, and other
                        components. A further aim is to establish unambiguously in what
                        circumstances components can be overridden, so that compilers know when it
                        is possible to perform optimizations such as inlining of function and
                        variable references.</p>
                     <p>Suppose a public template <var>T</var> calls a private function
                        <var>F</var>. When the package containing these two components is referenced
                        by a using package, the template remains public, while the function becomes
                        hidden. Because the function becomes hidden, it can no longer conflict with
                        any other function of the same name, or be overridden by any other function;
                        at this stage the compiler knows exactly which function <var>T</var> will be
                        calling, and can perform optimizations based on this knowledge.</p>
                  </note>

                  <p>The mechanism for resolving component references described in
                     this section is consistent with the mechanism used for binding function and
                     variable references described in the XPath specification. XPath requires these
                     variable and function names to be present in the static context for an XPath
                     expression. XSLT ensures that all the non-hidden functions, global variables,
                     and global parameters in a package are present in the static context for every
                     XPath expression that appears in that package, along with required information
                     such as the type of a variable and the signature of a function.</p>

                  <example>
                     <!--https://lists.w3.org/Archives/Public/public-xsl-wg/2016Jul/0005.html-->
                     <head>Named Component References in Inline Functions</head>
                     
                     <p>Named component references within inline functions follow the standard rules, but the rules need
                        to be interpreted with care. Suppose that in package <var>P</var> we find the declarations:</p>
                     
                     <eg role="xslt-declarations" xml:space="preserve">
&lt;xsl:variable name="v" as="xs:integer" visibility="public" select="3"/&gt;

&lt;xsl:function name="f:factory" as="function(*)" visibility="final"&gt;
  &lt;xsl:sequence select="function() {$v}"/&gt;
&lt;/xsl:function&gt;  
                  </eg>
                     
                     <p>and that in a using package Q we find:</p>
                     
                     <eg role="xslt-declarations" xml:space="preserve">
      
&lt;xsl:use-package name="P"&gt;
  &lt;xsl:override&gt;
    &lt;xsl:variable name="v" as="xs:integer" select="4"/&gt;
  &lt;/xsl:override&gt;
&lt;/xsl:use-package&gt;

&lt;xsl:template name="xsl:initial-template"&gt;
  &lt;v value="{f:factory()()}"/&gt;
&lt;/xsl:template&gt;  
      </eg>
                     
                     <p>The correct output here is <code>&lt;v value="4"/&gt;</code>.</p>
                     
                     <p>The explanation for this is as follows. Package <var>Q</var> contains a function <var>f:factory/QP</var>
                        whose declaring package is <var>P</var> and whose containing package is <var>Q</var>. The symbolic reference
                        <code>$v</code> within the body of this function is resolved in the normal way; since the containing package
                        is <var>Q</var>, it is resolved to the global variable <var>v/Q</var>: that is, the overriding declaration
                        of <code>$v</code> that appears within the <elcode>xsl:override</elcode> element within package <var>Q</var>,
                        whose value is 4.</p>
                     
                     <p>In terms of internal implementation, one way of looking at this is that the anonymous function returned
                        by <code>f:factory</code> contains within its closure bindings for the global variables and functions that
                        the anonymous function references; these bindings are inherited from the component bindings of the
                        component that lexically contains these symbolic references, which in this case is <code>f:factory</code>,
                        and more specifically the version of the <code>f:factory</code> component in package <var>Q</var>.</p>
                  </example>

               </div4>

               <div4 id="dynamic-component-references">
                  <head>Dynamic References to Components</head>

                  <p>There are several functions in which a dynamically-evaluated QName is used to
                     identify a component: these include <function>key</function>,
                        <function>accumulator-before</function>,
                        <function>accumulator-after</function>,
                     <xfunction>function-lookup</xfunction>, and
                        <function>function-available</function>. Dynamic references can also occur
                     in the XPath expression supplied to the <elcode>xsl:evaluate</elcode>
                     instruction. </p>
                  <p>In all these cases, the set of components that are available to be referenced
                     are those that are declared in the package where this function call appears,
                     including components declared within an <elcode>xsl:override</elcode>
                     declaration in that package, but excluding components declared with
                        <code>visibility="abstract"</code>. If the relevant component has been
                     overridden in a different package, the overriding declarations are not
                     considered. </p>
                  <p>If one of these functions (for example <function>key</function> or
                        <function>accumulator-before</function>) is invoked via a dynamic function
                     invocation, then the relevant package is the one in which the function item is
                     created (using a construct such as <code>key#2</code>, <code>key('my-key',
                        ?)</code>, or <code>function-lookup($KEYFN, 2)</code>). Function items
                     referring to context-dependent functions bind the context at the point where
                     the function item is created, not the context at the point where the function
                     item is invoked.</p>
                  
                  <note>
                     <p>This means that if a package wishes to make a key available for use by a
                        calling package, it can do so by creating a public global variable whose
                        value is a partial application of the <function>key</function> function:</p>
                     <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:variable name="get-order" select="key('orders-key', ?, ?)"/&gt;</eg>
                     <p>which the calling code can invoke as <code>$get-order('123-456', /)</code>.</p>
                  </note>

               </div4>

            </div3>

            <div3 id="modes-and-packages">
               <head>Overriding Template Rules from a Used Package</head>
               <p>The rules in the previous section apply to named components including functions,
                  named templates, global variables, and named attribute sets. The rules for
                     <termref def="dt-mode">modes</termref>, and the <termref def="dt-template-rule">template rules</termref> appearing within a mode, are slightly different.</p>

               <p>The unnamed mode is local to a package: in effect, each package has its own
                  private unnamed mode, and the unnamed mode of one package does not interact with
                  the unnamed mode of any other package. An
                        <elcode>xsl:apply-templates</elcode> instruction with no <code>mode</code>
                     attribute is treated as a <termref def="dt-symbolic-reference"/> to the default
                     mode defined for that instruction (see <specref ref="default-mode"/>), which in
                     turn defaults to the <termref def="dt-unnamed-mode"/>. Because the unnamed mode
                     always has private visibility, it cannot be overridden in another 
                     package.</p>

               <p>A named mode may be declared in an <elcode>xsl:mode</elcode> declaration as being
                  either <code>public</code>, <code>private</code>, or <code>final</code>. The
                  values of the <code>visibility</code> attribute are interpreted as follows:</p>
               <table class="def">
                  <caption>Visibility Values for Named Modes, and their Meaning</caption>
                  <thead>
                     <tr>
                        <th rowspan="1" colspan="1">Value</th>
                        <th rowspan="1" colspan="1">Meaning</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td rowspan="1" colspan="1">public</td>
                        <td rowspan="1" colspan="1">A <term>using</term> package may use
                              <elcode>xsl:apply-templates</elcode> to invoke templates in this mode;
                           it may also declare additional template rules in this mode, which are
                           selected in preference to template rules in the used package. These may
                           appear only as children of the <elcode>xsl:override</elcode> element
                           within the <elcode>xsl:use-package</elcode> element.</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">private</td>
                        <td rowspan="1" colspan="1">A <term>using</term> package may neither reference the mode nor provide
                           additional templates in this mode; the name of the mode is not even
                           visible in the using package, so no such attempt is possible. The using
                           package can use the same name for its own modes without risk of conflict.
                        </td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">final</td>
                        <td rowspan="1" colspan="1">A <term>using</term> package may use
                              <elcode>xsl:apply-templates</elcode> to invoke templates in this mode,
                           but it must not provide additional template rules in this mode. </td>
                     </tr>
                  </tbody>
               </table>
               <p>As with other named components, an <elcode>xsl:use-package</elcode> declaration
                  may contain an <elcode>xsl:accept</elcode> element to control the visibility of a
                  mode acquired from the <term>used</term> package. The allowed values of its
                     <code>visibility</code> attribute are <code>public</code>,
                  <code>private</code>, and <code>final</code>.</p>



               <p>The <elcode>xsl:mode</elcode> declaration itself must not be overridden. A using
                  package must not contain an <elcode>xsl:mode</elcode> declaration whose name
                  matches that of a <code>public</code> or <code>final</code>
                  <elcode>xsl:mode</elcode> component accepted from a used package.</p>

               <p>The <elcode>xsl:expose</elcode> and <elcode>xsl:accept</elcode> elements may be
                  used to reduce the visibility of a mode in a using package; the same rules apply
                  in general, though some of the rules are not applicable because, for example,
                  modes cannot be <code>abstract</code>.</p>

               <p>It is not possible for a package to combine the template rules from two other
                  packages into a single mode. When <elcode>xsl:apply-templates</elcode> is used
                  without specifying a mode, the chosen template rules will always come from the
                  same package; when it is used with a named mode, then they will come from the
                  package where the mode is defined, or any package that uses that package and adds
                  template rules to the mode. If two template rules defined in different packages
                  match the same node, then the rule in the using package wins over any rule in the
                  used package; this decision is made before taking other factors such as import
                  precedence and priority into account.</p>

               <p>A static error occurs if two modes with the same name are visible within a
                  package, either because they are both declared within the package, or because one
                  is declared within the package and the other is acquired from a used package, or
                  because both are accepted from different used packages.</p>

               <p>The rules for matching template rules by <termref def="dt-import-precedence"/> and <termref def="dt-priority"/> operate as
                  normal, with the addition that template rules declared within an
                     <elcode>xsl:use-package</elcode> element have higher precedence than any
                  template rule declared in the used package. More specifically, given an <elcode>xsl:apply-templates</elcode> instruction
                     in package <var>P</var>, naming a mode <var>M</var> that is declared in a used
                     package <var>Q</var> and is overridden in <var>P</var>, the search order for
                     template rules is:</p>

               <olist>
                  <item>
                     <p>Rules declared within <var>P</var> (specifically,
                           <elcode>xsl:template</elcode> rules declared as children of an
                           <elcode>xsl:override</elcode> element within the
                           <elcode>xsl:use-package</elcode> element that references package
                           <var>Q</var>). If there are multiple rules declared within <var>P</var>
                        that match a selected node, they are resolved on the basis of their explicit
                        or implicit <termref def="dt-priority"/>, and if the priorities are equal, the last one in <termref def="dt-declaration-order"/> wins.</p>
                  </item>
                  <item>
                     <p>Rules declared within <var>Q</var>, taking <termref def="dt-import-precedence"/>, <termref def="dt-priority"/>, and <termref def="dt-declaration-order"/> into account in the usual way (see <specref ref="conflict"/>).</p>
                  </item>
                  <item>
                     <p>Built-in template rules (see <specref ref="built-in-rule"/>) selected
                        according to the <code>on-no-match</code> attribute of the
                           <elcode>xsl:mode</elcode> declaration (in <var>Q</var>), or its
                        default.</p>
                  </item>
               </olist>

               <p>If the mode is overridden again in a package
                     <var>R</var> that uses <var>P</var>, then this search order is extended by
                  adding <var>R</var> at the start of the search list, and so on recursively.</p>

               <note>
                  <p>If existing XSLT code has been written to use template rules in the unnamed
                     mode, a convenient way to incorporate this code into a <termref def="dt-library-package">library package</termref> is to add a stub module
                     that defines a new named <code>public</code> or <code>final</code> mode, in
                     which there is a single template rule whose content is the single instruction
                        <code>&lt;xsl:apply-templates select="."/&gt;</code>. This in effect redirects
                        <elcode>xsl:apply-templates</elcode> instructions using the named mode to
                     the rules defined in the unnamed mode.</p>
               </note>

               <div4 id="requiring-explicit-modes">
                  <head>Requiring Explicit Mode Declarations</head>
                  <p>In previous versions of XSLT, modes were implicitly declared by simply using a
                     mode name in the <code>mode</code> attribute of <elcode>xsl:template</elcode>
                     or <elcode>xsl:apply-templates</elcode>. XSLT 3.0 introduced the ability to
                     declare a mode explicitly using an <elcode>xsl:mode</elcode> declaration (see
                        <specref ref="declaring-modes"/>).</p>
                  <p>By default, within a package that is defined using an explicit
                        <elcode>xsl:package</elcode> element, all modes must be explicitly declared.
                     In an implicit package, however (that is, one rooted at an
                        <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element),
                     modes can be implicitly declared as in previous XSLT versions.</p>

                  <p>The <code>declared-modes</code>
                     attribute of <elcode>xsl:package</elcode> determines whether or not modes that
                     are referenced within the package must be explicitly declared. 
                     
                     If the value is <code>yes</code> (the default),
                     then it is an error to use a mode name 
                        unless the package either contains
                     an explicit <elcode>xsl:mode</elcode> declaration for that mode, or accepts the mode
                     from a used package. If the value is <code>no</code>, then this is not an error.
                     
                     
                  
                  </p>
                  <p>This attribute affects all modules making up the package, it is not confined to
                     declarations appearing as children of the <elcode>xsl:package</elcode>
                     element.</p>

                  <p>
                     <error spec="XT" type="static" class="SE" code="3085">
                        <p>It is a <termref def="dt-static-error">static error</termref>, 
                           when the effective value of the <code>declared-modes</code> attribute of 
                           an <elcode>xsl:package</elcode> element is <code>yes</code>, if the 
                           package contains an explicit reference to an undeclared mode, or if 
                           it implicitly uses the unnamed mode and the unnamed mode is undeclared.</p></error></p>
                     
                     <p>For the purposes of the above rule:</p>
                     
                     <olist>
                        <item><p>A mode is <term>declared</term> if either of the following conditions is true:</p>
                           <olist>
                              <item><p>The package contains an <elcode>xsl:mode</elcode> 
                                 declaration for that mode.</p></item>
                              <item><p>The mode is a public or final mode accepted 
                                 from a used package. </p></item>
                           </olist>                       
                        </item>
                        <item><p>The offending reference may be either an explicit mode name, or the token <code>#unnamed</code> 
                           treated as a reference to the unnamed mode, or a defaulted mode attribute, and it may occur in any of the following:</p>
                           <olist>
                              <item><p>The <code>mode</code> 
                                 attribute of an <elcode>xsl:template</elcode> declaration</p></item>
                              <item><p>The <code>mode</code> 
                                 attribute of an <elcode>xsl:apply-templates</elcode> instruction</p></item>
                              <item><p>An <code>[xsl:]default-mode</code> attribute.</p></item>
                           </olist>
                        </item>
                        <item><p>A package <term>implicitly uses the unnamed mode</term>
                           if either of the following conditions is true:</p>
                           <olist>
                              <item><p>There is an <elcode>xsl:apply-templates</elcode> 
                                 element with no <code>mode</code> attribute, and with no ancestor-or-self having 
                                 an <code>[xsl:]default-mode</code> attribute.</p></item>
                              <item><p>There is an <elcode>xsl:template</elcode> 
                                 element with a <code>match</code> attribute and no <code>mode</code> attribute, and with no ancestor-or-self having 
                                 an <code>[xsl:]default-mode</code> attribute.</p></item>
                           </olist>
                        </item>
                     </olist>
                     

             
                  
                  
               </div4>


            </div3>
            <div3 id="package-local-declarations">
               <head>Declarations Local to a Package</head>

               <p>The <elcode>xsl:import</elcode> and
                     <elcode>xsl:include</elcode> declarations are local to a package.</p>

               <p>Declarations of <termref def="dt-key">keys</termref>, <termref def="dt-accumulator">accumulators</termref>, 
                  <termref def="dt-decimal-format">decimal formats</termref>, namespace aliases (see
                     <specref ref="namespace-aliasing"/>), <termref def="dt-output-definition">output definitions</termref>, and <termref def="dt-character-map">character
                     maps</termref> within a package have local scope within that package —
                  they are all effectively private. The elements that declare these constructs do
                  not have a <code>visibility</code> attribute. The unnamed decimal format and the
                  unnamed output format are also local to a package.</p>
               <p>If <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode>
                  declarations appear within a <termref def="dt-library-package">library
                     package</termref>, they only affect calls to the <xfunction>doc</xfunction> or
                     <function>document</function> functions appearing within that package. Such a declaration within the <termref def="dt-top-level-package"/> additionally affects stripping of whitespace in
                     the document that contains the <termref def="dt-global-context-item"/>.</p>

               <p>An <elcode>xsl:decimal-format</elcode> declaration within a package applies only
                  to calls on <xfunction>format-number</xfunction> appearing within that
                  package.</p>

               <p>An <elcode>xsl:namespace-alias</elcode> declaration within a package applies only
                  to literal result elements within the same package.</p>

               <p>An <elcode>xsl:import-schema</elcode> declaration within a package adds the names
                  of the imported schema components to the static context for that package only;
                  these names are effectively private, in the sense that they do not become
                  available for use in any other packages. However, the names of schema components
                  must be consistent across the stylesheet as a whole: it is not possible for two
                  different packages within a stylesheet to use a type-name such as <code>part-number</code> to
                  refer to different schema-defined simple or complex types.</p>

               <p>Type names used in the interface of public components in a package (for example,
                  in the arguments of a function) must be respected by callers of those components,
                  in the sense that the caller must supply values of the correct type. Often this
                  will mean that the using component, if it contains calls on such interfaces, must
                  itself import the necessary schema components. However, the requirement for an
                  explicit schema import applies only where the package contains explicit use of the
                  names of schema components required to call such interfaces.</p>

               <note>
                  <p>For example, suppose a <termref def="dt-library-package">library
                        package</termref> contains a function which requires an argument of type
                        <code>mfg:part-number</code>. The caller of this function must supply an
                     argument of the correct type, but does not need to import the schema unless it
                     explicitly uses the schema type name <code>mfg:part-number</code>. If it
                     obtains an instance of this type from outside the package, for example as the
                     result of another function call, then it can supply this instance to the
                     acquired function even though it has not imported a schema that defines this
                     type.</p>
               </note>


               <p>At execution time, the schema available for validating instance documents contains
                  (at least) the union of the schema components imported into all constituent
                  packages of the stylesheet.</p>

            </div3>


            <div3 id="declaring-global-context-item">
               <head>Declaring the Global Context Item</head>

               <p>The <elcode>xsl:global-context-item</elcode> element is used to declare whether a
                     <termref def="dt-global-context-item"/> is required, and if so, what its
                     <termref def="dt-required-type"/> is.</p>

               <p>The element is a <termref def="dt-declaration"/> that
                  can appear at most once in any stylesheet module; and if more than one
                     <elcode>xsl:global-context-item</elcode> declaration appears within a <termref def="dt-package"/>, then the declarations must be consistent. Specifically, all
                  the attributes <rfc2119>must</rfc2119> have semantically-equivalent values.</p>

               <note>
                  <p>This means that omitting an attribute is equivalent to specifying its default
                     value explicitly; and purely lexical variations, such as the presence of whitespace
                     in an attribute value, are not considered significant.</p>
               </note>

               <p>
                  <error spec="XT" type="static" class="SE" code="3087">
                     <p>It is a <termref def="dt-static-error">static error</termref> if more than
                        one <elcode>xsl:global-context-item</elcode> declaration appears within a
                           <termref def="dt-stylesheet-module"/>, or if several modules within a
                        single <termref def="dt-package"/> contain inconsistent
                           <elcode>xsl:global-context-item</elcode> declarations</p>
                  </error></p>

               <p>If there is no <elcode>xsl:global-context-item</elcode> declaration for a package,
                  this is equivalent to specifying the empty element
                     <code>&lt;xsl:global-context-item/&gt;</code>, which imposes no constraints.</p>



               <?element xsl:global-context-item?>

               <p>The <code>use</code> attribute takes the value <code>required</code>,
                     <code>optional</code>, or <code>absent</code>. The
                  default is <code>optional</code>.</p>
               <ulist>
                     <item>
                        <p>If the value <code>required</code> is specified, then there must be a
                           global context item. </p>
                     </item>
                     <item>
                        <p>If the value <code>optional</code> is specified, or if the attribute is
                           omitted, or if the <elcode>xsl:global-context-item</elcode> element is
                           omitted, then there may or may not be a global context item.</p>
                     </item>
                     <item>
                        <p>If the value <code>absent</code> is specified, then the global focus
                           (context item, position, and size) will be <termref def="dt-absent"/></p>
                        <note>
                           <p>This specification does not define whether supplying a global context
                              item in this situation results in an error or warning, or whether the
                              supplied context item is simply ignored.</p>
                        </note>
                     </item>
                  </ulist>

               <p>If the <code>as</code> attribute is present then its value must be an <xnt spec="XP40" ref="prod-xpath40-ItemType">ItemType</xnt>. If the attribute is
                  omitted this is equivalent to specifying <code>as="item()"</code>.</p>
               <p>The <code>as</code> attribute defines the required type of the global context
                  item. The default value is <code>as="item()"</code>. If a global context item is
                  supplied then it must conform to the required type, after conversion (if
                  necessary) using the <termref def="dt-coercion-rules"/>.</p>

               <p><error spec="XT" type="static" class="SE" code="3089">
                     <p>It is a <termref def="dt-static-error"/> if the <code>as</code> attribute is
                        present <error.extra>on the <elcode>xsl:global-context-item</elcode>
                           element</error.extra> when <code>use="absent"</code> is specified.</p>
                  </error></p>

               

               

               

               <p>The global context item is available only within the <termref def="dt-top-level-package"/>. If a valid <elcode>xsl:global-context-item</elcode>
                  declaration appears within a <termref def="dt-library-package"/>, then it is
                  ignored, unless it specifies <code>use="required"</code>, in which case an error
                  is signaled: <errorref spec="XT" class="TE" code="0590"/>.</p>
               

               <note>
                  <p>In earlier releases of this specification, the <termref def="dt-global-context-item"/> and
                  the <termref def="dt-initial-match-selection"/> were essentially the same thing, often referred
                  to as the <emph>principal source document</emph>. In XSLT 3.0, they were separated:
                  the global context item is a single item accessible to the initializers of global variables
                  as the value of the expression <code>.</code> (dot), while the initial match selection
                  is a sequence of nodes or other items supplied to an initial implicit <elcode>xsl:apply-templates</elcode>
                  invocation.</p>
                  <p>APIs that were originally designed for use with earlier versions of XSLT
                  are likely to bundle the two concepts together.</p>
                  <p>With a streamable processor, the <termref def="dt-initial-match-selection"/> can consist
                  of streamed nodes, but the <termref def="dt-global-context-item"/> is always <termref def="dt-grounded"/>,
                  because it is available to all global variables and there is no control over the sequence of processing.</p>
                  
                  
               </note>



               <p>A <termref def="dt-type-error"/> is signaled if 
                  <phrase diff="chg" at="A">the <termref def="dt-top-level-package"/> contains</phrase>
                  an <elcode>xsl:global-context-item</elcode>
                  declaration specifying a required type that does not match the supplied <termref def="dt-global-context-item"/>. The error code is the same as for
                     <elcode>xsl:param</elcode>: <errorref spec="XT" class="TE" code="0590"/>.
                  <phrase diff="add" at="A">[XSLT 3.0 Erratum E7, bug 30179].</phrase></p>



               <note>
                  <p>If the <code>ItemType</code> is one that can only be satisfied by a
                     schema-validated input document, for example
                        <code>as="schema-element(invoice)"</code>, the <termref def="dt-processor">processor</termref> may interpret this as a request to apply schema
                     validation to the input. Similarly, if the <code>KindTest</code> indicates that
                     an element node is required, the processor may interpret this as a request to
                     supply the document element rather than the document node of a supplied input
                     document.</p>
               </note>
               
               <p diff="add" at="A">
                  <error spec="XT" type="dynamic" class="DE" code="3086">
                     <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if an
                        <elcode>xsl:global-context-item</elcode> declaration specifies
                     <code>use="required"</code>, and no global context item is supplied. [XSLT 3.0 Erratum E6, bug 30173].</p>
                  </error></p>

            </div3>



            <div3 id="packages-csv-library-example">
               <head>Worked Example of a Library Package</head>





               <p>The example in this section illustrates the use of overrides to customize or
                  extend a (fictional) library package named
                     <code>http://example.com/csv-parser</code>, which provides a parsing function
                  for data formatted as lines containing comma-separated values. For simplicity of
                  exposition, the example shows a simple, naive implementation; a realistic CSV
                  parser would be more complicated and make the example harder to follow.</p>

               <div4 id="csv-example-default-functionality">
                  <head>Default Functionality of the CSV Package</head>

                  <p>The basic functionality of the package is provided by the function
                        <code>csv:parse</code>, which expects a string parameter named
                        <code>input</code>. By default, the function parses the input into lines,
                     and breaks lines on commas, returning as result an element named
                        <code>csv</code> containing one <code>row</code> element per line, each
                        <code>row</code> containing a sequence of <code>field</code> elements.</p>

                  <p>A simple stylesheet which uses this library and applies it to a string might
                     look like the following. The initial template applies <code>csv:parse</code> to
                     a suitable string and returns a copy of the result:</p>
                  <eg role="xslt-document" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:csv="http://example.com/csv"
   exclude-result-prefixes="xs csv"
   version="3.0"&gt;

   &lt;xsl:output indent="yes" /&gt;

   &lt;xsl:use-package name="http://example.com/csv-parser" 
                    package-version="*" /&gt;

   &lt;!-- example input "file"  --&gt;
   &lt;xsl:variable name="input" as="xs:string"&gt;
       name,id,postal code
       "Abel Braaksma",34291,1210 KA
       "Anders Berglund",473892,9843 ZD
   &lt;/xsl:variable&gt;

   &lt;!-- entry point --&gt;
   &lt;xsl:template name="xsl:initial-template"&gt;
       &lt;xsl:copy-of select="csv:parse($input)" /&gt;
   &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</eg>
                  <p>The result returned by this stylesheet would be:</p>
                  <eg role="xml" xml:space="preserve">&lt;csv&gt;
  &lt;row&gt;
    &lt;field quoted="no"&gt;name&lt;/field&gt;
    &lt;field quoted="no"&gt;id&lt;/field&gt;
    &lt;field quoted="no"&gt;postal code&lt;/field&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;field quoted="yes"&gt;Abel Braaksma&lt;/field&gt;
    &lt;field quoted="no"&gt;34291&lt;/field&gt;
    &lt;field quoted="no"&gt;1210 KA&lt;/field&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;field quoted="yes"&gt;Anders Berglund&lt;/field&gt;
    &lt;field quoted="no"&gt;473892&lt;/field&gt;
    &lt;field quoted="no"&gt;9843 ZD&lt;/field&gt;
  &lt;/row&gt;
&lt;/csv&gt;
</eg>

                  <p>Variations on this default behavior are achieved by overriding selected
                     declarations in the package, as described below.</p>
               </div4>

               <div4 id="csv-example-package-structure">
                  <head>Package Structure</head>

                  <p>The package module itself is version 1.0.0 of a package called
                        <code>http://example.com/csv-parser</code>; it has the following
                     structure:</p>
                  <eg role="xslt-document" xml:space="preserve">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:package
   name="http://example.com/csv-parser"
   package-version="1.0.0"
   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:csv="http://example.com/csv"
   exclude-result-prefixes="xs csv"
   declared-modes="yes"
   version="3.0"&gt;

   &lt;!--* Mode declarations ... *--&gt;
   &lt;!--* Variable declarations ... *--&gt;
   &lt;!--* Attribute-set declaration ... *--&gt;
   &lt;!--* Function declarations ... *--&gt;
   &lt;!--* Templates ... *--&gt;

&lt;/xsl:package&gt;</eg>

                  <p>The contents of the package (represented here by comments) are described more
                     fully below.</p>
               </div4>

               <div4 id="csv-example-customizing-parse">
                  <head>The <code>csv:parse</code> Function and its User-customization Hooks</head>

                  <p>The <code>csv:parse</code> function is final and cannot be overridden. As can be
                     seen from the code below, it (1) parses its <code>input</code> parameter into
                     lines, (2) calls function <code>csv:preprocess-line</code> on each line, then
                     (3) applies the templates of mode <code>csv:parse-line</code> to the
                     pre-processed value. The result is then (4) processed again by mode
                        <code>csv:post-process</code>.</p>

                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:function name="csv:parse" visibility="final"&gt;
    &lt;xsl:param name="input" as="xs:string" /&gt;   
    &lt;xsl:variable name="result" as="element()"&gt;
        &lt;csv&gt;
            &lt;xsl:apply-templates 
                select="(tokenize($input, $csv:line-separator) 
                        ! csv:preprocess-line(.))" 
                mode="csv:parse-line" /&gt;
        &lt;/csv&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:apply-templates select="$result" 
                         mode="csv:post-process" /&gt;
&lt;/xsl:function&gt;
</eg>

                  <p>The default code for this processing is given below. Each part of the
                     processing except the first (the tokenization into lines) can be overridden by
                     the user of the package.</p>
               </div4>
               <div4 id="csv-example-line-breaking">
                  <head>Breaking the Input into Lines</head>
                  <p>The first user-customization hook is given by the global variable
                        <code>csv:line-separator</code>, which specifies the line separator used to
                     break the input string into lines. It can be overridden by the user if need be.
                     The default declaration attempts to handle the line-separator sequences used by
                     most common operating systems in text files:</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:variable name="csv:line-separator" 
              as="xs:string" 
              select="'\r\n?|\n\r?'" 
              visibility="public"/&gt;
</eg>
               </div4>

               <div4 id="csv-example-preprocessing-lines">
                  <head>Pre-processing the Lines</head>

                  <p>The function <code>csv:preprocess-line</code> calls
                        <code>normalize-space()</code> on its argument:</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:function name="csv:preprocess-line" 
                 as="xs:string?" 
                 visibility="public"&gt;
    &lt;xsl:param name="line" as="xs:string" /&gt;
    &lt;xsl:sequence select="normalize-space($line)" /&gt;
&lt;/xsl:function&gt;
</eg>
                  <p>Because the function is declared <code>public</code>, it can be overridden by a
                     user. (This might be necessary, for example, if whitespace within quoted
                     strings needs to be preserved.)</p>
               </div4>

               <div4 id="example-csv-mode-parse-line">
                  <head>The Mode <code>csv:parse-line</code></head>

                  <p>By default, the mode <code>csv:parse-line</code> parses the current item (this
                     will be one line of the input data) into fields, using mode
                        <code>csv:parse-field</code> on the individual fields and (by default)
                     wrapping the result in a <code>row</code> element.</p>
                  <p>The mode is declared with <code>visibility="public"</code> to allow it to be
                     called from elsewhere and overridden:</p>

                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:mode name="csv:parse-line" visibility="public"/&gt;</eg>

                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:template match="." mode="csv:parse-line"&gt;
    &lt;row&gt;
        &lt;xsl:apply-templates 
            select="tokenize(., $csv:field-separator)" 
            mode="csv:parse-field" /&gt;
    &lt;/row&gt;
&lt;/xsl:template&gt;
</eg>
                  <p>This relies on the variable <code>csv:field-separator</code>, which is a comma
                     by default but which can be overridden by the user to parse tab-separated data
                     or data with other delimiters.</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:variable name="csv:field-separator" 
              as="xs:string" 
              select="','" 
              visibility="public"/&gt;
</eg>
                  <p>The default implementation of <code>csv:parse-line</code> does not handle
                     occurrences of the field separator occurring within quoted strings. The user
                     can add templates to the mode to provide that functionality. </p>
               </div4>

               <div4 id="csv-example-mode">
                  <head>Mode <code>csv:parse-field</code></head>

                  <p>Mode <code>csv:parse-field</code> processes the current item as a field; by
                     default it strips quotation marks from the value, calls the function
                        <code>csv:preprocess-field()</code> on it, and wraps the result in a
                        <code>field</code> element, which carries the attributes declared in the
                     attribute set <code>csv:field-attributes</code>.</p>

                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">
&lt;xsl:template match="." 
              mode="csv:parse-field" 
              expand-text="yes"&gt;
    &lt;xsl:variable name="string-body-pattern"
                  as="xs:string"
                  select="'([^' || $csv:validated-quote || ']*)'"/&gt;
    &lt;xsl:variable name="quoted-value"
                  as="xs:string"
                  select="$csv:validated-quote 
                          || $string-body-pattern 
                          || $csv:validated-quote"/&gt;
    &lt;xsl:variable name="unquoted-value"
                  as="xs:string"
                  select="'(.+)'"/&gt;

    &lt;field xsl:use-attribute-sets="csv:field-attributes"&gt;{
        csv:preprocess-field(
          replace(., 
                  $quoted-value || '|' || $unquoted-value, 
                  '$1$2'))
    }&lt;/field&gt;
&lt;/xsl:template&gt;
</eg>


                  <!--<p>I am having trouble deciding whether a user will find it more
convenient to have csv:preprocess-field() called before or after
quotation marks are stripped.  I don't suppose that for purposes of
the example it is essential that we have the best possible design, but
there is no need to make it needlessly implausible.</p>-->


                  <p>The attribute set <code>csv:field-attributes</code> includes, by default, a
                        <code>quoted</code> attribute which has the values <code>yes</code> or
                        <code>no</code> to show whether the input value was quoted or not.</p>

                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:attribute-set name="csv:field-attributes" 
                   visibility="public"&gt;
    &lt;xsl:attribute name="quoted" 
                   select="if (starts-with(., $csv:validated-quote)) 
                           then 'yes' 
                           else 'no'" /&gt;
&lt;/xsl:attribute-set&gt;
</eg>

                  <p>The mode <code>csv:parse-field</code> is declared with
                        <code>visibility="public"</code> to allow it to be called from elsewhere and
                     overridden; it specifies <code>on-no-match="shallow-copy"</code> so that any
                     string not matching a template will simply be copied:</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:mode name="csv:parse-field"
          on-no-match="shallow-copy" 
          visibility="public"/&gt;
</eg>
               </div4>

               <div4 id="csv-example-variable">
                  <head>The <code>csv:quote</code> Variable</head>

                  <p>The variable <code>csv:quote</code> can be used to specify the character used
                     in a particular input stream to quote values.</p>

                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:variable name="csv:quote" 
              as="xs:string" 
              select="'&amp;quot;'" 
              visibility="public"/&gt;
</eg>

                  <p>The template given above assumes that the variable is one character long. To
                     ensure that any overriding value of the variable is properly checked, references to the value use a
                     second variable <code>csv:validated-quote</code>, which
                     is declared <code>private</code> to ensure that the checking cannot be
                     disabled.</p>

                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:variable name="csv:validated-quote" visibility="private"
   as="xs:string" select="
       if (string-length($csv:quote) ne 1) 
       then error(xs:QName('csv:ERR001'), 
                  'Incorrect length for $csv:quote, should be 1') 
       else $csv:quote" /&gt;
</eg>

                  <p>When the value of <code>csv:quote</code> is not
                     exactly one character long, the reference to
                        <code>csv:validated-quote</code> will cause an error (csv:ERR001)
                     to be raised.</p>

               </div4>
               <div4 id="csv-example-preprocess-field">
                  <head>The <code>csv:preprocess-field</code> Function</head>

                  <p>The function <code>csv:preprocess-field</code> is called on each field after
                     any quotation marks are stripped and before it is written out as the value of a
                        <code>field</code> element:</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:function name="csv:preprocess-field" 
              as="xs:string"&gt;
    &lt;xsl:param name="field" 
               as="xs:string" /&gt;
    &lt;xsl:sequence select="$field" /&gt;
&lt;/xsl:function&gt;
</eg>
                  <p>As can be seen, the function does nothing but return its input; its only
                     purpose is to provide the opportunity for the user to supply a suitable
                     function to be invoked at this point in the processing of each field.</p>

               </div4>


               <div4 id="csv-example-postprocess">
                  <head>The Mode <code>csv:post-process</code></head>
                  <p>The mode <code>csv:post-process</code> is intended solely as a hook for user
                     code. By default, it does nothing.</p>

                  <p>The package defines no templates for this mode; the mode definition makes it
                     return a copy of its input:</p>
                  <eg role="xslt-declaration xmlns:csv='http://example.com/csv'" xml:space="preserve">&lt;xsl:mode name="csv:post-process" 
          on-no-match="shallow-copy" 
          visibility="public"/&gt;
</eg>
               </div4>

               <div4 id="csv-example-overriding">
                  <head>Overriding the Default Behavior</head>

                  <p>As can be seen from the code shown above, the package provides several
                     opportunities for users to override the default behavior:</p>
                  <ulist>
                     <item>
                        <p>The global variables <code>csv:line-separator</code>,
                              <code>csv:field-separator</code>, and <code>csv:quote</code> can be
                           overridden to specify the character strings used to separate lines and
                           fields and to quote individual field values.</p>
                     </item>
                     <item>
                        <p>The function <code>csv:preprocess-line</code> can be overridden to do
                           more (or less) than stripping white space; the function
                              <code>csv:preprocess-field</code> can be overridden to process
                           individual field values.</p>
                     </item>
                     <item>
                        <p>Templates can be added to the modes <code>csv:parse-line</code>,
                              <code>csv:parse-field</code>, and <code>csv:post-process</code> to
                           change their behavior.</p>
                     </item>
                     <item>
                        <p>The attribute set <code>csv:field-attributes</code> can be overridden to
                           specify a different set of attributes (or none) for <code>field</code>
                           elements.</p>
                     </item>
                  </ulist>

                  <p>The following using stylesheet illustrates the use of the
                        <elcode>xsl:override</elcode> element to take advantage of several of these
                     opportunities:</p>


                  <eg role="xslt-document" xml:space="preserve">
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:csv="http://example.com/csv"
   exclude-result-prefixes="xs csv"
   version="3.0"&gt;

   &lt;xsl:output indent="yes" /&gt;

   &lt;xsl:use-package name="http://example.com/csv-parser" 
                    package-version="*"&gt;
       &lt;xsl:override&gt;
           &lt;!-- Change the root element from 'csv' to 'root' --&gt;
           &lt;xsl:template match="csv" mode="csv:post-process"&gt;
               &lt;root&gt;
                   &lt;xsl:apply-templates mode="csv:post-process" /&gt;
               &lt;/root&gt;
           &lt;/xsl:template&gt;

           &lt;!-- add an extra attribute that uses the context item --&gt;
           &lt;xsl:attribute-set name="csv:field-attributes" 
                              use-attribute-sets="xsl:original"&gt;
               &lt;xsl:attribute name="type" 
                              select="if (. castable as xs:decimal) 
                                      then 'numeric' 
                                      else 'string'" /&gt;
           &lt;/xsl:attribute-set&gt;          

           &lt;!-- use semicolon not comma between fields --&gt;
           &lt;xsl:variable name="csv:field-separator" 
                         as="xs:string" select="';'" 
                         visibility="public"/&gt;

           &lt;!-- prevent empty rows from appearing with empty lines --&gt;
           &lt;xsl:function name="csv:preprocess-line" 
                         as="xs:string?" 
                         visibility="public"&gt;
               &lt;xsl:param name="line" as="xs:string" /&gt;
               &lt;xsl:variable name="norm-line" 
                             select="normalize-space(xsl:original($line))" /&gt;
               &lt;xsl:sequence select="if (string-length($norm-line) &gt; 0) 
                                     then $norm-line 
                                     else ()" /&gt;
           &lt;/xsl:function&gt;
       &lt;/xsl:override&gt;
   &lt;/xsl:use-package&gt;

   &lt;!-- example input "file"  --&gt;
   &lt;xsl:variable name="input" as="xs:string"&gt;
       name;id;postal code
       "Braaksma Abel";34291;1210 KA
       "Berglund Anders";473892;9843 ZD
   &lt;/xsl:variable&gt;

   &lt;!-- entry point --&gt;
   &lt;xsl:template name="xsl:initial-template"&gt;
       &lt;xsl:copy-of select="csv:parse($input)" /&gt;
   &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
                  <note>
                     <ulist>
                        <item>
                           <p>As it does elsewhere, the visibility of components declared within
                                 <elcode>xsl:override</elcode> defaults to <code>private</code>; to keep
                              the component public, it is necessary to specify visibility
                              explicitly.</p>
                        </item>
                        <item>
                           <p>The types and optionality of all function parameters must match those
                              of the function being overridden; for function overriding to be
                              feasible, packages must document the function signature
                              thoroughly.</p>
                        </item>
                        <item>
                           <p>The names, types, and optionality of all named-template parameters
                              must match those of the template being overridden; for overriding to
                              be feasible, packages must document the template signature
                              thoroughly.</p>
                        </item>
                        <item>
                           <p>The values for the attributes in the attribute set
                                 <code>csv:field-attributes</code> are calculated once for each
                              element for which the attribute set is supplied; the
                                 <code>select</code> attributes which determine the values can thus
                              refer to the context item. Here, the value specification for the
                                 <code>type</code> attribute checks to see whether the string value
                              of the context item is numeric by inquiring whether it can be cast to
                              decimal, and sets the value for the <code>type</code> attribute
                              accordingly.</p>
                        </item>
                     </ulist>
                  </note>

                  <p>The result returned by this stylesheet would be:</p>
                  <eg role="xml" xml:space="preserve">&lt;root&gt;
  &lt;row&gt;
    &lt;field quoted="no" type="string"&gt;name&lt;/field&gt;
    &lt;field quoted="no" type="string"&gt;id&lt;/field&gt;
    &lt;field quoted="no" type="string"&gt;postal code&lt;/field&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;field quoted="yes" type="string"&gt;Braaksma Abel&lt;/field&gt;
    &lt;field quoted="no" type="numeric"&gt;34291&lt;/field&gt;
    &lt;field quoted="no" type="string"&gt;1210 KA&lt;/field&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;field quoted="yes" type="string"&gt;Berglund Anders&lt;/field&gt;
    &lt;field quoted="no" type="numeric"&gt;473892&lt;/field&gt;
    &lt;field quoted="no" type="string"&gt;9843 ZD&lt;/field&gt;
  &lt;/row&gt;
&lt;/root&gt;
</eg>
               </div4>


            </div3>


            


         </div2>
         <div2 id="stylesheet-modules">
            <head>Stylesheet Modules</head>

            <p>
               <termdef id="dt-stylesheet-module" term="stylesheet module">A <termref def="dt-package">package</termref> consists of one or
                  more <term>stylesheet modules</term>, each one forming all or part of an XML
                  document.</termdef>
            </p>
            <note>
               <p>A stylesheet module is represented by an XDM element node (see <bibref ref="xpath-datamodel-30"/>). In the case of a standard stylesheet module, this
                  will be an <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode>
                  element. In the case of a simplified stylesheet module, it can be any element (not
                  in the <termref def="dt-xslt-namespace">XSLT namespace</termref>) that has an
                     <code>xsl:version</code> attribute.</p>
               <p>Although stylesheet modules will commonly be maintained in the form of documents
                  conforming to XML 1.0 or XML 1.1, this specification does not mandate such a
                  representation. As with <termref def="dt-source-tree">source trees</termref>, the
                  way in which stylesheet modules are constructed, from textual XML or otherwise, is
                  outside the scope of this specification.</p>
            </note>

            <p>The principal stylesheet module of a package may take one
               of three forms:</p>

            <ulist>
               <item>
                  <p>A package manifest, as described in <specref ref="packages"/>, which is a
                     subtree rooted at an <elcode>xsl:package</elcode> element</p>
               </item>
               <item>
                  <p>An implicit package, which is a subtree rooted at an
                        <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element.
                     This is transformed automatically to a package as described in <specref ref="packages"/>. </p>
               </item>
               <item>
                  <p>A simplified stylesheet, which is a subtree rooted at a literal result element,
                     as described in <specref ref="simplified-stylesheet"/>. This is first converted
                     to an implicit package by wrapping it in an <elcode>xsl:stylesheet</elcode>
                     element using the transformation described in <specref ref="simplified-stylesheet"/>, and then to an explicit package (rooted at an
                        <elcode>xsl:package</elcode> element) using the transformation described in
                        <specref ref="packages"/>. </p>
               </item>
            </ulist>

            <p>A stylesheet module other than the principal stylesheet
               module of a package may take either of two forms:</p>

            <ulist>
               <item>
                  <p><termdef id="dt-standard-stylesheet-module" term="standard stylesheet module">A
                           <term>standard stylesheet module</term>, which is a subtree rooted at an
                           <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode>
                        element.</termdef></p>
               </item>
               <item>
                  <p><termdef id="dt-simplified-stylesheet-module" term="simplified stylesheet">A
                           <term>simplified stylesheet</term>, which is a subtree rooted at a
                           <termref def="dt-literal-result-element">literal result
                        element</termref>, as described in <specref ref="simplified-stylesheet"/>.
                        This is first converted to a <termref def="dt-standard-stylesheet-module">standard stylesheet module</termref> by wrapping it in an xsl:stylesheet
                        element using the transformation described in <specref ref="simplified-stylesheet"/>.</termdef>
                  </p>
               </item>
            </ulist>
            <p>Whichever of the above forms a module takes, the outermost
               element (<elcode>xsl:package</elcode>, <elcode>xsl:stylesheet</elcode>, or a <termref def="dt-literal-result-element"/>) <rfc2119>may</rfc2119> either be the outermost
               element of an XML document, or it <rfc2119>may</rfc2119> be a child of some
               (non-XSLT) element in a host document. </p>
            <p><termdef id="dt-embedded-stylesheet-module" term="embedded stylesheet module">A stylesheet module whose outermost element is
                  the child of a non-XSLT element in a host document is referred to as an
                     <term>embedded stylesheet module</term>. See <specref ref="embedded"/>.</termdef>
            </p>


         </div2>
         <div2 id="stylesheet-element">
            <head>Stylesheet Element</head>
            <?element xsl:stylesheet?>
            <?element xsl:transform?>

            <p>A stylesheet module is represented by an <elcode>xsl:stylesheet</elcode> element in
               an XML document. <elcode>xsl:transform</elcode> is allowed as a synonym for
                  <elcode>xsl:stylesheet</elcode>; everything this specification says about the
                  <elcode>xsl:stylesheet</elcode> element applies equally to
                  <elcode>xsl:transform</elcode>.</p>

            <p>The <code>version</code> attribute indicates the version
               of XSLT that the stylesheet module requires. The attribute is
                  <rfc2119>required</rfc2119>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0110">
                  <p>The value of the <code>version</code> attribute <rfc2119>must</rfc2119> be a number:
                     specifically, it <rfc2119>must</rfc2119> be a valid instance of the type
                        <code>xs:decimal</code> as defined in <bibref ref="xmlschema-2"/>.</p>
               </error>
            </p>
            <p>The <code>version</code> attribute is intended to indicate the
               version of the XSLT specification against which the stylesheet is written. In a
               stylesheet written to use XSLT 4.0, the value <rfc2119>should</rfc2119> normally be
               set to <code>4.0</code>. If the value is numerically less than <code>4.0</code>, the
               stylesheet is processed using the rules for <termref def="dt-backwards-compatible-behavior">backwards compatible behavior</termref>
               (see <specref ref="backwards"/>). If the value is numerically greater than
                  <code>3.0</code>, the stylesheet is processed using the rules for <termref def="dt-forwards-compatible-behavior"/> (see <specref ref="forwards"/>).</p>

            <!--For this version of XSLT, the value <rfc2119>should</rfc2119> normally
be <code>
                  <phrase diff="chg" at="A">3.0</phrase>
               </code>.  A value of <code>1.0</code> indicates that the stylesheet module
was written with the intention that it <rfc2119>should</rfc2119> be processed using an XSLT 1.0 processor,
               <phrase diff="add" at="D">while a value of <code>2.0</code> indicates that the module
                  was intended to be processed using an XSLT 2.0 processor</phrase>.</p>
            <p>If a <termref def="dt-stylesheet">stylesheet</termref>
that specifies <code>[xsl:]version="1.0"</code> in the
outermost element of the <termref def="dt-principal-stylesheet-module">principal
stylesheet module</termref> (that is, <code>version="1.0"</code> in the case of a 
<termref def="dt-standard-stylesheet-module">standard stylesheet module</termref>, or
<code>xsl:version="1.0"</code> in the case of a <termref def="dt-simplified-stylesheet-module">simplified
stylesheet module</termref>) is submitted to an XSLT <phrase diff="chg" at="A">3.0</phrase> processor, the processor <rfc2119>should</rfc2119> output
a warning advising the user of possible incompatibilities, unless the user has requested otherwise. 
The processor <rfc2119>must</rfc2119> then process the stylesheet
using the rules for <termref def="dt-backwards-compatible-behavior"/>.
These rules require that if the processor does not support 
<termref def="dt-backwards-compatible-behavior"/>, it <rfc2119>must</rfc2119>
signal an error and <rfc2119>must not</rfc2119> execute the transformation.</p>
            <p>When the value of the <code>version</code> attribute is greater than <phrase diff="chg" at="A">3.0</phrase>, 
<termref def="dt-forwards-compatible-behavior">forwards compatible behavior</termref> 
is enabled (see <specref ref="forwards"/>).</p>
            <note>
               <p>XSLT 1.0 allowed the <code>[xsl:]version</code> attribute to take any numeric value,
and specified that if the value was not equal to 1.0, the <termref def="dt-stylesheet">stylesheet</termref> would be executed in
forwards compatible mode. XSLT 2.0 <phrase diff="chg" at="A">and 3.0</phrase>continue to allow the attribute to take any unsigned decimal value.
A software product that includes both an XSLT <phrase diff="chg" at="A">3.0</phrase> processor and
<phrase diff="chg" at="A">a processor supporting a different XSLT version</phrase> (or that can execute as either) may use the <code>[xsl:]version</code> attribute to 
decide which processor to invoke; such behavior is outside the scope of this specification. 
When the stylesheet is executed with an XSLT <phrase diff="chg" at="A">3.0</phrase> processor, the value
<code>1.0</code> is taken to indicate that the stylesheet module
was written with XSLT 1.0
in mind: if this value appears on the outermost element of the principal stylesheet module then
an XSLT <phrase diff="chg" at="A">3.0</phrase> processor will either reject the stylesheet or execute it in backwards compatible
mode, as described above. 
Setting <code>version="<phrase diff="chg" at="A">3.0</phrase>"</code> indicates that the <termref def="dt-stylesheet">stylesheet</termref> is to be
executed with neither backwards nor forwards compatible behavior enabled. Any other value less than
<code>2.0</code> enables backwards compatible behavior, while any value greater than <code>
                     <phrase diff="chg" at="A">3.0</phrase>
                  </code>
enables forwards compatible behavior.</p>
               
               <p>When developing a <termref def="dt-stylesheet">stylesheet</termref> that is designed to execute under either XSLT 1.0 or XSLT 2.0,
the recommended practice is to create two alternative <termref def="dt-stylesheet-module">stylesheet modules</termref>, 
one specifying
<code>version="1.0"</code>, and the other specifying <code>version="2.0"</code>; these
modules can use <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode> to incorporate 
the common code. When running under an XSLT 1.0 processor, the <code>version="1.0"</code> module can
be selected as the <termref def="dt-principal-stylesheet-module">principal stylesheet module</termref>;
when running under an XSLT 2.0 processor, the <code>version="2.0"</code> module can
be selected as the <termref def="dt-principal-stylesheet-module">principal stylesheet module</termref>.
Stylesheet modules that are included or imported should specify <code>version="2.0"</code> if they make use of XSLT 2.0 facilities,
and <code>version="1.0"</code> otherwise.</p>
            </note>-->
            <p>The effect of the <code>input-type-annotations</code> attribute is described in
                  <specref ref="stripping-annotations"/>.</p>
            <p>The <code>[xsl:]default-validation</code> attribute defines the default value of the
                  <code>validation</code> attribute of all relevant instructions appearing within
               its scope. For details of the effect of this attribute, see <specref ref="validation"/>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0120">
                  <p>An <elcode>xsl:stylesheet</elcode>, <elcode>xsl:transform</elcode>,
                  or <elcode>xsl:package</elcode> element <rfc2119>must not</rfc2119> have any
                     text node children.</p>
               </error> (This rule applies after stripping of <termref def="dt-whitespace-text-node">whitespace text nodes</termref> as described in <specref ref="stylesheet-stripping"/>.)</p>
            <p>
               <termdef id="dt-top-level" term="top-level">An element occurring as a child of an
                     <elcode>xsl:package</elcode>,
                     <elcode>xsl:stylesheet</elcode>,
                        <elcode>xsl:transform</elcode>, or <elcode>xsl:override</elcode>
                  element is called a <term>top-level</term> element.</termdef>
            </p>
            <p>
               <termdef id="dt-declaration" term="declaration">Top-level elements fall into two
                  categories: declarations, and user-defined data elements. Top-level elements whose
                  names are in the <termref def="dt-xslt-namespace">XSLT namespace</termref> are
                     <term>declarations</term>. Top-level elements in any other namespace are
                     <termref def="dt-data-element">user-defined data elements</termref> (see
                     <specref ref="user-defined-top-level"/>)</termdef>.</p>
            <p>The <termref def="dt-declaration">declaration</termref> elements permitted in the
                  <elcode>xsl:stylesheet</elcode> element are:</p>
            <slist>
               <sitem>
                  <elcode>xsl:accumulator</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:attribute-set</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:character-map</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:decimal-format</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:function</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:global-context-item</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:import</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:import-schema</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:include</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:key</elcode>
               </sitem>
               <sitem>
                  
                     <elcode>xsl:mode</elcode>
                  
               </sitem>
               <sitem>
                  <elcode>xsl:namespace-alias</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:output</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:param</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:preserve-space</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:strip-space</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:template</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:use-package</elcode>
               </sitem>
               <sitem>
                  <elcode>xsl:variable</elcode>
               </sitem>
            </slist>
            <p>Note that the <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> elements
               can act either as <termref def="dt-declaration">declarations</termref> or as <termref def="dt-instruction">instructions</termref>. A global variable or parameter is
               defined using a declaration; a local variable or parameter using an instruction.</p>
            <p>The child elements of the <elcode>xsl:stylesheet</elcode>
               element may appear in any order. In most cases, the ordering of these elements does
               not affect the results of the transformation; however:</p>

            <ulist>
               <item>
                  <p>As described in <specref ref="conflict"/>, when two template rules with the
                     same <termref def="dt-priority">priority</termref> match the same nodes, there
                     are situations where the order of the template rules will affect which is
                     chosen.</p>
               </item>
               <item>
                  <p>Forwards references to <termref def="dt-static-variable">static variables</termref> are not allowed in <termref def="dt-static-expression">static expressions</termref>.</p>
               </item>
            </ulist>

            
            <div3 id="default-collation-attribute">
               <head>The <code>default-collation</code> Attribute</head>
               <p>The <code>default-collation</code> attribute is a <termref def="dt-standard-attributes">standard attribute</termref> that may appear on
                  any element in the XSLT namespace, or (as <code>xsl:default-collation</code>) on a
                     <termref def="dt-literal-result-element">literal result element</termref>.</p>
               <p>The attribute, when it appears on an element
                        <var>E</var>, is used to specify the default collation used by all XPath
                     expressions appearing in attributes or <termref def="dt-text-value-template">text value templates</termref> that have <var>E</var> as an
                     ancestor, unless overridden by another <code>default-collation</code>
                  attribute on an inner element. It also determines the collation used by certain
                  XSLT constructs (such as <elcode>xsl:key</elcode> and
                     <elcode>xsl:for-each-group</elcode>) within its scope.</p>
               <p>The value of the attribute is a whitespace-separated list of collation URIs. If
                  any of these URIs is a relative URI reference,
                  then it is resolved relative to the base URI of the attribute’s parent
                  element. If the implementation recognizes one or more of the resulting absolute
                  collation URIs, then it uses the first one that it recognizes as the default
                  collation.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0125">
                     <p>It is a <termref def="dt-static-error">static error</termref> if the value
                        of an <code>[xsl:]default-collation</code> attribute, after resolving
                        against the base URI, contains no URI that the implementation recognizes as
                        a collation URI.</p>
                  </error>
               </p>
               <note>
                  <p>The reason the attribute allows a list of collation URIs is that collation URIs
                     will often be meaningful only to one particular XSLT implementation.
                     Stylesheets designed to run with several different implementations can
                     therefore specify several different collation URIs, one for use with each. To
                     avoid the above error condition, it is possible to include as the last
                     collation URI in the list either the Unicode Codepoint Collation or a collation in the UCA family (see <specref ref="uca-collations"/>) with the parameter
                        <code>fallback=yes</code>.</p>
               </note>
               <p>The <code>[xsl:]default-collation</code> attribute does not affect the collation
                  used by <elcode>xsl:sort</elcode> or by <elcode>xsl:merge</elcode>.</p>
               <p>In the absence of an
                     <code>[xsl:]default-collation</code> attribute, the default collation
                     <rfc2119>may</rfc2119> be set by the calling application in an <termref def="dt-implementation-defined"/> way. The recommended default, unless the user
                  chooses otherwise, is to use the Unicode codepoint collation.</p>
               <imp-def-feature id="idf-api-defaultcollation">In the absence of an
                     <code>[xsl:]default-collation</code> attribute, the default collation
                     <rfc2119>may</rfc2119> be set by the calling application in an <termref def="dt-implementation-defined"/> way.</imp-def-feature>
            </div3>
            <div3 id="default-mode">
               <head>The <code>default-mode</code> Attribute</head>
               <p>The <code>[xsl:]default-mode</code> attribute defines the default value for the
                     <termref def="dt-mode">mode</termref> attribute of all
                     <elcode>xsl:template</elcode> and <elcode>xsl:apply-templates</elcode> elements
                     within its scope.</p>
               
               

               <p>More specifically, when an element <var>E</var> matches
                  the pattern <code>(xsl:template[@match] | xsl:apply-templates)[not(@mode) or
                     normalize-space(@mode) eq "#default"]</code> (using the Unicode codepoint
                  collation), then the effective value of the <code>mode</code> attribute is taken
                  from the value of the <code>[xsl:]default-mode</code> attribute of the innermost
                  ancestor-or-self element of <var>E</var> that has such an attribute. If there is
                  no such element, then the default is the <termref def="dt-unnamed-mode">unnamed
                     mode</termref>. This is equivalent to specifying <code>#unnamed</code>.</p>
               
               <p>In addition, when the attribute appears on the <elcode>xsl:package</elcode>,
                  <elcode>xsl:stylesheet</elcode>, or <elcode>xsl:transform</elcode> element of the 
                  <termref def="dt-principal-stylesheet-module"/> of the <termref def="dt-top-level-package"/>,
                     it provides a default value for the <termref def="dt-initial-mode"/> used on stylesheet
                     invocation.</p>

               <p>The value of the <code>[xsl:]default-mode</code> attribute <rfc2119>must</rfc2119>
                  either be an <termref def="dt-eqname">EQName</termref>, or the token <code>#unnamed</code> which refers to
                  the <termref def="dt-unnamed-mode">unnamed mode</termref>.</p>

               <note>
                  <p>This attribute is provided to support an approach to stylesheet modularity in
                     which all the template rules for one <termref def="dt-mode">mode</termref> are
                     collected together into a single <termref def="dt-stylesheet-module">stylesheet
                        module</termref>. Using this attribute reduces the risk of forgetting to
                     specify the mode in one or more places where it is needed, and it also makes it
                     easier to reuse an existing stylesheet module that does not use modes in an
                     application where modes are needed to avoid conflicts with existing template
                     rules.</p>
                  <p>It is not necessary for the referenced mode to be
                     explicitly declared in an <elcode>xsl:mode</elcode> declaration, unless this is
                     mandated by the <code>declared-modes</code> attribute (which defaults to
                        <code>yes</code> on an <elcode>xsl:package</elcode> element).</p>
               </note>

            </div3>
            <div3 id="user-defined-top-level">
               <head>User-defined Data Elements</head>
               <p>
                  <termdef id="dt-data-element" term="user-defined data element">In addition to
                        <termref def="dt-declaration">declarations</termref>, the
                        <elcode>xsl:stylesheet</elcode> element may contain among its children any
                     element not from the <termref def="dt-xslt-namespace">XSLT namespace</termref>,
                     provided that the <termref def="dt-expanded-qname">expanded QName</termref> of
                     the element has a non-null namespace URI. Such elements are referred to as
                        <term>user-defined data elements</term>.</termdef>
               </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0130">
                     <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:stylesheet</elcode>, <elcode>xsl:transform</elcode>,
                           or <elcode>xsl:package</elcode> element has a child element whose name
                        has a null namespace URI.</p>
                  </error>
               </p>
               <p>An implementation <rfc2119>may</rfc2119> attach an <termref def="dt-implementation-defined"/> meaning to user-defined data elements that
                  appear in particular namespaces. The set of namespaces that are recognized for
                  such data elements is <termref def="dt-implementation-defined">implementation-defined</termref>. The presence of a user-defined data element
                     <rfc2119>must not</rfc2119> change the behavior of <termref def="dt-xslt-element">XSLT elements</termref> and functions defined in this
                  document; for example, it is not permitted for a user-defined data element to
                  specify that <elcode>xsl:apply-templates</elcode> should use different rules to
                  resolve conflicts. The constraints on what user-defined data elements can and
                  cannot do are exactly the same as the constraints on <termref def="dt-extension-attribute">extension attributes</termref>, described in
                     <specref ref="extension-attributes"/>. Thus, an implementation is always free
                  to ignore user-defined data elements, and <rfc2119>must</rfc2119> ignore such data
                  elements without giving an error if it does not recognize the namespace URI. </p>

               <imp-def-feature id="idf-ext-namespaces">The set of namespaces that are specially
                  recognized by the implementation (for example, for user-defined data elements, and
                     <termref def="dt-extension-attribute">extension attributes</termref>) is
                     <termref def="dt-implementation-defined"/>.</imp-def-feature>
               <imp-def-feature id="idf-ext-dataelements">The effect of user-defined data elements
                  whose name is in a namespace recognized by the implementation is <termref def="dt-implementation-defined"/>.</imp-def-feature>
               <p>User-defined data elements can provide, for example,</p>
               <ulist>
                  <item>
                     <p>information used by <termref def="dt-extension-instruction">extension
                           instructions</termref> or <termref def="dt-extension-function">extension
                           functions</termref> (see <specref ref="extension"/>),</p>
                  </item>
                  <item>
                     <p>information about what to do with any <termref def="dt-final-result-tree">final result tree</termref>,</p>
                  </item>
                  <item>
                     <p>information about how to construct <termref def="dt-source-tree">source
                           trees</termref>,</p>
                  </item>
                  <item>
                     <p>optimization hints for the <termref def="dt-processor">processor</termref>,</p>
                  </item>
                  <item>
                     <p>metadata about the stylesheet,</p>
                  </item>
                  <item>
                     <p>structured documentation for the stylesheet.</p>
                  </item>
               </ulist>
               
            </div3>
         </div2>
         <div2 id="simplified-stylesheet">
            <head>Simplified Stylesheet Modules</head>
            <p>A simplified syntax is allowed for a <termref def="dt-stylesheet-module">stylesheet
                  module</termref> that defines only a single template rule for the document node.
               The stylesheet module may consist of just a <termref def="dt-literal-result-element">literal result element</termref> (see <specref ref="literal-result-element"/>)
               together with its contents. The literal result element must have an
                  <code>xsl:version</code> attribute (and it must therefore also declare the XSLT
               namespace). Such a stylesheet module is equivalent to a standard stylesheet module
               whose <elcode>xsl:stylesheet</elcode> element contains a <termref def="dt-template-rule">template rule</termref> containing the literal result
               element, minus its <code>xsl:version</code> attribute; the template rule has a match
                  <termref def="dt-pattern">pattern</termref> of <code>/</code>.</p>
            <example>
               <head>A Simplified Stylesheet</head>
               <p>For example:</p>
               <eg xml:space="preserve" role="xml">&lt;html xsl:version="3.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</eg>
               <p>has the same meaning as</p>
               <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;xsl:template match="/"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</eg>
               <p>Note that it is not possible, using a simplified stylesheet, to request that the
                  serialized output contains a <code>DOCTYPE</code> declaration. This can only be
                  done by using a standard stylesheet module, and using the
                     <elcode>xsl:output</elcode> element.</p>
            </example>
            <p>More formally, a simplified stylesheet module is equivalent to the standard
               stylesheet module that would be generated by applying the following transformation to
               the simplified stylesheet module, invoking the transformation by calling the <termref def="dt-named-template">named template</termref>
               <code>expand</code>, with the containing literal result element as the <termref def="dt-context-node">context node</termref>: </p>
            <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template name="expand"&gt;
  &lt;xsl:element name="xsl:stylesheet"&gt;
    &lt;xsl:attribute name="version" select="@xsl:version"/&gt;
    &lt;xsl:element name="xsl:template"&gt;
      &lt;xsl:attribute name="match" select="'/'"/&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;  

&lt;/xsl:stylesheet&gt;</eg>
            <p>
               <error spec="XT" type="static" class="SE" code="0150">
                  <p>A <termref def="dt-literal-result-element">literal result element</termref>
                     that is used as the outermost element of a simplified stylesheet module
                        <rfc2119>must</rfc2119> have an <code>xsl:version</code> attribute.</p>
               </error> This indicates the version of XSLT that the stylesheet requires. For this
               version of XSLT, the value will normally be <code>
                  3.0
               </code>; the value <rfc2119>must</rfc2119> be a valid instance of the type
                  <code>xs:decimal</code> as defined in <bibref ref="xmlschema-2"/>.</p>
            
            <p>The allowed content of a literal result element when used as a simplified stylesheet
               is the same as when it occurs within a <termref def="dt-sequence-constructor">sequence constructor</termref>. Thus, a literal result element used as the
               document element of a simplified stylesheet cannot contain <termref def="dt-declaration">declarations</termref>. Simplified stylesheets therefore
               cannot use <termref def="dt-template-rule">template rules</termref>, <termref def="dt-global-variable">global variables</termref>, <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, <termref def="dt-stylesheet-function">stylesheet functions</termref>, <termref def="dt-key">keys</termref>, <termref def="dt-attribute-set">attribute-sets</termref>, or
                  <termref def="dt-output-definition">output definitions</termref>. In turn this
               means that the only useful way to initiate the transformation is to supply a document
               node as the <termref def="dt-initial-match-selection"/>, to be matched by the implicit
                  <code>match="/"</code> template rule using the <termref def="dt-unnamed-mode">unnamed mode</termref>. </p>
         </div2>
         <div2 id="backwards">
            <head>Backwards Compatible Processing</head>
            <p><termdef id="dt-effective-version" term="effective version">The <term>effective
                     version</term> of an element in a <termref def="dt-stylesheet-module"/> or <termref def="dt-package-manifest"/> is the decimal value of the <code>[xsl:]version</code> attribute
                  (see <specref ref="standard-attributes"/>) on that element or on the innermost
                  ancestor element that has such an attribute, excluding the <code>version</code>
                  attribute on an <elcode>xsl:output</elcode> element.</termdef></p>
            <p>
               <termdef id="dt-backwards-compatible-behavior" term="backwards compatible behavior">An element is processed with <term>backwards compatible behavior</term> if its
                     <termref def="dt-effective-version">effective version</termref> is less than
                     <code>3.0</code>.</termdef>
            </p>
            <p>Specifically:</p>
            <ulist>
               <item>
                  <p>If the <termref def="dt-effective-version">effective version</termref> is equal
                     to 1.0, then the element is processed with XSLT 1.0 behavior as described in
                        <specref ref="backwards-1.0"/>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-effective-version">effective version</termref> is equal
                     to 2.0, then the element is processed with XSLT 2.0 behavior as described in
                        <specref ref="backwards-2.0"/>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-effective-version">effective version</termref> is any
                     other value less than 3.0, the <rfc2119>recommended</rfc2119> action is to
                     report a static error; however, processors <rfc2119>may</rfc2119> recognize
                     such values and process the element in an <termref def="dt-implementation-defined"/> way.</p>
                  <imp-def-feature id="idf-err-unknownversion">If the <termref def="dt-effective-version">effective version</termref> of any element in the
                     stylesheet is not 1.0 or 2.0 but is less than 3.0, the
                        <rfc2119>recommended</rfc2119> action is to report a static error; however,
                     processors <rfc2119>may</rfc2119> recognize such values and process the element
                     in an <termref def="dt-implementation-defined"/> way.</imp-def-feature>
                  <note>
                     <p>XSLT 1.0 allowed the <code>version</code> attribute to take any decimal
                        value, and invoked forwards compatible processing for any value other than
                        1.0. XSLT 2.0 allowed the attribute to take any decimal value, and invoked
                        backwards compatible (i.e. 1.0-compatible) processing for any value less
                        than 2.0. Some stylesheets may therefore be encountered that use values
                        other than 1.0 or 2.0. In particular, the value 1.1 is sometimes
                        encountered, as it was used at one stage in a draft language proposal.</p>
                  </note>
               </item>
            </ulist>
            <p>These rules do not apply to the <elcode>xsl:output</elcode> element, whose
                  <code>version</code> attribute has an entirely different purpose: it is used to
               define the version of the output method to be used for serialization.</p>

            

            <p>It is <termref def="dt-implementation-defined"/> whether a particular XSLT 4.0
               implementation supports backwards compatible behavior for any XSLT version earlier
               than XSLT 4.0.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0160">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if an element has
                     an <termref def="dt-effective-version">effective version</termref> of
                        <var>V</var> (with <var>V</var> &lt; 3.0) when the implementation does not
                     support backwards compatible behavior for XSLT version <var>V</var>.</p>
               </error>
            </p>
            <imp-def-feature id="idf-feature-backwardscompatibility">It is implementation-defined
               whether an XSLT 3.0 processor supports backwards
               compatible behavior for any XSLT version earlier than XSLT 4.0.</imp-def-feature>

            <note>
               <p>By making use of backwards compatible behavior, it is possible to write the
                  stylesheet in a way that ensures that its results when processed with an XSLT 4.0
                  processor are identical to the effects of processing the same stylesheet using
                     a processor for an earlier version of XSLT.
                  To assist with transition, some parts of a stylesheet may be processed with
                  backwards compatible behavior enabled, and other parts with this behavior
                  disabled.</p>
               <p>All data values manipulated by an XSLT 4.0
                  processor are defined by the XDM data model, whether or not the relevant
                  expressions use backwards compatible behavior. Because the same data model is used
                  in both cases, expressions are fully composable. The result of evaluating
                  instructions or expressions with backwards compatible behavior is fully defined in
                  the XSLT 4.0 and XPath 3.0 specifications, it is not defined by reference to earlier versions of the XSLT and XPath
                     specifications. </p>

               <p>To write a stylesheet that makes use of features that
                     are new in version <var>N</var>, while also working with a processor that only
                     supports XSLT version <var>M</var> (<var>M</var> &lt; <var>N</var>),
                  it is necessary to understand both the rules for backwards compatible behavior in
                     XSLT version <var>N</var>, and the rules for
                  forwards compatible behavior in XSLT version
                        <var>M</var>. If the <elcode>xsl:stylesheet</elcode> element
                  specifies <code>version="2.0"</code>
                  or <code>version="3.0"</code>, then an XSLT 1.0
                  processor will ignore XSLT 2.0 and XSLT 3.0
                  <termref def="dt-declaration">declarations</termref> that were not defined in XSLT
                  1.0, for example <elcode>xsl:function</elcode> and
                     <elcode>xsl:import-schema</elcode>. If any new XSLT
                     3.0 instructions are used (for example <elcode>xsl:evaluate</elcode>
                  or <elcode>xsl:source-document</elcode>), or if new XPath
                     3.0 features are used (for example, new functions, or let expressions), then the stylesheet must provide
                  fallback behavior that relies only on facilities available in the earliest XSLT version supported. The fallback
                  behavior can be invoked by using the <elcode>xsl:fallback</elcode> instruction, or
                  by testing the results of the <function>function-available</function> or
                     <function>element-available</function> functions, or by testing the value of
                  the <code>xsl:version</code> property returned by the
                     <function>system-property</function> function.</p>
            </note>

            <div3 id="backwards-1.0">
               <head>XSLT 1.0 Compatibility Mode</head>
               <p><termdef id="dt-xslt-10-behavior" term="XSLT 1.0 behavior">An element in the
                     stylesheet is processed with <term>XSLT 1.0 behavior</term> if its <termref def="dt-effective-version">effective version</termref> is equal to
                     1.0.</termdef></p>
               <p>In this mode, if any attribute contains an XPath <termref def="dt-expression">expression</termref>, then the expression is evaluated with <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> set to
                     <code>true</code>. For details of this mode, see <xspecref spec="XP40" ref="static_context"/>. Expressions contained in
                        <termref def="dt-text-value-template">text value templates</termref> are
                     always evaluated with <termref def="dt-xpath-compat-mode">XPath 1.0
                        compatibility mode</termref> set to <code>false</code>, since this construct
                     was not available in XSLT 1.0.</p>

               <p>Furthermore, in such an expression any function call for which no implementation
                  is available (unless it uses the <termref def="dt-standard-function-namespace">standard function namespace</termref>) is bound to a fallback error function
                  whose effect when evaluated is to raise a dynamic error <errorref spec="XT" class="DE" code="1425"/> . The effect is that with backwards compatible
                  behavior enabled, calls on <termref def="dt-extension-function">extension
                     functions</termref> that are not available in a particular implementation do
                  not cause an error unless the function call is actually evaluated. For further
                  details, see <specref ref="extension-functions"/>.</p>
               <note>
                  <p>This might appear to contradict the specification of XPath 3.0, which states that a static error [XPST0017] is raised
                     when an expression contains a call to a function that is not present (with
                     matching name and arity) in the static context. This apparent contradiction is
                     resolved by specifying that the XSLT processor constructs a static context for
                     the expression in which every possible function name and arity (other than
                     names in the <termref def="dt-standard-function-namespace">standard function
                        namespace</termref>) is present; when no other implementation of the
                     function is available, the function call is bound to a fallback error function
                     whose run-time effect is to raise a dynamic error.</p>
               </note>
               <p>Certain XSLT constructs also produce different results when XSLT 1.0 compatibility
                  mode is enabled. This is described separately for each such construct.</p>

               <p>Processing an <termref def="dt-instruction"/> with XSLT
                  1.0 behavior is not compatible with streaming. More specifically, and
                  notwithstanding anything stated in <specref ref="streamability"/>, an instruction
                  that is processed with XSLT 1.0 behavior is <termref def="dt-roaming"/> and
                     <termref def="dt-free-ranging"/>, which has the effect that any construct
                  containing such an instruction is not <termref def="dt-guaranteed-streamable"/>.</p>


            </div3>
            <div3 id="backwards-2.0">
               <head>XSLT 2.0 Compatibility Mode</head>
               <p><termdef id="dt-xslt-20-behavior" term="XSLT 2.0 behavior">An element is processed
                     with <term>XSLT 2.0 behavior</term> if its <termref def="dt-effective-version">effective version</termref> is equal to 2.0.</termdef></p>
               <p>In this specification, no differences are defined for XSLT 2.0 behavior. An XSLT
                  3.0 processor will therefore produce the same results whether the <termref def="dt-effective-version">effective version</termref> of an element is set to
                  2.0 or 3.0.</p>
               <note>
                  <p>An XSLT 2.0 processor, by contrast, will in some cases produce different
                     results in the two cases. For example, if the stylesheet contains an
                        <elcode>xsl:iterate</elcode> instruction with an
                        <elcode>xsl:fallback</elcode> child, an XSLT 3.0 processor will process the
                        <elcode>xsl:iterate</elcode> instruction regardless whether the effective
                     version is 2.0 or 3.0, while an XSLT 2.0 processor will report a static error
                     if the effective version is 2.0, and will take the fallback action if the
                     effective version is 3.0.</p>
               </note>

            </div3>
         </div2>
         <div2 id="forwards">
            <head>Forwards Compatible Processing</head>
            <p>The intent of forwards compatible behavior is to make it possible to write a
               stylesheet that takes advantage of features introduced in some version of XSLT
               subsequent to XSLT 4.0, while retaining the
               ability to execute the stylesheet with an XSLT 4.0
               processor using appropriate fallback behavior.</p>
            <p>It is always possible to write conditional code to run under different XSLT versions
               by using the <code>use-when</code> feature described in <specref ref="conditional-inclusion"/>. The rules for forwards compatible behavior
               supplement this mechanism in two ways:</p>
            <ulist>
               <item>
                  <p>certain constructs in the stylesheet that mean nothing to an XSLT 4.0 processor are ignored, rather than being treated as
                     errors.</p>
               </item>
               <item>
                  <p>explicit fallback behavior can be defined for instructions defined in a future
                     XSLT release, using the <elcode>xsl:fallback</elcode> instruction.</p>
               </item>
            </ulist>
            <p>The detailed rules follow.</p>
            <p>
               <termdef id="dt-forwards-compatible-behavior" term="forwards compatible behavior">An
                  element is processed with <term>forwards compatible behavior</term> if its
                     <termref def="dt-effective-version">effective version</termref> is greater than
                     <code>3.0</code>.</termdef>
            </p>
            
            <p>These rules do not apply to the <code>version</code> attribute of the
                  <elcode>xsl:output</elcode> element, which has an entirely different purpose: it
               is used to define the version of the output method to be used for serialization.</p>
            <p>When an element is processed with forwards compatible behavior:</p>
            <ulist>
               <item>
                  <p>If the element is in the XSLT namespace and appears as a child of the
                        <elcode>xsl:stylesheet</elcode> element, and XSLT 4.0 does not allow the element to appear as a child of the
                        <elcode>xsl:stylesheet</elcode> element, then the element and its content
                        <rfc2119>must</rfc2119> be ignored.</p>
               </item>
               <item>
                  <p>If the element has an attribute that XSLT 4.0 does not allow the element to have, then the attribute
                        <rfc2119>must</rfc2119> be ignored.</p>
               </item>
               <item>
                  <p>If the element is in the XSLT namespace and appears as a child of an element whose content model requires a
                     <termref def="dt-sequence-constructor">sequence constructor</termref>, and XSLT
                        3.0 does not allow such elements to
                     appear as part of a sequence constructor, then:</p>
                  <olist>
                     <item>
                        <p>If the element has one or more <elcode>xsl:fallback</elcode> children,
                           then no error is reported either statically or dynamically, and the
                           result of evaluating the instruction is the concatenation of the
                           sequences formed by evaluating the sequence constructors within its
                              <elcode>xsl:fallback</elcode> children, in document order. Siblings of
                           the <elcode>xsl:fallback</elcode> elements are ignored, even if they are
                           valid XSLT 4.0 instructions.</p>
                     </item>
                     <item>
                        <p>If the element has no <elcode>xsl:fallback</elcode> children, then a
                           static error is reported in the same way as if forwards compatible
                           behavior were not enabled.</p>
                     </item>
                  </olist>
               </item>
            </ulist>
            <example>
               <head>Forwards Compatible Behavior</head>
               <p>For example, an XSLT 4.0
                  <termref def="dt-processor">processor</termref> will process the following
                  stylesheet without error, although the stylesheet includes elements from the
                     <termref def="dt-xslt-namespace">XSLT namespace</termref> that are not defined
                  in this specification:</p>
               <eg xml:space="preserve" role="xml">&lt;xsl:stylesheet version="17.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:exciting-new-17.0-feature&gt;
      &lt;xsl:fly-to-the-moon/&gt;
      &lt;xsl:fallback&gt;
        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;XSLT 17.0 required&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
            &lt;p&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/p&gt;
          &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:fallback&gt;
    &lt;/xsl:exciting-new-17.0-feature&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</eg>
            </example>
            <note>
               <p>If a stylesheet depends crucially on a <termref def="dt-declaration">declaration</termref> introduced by a version of XSLT after 3.0, then the stylesheet can use an
                     <elcode>xsl:message</elcode> element with <code>terminate="yes"</code> (see
                     <specref ref="message"/>) to ensure that implementations that conform to an
                  earlier version of XSLT will not silently ignore the <termref def="dt-declaration">declaration</termref>.</p>
            </note>
            <example>
               <head>Testing the XSLT Version</head>
               <p>For example,</p>
               <eg xml:space="preserve" role="xml">&lt;xsl:stylesheet version="18.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:important-new-17.0-declaration/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="number(system-property('xsl:version')) lt 17.0"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        ...
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  ...
&lt;/xsl:stylesheet&gt;</eg>
            </example>
            <note>
               <p>The XSLT 1.0 and XSLT 2.0 specifications did not anticipate the
                  introduction of the <elcode>xsl:package</elcode> element. An XSLT 1.0 or 2.0
                  processor encountering this element will report a static error, regardless of the
                     <code>version</code> setting.</p>
               <p>This problem can be circumvented by using the simplified package
                  syntax (whereby an
                        <elcode>xsl:stylesheet</elcode> element is implicitly treated as
                        <elcode>xsl:package</elcode>), or by writing the stylesheet code in
                  a separate module from the package manifest, and using the separate module as the
                  version of the stylesheet that is presented to a 2.0 processor.</p>
            </note>
         </div2>
         <div2 id="combining-modules">
            <head>Combining Stylesheet Modules</head>
            <p>XSLT provides two mechanisms to construct a <termref def="dt-package">package</termref> from multiple <termref def="dt-stylesheet-module">stylesheet modules</termref>:</p>
            <ulist>
               <item>
                  <p>an inclusion mechanism that allows stylesheet modules to be combined without
                     changing the semantics of the modules being combined, and</p>
               </item>
               <item>
                  <p>an import mechanism that allows stylesheet modules to override each other.</p>
               </item>
            </ulist>
            <div3 id="locating-modules">
               <head>Locating Stylesheet Modules</head>
               <p>The include and import mechanisms use two declarations,
                     <elcode>xsl:include</elcode> and <elcode>xsl:import</elcode>, which are defined
                  in the sections that follow.</p>
               <p>These declarations use an <code>href</code> attribute, whose value is a <termref def="dt-uri-reference">URI reference</termref>, to identify the <termref def="dt-stylesheet-module">stylesheet module</termref> to be included or
                  imported. If the value of this attribute is a relative URI reference, it is resolved as described in <specref ref="uri-references"/>.</p>
               <p>After resolving against the base URI, the way in which the URI reference is used
                  to locate a representation of a <termref def="dt-stylesheet-module">stylesheet
                     module</termref>, and the way in which the stylesheet module is constructed
                  from that representation, are <termref def="dt-implementation-defined">implementation-defined</termref>. In particular, it is implementation-defined
                  which URI schemes are supported, whether fragment identifiers are supported, and
                  what media types are supported. Conventionally, the URI is a reference to a
                  resource containing the stylesheet module as a source XML document, or it may
                  include a fragment identifier that selects an embedded stylesheet module within a
                  source XML document; but the implementation is free to use other mechanisms to
                  locate the stylesheet module identified by the URI reference.</p>

               <imp-def-feature id="idf-api-moduleuri"> It is implementation-defined what forms of
                  URI reference are acceptable in the <code>href</code> attribute of the
                     <elcode>xsl:include</elcode> and <elcode>xsl:import</elcode> elements, for
                  example, the URI schemes that may be used, the forms of fragment identifier that
                  may be used, and the media types that are supported. The way in which the URI
                  reference is used to locate a representation of a <termref def="dt-stylesheet-module">stylesheet module</termref>, and the way in which
                  the stylesheet module is constructed from that representation, are also
                  implementation-defined.</imp-def-feature>

               <p>The referenced <termref def="dt-stylesheet-module">stylesheet module</termref>
                  <rfc2119>must</rfc2119> be either a <termref def="dt-standard-stylesheet-module"/>
                  or a <termref def="dt-simplified-stylesheet-module"/>. It <rfc2119>must
                     not</rfc2119> be a <termref def="dt-package-manifest"/>. If it is a simplified
                  stylesheet module then it is transformed into the equivalent standard stylesheet
                  module by applying the transformation described in <specref ref="simplified-stylesheet"/>. </p>


               <p>Implementations <rfc2119>may</rfc2119> choose to accept URI references containing
                  a fragment identifier defined by reference to the XPointer specification (see
                     <bibref ref="xptr-framework"/>). Note that if the implementation does not
                  support the use of fragment identifiers in the URI reference, then it will not be
                  possible to include an <termref def="dt-embedded-stylesheet-module">embedded
                     stylesheet module</termref>.</p>

               <p>
                  <error spec="XT" type="static" class="SE" code="0165">
                     <p>It is a <termref def="dt-static-error">static error</termref> if the
                        processor is not able to retrieve the resource identified by the URI
                           reference<error.extra> in the <code>href</code> attribute of
                              <elcode>xsl:include</elcode> or <elcode>xsl:import</elcode>
                        </error.extra>, or if the resource that is retrieved does not contain a
                        stylesheet module.</p>
                  </error>
               </p>
               <note>
                  <p><!--bug 9992--> It is appropriate to use this error code when
                     the resource cannot be retrieved, or when the retrieved resource is not well
                     formed XML. If the resource contains XML that can be parsed but that violates
                     the rules for stylesheet modules, then a more specific error code may be more
                     appropriate.</p>
               </note>
            </div3>
            <div3 id="include">
               <head>Stylesheet Inclusion</head>
               <?element xsl:include?>
               <p>A stylesheet module may include another stylesheet module using an
                     <elcode>xsl:include</elcode> declaration.</p>
               <p>The <elcode>xsl:include</elcode> declaration has a <rfc2119>required</rfc2119>
                  <code>href</code> attribute whose value is a URI reference identifying the
                  stylesheet module to be included. This attribute is used as described in <specref ref="locating-modules"/>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0170">
                     <p>An <elcode>xsl:include</elcode> element <rfc2119>must</rfc2119> be a
                           <termref def="dt-top-level">top-level</termref> element.</p>
                  </error>
               </p>
               <p>
                  <termdef id="dt-stylesheet-level" term="stylesheet level">A <term>stylesheet
                        level</term> is a collection of <termref def="dt-stylesheet-module">stylesheet modules</termref> connected using <elcode>xsl:include</elcode>
                     declarations: specifically, two stylesheet modules <var>A</var> and
                        <var>B</var> are part of the same stylesheet level if one of them includes
                     the other by means of an <elcode>xsl:include</elcode> declaration, or if there
                     is a third stylesheet module <var>C</var> that is in the same stylesheet level
                     as both <var>A</var> and <var>B</var>.</termdef>
               </p>
               <note>
                  <p>A stylesheet level thus groups the <termref def="dt-declaration">declarations</termref> 
                     in a <termref def="dt-package"/> by <termref def="dt-import-precedence"/>:
                  two declarations within a package are in the same stylesheet level if and only if they
                  have the same import precedence.</p>
               </note>
               <p>
                  <termdef id="dt-declaration-order" term="declaration order">The <termref def="dt-declaration">declarations</termref> within a <termref def="dt-stylesheet-level">stylesheet level</termref> have a total ordering
                     known as <term>declaration order</term>. The order of declarations within a
                     stylesheet level is the same as the document order that would result if each
                     stylesheet module were inserted textually in place of the
                        <elcode>xsl:include</elcode> element that references it.</termdef> In other
                  respects, however, the effect of <elcode>xsl:include</elcode> is not equivalent to
                  the effect that would be obtained by textual inclusion.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0180">
                     <p>It is a <termref def="dt-static-error">static error</termref> if a
                        stylesheet module directly or indirectly includes itself.</p>
                  </error>
               </p>
               <note>
                  <p>It is not intrinsically an error for a <termref def="dt-stylesheet">stylesheet</termref> to include the same module more than once. However,
                     doing so can cause errors because of duplicate definitions. Such multiple
                     inclusions are less obvious when they are indirect. For example, if stylesheet
                        <var>B</var> includes stylesheet <var>A</var>, stylesheet <var>C</var>
                     includes stylesheet <var>A</var>, and stylesheet <var>D</var> includes both
                     stylesheet <var>B</var> and stylesheet <var>C</var>, then <var>A</var> will be
                     included indirectly by <var>D</var> twice. If all of <var>B</var>, <var>C</var>
                     and <var>D</var> are used as independent stylesheets, then the error can be
                     avoided by separating everything in <var>B</var> other than the inclusion of
                        <var>A</var> into a separate stylesheet <var>B'</var> and changing
                        <var>B</var> to contain just inclusions of <var>B'</var> and <var>A</var>,
                     similarly for <var>C</var>, and then changing <var>D</var> to include
                        <var>A</var>, <var>B'</var>, <var>C'</var>.</p>
               </note>
            </div3>
            <div3 id="import">
               <head>Stylesheet Import</head>
               <?element xsl:import?>
               <p>A stylesheet module may import another <termref def="dt-stylesheet-module">stylesheet module</termref> using an <elcode>xsl:import</elcode>
                  <termref def="dt-declaration">declaration</termref>. Importing a stylesheet module
                  is the same as including it (see <specref ref="include"/>) except that <termref def="dt-template-rule">template rules</termref> and other <termref def="dt-declaration">declarations</termref> in the importing module take
                  precedence over template rules and declarations in the imported module; this is
                  described in more detail below.</p>
               <p>The <elcode>xsl:import</elcode> declaration has a <rfc2119>required</rfc2119>
                  <code>href</code> attribute whose value is a URI reference identifying the
                  stylesheet module to be included. This attribute is used as described in <specref ref="locating-modules"/>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0190">
                     <p>An <elcode>xsl:import</elcode> element <rfc2119>must</rfc2119> be a <termref def="dt-top-level">top-level</termref> element.</p>
                  </error>
               </p>
               
               <example>
                  <head>Using <elcode>xsl:import</elcode>
                  </head>
                  <p>For example,</p>
                  <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;</eg>
               </example>
               <p>
                  <termdef id="dt-import-tree" term="import tree">The <termref def="dt-stylesheet-level">stylesheet levels</termref> making up a <termref def="dt-stylesheet">stylesheet</termref> are treated as forming an
                        <term>import tree</term>. In the import tree, each stylesheet level has one
                     child for each <elcode>xsl:import</elcode> declaration that it
                     contains.</termdef> The ordering of the children is the <termref def="dt-declaration-order">declaration order</termref> of the
                     <elcode>xsl:import</elcode> declarations within their stylesheet level.</p>
               <p>
                  <termdef id="dt-import-precedence" term="import precedence">A <termref def="dt-declaration">declaration</termref>
                     <var>D</var> in the stylesheet is defined to have lower <term>import
                        precedence</term> than another declaration <var>E</var> if the stylesheet
                     level containing <var>D</var> would be visited before the stylesheet level
                     containing <var>E</var> in a post-order traversal of the import tree (that is,
                     a traversal of the import tree in which a stylesheet level is visited after its
                     children). Two declarations within the same stylesheet level have the same
                     import precedence.</termdef>
               </p>
               <p>For example, suppose</p>
               <ulist>
                  <item>
                     <p>stylesheet module <var>A</var> imports stylesheet modules <var>B</var> and
                           <var>C</var> in that order;</p>
                  </item>
                  <item>
                     <p>stylesheet module <var>B</var> imports stylesheet module <var>D</var>;</p>
                  </item>
                  <item>
                     <p>stylesheet module <var>C</var> imports stylesheet module <var>E</var>.</p>
                  </item>
               </ulist>
               <p>Then the import tree has the following structure:</p>

               <g:graph rankdir="LR">
                  <g:node label="A" shape="box">
                     <g:node label="B" shape="box">
                        <g:node label="D" shape="box"/>
                     </g:node>
                     <g:node label="C" shape="box">
                        <g:node label="E" shape="box"/>
                     </g:node>
                  </g:node>
               </g:graph>


               <!--<p><emph>Here you should see a diagram. If it does not appear correctly in your
                     browser, you need to install an SVG Plugin.</emph></p>--> 

               <p>The order of import precedence (lowest first) is <var>D</var>, <var>B</var>,
                     <var>E</var>, <var>C</var>, <var>A</var>.</p>
               <p>In general, a <termref def="dt-declaration">declaration</termref> with higher
                  import precedence takes precedence over a declaration with lower import
                  precedence. This is defined in detail for each kind of declaration.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0210">
                     <p>It is a <termref def="dt-static-error">static error</termref> if a
                        stylesheet module directly or indirectly imports itself.</p>
                  </error>
               </p>
               <note>
                  <p>The case where a stylesheet module with a particular URI is imported several
                     times is not treated specially. The effect is exactly the same as if several
                     stylesheet modules with different URIs but identical content were imported.
                     This might or might not cause an error, depending on the content of the
                     stylesheet module.</p>
               </note>
            </div3>
         </div2>
         <div2 id="embedded">
            <head>Embedded Stylesheet Modules</head>
            <p>An <termref def="dt-embedded-stylesheet-module">embedded stylesheet module</termref>
               is a <termref def="dt-stylesheet-module">stylesheet module</termref> whose containing
               element is not the outermost element of the containing XML document. Both <termref def="dt-standard-stylesheet-module">standard stylesheet modules</termref> and
                  <termref def="dt-simplified-stylesheet-module">simplified stylesheet
                  modules</termref> may be embedded in this way.</p>
            <p>Two situations where embedded stylesheets may be useful are:</p>
            <ulist>
               <item>
                  <p>The stylesheet may be embedded in the source document to be transformed.</p>
               </item>
               <item>
                  <p>The stylesheet may be embedded in an XML document that describes a sequence of
                     processing of which the XSLT transformation forms just one part.</p>
               </item>
            </ulist>
            <p>The <elcode>xsl:stylesheet</elcode> element <rfc2119>may</rfc2119> have an
                  <code>id</code> attribute to facilitate reference to the stylesheet module within
               the containing document.</p>
            <note>
               <p>In order for such an attribute value to be used as a fragment identifier in a URI,
                  the XDM attribute node must generally have the <code>is-id</code> property: see
                     <xspecref spec="DM30" ref="dm-is-id"/>. This property will typically be set if
                  the attribute is defined in a DTD as being of type <code>ID</code>, or if it is
                  defined in a schema as being of type <code>xs:ID</code>. It is also necessary that
                  the media type of the containing document should support the use of ID values as
                  fragment identifiers. 
                  Such support is widespread in existing products, and is
                     endorsed in respect of the media type <code>application/xml</code> by <bibref ref="rfc7303"/>.</p>

               <p>An alternative, if the implementation supports it, is to use an
                     <code>xml:id</code> attribute. XSLT allows this attribute (like other
                  namespaced attributes) to appear on any <termref def="dt-xslt-element">XSLT
                     element</termref>.</p>
            </note>
            <example>
               <head>The <code>xml-stylesheet</code> Processing Instruction</head>
               <p>The following example shows how the <code>xml-stylesheet</code> processing
                  instruction (see <bibref ref="xml-stylesheet"/>) can be used to allow a source
                  document to contain its own stylesheet. The URI reference uses  a fragment identifier to locate the
                     <elcode>xsl:stylesheet</elcode> element:</p>
               <eg xml:space="preserve" role="xml">&lt;?xml-stylesheet type="application/xslt+xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
  &lt;head&gt;
    &lt;xsl:stylesheet id="style1"
                    version="3.0"
                    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                    xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:import href="doc.xsl"/&gt;
    &lt;xsl:template match="id('foo')"&gt;
      &lt;fo:block font-weight="bold"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="xsl:stylesheet"&gt;
      &lt;!-- ignore --&gt;
    &lt;/xsl:template&gt;
    &lt;/xsl:stylesheet&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;para id="foo"&gt;
    ...
    &lt;/para&gt;
  &lt;/body&gt;
&lt;/doc&gt;
</eg>
            </example>
            <note>
               <p>A stylesheet module that is embedded in the document to which it is to be applied
                  typically needs to contain a <termref def="dt-template-rule">template
                     rule</termref> that specifies that <elcode>xsl:stylesheet</elcode> elements are
                  to be ignored.</p>
            </note>
            <note>
               <p>The above example uses the pseudo-attribute
                     <code>type="application/xslt+xml"</code> in the <code>xml-stylesheet</code>
                  processing instruction to denote an XSLT stylesheet. This is the officially
                  registered media type for XSLT: see <specref ref="xslt-media-type"/>. However,
                  browsers developed before this media type was registered are more likely to accept
                  the unofficial designation <code>type="text/xsl"</code>.</p>
            </note>
            <note>
               <p>Support for the <code>xml-stylesheet</code> processing instruction is not required
                  for conformance with this Recommendation. Implementations are not constrained in
                  the mechanisms they use to identify a stylesheet when a transformation is
                  initiated: see <specref ref="initiating"/>.</p>
            </note>
         </div2>
         <div2 id="preprocessing">
            <head>Stylesheet Preprocessing</head>
            <p>This specification provides two features that cause the
               raw stylesheet to be preprocessed as the first stage of static processing: elements
               may be conditionally included or excluded by means of an <code>[xsl:]use-when</code>
               attribute as described in <specref ref="conditional-inclusion"/>, and attributes may
               be conditionally computed as described in <specref ref="shadow-attributes"/>.</p>

            <p>Note that many of the rules affecting the validity of
               stylesheet documents apply to a stylesheet after this preprocessing phase has been
               carried out.</p>

            <div3 id="conditional-inclusion">
               <head>Conditional Element Inclusion</head>
               <p>Any element in the XSLT namespace may have a <code>use-when</code> attribute whose
                  value is an XPath expression that can be evaluated statically. 
                  A <termref def="dt-literal-result-element">literal result element</termref>, or
                  any other element within a <termref def="dt-stylesheet-module">stylesheet
                     module</termref> that is not in the XSLT namespace, may similarly carry an
                  <code>xsl:use-when</code> attribute.      
                  If the attribute is
                  present and the <xtermref spec="XP40" ref="dt-ebv">effective boolean
                     value</xtermref> of the expression is false, then the element, together with
                  all the nodes having that element as an ancestor, is effectively excluded from the
                     <termref def="dt-stylesheet-module">stylesheet module</termref>. When a node is
                  effectively excluded from a stylesheet module the stylesheet module has the same
                  effect as if the node were not there. Among other things this means that no static
                  or dynamic errors will be reported in respect of the element and its contents,
                  other than errors in the <code>use-when</code> attribute itself.</p>
               <note>
                  <p>This does not apply to XML parsing or validation errors, which will be reported
                     in the usual way. It also does not apply to attributes that are necessarily
                     processed before <code>[xsl:]use-when</code>, examples being
                        <code>xml:space</code> and <code>[xsl:]xpath-default-namespace</code>.</p>
               </note>
              
               <p>If the <elcode>xsl:package</elcode>, 
               <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element
                  itself is effectively excluded, the effect is to exclude all the children of the
                     <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element, but
                  not the <elcode>xsl:stylesheet</elcode> or <elcode>xsl:transform</elcode> element
                  or its attributes.</p>
               <note>
                  <p>This allows all the declarations that depend on the same condition to be
                     included in one stylesheet module, and for their inclusion or exclusion to be
                     controlled by a single <code>use-when</code> attribute at the level of the
                     module.</p>
               </note>
               <p>Conditional element exclusion happens after stripping of whitespace text nodes
                  from the stylesheet, as described in <specref ref="stylesheet-stripping"/>.</p>
               <p>The XPath expression used as the value of the
                     <code>xsl:use-when</code> attribute follows the rules for <termref def="dt-static-expression">static expressions</termref>, including the rules for handling errors.</p>

               <p>The use of <code>[xsl:]use-when</code> is illustrated in the following
                  examples.</p>
               <example>
                  <head>Using Conditional Exclusion to Achieve Portability</head>
                  <p>This example demonstrates the use of the <code>use-when</code> attribute to
                     achieve portability of a stylesheet across schema-aware and non-schema-aware
                     processors.</p>
                  <eg xml:space="preserve" role="xslt-declarations">&lt;xsl:import-schema schema-location="http://example.com/schema"
              use-when="system-property('xsl:is-schema-aware')='yes'"/&gt;

&lt;xsl:template match="/" 
              use-when="system-property('xsl:is-schema-aware')='yes'" 
              priority="2"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</eg>
                  <p>The effect of these declarations is that a non-schema-aware processor ignores
                     the <elcode>xsl:import-schema</elcode> declaration and the first template rule,
                     and therefore generates no errors in respect of the schema-related constructs
                     in these declarations.</p>
               </example>
               <example>
                  <head>Including Variant Stylesheet Modules</head>
                  <p>This example includes different stylesheet modules depending on which XSLT
                     processor is in use.</p>
                  <eg xml:space="preserve" role="xslt-declarations">&lt;xsl:include href="module-A.xsl" 
     use-when="system-property('xsl:vendor')='vendor-A'"/&gt;
&lt;xsl:include href="module-B.xsl" 
     use-when="system-property('xsl:vendor')='vendor-B'"/&gt;</eg>
               </example>
            </div3>
            <div3 id="shadow-attributes">
               <head>Shadow Attributes</head>
               
               <p>When a no-namespace attribute name <var>N</var> is permitted to appear on an element
                  in the <termref def="dt-xslt-namespace"/> (provided that <var>N</var> does not start with an underscore), 
                  then a value <var>V</var> can be supplied for <var>N</var> in one of two ways:
               </p>
               
               <ulist>
                  <item><p>The conventional way is for an attribute node with name <var>N</var> and value <var>V</var> to appear 
                     in the XDM representation of the element node in the stylesheet tree.
                  </p></item>
                  <item><p>As an alternative, a shadow attribute may be supplied allowing the value <var>V</var> 
                     to be statically computed during the preprocessing phase. The shadow attribute has a name 
                     that is the same as the name <var>N</var> prefixed with an underscore, and the value of 
                     the shadow attribute is a <termref def="dt-value-template"/> in which all expressions enclosed between 
                     curly braces must be <termref def="dt-static-expression">static
                        expressions</termref>. The value <var>V</var> is the result of 
                     evaluating the value template. If a shadow attribute is present, then any attribute node with name
                     <var>N</var> (sharing the same parent element) is ignored.
                  </p></item>
               </ulist>
               
               <p>For example, an <elcode>xsl:include</elcode> element might be written:</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:include _href="common{$VERSION}.xsl"/&gt;</eg>
               <p>allowing the stylesheet to include a specific version of a library module based on
                  the value of a <termref def="dt-static-parameter"/>.</p>
               <p>Similarly, a <termref def="dt-mode"/> might be declared like this:</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:param name="streamable" as="xs:boolean" 
                  required="yes" static="yes"/&gt;
&lt;xsl:mode _streamable="{$streamable}" on-no-match="shallow-skip"/&gt;</eg>
               <p>this allowing the streamability of the mode to be controlled using a <termref def="dt-static-parameter"/>
                  (Note: this example relies on the fact that the
                        <code>streamable</code> attribute accepts a boolean value, which means that
                     the values <code>true</code> and <code>false</code> are accepted as synonyms of
                        <code>yes</code> and <code>no</code>).</p>
               <p>This mechanism applies to all attributes in the stylesheet where the attribute
                  name is in no namespace and the name of the parent element is in the <termref def="dt-xslt-namespace"/>. This includes attributes that have static
                  significance such as the <code>use-when</code> attribute, the <code>version</code>
                  attribute, and the <code>static</code> attribute on <elcode>xsl:variable</elcode>.
                  The mechanism does not apply to shadow attributes (that is, it is not possible to
                  invoke two stages of preprocessing by using two leading underscores). It does not
                  apply to attributes of literal result elements, nor to attributes in a namespace
                  such as the XML or XSLT namespace, nor to namespace declarations.</p>
             
               <note>
                  <p>If a shadow attribute and its corresponding target attribute are both present in
                     the stylesheet, the non-shadow attribute is ignored.
                     This may be useful to make stylesheet code compatible across XSLT versions; an
                     XSLT 2.0 processor operating in forwards compatible mode will ignore shadow
                     attributes, and will require the target attribute to be valid.</p>
               </note>
               <note>
                  <p>The statement that the non-shadow attribute is
                     ignored extends to error detection: it is not an error if the non-shadow
                     attribute has an invalid value. However, this is not reflected in the schema
                     for XSLT stylesheets, so validation using this schema may report errors in such
                     cases.</p>
               </note>
               <note>
                  <p>An attribute whose name begins with an underscore is
                  treated specially only when it appears on an element in the XSLT namespace. On a 
                  <termref def="dt-literal-result-element"/>, it is treated in the same way as any other attribute (that is,
                  its effective value is copied to the result tree). On an
                     <termref def="dt-extension-instruction"/> or
                  <termref def="dt-data-element"/>, as with other attributes
                  on these elements, its meaning is entirely <termref def="dt-implementation-defined"/>.</p>
               </note>

               <example>
                  <head>Using Shadow Attributes to Parameterize XPath Default Namespace</head>
                  <p>Although it is not usually considered good practice, it sometimes happens that
                     variants or versions of an XML vocabulary exist in which the same local names
                     are used, but in different namespaces. There is then a requirement to write
                     code that will process source documents in a variety of different
                     namespaces.</p>

                  <p>It is possible to define a static stylesheet parameter containing the target
                     namespace, for example:</p>

                  <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:param name="NS" as="xs:string" static="yes" 
                          select="'http://example.com/ns/one'"/&gt;</eg>
                  <p>And this can then be used to set the default namespace for XPath
                     expressions:</p>
                  <eg role="non-xml" xml:space="preserve">_xpath-default-namespace="{$NS}"</eg>
                  <p>However, it is not possible to put this shadow attribute on the
                        <elcode>xsl:stylesheet</elcode> or <elcode>xsl:package</elcode> element of
                     the principal stylesheet module, because at that point the variable
                        <code>$NS</code> is not in scope. A workaround is to create a stub
                     stylesheet module which contains nothing but the static parameter declaration
                     and an <elcode>xsl:include</elcode> of the stylesheet module containing the
                     real logic. The static stylesheet parameter will then be in scope on the
                        <elcode>xsl:stylesheet</elcode> element of the included stylesheet module,
                     and the shadow attribute <code>_xpath-default-namespace="{$NS}"</code> can
                     therefore appear on this <elcode>xsl:stylesheet</elcode> element.</p>
               </example>

               <example>
                  <head>Using Shadow Attributes to Parameterize Selection of Elements</head>
                  <p>The following stylesheet produces a report giving information about selected
                     employees. The predicate defining which employees are to be included in the
                     report is supplied (as a string containing an XPath expression) in a static
                     stylesheet parameter:</p>
                  <eg role="xslt-declaration xmlns:local='local'" xml:space="preserve">
&lt;xsl:param name="filter" static="yes"
           as="xs:string" select="'true()'"/&gt;
&lt;xsl:function name="local:filter" as="xs:boolean"&gt;
   &lt;xsl:param name="e" as="element(employee)"/&gt;
   &lt;xsl:sequence _select="$e/({$filter})"/&gt;
&lt;/xsl:function&gt;
&lt;xsl:template match="/"&gt;
   &lt;report&gt;
      &lt;xsl:apply-templates mode="report" select="//employee[local:filter(.)]"/&gt;
   &lt;/report&gt;
&lt;/xsl:template&gt;</eg>
                  <p>If the supplied value of the filter parameter is, say <code>location =
                        "UK"</code>, then the report will cover employees based in the UK.</p>
                  <note>
                     <p>The stylesheet function <code>local:filter</code> is used here in preference
                        to direct use of the supplied predicate within the <code>select</code>
                        attribute of the <elcode>xsl:apply-templates</elcode> instruction because it
                        reduces exposure to code injection attacks. It does not necessarily
                        eliminate all such risks, however. For example, it would be possible for a
                        caller to supply an expression that never terminates, thus creating a
                        denial-of-service risk.</p>
                  </note>
               </example>


            </div3>
         </div2>
         <div2 id="built-in-types">
            <head>Built-in Types</head>

            <p>Every XSLT 4.0 processor includes the following
               named type definitions in the <termref def="dt-in-scope-schema-component">in-scope
                  schema components</termref>:</p>
            <ulist>
               <item>
                  <p>
                     All built-in types defined in <bibref ref="xmlschema-2"/>, including <code>xs:anyType</code> and
                           <code>xs:anySimpleType</code>.</p>
               </item>

               <item>
                  <p>The following types defined in <bibref ref="xpath-30"/>:
                        <code>xs:yearMonthDuration</code>, <code>xs:dayTimeDuration</code>,
                        <code>xs:anyAtomicType</code>, <code>xs:untyped</code>, and
                        <code>xs:untypedAtomic</code>.</p>
               </item>
            </ulist>

            <p>XSLT 4.0 processors <rfc2119>may</rfc2119> optionally include types
               defined in XSD 1.1 (see <bibref ref="xmlschema11-1"/>). XSD 1.1 adopts the types
                  <code>xs:yearMonthDuration</code>, <code>xs:dayTimeDuration</code>, and
                  <code>xs:anyAtomicType</code> previously defined in XPath 2.0, and adds one new
               type: <code>xs:dateTimeStamp</code>. XSD 1.1 also allows implementers to define
               additional primitive types, and XSLT 4.0 permits such types to be supported by an
               XSLT processor.</p>

            <p>A <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>
               additionally supports:</p>
            <ulist>
               
               <item>
                  <p>User-defined types, and element and attribute declarations, that are imported
                     using an <elcode>xsl:import-schema</elcode> declaration as described in
                        <specref ref="import-schema"/>. These may include both simple and complex
                     types.</p>
               </item>
            </ulist>
            <note>
               <p>The names that are imported from the XML Schema namespace do not include all the
                  names of top-level types defined in either the Schema for Schema Documents or the
                  Schema for Schema Documents (Datatypes). The Schema for Schema Documents, as well
                  as defining built-in types such as <code>xs:integer</code> and
                     <code>xs:double</code>, also defines types that are intended for use only
                  within that schema, such as <code>xs:derivationControl</code>. A <termref def="dt-stylesheet">stylesheet</termref> that is designed to process XML Schema
                  documents as its input or output may import the Schema for Schema Documents.</p>
            </note>
            <p>An implementation may define mechanisms that allow additional <termref def="dt-schema-component">schema components</termref> to be added to the <termref def="dt-in-scope-schema-component">in-scope schema components</termref> for the
               stylesheet. For example, the mechanisms used to define <termref def="dt-extension-function">extension functions</termref> (see <specref ref="extension-functions"/>) may also be used to import the types used in the
               interface to such functions.</p>
            <imp-def-feature id="idf-ext-importtypes">An implementation may define mechanisms, above
               and beyond <elcode>xsl:import-schema</elcode>, that allow <termref def="dt-schema-component">schema components</termref> such as type definitions to
               be made available within a stylesheet.</imp-def-feature>
            <p>These <termref def="dt-schema-component">schema components</termref> are the only
               ones that may be referenced in XPath expressions within the stylesheet, or in the
                  <code>[xsl:]type</code> and <code>as</code> attributes of those elements that
               permit these attributes.</p>
            
         </div2>
         <div2 id="import-schema">
            <head>Importing Schema Components</head>
            <note>
               <p>The facilities described in this section are not available with a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref>. They require a
                     <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                     processor</termref>, as described in <specref ref="conformance"/>.</p>
            </note>
            <?element xsl:import-schema?>
            <p>The <elcode>xsl:import-schema</elcode> declaration is used to identify <termref def="dt-schema-component">schema components</termref> (that is, top-level type
               definitions and top-level element and attribute declarations) that need to be
               available statically, that is, before any source document is available. Names of such
               components used statically within the <termref def="dt-stylesheet">stylesheet</termref> must refer to an <termref def="dt-in-scope-schema-component">in-scope schema component</termref>, which means they must either be built-in
               types as defined in <specref ref="built-in-types"/>, or they must be imported using
               an <elcode>xsl:import-schema</elcode> declaration.</p>
            <p>The <elcode>xsl:import-schema</elcode> declaration identifies a namespace containing
               the names of the components to be imported (or indicates that components whose names
               are in no namespace are to be imported). The effect is that the names of top-level
               element and attribute declarations and type definitions from this namespace (or
               non-namespace) become available for use within XPath expressions in the <termref def="dt-package">package</termref>, and within
               other stylesheet constructs such as the <code>type</code> and <code>as</code>
               attributes of various <termref def="dt-xslt-element">XSLT elements</termref>.</p>
            <p>The same schema components are available in all stylesheet modules
                  within the <termref def="dt-declaring-package">declaring
                     package</termref>; importing components in one stylesheet module makes
               them available throughout the <termref def="dt-package">package</termref>.</p>
            <p>The schema components imported into different <termref def="dt-package">packages</termref> within a <termref def="dt-stylesheet">stylesheet</termref> must be consistent. Specifically, it is not permitted to use
               the same name in the same XSD symbol space to refer to different schema components
               within different packages; and the union of the schema components imported into the
               packages of a stylesheet must constitute a valid schema (as well as the set of schema
               components imported into each package forming a valid schema in its own right).</p>
            <p>The <code>namespace</code> and <code>schema-location</code> attributes are both
               optional.</p>
            <!--Text replaced by erratum E9 change 1"-->
            <p>If the <elcode>xsl:import-schema</elcode> element contains an <code>xs:schema</code>
               element, then the <code>schema-location</code> attribute <rfc2119>must</rfc2119> be
               absent, and one of the following <rfc2119>must</rfc2119> be true:</p>
            <ulist>
               <item>
                  <p>the <code>namespace</code> attribute of the <elcode>xsl:import-schema</elcode>
                     element and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element are both absent (indicating a no-namespace
                     schema), or</p>
               </item>
               <item>
                  <p>the <code>namespace</code> attribute of the <elcode>xsl:import-schema</elcode>
                     element and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element are both present and both have the same
                     value, or</p>
               </item>
               <item>
                  <p>the <code>namespace</code> attribute of the <elcode>xsl:import-schema</elcode>
                     element is absent and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element is present, in which case the target
                     namespace is as given on the <code>xs:schema</code> element.</p>
               </item>
            </ulist>
            <!--End of text replaced by erratum E9-->
            <p>
               <error spec="XT" type="static" class="SE" code="0215">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:import-schema</elcode> element that contains an
                        <code>xs:schema</code> element has a <code>schema-location</code> attribute,
                     or if it has a <code>namespace</code> attribute that conflicts with the target
                     namespace of the contained schema.</p>
               </error>
            </p>
            <p>If two <elcode>xsl:import-schema</elcode> declarations specify the same namespace, or
               if both specify no namespace, then only the one with highest <termref def="dt-import-precedence">import precedence</termref> is used. If this leaves
               more than one, then all the declarations at the highest import precedence are used
               (which may cause conflicts, as described below).</p>
            <p>After discarding any <elcode>xsl:import-schema</elcode> declarations under the above
               rule, the effect of the remaining <elcode>xsl:import-schema</elcode> declarations is
               defined in terms of a hypothetical document called the synthetic schema document,
               which is constructed as follows. The synthetic schema document defines an arbitrary
               target namespace that is different from any namespace actually used by the
               application, and it contains <code>xs:import</code> elements corresponding
               one-for-one with the <elcode>xsl:import-schema</elcode> declarations in the <termref def="dt-stylesheet">stylesheet</termref>, with the following correspondence:</p>
            <ulist>
               <item>
                  <p>The <code>namespace</code> attribute of the <code>xs:import</code> element is
                     copied from the <code>namespace</code> attribute of the
                        <elcode>xsl:import-schema</elcode> declaration if it is explicitly present,
                     or is implied by the <code>targetNamespace</code> attribute of a contained
                        <code>xs:schema</code> element, and is absent if it is absent.</p>
               </item>
               <item>
                  <p>The <code>schemaLocation</code> attribute of the <code>xs:import</code> element
                     is copied from the <code>schema-location</code> attribute of the
                        <elcode>xsl:import-schema</elcode> declaration if present, and is absent if
                     it is absent. If there is a contained <code>xs:schema</code> element, the
                     effective value of the <code>schemaLocation</code> attribute is a URI
                     referencing a document containing a copy of the <code>xs:schema</code>
                     element.</p>
               </item>
               <item>
                  <p>The base URI of the <code>xs:import</code> element is the same as the base URI
                     of the <elcode>xsl:import-schema</elcode> declaration.</p>
               </item>
            </ulist>
            <p>The schema components included in the <termref def="dt-in-scope-schema-component">in-scope schema components</termref> (that is, the components whose names are
               available for use within the stylesheet) are the top-level element and attribute
               declarations and type definitions that are available for reference within the
               synthetic schema document. See <bibref ref="xmlschema-1"/> (section 4.2.3,
                  <emph>References to schema components across namespaces</emph>).</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0220">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the synthetic
                     schema document does not satisfy the constraints described in <bibref ref="xmlschema-1"/> (section 5.1, <emph>Errors in Schema Construction and
                        Structure</emph>). This includes, without loss of generality, conflicts such
                     as multiple definitions of the same name.</p>
               </error>
            </p>
            <note>
               <p>The synthetic schema document does not need to be constructed by a real
                  implementation. It is purely a mechanism for defining the semantics of
                     <elcode>xsl:import-schema</elcode> in terms of rules that already exist within
                  the XML Schema specification. In particular, it implicitly defines the rules that
                  determine whether the set of <elcode>xsl:import-schema</elcode> declarations are
                  mutually consistent.</p>
               <p>These rules do not cause names to be imported transitively. The fact that a name
                  is available for reference within a schema document A does not of itself make the
                  name available for reference in a stylesheet that imports the target namespace of
                  schema document A. (See <bibref ref="xmlschema-1"/> section 3.15.3, Constraints on
                  XML Representations of Schemas.) The stylesheet must import all the namespaces
                  containing names that it actually references.</p>
               <p>The <code>namespace</code> attribute indicates that a schema for the given
                  namespace is required by the <termref def="dt-stylesheet">stylesheet</termref>.
                  This information may be enough on its own to enable an implementation to locate
                  the required schema components. The <code>namespace</code> attribute may be
                  omitted to indicate that a schema for names in no namespace is being imported. The
                  zero-length string is not a valid namespace URI, and is therefore not a valid
                  value for the <code>namespace</code> attribute.</p>
               <p>The <code>schema-location</code> attribute is a <termref def="dt-uri-reference">URI Reference</termref> that gives a hint indicating where a schema document
                  or other resource containing the required definitions may be found. It is likely
                  that a <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT
                     processor</termref> will be able to process a schema document found at this
                  location.</p>
               <p>The XML Schema specification gives implementations flexibility in how to handle
                  multiple imports for the same namespace. Multiple imports do not cause errors if
                  the definitions do not conflict.</p>
               <p>A consequence of these rules is that it is not intrinsically an error if no schema
                  document can be located for a namespace identified in an
                     <elcode>xsl:import-schema</elcode> declaration. This will cause an error only
                  if it results in the stylesheet containing references to names that have not been
                  imported.</p>
               <p>An inline schema document (using an <code>xs:schema</code> element as a child of
                  the <code>xsl:import-schema</code> element) has the same status as an external
                  schema document, in the sense that it acts as a hint for a source of schema
                  components in the relevant namespace. To ensure that the inline schema document is
                  always used, it is advisable to use a target namespace that is unique to this
                  schema document.</p>
            </note>
            <p>The use of a namespace in an <elcode>xsl:import-schema</elcode> declaration does not
               by itself associate any namespace prefix with the namespace. If names from the
               namespace are used within the stylesheet module then a namespace declaration must be
               included in the stylesheet module, in the usual way.</p>
            <example>
               <head>An Inline Schema Document</head>
               <p>The following example shows an inline schema document. This declares a simple type
                     <code>local:yes-no</code>, which the stylesheet then uses in the declaration of
                  a variable.</p>
               <p>The example assumes the namespace declaration
                     <code>xmlns:local="http://example.com/ns/yes-no"</code>
               </p>
               <eg xml:space="preserve" role="xslt-declarations">&lt;xsl:import-schema&gt;
  &lt;xs:schema targetNamespace="http://example.com/ns/yes-no"
             xmlns:xs="http://www.w3.org/2001/XMLSchema"
             xmlns:local="http://example.com/ns/yes-no"&gt;
    &lt;xs:simpleType name="yes-no"&gt;
      &lt;xs:restriction base="xs:string"&gt;
        &lt;xs:enumeration value="yes"/&gt;
        &lt;xs:enumeration value="no"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:schema&gt;
&lt;/xsl:import-schema&gt;

&lt;xsl:variable name="condition" select="local:yes-no('yes')" 
                               as="local:yes-no"/&gt;
</eg>
            </example>
            <p>There are two built-in functions
                  (<xfunction>analyze-string</xfunction> and <function>json-to-xml</function>) whose
               result is an XML structure for which a schema is defined. The namespace for these
               schema definitions is (in both cases) <code>http://www.w3.org/2005/xpath-functions</code>. Schema
               components for these namespaces are available for reference within the stylesheet if
               and only if an <elcode>xsl:import-schema</elcode> declaration is present referencing
               this namespace. If such a declaration is present, then the schema that is
               imported is the schema defined in the specification of these functions: the <code>schemaLocation</code>
               attribute has no effect.</p>
         </div2>
      </div1>
      <div1 id="data-model">
         <head>Data Model</head>
         <p>The data model used by XSLT is the XPath 3.0 and XQuery
               3.0 data model (XDM), as defined in <bibref ref="xpath-datamodel-30"/>. XSLT
            operates on source, result and stylesheet documents using the same data model.</p>
         <p>This section elaborates on some particular features of XDM as it is used by XSLT:</p>
         <p>The rules in <specref ref="stylesheet-stripping"/> and <specref ref="strip"/> make use
            of the concept of a whitespace text node.</p>
         <p>
            <termdef id="dt-whitespace-text-node" term="whitespace text node">A <term>whitespace
                  text node</term> is a text node whose content consists entirely of whitespace
               characters (that is, #x09, #x0A, #x0D, or #x20).</termdef>
         </p>
         <note>
            <p>Features of a source XML document that are not represented in the XDM tree will have
               no effect on the operation of an XSLT stylesheet. Examples of such features are
               entity references, CDATA sections, character references, whitespace within element
               tags, and the choice of single or double quotes around attribute values.</p>
         </note>
         <div2 id="xml-versions">
            <head>XML Versions</head>
            <p>The XDM data model defined in <bibref ref="xpath-datamodel-30"/> is capable of
               representing either an XML 1.0 document (conforming to <bibref ref="REC-xml"/> and
                  <bibref ref="xml-names"/>) or an XML 1.1 document (conforming to <bibref ref="xml11"/> and <bibref ref="xml-names11"/>), and it makes no distinction
               between the two. In principle, therefore, XSLT 4.0
               can be used with either of these XML versions.</p>
            <p>Construction of the XDM tree is outside the scope of this specification, so XSLT
                  4.0 places no formal requirements on an XSLT
               processor to accept input from either XML 1.0 documents or XML 1.1 documents or both.
               This specification does define a serialization capability (see <specref ref="serialization"/>), though from a conformance point of view it is an optional
               feature. Although facilities are described for serializing the XDM tree as either XML
               1.0 or XML 1.1 (and controlling the choice), there is again no formal requirement on
               an XSLT processor to support either or both of these XML versions as serialization
               targets.</p>
            <p>Because the XDM tree is the same whether the original document was XML 1.0 or XML
               1.1, the semantics of XSLT processing do not depend on the version of XML used by the
               original document. There is no reason in principle why all the input and output
               documents used in a single transformation must conform to the same version of
               XML.</p>
            <p>Some of the syntactic constructs in XSLT 4.0 and
                  XPath 3.0, for example the productions <xnt spec="XML" ref="Char">Char</xnt> and <xnt spec="Names" ref="NT-NCName">NCName</xnt>, are defined by reference to the XML and XML Namespaces
               specifications. There are slight variations between the XML 1.0 and XML 1.1 versions
               of these productions (and, indeed, between different
                  editions of XML 1.0). Implementations <rfc2119>may</rfc2119> support
                  any version; it is
                  <rfc2119>recommended</rfc2119> that an XSLT 4.0
               processor that implements the 1.1 versions <rfc2119>should</rfc2119> also provide a
               mode that supports the 1.0 versions. It is thus <termref def="dt-implementation-defined">implementation-defined</termref> which versions
               and editions of XML and XML Namespaces are supported by the implementation.</p>
            <note>
               <p>The specification referenced as <bibref ref="xml-names"/> was actually published
                  without a version number.</p>
            </note>
            <imp-def-feature id="idf-spec-xml">It is implementation-defined which versions and
               editions of XML and XML Namespaces (1.0 and/or 1.1) are supported.</imp-def-feature>
            <p>The current version of <bibref ref="xmlschema11-2"/> references the XML 1.1 specifications, but the previous version (<bibref ref="xmlschema-2"/>) (that is, XSD 1.0) remains in widespread use, and only
                  references XML 1.0. With processors lacking support for XSD 1.1,
               therefore, datatypes such as <code>xs:NCName</code> and <code>xs:ID</code> may be
               constrained by the XML 1.0 rules, and not allow the full range of values permitted by
               XML 1.1. It is <rfc2119>recommended</rfc2119> that implementers wishing to support
               XML 1.1 should consult <bibref ref="SCHEMA-AND-XML-1.1"/> for guidance.</p>
         </div2>
         <div2 id="xdm-versions">
            <head>XDM versions</head>
            <p diff="chg" at="A">XSLT 4.0 <rfc2119>requires</rfc2119> a processor to support XDM 3.1 as defined in
                  <bibref ref="xpath-datamodel-31"/>.</p>
            <!--<p>A processor <rfc2119>may</rfc2119> also provide a user option to support XDM 3.1 as
               defined in <bibref ref="xpath-datamodel-31"/>, in which case it must do so as defined
               in <specref ref="xpath31-feature"/>.</p>
            <note>
               <p>The essential differences between XDM 3.0 (with the extensions defined in this
                  specification) and XDM 3.1 are that XDM 3.1 adds support for arrays, and for the
                     <code>xs:numeric</code> union type.</p>
            </note>-->
            <p>A processor <rfc2119>may</rfc2119> also provide a user option to support versions of
               XDM later than 3.1, in which case the way it does so is <termref def="dt-implementation-defined"/>.</p>


         </div2>
         <div2 id="stylesheet-stripping">
            <head>Stripping Whitespace from the Stylesheet</head>
            <p>The tree representing the stylesheet is preprocessed as follows:</p>
            <olist>
               <item>
                  <p>All comments and processing instructions are removed.</p>
               </item>
               <item>
                  <p>Any text nodes that are now adjacent to each other are merged.</p>
               </item>
               <item>
                  <p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref> that
                     satisfies both the following conditions is removed from the tree:</p>
                  <ulist>
                     <item>
                        <p>The parent of the text node is not an <elcode>xsl:text</elcode>
                           element</p>
                     </item>
                     <item>
                        <p>The text node does not have an ancestor element that has an
                              <code>xml:space</code> attribute with a value of
                           <code>preserve</code>, unless there is a closer ancestor element having
                           an <code>xml:space</code> attribute with a value of
                           <code>default</code>.</p>
                     </item>
                  </ulist>
               </item>
               <item>
                  <p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref> whose
                     parent is one of the following elements is removed from the tree, regardless of
                     any <code>xml:space</code> attributes:</p>
                  <slist>
                     <sitem>
                        
                           <elcode>xsl:accumulator</elcode>
                        
                     </sitem>
                     <sitem>
                        <elcode>xsl:analyze-string</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:apply-imports</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:apply-templates</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:attribute-set</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:call-template</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:character-map</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:choose</elcode>
                     </sitem>
                     <sitem>
                        
                           <elcode>xsl:evaluate</elcode>
                        
                     </sitem>
                     <sitem>
                        
                           <elcode>xsl:fork</elcode>
                        
                     </sitem>
                     <sitem>
                        
                           <elcode>xsl:merge</elcode>
                        
                     </sitem>
                     <sitem>
                        
                           <elcode>xsl:merge-source</elcode>
                        
                     </sitem>
                     <sitem>
                        
                           <elcode>xsl:mode</elcode>
                        
                     </sitem>
                     <sitem>
                        
                           <elcode>xsl:next-iteration</elcode>
                        
                     </sitem>
                     <sitem>
                        <elcode>xsl:next-match</elcode>
                     </sitem>
                     <sitem>
                        
                           <elcode>xsl:override</elcode>
                        
                     </sitem>
                     <sitem>
                        
                           <elcode>xsl:package</elcode>
                        
                     </sitem>
                     <sitem>
                        <elcode>xsl:stylesheet</elcode>
                     </sitem>
                     <sitem>
                        <elcode>xsl:transform</elcode>
                     </sitem>
                     <sitem>
                        
                           <elcode>xsl:use-package</elcode>
                        
                     </sitem>
                  </slist>
               </item>
               <item>
                  <p>Any <termref def="dt-whitespace-text-node">whitespace text node</termref> whose
                     immediate following-sibling node is an <elcode>xsl:param</elcode> or
                        <elcode>xsl:sort</elcode>
                     or <elcode>xsl:context-item</elcode> or
                           <elcode>xsl:on-completion</elcode> element is removed from the
                     tree, regardless of any <code>xml:space</code> attributes.</p>
               </item>
               <item>
                  <p>Any <termref def="dt-whitespace-text-node">whitespace text
                        node</termref> whose immediate preceding-sibling node is an
                        <elcode>xsl:catch</elcode>
                      element is removed from the
                     tree, regardless of any <code>xml:space</code> attributes.</p>
               </item>
            </olist>
            <p>
               <error spec="XT" type="static" class="SE" code="0260">
                  <p>Within an <termref def="dt-xslt-element">XSLT element</termref> that is
                        <rfc2119>required</rfc2119> to be empty, any content other than comments or
                     processing instructions, including any <termref def="dt-whitespace-text-node">whitespace text node</termref> preserved using the
                        <code>xml:space="preserve"</code> attribute, is a <termref def="dt-static-error">static error</termref>.</p>
               </error>
            </p>
            <note>
               <p>Using <code>xml:space="preserve"</code> in parts of the stylesheet that contain
                     <termref def="dt-sequence-constructor">sequence constructors</termref> will
                  cause whitespace text nodes in that part of the
                     stylesheet to be copied to the result of the sequence constructor.
                  When the result of the sequence constructor is used to form the content of an
                  element, this can cause errors if such text nodes are followed by attribute nodes
                  generated using <elcode>xsl:attribute</elcode>.</p>
            </note>
            <note>
               <p>If an <code>xml:space</code> attribute is specified on a <termref def="dt-literal-result-element">literal result element</termref>, it will be
                  copied to the result tree in the same way as any other attribute.</p>
            </note>
         </div2>
         <div2 id="preprocessing-source-docs">
            <head>Preprocessing Source Documents</head>
            
            <p>Source documents supplied as input to a transformation may be subject to preprocessing. 
               Two kinds of preprocessing are defined: stripping of type annotations (see <specref ref="stripping-annotations"/>), 
               and stripping of whitespace text nodes (see <specref ref="strip"/>).
            </p>
            <p>Stripping of type annotations happens before stripping of whitespace text nodes.
            </p>
            <p>The source documents to which this applies are as follows:
            </p>
            
            <ulist>
               <item><p>The document containing the <termref def="dt-global-context-item"/> if it is a node;</p></item>
            
               <item><p>Any documents containing a node present in the <termref def="dt-initial-match-selection"/>;</p></item>
            
               <item><p>Any document containing a node that is returned by the functions <function>document</function>, <xfunction>doc</xfunction>,
                  or <xfunction>collection</xfunction>;</p></item>
            
               <item><p>Any document read using <code>xsl:source-document</code>.</p></item> 
            </ulist>
            
            <note><p>This list excludes documents passed as the values of 
               <termref def="dt-stylesheet-parameter">stylesheet parameters</termref> or parameters 
               of the <termref def="dt-initial-named-template"/> or <termref def="dt-initial-function"/>, 
               trees created by functions such as <xfunction>parse-xml</xfunction>, <code>parse-xml-fragment</code>,
               <xfunction>analyze-string</xfunction>, or <function>json-to-xml</function>,
               and values returned from <termref def="dt-extension-function">extension
                  functions</termref>.
            </p></note>
            
            <p>If a node other than a document node is supplied (for example as the global context item), 
               then the preprocessing is applied to the entire document containing that node. If several nodes within the same 
               document are supplied (for example as nodes in the initial match selection, or as nodes returned by the 
               <xfunction>collection</xfunction> function), then the preprocessing is only applied to that document once.
               If a whitespace text node is supplied (for example as the global context item) and the rules cause this node
               to be stripped from its containing tree, then the behavior is as if this node had not been supplied 
               (which may cause an error, for example if a global context item is required.)
            </p>
            <p>The rules determining whether or not stripping of annotations and/or whitespace 
               happens are defined at the level of a <termref def="dt-package"/>. Declarations within a <termref def="dt-library-package"/> 
               only affect the handling of documents loaded using a call on the <function>document</function>, <xfunction>doc</xfunction>,
               or <xfunction>collection</xfunction> functions or an evaluation of an <elcode>xsl:source-document</elcode> instruction 
               appearing lexically within the same package. Declarations within the <termref def="dt-top-level-package"/> also affect the processing 
               of the <termref def="dt-global-context-item"/> and the <termref def="dt-initial-match-selection"/>.
            </p>
            <p>The semantics of the <function>document</function>, <xfunction>doc</xfunction>,
               and <xfunction>collection</xfunction> functions are formally defined in terms of mappings from URIs to document nodes 
               maintained within the dynamic context (see <specref ref="xpath-dynamic-context"/>). The effect of the 
               declarations that control stripping of type annotations 
               and whitespace is therefore to modify this mapping (so it now maps the URI to a stripped document). The modification 
               applies to the dynamic context for calls to these function appearing within a particular package; each package therefore 
               has a different set of mappings. This means that when two calls to the <xfunction>doc</xfunction> function appear in 
               different packages, specifying the same absolute URI, then in general different documents are returned. An implementation 
               <rfc2119>may</rfc2119> return the same document for two such calls if it is able to determine that the effect of the annotation 
               and whitespace stripping rules in both packages is the same.
            </p>
            <p>The effect of dynamic calls to the <function>document</function>, <xfunction>doc</xfunction>,
               and <xfunction>collection</xfunction> functions is defined in the same way as for other functions with dependencies on 
               the dynamic context. As described in <specref ref="additional-dynamic-context"/>, named function references 
               (such as <code>doc#1</code>) and calls on <xfunction>function-lookup</xfunction> (for example, <code>function-lookup("doc", 1)</code>) 
               are defined to retain the XPath static and dynamic context at the point of invocation as part of the closure of the 
               resulting function item, and to use this preserved context when a dynamic function call is subsequently made using the function item.
            </p>
            
            
            
         <div3 id="stripping-annotations">
            <head>Stripping Type Annotations from a Source Tree</head>
            <p>
               <termdef id="dt-type-annotation" term="type annotation">The term <term>type
                     annotation</term> is used in this specification to refer to the value returned
                  by the <code>dm:type-name</code> accessor of a node: see <xspecref spec="DM30" ref="dm-type-name"/>.</termdef>
            </p>
            <p>There is sometimes a requirement to write stylesheets that produce the same results
               whether or not the source documents have been validated against a schema. To achieve
               this, an option is provided to remove any <termref def="dt-type-annotation">type
                  annotations</termref> on element and attribute nodes in a <termref def="dt-source-tree">source tree</termref>, replacing them with an annotation of
                  <code>xs:untyped</code> in the case of element nodes, and
                  <code>xs:untypedAtomic</code> in the case of attribute nodes.</p>
            <p>Such stripping of <termref def="dt-type-annotation">type annotations</termref> can be
               requested by specifying <code>input-type-annotations="strip"</code> on the <elcode>xsl:package</elcode> element. This
               attribute has three permitted values: <code>strip</code>, <code>preserve</code>, and
                  <code>unspecified</code>. The default value is <code>unspecified</code>. 
            <phrase diff="add" at="A">Specifying <code>unspecified</code> has the same effect
            as omitting the attribute [XSLT 3.0 Erratum E43, bug 30383].</phrase></p>

            <p>The <code>input-type-annotations</code> attribute may also
               be specified on the <elcode>xsl:stylesheet</elcode> element; if it is specified at
               this level then it must be consistent for all stylesheet modules within the same
               package.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0265">
                  <p> It is a <termref def="dt-static-error">static error</termref> if there is a
                        <termref def="dt-stylesheet-module">stylesheet module</termref> in a
                        <termref def="dt-package">package</termref> that specifies
                        <code>input-type-annotations="strip"</code> and another <termref def="dt-stylesheet-module">stylesheet module</termref> that specifies
                        <code>input-type-annotations="preserve"</code>, or if a stylesheet module specifies the value
                           <code>strip</code> or <code>preserve</code> and the same value is not
                        specified on the <elcode>xsl:package</elcode> element of the containing
                        package.</p>
               </error>
            </p>
            
            <p diff="add" at="A">Type annotations are stripped from relevant source documents if 
               at least one <termref def="dt-stylesheet-module"/> in the <termref def="dt-stylesheet"/>
               specifies <code>input-type-annotations="strip"</code> on the <elcode>xsl:package</elcode>, 
               <elcode>xsl:stylesheet</elcode>, or <elcode>xsl:transform</elcode> element [XSLT 3.0 Erratum E43, bug 30383].</p>
            
            <p>When type annotations are stripped, the following changes are made to the source
               tree:</p>
            <ulist>
               <item>
                  <p>The type annotation of every element node is changed to <code>xs:untyped</code>
                  </p>
               </item>
               <item>
                  <p>The type annotation of every attribute node is changed to
                        <code>xs:untypedAtomic</code>
                  </p>
               </item>
               <item>
                  <p>The typed value of every element and attribute node is set to be the same as
                     its string value, as an instance of <code>xs:untypedAtomic</code>.</p>
               </item>
               <item>
                  <p>The <code>is-nilled</code> property of every element node is set to
                        <code>false</code>.</p>
               </item>
            </ulist>
            <p>The values of the <code>is-id</code> and <code>is-idrefs</code> properties are not
               changed.</p>
            <note>
               <p>Stripping <termref def="dt-type-annotation">type annotations</termref> does not
                  necessarily return the document to the state it would be in had validation not
                  taken place. In particular, any defaulted elements and attributes that were added
                  to the tree by the validation process will still be present, and elements and
                  attributes validated as IDs will still be accessible using the
                     <xfunction>id</xfunction> function.</p>
            </note>
         </div3>
         <div3 id="strip">
            <head>Stripping Whitespace from a Source Tree</head>
            <p>A <termref def="dt-source-tree">source tree</termref> supplied as input to the
               transformation process may contain <termref def="dt-whitespace-text-node">whitespace
                  text nodes</termref> that are of no interest, and that do not need to be retained
               by the transformation. Conceptually, an XSLT <termref def="dt-processor">processor</termref> makes a copy of the source tree from which unwanted <termref def="dt-whitespace-text-node">whitespace text nodes</termref> have been removed.
               This process is referred to as whitespace stripping. </p>
            

            

            <p>The stripping process takes as input a set of element names whose child <termref def="dt-whitespace-text-node">whitespace text nodes</termref> are to be preserved.
               The way in which this set of element names is established using the
                  <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>
               declarations is described later in this section.</p>

            
            
            <p>The stripping process that applies for a particular
               <termref def="dt-package"/> is determined by the <elcode>xsl:strip-space</elcode>
               and <elcode>xsl:preserve-space</elcode> declarations within that package.</p>

            <p>A <termref def="dt-whitespace-text-node">whitespace text node</termref> is preserved
               if either of the following apply:</p>
            <ulist>
               <item>
                  <p>The element name of the parent of the text node is in the set of
                     whitespace-preserving element names.</p>
               </item>
               <item>
                  <p>An ancestor element of the text node has an <code>xml:space</code> attribute
                     with a value of <code>preserve</code>, and no closer ancestor element has
                        <code>xml:space</code> with a value of <code>default</code>.</p>
               </item>
            </ulist>
            <p>Otherwise, the <termref def="dt-whitespace-text-node">whitespace text node</termref>
               is stripped.</p>
            <p>The <code>xml:space</code> attributes are not removed from the tree.</p>
            
            
            <?element xsl:strip-space?>
            <?element xsl:preserve-space?>
            <p>The set of whitespace-preserving element names is specified by
                  <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode>
               <termref def="dt-declaration">declarations</termref>. Whether an element name is
               included in the set of whitespace-preserving names is determined by the best match
               among all the <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode>
               declarations: it is included if and only if there is no match or the best match is an
                  <elcode>xsl:preserve-space</elcode> element. The <elcode>xsl:strip-space</elcode>
               and <elcode>xsl:preserve-space</elcode> elements each have an <code>elements</code>
               attribute whose value is a whitespace-separated list of <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTests</xnt>; an element name matches an
                  <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode> element if
               it matches one of the <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTests</xnt>.
               An element matches a <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTest</xnt> if
               and only if the <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTest</xnt> would be
               true for the element as an XPath node test.</p>

            

            <p><!--bug 10097--><error spec="XT" type="static" class="SE" code="0270">
                  <p>It is a <termref def="dt-static-error">static error</termref> if within any <termref def="dt-package">package</termref> the same <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTest</xnt> appears in both an
                        <elcode>xsl:strip-space</elcode> and an <elcode>xsl:preserve-space</elcode>
                     declaration if both have the same <termref def="dt-import-precedence">import
                        precedence</termref>. Two NameTests are considered the same if they match
                     the same set of names (which can be determined by comparing them after
                     expanding namespace prefixes to URIs).</p>
               </error></p>

            <p>Otherwise, when more than one
                  <elcode>xsl:strip-space</elcode> and <elcode>xsl:preserve-space</elcode> element
                  within the relevant <termref def="dt-package">package</termref> matches, the best matching element is determined by
               the best matching <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTest</xnt>.
                  
               <!--bug 10097-->The rules are similar to those for
               <termref def="dt-template-rule">template rules</termref>:</p>
            <ulist>
               <item>
                  <p>First, any match with lower <termref def="dt-import-precedence">import
                        precedence</termref> than another match is ignored.</p>
               </item>
               <item>
                  <p>Next, any match that has a lower <termref def="dt-default-priority">default
                        priority</termref> than the <termref def="dt-default-priority">default
                        priority</termref> of another match is ignored.</p>
               </item>
               <item>
                  <p>If several matches have the same <termref def="dt-default-priority">default priority</termref> (which can only happen
                     if one of the NameTests takes the form <code>*:local</code> and the other takes
                     the form <code>prefix:*</code>), then the declaration that appears last in
                        <termref def="dt-declaration-order">declaration order</termref> is used.</p>
               </item>
            </ulist>
            

            <p>If an element in a source document has a <termref def="dt-type-annotation">type
                  annotation</termref> that is a simple type or a complex type with simple content,
               then any whitespace text nodes among its children are preserved, regardless of any
                  <elcode>xsl:strip-space</elcode> declarations. The reason for this is that
               stripping a whitespace text node from an element with simple content could make the
               element invalid: for example, it could cause the <code>minLength</code> facet to be
               violated.</p>
            <p>Stripping of <termref def="dt-type-annotation">type annotations</termref> happens
               before stripping of whitespace text nodes, so this situation will not occur if
                  <code>input-type-annotations="strip"</code> is specified.</p>
            <note>
               <p>In <bibref ref="xpath-datamodel-30"/>, processes are described for constructing an
                  XDM tree from an Infoset or from a PSVI. Those processes deal with whitespace
                  according to their own rules, and the provisions in this section apply to the
                  resulting tree. In practice this means that elements that are defined in a DTD or
                  a Schema to contain element-only content will have <termref def="dt-whitespace-text-node">whitespace text nodes</termref> stripped,
                  regardless of the <elcode>xsl:strip-space</elcode> and
                     <elcode>xsl:preserve-space</elcode> declarations in the stylesheet.</p>
               <p>However, source trees are not necessarily constructed using those processes;
                  indeed, they are not necessarily constructed by parsing XML documents. Nothing in
                  the XSLT specification constrains how the source tree is constructed, or what
                  happens to <termref def="dt-whitespace-text-node">whitespace text nodes</termref>
                  during its construction. The provisions in this section relate only to whitespace
                  text nodes that are present in the tree supplied as input to the XSLT processor.
                  The XSLT processor cannot preserve whitespace text nodes unless they were actually
                  present in the supplied tree.</p>
            </note>
         </div3>
         </div2>
         <div2 id="id-in-data-model">
            <head>Attribute Types and DTD Validation</head>
            <p>The mapping from the Infoset to the XDM data model, described in <bibref ref="xpath-datamodel-30"/>, does not retain attribute types. This means, for
               example, that an attribute described in the DTD as having attribute type
                  <code>NMTOKENS</code> will be annotated in the XDM tree as
                  <code>xs:untypedAtomic</code> rather than <code>xs:NMTOKENS</code>, and its typed
               value will consist of a single <code>xs:untypedAtomic</code> value rather than a
               sequence of <code>xs:NMTOKEN</code> values.</p>
            <p>Attributes with a DTD-derived type of ID, IDREF, or IDREFS will be marked in the XDM
               tree as having the <code>is-id</code> or <code>is-idrefs</code> properties. It is
               these properties, rather than any <termref def="dt-type-annotation">type
                  annotation</termref>, that are examined by the functions <xfunction>id</xfunction>
               and <xfunction>idref</xfunction> described in <bibref ref="xpath-functions-40"/>.</p>
         </div2>
         <div2 id="model-for-streaming">
            <head>Data Model for Streaming</head>
            <div3 id="streamed-documents">
               <head>Streamed Documents</head>
           
            <p>The data model for nodes in a document that is being streamed is no different from
               the standard XDM data model, in that it contains the same objects (nodes) with the
               same properties and relationships. The facilities for streaming do not change the
               data model; instead they impose rules that limit the ability of stylesheets to
               navigate the data model.</p>
            <p>A useful way to visualize streaming is to suppose that at any point in time, there is
               a current position in the streamed input document which may be the start or end of
               the document, the start or end tag of an element, or a text, comment, or processing
               instruction node. From this position, the stylesheet has access to the following
               information: </p>
            <ulist>
               <item>
                  <p>Properties intrinsic to the node, such as its name, its base URI, its type
                     annotation, and its <code>is-id</code> and <code>is-idref</code>
                     properties.</p>
               </item>
               <item>
                  <p>The ancestors of the node (but navigation downwards from the ancestors is not
                     permitted).</p>
               </item>
               <item>
                  <p>The attributes of the node, and the attributes of its ancestors. For each such
                     attribute, all the properties of the node including its string value and typed
                     value are available, but there are limitations that restrict navigation from
                     the attribute node to other nodes in the document.</p>
               </item>
               <item>
                  <p>The in-scope namespace bindings of the node.</p>
               </item>
               <item>
                  <p>In the case of attributes, text nodes, comments, and processing instructions,
                     the string value and typed value of the node.</p>
               </item>
               
               <item>
                  <p>In the case of element nodes, whether or not the element has children. This
                     information is obtained by calling the <xfunction>has-children</xfunction>
                     function. This implies that the processor performs look-ahead (limited to a
                     single token) to determine whether the start tag is immediately followed by a
                     matching end tag.</p>
               </item>
               <item>
                  <p>In the case of document nodes, details of unparsed entities in the document.
                     This information is obtained by calling the
                        <function>unparsed-entity-uri</function> and
                        <function>unparsed-entity-public-id</function> functions. A processor might
                     enable this by reading the DTD as soon as the document is opened. Since
                     comments and processing instructions that precede the DOCTYPE declaration are
                     available as children of the document node, this also implies that a streaming
                     processor needs sufficient memory to hold these comments and processing
                     instructions until the start tag of the first element is encountered.
                     Information about unparsed entities remains available for the duration of
                     processing, in the same way as attributes of ancestor elements.</p>
               </item>
            </ulist>
            <p>The children and other descendants of a node are not accessible except as a
               by-product of changing the current position in the document. The same applies to
               properties of an element or document node that require examination of the
               node’s descendants, that is, the string value and typed value. This is
               enforced by means of a rule that only one expression requiring downward navigation
               from a node is permitted.</p>


            <p>Information about the type of a node is in general
               considered a property intrinsic to the node, and is available without advancing the
               input stream. There is an exception for an expression of the form <code>(/) instance
                  of document-node(element(invoice))</code>. This is not guaranteed streamable,
               because it requires reading ahead to check that the document node has only one
               element child. However, a processor that knows that the parser delivering the
               document stream is only capable of delivering well-formed documents may use this
               knowledge (along with the limited look-ahead needed to get the name of the outermost
               element) to make this expression streamable.</p>

            <p>A streaming processor is not
                  required to read any more of the source document than is needed to
               generate correct stylesheet output. It is not required to read the full source
               document merely in order to satisfy the requirement imposed by the XML Recommendation
               that an XML Processor must report violations of well-formedness in the input.</p>

            <p>More detailed rules are defined in <specref ref="streamability"/>.</p>
            </div3>
            <div3 id="streaming-other-types">
               <head>Other Data Structures</head>
               
               <p diff="chg" at="A">Maps and arrays were defined in XPath 3.1.</p>
               <p>Streaming facilities in this specification are, for the most part, relevant 
                  only to streamed processing of XML trees, and not to other structures such as 
                  sequences, maps and arrays, which will typically be held in memory unless 
                  the processor is capable of avoiding this.
               </p>
               <p>Maps, however, play an important role in enabling streamed applications
               to be written. For example, a map can be used as the data structure maintained
               by an accumulator (see <specref ref="accumulators"/>) to remember information
               that has been retrieved from a streamed document, given that it is not possible to
               revisit the same nodes later. There is also a special streamability rule for
               map constructor expressions (see <specref ref="maps-streaming"/>) that allows
               such an expression to make multiple downward selections in the streamed input
               document: for example one can write <code>map{'authors':data(author), 'editors':data(editor)}</code>,
               which gathers the values of these two elements, or sets of elements, from the input
               stream, regardless what order they appear in — even if they are interleaved.</p>
               
               <p>The rules for creating maps and arrays are designed to ensure that the 
                  entries in a map, and the members of an array, cannot contain nodes from 
                  a streamed document. This is achieved by the way in which the streamability 
                  properties of the relevant expressions and functions are defined.
               </p>
               <p>By contrast, sequences can and often do contain nodes from streamed documents, 
                  and a major purpose of the rules for streamability is to make this possible.
               </p>
            </div3>
         </div2>
         <div2 id="limits">
            <head>Limits</head>
            <p>The XDM data model (see <bibref ref="xpath-datamodel-30"/>) leaves it to the host
               language to define limits. This section describes the limits that apply to XSLT.</p>
            <p>Limits on some primitive datatypes are defined in <bibref ref="xmlschema-2"/>. Other
               limits, listed below, are <termref def="dt-implementation-defined">implementation-defined</termref>. Note that this does not necessarily mean that
               each limit must be a simple constant: it may vary depending on environmental factors
               such as available resources.</p>
            <imp-def-feature id="idf-defaults-limits">Limits on the value space of primitive
               datatypes, where not fixed by <bibref ref="xmlschema-2"/>, are
               implementation-defined.</imp-def-feature>
            <p>The following limits are <termref def="dt-implementation-defined">implementation-defined</termref>:</p>
            <olist>
               <item>
                  <p>For the <code>xs:decimal</code> type, the maximum number of decimal digits (the
                        <code>totalDigits</code> facet). This must be at least 18 digits. (Note,
                     however, that support for the full value range of <code>xs:unsignedLong</code>
                     requires 20 digits.) </p>
               </item>
               <item>
                  <p>For the types <code>xs:date</code>, <code>xs:time</code>,
                        <code>xs:dateTime</code>, <code>xs:gYear</code>, and
                        <code>xs:gYearMonth</code>: the range of values of the year component, which
                     must be at least +0001 to +9999; and the maximum number of fractional second
                     digits, which must be at least 3.</p>
               </item>
               <item>
                  <p>For the <code>xs:duration</code> type: the maximum absolute values of the
                     years, months, days, hours, minutes, and seconds components. </p>
               </item>
               <item>
                  <p>For the <code>xs:yearMonthDuration</code> type: the maximum absolute value,
                     expressed as an integer number of months.</p>
               </item>
               <item>
                  <p>For the <code>xs:dayTimeDuration</code> type: the maximum absolute value,
                     expressed as a decimal number of seconds.</p>
               </item>
               <item>
                  <p>For the types <code>xs:string</code>, <code>xs:hexBinary</code>,
                        <code>xs:base64Binary</code>, <code>xs:QName</code>, <code>xs:anyURI</code>,
                        <code>xs:NOTATION</code>, and types derived from them: the maximum length of
                     the value. </p>
               </item>
               <item>
                  <p>For sequences, the maximum number of items in a sequence.</p>
               </item>
            </olist>
         </div2>
         <div2 id="d-o-e-in-data-model">
            <head>Disable Output Escaping</head>
            <p>For backwards compatibility reasons, XSLT 4.0
               continues to support the <code>disable-output-escaping</code> feature introduced in
               XSLT 1.0. This is an optional feature and implementations are not
                  <rfc2119>required</rfc2119> to support it. A new facility, that of named <termref def="dt-character-map">character maps</termref> (see <specref ref="character-maps"/>) was introduced in XSLT 2.0. It provides
               similar capabilities to <code>disable-output-escaping</code>, but without distorting
               the data model.</p>
            <p>If an <termref def="dt-implementation">implementation</termref> supports the
                  <code>disable-output-escaping</code> attribute of <elcode>xsl:text</elcode> and
                  <elcode>xsl:value-of</elcode>, (see <specref ref="disable-output-escaping"/>),
               then the data model for trees constructed by the <termref def="dt-processor">processor</termref> is augmented with a boolean value representing the value of
               this property. This boolean value, however, can be set only within a <termref def="dt-final-result-tree">final result tree</termref> that is being passed to the
               serializer.</p>
            <p>Conceptually, each character in a text node on such a result tree has a boolean
               property indicating whether the serializer is to disable the normal rules for
               escaping of special characters (for example, outputting of <code>&amp;</code> as
                  <code>&amp;amp;</code>) in respect of this character.</p>
            <note>
               <p>In practice, the nodes in a <termref def="dt-final-result-tree">final result
                     tree</termref> will often be streamed directly from the XSLT processor to the
                  serializer. In such an implementation, <code>disable-output-escaping</code> can be
                  viewed not so much a property stored with nodes in the tree, but rather as
                  additional information passed across the interface between the XSLT processor and
                  the serializer.</p>
            </note>
         </div2>
      </div1>
      <div1 id="constructs">
         <head>Features of the XSLT Language</head>
         <div2 id="names">
            <head>Names</head>

            <div3 id="qname">
               <head>Qualified Names</head>
               <p>Many constructs appearing in a stylesheet, for example <termref def="dt-named-template">named templates</termref>, <termref def="dt-mode">modes</termref>, and <termref def="dt-attribute-set">attribute sets</termref>,
                  are named using a qualified name: this consists of a local name and an optional
                  namespace URI.</p>

               <p>In most cases where such names are written in a <termref def="dt-stylesheet">stylesheet</termref>, 
                  the syntax for expressing the name is given by the
                  production <xnt spec="XP40" ref="prod-xpath40-EQName">EQName</xnt> in the XPath
                  specification. In practice, this means that three forms are permitted:</p>

               <ulist>
                  <item>
                     <p>A simple <code>NCName</code> appearing on its own (without any prefix). This
                        represents the local name of the object. The interpretation of unprefixed
                        names is described below.</p>
                  </item>
                  <item>
                     <p>A <termref def="dt-lexical-qname">lexical QName</termref> written in the
                        form <code>NCName ":" NCName</code> where the first part is a namespace
                        prefix and the second part is the local name. The namespace part of the
                        object’s name is then derived from the prefix by examining the
                        in-scope namespace bindings of the element node in the stylesheet where the
                        name appears.</p>
                  </item>
                  <item>
                     <p>A <xnt spec="XP40" ref="prod-xpath40-URIQualifiedName">URIQualifiedName</xnt> in the form <code>"Q{" URI? "}" NCName</code>
                        where the two parts of the name, that is the namespace part and the local
                        part, both appear explicitly. If the URI part is omitted (for example
                           <code>Q{}local</code>), the resulting expanded QName is a QName whose
                        namespace part is absent.</p>
                  </item>
               </ulist>
               
               <p diff="add" at="B">The rules for the use of these constructs generally permit
               leading and trailing whitespace, which is ignored.</p>

               <note>
                  <p>There are a few places where the third form, a URIQualifiedName, is not
                     permitted. These include the <code>name</code> attribute of
                        <elcode>xsl:element</elcode> and <elcode>xsl:attribute</elcode> (which have
                     a separate <code>namespace</code> attribute for the purpose), and constructs
                     defined by other specifications. For example, names appearing within an
                     embedded <code>xs:schema</code> element must follow the XSD rules.</p>
               </note>

               <p>
                  <termdef id="dt-expanded-qname" term="expanded QName">An <term>expanded
                        QName</term> is a value in the value space of the <code>xs:QName</code>
                     datatype as defined in the XDM data model (see <bibref ref="xpath-datamodel-30"/>): that is, a triple containing namespace prefix (optional), namespace URI
                     (optional), and local name. Two expanded QNames are equal if the namespace URIs
                     are the same (or both absent) and the local names are the same. The prefix
                     plays no part in the comparison, but is used only if the expanded QName needs
                     to be converted back to a string.</termdef>
               </p>

               <p><termdef id="dt-eqname" term="EQName">An <term>EQName</term> is a string
                     representing an <termref def="dt-expanded-qname">expanded QName</termref> where
                     the string, after removing leading and trailing whitespace, is in the form
                     defined by the <xnt spec="XP40" ref="prod-xpath40-EQName">EQName</xnt>
                     production in the XPath specification.</termdef></p>



               <p>
                  <termdef id="dt-lexical-qname" term="lexical QName">A <term>lexical QName</term>
                     is a string representing an <termref def="dt-expanded-qname">expanded
                        QName</termref> where the string, after removing leading and trailing
                     whitespace, is within the lexical space of the <code>xs:QName</code> datatype
                     as defined in XML Schema (see <bibref ref="xmlschema-2"/>): that is, a local
                     name optionally preceded by a namespace prefix and a colon.</termdef>
               </p>

               <p>Note that every <termref def="dt-lexical-qname">lexical QName</termref> is an
                     <termref def="dt-eqname">EQName</termref>, but the converse is not true.</p>


               <p>The following rules are used when interpreting a <termref def="dt-lexical-qname">lexical QName</termref>:</p>

               <olist>
                  <item>
                     <p>
                        <termdef id="dt-defining-element" term="defining element">A string in the
                           form of a lexical QName may occur as the value of an attribute node in a
                           stylesheet module, or within an XPath <termref def="dt-expression">expression</termref> contained in an attribute or text node within a stylesheet module, or as the
                           result of evaluating an XPath expression contained in such a node. The
                           element containing this attribute or
                              text node is referred to as the <term>defining element</term>
                           of the lexical QName.</termdef>
                     </p>
                  </item>

                  <item>
                     <p>If the lexical QName has a prefix, then the prefix is expanded into a URI
                        reference using the namespace declarations in effect on its <termref def="dt-defining-element">defining element</termref>. The <termref def="dt-expanded-qname">expanded QName</termref> consisting of the local
                        part of the name and the possibly null URI reference is used as the name of
                        the object. The default namespace of the defining element (see <xspecref spec="DM30" ref="ElementNode"/>) is <emph>not</emph> used for unprefixed
                        names.</p>
                     <p>
                        <error spec="XT" type="static" class="SE" code="0280">
                           <p>In the case of a prefixed <termref def="dt-lexical-qname">lexical
                                 QName</termref> used as the value (or as
                                 part of the value) of an attribute in the <termref def="dt-stylesheet">stylesheet</termref>, or appearing within an
                              XPath <termref def="dt-expression">expression</termref> in the
                              stylesheet, it is a <termref def="dt-static-error">static
                                 error</termref> if the <termref def="dt-defining-element">defining
                                 element</termref> has no namespace node whose name matches the
                              prefix of the <termref def="dt-lexical-qname">lexical
                              QName</termref>.</p>
                        </error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0290">
                           <p>Where the result of evaluating an XPath expression (or an attribute
                              value template) is required to be a <termref def="dt-lexical-qname">lexical QName</termref>, or if it is permitted to be a <termref def="dt-lexical-qname">lexical QName</termref> and the actual value
                              takes the form of a <termref def="dt-lexical-qname">lexical
                                 QName</termref>, then unless otherwise specified it is a <termref def="dt-dynamic-error"> dynamic error</termref> if the value
                              has a prefix and the <termref def="dt-defining-element">defining
                                 element</termref> has no namespace node whose name matches that
                              prefix. This error <rfc2119>may</rfc2119> be signaled as a <termref def="dt-static-error">static error</termref> if the value of the
                              expression can be determined statically.</p>
                        </error>
                     </p>
                  </item>
                  <item>
                     <p>If the lexical QName has no prefix, then:</p>
                     <olist>
                        <item>
                           <p>In the case of an unprefixed QName used as a <code>NameTest</code>
                              within an XPath <termref def="dt-expression">expression</termref> (see
                                 <specref ref="expressions"/>), and in certain other contexts, the
                              namespace to be used in expanding the QName may be specified by means
                              of the <code>[xsl:]xpath-default-namespace</code> attribute, as
                              specified in <specref ref="unprefixed-qnames"/>.</p>
                        </item>

                        <item>
                           <p>If the name is in one of the following categories, then the default
                              namespace of the <termref def="dt-defining-element">defining
                                 element</termref> is used:</p>
                           <olist>
                              <item>
                                 <p>Where a QName is used to define the name of an element being
                                    constructed. This applies both to cases where the name is known
                                    statically (that is, the name of a literal result element) and
                                    to cases where it is computed dynamically (the value of the
                                       <code>name</code> attribute of the
                                       <elcode>xsl:element</elcode> instruction).</p>
                              </item>
                              <item>
                                 <p>The default namespace is used when expanding the first argument
                                    of the function <function>element-available</function>.</p>
                              </item>
                              <item>
                                 <p>The default namespace applies to any unqualified element names
                                    appearing in the <code>cdata-section-elements</code>
                                    or
                                          <code>suppress-indentation</code> attributes of
                                       <elcode>xsl:output</elcode> or
                                       <elcode>xsl:result-document</elcode>
                                 </p>
                              </item>
                           </olist>
                        </item>

                        <item>
                           <p>In all other cases, a <termref def="dt-lexical-qname">lexical
                                 QName</termref> with no prefix represents an <termref def="dt-expanded-qname">expanded QName</termref> in no namespace
                              (that is, an <code>xs:QName</code> value in which both the prefix and
                              the namespace URI are absent).</p>
                        </item>
                     </olist>
                  </item>


               </olist>
            </div3>
            <div3 id="unprefixed-qnames" diff="chg" at="A">
               <head>Unprefixed Lexical QNames in Expressions and Patterns</head>
               
               
               <div4 id="unprefixed-element-names">
                  <head>Unprefixed Element Names</head>
               
               <p>The attribute <code>[xsl:]default-element-namespace</code> (see <specref ref="standard-attributes"/>) 
                  may be used on an element in the <termref def="dt-stylesheet">stylesheet</termref> to define the 
                  namespace that will be used for an unprefixed element name within an XPath expression, and
                  in certain other contexts listed below.</p>
               <p>The attribute <code>[xsl:]xpath-default-namespace</code> (which is retained for backwards
                  compatibility reasons) also has the same effect, but also affects unprefixed type names.</p>
               <p>The value of the attribute, in each case, is the namespace URI to be used.</p>
               <p>For any element <code>$E</code> in the <termref def="dt-stylesheet">stylesheet</termref>, there is an
                  effective value for the default element namespace, which is the value of the
                  XPath expression:</p>
                  <eg>string(($E/ancestor-or-self::node()/
     (self::xsl:*/@default-element-namespace 
        otherwise
      @xsl:default-element-namespace
        otherwise
      self::xsl:*/@xpath-default-namespace
        otherwise
      @xsl:xpath-default-namespace))[last()]).</eg>
               <note><p>That is, the default element namespace is the value of the <code>[xsl:]default-element-namespace</code> or
                  <code>[xsl:]xpath-default-namespace</code> attribute on that element or on the innermost
                  containing element that specifies such an attribute, or a zero-length string if
                  no containing element specifies such an attribute; and if both attributes are present
                  on the same element, then <code>[xsl:]default-element-namespace</code> wins.</p></note>
               
               <p>For any element in the <termref def="dt-stylesheet">stylesheet</termref>, the
                  effective value of the default element namespace determines the value of the <emph>default
                     namespace for element names</emph> in the static context of any XPath
                  expression contained in an attribute or text
                     node of that element (including XPath expressions in <termref def="dt-attribute-value-template">attribute value templates</termref>
                  and <termref def="dt-text-value-template">text value
                        templates</termref>). The effect of this is specified in <bibref ref="xpath-40"/>; in summary, it determines the namespace used for any
                  unprefixed element name appearing in a path expression or in the <termref def="dt-sequence-type"/>
                  production.</p>
               <p>The effective value of this attribute similarly applies to any of the following
                  constructs appearing within its scope:</p>
               <ulist>
                  <item>
                     <p>any unprefixed element name used in a <termref def="dt-pattern">pattern</termref>
                     </p>
                  </item>
                  <item>
                     <p>any unprefixed element name used in the <code>elements</code> attribute of
                        the <elcode>xsl:strip-space</elcode> or <elcode>xsl:preserve-space</elcode>
                        instructions</p>
                  </item>
                  <item>
                     <p>any unprefixed element name used in the <code>as</code>
                        attribute of an <termref def="dt-xslt-element">XSLT element</termref>
                     </p>
                  </item>
                  
               </ulist>
               <p>The <code>[xsl:]xpath-default-namespace</code> attribute <rfc2119>must</rfc2119>
                  be in the <termref def="dt-xslt-namespace">XSLT namespace</termref> if and only if
                  its parent element is <emph>not</emph> in the XSLT namespace.</p>
               <p>If the effective value of the attribute is a zero-length string, which will be the
                  case if it is explicitly set to a zero-length string or if it is not specified at
                  all, then an unprefixed element name or type name refers to a name that is in no
                  namespace. The default namespace of the parent element (see <xspecref spec="DM30" ref="ElementNode"/>) is <emph>not</emph> used.</p>
               </div4>
               
               <div4 id="unprefixed-type-names">
                  <head>Unprefixed Type Names</head>
                  
                  <p>The attribute <code>[xsl:]default-type-namespace</code> (see <specref ref="standard-attributes"/>) 
                     may be used on an element in the <termref def="dt-stylesheet">stylesheet</termref> to define the 
                     namespace that will be used for an unprefixed type name within an XPath expression, and
                     in certain other contexts listed below.</p>
                  <p>The attribute <code>[xsl:]xpath-default-namespace</code> (which is retained for backwards
                     compatibility reasons) also has the same effect, but also affects unprefixed element names.</p>
                  <p>The value of the attribute, in each case, is the namespace URI to be used.</p>
                  <p>For any element <code>$E</code> in the <termref def="dt-stylesheet">stylesheet</termref>, there is an
                     effective value for the default type namespace, which is the value of the
                     XPath expression:</p>
                  <eg>string(($E/ancestor-or-self::node()/
   (self::xsl:*/@default-type-namespace 
      otherwise
   @xsl:default-type-namespace
      otherwise
   self::xsl:*/@xpath-default-namespace
      otherwise
   @xsl:xpath-default-namespace))[last()]).</eg>
                  <note><p>That is, the default type namespace is the value of the <code>[xsl:]default-type-namespace</code> or
                     <code>[xsl:]xpath-default-namespace</code> attribute on that element or on the innermost
                     containing element that specifies such an attribute, or a zero-length string if
                     no containing element specifies such an attribute; and if both attributes are present
                     on the same element, then <code>[xsl:]default-type-namespace</code> wins.</p></note>
                  
                  <p>For any element in the <termref def="dt-stylesheet">stylesheet</termref>, the
                     effective value of the default type namespace determines the value of the <emph>default
                        namespace for type names</emph> in the static context of any XPath
                     expression contained in an attribute or text
                     node of that element (including XPath expressions in <termref def="dt-attribute-value-template">attribute value templates</termref>
                     and <termref def="dt-text-value-template">text value
                        templates</termref>). The effect of this is specified in <bibref ref="xpath-40"/>; in summary, it determines the namespace used for any
                     unprefixed element name appearing in a path expression or in the <termref def="dt-sequence-type"/>
                     production.</p>
                  <p>The effective value of this attribute similarly applies to any of the following
                     constructs appearing within its scope:</p>
                  <ulist>
                     <item>
                        <p>any unprefixed type name used in a <termref def="dt-pattern">pattern</termref>
                        </p>
                     </item>
                     <item>
                        <p>any unprefixed type name used in the <code>as</code> or <code>type</code>
                           attribute of an <termref def="dt-xslt-element">XSLT element</termref>
                        </p>
                     </item>
                     <item>
                        <p>any unprefixed type name used in the <code>xsl:type</code>
                           attribute of a <termref def="dt-literal-result-element"/>.
                        </p>
                     </item>
                     
                  </ulist>
                  
                  <p>If the effective value of the attribute is a zero-length string, which will be the
                     case if it is explicitly set to a zero-length string or if it is not specified at
                     all, then an unprefixed element name or type name refers to a name that is in no
                     namespace. The default namespace of the parent element (see <xspecref spec="DM30" ref="ElementNode"/>) 
                     is <emph>not</emph> used.</p>
                  
                  <note><p>In a stylesheet that does not import any schema, all type names used are likely
                  to be in the namespace <code>http://www.w3.org/2001/XMLSchema</code>, which is traditionally
                  bound to the prefix <code>xs</code>. In such a stylesheet, it makes sense to declare (on the
                     outermost <elcode>xsl:stylesheet</elcode> element) the attribute 
                     <code>default-type-namespace="http://www.w3.org/2001/XMLSchema"</code>. With this
                  declaration in place, variables and parameters can use type declarations such
                  as <code>as="integer"</code> rather than <code>as="xs:integer"</code>, thus eliminating the need
                  to declare this namespace.</p>
                  <p>Note however that the default namespace for types does not apply to the names of constructor
                  functions. In a function call such as <code>decimal(@price)</code> the rules for unprefixed
                  function names, not type names, apply.</p>
                  <p>In a stylesheet that imports a no-namespace schema, setting the default type namespace to
                     <code>http://www.w3.org/2001/XMLSchema</code> is still possible; but in this case user-defined
                  types in no namespace can only be referenced using the notation <code>Q{}my-type</code>.</p></note>
               </div4>
               <div4 id="unprefixed-function-names">
                  <head>Unprefixed Function Names</head>
                  <p>The interpretation of unprefixed function names is described in
                  <specref ref="resolving-function-names"/>.</p>
               </div4>
               <div4 id="other-unprefixed-names">
                  <head>Other Unprefixed Names</head>
                  <p>For other unprefixed names, for example variable
                     names, template names, mode names, or strings that are interpreted as <termref def="dt-lexical-qname">lexical QNames</termref> during stylesheet evaluation,
                     such as the <termref def="dt-effective-value">effective value</termref> of the
                     <code>name</code> attribute of <elcode>xsl:element</elcode> or the string
                     supplied as the first argument to the <function>key</function> function, any unprefixed
                  lexical QName is taken as being a no-namespace name.</p>
               </div4>
               
            </div3>
            <div3 id="reserved-namespaces">
               <head>Reserved Namespaces</head>
               <p>
                  <termdef id="dt-reserved-namespace" term="reserved namespace">The XSLT namespace,
                     together with certain other namespaces recognized by an XSLT processor, are
                     classified as <term>reserved namespaces</term> and <rfc2119>must</rfc2119> be
                     used only as specified in this and related specifications.</termdef> The
                  reserved namespaces are those listed below.</p>
               <ulist>
                  <item>
                     <p>The <termref def="dt-xslt-namespace">XSLT namespace</termref>, described in
                           <specref ref="xslt-namespace"/>, is reserved.</p>
                  </item>
                  <item>
                     <p>
                        <termdef id="dt-standard-function-namespace" term="standard function namespace">The <term>standard function
                              namespace</term>
                           <code>http://www.w3.org/2005/xpath-functions</code> is used for functions
                           in the function library defined in <bibref ref="xpath-functions-40"/> and
                           for standard functions defined in this specification.</termdef>
                     </p>
                  </item>
                  <item>
                     <p> The namespace
                           <code>http://www.w3.org/2005/xpath-functions/math</code> is used for
                        mathematical functions in the function library defined in <bibref ref="xpath-functions-30"/>. </p>
                  </item>
                  <item>
                     <p> The namespace
                           <code>http://www.w3.org/2005/xpath-functions/map</code> is used for
                        functions defined in this specification relating to the manipulation of
                           maps. </p>
                  </item>
                  <item>
                     <p> The namespace
                           <code>http://www.w3.org/2005/xpath-functions/array</code> is reserved for
                        use as described in <bibref ref="xpath-functions-31"/>.<phrase diff="del" at="A"> The namespace is
                        reserved whether or not the processor actually supports XPath 3.1.</phrase></p>
                  </item>
                  <item>
                     <p>
                        <termdef id="xml-namespace" term="XML namespace">The <term>XML
                              namespace</term>, defined in <bibref ref="xml-names"/> as
                              <code>http://www.w3.org/XML/1998/namespace</code>, is used for
                           attributes such as <code>xml:lang</code>, <code>xml:space</code>, and
                              <code>xml:id</code>.</termdef>
                     </p>
                  </item>
                  <item>
                     <p><termdef id="dt-schema-namespace" term="schema namespace">The <term>schema
                              namespace</term>
                           <code>http://www.w3.org/2001/XMLSchema</code> is used as defined in
                              <bibref ref="xmlschema-1"/></termdef>. In a <termref def="dt-stylesheet">stylesheet</termref> this namespace may be used to
                        refer to built-in schema datatypes and to the constructor functions
                        associated with those datatypes.</p>
                  </item>
                  <item>
                     <p><termdef id="dt-schema-instance-namespace" term="schema instance namespace">The <term>schema instance namespace</term>
                           <code>http://www.w3.org/2001/XMLSchema-instance</code> is used as defined
                           in <bibref ref="xmlschema-1"/></termdef>. Attributes in this namespace,
                        if they appear in a <termref def="dt-stylesheet">stylesheet</termref>, are
                        treated by the XSLT processor in the same way as any other attributes.</p>
                  </item>
                  <item>
                     <p><termdef id="dt-standard-error-namespace" term="standard error namespace">The <term>standard error namespace</term>
                           <code>http://www.w3.org/2005/xqt-errors</code> is used for error codes
                           defined in this specification and related specifications. It is also used
                           for the names of certain predefined variables accessible within the scope
                           of an <elcode>xsl:catch</elcode> element.</termdef></p>
                  </item>
                  <item>
                     <p>The namespace <code>http://www.w3.org/2000/xmlns/</code> is reserved for use
                        as described in <bibref ref="xml-names"/>. No element or attribute node can
                        have a name in this namespace, and although the prefix <code>xmlns</code> is
                        implicitly bound to this namespace, no namespace node will ever define this
                        binding.</p>
                  </item>
               </ulist>
               
               <note>
                  <p>With the exception of the XML namespace, any of the above namespaces that are
                     used in a stylesheet must be explicitly declared with a namespace declaration.
                     Although conventional prefixes are used for these namespaces in this
                     specification, any prefix may be used in a user stylesheet.</p>
               </note>

               <p>Reserved namespaces may be used without restriction to refer to the names of
                  elements and attributes in source documents and result documents. As far as the
                  XSLT processor is concerned, reserved namespaces other than the XSLT namespace may
                  be used without restriction in the names of <termref def="dt-literal-result-element">literal result elements</termref> and <termref def="dt-data-element">user-defined data elements</termref>, and in the names of
                  attributes of literal result elements or of <termref def="dt-xslt-element">XSLT
                     elements</termref>: but other processors <rfc2119>may</rfc2119> impose
                  restrictions or attach special meaning to them. Reserved namespaces <rfc2119>must
                     not</rfc2119> be used, however, in the names of stylesheet-defined objects such
                  as <termref def="dt-variable">variables</termref> and <termref def="dt-stylesheet-function">stylesheet functions</termref>,
                     nor in the names of <termref def="dt-extension-function">extension functions</termref>
                     or <termref def="dt-extension-instruction">extension instructions</termref>.</p>
               
               <p>It is not an error to use a reserved namespace in the name of an 
                  <termref def="dt-extension-attribute">extension attribute</termref>: 
                  attributes such as <code>xml:space</code> and <code>xsi:type</code> 
                  fall into this category. XSLT processors <rfc2119>must not</rfc2119> reject such attributes, 
                  and <rfc2119>must not</rfc2119> attach any meaning to them other than any meaning 
                  defined by the relevant specification.</p>
               
               <p>
                  <error spec="XT" type="static" class="SE" code="0080">
                     <p>It is a <termref def="dt-static-error">static error</termref> to use a
                           <termref def="dt-reserved-namespace">reserved namespace</termref> in the
                        name of a <termref def="dt-named-template">named template</termref>, a
                           <termref def="dt-mode">mode</termref>, an <termref def="dt-attribute-set">attribute set</termref>, a <termref def="dt-key">key</termref>, a
                           <termref def="dt-decimal-format">decimal-format</termref>, a <termref def="dt-variable">variable</termref> or <termref def="dt-parameter">parameter</termref>, a <termref def="dt-stylesheet-function">stylesheet
                           function</termref>, a named <termref def="dt-output-definition">output
                           definition</termref>, an <termref def="dt-accumulator"/>, or a <termref def="dt-character-map">character map</termref><phrase>; except that the name
                              <code>xsl:initial-template</code> is permitted as a template
                           name.</phrase></p>
                  </error>
               </p>

               <note>
                  <p>The name <code>xsl:original</code> is used within <elcode>xsl:override</elcode>
                     to refer to a <termref def="dt-component"/> that is being overridden. Although
                     the name <code>xsl:original</code> is used to refer to the component, the
                     component has its own name, and no component ever has the name
                        <code>xsl:original</code>. </p>
               </note>

            </div3>
         </div2>


         <div2 id="expressions">
            <head>Expressions</head>
            <p>XSLT uses the expression language defined by <phrase>XPath 3.0</phrase>
               <bibref ref="xpath-30"/>. Expressions are used in XSLT for a variety of purposes
               including:</p>
            <ulist>
               <item>
                  <p>selecting nodes for processing;</p>
               </item>
               <item>
                  <p>specifying conditions for different ways of processing a node;</p>
               </item>
               <item>
                  <p>generating text to be inserted in a <termref def="dt-result-tree">result
                        tree</termref>.</p>
               </item>
            </ulist>
            <p>
               <termdef id="dt-expression" term="expression">Within this specification, the term
                     <term>XPath expression</term>, or simply <term>expression</term>, means a
                  string that matches the production <xnt spec="XP40" ref="prod-xpath40-Expr">Expr</xnt> 
                  defined in <bibref ref="xpath-30"/><phrase diff="del">, with the extensions defined in <specref ref="map"/></phrase>.</termdef>
            </p>
            <p diff="del" at="A">If the processor implements the XPath 3.1 feature, then the definition of the production
                  <code>Expr</code> from XPath 3.1 is used.</p>
            <p diff="del" at="A">If the processor is configured to use a version of XPath
               later than XPath 3.1, then the syntax of an XPath expression is <termref def="dt-implementation-defined"/>.</p>
            <p>An XPath expression may occur as the value of certain attributes on XSLT-defined
               elements, and also within curly brackets in <termref def="dt-attribute-value-template">attribute value templates</termref>
               and <termref def="dt-text-value-template">text value
                     templates</termref>.</p>
            <p>Except where <termref def="dt-forwards-compatible-behavior"/> is enabled (see
                  <specref ref="forwards"/>), it is a <termref def="dt-static-error">static
                  error</termref> if the value of such an attribute, <error.extra>an attribute
                  defined as containing an XPath <termref def="dt-expression">expression</termref>
               </error.extra> or the text between curly brackets in an <termref def="dt-attribute-value-template">attribute value template</termref>
               or <termref def="dt-text-value-template">text value
                     template</termref>, does not match the XPath production <xnt spec="XP40" ref="prod-xpath40-Expr">Expr</xnt>, or if it fails to satisfy other
               static constraints defined in the XPath specification, for example that all variable
               references <rfc2119>must</rfc2119> refer to <termref def="dt-variable">variables</termref> that are in scope. Error codes are defined in <bibref ref="xpath-30"/>.</p>
            <p>The transformation fails with a <termref def="dt-dynamic-error"> dynamic error</termref> if any XPath <termref def="dt-expression">expression</termref> is evaluated and raises a dynamic error.
               Error codes are defined in <bibref ref="xpath-30"/>.</p>
            <p>The transformation fails with a <termref def="dt-type-error">type error</termref> if
               an XPath <termref def="dt-expression">expression</termref> raises a type error, or if
               the result of evaluating the XPath <termref def="dt-expression">expression</termref>
               is evaluated and raises a type error, or if the XPath processor signals a type error
               during static analysis of an <termref def="dt-expression">expression</termref>. Error
               codes are defined in <bibref ref="xpath-30"/>.</p>
            <p>
               <termdef id="dt-required-type" term="required type">The context within a <termref def="dt-stylesheet">stylesheet</termref> where an XPath <termref def="dt-expression">expression</termref> appears may specify the <term>required
                     type</term> of the expression. The required type indicates the type of the
                  value that the expression is expected to return.</termdef> If no required type is
               specified, the expression may return any value: in effect, the required type is then
                  <code>item()*</code>. </p>
            

            <p diff="chg" at="A">
               <termdef id="dt-coercion-rules" term="coercion rules"> When
                  used in this specification without further qualification, the term <term>coercion rules</term> 
                  means the coercion rules defined in <bibref ref="xpath-40"/>, applied with XPath 1.0 
                  compatibility mode set to false.</termdef>
            </p>
            
            <note diff="add" at="A">
               <p>In earlier versions of this specification, these were referred to as the
               <term>function conversion rules.</term></p>
            </note>

            <note>
               <p> These are the rules defined in <bibref ref="xpath-40"/> for converting the
                  supplied argument of a function call to the required type of that argument, as
                  defined in the function signature. The same rules are used in XSLT for converting
                  the value of a variable to the declared type of the variable, or the result of
                  evaluating a function or template body to the declared type of the function or
                  template. They are also used when parameters are supplied to a template using
                     <elcode>xsl:with-param</elcode>. In all such cases, the rules that apply are
                  the XPath 4.0 rules without XPath 1.0 compatibility mode. The rules with XPath 1.0
                  compatibility mode set to true are used only for XPath function calls, and for the
                  operands of certain XPath operators. </p>
            </note>

            <p>This specification also invokes the XPath 3.0
               <termref def="dt-coercion-rules"/> to
               convert the result of evaluating an XSLT <termref def="dt-sequence-constructor">sequence constructor</termref> to a required type (for example, the sequence
               constructor enclosed in an <elcode>xsl:variable</elcode>,
                  <elcode>xsl:template</elcode>, or <elcode>xsl:function</elcode> element).</p>
            <p>Any <termref def="dt-dynamic-error">dynamic error</termref> or <termref def="dt-type-error">type error</termref> 
               that occurs when applying the <termref def="dt-coercion-rules"/> to convert
               a value to a required type results in the transformation failing, in the same way as
               if the error had occurred while evaluating an expression.</p>
            <note>
               <p>Note the distinction between the two kinds of error that may occur. Attempting to
                  convert an integer to a date is a type error, because such a conversion is never
                  possible. Type errors can be reported statically if they can be detected
                  statically, whether or not the construct in question is ever evaluated. Attempting
                  to convert the <phrase diff="chg" at="A"><code>xs:untypedAtomic</code></phrase> value 
                  <code>2003-02-29</code> to a date is a dynamic error rather
                  than a type error, because the problem is with this particular value, not with its
                  type. Dynamic errors are reported only if the instructions or expressions that
                  cause them are actually evaluated. <phrase diff="add" at="A">[XSLT 3.0 Erratum E21, bug 30236]</phrase></p>
            </note>

            <p>The XPath specification states that the host language must
               specify whether the XPath processor normalizes all line breaks on input, before
               parsing, and if it does so, whether it uses the rules of [XML 1.0] or [XML 1.1]. In
               the case of XSLT, all handling of line breaks is the responsibility of the XML parser
               (which may support either XML 1.0 or XML 1.1); the XSLT and XPath processors perform
               no further changes.</p>


            <note>
               <p>Most XPath expressions in a stylesheet appear within
                  XML attributes. They are therefore subject to XML line-ending normalization (for
                  example, a CRLF sequence is normalized to LF) and also to XML attribute-value
                  normalization, which replaces tabs and newlines by spaces. XPath expressions
                  appearing in text value templates, however (see <specref ref="text-value-templates"/>) are subject to line-ending normalization but not
                  attribute-value normalization. In both cases, normalization of whitespace can be
                  prevented by using character references such as <code>&amp;#x9;</code>.</p>
            </note>

         </div2>
         <div2 id="static-and-dynamic-context">
            <head>The Static and Dynamic Context</head>
            <p>XPath defines the concept of an <xtermref spec="XP40" ref="dt-expression-context">expression context</xtermref> which contains all the information that can affect
               the result of evaluating an <termref def="dt-expression">expression</termref>. The
               expression context has two parts, the <xtermref spec="XP40" ref="dt-static-context">static context</xtermref>, and the <xtermref spec="XP40" ref="dt-dynamic-context">dynamic context</xtermref>. The components that make up the expression context
               are defined in the XPath specification (see <xspecref spec="XP40" ref="context"/>).
               This section describes the way in which these components are initialized when an
               XPath expression is contained within an XSLT stylesheet.</p>
            
            <p diff="add" at="A">
               This section does not apply to <termref def="dt-static-expression">static expressions</termref> 
               (whose context is defined in <specref ref="static-expression"/>), nor to XPath expressions 
               evaluated using <elcode>xsl:evaluate</elcode> (whose context is defined in 
               <specref ref="evaluate-dynamic-context"/>). [XSLT 3.0 Erratum E24, bug 30241]
            </p>
            <p>As well as providing values for the static and dynamic context components defined in
               the XPath specification, XSLT defines additional context components of its own. These
               context components are used by XSLT instructions (for example,
                  <elcode>xsl:next-match</elcode> and <elcode>xsl:apply-imports</elcode>), and also
               by the functions in the extended function library described in this
               specification.</p>
            <p>The following four sections describe:</p>
            <slist>
               <sitem>
                  <specref ref="static-context"/>
               </sitem>
               <sitem>
                  <specref ref="additional-static-context"/>
               </sitem>
               <sitem>
                  <specref ref="xpath-dynamic-context"/>
               </sitem>
               <sitem>
                  <specref ref="additional-dynamic-context"/>
               </sitem>
            </slist>
            <div3 id="static-context">
               <head>Initializing the Static Context</head>
               <p>The <xtermref spec="XP40" ref="dt-static-context">static context</xtermref> of an
                  XPath expression appearing in an XSLT stylesheet is initialized as follows. In
                  these rules, the term <term>containing element</term> means the element within the
                  stylesheet that is the parent of the attribute or text
                     node whose value contains the XPath expression in question, and the
                  term <term>enclosing element</term> means the containing element or any of its
                  ancestors.</p>
               <ulist>
                  <item>
                     <p>
                        <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref>
                        is set to true if and only if the containing element is processed with
                           <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref> (see
                           <specref ref="backwards"/>).</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP40" ref="dt-static-namespaces">statically known
                           namespaces</xtermref> are the namespace declarations that are in scope
                        for the containing element.</p>
                  </item>
                  <item>
                     <p diff="chg" at="A">The <xtermref spec="XP40" ref="dt-def-element-ns">default element
                           namespace</xtermref> is determined as described in
                        <specref ref="unprefixed-element-names"/>.</p>
                  </item>
                  <item>
                     <p diff="chg" at="A">The <xtermref spec="XP40" ref="dt-def-type-ns">default type
                        namespace</xtermref> is determined as described in
                        <specref ref="unprefixed-type-names"/>..</p>
                  </item>
                  <item>
                     <p diff="chg" at="A">The algorithm used as the <xtermref ref="dt-function-name-resolver" 
                        spec="XP40">function resolver</xtermref> is described in <specref ref="resolving-function-names"/>.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP40" ref="dt-issd">in-scope schema
                           definitions</xtermref> for the XPath expression are the same as the
                           <termref def="dt-in-scope-schema-component">in-scope schema
                           components</termref> for the <termref def="dt-stylesheet">stylesheet</termref>, and are as specified in <specref ref="built-in-types"/>.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP40" ref="dt-in-scope-variables">in-scope
                           variables</xtermref> are defined by the <termref def="dt-variable-binding-element">variable binding elements</termref>
                        that are in scope for the containing element (see <specref ref="variables-and-parameters"/>).</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP40" ref="dt-context-item-static-type">context item
                           static type</xtermref> may be determined by an XSLT processor that
                        performs static type inferencing, using rules that are outside the scope of
                        this specification; if no static type inferencing is done, then the context
                        item static type for every XPath expression is <code>item()</code>. Note that some limited static type inferencing is
                           required in the case of a processor that performs streamability analysis:
                           see <specref ref="determining-static-type"/>.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP40" ref="dt-known-func-signatures">statically known
                           function signatures</xtermref> are:</p>

                     <ulist>
                        <item>
                           <p>The functions defined in <bibref ref="xpath-functions-40"/> in
                              namespaces <code>http://www.w3.org/2005/xpath-functions</code> and
                                 <code>http://www.w3.org/2005/xpath-functions/math</code>;</p>
                        </item>
                        <item>
                           <p>The functions defined in this specification in namespaces
                                 <code>http://www.w3.org/2005/xpath-functions</code> and
                                 <code>http://www.w3.org/2005/xpath-functions/map</code>;</p>
                        </item>
                        <item>
                           <p>Constructor functions for all the simple types in the <xtermref spec="XP40" ref="dt-issd">in-scope schema definitions</xtermref>, including both built-in
                              types and user-defined types;</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-stylesheet-function">stylesheet
                                 functions</termref> defined in the containing <termref def="dt-package"/>;</p>
                        </item>
                        <item>
                           <p>Stylesheet functions defined in used packages, subject to visibility:
                              see <specref ref="package-dependencies"/>;</p>
                        </item>
                        <item>
                           <p>any <termref def="dt-extension-function">extension functions</termref>
                              bound using <termref def="dt-implementation-defined">implementation-defined</termref> mechanisms (see <specref ref="extension"/>).</p>
                           <note>
                              <p>The term <termref def="dt-extension-function"/> includes both
                                 vendor-supplied and user-written extension functions.</p>
                           </note>
                        </item>
                     </ulist>

                     <note>
                        <p>It follows from the above that a conformant XSLT processor must implement
                           the entire library of functions defined in
                                 <bibref ref="xpath-functions-40"/> as well as those defined
                           in this specification.</p>
                     </note>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP40" ref="dt-static-collations">statically known
                           collations</xtermref> are <termref def="dt-implementation-defined">implementation-defined</termref>, except that they <rfc2119>must</rfc2119> always include (a) the Unicode
                           codepoint collation, defined in <xspecref spec="FO40" ref="string-compare"/>, and (b) the family of UCA collations described
                           in <specref ref="uca-collations"/>.</p>

                  </item>
                  <item>
                     <p>The <xtermref spec="XP40" ref="dt-def-collation">default
                           collation</xtermref> is defined by the value of the
                           <code>[xsl:]default-collation</code> attribute on the innermost enclosing
                        element that has such an attribute. For details, see <specref ref="default-collation-attribute"/>.</p>
                     <p>
                        <termdef id="dt-default-collation" term="default collation">In this
                           specification the term <term>default collation</term> means the collation
                           that is used by XPath operators such as <code>eq</code> and
                              <code>lt</code> appearing in XPath expressions within the
                           stylesheet.</termdef>
                     </p>
                     <p>This collation is also used by default when comparing strings in the
                        evaluation of the <elcode>xsl:key</elcode> and
                           <elcode>xsl:for-each-group</elcode> elements. This <rfc2119>may</rfc2119>
                        also (but need not necessarily) be the same as the default collation used
                        for <elcode>xsl:sort</elcode> elements within the stylesheet. Collations
                        used by <elcode>xsl:sort</elcode> are described in <specref ref="collating-sequences"/>.</p>
                  </item>
                  <item>
                     <p><term>Static base URI</term>: In a conventional interpreted 
                        environment, the static base URI of an expression in the stylesheet is the base URI 
                        of the containing element in the stylesheet. The concept of the base URI of a node 
                        is defined in <xspecref spec="DM30" ref="dm-base-uri"/>.</p>
                        
                     <p>When stylesheets are executed in an environment where no source code is present
                        (for example, because the code of the stylesheet has been compiled and is distributed 
                        as executable object code), it is <rfc2119>recommended</rfc2119> (subject to operational
                        constraints such as security) that the static base URI used during stylesheet evaluation
                        should be the location from which the stylesheet was loaded for execution 
                        (its “deployed location”). This means, for example, that when the <xfunction>doc</xfunction>
                        or <function>document</function> functions are called with a relative URI, the required document
                        is by default located relative to the deployed location of the stylesheet.
                     </p>
                     
                     <p>Whether or not the stylesheet is executed directly from source code,
                     it is possible that no static base URI is available, for example because the code was supplied
                     as an anonymous input stream, or because security policies are set to prevent executable code discovering
                     the location from which it was loaded. If the static base URI is not known, the <xfunction>static-base-uri</xfunction>
                     function returns an empty sequence, and other operations that depend on the static base URI may fail with
                     a dynamic error.</p>
                     
                  </item>
                  <item>
                     <p>The set of <xtermref spec="XP40" ref="dt-known-docs">statically known
                           documents</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>. </p>
                     <imp-def-feature id="idf-api-staticallyknowndocs">The <xtermref spec="XP40" ref="dt-known-docs">statically known documents</xtermref>, <xtermref spec="XP40" ref="dt-known-collections">statically known
                           collections</xtermref>, and the <xtermref spec="XP40" ref="dt-known-default-collection">statically known default collection
                           type</xtermref> are <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature>
                  </item>
                  <item>
                     <p>The set of <xtermref spec="XP40" ref="dt-known-collections">statically known
                           collections</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>. </p>

                  </item>
                  <item>
                     <p>The <xtermref spec="XP40" ref="dt-known-default-collection">statically known
                           default collection type</xtermref> is <termref def="dt-implementation-defined">implementation-defined</termref>. </p>

                  </item>
                  <item>
                     <p>The set of <xtermref spec="XP40" ref="dt-static-decimal-formats">statically
                           known decimal formats</xtermref> is the set of decimal formats defined by
                           <elcode>xsl:decimal-format</elcode> declarations in the stylesheet. </p>
                     <note diff="del" at="A">
                        <p>XSLT 3.0 provides support for the <code>exponent-separator</code>
                           property which is added to the static context in XPath 3.1; when XSLT 3.0
                           is used with XPath 3.0, this property is ignored.</p>
                     </note>
                  </item>
               </ulist>

            </div3>
            <div3 id="resolving-function-names" diff="add" at="A">
               <head>Resolving Function Names</head>
               <p>This section defines how function names appearing in XPath expressions and patterns
               are resolved: specifically, it defines the <xtermref ref="dt-function-name-resolver" spec="XP40"/> that
                  forms part of the <xtermref ref="dt-static-context" spec="XP40"/>.</p>
               <p>The rules depend on whether or not the stylesheet module contains an
               <elcode>xsl:function-library</elcode> declaration: the following two sections describe
               these two cases.</p>
               <p>The name <code>xsl:original</code> is treated specially, as described in 
               <specref ref="refer-to-overridden"/>.</p>
               
               <div4 id="resolving-function-names-without-function-library">
                  <head>When no <elcode>xsl:function-library</elcode> is Declared</head>
                  <p>In the absence of an <elcode>xsl:function-library</elcode> declaration in the
                  containing module:</p>
                  <olist>
                     <item><p>A lexical QName with no prefix is treated as the local name of a function
                     in the namespace <code>http://www.w3.org/2005/xpath-functions</code>.</p></item>
                     <item><p>A lexical QName with a prefix is resolved by reference to the in-scope
                        namespaces of the <term>containing element</term>.</p></item>
                  </olist>
               </div4>
               
               <div4 id="resolving-function-names-with-function-library">
                  <head>When an <elcode>xsl:function-library</elcode> is Declared</head>
                  <p>A stylesheet module may contain at most one <elcode>xsl:function-library</elcode>
                     declaration. The <elcode>xsl:function-library</elcode> declaration affects the
                  resolution of all function names used in expressions and patterns within that stylesheet
                  module; it has no effect outside the containing module.</p>
                  <?element xsl:function-library?>
                  <?element xsl:function-namespace?>
                  
                  <p>Within the <elcode>xsl:function-library</elcode> declaration, each <elcode>xsl:function-namespace</elcode>
                  element defines a namespace that (typically) contains a number of functions, whose names are in that namespace.</p>
                  
                  <p>It is a static error [TBA] if there is more than one <elcode>xsl:function-library</elcode> declaration
                  within a <termref def="dt-stylesheet-module"/>.</p>
                  
                  <p>It is a static error [TBA] if two <elcode>xsl:function-namespace</elcode> elements within
                     an <elcode>xsl:function-library</elcode> declaration have the same value for the <code>uri</code> attribute.</p>
                  
                  <p>It is a static error [TBA] if two <elcode>xsl:function-namespace</elcode> elements within
                     an <elcode>xsl:function-library</elcode> declaration have the same value for the <code>prefix</code> attribute.</p>
                  
                  
                  <p>An unprefixed function name (together with the required arity) is resolved as follows:</p>
                  <olist>
                     <item><p>If exactly one of the <elcode>xsl:function-namespace</elcode> elements contains a function
                     name with the required local name and arity, and does not exclude that local name by listing it
                     in the <code>exclude</code> attribute, then that function is chosen.</p></item>
                     <item><p>Otherwise (if none of the <elcode>xsl:function-namespace</elcode> elements identifies
                     such a function, or if more than one does so), the name is unresolved and a static error is reported.</p></item>
                  </olist>
                  <p>A prefixed function name (together with the required arity) is resolved as follows:</p>
                  <olist>
                     <item><p>If the namespace prefix used in the lexical QName matches the value of the <code>prefix</code>
                        attribute of one of the <elcode>xsl:function-namespace</elcode> elements, then the local name
                        is expanded using that namespace URI.</p></item>
                     <item><p>Otherwise (if there is no matching <elcode>xsl:function-namespace</elcode> element), the name is 
                        resolved as if the <elcode>xsl:function-library</elcode> element were not present: see
                        <specref ref="resolving-function-names-without-function-library"/>.</p></item>
                  </olist>
                  <p>A function name used in the <code>name</code> attribute of an <elcode>xsl:function</elcode> declaration
                  must be prefixed, and is expanded using the rules above.</p>
                  <example>
                     <head>Example <code>xsl:function-library</code></head>
                     <p>The following example shows a function library that makes all the standard function namespaces
                     available:</p>
                     <eg><![CDATA[<xsl:function-library>
     <xsl:function-namespace prefix="fn" 
                             uri="http://www.w3.org/2005/xpath-functions"/> 
     <xsl:function-namespace prefix="math" 
                             uri="http://www.w3.org/2005/xpath-functions/math"/> 
     <xsl:function-namespace prefix="map" 
                             uri="http://www.w3.org/2005/xpath-functions/map"/>
     <xsl:function-namespace prefix="array" 
                             uri="http://www.w3.org/2005/xpath-functions/array"/>
     <xsl:function-namespace prefix="xs" 
                             uri="http://www.w3.org/2001/XMLSchema"/>
 </xsl:function-library>    
                        ]]></eg>
                     <p>Within a stylesheet module containing this declaration, functions from all these namespaces
                        can be referred to be local name alone, provided the local name and arity (in combination)
                        are unique. So it is possible to use <code>name()</code>
                     to refer to a function in the <code>fn</code> namespace, <code>sqrt($x)</code> to refer to a function
                     in the <code>math</code> namespace, and <code>integer($x)</code> to refer to a function in the
                     <code>xs</code> namespace. However, the function call <code>boolean($x)</code> would be an error,
                     because the reference is ambiguous: it could mean <code>fn:boolean($x)</code> or <code>xs:boolean($x)</code>.
                     To disambiguate the call, it is necessary to use the namespace prefix.</p>
                     
                     <p>It is not necessary, however, for the stylesheet to contain an XML namespace declaration that binds the
                     prefix; the binding in the <elcode>xsl:function-namespace</elcode> element suffices.</p>
                     
                     <p>An <elcode>xsl:function-library</elcode> element may include user-defined or vendor-defined function
                     namespaces as well as system-defined namespaces.</p>
                  </example>
                  <example>
                     <head>Excluding Selected Names</head>
                     <p>The following example modifies the above function library to exclude some functions 
                        that otherwise cause conflicts:</p>
                     <eg><![CDATA[<xsl:function-library>
     <xsl:function-namespace prefix="fn" 
                             uri="http://www.w3.org/2005/xpath-functions"/> 
     <xsl:function-namespace prefix="math" 
                             uri="http://www.w3.org/2005/xpath-functions/math"/> 
     <xsl:function-namespace prefix="map" 
                             uri="http://www.w3.org/2005/xpath-functions/map"
                             exclude="remove"/>
     <xsl:function-namespace prefix="array" 
                             uri="http://www.w3.org/2005/xpath-functions/array"
                             exclude="get put"/>
     <xsl:function-namespace prefix="xs" 
                             uri="http://www.w3.org/2001/XMLSchema"
                             exclude="boolean"/>
</xsl:function-library>    
                        ]]></eg>
                     <p>With the above declaration, it becomes possible to use the function call <code>remove($x, $n)</code>
                     to refer unambiguously to the <code>fn:remove</code> function, because the entry for the <code>map</code>
                     namespace explicitly excludes <code>map:remove</code>, which would otherwise cause an ambiguity.
                     Similarly, <code>boolean($x)</code> unambiguously refers to <code>fn:boolean</code>, and
                     <code>get($m, $k)</code> unambiguously refers to <code>map:get</code>.</p>
                     
                     <p>It would also be possible to write a stylesheet function <code>my:get</code> which calls
                     <code>map:get</code> or <code>array:get</code> as appropriate:</p>
                     <eg><![CDATA[<xsl:function name="my:get">
  <xsl:param name="target"/>
  <xsl:param name="key"/>
  <xsl:if test="$target instance of map(*)" 
          then="map:get($target, $key)"
          else="array:get($target, $key)"/>
</xsl:function>]]></eg>
                     <p>If the function library includes the <code>my</code> namespace, and if <code>map:get</code>
                        and <code>array:get</code> are excluded, then an unprefixed call on <code>get()</code> becomes possible.
                     A smart optimizer might even be able to decide at compile time which underlying function to call, if the type
                     of the first argument is known.</p>
                  </example>
                  <note>
                     <p>This construct has several motivating purposes:</p>
                     <ulist>
                        <item><p>Firstly, it improves code readability by reducing the need to qualify function names
                        with a namespace prefix when the local name is unambiguous. The expression <code>sin($x)+cos($y)</code>
                        is easier to read than <code>math:sin($x)+math:cos($y)</code>.</p></item>
                        <item><p>Secondly, it reduces the need to declare namespaces (using <code>xmlns:prefix="uri"</code>
                        declarations) that are needed only for the purpose of qualifying function names. This is useful
                        because a proliferation of such namespace declarations carries unwanted overheads. Even if the namespaces
                        are designated as <term>excluded namespaces</term> (see <specref ref="lre-namespaces"/>) they
                        still become part of the <xtermref spec="XP40" ref="dt-in-scope-namespaces"/> in the static context of every
                        XPath expression, which need to be carried around at run-time in a compiled stylesheet because they 
                        can be referenced at execution time (for example in a call of <xfunction>function-available</xfunction>)</p>
                        <p>Namespace bindings established using an <elcode>xsl:function-library</elcode> declaration impose less overhead
                        because they are used only when binding function names, and they are never needed at evaluation time.</p></item>
                        <item><p>Finally, stylesheet authors may consider that documenting the dependencies
                        of a stylesheet module makes the code more maintainable.</p></item>
                     </ulist>
                  </note>
                  <note>
                     <p>The rules take into account that new functions may be added to a namespace over time.
                     Adding a new function to one of the namespaces may introduce a conflict, but this conflict will always
                     result in a static error, it will never result in the wrong function being called. The conflict can
                     always be resolved by excluding the function that caused the conflict, thus limiting the scope of the changes needed
                     to handle this eventuality.</p>
                  </note>
                  <note>
                     <p>It is probably good practice for the <elcode>xsl:function-library</elcode> declaration to appear
                     near the start of a module, along with any <elcode>xsl:include</elcode> and <elcode>xsl:import</elcode>
                     declarations, but this is not a formal requirement. The declaration can appear anywhere in the module.</p>
                     
                     <p>Consider using XInclude, or DTD-defined entities, if you want to share an <elcode>xsl:function-library</elcode>
                     declaration between multiple modules.</p>
                  </note>
               </div4>
               
            </div3>
            
            <div3 id="additional-static-context">
               <head>Additional Static Context Components used by XSLT</head>
               <p>Some of the components of the XPath static context are used also by <termref def="dt-xslt-element">XSLT elements</termref>. For example, the
                     <elcode>xsl:sort</elcode> element makes use of the collations defined in the
                  static context, and attributes such as <code>type</code> and <code>as</code> may
                  reference types defined in the <termref def="dt-in-scope-schema-component">in-scope schema components</termref>.</p>
               <p>Many top-level declarations in a stylesheet, and attributes on the
                     <elcode>xsl:stylesheet</elcode> element, affect the behavior of instructions
                  within the stylesheet. Each of these constructs is described in its appropriate
                  place in this specification.</p>
               <p>A number of these constructs are of particular significance because they are used
                  by functions defined in XSLT, which are added to the library of functions
                  available for use in XPath expressions within the stylesheet. These are:</p>
               <ulist>
                  <item>
                     <p>The set of named keys, used by the <function>key</function> function</p>
                  </item>
                  
                  <item>
                     <p>The values of system properties, used by the
                           <function>system-property</function> function</p>
                  </item>
                  <item>
                     <p>The set of available instructions, used by the
                           <function>element-available</function> function</p>
                  </item>
               </ulist>
               <p>A dynamic function call clears the first of these
                  components: this means that a dynamic call to the <function>key</function>
                  function will always raise a dynamic error (the key name is unknown). The values
                  of system properties and the set of available instructions, by contrast, reflect
                  the capabilities and configuration of the processor rather than values specific to
                  the stylesheet code itself; the result of a dynamic call to
                     <function>system-property</function> or <function>element-available</function>
                  will reflect the information available to the processor at evaluation time.</p>
               <note>
                  <p>If these functions are called within a <termref def="dt-static-expression"/>, the results will reflect the capabilities and
                     configuration of the processor used to perform static analysis, while if they
                     are called elsewhere, the results should reflect the capabilities and
                     configuration of the processor used to perform dynamic evaluation, which might
                     give a different result. These calls should not be pre-evaluated at compile
                     time unless it is known that this will give the same result.</p>
               </note>
            </div3>
            <div3 id="xpath-dynamic-context">
               <head>Initializing the Dynamic Context</head>
               <p>For convenience, the dynamic context is described in two parts: the <termref def="dt-focus">focus</termref>, which represents the place in the source
                  document that is currently being processed, and a collection of additional context
                  variables.</p>
               <p>A number of functions specified in <bibref ref="xpath-functions-40"/> are defined
                  to be <xtermref spec="FO40" ref="dt-deterministic">deterministic</xtermref>,
                  meaning that if they are called twice during the same <xtermref spec="FO40" ref="execution-scope">execution scope</xtermref>, with the same arguments, then
                  they return the same results (see <xspecref spec="FO40" ref="terminology"/>). In
                  XSLT, the execution of a stylesheet defines the execution scope. This means, for
                  example, that if the function <xfunction>current-dateTime</xfunction> is called
                  repeatedly during a transformation, it produces the same result each time. By
                  implication, the components of the dynamic context on which these functions depend
                  are also stable for the duration of the transformation. Specifically, the
                  following components defined in <xspecref spec="XP40" ref="eval_context"/> must be
                  stable: <emph>function implementations</emph>, <emph>current dateTime</emph>,
                     <emph>implicit timezone</emph>, <emph>available documents</emph>,
                     <emph>available collections</emph>, and <emph>default collection</emph>. The
                  values of global variables and stylesheet parameters are also stable for the
                  duration of a transformation. The focus is <emph>not</emph> stable; the additional
                  dynamic context components defined in <specref ref="additional-dynamic-context"/>
                  are also <emph>not</emph> stable.</p>
               <p>As specified in <bibref ref="xpath-functions-40"/>, implementations may provide
                  user options that relax the requirement for the <xfunction>doc</xfunction> and
                     <xfunction>collection</xfunction> functions (and therefore, by implication, the
                     <function>document</function> function) to return stable results. By default,
                  however, the functions must be stable. The manner in which such user options are
                  provided, if at all, is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
               <imp-def-feature id="idf-api-stability">Implementations may provide user options that
                  relax the requirement for the <xfunction>doc</xfunction> and
                     <xfunction>collection</xfunction> functions (and therefore, by implication, the
                     <function>document</function> function) to return stable results. The manner in
                  which such user options are provided, if at all, is <termref def="dt-implementation-defined"/>. </imp-def-feature>
               <p>XPath expressions contained in <code>[xsl:]use-when</code> attributes are not
                  considered to be evaluated “during the transformation” as defined above. For
                  details see <specref ref="conditional-inclusion"/>.</p>

               <p><termdef id="dt-absent" term="absent">A component of the context
                     that has no value is said to be <term>absent</term>.</termdef> This is a
                  distinguishable state, and is not the same as having the empty sequence as its
                  value.</p>

               <div4 id="focus">
                  <head>Maintaining Position: the Focus</head>
                  <p>
                     <termdef id="dt-focus" term="focus">When a <termref def="dt-sequence-constructor">sequence constructor</termref> is
                        evaluated, the <termref def="dt-processor">processor</termref> keeps track
                        of which items are being processed by means of a set of implicit variables
                        referred to collectively as the <term>focus</term>.</termdef> More
                     specifically, the focus consists of the following three values:</p>
                  <ulist>
                     <item>
                        <p><termdef id="dt-context-item" term="context item">The <term>context
                                 item</term> is the item currently being processed. An item (see
                                 <bibref ref="xpath-datamodel-30"/>) is either an atomic value (such
                              as an integer, date, or string), a node, or
                                 a function item. It changes whenever instructions such as
                                 <elcode>xsl:apply-templates</elcode> and
                                 <elcode>xsl:for-each</elcode> are used to process a sequence of
                              items; each item in such a sequence becomes the context item while
                              that item is being processed.</termdef> The context item is returned
                           by the XPath <termref def="dt-expression">expression</termref>
                           <code>.</code> (dot).</p>
                     </item>
                     <item>
                        <p><termdef id="dt-context-position" term="context position">The
                                 <term>context position</term> is the position of the context item
                              within the sequence of items currently being processed. It changes
                              whenever the context item changes. When an instruction such as
                                 <elcode>xsl:apply-templates</elcode> or
                                 <elcode>xsl:for-each</elcode> is used to process a sequence of
                              items, the first item in the sequence is processed with a context
                              position of 1, the second item with a context position of 2, and so
                              on.</termdef> The context position is returned by the XPath <termref def="dt-expression">expression</termref>
                           <code>position()</code>.</p>
                     </item>
                     <item>
                        <p><termdef id="dt-context-size" term="context size">The <term>context
                                 size</term> is the number of items in the sequence of items
                              currently being processed. It changes whenever instructions such as
                                 <elcode>xsl:apply-templates</elcode> and
                                 <elcode>xsl:for-each</elcode> are used to process a sequence of
                              items; during the processing of each one of those items, the context
                              size is set to the count of the number of items in the sequence (or
                              equivalently, the position of the last item in the
                              sequence).</termdef> The context size is returned by the XPath
                              <termref def="dt-expression">expression</termref>
                           <code>last()</code>.</p>
                     </item>
                  </ulist>
                  <p>
                     <termdef id="dt-context-node" term="context node">If the <termref def="dt-context-item">context item</termref> is a node (as distinct from
                        an atomic value such as an integer), then it is also referred to as the
                           <term>context node</term>. The context node is not an independent
                        variable, it changes whenever the context item changes. When the context
                        item is an atomic value or a function
                           item, there is no context node.</termdef> The context node is
                     returned by the XPath <termref def="dt-expression">expression</termref>
                     <code>self::node()</code>, and it is used as the starting node for all relative
                     path expressions.</p>
                  <p>Where the containing element of an XPath expression is an <termref def="dt-instruction">instruction</termref> or a <termref def="dt-literal-result-element">literal result element</termref>, the
                     initial context item, context position, and context size for the XPath <termref def="dt-expression">expression</termref> are the same as the <termref def="dt-context-item">context item</termref>, <termref def="dt-context-position">context position</termref>, and <termref def="dt-context-size">context size</termref> for the evaluation of the
                     containing instruction or literal result element.</p>
                  <p>The context item for evaluating global
                        variables <phrase diff="add" at="A">declared</phrase>
                     in the <termref def="dt-top-level-package"/> is set to the <termref def="dt-global-context-item"/>
                        supplied when the transformation is invoked (see <specref ref="initiating"/>).
                     <phrase diff="add" at="A">For global variables declared in a </phrase> <termref def="dt-library-package">library
                           package</termref>, the context item <phrase diff="del" at="A">for evaluating global variables</phrase> is
                     <termref def="dt-absent"/>. <phrase diff="add" at="A">[XSLT 3.0 Erratum E7, bug 30179].</phrase></p>
                  <p>For an XPath expression contained in a <termref def="dt-value-template"/>, the initial context item, context position, and
                     context size for the XPath <termref def="dt-expression">expression</termref>
                     are the same as the <termref def="dt-context-item">context item</termref>,
                        <termref def="dt-context-position">context position</termref>, and <termref def="dt-context-size">context size</termref> for the evaluation of the
                     containing <termref def="dt-sequence-constructor"/>.</p>
                  <p>In other cases (for example, where the containing element is
                        <elcode>xsl:sort</elcode>, <elcode>xsl:with-param</elcode>, or
                        <elcode>xsl:key</elcode>), the rules are given in the specification of the
                     containing element.</p>
                  <p>The <function>current</function> function can be used within any XPath <termref def="dt-expression">expression</termref> to select the item that was
                     supplied as the context item to the XPath expression by the XSLT processor.
                     Unlike <code>.</code> (dot) this is unaffected by changes to the context item
                     that occur within the XPath expression. The <function>current</function>
                     function is described in <specref ref="func-current"/>.</p>
                  <p>On completion of an instruction that changes the <termref def="dt-focus">focus</termref> (such as <elcode>xsl:apply-templates</elcode> or
                        <elcode>xsl:for-each</elcode>), the focus reverts to its previous value.</p>
                  <p>When a <termref def="dt-stylesheet-function">stylesheet function</termref> is
                     called, the focus within the body of the function is initially <termref def="dt-absent">absent</termref>.</p>
                  <p>When the focus is <termref def="dt-absent">absent</termref>, evaluation of any
                        <termref def="dt-expression">expression</termref> that references the
                     context item, context position, or context size results in a <termref def="dt-dynamic-error">
                        dynamic error</termref>
                     <xerrorref spec="XP40" class="DY" code="0002"/></p>
                  <p>The description above gives an outline of the way the <termref def="dt-focus">focus</termref> works. Detailed rules for the effect of each instruction
                     are given separately with the description of that instruction. In the absence
                     of specific rules, an instruction uses the same focus as its parent
                     instruction. </p>
                  <p>
                     <termdef id="dt-singleton-focus" term="singleton focus">A <term>singleton
                           focus</term> based on an item <var>J</var> has the <termref def="dt-context-item">context item</termref> (and
                           therefore the <termref def="dt-context-node">context node</termref>, if
                              <var>J</var> is a node) set to <var>J</var>, and the <termref def="dt-context-position">context position</termref> and <termref def="dt-context-size">context size</termref> both set to 1
                        (one).</termdef>
                  </p>
               </div4>

               <div4 id="evaluation-context">
                  <head>Other Components of the XPath Dynamic Context</head>
                  <p>The previous section explained how the <termref def="dt-focus">focus</termref>
                     for an XPath expression appearing in an XSLT stylesheet is initialized. This
                     section explains how the other components of the <xtermref spec="XP40" ref="dt-dynamic-context">dynamic context</xtermref> of an XPath expression
                     are initialized.</p>
                  <ulist>
                     <item>
                        <p>The <xtermref spec="XP40" ref="dt-variable-values">dynamic
                              variables</xtermref> are the current values of the in-scope <termref def="dt-variable-binding-element">variable binding
                           elements</termref>.</p>
                     </item>
                     <item>
                        <p>The <xtermref spec="XP40" ref="dt-named-functions">named functions</xtermref>
                        (representing the functions accessible using <function>function-available</function> or <xfunction>function-lookup</xfunction>)
                           include all the functions available in the static context, and may also include an additional 
                           <termref def="dt-implementation-defined"/> set of functions that are available dynamically but not statically.
                        </p>
                        <note><p>This set therefore includes some functions that are not available for
                        dynamic calling using <elcode>xsl:evaluate</elcode>, for example <termref def="dt-stylesheet-function">stylesheet functions</termref>
                        whose visibility is private, and XSLT-defined functions such as <function>current</function> and <function>key</function>.</p></note>
                        <note><p>The rule that all functions present in the static context must always be present in 
                           the dynamic context is a consistency constraint. The effect of violating a consistency constraint is 
                           <termref def="dt-implementation-defined"/>: it does not necessarily lead to an error. 
                           For example, if the version of a used package that is available
                           at evaluation time does not include all public user-defined functions that were available in the version that was
                           used at analysis time, then a processor <rfc2119>may</rfc2119> recover by signaling an error only if the function
                           is actually called. Conversely, if the evaluation-time version of the package includes additional public functions, these <rfc2119>may</rfc2119>
                        be included in the dynamic context even though they were absent from the static context. 
                        Dynamic calling of functions using <xfunction>function-lookup</xfunction>
                        may therefore be an effective strategy for coping with variations between versions of a library package on which a stylesheet
                        depends.</p></note>
                     </item>
                     
                     <item>
                        <p>The <xtermref spec="XP40" ref="dt-known-docs">available
                              documents</xtermref> are defined as part of the XPath 3.0 dynamic context to support the
                              <xfunction>doc</xfunction> function, but this component is also
                           referenced by the similar XSLT <function>document</function> function:
                           see <specref ref="func-document"/>. This variable defines a mapping
                           between URIs passed to the <xfunction>doc</xfunction> or
                              <function>document</function> function and the document nodes that are
                           returned.</p>
                        <p>The mapping from URIs to document nodes is
                           affected by <elcode>xsl:strip-space</elcode> declarations and by the
                              <code>input-type-annotations</code> attribute, and may therefore vary
                           from one package to another.</p>
                        <note>
                           <p>Defining this as part of the evaluation context is a formal way of
                              specifying that the way in which URIs get turned into document nodes
                              is outside the control of the language specification, and depends
                              entirely on the run-time environment in which the transformation takes
                              place.</p>
                        </note>
                        <p>The XSLT-defined <function>document</function> function allows the use of
                           URI references containing fragment identifiers. The interpretation of a
                           fragment identifier depends on the media type of the resource
                           representation. Therefore, the information supplied in <xtermref spec="XP40" ref="dt-known-docs">available documents</xtermref> for
                           XSLT processing must provide not only a mapping from URIs to document
                           nodes as required by XPath, but also a mapping from URIs to media
                           types.</p>
                     </item>                    
                     <item>
                        <p>All other aspects of the dynamic context (for example,
                           the current date and time, the implicit timezone, the default language, calendar, and place,
                           the available documents, text resources, and collections, and the default collection<phrase diff="del" at="A"> — details
                           vary slightly between XPath 3.0 and XPath 3.1</phrase>) are <termref def="dt-implementation-defined"/>,
                        and do not change in the course of a single transformation, except to the extent that they
                        <rfc2119>may</rfc2119> be different from one <termref def="dt-package"/> to another.</p>
                     </item>
                  </ulist>
               </div4>
            </div3>
            <div3 id="additional-dynamic-context">
               <head>Additional Dynamic Context Components used by XSLT</head>
               <p>In addition to the values that make up the <termref def="dt-focus">focus</termref>, an XSLT processor maintains a number of other dynamic context
                  components that reflect aspects of the evaluation context. These components are
                  fully described in the sections of the specification that maintain and use them.
                  They are:</p>
               <ulist>
                  <item>
                     <p>The <termref def="dt-current-template-rule">current template rule</termref>,
                        which is the <termref def="dt-template-rule">template rule</termref> most
                        recently invoked by an <elcode>xsl:apply-templates</elcode>,
                           <elcode>xsl:apply-imports</elcode>, or <elcode>xsl:next-match</elcode>
                        instruction: see <specref ref="apply-imports"/>; </p>
                  </item>
                  <item>
                     <p>The <termref def="dt-current-mode">current mode</termref>, which is the
                           <termref def="dt-mode">mode</termref> set by the most recent call of
                           <elcode>xsl:apply-templates</elcode> (for a full definition see <specref ref="modes"/>);</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-current-group">current group</termref> and <termref def="dt-current-grouping-key">current grouping key</termref>, which
                        provide information about the collection of items currently being processed
                        by an <elcode>xsl:for-each-group</elcode>
                        
                        instruction: see <specref ref="func-current-group"/> and <specref ref="func-current-grouping-key"/>;</p>
                     <note>
                        <p>In XSLT 3.0 the initial value of these two properties is “absent”, which
                           means that any reference to their values causes a dynamic error.
                           Previously, the initial value was an empty sequence. </p>
                     </note>
                  </item>
                  <item>
                     <p>The <termref def="dt-current-merge-group"/> and <termref def="dt-current-merge-key"/>, which provide information about the
                        collection of items currently being processed by an
                           <elcode>xsl:merge</elcode> instruction.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-current-captured-substrings">current captured
                           substrings</termref>: this is a sequence of strings, which is maintained
                        when a string is matched against a regular expression using the
                           <elcode>xsl:analyze-string</elcode> instruction, and which is accessible
                        using the <function>regex-group</function> function: see <specref ref="func-regex-group"/>.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-output-state">output state</termref>: this is a flag
                        whose two possible values are <termref def="dt-final-output-state">final
                           output state</termref> and <termref def="dt-temporary-output-state">temporary output state</termref>.  The initial setting when the stylesheet is invoked by executing a
                           template is <termref def="dt-final-output-state">final output
                           state</termref>, and it is switched to <termref def="dt-temporary-output-state">temporary output state</termref> by
                        instructions such as <elcode>xsl:variable</elcode>. For more details, see
                           <specref ref="result-document-restrictions"/>.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-current-output-uri">current output URI</termref>: this
                        is the URI associated with the result tree to which instructions are
                        currently writing. The current output URI is initially the same as the
                           <termref def="dt-base-output-uri"/>. During the evaluation of an
                           <elcode>xsl:result-document</elcode> instruction, the current output URI
                        is set to the absolute URI identified by the <code>href</code> attribute of
                        that instruction.</p>
                  </item>

               </ulist>
               <p>The following non-normative table summarizes the initial state of each of the
                  components in the evaluation context, and the instructions which cause the state
                  of the component to change.</p>



               <table class="data">
                  <caption>Components of the Dynamic Evaluation Context</caption>
                  <thead>
                     <tr>
                        <th align="left" rowspan="1" colspan="1">Component</th>
                        <th align="left" rowspan="1" colspan="1">Initial Setting</th>
                        <th align="left" rowspan="1" colspan="1">Set by</th>
                        <th align="left" rowspan="1" colspan="1">Cleared by</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-focus">focus</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="initiating"/>.</td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:for-each</elcode>,
                              <elcode>xsl:for-each-group</elcode>,
                              <elcode>xsl:analyze-string</elcode>, evaluation of <termref def="dt-pattern">patterns</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">Calls to <termref def="dt-stylesheet-function">stylesheet
                              functions</termref>
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-template-rule">current template rule</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">If apply-templates invocation is used
                           (see <specref ref="invoking-initial-mode"/>), then for each item in the 
                           <termref def="dt-initial-match-selection"/>, the <termref def="dt-current-template-rule"/>
                           is initially set to the template rule chosen for processing that item. Otherwise,
                           <termref def="dt-absent"/>.
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
                              <elcode>xsl:next-match</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="apply-imports"/>.
                           <!--<elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>,
                              <elcode>xsl:analyze-string</elcode>, 
                           <elcode>xsl:iterate</elcode>, <elcode>xsl:source-document</elcode>,
                                 <elcode>xsl:merge</elcode>, <elcode>xsl:evaluate</elcode>;
                           <phrase diff="chg" at="T-bug29716"><elcode>xsl:copy</elcode> if there
                           is a <code>select</code> attribute</phrase>; <elcode>xsl:call-template</elcode>
                           if the relevant named template has <code>xsl:context-item use="absent"</code>;
                            <phrase diff="chg" at="Q-bug23631">calls to <termref
                                 def="dt-stylesheet-function">stylesheet functions</termref>; and
                              dynamic function calls</phrase>. Also cleared while evaluating global
                           variables or default values of stylesheet parameters, <phrase diff="add"
                              at="M"><termref def="dt-pattern">patterns</termref></phrase>, and the
                           sequence constructors contained in <elcode>xsl:key</elcode> and
                              <elcode>xsl:sort</elcode>.--></td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-mode">current mode</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">the initial <termref def="dt-mode">mode</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:apply-templates</elcode>
                        </td>
                        <!--Text replaced by erratum E19 change 1"-->
                        <td valign="top" rowspan="1" colspan="1">Calls to <termref def="dt-stylesheet-function">stylesheet
                              functions</termref>. Also cleared while evaluating global
                           variables and stylesheet parameters, <termref def="dt-pattern">patterns</termref>, and the sequence
                           constructor contained in <elcode>xsl:key</elcode> or
                              <elcode>xsl:sort</elcode>. Clearing the current mode causes the
                           current mode to be set to the default (unnamed) mode.</td>
                        <!--End of text replaced by erratum E19-->
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-group">current group</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">absent</td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:for-each-group</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="func-current-group"/>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-grouping-key">current grouping key</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">absent</td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:for-each-group</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="func-current-grouping-key"/>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-merge-group">current merge group</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">absent</td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:merge</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="func-current-merge-group"/>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-merge-key">current merge key</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1"><phrase>absent</phrase></td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:merge</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="func-current-merge-key"/>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-captured-substrings">current captured
                              substrings</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">empty sequence</td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:matching-substring</elcode>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <elcode>xsl:non-matching-substring</elcode>; Calls to <termref def="dt-stylesheet-function">stylesheet functions</termref>, dynamic function calls,
                              evaluation of global variables, stylesheet
                              parameters, and <termref def="dt-pattern">patterns</termref>
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-output-state">output state</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-final-output-state">final output state</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">Set to <termref def="dt-temporary-output-state">temporary
                              output state</termref> by instructions such as
                              <elcode>xsl:variable</elcode>, <elcode>xsl:attribute</elcode>, etc.,
                           and by calls on <termref def="dt-stylesheet-function">stylesheet
                              functions</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">None</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-current-output-uri">current output URI</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">
                           <termref def="dt-base-output-uri">base output URI</termref>
                        </td>
                        <td valign="top" rowspan="1" colspan="1"><elcode>xsl:result-document</elcode></td>
                        <td valign="top" rowspan="1" colspan="1">Calls to <termref def="dt-stylesheet-function">stylesheet
                              functions</termref>, dynamic function calls, evaluation of <termref def="dt-global-variable">global variables</termref>, <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, and
                              <termref def="dt-pattern">patterns</termref>.</td>

                     </tr>

                  </tbody>
               </table>
               <p><termdef id="dt-initial-setting" term="initial setting">The <term>initial setting</term> of a component of the dynamic context is used
                     when evaluating <termref def="dt-global-variable">global variables</termref>
                     and <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>,
                     when evaluating the <code>use</code> and <code>match</code> attributes of
                        <elcode>xsl:key</elcode>, and when evaluating the <code>initial-value</code> of
                        <elcode>xsl:accumulator</elcode> and the <code>select</code> expressions or
                     contained sequence constructors of
                     <elcode>xsl:accumulator-rule</elcode></termdef>.</p>
               <p><termdef id="dt-non-contextual-function-call" term="non-contextual function call">The term <term>non-contextual function
                        call</term> is used to refer to function calls that do not pass the dynamic
                     context to the called function. This includes all calls on <termref def="dt-stylesheet-function">stylesheet functions</termref> and all
                        <xtermref spec="XP40" ref="dt-dynamic-function-invocation">dynamic function
                        invocations</xtermref>, (that is calls to function items as permitted by
                     XPath 3.0). It excludes calls to some
                        functions in the namespace
                           <code>http://www.w3.org/2005/xpath-functions</code>, in
                     particular those that explicitly depend on the context, such as the
                        <function>current-group</function> and <function>regex-group</function>
                     functions. It is <termref def="dt-implementation-defined">implementation-defined</termref> whether, and under what circumstances,
                     calls to <termref def="dt-extension-function">extension functions</termref> are
                     non-contextual.</termdef></p>
               <imp-def-feature id="id-ext-accesstoconttext">The availability of dynamic context
                  information within <termref def="dt-extension-function">extension
                     functions</termref> is <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature>

               <p>Named function references (such as <code>position#0</code>) and
                  calls on <xfunction>function-lookup</xfunction> (for example,
                     <code>function-lookup("position", 0)</code>) are defined to retain the XPath
                  static and dynamic context at the point of invocation as part of the closure of
                  the resulting function item, and to use this preserved context when a dynamic
                  function call is subsequently made using the function item. This rule does not
                  extend to the XSLT extensions to the dynamic context defined in this section. If a
                  dynamic function call is made that depends on the XSLT part of the dynamic context
                  (for example, <code>regex-group#1(2)</code>), then the relevant components of the
                  context are cleared as described in the table above. </p>
               
            </div3>
         </div2>

         

         <div2 id="patterns">
            <head>Patterns</head>

            <p>In XSLT 4.0, patterns can match any kind of item: atomic values and
               function items as well as nodes.</p>

            <p>A <termref def="dt-template-rule">template rule</termref> identifies the items to which it applies by means of a pattern. As
               well as being used in template rules, patterns are used for numbering (see <specref ref="number"/>), for grouping (see <specref ref="grouping"/>), and for declaring
                  <termref def="dt-key">keys</termref> (see <specref ref="key"/>).</p>
            <p><termdef id="dt-pattern" term="pattern">A <term>pattern</term> specifies a set of
                  conditions on an item. An item that satisfies the conditions matches the pattern; an
                     item that does not satisfy the conditions
                  does not match the pattern.</termdef></p>

            <p diff="chg" at="A">There are three kinds of pattern: <termref def="dt-predicate-pattern">predicate patterns</termref>, 
               <termref def="dt-type-pattern">type patterns</termref>,
               and <termref def="dt-node-pattern">node patterns</termref>:</p>

            <ulist diff="chg" at="A">
               <item>
                  <p><termdef id="dt-predicate-pattern" term="predicate pattern">A <term>predicate pattern</term> is written as
                           <code>.</code> (dot) followed by zero or more predicates in square
                        brackets, and it matches any item for which each of the predicates evaluates
                        to <code>true</code>.</termdef></p>
                  <p>A predicate pattern <code>.[P1][P2]...</code> can be regarded as an abbreviation
                     for the type pattern <code>type(item())[P1][P2]...</code>.</p>
               </item>
               <item>
                  <p><termdef id="dt-type-pattern" term="type pattern">A <term>type pattern</term> can be written as
                     <code>type(T)</code> (where <var>T</var> is an <xnt spec="XP40" ref="nt-ItemType">ItemType</xnt>
                     followed by zero or more predicates in square
                     brackets, and it matches any item of type <var>T</var> which each of the predicates evaluates
                     to <code>true</code>.</termdef></p>
                  <p>For convenience, if <var>T</var> takes the form <code>record(F1, F2, ...)</code>, then the pattern can be abbrevated.</p>
                  <p>The detailed semantics are given in <specref ref="pattern-semantics"/>. This construct can be used to match items of any
                     kind (nodes, atomic values, and function items). For example, the pattern
                     <code>.[starts-with(., '$')]</code> matches any string that starts with the
                     character "$", or a node whose atomized value starts with "$". This example
                     shows a predicate pattern with a single predicate, but the grammar allows any
                     number of predicates (zero or more).</p>
               </item>
               <item>
                  <p><termdef id="dt-node-pattern" term="node pattern">A <term>node pattern</term> uses a subset of
                        the syntax for path expressions, and is defined to match a node if the
                        corresponding path expression would select the node. Node patterns may
                        also be formed by combining other patterns using union, intersection, and
                        difference operators.</termdef></p>
                  <p>The syntax for node patterns
                        (<code>UnionExprP</code> in the grammar:
                        see <specref ref="pattern-syntax"/>) is a subset of the syntax for
                        <termref def="dt-expression">expressions</termref>. Node patterns are
                        used only for matching nodes; an item other than a node will never match a
                           node pattern.
                     As explained in detail below, a node matches a node pattern if the node can be selected by
                     deriving an equivalent expression, and evaluating this expression with respect
                     to some possible context.</p>
               </item>
            </ulist>





            




            <note>
               <p>The specification uses the phrases <emph>an item matches a pattern</emph> and
                     <emph>a pattern matches an item</emph> interchangeably. They are equivalent: an
                  item matches a pattern if and only if the pattern matches the item.</p>
            </note>
            <div3 id="pattern-examples">
               <head>Examples of Patterns</head>
               <example id="pattern-examples-1">
                  <head>Patterns</head>
                  <p>Here are some examples of patterns:</p>
                  <ulist>
                     <item>
                        <p><emph>Predicate Patterns:</emph></p>
                        <olist>
                           <item>
                              <p><code>.</code> matches any item.</p>
                           </item>
                           <item>
                              <p><code>.[. castable as xs:date]</code> matches any item
                                 that can be successfully cast to <code>xs:date</code>: for example,
                              an <code>xs:date</code> or <code>xs:dateTime</code> value, or a string
                              in the lexical form of a date, or a node whose typed value is an <code>xs:date</code>
                              or a string in the form of a date.</p>
                           </item>
                           <item>
                              <p><code>.[string() => matches('^[0-9]$')]</code> matches any
                                 item whose string value is a sequence of digits.</p>
                           </item>
                           <item>
                              <p><code>.[. castable as xs:date][xs:date(.) le current-date()]</code> matches any
                                 item that is castable to <code>xs:date</code> provided that the result of casting
                                 the value to <code>xs:date</code> is a date in the past.</p>
                           </item>
                        </olist>
                     </item>
                     <item diff="add" at="A">
                        <p><emph>Type Patterns</emph></p>
                        <olist>
                           <item>
                              <p><code>type(item())</code> matches any item.</p>
                           </item>
                           <item>
                              <p><code>type(node())</code> matches any node.
                                 (Note the distinction from the pattern <code>node()</code>.)</p>
                           </item>
                           <item>
                              <p><code>type(xs:date)</code> matches any
                                 atomic value of type <code>xs:date</code> (or a type derived by
                                 restriction from <code>xs:date</code>).</p>
                           </item>
                           <item>
                              <p><code>type(xs:date)[. gt current-date()]</code> matches any date in
                                 the future.</p>
                           </item>
                           <item>
                              <p><code>type(xs:string)[starts-with(., 'e')]</code> matches any <code>xs:string</code>
                                 value that starts with the letter 'e'. Note there is no type conversion; the pattern
                              will not match an <code>xs:untypedAtomic</code> or <code>xs:anyURI</code> value,
                              nor will it match any node.</p>
                           </item>
                           <item>
                              <p><code>type(function(*))</code> matches any
                                 function item.</p>
                           </item>
                           <item>
                              <p><code>type(function($x as xs:integer) as xs:boolean)[.(42)]</code> matches any function that
                                 accepts an <code>xs:integer</code> argument and returns a boolean result, provided
                                 that the result of calling the function with the argument value <code>42</code> is true.</p>
                           </item>
                           <item>
                              <p><code>union(xs:date, xs:dateTime, xs:time)</code> matches any atomic value
                                 that is an instance of <code>xs:date</code>, <code>xs:dateTime</code>, or <code>xs:time</code>.</p>
                           </item>
                           <item>
                              <p><code>enum("red", "green", "blue")</code> matches any one of the three strings
                                 <code>"red"</code>, <code>"green"</code>, or <code>"blue"</code>.</p>
                           </item>
                           <item>
                              <p><code>record(first, last, *)[?location = 'UK']</code> matches any map whose keys include the strings <code>"first"</code>
                                 and <code>"last"</code>, and that also has an entry with key <code>"location"</code> whose
                              value is <code>"UK"</code>.</p>
                           </item>
                           <item>
                              <p><code>record(longitude, latitude)</code> matches any map with two entries whose keys are the strings <code>"longitude"</code>
                                 and <code>"latitude"</code>.</p>
                           </item>
                           <item>
                              <p><code>array(xs:integer)[array:size(.) eq 4]</code> matches any array of four integers.</p>
                           </item>
                           <item>
                              <p><code>array(record(first, last, *))</code> matches any array of maps where each map
                                 contains entries with keys <code>"first"</code> and <code>"last"</code>. (Note that
                              this includes the empty array).</p>
                           </item>
                           <item>
                              <p><code>array(record(first, last, *))[array:size(.) gt 0]</code> matches any non-empty array of maps where each map
                                 contains entries with keys <code>"first"</code> and <code>"last"</code>. </p>
                           </item>
                           <item>
                              <p><code>type(complex)</code> matches any value that is an instance of the item type declared in an <elcode>xsl:item-type</elcode>
                                 declaration with name <code>"complex"</code></p>
                           </item>
                           <item>
                              <p><code>type(complex)[?i eq 0]</code> matches any value that is an instance of the item type declared in an <elcode>xsl:item-type</elcode>
                                 declaration with name <code>"complex"</code> and that is a map with an entry having key "i" and value zero.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p><emph>Node Patterns</emph></p>
                        <olist><item>
                           <p><code>*</code> matches any element.</p>
                        </item>
                        <item>
                           <p><code>para</code> matches any <code>para</code> element.</p>
                        </item>
                        <item>
                           <p><code>chapter|appendix</code> matches any <code>chapter</code> element
                              and any <code>appendix</code> element.</p>
                        </item>
                        <item>
                           <p><code>olist/entry</code> matches any <code>entry</code> element with an
                              <code>olist</code> parent.</p>
                        </item>
                        <item>
                           <p><code>appendix//para</code> matches any <code>para</code> element with an
                              <code>appendix</code> ancestor element.</p>
                        </item>
                        <item>
                           <p><code>schema-element(us:address)</code> matches any element that is
                              annotated as an instance of the type defined by the schema element
                              declaration <code>us:address</code>, and whose name is either
                              <code>us:address</code> or the name of another element in its
                              substitution group. </p>
                        </item>
                        <item>
                           <p><code>attribute(*, xs:date)</code> matches any attribute annotated as
                              being of type <code>xs:date</code>.</p>
                        </item>
                        <item>
                           <p><code>/</code> matches a document node.</p>
                        </item>
                        <item>
                           <p><code>document-node()</code> matches a document node.</p>
                        </item>
                        <item>
                           <p><code>document-node(schema-element(my:invoice))</code> matches the
                              document node of a document whose document element is named
                              <code>my:invoice</code> and matches the type defined by the global
                              element declaration <code>my:invoice</code>.</p>
                        </item>
                        <item>
                           <p><code>text()</code> matches any text node.</p>
                        </item>
                        <item>
                           <p><code>namespace-node()</code> matches any namespace
                              node.</p>
                        </item>
                        <item>
                           <p><code>node()</code> matches any node other than an attribute node,
                              namespace node, or document node.</p>
                        </item>
                        <item>
                           <p><code>id("W33")</code> matches the element with unique ID
                              <code>W33</code>. </p>
                        </item>
                        <item>
                           <p><code>para[1]</code> matches any <code>para</code> element that is the
                              first <code>para</code> child element of its parent. It also matches a
                              parentless <code>para</code> element.</p>
                        </item>
                        <item>
                           <p><code>//para</code> matches any <code>para</code> element in a tree that is rooted at a document node.</p>
                        </item>
                        <item>
                           <p><code>bullet[position() mod 2 = 0]</code> matches any <code>bullet</code>
                              element that is an even-numbered <code>bullet</code> child of its
                              parent.</p>
                        </item>
                        <item>
                           <p><code>div[@class="appendix"]//p</code> matches any <code>p</code> element
                              with a <code>div</code> ancestor element that has a <code>class</code>
                              attribute with value <code>appendix</code>. </p>
                        </item>
                        <item>
                           <p><code>@class</code> matches any <code>class</code> attribute
                              (<emph>not</emph> any element that has a <code>class</code>
                              attribute).</p>
                        </item>
                        <item>
                           <p><code>@*</code> matches any attribute node.</p>
                        </item>
                        <item>
                           <p><code>$xyz</code> matches any node that is present in
                              the value of the variable <code>$xyz</code>.</p>
                        </item>
                        <item>
                           <p><code>$xyz//*</code> matches any element that is a
                              descendant of a node that is present in the value of the variable
                              <code>$xyz</code>.</p>
                        </item>
                        <item>
                           <p><code>doc('product.xml')//*</code> matches any element
                              within the document whose document URI is 'product.xml'.</p>
                        </item>
                    </olist>
                 </item>
                  </ulist>       
                  
               </example>
            </div3>
            <div3 id="pattern-syntax">
               <head>Syntax of Patterns</head>
               <p>
                  <error spec="XT" type="static" class="SE" code="0340">
                     <p>Where an attribute is defined to contain a <termref def="dt-pattern">pattern</termref>, it is a <termref def="dt-static-error">static
                           error</termref> if the pattern does not match the production <nt def="Pattern40">Pattern40</nt>.</p>
                  </error></p>
               <p>The grammar for patterns uses the notation defined in <xspecref spec="XP40" ref="EBNFNotation">Notation</xspecref>. </p>
               <p>The lexical rules for patterns are the same as the lexical rules
                  for XPath expressions, as defined in <xspecref spec="XP40" ref="lexical-structure">Lexical structure</xspecref>. Comments are permitted between tokens, using the
                  syntax <code>(: ... :)</code>. All other provisions of the XPath grammar apply
                  where relevant, for example the rules for whitespace handling and
                  extra-grammatical constraints.</p>
               
               <scrap headstyle="show" id="Patterns-scrap" diff="add" at="A">
                  <head></head>
                  
                  <prodrecap ref="Pattern40" id="Pattern40"/>
                  <prodrecap ref="PredicatePattern" id="PredicatePattern"/>
                  <prodrecap ref="TypePattern" id="TypePattern"/>
                  <prodrecap ref="NodePattern" id="NodePattern"/>
               </scrap>
               
               <p diff="add" at="A">Patterns fall into three groups:</p>
               
               <ulist diff="add" at="A">
                  <item><p>A <code>PredicatePattern</code> matches items according to conditions that the item must
                  satisfy: for example <code>.[. castable as xs:integer]</code> matches any value (it might
                  be an atomic value, a node, or an array) that is castable as an integer.</p></item>
                  <item><p>A <code>TypePattern</code> matches items according to their type. For example
                  <code>type(xs:integer)</code> matches an atomic value that is an instance of <code>xs:integer</code>,
                  while <code>record(longitude, latitude)</code> matches a map that has exactly two entries, with
                  keys <code>"longitude"</code> and <code>"latitude"</code></p></item>
                  <item><p>A <code>NodePattern</code> matches nodes in a tree, typically by specifying a path that
                  can be used to locate the nodes: for example <code>order</code> matches an element node
                  named <code>order</code>, while <code>billing-address/city</code> matches an element named <code>city</code>
                  whose parent node is an element named <code>billing-address</code>.</p></item>
               </ulist>
               
               <p diff="add" at="A">The following sections define the rules for each of these groups.</p>
               
               <div4 id="predicate-patterns">
                  <head>Predicate Patterns</head>
                  
                  <scrap headstyle="show" id="PredicatePatterns-scrap">
                     <head></head>
                     <prodrecap ref="PredicatePattern"/>
                     <prodrecap ref="PredicateList" id="PredicateList"/>
                  </scrap>
                  
                  <p>A <nt def="PredicatePattern">PredicatePattern</nt>
                     <var>PP</var> matches an item <var>J</var> if and only if the XPath expression taking
                     the same form as <var>PP</var> returns a non-empty sequence when evaluated with a
                     <termref def="dt-singleton-focus"/> based on <var>J</var>.</p>
                  
                  
                  
                  <note>
                     <p>The pattern <code>.</code>, which is a <code>PredicatePattern</code> with an
                        empty <xnt spec="XP40" ref="prod-xpath40-PredicateList">PredicateList</xnt>,
                        matches every item.</p>
                     <p>A predicate with the numeric value 1 (one) always matches, and a predicate with
                        any other numeric value never matches. Numeric predicates in a
                        <code>PredicatePattern</code> are therefore not useful, but are defined this
                        way in the interests of consistency with XPath.</p>
                  </note>
                  
                  <p diff="add" at="A">For example, the pattern <code>.[contains(., "XSLT")]</code>
                  matches any item whose typed value contains <code>"XSLT"</code> as a substring. 
                  It matches values such as the string "XSLT Transformations", the <code>xs:anyURI</code> value
                     <code>http://www.w3.org/TR/XSLT</code>, the attribute node 
                     <code>class="XSD XSLT XPath"</code>, and the singleton array <code>["XSLT 4.0"]</code>.</p>
                  
               </div4>
               
               <div4 id="type-patterns" diff="add" at="A">
                  <head>Type Patterns</head>
                  
                  <scrap headstyle="show" id="TypePatterns-scrap">
                     <head></head>
                     <prodrecap ref="TypePattern"/>
                     <prodrecap ref="WrappedItemTest" id="WrappedItemTest"/>
                     <prodrecap ref="AnyItemTest" id="AnyItemTest"/>
                     <prodrecap ref="FunctionTest" id="FunctionTest"/>
                     <prodrecap ref="MapTest" id="MapTest"/>
                     <prodrecap ref="ArrayTest" id="ArrayTest"/>
                     <prodrecap ref="RecordTest" id="RecordTest"/>
                     <prodrecap ref="EnumerationType" id="EnumerationType"/>
                     <prodrecap ref="NamedItemType" id="NamedItemType"/>
                     <prodrecap ref="PredicateList"/>
                  </scrap>
                  
      
                  
                  <p>A type pattern tests whether an item matches a given item type, optionally qualified
                  with one or more predicates that the value must also satisfy.</p>
                  
                  <p>The general-purpose construct <code>type(ItemType)</code> allows any <code>ItemType</code>
                  to be used in a pattern. Where syntactic constraints permit, many <code>ItemTypes</code> can 
                     also be used directly: for example
                  <code>type(item())</code> can be abbreviated as <code>item()</code>.</p>
                  <p>For example:</p>
                  <ulist>
                     <item><p><code>type(integer)</code> matches any instance of
                        <code>xs:integer</code></p></item>
                     <item><p><code>type(integer)[. gt 0]</code> matches
                        any positive integer.</p></item>
                     <item><p><code>type(union(string, untypedAtomic))[matches(., '[0-9]+')]</code> matches
                        any instance of <code>xs:string</code> or <code>xs:untypedAtomic</code> that
                        contains a sequence of decimal digits.</p></item>
                     <item><p><code>type(node())</code> matches any node. (This is not the same as the pattern
                        <code>node()</code>, which for historical reasons only matches  element, text, comment, 
                        and processing instruction nodes).</p></item>
                  </ulist>
                  <note><p>The above examples assume the declaration 
                     <code>default-type-namespace="http://www.w3.org/2001/XMLSchema"</code>.</p></note>
                  
                  <p>More formally, an item <var>$J</var> matches a pattern <code>type(T)[P1][P2][P3]</code> if
                  the XPath expression <code>$J instance of T and exists($J[P1][P2]P3])</code> is true.</p>
                  
                  <note><p>As with predicate patterns, numeric predicates are allowed, but serve no useful purpose.</p></note>
                  
                  
                  
                  <p>A pattern written as <code>record(A, B, C)</code> is an abbreviation for <code>type(record(A, B, C))</code>
                     (retaining any predicates). For example, the pattern <code>record(first, last, *)[?first eq "Sharon"]</code>
                  matches any map having entries with the string-valued keys <code>"first"</code> and <code>"last"</code>,
                     where the entry for the key <code>"first"</code> is equal to the string <code>"Sharon"</code>.</p>
                  
                  <note>
                     <p>The item type in a pattern can be any <code>ItemType</code>, but patterns that match
                        nodes can usually be expressed more economically
                        as a <code>NodeTest</code>: for example <code>match="type(element(PERSON))"</code> has the same meaning as
                        <code>match="element(PERSON)"</code>, which in turn is usually abbreviated to <code>match="PERSON"</code>.</p>
                  </note>
                  
               </div4>
               
               <div4 id="node-patterns">
                  <head>Node Patterns</head>
               

               <scrap id="NodePatterns-scrap">
                  <head></head>

                  <prodrecap ref="NodePattern"/>
                  <prodrecap ref="UnionExprP" id="UnionExprP"/>
                  <prodrecap ref="IntersectExceptExprP" id="IntersectExceptExprP"/>
                  <prodrecap ref="PathExprP" id="PathExprP"/>
                  <prodrecap ref="RootedPath" id="RootedPath"/>
                  <prodrecap ref="FunctionCallP" id="FunctionCallP"/>
                  <prodrecap ref="OuterFunctionName" id="OuterFunctionName"/>
                  <prodrecap ref="ArgumentListP" id="ArgumentListP"/>
                  <prodrecap ref="ArgumentP" id="ArgumentP"/>
                  <prodrecap ref="RelativePathExprP" id="RelativePathExprP"/>
                  <prodrecap ref="StepExprP" id="StepExprP"/>
                  <prodrecap ref="PostfixExprP" id="PostfixExprP"/>
                  <prodrecap ref="ParenthesizedExprP" id="ParenthesizedExprP"/>
                  <prodrecap ref="AxisStepP" id="AxisStepP"/>
                  <prodrecap ref="ForwardStepP" id="ForwardStepP"/>
                  <prodrecap ref="ForwardAxisP" id="ForwardAxisP"/>


               </scrap>
               
               <p>Node Patterns are used to match XDM nodes.</p>

               <p>The names of these constructs are chosen to align with the XPath 3.0 grammar.
                  Constructs whose names are suffixed with <code>P</code> are restricted forms of
                  the corresponding XPath 3.0 construct without the suffix. Constructs labeled with
                  the suffix “XP40” are defined in <bibref ref="xpath-40"/>.</p>

               <p diff="del" at="A">Where the XSLT 3.0 processor implements the XPath 3.1 feature, the definitions that apply to constructs labeled
                  with the suffix “XP30” are those in [XPath 3.1]</p>


               <p>In a <nt def="FunctionCallP">FunctionCallP</nt>, the
                     <code>EQName</code> used for the function name must have local part
                     <code>doc</code>, <code>id</code>, <code>element-with-id</code>,
                     <code>key</code>, or
                     <code>root</code>, and must use the <termref def="dt-standard-function-namespace"/> either explicitly or implicitly.</p>

               <p>In the case of a call to the
                     <xfunction>root</xfunction> function, the argument list must be empty: that is,
                  only the zero-arity form of the function is allowed.</p>

               <note>
                  <p>As with XPath expressions, the pattern <code>/ union /*</code> can be parsed in
                     two different ways, and the chosen interpretation is to treat
                        <code>union</code> as an element name rather than as an operator. The other
                     interpretation can be achieved by writing <code>(/) union (/*)</code></p>
               </note>
                  <note diff="add" at="E">
                     <p>A peculiarity of this grammar is that <code>doc('a.xml')/(id('abc'))</code> is a 
                        valid pattern, while <code>doc('a.xml')/id('abc')</code> is not: the <code>/</code> 
                        operator must be followed either by a parenthesized expression, or by an axis step.</p>
                  </note>
            </div4>
            <div4 id="pattern-semantics">
               <head>The Meaning of a Node Pattern</head>
               <p>The meaning of a node pattern is defined formally as follows, where “if” is to be read
                  as “if and only if”.</p>

               
  

               <p>The pattern is converted to an <termref def="dt-expression">expression</termref>, called the <term>equivalent expression</term>. The
                  equivalent expression to a <nt def="Pattern40">Pattern</nt> is the XPath
                  expression that takes the same lexical form as the <code>Pattern</code> as
                  written, with the following adjustment:</p>
               <ulist>
                  
                  <item>
                     <p>If any <code>PathExprP</code> in the
                              <code>Pattern</code> is a <code>RelativePathExprP</code>, then the
                           first <code>StepExprP</code>
                           <var>PS</var> of this <code>RelativePathExprP</code> is adjusted
                        to allow it to match a parentless element, attribute, or namespace node. The
                        adjustment depends on the axis used in this step, whether it appears
                        explicitly or implicitly (according to the rules of <xspecref spec="XP40" ref="abbrev"/>), and is made as follows:</p>
                     <olist>
                        <item>
                           <p>If the <code>NodeTest</code> in <var>PS</var> is
                                 <code>document-node()</code> (optionally with arguments), and if no
                              explicit axis is specified, then the axis in step <var>PS</var> is
                              taken as <code>self</code> rather than <code>child</code>.</p>
                        </item>
                        <item>
                           <p>If <var>PS</var> uses the child axis (explicitly or implicitly), and
                              if the <code>NodeTest</code> in <var>PS</var> is not
                                 <code>document-node()</code> (optionally with arguments), then the
                              axis in step <var>PS</var> is replaced by <code>child-or-top</code>,
                              which is defined as follows. If the context node is a parentless
                              element, comment, processing-instruction, or text node then the
                                 <code>child-or-top</code> axis selects the context node; otherwise
                              it selects the children of the context node. It is a forwards axis
                              whose principal node kind is element.</p>
                        </item>
                        <item>
                           <p>If <var>PS</var> uses the attribute axis (explicitly or implicitly),
                              then the axis in step <var>PS</var> is replaced by
                                 <code>attribute-or-top</code>, which is defined as follows. If the
                              context node is an attribute node with no parent, then the
                                 <code>attribute-or-top</code> axis selects the context node;
                              otherwise it selects the attributes of the context node. It is a
                              forwards axis whose principal node kind is attribute.</p>
                        </item>
                        <item>
                           <p>If <var>PS</var> uses the namespace axis (explicitly or implicitly), then the axis in step
                                 <var>PS</var> is replaced by <code>namespace-or-top</code>, which
                              is defined as follows. If the context node is a namespace node with no
                              parent, then the <code>namespace-or-top</code> axis selects the
                              context node; otherwise it selects the namespace nodes of the context
                              node. It is a forwards axis whose principal node kind is
                              namespace.</p>

                        </item>
                     </olist>
                     <p>The axes <code>child-or-top</code>, <code>attribute-or-top</code>, and
                           <code>namespace-or-top</code> are introduced only for definitional
                        purposes. They cannot be used explicitly in a user-written pattern or
                        expression.</p>
                     <note>
                        <p>The purpose of this adjustment is to ensure that a pattern such as
                              <code>person</code> matches any element named <code>person</code>,
                           even if it has no parent; and similarly, that the pattern
                              <code>@width</code> matches any attribute named <code>width</code>,
                           even a parentless attribute. The rule also ensures that a pattern using a
                              <code>NodeTest</code> of the form <code>document-node(...)</code>
                           matches a document node. The pattern <code>node()</code> will match any
                           element, text node, comment, or processing instruction, whether or not it
                           has a parent. For backwards compatibility reasons, the pattern
                              <code>node()</code>, when used without an explicit axis, does not
                           match document nodes, attribute nodes, or namespace nodes. The rules are
                           also phrased to ensure that positional patterns of the form
                              <code>para[1]</code> continue to count nodes relative to their parent,
                           if they have one. To match any node at all,
                              XSLT 4.0 allows the pattern <code>.[. instance of node()]</code> to be
                              used.</p>
                     </note>

                  </item>
               </ulist>

               <p>The meaning of the pattern is then defined in terms of the semantics of the
                  equivalent expression, denoted below as <code>EE</code>.</p>

               <p>Specifically, an item <var>N</var> matches a pattern <var>P</var> if  the following applies, where
                     <code>EE</code> is the <term>equivalent expression</term> to <var>P</var>:</p>
               <olist>

                  <item>
                     <p><var>N</var> is a node, and the result of evaluating the expression
                           <code>root(.)//(EE)</code> with a <termref def="dt-singleton-focus">singleton focus</termref> based on <var>N</var> is a sequence that
                        includes the node <var>N</var>
                     </p>
                  </item>
                  
               </olist>

               <p>If a pattern appears in an attribute of an element that
                     is processed with <termref def="dt-xslt-10-behavior">XSLT 1.0
                        behavior</termref> (see <specref ref="backwards"/>), then the
                  semantics of the pattern are defined on the basis that the equivalent XPath
                  expression is evaluated with <termref def="dt-xpath-compat-mode">XPath 1.0
                     compatibility mode</termref> set to true.</p>


               <example>
                  <head>The Semantics of Node Patterns</head>
                  <p>The <termref def="dt-node-pattern"/>
                     <code>p</code> matches any <code>p</code> element, because a <code>p</code>
                     element will always be present in the result of evaluating the <termref def="dt-expression">expression</termref>
                     <code>root(.)//(child-or-top::p)</code>. Similarly, <code>/</code> matches a
                     document node, and only a document node, because the result of the <termref def="dt-expression">expression</termref>
                     <code>root(.)//(/)</code> returns the root node of the tree containing the
                     context node if and only if it is a document node.</p>
                  <p>The <termref def="dt-node-pattern"/>
                     <code>node()</code> matches all nodes selected by the expression
                        <code>root(.)//(child-or-top::node())</code>, that is, all element, text,
                     comment, and processing instruction nodes, whether or not they have a parent.
                     It does not match attribute or namespace nodes because the expression does not
                     select nodes using the attribute or namespace axes. It does not match document
                     nodes because for backwards compatibility reasons the <code>child-or-top</code>
                     axis does not match a document node.</p>
                  <note diff="add" at="A">
                     <p>The pattern <code>type(node())</code> matches all nodes.</p>
                  </note>
                  <p>The <termref def="dt-node-pattern"/>
                     <code>$V</code> matches all nodes selected by the expression
                        <code>root(.)//($V)</code>, that is, all nodes in the value of $V (which
                     will typically be a global variable, though when the pattern is used in
                     contexts such as the <elcode>xsl:number</elcode> or
                        <elcode>xsl:for-each-group</elcode> instructions, it can also be a local
                     variable).</p>
                  <p>The <termref def="dt-node-pattern"/>
                     <code>doc('product.xml')//product</code> matches all nodes selected by the
                     expression <code>root(.)//(doc('product.xml')//product)</code>, that is, all
                        <code>product</code> elements in the document whose URI is
                        <code>product.xml</code>.</p>
                  <p>The <termref def="dt-node-pattern"/>
                     <code>root(.)/self::E</code> matches an <code>E</code> element that is the root
                     of a tree (that is, an <code>E</code> element with no parent node).</p>
               </example>
               <p>Although the semantics of <termref def="dt-node-pattern">node patterns</termref> are
                  specified formally in terms of expression evaluation, it is possible to understand
                  pattern matching using a different model. A <termref def="dt-node-pattern"/> such as
                     <code>book/chapter/section</code> can be examined from right to left. A node
                  will only match this pattern if it is a <code>section</code> element; and then,
                  only if its parent is a <code>chapter</code>; and then, only if the parent of that
                     <code>chapter</code> is a <code>book</code>. When the pattern uses the
                     <code>//</code> operator, one can still read it from right to left, but this
                  time testing the ancestors of a node rather than its parent. For example
                     <code>appendix//section</code> matches every <code>section</code> element that
                  has an ancestor <code>appendix</code> element.</p>
               <p>The formal definition, however, is useful for understanding the meaning of a
                  pattern such as <code>para[1]</code>. This matches any node selected by the
                  expression <code>root(.)//(child-or-top::para[1])</code>: that is, any
                     <code>para</code> element that is the first <code>para</code> child of its
                  parent, or a <code>para</code> element that has no parent.</p>
               <note>
                  <p>An implementation, of course, may use any algorithm it wishes for evaluating
                     patterns, so long as the result corresponds with the formal definition above.
                     An implementation that followed the formal definition by evaluating the
                     equivalent expression and then testing the membership of a specific node in the
                     result would probably be very inefficient.</p>
               </note>
               <note diff="chg" at="A2022-03-04">
                  <p>Patterns using the <code>intersect</code> and <code>except</code> operators
                  do not always have the intuitive meaning: in particular, it is not always the case
                  that a node matches <code>A except B</code> if it matches <code>A</code> but does
                  not match <code>B</code>.</p>
                  <p>For example, consider the pattern <code>para except appendix//para</code>.
                  This expands to <code>root(.)/descendant-or-self::node()/(child::para except child::appendix//para)</code>.
                  Since for a given parent node, the results of <code>child::para</code> and <code>child::appendix</code>
                  are disjoint, the right-hand operand of <code>except</code> has no effect.</p>
                  <p>The effect of matching all paragraphs except those within an appendix can be achieved 
                     using the pattern <code>para except //appendix//para</code>; alternatively, use
                   <code>para[not(ancestor::appendix)]</code>.</p>
                  <p>Simpler patterns such as <code>@* except @code</code> generally have the expected effect;
                  the complications arise mainly when non-trivial relative paths are used.</p>
               </note>
            </div4>
            </div3>
            <div3 id="pattern-errors">
               <head>Errors in Patterns</head>
               <p>A <termref def="dt-dynamic-error">dynamic error</termref> or <termref def="dt-type-error">type error</termref> that occurs during the evaluation of a
                     <termref def="dt-pattern">pattern</termref> against a particular item has the effect that the item being tested is
                  treated as not matching the pattern. The error does not cause the transformation
                  to fail, and cannot be caught by a try/catch expression surrounding the
                  instruction that causes the pattern to be evaluated.</p>
               <note>
                  <p>The reason for this provision is that it is difficult for the stylesheet author
                     to predict which predicates in a pattern will actually be evaluated. In the
                     case of match patterns in template rules, it is not even possible to predict
                     which patterns will be evaluated against a particular node.</p>
                  <p>There is a risk that ignoring errors in this way may make programming mistakes
                     harder to debug. Implementations may mitigate this by providing warnings or
                     other diagnostics when evaluation of a pattern triggers an error condition.</p>
                  <p>Static errors in patterns, including dynamic and type errors that are signaled
                     statically as permitted by the specification, are reported in the normal way
                     and cause the transformation to fail.</p>
               </note>
               <p>The requirement to detect and report a <termref def="dt-circularity"/> as a dynamic error overrides this rule.</p>


            </div3>
            <div3 id="testing-against-pattern" diff="add" at="A">
               <head>Testing a Value Against a Pattern</head>
               <p>The <elcode>xsl:match</elcode> instruction can be used to test a value against a pattern.</p>
               <?element xsl:match?>
               <p>The <code>select</code> attribute is a <termref def="dt-expression"/>, defaulting to <code>.</code>,
               which selects the <termref def="dt-context-item"/>.</p>
               <p>The <code>pattern</code> attribute is a <termref def="dt-pattern"/>.</p>
               <p>The result of the <elcode>xsl:match</elcode> instruction is the <code>xsl:boolean</code>
                  value <code>true</code> if every item selected
               by the <code>select</code> expression matches the pattern, and is
               <code>false</code> otherwise.</p>
               <p>Any <code>xsl:fallback</code> child elements are ignored by an XSLT 4.0 processor, but
               may be used to define fallback processing for an XSLT 3.0 or earlier processor.</p>
               <example>
                  <head>Declaring a function that matches against a pattern</head>
                  <p>The following declaration declares a function that matches its argument against 
                  a supplied pattern:</p>
                  <eg><![CDATA[
<xsl:function name="f:is-division" as="xs:boolean">
  <xsl:param name="node" as="element(*)"/>
  <xsl:match select="$node" pattern="div1 | div2 | div3 | div4"/>
</xsl:function>]]></eg>
                  <p>This function might then be used in an expression such as <code>child::*[f:is-division(.)]</code>.</p>
               </example>
            </div3>
         </div2>
         <div2 id="named-item-types" diff="add" at="A">
            <head>Defining Named Item Types</head>
            
            <?element xsl:item-type?>
            
            <p>An <elcode>xsl:item-type</elcode> declaration associates a name with an item type, and allows the type
            to be referenced by name throughout the stylesheet package.</p>
            <example id="e-item-type-complex">
               <p>The following example declares a named item type for complex numbers, and uses it in a variable
               declaration and two function declarations.</p>
               <eg><![CDATA[<xsl:item-type name="cx:complex" as="record(r as xs:double, i as xs:double)"/>

<xsl:variable name="i" as="cx:complex" select="cx:number(0, 1)"/>

<xsl:function name="cx:number" as="cx:complex">
  <xsl:param name="r" as="xs:double"/>
  <xsl:param name="i" as="xs:double"/>
  <xsl:sequence select="map{'r':$r, 'i':$i}"/>
</xsl:function>

<xsl:function name="cx:add" as="cx:complex">
  <xsl:param name="x" as="cx:complex"/>
  <xsl:param name="y" as="cx:complex"/>
  <xsl:sequence select="cx:number($x?r + $y?r, $x?i + $y?i)"/>
</xsl:function>
                  ]]></eg>
            </example>
            <p>Using named item types makes the stylesheet more readable, and improves potential for change: a change
            to the way complex numbers are implemented in this example is less likely to affect users of the function
            library. However, named item types do not provide true encapsulation or information hiding; users of the 
            function library can still treat complex numbers as raw maps if they wish.</p>
            <p>The <elcode>xsl:item-type</elcode> declaration adds an entry to the 
               <xtermref spec="XP40" ref="dt-type-aliases"/>
            component of the static context for XPath expressions, and also becomes available for use wherever
            XSLT allows an <code>ItemType</code> to appear.</p>
            <p>The scope of a named item type is the <termref def="dt-package"/> in which it is declared. If it
            is declared with <code>visibility="final"</code> then it also becomes available for use in using
            packages. Named item types cannot be overridden in a using package, so the only permitted values for
            <code>visibility</code> are <code>private</code> and <code>final</code>.</p>
            <p>The name of the item type is the expanded name formed by resolving the <code>name</code> attribute.
            A lexical QName with no prefix is treated as a no-namespace name.</p>
            <p>If two <elcode>xsl:item-type</elcode> declarations in a <termref def="dt-package"/> have the same
            name, then the one with higher <termref def="dt-import-precedence"/> is used. </p>
            <p><error spec="XT" type="static" class="SE" code="9ZZZ">
               <p>It is a <termref def="dt-static-error">static error</termref> if a package contains two 
                  <elcode>xsl:item-type</elcode>
                  declarations having the same <termref def="dt-import-precedence">import
                     precedence</termref>, unless there is another definition of the same
                  item type with higher import precedence.</p>
            </error></p>
            <p>TODO: add named item types to xsl:accept and xsl:expose. Clarify that when a function or variable
            is exported to a different package, its declared type/signature uses the expanded form of any named
            item type; there's no requirement for the using package to know the named item types. But it becomes
            easier to use the exposed variables and functions if the names of the types are exposed too.</p>
         </div2>
         <div2 id="defining-decimal-format">
            <head>Defining a Decimal Format</head>
            
            <p>The definition of the <xfunction>format-number</xfunction> function
               is now in <bibref ref="xpath-functions-40"/>. What remains here is the definition of
               the <elcode>xsl:decimal-format</elcode> declaration, which provides the context for
               this function when used in an XSLT stylesheet.</p>
            
            <?element xsl:decimal-format?>
            <p>The <elcode>xsl:decimal-format</elcode> element sets the
               <term>statically known decimal formats</term> component of the static context
               for XPath expressions, which controls the interpretation of a <termref def="dt-picture-string">picture string</termref> used by the
               <xfunction>format-number</xfunction> function.</p>
            <p><termdef id="dt-picture-string" term="picture string">The <term>picture string</term>
               is the string supplied as the second argument of the
               <xfunction>format-number</xfunction> function.</termdef>
            </p>
            <note>
               <p>The <xfunction>format-number</xfunction> function, previously defined in this
                  specification, is now defined in <bibref ref="xpath-functions-40"/>. </p>
            </note>
            <p>A <termref def="dt-package">package</termref> may
               contain multiple <elcode>xsl:decimal-format</elcode> declarations and may include or
               import <termref def="dt-stylesheet-module">stylesheet modules</termref> that also
               contain <elcode>xsl:decimal-format</elcode> declarations. The name of an
               <elcode>xsl:decimal-format</elcode> declaration is the value of its
               <code>name</code> attribute, if any.</p>
            <p>
               <termdef id="dt-decimal-format" term="decimal format">All the
                  <elcode>xsl:decimal-format</elcode> declarations in a package that share the same name are grouped into a named
                  <term>decimal format</term>; those that have no name are grouped into a single
                  unnamed decimal format.</termdef>
            </p>
            
            <p> The attributes of the <elcode>xsl:decimal-format</elcode>
               declaration define the value of the corresponding property in the relevant decimal
               format in the <xtermref spec="XP40" ref="dt-static-decimal-formats">statically known
                  decimal formats</xtermref> component of the static context for all XPath
               expressions in the package. The attribute names used in the XSLT 4.0 syntax are the
               same as the property names used in the definition of the static context. </p>
            
            
            
            <p diff="del" at="A"> The <code>exponent-separator</code> attribute is provided
               for use with XPath 3.1. It has no effect when used with XPath 3.0. </p>
            
            
            
            <p>The scope of an <elcode>xsl:decimal-format</elcode> name is the
               package in which it is declared; the name is available for use only in calls to
               <xfunction>format-number</xfunction> that appear within the same package.</p>
            
            <p>If a <termref def="dt-package">package</termref> does not contain a declaration of
               the unnamed decimal format, a declaration equivalent to an
               <elcode>xsl:decimal-format</elcode> element with no attributes is implied.</p>
            <p>The attributes of the <elcode>xsl:decimal-format</elcode> declaration establish
               values for a number of variables used as input to the algorithm followed by the
               <xfunction>format-number</xfunction> function. An outline of the purpose of each
               attribute is given below; however, the definitive explanations are given as part of the specification of
               <xfunction>format-number</xfunction>.</p>
            <p>For any named <termref def="dt-decimal-format">decimal format</termref>, the
               effective value of each attribute is taken from an
               <elcode>xsl:decimal-format</elcode> declaration that has that name, and that
               specifies an explicit value for the required attribute. If there is no such
               declaration, the default value of the attribute is used. If there is more than one
               such declaration, the one with highest <termref def="dt-import-precedence">import
                  precedence</termref> is used.</p>
            <p>For any unnamed <termref def="dt-decimal-format">decimal format</termref>, the
               effective value of each attribute is taken from an
               <elcode>xsl:decimal-format</elcode> declaration that is unnamed, and that
               specifies an explicit value for the required attribute. If there is no such
               declaration, the default value of the attribute is used. If there is more than one
               such declaration, the one with highest <termref def="dt-import-precedence">import
                  precedence</termref> is used.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1290">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a named or
                     unnamed <termref def="dt-decimal-format">decimal format</termref> contains two
                     conflicting values for the same attribute in different
                     <elcode>xsl:decimal-format</elcode> declarations having the same <termref def="dt-import-precedence">import precedence</termref>, unless there is
                     another definition of the same attribute with higher import precedence.</p>
               </error>
            </p>
            <p>The following attributes control the interpretation of characters in the <termref def="dt-picture-string">picture string</termref> supplied to the
               <xfunction>format-number</xfunction> function, and also specify characters that
               may appear in the result of formatting the number. In each case the value
               <rfc2119>must</rfc2119> be a single character <errorref class="SE" code="0020"/>.</p>
            <ulist>
               <item>
                  <p>
                     <code>decimal-separator</code> specifies the character used to separate the
                     integer part from the fractional part of the formatted number; the default
                     value is the period character (<code>.</code>)</p>
               </item>
               <item>
                  <p>
                     <code>grouping-separator</code> specifies the character typically used as a
                     thousands separator; the default value is the comma character
                     (<code>,</code>)</p>
               </item>
               <item>
                  <p>
                     <code>percent</code> specifies the character used to indicate that the number
                     is represented as a per-hundred fraction; the default value is the percent
                     character (<code>%</code>)</p>
               </item>
               <item>
                  <p>
                     <code>per-mille</code> specifies the character used to indicate that the number
                     is represented as a per-thousand fraction; the default value is the Unicode
                     per-mille character (#x2030)</p>
               </item>
               <item>
                  <p>
                     <code>zero-digit</code> specifies the character used to represent the digit
                     zero; the default value is the Western digit zero (<code>0</code>). This
                     character <rfc2119>must</rfc2119> be a digit (category <code>Nd</code> in the
                     Unicode property database), and it <rfc2119>must</rfc2119> have the numeric
                     value zero. This attribute implicitly defines the Unicode character that is
                     used to represent each of the values 0 to 9 in the final result string: Unicode
                     is organized so that each set of decimal digits forms a contiguous block of
                     characters in numerical sequence.</p>
               </item>
            </ulist>
            <p>
               <error spec="XT" type="static" class="SE" code="1295">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the character
                     specified in the <code>zero-digit</code> attribute is not a digit or is a digit
                     that does not have the numeric value zero. </p>
               </error>
            </p>
            <p>The following attributes control the interpretation of characters in the <termref def="dt-picture-string">picture string</termref> supplied to the
               <xfunction>format-number</xfunction> function. In each case the value
               <rfc2119>must</rfc2119> be a single character <errorref class="SE" code="0020"/>.</p>
            <ulist>
               <item>
                  <p>
                     <code>digit</code> specifies the character used in the <termref def="dt-picture-string">picture string</termref> as a place-holder for an
                     optional digit; the default value is the number sign character
                     (<code>#</code>)</p>
               </item>
               <item>
                  <p>
                     <code>pattern-separator</code> specifies the character used to separate
                     positive and negative sub-pictures in a <termref def="dt-picture-string">picture string</termref>; the default value is the semi-colon character
                     (<code>;</code>)</p>
               </item>
            </ulist>
            <p>The following attributes specify characters or strings that may appear in the result
               of formatting the number:</p>
            <ulist>
               <item>
                  <p>
                     <code>infinity</code> specifies the string used to represent the
                     <code>xs:double</code> value <code>INF</code>; the default value is the
                     string <code>Infinity</code>
                  </p>
               </item>
               <item>
                  <p>
                     <code>NaN</code> specifies the string used to represent the
                     <code>xs:double</code> value <code>NaN</code> (not-a-number); the default
                     value is the string <code>NaN</code>
                  </p>
               </item>
               <item>
                  <p>
                     <code>minus-sign</code> specifies the character used to signal a negative
                     number; the default value is the hyphen-minus character (<code>-</code>, #x2D).
                     The value <rfc2119>must</rfc2119> be a single character.</p>
               </item>
            </ulist>
            <p>
               <error spec="XT" type="static" class="SE" code="1300">
                  <p>It is a <termref def="dt-static-error">static error</termref> if, for any named
                     or unnamed decimal format, the variables representing characters used in a
                     <termref def="dt-picture-string">picture string</termref> do not each have
                     distinct values. These variables are <var>decimal-separator-sign</var>,
                     <var>grouping-sign</var>, <var>percent-sign</var>,
                     <var>per-mille-sign</var>, <var>digit-zero-sign</var>, <var>digit-sign</var>,
                     and <var>pattern-separator-sign</var>.</p>
               </error>
            </p>
            <p>Every (named or unnamed) decimal format defined in a <termref def="dt-stylesheet">package</termref> is added to the <xtermref spec="XP40" ref="dt-static-decimal-formats">statically known decimal formats</xtermref> in the
               <xtermref spec="XP40" ref="dt-static-context">static context</xtermref> of every
               expression in the <termref def="dt-package">package</termref>, excluding expressions
               appearing in <code>[xsl:]use-when</code> attributes.</p>
            
         </div2>
         <div2 id="value-templates">
            <head>Value Templates</head>
            <p>The string value of an attribute or text node in the stylesheet may in particular
               circumstances contain embedded expressions enclosed between curly brackets.
               Attributes and text nodes that use (or are permitted to use) this mechanism are
               referred to respectively as <termref def="dt-attribute-value-template">attribute
                  value templates</termref> and <termref def="dt-text-value-template">text value
                  templates</termref>.</p>

            <p><termdef id="dt-value-template" term="value template">Collectively,
                  attribute value templates and text value templates are referred to as <term>value
                     templates</term>.</termdef></p>

            <p>A value template is a string consisting of an alternating sequence of fixed parts and
               variable parts:</p>
            <ulist>
               <item><p>A variable part consists of an optional XPath <termref def="dt-expression">expression</termref> enclosed in curly brackets (<code>{}</code>):
                  more specifically, a string conforming 
                     to the XPath production <code>Expr?</code>.</p>
                  <note>
                     <p>An expression within a variable part may contain an unescaped curly bracket within
                        a <xnt spec="XP40" ref="prod-xpath40-StringLiteral">StringLiteral</xnt> or within
                        a comment.</p>
                     <p>Currently no XPath expression starts with an opening curly
                        bracket, so the use of <code>{{</code> creates no ambiguity. If an enclosed
                        expression ends with a closing curly bracket, no whitespace is required between
                        this and the closing delimiter.</p>
                     <p>The fact that the expression is optional means that the
                     string contained between the curly brackets may be zero-length, may comprise whitespace
                     only, or may contain XPath comments. The effective value in this case is a zero-length
                     string, which is equivalent to omitting the variable part entirely, together with its 
                     curly-bracket delimiters. </p> 
                  </note>
               </item>
               <item><p>A fixed part
                  may contain any characters, except that a left curly bracket <rfc2119>must</rfc2119>
                  be written as <code>{{</code> and a right curly bracket <rfc2119>must</rfc2119> be
                  written as <code>}}</code>. </p></item>
            </ulist>
               
 
           
            <p>
               <error spec="XT" type="static" class="SE" code="0350">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an unescaped
                     left curly bracket appears in a fixed part of a value template without a
                     matching right curly bracket.</p>
               </error>
            </p>
            <p>It is a <termref def="dt-static-error">static error</termref> if the string contained
               between matching curly brackets in a value template does not match the XPath
               production <xnt spec="XP40" ref="prod-xpath40-Expr">Expr?</xnt>, or if it contains
               other XPath static errors. The error is signaled using the appropriate XPath error
               code.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0370">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an unescaped
                     right curly bracket occurs in a fixed part of a value template.</p>
               </error>
            </p>
            <p>
               <termdef id="dt-effective-value" term="effective value">The result of evaluating a
                  value template is referred to as its <term>effective value</term>.</termdef> The
               effective value is the string obtained by concatenating the expansions of the fixed
               and variable parts:</p>
            <ulist>
               <item>
                  <p>The expansion of a fixed part is obtained by replacing any double curly
                     brackets (<code>{{</code> or <code>}}</code>) by the corresponding single curly
                     bracket.</p>
               </item>
               <item>
                  <p>The expansion of a variable part is as follows:</p>
                  <ulist>
                     <item><p>If an expression is present, the result of evaluating the enclosed XPath
                        <termref def="dt-expression">expression</termref> and converting the
                        resulting value to a string. This conversion is done using the rules given in
                        <specref ref="constructing-simple-content"/>.</p></item>
                     <item><p>If the expression is omitted, a zero-length string.</p></item>
                  </ulist>
               </item>
            </ulist>

            <note>
               <p>This process can generate dynamic errors, for example if the sequence contains an
                  element with a complex content type (which cannot be atomized).</p>
            </note>

            <p>In the case of an attribute value template, the effective value becomes the string
               value of the new attribute node. In the case of a text value template, the effective
               value becomes the string value of the new text node.</p>




            <div3 id="attribute-value-templates">
               <head>Attribute Value Templates</head>
               <p>
                  <termdef id="dt-attribute-value-template" term="attribute value template">In an
                     attribute that is designated as an <term>attribute value template</term>, such
                     as an attribute of a <termref def="dt-literal-result-element">literal result
                        element</termref>, an <termref def="dt-expression">expression</termref> can
                     be used by surrounding the expression with curly brackets (<code>{}</code>),
                     following the general rules for <termref def="dt-value-template">value
                        templates</termref></termdef>.</p>

               <p>Curly brackets are not treated specially in an attribute value in an XSLT <termref def="dt-stylesheet">stylesheet</termref> unless the attribute is specifically
                  designated as one that permits an attribute value template; in an element syntax
                  summary, the value of such attributes is surrounded by curly brackets.</p>
               <note>
                  <p>Not all attributes are designated as attribute value templates. Attributes
                     whose value is an <termref def="dt-expression">expression</termref> or <termref def="dt-pattern">pattern</termref>, attributes of <termref def="dt-declaration">declaration</termref> elements and attributes that
                     refer to named XSLT objects are generally not designated as attribute value
                     templates (an exception is the <code>format</code> attribute of
                        <elcode>xsl:result-document</elcode>). Namespace declarations are not XDM
                     attribute nodes and are therefore never treated as attribute value
                     templates.</p>
               </note>


               <p>If the element containing the attribute is processed
                     with <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref>, then the
                     rules for converting the value of the expression to a string (given in <specref ref="value-templates"/>) are modified as follows. After <termref def="dt-atomization">atomizing</termref> the result of the expression, all
                     items other than the first item in the resulting sequence are discarded, and
                     the effective value is obtained by converting the first item in the sequence to
                     a string. If the atomized sequence is empty, the result is a zero-length
                     string.</p>

               <note>
                  <p>The above rule applies to attribute value templates but not
                     to text value templates, since the latter were not available in XSLT 1.0.</p>
               </note>

               <example>
                  <head>Attribute Value Templates</head>
                  <p>The following example creates an <code>img</code> result element from a
                        <code>photograph</code> element in the source; the value of the
                        <code>src</code> and <code>width</code> attributes are computed using XPath
                     expressions enclosed in attribute value templates:</p>
                  <eg xml:space="preserve" role="xslt-declarations">&lt;xsl:variable name="image-dir" select="'/images'"/&gt;

&lt;xsl:template match="photograph"&gt;
  &lt;img src="{$image-dir}/{href}" width="{size/@width}"/&gt;
&lt;/xsl:template&gt;</eg>
                  <p>With this source</p>
                  <eg xml:space="preserve" role="xml">&lt;photograph&gt;
  &lt;href&gt;headquarters.jpg&lt;/href&gt;
  &lt;size width="300"/&gt;
&lt;/photograph&gt;</eg>
                  <p>the result would be</p>
                  <eg xml:space="preserve" role="xml">&lt;img src="/images/headquarters.jpg" width="300"/&gt;</eg>
               </example>
               <example>
                  <head>Producing a Space-Separated List</head>
                  <p>The following example shows how the values in a sequence are output as a
                     space-separated list. The following literal result element:</p>
                  <eg xml:space="preserve" role="xml">&lt;temperature readings="{10.32, 5.50, 8.31}"/&gt;</eg>
                  <p>produces the output node:</p>
                  <eg xml:space="preserve" role="xml">&lt;temperature readings="10.32 5.5 8.31"/&gt;</eg>
               </example>
               <p>Curly brackets are <emph>not</emph> recognized recursively inside expressions.</p>
               <example>
                  <head>Curly Brackets cannot be Nested</head>
                  <p>For example:</p>
                  <eg role="error" xml:space="preserve">&lt;a href="#{id({@ref})/title}"/&gt;</eg>
                  <p>is <emph>not</emph> allowed. Instead, use simply:</p>
                  <eg xml:space="preserve" role="xml">&lt;a href="#{id(@ref)/title}"/&gt;</eg>
               </example>
            </div3>

            <div3 id="text-value-templates">
               <head>Text Value Templates</head>

               <p>The <termref def="dt-standard-attributes">standard attribute</termref>
                  <code>[xsl:]expand-text</code> may appear on any element in the stylesheet, and
                  determines whether descendant text nodes of that element are treated as text value
                  templates. A text node in the stylesheet is treated as a text value template if
                  (a) it is part of a <termref def="dt-sequence-constructor">sequence
                     constructor</termref>
                  or a child of an <elcode>xsl:text</elcode>
                     instruction, (b) there is an ancestor element with an
                     <code>[xsl:]expand-text</code> attribute, and (c) on the innermost ancestor
                  element that has such an attribute, the value of the attribute is
                  <code>yes</code>. The attribute is boolean and
                        <rfc2119>must</rfc2119> therefore take one of the values <code>yes</code>
                     (synonyms <code>true</code> or <code>1</code>) or <code>no</code> (synonyms
                        <code>false</code> or <code>0</code>). </p>

               <p>This section describes how text nodes  are processed when the effective value is
                     <code>yes</code>. Such text nodes are referred to as text value templates.</p>

               <p>
                  <termdef id="dt-text-value-template" term="text value template">In a text node
                     that is designated as a <term>text value template</term>, <termref def="dt-expression">expressions</termref> can be used by surrounding each
                     expression with curly brackets (<code>{}</code>).</termdef></p>

               <p>The rules for text value templates are given in <specref ref="value-templates"/>.
                  A text node 
                  whose value is a text value template results in the construction of a text node in
                  the result of the containing sequence
                     constructor or <elcode>xsl:text</elcode> instruction. The string value
                  of that text node is obtained by computing the effective value of the value
                  template.</p>

               <note>
                  

                  <p>The result of evaluating a text value template is a (possibly zero-length) text
                     node. This text node becomes part of the result of the containing sequence
                     constructor or <elcode>xsl:text</elcode> instruction, and is thereafter handled
                     exactly as if the value had appeared explicitly as a text node in the
                     stylesheet.</p>

                  <p>The way in which the effective value is computed does not depend on any
                        <code>separator</code> attribute on a containing
                        <elcode>xsl:value-of</elcode> or <elcode>xsl:attribute</elcode> instruction.
                     The <code>separator</code> attribute only affects how the text node is combined
                     with adjacent items in the result of the containing sequence constructor.</p>

                  <p>Fixed parts consisting entirely of whitespace are significant and are handled
                     in the same way as any other fixed part. This is different from the default
                     treatment of “boundary space” in XQuery.</p>


               </note>



               <example>
                  <head>Using a text value template to construct message output</head>
                  <eg role="xslt-instructions" xml:space="preserve">&lt;xsl:variable name="id" select="'A123'"/&gt;
&lt;xsl:variable name="step" select="5"/&gt;
&lt;xsl:message expand-text="yes"
     &gt;Processing id={$id}, step={$step}&lt;/xsl:message&gt;
</eg>
                  <p>This will typically output the message text <code>Processing id=A123,
                        step=5</code>.</p>
               </example>

               <example>
                  <head>Using a text value template to define the result of a function</head>
                  <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">&lt;xsl:function name="f:sum" expand-text="yes" as="xs:integer"&gt;
&lt;xsl:param name="x" as="xs:integer"/&gt;
&lt;xsl:param name="y" as="xs:integer"/&gt;
  {$x + $y}
&lt;/xsl:function&gt;</eg>
                  <p>Note that although this is a very readable way of expressing the computation
                     performed by the function, the semantics are somewhat complex, and this could
                     mean that execution is inefficient. The function computes the value of <code>$x
                        + $y</code> as an integer, and then constructs a text node containing the
                     string representation of this integer (preceded and followed by whitespace).
                     Because the declared result type of the function is <code>xs:integer</code>,
                     this text node is then atomized, giving an <code>xs:untypedAtomic</code> value,
                     and the <code>xs:untypedAtomic</code> value is then cast to an
                        <code>xs:integer</code>.</p>
               </example>

               <note>
                  <p>The main motivations for adding text value templates to the XSLT language are
                     firstly, to make it easier to construct parameterized text in contexts such as
                        <elcode>xsl:value-of</elcode> and <elcode>xsl:message</elcode>, and
                     secondly, to allow use of complex multi-line XPath expressions where
                     maintaining correct indentation is important for readability. The fact that XML
                     processors are required to normalize whitespace in attribute values means that
                     writing such expressions within a <code>select</code> attribute is not
                     ideal.</p>

                  <p>The facility is only present if enabled using the
                        <code>[xsl:]expand-text</code> attribute. This is partly for backwards
                     compatibility, and partly to avoid creating difficulties when constructing
                     content that is rich in curly brackets, for example JavaScript code or CSS
                     style sheets.</p>
               </note>




            </div3>
         </div2>
         <div2 id="sequence-constructors">
            <head>Sequence Constructors</head>
            <p>
               <termdef id="dt-sequence-constructor" term="sequence constructor">A <term>sequence
                     constructor</term> is a sequence of zero or more sibling nodes in the <termref def="dt-stylesheet">stylesheet</termref> that can be evaluated to return a
                  sequence of nodes, atomic values, and function
                     items. The way that the resulting sequence is used depends on the
                  containing instruction.</termdef>
            </p>
            <p>Many <termref def="dt-xslt-element">XSLT elements</termref>, and also <termref def="dt-literal-result-element">literal result elements</termref>, are defined to
               take a <termref def="dt-sequence-constructor"/> as their content.</p>

            <p>Four kinds of nodes may be encountered in a sequence constructor:</p>
            <olist>
               <item>
                  <p> A <emph>Text node</emph> appearing in the <termref def="dt-stylesheet">stylesheet</termref> (if it has not been removed in the process of
                     whitespace stripping: see <specref ref="stylesheet-stripping"/>) is processed as follows:</p>
                  <olist>
                     <item>
                        <p>if the effective value of the standard attribute
                              <code>[xsl:]expand-text</code> is <code>no</code>, or in the absence
                           of this attribute, the text node in the stylesheet is copied to create a
                           new parentless text node in the result of the sequence constructor.</p>
                        
                     </item>
                     <item>
                        <p>Otherwise (the effective value of <code>[xsl:]expand-text</code> is
                              <code>yes</code>), the text node in the stylesheet is processed as
                           described in <specref ref="text-value-templates"/>.</p>
                     </item>
                  </olist>
               </item>
               <item>
                  <p> A <termref def="dt-literal-result-element">literal result element</termref> is
                     evaluated to create a new parentless element node, having the same <termref def="dt-expanded-qname">expanded QName</termref> as the literal result
                     element: see <specref ref="literal-result-element"/>. </p>
               </item>
               <item>
                  <p>An XSLT <termref def="dt-instruction">instruction</termref> produces a sequence
                     of zero, one, or more items as its result. For most XSLT instructions, these
                     items are nodes, but some instructions (such
                        as
                     <elcode>xsl:sequence</elcode> and <elcode>xsl:copy-of</elcode>) can also
                     produce atomic values or function items.
                     Several instructions, such as <elcode>xsl:element</elcode>, return a newly
                     constructed parentless node (which may have its own attributes, namespaces,
                     children, and other descendants). Other instructions, such as
                        <elcode>xsl:if</elcode>, pass on the items produced by their own nested
                     sequence constructors. The <elcode>xsl:sequence</elcode> instruction may return
                     atomic values, function items, or existing
                     nodes.</p>
               </item>
               <item>
                  <p> An <termref def="dt-extension-instruction"/> (see <specref ref="extension-instruction"/>) also produces a sequence of items as its
                     result.</p>
               </item>
            </olist>
            <p><termdef id="dt-immediate-result" term="immediate result">The result of evaluating
               a <termref def="dt-sequence-constructor"/> is the sequence
               of items formed by concatenating the results of evaluating each of the nodes in the
               sequence constructor, retaining order. This is 
                  referred to as the <term>immediate result</term>
            of the sequence constructor.</termdef></p>
            <p>However:</p>
            <ulist>
               <item>
                  <p>For the effect of the <elcode>xsl:fallback</elcode> instruction, see <specref ref="fallback"/>.</p>
               </item>
               <item>
                  <p>For the effect of the <elcode>xsl:on-empty</elcode> and
                        <elcode>xsl:on-non-empty</elcode> instructions, see <specref ref="conditional-content-construction"/>.</p>
               </item>
            </ulist>
            <p>The way that <termref def="dt-immediate-result"/> of a <termref def="dt-sequence-constructor"/> 
               is used depends on the containing element in the stylesheet, and is specified in the rules 
               for that element. It is typically one of the following:</p>
            <ulist>
               <item>
                  <p>The <termref def="dt-immediate-result"/> may be bound to a <termref def="dt-variable"/> or 
                     delivered as the result of a <termref def="dt-stylesheet-function"/>.
                     In this case the <code>as</code> attribute of the containing <elcode>xsl:variable</elcode>
                     or <elcode>xsl:function</elcode> element may be used to declare its required type, 
                     and the <termref def="dt-immediate-result"/> is then converted to the required type 
                     by applying the <termref def="dt-coercion-rules"/>.</p>
                     
                     <note>
                        <ulist>
                           <item><p>In the absence of an <code>as</code> attribute, the result of a 
                              function is the <termref def="dt-immediate-result"/> of the sequence constructor; 
                              but the value of a variable (for backwards compatibility reasons) is a document node 
                              whose content is formed by applying the rules in <specref ref="constructing-complex-content"/> 
                              to the <termref def="dt-immediate-result"/>.
                           </p></item>
                           <item><p>The coercion rules do not merge adjacent text nodes 
                              or insert separators between adjacent items. This means it is often inappropriate 
                              to use <elcode>xsl:value-of</elcode> in the body of <elcode>xsl:variable</elcode> or 
                              <elcode>xsl:function</elcode>, especially when the intent is to return an atomic result. 
                              The <elcode>xsl:sequence</elcode> instruction is designed for this purpose, and 
                              is usually a better choice.
                           </p></item>
                           <item><p>The result of a function, or the value of a variable, may contain nodes 
                              (such as elements, attributes, and text nodes) that are not attached to any parent node 
                              in a <termref def="dt-result-tree"/>.  The semantics of XPath expressions when applied to parentless nodes 
                              are well-defined; however, such expressions should be used with care. For example, 
                              the expression <code>/</code> causes a type error if the root of the tree containing 
                              the context node is not a document node.
                           </p></item>
                           <item><p>Parentless attribute nodes require particular care because they have no
                              namespace nodes associated with them. A parentless attribute node is not
                              permitted to contain namespace-sensitive content (for example, a QName or an
                              XPath expression) because there is no information enabling the prefix to be
                              resolved to a namespace URI. Parentless attributes can be useful in an
                              application (for example, they provide an alternative to the use of
                              attribute sets: see <specref ref="attribute-sets"/>) but they need to be
                              handled with care.</p></item>
                        </ulist>
                     </note>
      
               </item>
               <item>
                  <p>The sequence may be returned as the result of the containing element. This
                     happens, for example, when 
                     the element containing the
                     sequence constructor is 
                        <elcode>xsl:break</elcode>,
                        <elcode>xsl:catch</elcode>, 
                        <elcode>xsl:fallback</elcode>, <elcode>xsl:for-each</elcode>,
                        <elcode>xsl:for-each-group</elcode>, <elcode>xsl:fork</elcode>, <elcode>xsl:if</elcode>, <elcode>xsl:iterate</elcode>,
                        <elcode>xsl:matching-substring</elcode>, 
                        <elcode>xsl:non-matching-substring</elcode>, <elcode>xsl:on-completion</elcode>,
                        <elcode>xsl:otherwise</elcode>, <elcode>xsl:perform-sort</elcode>,
                        <elcode>xsl:sequence</elcode>, <elcode>xsl:try</elcode>, or <elcode>xsl:when</elcode>. </p>
               </item>
               <item>
                  <p>The sequence may be used to construct the content of a new element or document
                     node. This happens when the sequence constructor appears as the content of a
                        <termref def="dt-literal-result-element">literal result element</termref>,
                     or of one of the instructions <elcode>xsl:copy</elcode>,
                        <elcode>xsl:element</elcode>, <elcode>xsl:document</elcode>,
                        <elcode>xsl:result-document</elcode>, <elcode>xsl:assert</elcode>, or <elcode>xsl:message</elcode>.
                     It also happens when the sequence constructor is contained in one of the
                     elements <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>, or
                        <elcode>xsl:with-param</elcode>,  when this instruction has no
                        <code>as</code> attribute. For details, see <specref ref="constructing-complex-content"/>.</p>
               </item>
               <item>
                  <p>The sequence may be used to construct the <termref def="dt-string-value">string
                        value</termref> of an attribute node, text node, namespace node, comment
                     node, or processing instruction node. This happens when the sequence
                     constructor is contained in one of the elements <elcode>xsl:attribute</elcode>,
                        <elcode>xsl:value-of</elcode>, <elcode>xsl:namespace</elcode>,
                        <elcode>xsl:comment</elcode>, or
                     <elcode>xsl:processing-instruction</elcode>. For details, see <specref ref="constructing-simple-content"/>.</p>
               </item>
            </ulist>
            

            <div3 id="constructing-complex-content">
               <head>Constructing Complex Content</head>
               
               <p>Many instructions, for example <elcode>xsl:copy</elcode>, <elcode>xsl:element</elcode>, 
                  <elcode>xsl:document</elcode>, <elcode>xsl:result-document</elcode>, and 
                  <termref def="dt-literal-result-element">literal result elements</termref>, 
                  create a new parent node, and evaluate a <termref def="dt-sequence-constructor"/> 
                  forming the content of the instruction to create the attributes, 
                  namespaces, and children of the new parent node. The <termref def="dt-immediate-result"/> 
                  of the sequence constructor is processed to create the content of the new parent 
                  node as described in this section.</p>

               <p>When constructing the content of an element, the <code>inherit-namespaces</code>
                  attribute of the <elcode>xsl:element</elcode> or <elcode>xsl:copy</elcode>
                  instruction, or the <code>xsl:inherit-namespaces</code> property of the literal
                  result element, determines whether namespace nodes are to be inherited. The effect
                  of this attribute is described in the rules that follow.</p>
               <p>The <termref def="dt-immediate-result"/> of the <termref def="dt-sequence-constructor"/>
                  is processed as follows (applying the rules in the order they are listed):</p>
               <olist>
                  <item>
                     <p>The containing instruction may generate attribute nodes and/or namespace
                        nodes, as specified in the rules for the individual instruction. For
                        example, these nodes may be produced by expanding an
                           <code>[xsl:]use-attribute-sets</code> attribute, or by expanding the
                        attributes of a <termref def="dt-literal-result-element">literal result
                           element</termref>. Any such nodes are prepended to the 
                        <termref def="dt-immediate-result"/> of the <termref def="dt-sequence-constructor"/>.</p>
                  </item>
                  <item>
                     <p>Any array item in the sequence (see <specref ref="arrays"/>)
                     is replaced by its members, recursively. This is equivalent to applying
                     the <xfunction spec="FO40">array:flatten</xfunction> function defined in 
                     <bibref ref="xpath-functions-31"/>.</p>
                     <note diff="del" at="A"><p>This situation only arises if the XPath 3.1 feature is implemented.
                     Note that if the array contains nodes, this operation leaves the nodes in the sequence: they
                     are not <termref def="dt-atomization">atomized</termref>.</p></note>
                  </item>
                  <item>
                     <p>Any atomic value in the sequence is cast to a string.</p>
                     <note>
                        <p>Casting from <code>xs:QName</code> or <code>xs:NOTATION</code> to
                              <code>xs:string</code> always succeeds, because these values retain a
                           prefix for this purpose. However, there is no guarantee that the prefix
                           used will always be meaningful in the context where the resulting string
                           is used.</p>
                     </note>
                  </item>
                  <item>
                     <p>Any consecutive sequence of strings in the sequence is converted
                        to a single text node, whose <termref def="dt-string-value">string
                           value</termref> contains the content of each of the strings in turn, with
                        a single space (#x20) used as a separator between successive strings.</p>
                  </item>
                  <item>
                     <p>Any document node within the sequence is replaced by a sequence
                        containing each of its children, in document order.</p>
                  </item>
                  <item>
                     <p>Zero-length text nodes within the sequence are removed.</p>
                  </item>
                  <item>
                     <p>Adjacent text nodes within the sequence are merged into a single text
                        node.</p>
                  </item>
                  <item>
                     <p>Invalid items in the sequence are
                        detected as follows.</p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0410">
                           <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the 
                              sequence used to construct the content of an element node contains a
                              namespace node or attribute node that is preceded in the sequence by a
                              node that is neither a namespace node nor an attribute node.</p>
                        </error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0420">
                           <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the 
                              sequence used to construct the content of a document node contains a
                              namespace node or attribute node.</p>
                        </error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0430">
                           <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the 
                              sequence contains two or more namespace nodes having the same name but
                              different <termref def="dt-string-value">string values</termref> (that
                              is, namespace nodes that map the same prefix to different namespace
                              URIs).</p>
                        </error>
                     </p>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0440">
                           <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the 
                              sequence contains a namespace node with no name and the element node
                              being constructed has a null namespace URI (that is, it is an error to
                              define a default namespace when the element is in no namespace). </p>
                        </error>
                     </p>
                     <p diff="add" at="E">
                        <error spec="XT" type="type" class="DE" code="0450">
                           <p>It is a <termref def="dt-type-error">type error</termref> if the result
                              sequence contains a function item. </p>
                        </error>
                     </p>
                     <note diff="add" at="E">
                        <p>The error code reflects the fact that this error was at one time classified 
                           as a dynamic error rather than a type error. [XSLT 3.0 Erratum E17, bug 30223].</p>
                     </note>
                  </item>
                  <item>
                     <p>If the sequence contains two or more namespace nodes with the same
                        name (or no name) and the same <termref def="dt-string-value">string
                           value</termref> (that is, two namespace nodes mapping the same prefix to
                        the same namespace URI), then all but one of the duplicate nodes are
                        discarded.</p>
                     <note>
                        <p>Since the order of namespace nodes is <termref def="dt-implementation-dependent">implementation-dependent</termref>,
                           it is not significant which of the duplicates is retained.</p>
                     </note>
                  </item>
                  <item>
                     <!--Text replaced by erratum E10 change 1"-->
                     <p>If an attribute <var>A</var> in the sequence has the same name as
                        another attribute <var>B</var> that appears later in the sequence,
                        then attribute <var>A</var> is discarded from the sequence. Before
                        discarding attribute <var>A</var>, the processor <rfc2119>may</rfc2119>
                        signal any <termref def="dt-type-error">type errors</termref> that would be
                        signaled if attribute <var>B</var> were not present. </p>
                     <!--End of text replaced by erratum E10-->
                  </item>
                  <item>
                     <p>Each node in the resulting sequence is attached as a namespace, attribute,
                        or child of the newly constructed element or document node. Conceptually
                        this involves making a deep copy of the node; in practice, however, copying
                        the node will only be necessary if the existing node can be referenced
                        independently of the parent to which it is being attached. When copying an
                        element or processing instruction node, its base URI property is changed to
                        be the same as that of its new parent, unless it has an
                           <code>xml:base</code> attribute (see <bibref ref="xmlbase"/>) that
                        overrides this. If the copied element has an <code>xml:base</code>
                        attribute, its base URI is the value of that attribute, resolved (if it is
                        relative) against the base URI of the new parent node.</p>
                     <p>Except for the handling of base URI, the copying
                        of a node follows the rules of the <elcode>xsl:copy-of</elcode> instruction
                        with attributes <code>copy-namespaces="yes" copy-accumulators="no"
                           validation="preserve"</code>.</p>
                     <note>
                        <p>This has the consequence that the type annotation and the values of the
                              <code>nilled</code>, <code>is-id</code>, and <code>is-idrefs</code>
                           properties are retained. However, if the node under construction (the new
                           parent of the node being copied) uses a validation mode other than
                              <code>preserve</code>, this will be transient: the values will be
                           recomputed when the new parent node is validated.</p>
                     </note>
                  </item>
                  <item>
                     <p>If the newly constructed node is an element node, then namespace fixup is
                        applied to this node, as described in <specref ref="namespace-fixup"/>.</p>
                  </item>
                  <item>
                     <p>If the newly constructed node is an element node, and if namespaces are
                        inherited, then each namespace node of the newly constructed element
                        (including any produced as a result of the namespace fixup process) is
                        copied to each descendant element of the newly constructed element, unless
                        that element or an intermediate element already has a namespace node with
                        the same name (or absence of a name) or that descendant element or an
                        intermediate element is in no namespace and the namespace node has no
                        name.</p>
                  </item>
               </olist>
               <example>
                  <head>A Sequence Constructor for Complex Content</head>
                  <p>Consider the following stylesheet fragment:</p>
                  <eg xml:space="preserve" role="xslt-instruction">&lt;td&gt;
  &lt;xsl:attribute name="valign"&gt;top&lt;/xsl:attribute&gt;
  &lt;xsl:value-of select="@description"/&gt;
&lt;/td&gt;</eg>
                  <p>This fragment consists of a literal result element <code>td</code>, containing
                     a sequence constructor that consists of two instructions:
                        <elcode>xsl:attribute</elcode> and <elcode>xsl:value-of</elcode>. The
                     sequence constructor is evaluated to produce a sequence of two nodes: a
                     parentless attribute node, and a parentless text node. The <code>td</code>
                     instruction causes a <code>td</code> element to be created; the new attribute
                     therefore becomes an attribute of the new <code>td</code> element, while the
                     text node created by the <elcode>xsl:value-of</elcode> instruction becomes a
                     child of the <code>td</code> element (unless it is zero-length, in which case
                     it is discarded).</p>
               </example>
               <example>
                  <head>Space Separators in Element Content</head>
                  <p>Consider the following stylesheet fragment:</p>
                  <eg xml:space="preserve" role="xslt-instruction">&lt;doc&gt;
  &lt;e&gt;&lt;xsl:sequence select="1 to 5"/&gt;&lt;/e&gt;
  &lt;f&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/f&gt;
&lt;/doc&gt;</eg>
                  <p>This produces the output (when indented):</p>
                  <eg xml:space="preserve" role="xml">&lt;doc&gt;
  &lt;e&gt;1 2 3 4 5&lt;/e&gt;
  &lt;f&gt;12345&lt;/f&gt;
&lt;/doc&gt;</eg>
                  <p>The difference between the two cases is that for the <code>e</code> element,
                     the sequence constructor generates a sequence of five atomic values, which are
                     therefore separated by spaces. For the <code>f</code> element, the content is a
                     sequence of five text nodes, which are concatenated without space
                     separation.</p>
                  <p>It is important to be aware of the distinction between
                        <elcode>xsl:sequence</elcode>, which returns the value of its
                        <code>select</code> expression unchanged, and <elcode>xsl:value-of</elcode>,
                     which constructs a text node.</p>
               </example>
            </div3>
            <div3 id="constructing-simple-content">
               <head>Constructing Simple Content</head>
               <p>The instructions <elcode>xsl:attribute</elcode>, <elcode>xsl:comment</elcode>,
                     <elcode>xsl:processing-instruction</elcode>, <elcode>xsl:namespace</elcode>,
                  and <elcode>xsl:value-of</elcode> all create nodes that cannot have children.
                  Specifically, the <elcode>xsl:attribute</elcode> instruction creates an attribute
                  node, <elcode>xsl:comment</elcode> creates a comment node,
                     <elcode>xsl:processing-instruction</elcode> creates a processing instruction
                  node, <elcode>xsl:namespace</elcode> creates a namespace node, and
                     <elcode>xsl:value-of</elcode> creates a text node. The string value of the new
                  node is constructed using either the <code>select</code> attribute of the
                  instruction, or the <termref def="dt-sequence-constructor">sequence
                     constructor</termref> that forms the content of the instruction. The
                     <code>select</code> attribute allows the content to be specified by means of an
                  XPath expression, while the sequence constructor allows it to be specified by
                  means of a sequence of XSLT instructions. The <code>select</code> attribute or
                  sequence constructor is evaluated to produce a result sequence, and the <termref def="dt-string-value">string value</termref> of the new node is derived from
                  this result sequence according to the rules below.</p>
               <p>These rules are also used to compute the <termref def="dt-effective-value">effective value</termref> of a <termref def="dt-value-template">value template</termref>. In this case the
                  sequence being processed is the result of evaluating an XPath expression enclosed
                  between curly brackets, and the separator is a single space character.</p>
               <olist>
                  <item>
                     <p>Zero-length text nodes in the sequence are discarded.</p>
                  </item>
                  <item>
                     <p>Adjacent text nodes in the sequence are merged into a single text node.</p>
                  </item>
                  <item>
                     <p>The sequence is <termref def="dt-atomization">atomized</termref>
                        (which may cause a dynamic error).</p>
                  </item>
                  <item>
                     <p>Every value in the atomized sequence is cast to a string.</p>
                  </item>
                  <item>
                     <p>The strings within the resulting sequence are concatenated, with a (possibly
                        zero-length) separator inserted between successive strings. The default
                        separator depends on the containing instruction; except where
                        otherwise specified, it is a single space.</p>
                     
                     <p>In the case of <elcode>xsl:attribute</elcode>
                        and <elcode>xsl:value-of</elcode>, the default separator is a single space
                     when the <code>select</code> attribute is used, or a zero-length string otherwise; 
                     a different separator can be specified
                        using the <code>separator</code> attribute of the instruction.</p>
                        <p>In the case of <elcode>xsl:comment</elcode>,
                        <elcode>xsl:processing-instruction</elcode>, and
                           <elcode>xsl:namespace</elcode>, and when expanding a <termref def="dt-value-template">value
                        template</termref>, the default separator cannot be changed.</p>
                  </item>
                  <item>
                     <p>In the case of <elcode>xsl:processing-instruction</elcode>, any leading
                        spaces in the resulting string are removed.</p>
                  </item>
                  <item>
                     <p>The resulting string forms the <termref def="dt-string-value">string
                           value</termref> of the new attribute, namespace, comment,
                        processing-instruction, or text node.</p>
                  </item>
               </olist>
               <example>
                  <head>Space Separators in Attribute Content</head>
                  <p>Consider the following stylesheet fragment:</p>
                  <eg xml:space="preserve" role="xslt-instruction">&lt;doc&gt;
  &lt;xsl:attribute name="e" select="1 to 5"/&gt;
  &lt;xsl:attribute name="f"&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="g" expand-text="yes"&gt;{1 to 5}&lt;/xsl:attribute&gt;
&lt;/doc&gt;</eg>
                  <p>This produces the output:</p>
                  <eg xml:space="preserve" role="xml">&lt;doc e="1 2 3 4 5" f="12345" g="1 2 3 4 5"/&gt;</eg>
                  <p>The difference between the three cases is as follows. For the
                        <code>e</code> attribute, the sequence constructor generates a sequence of
                     five atomic values, which are therefore separated by spaces. For the
                        <code>f</code> attribute, the content is supplied as a sequence of five text
                     nodes, which are concatenated without space separation. For the <code>g</code>
                     attribute, the <termref def="dt-text-value-template"/> constructs a text node
                     using the rules for constructing simple content, which insert space separators
                     between atomic values; the text node is then atomized to form the value of the
                     attribute.</p>
                  <p>Specifying <code>separator=""</code> on the first
                        <elcode>xsl:attribute</elcode> instruction would cause the attribute value
                     to be <code>e="12345"</code>. A <code>separator</code> attribute on the second
                        <elcode>xsl:attribute</elcode> instruction would have no effect, since the
                     separator only affects the way adjacent atomic values are handled: separators
                     are never inserted between adjacent text nodes. A
                           <code>separator</code> on the third <elcode>xsl:attribute</elcode>
                        instruction would also have no effect, because text value templates are
                        evaluated without regard to the containing instruction.</p>
               </example>
               <note>
                  <p>If an attribute value template contains a sequence of fixed and variable parts,
                     no additional whitespace is inserted between the expansions of the fixed and
                     variable parts. For example, the <termref def="dt-effective-value">effective
                        value</termref> of the attribute <code>a="chapters{4 to 6}"</code> is
                        <code>a="chapters4 5 6"</code>.</p>
               </note>
            </div3>
            <div3 id="namespace-fixup">
               <head>Namespace Fixup</head>
               <p>In a tree supplied to or constructed by an XSLT processor, the constraints
                  relating to namespace nodes that are specified in <bibref ref="xpath-datamodel-30"/>
                  <rfc2119>must</rfc2119> be satisfied. For example:</p>
               <ulist>
                  <item>
                     <p>If an element node has an <termref def="dt-expanded-qname">expanded
                           QName</termref> with a non-null namespace URI, then that element node
                           <rfc2119>must</rfc2119> have at least one namespace node whose <termref def="dt-string-value">string value</termref> is the same as that
                        namespace URI.</p>
                  </item>
                  <item>
                     <p>If an element node has an attribute node whose <termref def="dt-expanded-qname">expanded QName</termref> has a non-null namespace
                        URI, then the element <rfc2119>must</rfc2119> have at least one namespace
                        node whose <termref def="dt-string-value">string value</termref> is the same
                        as that namespace URI and whose name is non-empty.</p>
                  </item>
                  <item>
                     <p>Every element <rfc2119>must</rfc2119> have a namespace node whose <termref def="dt-expanded-qname">expanded QName</termref> has local-part
                           <code>xml</code> and whose <termref def="dt-string-value">string
                           value</termref> is <code>http://www.w3.org/XML/1998/namespace</code>. The
                        namespace prefix <code>xml</code>
                        <rfc2119>must</rfc2119> not be associated with any other namespace URI, and
                        the namespace URI <code>http://www.w3.org/XML/1998/namespace</code>
                        <rfc2119>must</rfc2119> not be associated with any other prefix.</p>
                  </item>
                  <item>
                     <!--Text replaced by erratum E6 change 7"-->
                     <p>A namespace node <rfc2119>must not</rfc2119> have the name
                           <code>xmlns</code> or the string value
                           <code>http://www.w3.org/2000/xmlns/</code>.</p>
                     <!--End of text replaced by erratum E6-->
                  </item>
               </ulist>
               <p>
                  <termdef id="dt-namespace-fixup" term="namespace fixup">The rules for the
                     individual XSLT instructions that construct a <termref def="dt-result-tree">result tree</termref> (see <specref ref="creating-new-nodes"/>) prescribe
                     some of the situations in which namespace nodes are written to the tree. These
                     rules, however, are not sufficient to ensure that the prescribed constraints
                     are always satisfied. The XSLT processor <rfc2119>must</rfc2119> therefore add
                     additional namespace nodes to satisfy these constraints. This process is
                     referred to as <term>namespace fixup</term>.</termdef>
               </p>
               <p>The actual namespace nodes that are added to the tree by the namespace fixup
                  process are <termref def="dt-implementation-dependent">implementation-dependent</termref>, provided firstly, that at the end of the
                  process the above constraints <rfc2119>must</rfc2119> all be satisfied, and
                  secondly, that a namespace node <rfc2119>must not</rfc2119> be added to the tree
                  unless the namespace node is necessary either to satisfy these constraints, or to
                  enable the tree to be serialized using the original namespace prefixes from the
                  source document or <termref def="dt-stylesheet">stylesheet</termref>.</p>
               <p>Namespace fixup <rfc2119>must not</rfc2119> result in an element having multiple
                  namespace nodes with the same name.</p>
               <p>Namespace fixup <rfc2119>may</rfc2119>, if necessary to resolve conflicts, change
                  the namespace prefix contained in the QName value that holds the name of an
                  element or attribute node. This includes the option to add or remove a prefix.
                  However, namespace fixup <rfc2119>must not</rfc2119> change the prefix component
                  contained in a value of type <code>xs:QName</code> or <code>xs:NOTATION</code>
                  that forms the typed value of an element or attribute node.</p>
               <note>
                  <p>Namespace fixup is not used to create namespace declarations for
                        <code>xs:QName</code> or <code>xs:NOTATION</code> values appearing in the
                     content of an element or attribute.</p>
                  <p>Where values acquire such types as the result of validation, namespace fixup
                     does not come into play, because namespace fixup happens before validation: in
                     this situation, it is the user’s responsibility to ensure that the
                     element being validated has the required namespace nodes to enable validation
                     to succeed.</p>
                  <p>Where existing elements are copied along with their existing <termref def="dt-type-annotation">type annotations</termref>
                        (<code>validation="preserve"</code>) the rules require that existing
                     namespace nodes are also copied, so that any namespace-sensitive values remain
                     valid.</p>
                  <p>Where existing attributes are copied along with their existing type
                     annotations, the rules of the XDM data model require that a parentless
                     attribute node cannot contain a namespace-sensitive typed value; this means
                     that it is an error to copy an attribute using
                        <code>validation="preserve"</code> if it contains namespace-sensitive
                     content.</p>
               </note>
               <p>Namespace fixup is applied to every element that is constructed using a <termref def="dt-literal-result-element">literal result element</termref>, or one of the
                  instructions <elcode>xsl:element</elcode>, <elcode>xsl:copy</elcode>, or
                     <elcode>xsl:copy-of</elcode>. An implementation is not
                     <rfc2119>required</rfc2119> to perform namespace fixup for elements in any
                  source document, that is, for a document in the <termref def="dt-initial-match-selection"/>, documents loaded using the
                     <function>document</function>, <xfunction>doc</xfunction> or
                     <xfunction>collection</xfunction> function, documents supplied as the value of
                  a <termref def="dt-stylesheet-parameter">stylesheet parameter</termref>, or
                  documents returned by an <termref def="dt-extension-function">extension
                     function</termref> or <termref def="dt-extension-instruction">extension
                     instruction</termref>.</p>
               <note>
                  <p>A source document (an input document, a document returned by the
                        <function>document</function>, <xfunction>doc</xfunction> or
                        <xfunction>collection</xfunction> functions, a document returned by an
                     extension function or extension instruction, or a document supplied as a
                     stylesheet parameter) is required to satisfy the constraints described in
                        <bibref ref="xpath-datamodel-30"/>, including the constraints imposed by the
                     namespace fixup process. The effect of supplying a pseudo-document that does
                     not meet these constraints is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
               </note>
               <p>In an Infoset (see <bibref ref="xml-infoset"/>) created from a document conforming
                  to <bibref ref="xml-names"/>, it will always be true that if a parent element has
                  an in-scope namespace with a non-empty namespace prefix, then its child elements
                  will also have an in-scope namespace with the same namespace prefix, though
                  possibly with a different namespace URI. This constraint is removed in <bibref ref="xml-names11"/>. XSLT 4.0 supports the
                  creation of result trees that do not satisfy this constraint: the namespace fixup
                  process does not add a namespace node to an element merely because its parent node
                  in the <termref def="dt-result-tree">result tree</termref> has such a namespace
                  node. However, the process of constructing the children of a new element, which is
                  described in <specref ref="constructing-complex-content"/>, does cause the
                  namespaces of a parent element to be inherited by its children unless this is
                  prevented using <code>[xsl:]inherit-namespaces="no"</code> on the instruction that
                  creates the parent element.</p>
               <note>
                  <p>This has implications on serialization, defined in <bibref ref="xslt-xquery-serialization-30"/>. It means that it is possible to create
                        <termref def="dt-final-result-tree">final result trees</termref> that cannot
                     be faithfully serialized as XML 1.0 documents. When such a result tree is
                     serialized as XML 1.0, namespace declarations written for the parent element
                     will be inherited by its child elements as if the corresponding namespace nodes
                     were present on the child element, except in the case of the default namespace,
                     which can be undeclared using the construct <code>xmlns=""</code>. When the
                     same result tree is serialized as XML 1.1, however, it is possible to undeclare
                     any namespace on the child element (for example, <code>xmlns:foo=""</code>) to
                     prevent this inheritance taking place.</p>
               </note>
            </div3>
         </div2>
         <div2 id="uri-references">
            <head>URI References</head>
            <p>
               <termdef id="dt-uri-reference" term="URI Reference">Within this specification, the
                  term <term>URI Reference</term>, unless otherwise stated, refers to a string in
                  the lexical space of the <code>xs:anyURI</code> datatype as defined in <bibref ref="xmlschema-2"/>.</termdef> Note that this is a wider definition than that
               in <bibref ref="RFC3986"/>: in particular, it is designed to accommodate
               Internationalized Resource Identifiers (IRIs) as described in <bibref ref="RFC3987"/>, and thus allows the use of non-ASCII characters without escaping.</p>
            <p>URI References are used in XSLT with three main roles:</p>
            <ulist>
               <item>
                  <p>As namespace URIs</p>
               </item>
               <item>
                  <p>As collation URIs</p>
               </item>
               <item>
                  <p>As identifiers for resources such as stylesheet modules; these resources are
                     typically accessible using a protocol such as HTTP. Examples of such
                     identifiers are the URIs used in the <code>href</code> attributes of
                        <elcode>xsl:import</elcode>, <elcode>xsl:include</elcode>, and
                        <elcode>xsl:result-document</elcode>.</p>
               </item>
            </ulist>
            <p>The rules for namespace URIs are given in <bibref ref="xml-names"/> and <bibref ref="xml-names11"/>. Those specifications deprecate the use of relative URI
                  references as namespace URIs.</p>
            <p>The rules for collation URIs are given in <bibref ref="xpath-functions-40"/>.</p>
            <p>URI references used to identify external resources must conform to the same rules as
               the locator attribute (<code>href</code>) defined in section 5.4 of <bibref ref="xlink"/>. If the URI reference is relative, then it is resolved (unless
               otherwise specified) against the base URI of the containing element node, according
               to the rules of <bibref ref="RFC3986"/>, after first escaping all characters that
               need to be escaped to make it a valid RFC3986 URI reference. (But a relative URI
                  reference in the <code>href</code> attribute of
                  <elcode>xsl:result-document</elcode> is resolved against the <termref def="dt-base-output-uri">Base Output URI</termref>.)</p>
            <p>Other URI references appearing in an XSLT stylesheet document, for example the system
               identifiers of external entities or the value of the <code>xml:base</code> attribute,
               must follow the rules in their respective specifications.</p>
            <p><!--bug 17595-->The base URI of an element node in the stylesheet
               is determined as defined in <xspecref spec="DM30" ref="dm-base-uri"/>. Some
               implementations may allow the output of the static analysis phase of stylesheet
               processing (a “compiled stylesheet”) to be evaluated in a different location from
               that where static analysis took place. Furthermore, stylesheet authors may in such
               cases wish to avoid exposing the location of resources that are private to the
               development environment. If the base URI of an element in the stylesheet is defined
               by an absolute URI appearing in an <code>xml:base</code> attribute within the
               stylesheet, this value <rfc2119>must</rfc2119> be used as the static base URI. In
               other cases where processing depends on the static base URI of a stylesheet module,
               implementations <rfc2119>may</rfc2119> use different values for the static base URI
               during static analysis and during dynamic evaluation (for example, an implementation
                  <rfc2119>may</rfc2119> use different base URIs for resolving
                  <elcode>xsl:import</elcode> module references and for resolving a relative
               reference used as an argument to the <xfunction>doc</xfunction> function). In such
               cases an implementation <rfc2119>must</rfc2119> document how the static base URI is
               computed for each situation in which it is required. </p>

         </div2>
      </div1>
      <div1 id="rules">
         <head>Template Rules</head>
         <p>Template rules define the processing that can be applied to items that match a particular <termref def="dt-pattern">pattern</termref>.</p>
         <div2 id="defining-templates">
            <head>Defining Templates</head>
            <?element xsl:template?>
            <p>
               <termdef id="dt-template" term="template">An <elcode>xsl:template</elcode>
                  declaration defines a <term>template</term>, which contains a <termref def="dt-sequence-constructor">sequence constructor</termref>;
                  this sequence constructor is evaluated to determine
                     the result of the template. A template can serve either as a <termref def="dt-template-rule">template rule</termref>, invoked by matching items against a <termref def="dt-pattern">pattern</termref>, or as a <termref def="dt-named-template">named
                     template</termref>, invoked explicitly by name. It is also possible for the
                  same template to serve in both capacities.</termdef>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="0500">
                  <p>An <elcode>xsl:template</elcode> element <rfc2119>must</rfc2119> have either a
                        <code>match</code> attribute or a <code>name</code> attribute, or both. An
                        <elcode>xsl:template</elcode> element that has no <code>match</code>
                     attribute <rfc2119>must</rfc2119> have no <code>mode</code> attribute and no
                        <code>priority</code> attribute. An
                           <elcode>xsl:template</elcode> element that has no <code>name</code>
                        attribute <rfc2119>must</rfc2119> have no <code>visibility</code>
                        attribute.</p>
               </error>
            </p>
            <p>If an <elcode>xsl:template</elcode> element has a <code>match</code> attribute, then
               it is a <termref def="dt-template-rule">template rule</termref>. If it has a
                  <code>name</code> attribute, then it is a <termref def="dt-named-template">named
                  template</termref>.</p>
            <p>A <termref def="dt-template">template</termref> may be invoked in a number of ways,
               depending on whether it is a <termref def="dt-template-rule">template rule</termref>,
               a <termref def="dt-named-template">named template</termref>, or both. The result of
               invoking the template is the result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> contained in the
                  <elcode>xsl:template</elcode> element (see <specref ref="sequence-constructors"/>).</p>

            <p>For details of the optional <elcode>xsl:context-item</elcode> child
               element, see <specref ref="declaring-context-item"/>.</p>


            <p>If an <code>as</code> attribute of the <elcode>xsl:template</elcode> element is
               present, the <code>as</code> attribute defines the required type of the result. The
               result of evaluating the <termref def="dt-sequence-constructor">sequence
                  constructor</termref> is then converted to the required type using the 
               <termref def="dt-coercion-rules"/>. If no
                  <code>as</code> attribute is specified, the default value is <code>item()*</code>,
               which permits any value. No conversion then takes place.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0505">
                  <p>It is a <termref def="dt-type-error">type error</termref> if the result of
                     evaluating the <termref def="dt-sequence-constructor">sequence
                        constructor</termref> cannot be converted to the required type.</p>
               </error>
            </p>

            <p>If the <code>visibility</code> attribute is present with the value
                  <code>abstract</code> then (a) the <termref def="dt-sequence-constructor"/>
               defining the template body <rfc2119>must</rfc2119> be empty: that is, the only
               permitted children are <elcode>xsl:context-item</elcode> and
                  <elcode>xsl:param</elcode>, and (b) there <rfc2119>must</rfc2119> be no
                  <code>match</code> attribute.</p>
            <!--<p diff="add" at="I">If the parent of the <elcode>xsl:template</elcode> element is an
                  <elcode>xsl:override</elcode> element, then there must be a <code>name</code>
               attribute and no <code>match</code> attribute, and the <termref def="dt-package"
                  >package</termref> that is the target of the containing
                  <elcode>xsl:use-package</elcode> element must contain among its <termref
                  def="dt-component">components</termref> a <termref def="dt-named-template">named
                  template</termref> whose <termref def="dt-symbolic-identifier">symbolic
                  identifier</termref> is the same as this named template, and which has a <termref
                  def="dt-compatible">compatible</termref> signature.</p>-->
            
            <p>If the parent of the <elcode>xsl:template</elcode> element is an
               <elcode>xsl:override</elcode> element, then either or both of the following conditions
               must be true:</p>
            <olist>
               <item><p>There is a <code>name</code> attribute, and the <termref def="dt-package">package</termref> identified by the containing
                  <elcode>xsl:use-package</elcode> element contains among its <termref def="dt-component">components</termref> a <termref def="dt-named-template">named
                        template</termref> whose <termref def="dt-symbolic-identifier">symbolic
                           identifier</termref> is the same as that of this named template, and which has a <termref def="dt-compatible">compatible</termref> signature.</p></item>
               <item><p>Both the following conditions are true:</p>
                  <olist>
                     <item><p>There is a <code>match</code> attribute.</p></item>
                     <item><p>The value of the <code>mode</code> attribute,
                        or in its absence the string <code>#default</code>,
                        is a whitespace-separated sequence of tokens in which each token satisfies
                        one of the following conditions:</p>
                        <olist>
                           <item><p>The token is an EQName representing the name of a mode that is exposed,
                           with visibility equal to <code>public</code>, by the package identified by the containing
                           <elcode>xsl:use-package</elcode> element.</p></item>
                           <item><p>The token is <code>#default</code>, and there is an ancestor-or-self element with
                              a <code>default-mode</code> attribute whose value is an EQName representing the name of a mode that is exposed,
                              with visibility equal to <code>public</code>, by the package identified by the containing
                              <elcode>xsl:use-package</elcode> element.</p></item>
                        </olist>
                     </item>
                  </olist>
                  <note><p>The token <code>#unnamed</code> is not allowed because the unnamed mode never has public visibility. 
                     The token <code>#all</code> is not allowed because its intended meaning would not be obvious.
                  </p></note>
               </item>
            </olist>
         </div2>
         <div2 id="defining-template-rules">
            <head>Defining Template Rules</head>
            <p>This section describes <termref def="dt-template-rule">template rules</termref>.
                  <termref def="dt-named-template">Named templates</termref> are described in
                  <specref ref="named-templates"/>.</p>
            <p>A <termref def="dt-template-rule">template rule</termref> is specified using the
                  <elcode>xsl:template</elcode> element with a <code>match</code> attribute. The
                  <code>match</code> attribute is a <nt def="Pattern40">Pattern</nt> that identifies
               the items to which the rule applies. The result of
               applying the template rule is the result of evaluating the sequence constructor
               contained in the <elcode>xsl:template</elcode> element, with the matching item used as the <termref def="dt-context-item">context item</termref>.</p>
            <example>
               <head>A Simple Template Rule</head>
               <p>For example, an XML document might contain:</p>
               <eg xml:space="preserve" role="xml">This is an &lt;emph&gt;important&lt;/emph&gt; point.</eg>
               <p>The following <termref def="dt-template-rule">template rule</termref> matches
                     <code>emph</code> elements and produces a <code>fo:wrapper</code> element with
                  a <code>font-weight</code> property of <code>bold</code>.</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="emph"&gt;
  &lt;fo:wrapper font-weight="bold" 
              xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;
</eg>
            </example>
            <p>A <termref def="dt-template-rule">template rule</termref> is evaluated when an
                  <elcode>xsl:apply-templates</elcode> instruction selects an item that matches the pattern specified in the <code>match</code>
               attribute. The <elcode>xsl:apply-templates</elcode> instruction is described in the
               next section. If several template rules match a selected item, only one of them is evaluated, as described in <specref ref="conflict"/>.</p>
         </div2>
         <div2 id="applying-templates">
            <head>Applying Template Rules</head>
            <?element xsl:apply-templates?>
            <p>The <elcode>xsl:apply-templates</elcode> instruction takes as input a sequence of
                  items (typically nodes in a <termref def="dt-source-tree">source tree</termref>), and produces as output a sequence of
               items; these will often be nodes to be added to a <termref def="dt-result-tree">result tree</termref>.</p>
            <p>If the instruction has one or more <elcode>xsl:sort</elcode> children, then the input
               sequence is sorted as described in <specref ref="sorting"/>. The result of this sort
               is referred to below as the <term>sorted sequence</term>; if there are no
                  <elcode>xsl:sort</elcode> elements, then the sorted sequence is the same as the
               input sequence.</p>
            <p>Each item in the input sequence is processed by
               finding a <termref def="dt-template-rule">template rule</termref> whose <termref def="dt-pattern">pattern</termref> matches that item. If there is more than one such template rule, the best among them
               is chosen, using rules described in <specref ref="conflict"/>. If there is no
               template rule whose pattern matches the item, a
               built-in template rule is used (see <specref ref="built-in-rule"/>). The chosen
               template rule is evaluated. The rule that matches the <var>N</var>th item in the sorted sequence is evaluated with that
                  item as the <termref def="dt-context-item">context item</termref>, with <var>N</var> as the <termref def="dt-context-position">context position</termref>, and with the length of the
               sorted sequence as the <termref def="dt-context-size">context size</termref>. Each
               template rule that is evaluated produces a sequence of items as its result. The
               resulting sequences (one for each item in the
               sorted sequence) are then concatenated, to form a single sequence. They are
               concatenated retaining the order of the items in
               the sorted sequence. The final concatenated sequence forms the result of the
                  <elcode>xsl:apply-templates</elcode> instruction. </p>
            <example>
               <head>Applying Template Rules</head>
               <p>Suppose the source document is as follows:</p>
               <eg xml:space="preserve" role="xml">&lt;message&gt;Proceed &lt;emph&gt;at once&lt;/emph&gt; to the exit!&lt;/message&gt;</eg>
               <p>This can be processed using the two template rules shown below.</p>
               <eg xml:space="preserve" role="xslt-declarations">&lt;xsl:template match="message"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="emph"&gt;
  &lt;b&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/b&gt;
&lt;/xsl:template&gt;</eg>
               <p>There is no template rule for the document node; the built-in template rule for
                  this node will cause the <code>message</code> element to be processed. The
                  template rule for the <code>message</code> element causes a <code>p</code> element
                  to be written to the <termref def="dt-result-tree">result tree</termref>; the
                  contents of this <code>p</code> element are constructed as the result of the
                     <elcode>xsl:apply-templates</elcode> instruction. This instruction selects the
                  three child nodes of the <code>message</code> element (a text node containing the
                  value <code>Proceed </code>, an <code>emph</code> element node, and a text node
                  containing the value <code> to the exit!</code>). The two text nodes are
                  processed using the built-in template rule for text nodes, which returns a copy of
                  the text node. The <code>emph</code> element is processed using the explicit
                  template rule that specifies <code>match="emph"</code>.</p>
               <p>When the <code>emph</code> element is processed, this template rule constructs a
                     <code>b</code> element. The contents of the <code>b</code> element are
                  constructed by means of another <elcode>xsl:apply-templates</elcode> instruction,
                  which in this case selects a single node (the text node containing the value
                     <code>at once</code>). This is again processed using the built-in template
                  rule for text nodes, which returns a copy of the text node.</p>
               <p>The final result of the <code>match="message"</code> template rule thus consists
                  of a <code>p</code> element node with three children: a text node containing the
                  value <code>Proceed </code>, a <code>b</code> element that is the parent of a
                  text node containing the value <code>at once</code>, and a text node containing
                  the value <code> to the exit!</code>. This <termref def="dt-result-tree">result
                     tree</termref> might be serialized as:</p>
               <eg xml:space="preserve" role="xml">&lt;p&gt;Proceed &lt;b&gt;at once&lt;/b&gt; to the exit!&lt;/p&gt;</eg>
            </example>
            <p>The default value of the <code>select</code> attribute is <code>child::node()</code>,
               which causes all the children of the context node to be processed.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0510">
                  <p>It is a <termref def="dt-type-error">type error</termref> if an
                        <elcode>xsl:apply-templates</elcode> instruction with no <code>select</code>
                     attribute is evaluated when the <termref def="dt-context-item">context
                        item</termref> is not a node. </p>
               </error>
            </p>
            <p>A <code>select</code> attribute can be used to process items selected by an expression instead of processing all children. The
               value of the <code>select</code> attribute is an <termref def="dt-expression">expression</termref>. </p>
            
            
            <example>
               <head>Applying Templates to Selected Nodes</head>
               <p>The following example processes all of the <code>given-name</code> children of the
                     <code>author</code> elements that are children of
                  <code>author-group</code>:</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template match="author-group"&gt;
  &lt;fo:wrapper&gt;
    &lt;xsl:apply-templates select="author/given-name"/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Applying Templates to Nodes that are not Descendants</head>
               <p>It is also possible to process elements that are not descendants of the context
                  node. This example assumes that a <code>department</code> element has
                     <code>group</code> children and <code>employee</code> descendants. It finds an
                  employee’s department and then processes the <code>group</code> children of
                  the <code>department</code>.</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template match="employee"&gt;
  &lt;fo:block&gt;
    Employee &lt;xsl:apply-templates select="name"/&gt; belongs to group
    &lt;xsl:apply-templates select="ancestor::department/group"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Matching Nodes by Schema-Defined Types</head>
               <p>It is possible to write template rules that are matched according to the
                  schema-defined type of an element or attribute. The following example applies
                  different formatting to the children of an element depending on their type:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="3"&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;xsl:value-of select="name()"/&gt;&lt;/td&gt;
    &lt;td&gt;&lt;xsl:next-match/&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:decimal) | 
                     product/element(*, xs:double)" priority="2"&gt;  
  &lt;xsl:value-of select="format-number(xs:double(.), '#,###0.00')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:date)" priority="2"&gt;
  &lt;xsl:value-of select="format-date(., '[Mn] [D], [Y]')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="1.5"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;</eg>
               <p>The <elcode>xsl:next-match</elcode> instruction is described in <specref ref="apply-imports"/>.</p>
            </example>
            <example>
               <head>Re-ordering Elements in the Result Tree</head>
               <p>Multiple <elcode>xsl:apply-templates</elcode> elements can be used within a single
                  template to do simple reordering. The following example creates two HTML tables.
                  The first table is filled with domestic sales while the second table is filled
                  with foreign sales.</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/domestic"/&gt;
  &lt;/table&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/foreign"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Processing Recursive Structures</head>
               <p>It is possible for there to be two matching descendants where one is a descendant
                  of the other. This case is not treated specially: both descendants will be
                  processed as usual.</p>
               <p> For example, given a source document</p>
               <eg xml:space="preserve" role="xml">&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;</eg>
               <p>the rule</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="doc"&gt;
  &lt;xsl:apply-templates select=".//div"/&gt;
&lt;/xsl:template&gt;</eg>
               <p>will process both the outer <code>div</code> and inner <code>div</code>
                  elements.</p>
               <p>This means that if the template rule for the <code>div</code> element processes
                  its own children, then these grandchildren will be processed more than once, which
                  is probably not what is required. The solution is to process one level at a time
                  in a recursive descent, by using <code>select="div"</code> in place of
                     <code>select=".//div"</code>
               </p>
            </example>
            <example>
               <head>Applying Templates to Atomic Values</head>
               <p>This example reads a non-XML text file and processes it line-by-line, applying
                  different template rules based on the content of each line:</p>
               <eg xml:space="preserve" role="xslt-declarations" diff="chg" at="A">&lt;xsl:template name="main"&gt;
  &lt;xsl:apply-templates select="unparsed-text-lines('input.txt')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="type(xs:string)[starts-with(., '==')]"&gt;
  &lt;h2&gt;&lt;xsl:value-of select="replace(., '==', '')"/&gt;&lt;/h2&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="type(xs:string)[starts-with(., '::')]"&gt;
  &lt;p class="indent"&gt;&lt;xsl:value-of select="replace(., '::', '')"/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="type(xs:string)"&gt;
  &lt;p class="body"&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

</eg>
            </example>
            <example>
               <head>Applying Templates to JSON Documents</head>
               <p>This example reads a JSON data file and formats it as XHTML.</p>
               <p>It takes the following JSON data as input:</p>
               <eg>[
  { "Title": "Computer Architecture",
    "Authors": ["Enid Blyton"]
    "Category": "Computers",
    "Price": 42.60
  },
  { "Title": "How to Win Elections",
    "Authors": ["Donald Trump", "Boris Johnson"],
    "Category": "Politics",
    "Price": 56.00
  },
  {  "Title": "How to Explore Outer Space with Binoculars",
     "Authors: ["Bruce Betts", "Erica Colon"]
     "Category": "Science",
     "Price": 10.40
  }
]</eg>
               <p>The following template rules are used. The settings <code>expand-text="yes"</code> 
                  and <code>default-type-namespace="http://www.w3.org/2001/XMLSchema"</code> are assumed:</p>
               <eg><![CDATA[
<xsl:item-type name="book" as="record(Title, Authors, Category, *)"/>                  
<xsl:template name="xsl:initial-template">
  <xsl:apply-templates select="parse-json('input.json')"/>
</xsl:template>  
<xsl:template match="array(book)">
  <h1>Christmas Book Selection</h1>
  <table>
    <thead>
       <tr>
         <th>Title</th>
         <th>Authors</th>
         <th>Category</th>
         <th>Price</th>
       </tr>
    </thead>
    <tbody>
      <xsl:apply-templates select="?*">
    </tbody>
  </table>
</xsl:template>
<xsl:template match="type(book)">
  <tr>
    <td>{?Title}</td>
    <td>{?Authors?* => string-join(", ")}</td>
    <td>{?Category}</td>
    <td>${?Price}</td>
  </tr>
</xsl:template>  
]]></eg>
            </example>
            <note>
               <p>The <elcode>xsl:apply-templates</elcode> instruction is most commonly used to
                  process nodes that are descendants of the context node. Such use of
                     <elcode>xsl:apply-templates</elcode> cannot result in non-terminating
                  processing loops. However, when <elcode>xsl:apply-templates</elcode> is used to
                  process elements that are not descendants of the context node, the possibility
                  arises of non-terminating loops. For example,</p>
               <eg role="error" xml:space="preserve">&lt;xsl:template match="foo"&gt;
  &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:template&gt;</eg>
               <p>Implementations may be able to detect such loops in some cases, but the
                  possibility exists that a <termref def="dt-stylesheet">stylesheet</termref> may
                  enter a non-terminating loop that an implementation is unable to detect. This may
                  present a denial of service security risk.</p>
            </note>
         </div2>
         <div2 id="apply-templates-separator" diff="add" at="A">
            <head>The <code>separator</code> attribute</head>
            
            <p>If the <code>separator</code> attribute of <elcode>xsl:apply-templates</elcode>
               is present, then its <termref def="dt-effective-value"/>
               is inserted, as a text node, into the output sequence, immediately after the results of processing each item in the sorted
               sequence other than the last.</p>
            <p>For example, if the <code>ARTICLE</code> element has a number of element children named <code>AUTHOR</code>,
               the following code will produce a sorted, comma-separated list of authors:</p>
            <eg><![CDATA[
<xsl:template match="ARTICLE">
  <article>
     ...
     <xsl:text>Author(s): </xsl:text>
     <xsl:apply-templates select="AUTHOR" separator=", ">
       <xsl:sort select="LAST-NAME"/>
       <xsl:sort select="FIRST-NAME"/>
     </xsl:apply-templates>
     ...
  </article>
</xsl:template>
<xsl:template match="AUTHOR" expand-text="yes">
  <xsl:text>{FIRST-NAME} {LAST-NAME}</xsl:text>
</xsl:template>  
 ]]></eg>
            
            <p>The node identity of any text nodes that are inserted is <termref def="dt-implementation-dependent"/>. Specifically,
               it is not defined whether all the text nodes inserted in the course of one evaluation of the instruction are identical
               to each other, nor whether they are identical to the text nodes inserted in the course of another evaluation of this
               instruction, nor whether they are identical to any other parentless text nodes having the same string value.</p>
            <p>If the separator is a zero-length string, then a zero-length text node is inserted into the sequence. (If the
               sequence is used for constructing the value of a node, then zero-length text nodes will be discarded: see
               <specref ref="constructing-simple-content"/> and <specref ref="constructing-complex-content"/>.)</p>
         </div2>
         <!--<div2 id="template-test" diff="add" at="A">
            <head>The <code>test</code> Attribute</head>
            <p>If a template rule has a <code>test</code> attribute, then its value is an <termref def="dt-expression"/>,
               and the template rule is a candidate for evaluation only if the <code>test</code> condition is true.
               The <code>test</code> condition has access to the values of all the parameters declared in the called template,
               both tunnel and non-tunnel parameters.</p>
            <p>This mechanism allows the applicability of a template rule to be depend not only on the match pattern applied
               to the item selected for processing, but also on the context in which the evaluation takes place.
               It is especially useful when processing structures derived from JSON (maps and arrays), because unlike
               nodes, there is no parent or ancestor axis that can be used in the <code>match</code> pattern
               to examine items in the enclosing tree.</p>
            <example id="e-template-test-conditions">
            <p>For example, consider the JSON structure:</p>
            <eg>
{ "order": {
    "shipping-address": {
         "first-line": "10 Downing Street",
         "second-line": "Westminster",
         "city": "London",
         "postcode": "SW1A 2AA"
   },
   "billing-address": {
         "first-line": "Buckingham Palace",
         "city": "London",
         "postcode": "SW1A 1AA"
   }
}
            </eg>
            <p>The two addresses can both be matched with the pattern <code>match="record(first-line, city, postcode, *)"</code>,
               but if they are to be handled using different template rules, then it is difficult to write match patterns
               that distinguish them, because the pattern cannot refer to ancestor information in the tree. This can be solved
               by having the calling code set a tunnel parameter <code>$address-role</code> to <code>"shipping"</code> or
               <code>"billing"</code>, and using the attributes <code>test="$address-role='shipping'"</code> and 
               <code>test="$address-role='billing'"</code> respectively on the two template rules.</p>
            </example>
            <p>The expression in the <code>test</code> condition is evaluated as follows:</p>
            <olist>
               <item><p>The static context includes all variables listed in the body of the template rule using
               <elcode>xsl:param</elcode> with <code>tunnel="yes"</code>. It also includes all visible global variables
                  (unless shadowed by a tunnel parameter) and all stylesheet functions.</p></item>
               <item><p>The dynamic context includes all the values for the global variables and the values
               for tunnel parameters, including those set by the calling instruction (such as <code>xsl:apply-templates</code>)
               as well as any that are carried over from outer callers.</p></item>
               <item><p>The focus for evaluation is absent. In particular, the <code>test</code> expression does
               not have access to the item that is being matched.</p></item>
               <item><p>The available documents, available text resources, available collections, and available URI
               collections are all empty.</p></item>
            </olist>
            <p>If the test condition evaluates to false, or if evaluation fails, then the template rule is not a candidate
            for matching.</p>
            <note>
               <p>When an <elcode>xsl:apply-templates</elcode> instruction selects multiple items for processing, the values
               of tunnel parameters will be the same for each one, and the set of eligible template rules will therefore
               also be the same for each one. The <code>test</code> conditions therefore do not need to be re-evaluated
               for each item being processed.</p>
            </note>
            <p>When an <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> instruction is evaluated,
            the values of tunnel parameters may change, and the set of eligible template rules may therefore also change.</p>
         </div2>-->
            
        
         <div2 id="conflict">
            <head>Conflict Resolution for Template Rules</head>
            <p>It is possible for a selected item to match more
               than one <termref def="dt-template-rule">template rule</termref> with a given
                  <termref def="dt-mode">mode</termref>
               <var>M</var>. When this happens, only one template rule is evaluated for the item. The template rule to be used is determined as
               follows:</p>
            <olist>
               <item>
                  <p>First, only the matching template rule or rules with the highest <termref def="dt-import-precedence">import precedence</termref> are considered. Other
                     matching template rules with lower precedence are eliminated from
                     consideration.</p>
               </item>
               <item>
                  <p>Next, of the remaining matching rules, only those with the highest priority are
                     considered. Other matching template rules with lower priority are eliminated
                     from consideration.</p>
                  <p><termdef term="priority" id="dt-priority">The <term>priority</term> of a
                        template rule is specified by the <code>priority</code> attribute on the
                           <elcode>xsl:template</elcode> declaration. If no priority is specified
                        explicitly for a template rule, its <termref def="dt-default-priority">default priority</termref> is used, as defined in <specref ref="default-priority"/>.</termdef></p>
                  <p>
                     <error spec="XT" type="static" class="SE" code="0530">
                        <p>The value of the <code>priority</code> attribute <error.extra> of the
                                 <elcode>xsl:template</elcode> element</error.extra>
                           <rfc2119>must</rfc2119> conform to the rules for the
                              <code>xs:decimal</code> type defined in <bibref ref="xmlschema-2"/>.
                           Negative values are permitted.</p>
                     </error>
                  </p>

               </item>

               <item>
                  <p>If this leaves more than one matching template rule, then:</p>
                  <olist>
                     <item>
                        <p>If the <termref def="dt-mode">mode</termref>
                           <var>M</var> has an <elcode>xsl:mode</elcode> declaration, and the
                           attribute value <code>on-multiple-match="fail"</code> is specified in the
                           mode declaration, a dynamic error is signaled. The error is treated as
                           occurring in the <elcode>xsl:apply-templates</elcode> instruction, and
                           can be recovered by wrapping that instruction in an
                              <elcode>xsl:try</elcode> instruction.</p>
                        <p>
                           <error spec="XT" type="dynamic" class="DE" code="0540">
                              <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the
                                 conflict resolution algorithm for template rules leaves more than
                                 one matching template rule  when the
                                    declaration of the relevant <termref def="dt-mode">mode</termref> has an <code>on-multiple-match</code>
                                    attribute with the value <code>fail</code>.</p>
                           </error></p>
                     </item>
                     <item>
                        <p>Otherwise, of the matching template rules that remain, the one that
                           occurs last in <termref def="dt-declaration-order">declaration
                              order</termref> is used.</p>
                     </item>
                  </olist>

                  <note>
                     <p>This was a recoverable error in XSLT 2.0, meaning that it was
                        implementation-defined whether the error was signaled, or whether the
                        ambiguity was resolved by taking the last matching rule in declaration
                        order.  In XSLT 3.0 this situation is not an error unless the
                        attribute value <code>on-multiple-match="fail"</code> is specified in the
                        mode declaration. It is also possible to request warnings when this
                        condition arises, by means of the attribute <code>warning-on-multiple-match="yes"</code>. </p>
                  </note>

               </item>
            </olist>

         </div2>
         <div2 id="default-priority">
            <head>Default Priority for Template Rules</head>
            <p><termdef id="dt-default-priority" term="default priority">If no <code>priority</code>
                  attribute is specified on an <elcode>xsl:template</elcode> element, a
                     <term>default priority</term> is computed, based on the syntax of the <termref def="dt-pattern">pattern</termref> supplied in the <code>match</code>
                  attribute.</termdef> The rules are as follows. </p>
            <olist>
               <item>
                  <p>If the top-level pattern is a <nt def="ParenthesizedExprP">ParenthesizedExprP</nt> then the outer parentheses are effectively
                     stripped; these rules are applied recursively to the <nt def="UnionExprP">UnionExprP</nt> contained in the <nt def="ParenthesizedExprP">ParenthesizedExprP</nt>.</p>
               </item>
               <item>
                  <p>If the top-level pattern is a <nt def="UnionExprP">UnionExprP</nt> consisting
                     of multiple alternatives separated by <code>|</code> or <code>union</code>,
                     then the template rule is treated equivalently to a set of template rules, one
                     for each alternative. 
                     These template rules are adjacent to each
                        other in declaration order, and the declaration order within this set of
                        template rules (which affects the result of <elcode>xsl:next-match</elcode>
                        if the alternatives have the same default priority) is the order of
                        alternatives in the <nt def="UnionExprP">UnionExprP</nt>.</p>
                  <note>
                     <p>The splitting of a template rule into multiple rules occurs only if there is
                        no explicit <code>priority</code> attribute.</p>
                  </note>
               </item>
               <item>
                  <p>If the top-level pattern is an <nt def="IntersectExceptExprP">IntersectExceptExprP</nt> containing two or more <nt def="PathExprP">PathExprP</nt> operands separated by <code>intersect</code> or
                        <code>except</code> operators, then the priority of the pattern is that of
                     the first <nt def="PathExprP">PathExprP</nt>. </p>
               </item>
               <item>
                  <p>If the pattern is a <nt def="PredicatePattern">PredicatePattern</nt> then its priority is 1 (one), unless the <xnt spec="XP40" ref="prod-xpath40-PredicateList">PredicateList</xnt> is empty,
                     in which case the priority is −1 (minus one).</p>
                  
                  
               </item>
               


               <item>
                  <p>If the pattern is a <nt def="PathExprP">PathExprP</nt> taking the form
                        <code>/</code>, then the priority is −0.5 (minus 0.5).</p>
               </item>
               <item>
                  <p>If the pattern is a <nt def="PathExprP">PathExprP</nt> taking the form of an
                        <termref def="dt-eqname">EQName</termref> optionally preceded by a <nt def="ForwardAxisP">ForwardAxisP</nt> or has the form
                        <code>processing-instruction(</code>
                     <xnt spec="XP40" ref="prod-xpath40-StringLiteral">StringLiteral</xnt>
                     <code>)</code> or <code>processing-instruction(</code>
                     <xnt spec="Names" ref="NT-NCName">NCName</xnt>
                     <code>)</code> optionally preceded by a <nt def="ForwardAxisP">ForwardAxisP</nt>, then the priority is 0 (zero).</p>
               </item>
               <item>
                  <p>If the pattern is a <nt def="PathExprP">PathExprP</nt> taking the form of an
                        <xnt spec="XP40" ref="prod-xpath40-ElementTest">ElementTest</xnt> or <xnt spec="XP40" ref="prod-xpath40-AttributeTest">AttributeTest</xnt>, optionally
                     preceded by a <nt def="ForwardAxisP">ForwardAxisP</nt>, then the priority is as
                     shown in the table below. In this table, the symbols <var>E</var>,
                     <var>A</var>, and <var>T</var> represent an arbitrary element name, attribute
                     name, and type name respectively, while the symbol <code>*</code> represents
                     itself. The presence or absence of the symbol <code>?</code> following a type
                     name does not affect the priority.</p>
                  <table class="data">
                     <caption>Default Priority of Patterns</caption>
                     <thead>
                        <tr>
                           <th rowspan="1" colspan="1">Format</th>
                           <th rowspan="1" colspan="1">Priority</th>
                           <th rowspan="1" colspan="1">Notes</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element()</code>
                           </td>
                           <td rowspan="1" colspan="1">−0.5</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>*</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element(*)</code>
                           </td>
                           <td rowspan="1" colspan="1">−0.5</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>*</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute()</code>
                           </td>
                           <td rowspan="1" colspan="1">−0.5</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>@*</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute(*)</code>
                           </td>
                           <td rowspan="1" colspan="1">−0.5</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>@*</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element(<var>E</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0</td>
                           <td rowspan="1" colspan="1">(equivalent to E)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element(*,<var>T</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0</td>
                           <td rowspan="1" colspan="1">(matches by type only)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute(<var>A</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0</td>
                           <td rowspan="1" colspan="1">(equivalent to <code>@A</code>)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute(*,<var>T</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0</td>
                           <td rowspan="1" colspan="1">(matches by type only)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>element(<var>E</var>,<var>T</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.25</td>
                           <td rowspan="1" colspan="1">(matches by name and type)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>schema-element(<var>E</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.25</td>
                           <td rowspan="1" colspan="1">(matches by substitution group and type)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>attribute(<var>A</var>,<var>T</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.25</td>
                           <td rowspan="1" colspan="1">(matches by name and type)</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1">
                              <code>schema-attribute(<var>A</var>)</code>
                           </td>
                           <td rowspan="1" colspan="1">0.25</td>
                           <td rowspan="1" colspan="1">(matches by name and type)</td>
                        </tr>
                     </tbody>
                  </table>
               </item>
               <item>
                  <p>If the pattern is a <nt def="PathExprP">PathExprP</nt> taking the form of a
                        <xnt spec="XP40" ref="prod-xpath40-DocumentTest">DocumentTest</xnt>, then if
                     it includes no <xnt spec="XP40" ref="prod-xpath40-ElementTest">ElementTest</xnt> or <xnt spec="XP40" ref="prod-xpath40-SchemaElementTest">SchemaElementTest</xnt> the priority is −0.5. If it does include an
                        <xnt spec="XP40" ref="prod-xpath40-ElementTest">ElementTest</xnt> or <xnt spec="XP40" ref="prod-xpath40-SchemaElementTest">SchemaElementTest</xnt>,
                     then the priority is the same as the priority of that <xnt spec="XP40" ref="prod-xpath40-ElementTest">ElementTest</xnt> or <xnt spec="XP40" ref="prod-xpath40-SchemaElementTest">SchemaElementTest</xnt>, computed
                     according to the table above.</p>
               </item>
               <item>
                  <p>If the pattern is a <nt def="PathExprP">PathExprP</nt> taking the form of an
                        <xnt spec="Names" ref="NT-NCName">NCName</xnt><code>:*</code><phrase diff="add" at="A">, 
                           <xnt spec="XP30" ref="prod-xpath40-BracedURILiteral"/>*,</phrase> or
                        <code>*:</code><xnt spec="Names" ref="NT-NCName">NCName</xnt>, optionally
                     preceded by a <nt def="ForwardAxisP">ForwardAxisP</nt>, then the priority is
                     −0.25. <phrase diff="add" at="A">[XSLT 3.0 Erratum E37, bug 30375].</phrase></p>
               </item>
               <item>
                  <p>If the pattern is a <nt def="PathExprP">PathExprP</nt> taking the form of any
                     other <xnt spec="XP40" ref="prod-xpath40-NodeTest">NodeTest</xnt>, optionally
                     preceded by a <nt def="ForwardAxisP">ForwardAxisP</nt>, then the priority is
                     −0.5.</p>
               </item>
               <item>
                  <p>In all other cases, the priority is +0.5. 
                     <phrase diff="add" at="A">TODO: define default priorities for type patterns,
                     as suggested in https://www.saxonica.com/papers/xmlprague-2020mhk.pdf section 6.5.1</phrase></p>
               </item>
            </olist>
            <note>
               <p>In many cases this means that highly selective patterns have higher priority than
                  less selective patterns. The most common kind of pattern (a pattern that tests for
                  a node of a particular kind, with a particular <termref def="dt-expanded-qname">expanded QName</termref> or a particular type) has priority 0. The next less
                  specific kind of pattern (a pattern that tests for a node of a particular kind and
                  an <termref def="dt-expanded-qname">expanded QName</termref> with a particular
                  namespace URI) has priority −0.25. Patterns less specific than this
                  (patterns that just test for nodes of a given kind) have priority −0.5.
                  Patterns that specify both the name and the required type have a priority of
                  +0.25, putting them above patterns that only specify the name <emph>or</emph> the
                  type. Patterns more specific than this, for example patterns that include
                  predicates or that specify the ancestry of the required node, have priority
                  0.5.</p>
               
               <p>However, it is not invariably true that a more selective pattern has higher
                  priority than a less selective pattern. For example, the priority of the pattern
                     <code>node()[self::*]</code> is higher than that of the pattern
                     <code>salary</code>. Similarly, the patterns <code>attribute(*,
                     xs:decimal)</code> and <code>attribute(*, xs:short)</code> have the same
                  priority, despite the fact that the latter pattern matches a subset of the nodes
                  matched by the former. Therefore, to achieve clarity in a <termref def="dt-stylesheet">stylesheet</termref> it is good practice to allocate
                  explicit priorities.</p>
               
            </note>

         </div2>
         <div2 id="modes">
            <head>Modes</head>
            <p>
               <termdef id="dt-mode" term="mode"> A <term>mode</term> is a set of template rules;
                  when the <elcode>xsl:apply-templates</elcode> instruction selects a set of items
                  for processing, it identifies the rules to be used for processing those items by
                  nominating a mode, explicitly or implicitly.</termdef> Modes allow a node in a
                  <termref def="dt-source-tree">source tree</termref> (for example) to be processed
               multiple times, each time producing a different result. They also allow different
               sets of <termref def="dt-template-rule">template rules</termref> to be active when
               processing different trees, for example when processing documents loaded using the
                  <function>document</function> function (see <specref ref="func-document"/>). </p>
            <p>Modes are identified by an <termref def="dt-expanded-qname">expanded QName</termref>; in addition to any named modes, there is always one
               unnamed mode available. Whether a mode is named or unnamed, its properties
                  <rfc2119>may</rfc2119> be defined in an <elcode>xsl:mode</elcode> declaration. If
               a mode name is used (for example in an <elcode>xsl:template</elcode> declaration or
               an <elcode>xsl:apply-templates</elcode> instruction) and no declaration of that mode
               appears in the stylesheet, the mode is implicitly declared with default
               properties.</p>
            <div3 id="declaring-modes">
               <head>Declaring Modes</head>

               <?element xsl:mode?>



               <p>
                  <termdef id="dt-unnamed-mode" term="unnamed mode">The <term>unnamed mode</term> is the default mode used when no
                        <code>mode</code> attribute is specified on an
                        <elcode>xsl:apply-templates</elcode> instruction or
                        <elcode>xsl:template</elcode> declaration, unless a different default mode
                     has been specified using the <code>[xsl:]default-mode</code> attribute of a containing
                        element.</termdef>
               </p>
               <p>Every <termref def="dt-mode">mode</termref> other than the <termref def="dt-unnamed-mode">unnamed mode</termref> is identified by an <termref def="dt-expanded-qname">expanded QName</termref>.</p>
               <p>A <termref def="dt-stylesheet">stylesheet</termref> may contain multiple
                     <elcode>xsl:mode</elcode> declarations and may include or import <termref def="dt-stylesheet-module">stylesheet modules</termref> that also contain
                     <elcode>xsl:mode</elcode> declarations. The name of an
                     <elcode>xsl:mode</elcode> declaration is the value of its <code>name</code>
                  attribute, if any.</p>
               <p>
                  <termdef id="dt-mode-definition" term="mode definition">All the
                        <elcode>xsl:mode</elcode> declarations in a <termref def="dt-package"/> that share the same
                     name are grouped into a named <term>mode definition</term>; those that have no
                     name are grouped into a single unnamed mode definition.</termdef>
               </p>
               <p>The <code>declared-modes</code> attribute of
                     the <elcode>xsl:package</elcode> element determines whether implicit mode
                     declarations are allowed, as described in <specref ref="requiring-explicit-modes"/>. If the package allows implicit mode
                     declarations, then  if a <termref def="dt-stylesheet">stylesheet</termref> does not contain a declaration of the unnamed mode, a
                  declaration is implied equivalent to an <elcode>xsl:mode</elcode> element with
                     no attributes. Similarly, if there
                  is a mode that is named in an <elcode>xsl:template</elcode> or
                     <elcode>xsl:apply-templates</elcode> element, or in the <code>[xsl:]default-mode</code> attribute of a containing
                     element, and the <termref def="dt-stylesheet">stylesheet</termref>
                  does not contain a declaration of that mode, then a declaration is implied
                  comprising an <elcode>xsl:mode</elcode> element with a <code>name</code> attribute
                     equal to that mode name, plus the attribute
                        <code>visibility="private"</code>. </p>

               
               
               <p>The attributes of the <elcode>xsl:mode</elcode> declaration establish values for a
                  number of properties of a mode. The allowed values and meanings of the attributes
                  are given in the following table.</p>


               <table class="data">
                  <caption>Attributes of the <code>xsl:mode</code> Element</caption>
                  <thead>
                     <tr>
                        <th rowspan="1" colspan="1">Attribute</th>
                        <th rowspan="1" colspan="1">Values</th>
                        <th rowspan="1" colspan="1">Meaning</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">name</td>
                        <td valign="top" rowspan="1" colspan="1">An <termref def="dt-eqname">EQName</termref></td>
                        <td valign="top" rowspan="1" colspan="1">Specifies the name of the mode. If omitted, this
                              <elcode>xsl:mode</elcode> declaration provides properties of the
                              <termref def="dt-unnamed-mode">unnamed mode</termref></td>
                     </tr>
                     <tr diff="add" at="A">
                        <td valign="top" rowspan="1" colspan="1">as</td>
                        <td valign="top" rowspan="1" colspan="1">A <code>SequenceType</code></td>
                        <td valign="top" rowspan="1" colspan="1">Declares the type of value returned by all
                           template rules in this mode. If any template rules in this mode declare their
                        return type using an <code>as</code> attribute on <elcode>xsl:template</elcode>,
                        the values must be consistent.</td>
                     </tr> 
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">streamable</td>
                        <td valign="top" rowspan="1" colspan="1"><code>yes</code> or <code>no</code> (default
                              <code>no</code>)</td>
                        <td valign="top" rowspan="1" colspan="1">Determines whether template rules in this mode are to be
                           capable of being processed using <termref def="dt-streaming"/>. If the
                           value <code>yes</code> is specified, then the body of any <termref def="dt-template-rule">template rule</termref> that uses this mode
                              <rfc2119>must</rfc2119> conform to the rules for streamable templates
                           given in <specref ref="streamable-templates"/>.</td>
                     </tr> 
                     
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">use-accumulators</td>
                        <td valign="top" rowspan="1" colspan="1">List of accumulator names, or <code>#all</code> (default is an empty list)</td>
                        <td valign="top" rowspan="1" colspan="1">Relevant only when this mode is the <termref def="dt-initial-mode"/>
                           of the transformation, determines which accumulators are applicable to documents
                           containing nodes in the <termref def="dt-initial-match-selection"/>. For
                        further details see <specref ref="applicability-of-accumulators"/>.</td> 
                     </tr>

                     <tr>
                        <td valign="top" rowspan="1" colspan="1">on-no-match</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>deep-copy</code>,
                                 <code>shallow-copy</code>, <code>deep-skip</code>,
                                 <code>shallow-skip</code>, <code>text-only-copy</code> or
                                 <code>fail</code> (default
                           <code>text-only-copy</code>)</td>
                        <td valign="top" rowspan="1" colspan="1">Determines selection of the built-in <termref def="dt-template-rule">template rules</termref> that are used to
                           process an item when an
                              <elcode>xsl:apply-templates</elcode> instruction selects an item that does not match any
                           user-written <termref def="dt-template-rule">template rule</termref> in
                           the <termref def="dt-stylesheet">stylesheet</termref>. For details, see
                              <specref ref="built-in-rule"/>.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">on-multiple-match</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>fail</code> or <code>use-last</code> (default
                              <code>use-last</code>)</td>
                        <td valign="top" rowspan="1" colspan="1">Defines the action to be taken when
                              <elcode>xsl:apply-templates</elcode> is used in this mode and more
                           than one user-written <termref def="dt-template-rule">template
                              rule</termref> is available to process an item, each having the same <termref def="dt-import-precedence">import precedence</termref> and <termref def="dt-priority">priority</termref>. The value <code>fail</code>
                           indicates that it is a <termref def="dt-dynamic-error"> dynamic error</termref> if more
                           than one template rule matches an
                              item. The value <code>use-last</code> indicates that the
                           situation is not to be treated as an error (the last template in <termref def="dt-declaration-order">declaration order</termref> is the one that
                           is used). </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">warning-on-no-match</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>yes</code> or <code>no</code>. The default is
                              <termref def="dt-implementation-defined"/>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">Requests the <termref def="dt-processor">processor</termref> to output (or not to output) a warning message in
                           the case where an <elcode>xsl:apply-templates</elcode> instruction
                           selects an item that matches
                           no user-written template rule. The form and destination of such warnings
                           is <termref def="dt-implementation-defined">implementation-defined</termref>. The processor
                              <rfc2119>may</rfc2119> ignore this attribute, for example if the
                           environment provides no suitable means of communicating with the user.
                        </td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">warning-on-multiple-match</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>yes</code> or <code>no</code>. The default is
                              <termref def="dt-implementation-defined"/>
                        </td>
                        <td valign="top" rowspan="1" colspan="1">Requests the <termref def="dt-processor">processor</termref> to output a warning message in the case where an
                              <elcode>xsl:apply-templates</elcode> instruction selects an item that matches multiple
                           template rules having the same <termref def="dt-import-precedence">import
                              precedence</termref> and <termref def="dt-priority">priority</termref>. The form and destination of such warnings is
                              <termref def="dt-implementation-defined">implementation-defined</termref>. The processor
                              <rfc2119>may</rfc2119> ignore this attribute, for example if the
                           environment provides no suitable means of communicating with the
                           user.</td>
                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">typed</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>yes</code>, <code>no</code>,
                              <code>strict</code>, <code>lax</code>, or <code>unspecified</code>.
                           The default is <code>unspecified</code>.</td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="xsl-mode-typed"/>.</td>

                     </tr>
                     <tr>
                        <td valign="top" rowspan="1" colspan="1">visibility</td>
                        <td valign="top" rowspan="1" colspan="1">One of <code>public</code>, <code>private</code>, or
                              <code>final</code>. The default is <code>private</code>.</td>
                        <td valign="top" rowspan="1" colspan="1">See <specref ref="visibility"/>. If the mode is unnamed, that is, if the
                                 <code>name</code> attribute is absent, then the
                                 <code>visibility</code> attribute if present
                                 <rfc2119>must</rfc2119> have the value
                              <code>private</code>. A
                                 named mode is not
                              eligible to be used as the <termref def="dt-initial-mode"/> if its
                              visibility is <code>private</code>.</td>

                     </tr>

                  </tbody>

               </table>




               <imp-def-feature id="idf-err-warningonmatch">The default values for the
                     <code>warning-on-no-match</code> and <code>warning-on-multiple-match</code>
                  attributes of <elcode>xsl:mode</elcode> are <termref def="dt-implementation-defined"/>.</imp-def-feature>

               <imp-def-feature id="idf-err-matchmessages">The form of any warnings output when
                  there is no matching template rule, or when there are multiple matching template
                  rules, is <termref def="dt-implementation-defined"/>.</imp-def-feature>

               <p>
                  <termdef id="dt-streamable-mode" term="streamable mode">A <term>streamable
                        mode</term> is a <termref def="dt-mode">mode</termref> that is declared in
                     an <elcode>xsl:mode</elcode> declaration with the attribute
                        <code>streamable="yes"</code>.</termdef>
               </p>
               <p>For any named <termref def="dt-mode">mode</termref>, the effective value of each
                  attribute is taken from an <elcode>xsl:mode</elcode> declaration that has a
                  matching name in its <code>name</code> attribute, and that specifies an explicit
                  value for the required attribute. If there is
                     no such declaration, the default value of the attribute is used. If
                  there is more than one such declaration, the one with highest <termref def="dt-import-precedence">import precedence</termref> is used.</p>
               <p>For the <termref def="dt-unnamed-mode">unnamed mode</termref>, the effective value
                  of each attribute is taken from an <elcode>xsl:mode</elcode> declaration that has
                  no <code>name</code> attribute, and that specifies an explicit value for the
                  required attribute. If there is no such declaration, the default value of the
                  attribute is used. If there is more than one such declaration, the one with
                  highest <termref def="dt-import-precedence">import precedence</termref> is
                  used.</p>
               
               <p>
                  <error spec="XT" type="static" class="SE" code="0545">
                     <p>It is a <termref def="dt-static-error">static error</termref> if for any
                        named or unnamed <termref def="dt-mode">mode</termref>, a package explicitly specifies two conflicting
                        values for the same attribute in different <elcode>xsl:mode</elcode>
                        declarations having the same <termref def="dt-import-precedence">import
                           precedence</termref>, unless there is another definition of the same
                        attribute with higher import precedence. The attributes in question are the
                        attributes other than <code>name</code> on the <elcode>xsl:mode</elcode>
                           element.</p>
                  </error>
               </p>
               

               
            </div3>

            <div3 id="using-modes">
               <head>Using Modes</head>
               <p><termdef id="dt-applicable" term="applicable">A <termref def="dt-template-rule">template rule</termref> is <term>applicable</term> to one or more modes.
                     The modes to which it is applicable are defined by the <code>mode</code>
                     attribute of the <elcode>xsl:template</elcode> element. If the attribute is
                     omitted, then the template rule is applicable to the default mode specified in the <code>[xsl:]default-mode</code> attribute of the innermost containing
                           element that has such an attribute, which in turn defaults to
                        the <termref def="dt-unnamed-mode">unnamed mode</termref>. If the
                        <code>mode</code> attribute is present, then its value
                        <rfc2119>must</rfc2119> be a non-empty whitespace-separated list of tokens,
                     each of which defines a mode to which the template rule is
                     applicable.</termdef></p>

               <p>Each token in the <code>mode</code> attribute <rfc2119>must</rfc2119> be one of
                  the following:</p>
               <ulist>
                  <item>
                     <p>An <termref def="dt-eqname">EQName</termref>, which is expanded as described in <specref ref="qname"/> to define the name of the mode</p>
                  </item>
                  <item>
                     <p>The token <code>#default</code>, to indicate that the template rule is
                        applicable to the default mode that would apply if
                           the <code>mode</code> attribute were absent
                     </p>
                  </item>
                  <item>
                     <p>The token <code>#unnamed</code>, to indicate that the
                        template rule is applicable to the <termref def="dt-unnamed-mode">unnamed
                           mode</termref>
                     </p>
                  </item>
                  <item>
                     <p>The token <code>#all</code>, to indicate that the template rule is
                        applicable to all modes <phrase diff="chg" at="A">other than <termref def="dt-enclosed-mode">enclosed modes</termref></phrase>
                        (specifically, to the unnamed mode and to every mode that is named explicitly or implicitly in an
                           <elcode>xsl:apply-templates</elcode> instruction  anywhere in
                        the stylesheet).</p>
                     <p diff="chg" at="A">More specifically, when a template rule specifies <code>mode="#all"</code> this makes the
                        template rule <termref def="dt-applicable"/> to:</p>
                        <ulist>
                           <item><p>The unnamed mode.</p></item>
                           <item><p>Every mode, other than an <termref def="dt-enclosed-mode"/>, that is declared using an
                              <elcode>xsl:mode</elcode> declaration within the containing <termref def="dt-package"/>.</p></item>
                           <item><p>Every mode that is implicitly declared within the containing <termref def="dt-package"/>
                              by virtue of being referenced in an <elcode>xsl:template</elcode> or
                           <elcode>xsl:apply-templates</elcode> element.</p></item>
                        </ulist>
                        <p>The value <code>mode="#all"</code>
                        cannot be used on a template rule declared within an
                        <elcode>xsl:override</elcode> <phrase diff="add" at="A">or <elcode>xsl:mode</elcode></phrase> element.</p>
                  </item>
               </ulist>

               <p></p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0550">
                     <p>It is a <termref def="dt-static-error">static error</termref> if the list of
                        modes <error.extra>in the <code>mode</code> attribute of
                              <elcode>xsl:template</elcode>
                        </error.extra> is empty, if the same token is included more than once in the
                        list, if the list contains an invalid token, or if the token
                           <code>#all</code> appears together with any other value.</p>
                  </error>
               </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="3440">
                     <p>In the case of a <termref def="dt-template-rule"/> (that is, an
                           <elcode>xsl:template</elcode> element having a <code>match</code>
                        attribute) appearing as a child of <elcode>xsl:override</elcode>, it is a
                           <termref def="dt-static-error">static error</termref> if the list of
                        modes in the <code>mode</code> attribute contains <code>#all</code> or
                           <code>#unnamed</code>, or if it contains <code>#default</code> and the
                        default mode is the <termref def="dt-unnamed-mode"/>, or if the
                           <code>mode</code> attribute is omitted when the default mode is the
                           <termref def="dt-unnamed-mode"/>.</p>
                  </error>
               </p>
               <p>The <elcode>xsl:apply-templates</elcode> element also has an optional
                     <code>mode</code> attribute. The value of this attribute
                     <rfc2119>must</rfc2119> be one of the following:</p>
               <ulist>
                  <item>
                     <p>an <termref def="dt-eqname">EQName</termref>, which is expanded as described in <specref ref="qname"/> to define the name of a mode</p>
                  </item>
                  <item>
                     <p>the token <code>#default</code>, to indicate that the default mode for the <termref def="dt-stylesheet-module">stylesheet
                              module</termref>
                         is to be used</p>
                  </item>
                  <item>
                     <p>the token <code>#unnamed</code>, to indicate that the
                           <termref def="dt-unnamed-mode">unnamed mode</termref> is to be used</p>
                  </item>
                  <item>
                     <p>the token <code>#current</code>, to indicate that the <termref def="dt-current-mode">current mode</termref> is to be used</p>
                  </item>
               </ulist>

               <p>If the attribute is omitted, the default mode for the
                        <termref def="dt-stylesheet-module">stylesheet module</termref>
                   is used.</p>
               <p>When searching for a template rule to process each item selected by the <elcode>xsl:apply-templates</elcode>
                  instruction, only those template rules that are applicable to the selected mode
                  are considered.</p>
               <!--Text replaced by erratum E19 change 2"-->
               <p>
                  <termdef id="dt-current-mode" term="current mode">At any point in the processing
                     of a stylesheet, there is a <term>current mode</term>. When the transformation
                     is initiated, the current mode is the <termref def="dt-initial-mode"/>, as described in <specref ref="initiating"/>. Whenever an <elcode>xsl:apply-templates</elcode>
                     instruction is evaluated, the current mode becomes the mode selected by this
                     instruction.</termdef> When a <termref def="dt-non-contextual-function-call"/> is made, the current mode
                  is set to the <termref def="dt-unnamed-mode">unnamed mode</termref>. While
                  evaluating global variables and parameters, and the sequence constructor contained
                  in <elcode>xsl:key</elcode> or <elcode>xsl:sort</elcode>, the current mode is set
                  to the unnamed mode. No other instruction changes the current mode. The current
                  mode while evaluating an <termref def="dt-attribute-set">attribute set</termref>
                  is the same as the current mode of the caller. On completion of the
                     <elcode>xsl:apply-templates</elcode> instruction, or on return from a
                  stylesheet function call, the current mode reverts to its previous value. The
                  current mode is used when an <elcode>xsl:apply-templates</elcode> instruction uses
                  the syntax <code>mode="#current"</code>; it is also used by the
                     <elcode>xsl:apply-imports</elcode> and <elcode>xsl:next-match</elcode>
                  instructions (see <specref ref="apply-imports"/>).</p>
            </div3>
            <!--End of text replaced by erratum E19-->

            <div3 id="xsl-mode-typed">
               <head>Declaring the Type of Nodes Processed by a Mode</head>

               <p>Typically the template rules in a particular <termref def="dt-mode"/> will be
                  designed to process a specific kind of input document. The <code>typed</code>
                  attribute of <elcode>xsl:mode</elcode> gives the stylesheet author the opportunity
                  to provide information about this document to the processor. This information may
                  enable the processor to improve diagnostics or to optimize performance.</p>

               <p>The <code>typed</code> attribute of <elcode>xsl:mode</elcode> informs the
                  processor whether the nodes to be processed by template rules in this mode are to
                  be typed or untyped. </p>

               <ulist>
                  <item>
                     <p>If the value <code>yes</code> is specified (synonyms <code>true</code> or
                           <code>1</code>), then all nodes processed in this mode must be typed. A
                        dynamic error occurs if <elcode>xsl:apply-templates</elcode> in this mode
                        selects an element or attribute node whose <termref def="dt-type-annotation"/> is <code>xs:untyped</code> or <code>xs:untypedAtomic</code>. </p>
                  </item>
                  <item>
                     <p>If the value <code>no</code> is specified (synonyms <code>false</code> or
                           <code>0</code>), then all nodes processed in this mode must be untyped. A
                        dynamic error occurs if <elcode>xsl:apply-templates</elcode> in this mode
                        selects an element or attribute whose <termref def="dt-type-annotation"/> is
                        anything other than <code>xs:untyped</code> or
                        <code>xs:untypedAtomic</code>. </p>
                  </item>
                  <item>
                     <p>The value <code>strict</code> is equivalent to <code>yes</code>, with the
                        additional provision that in the match pattern of any template rule that is
                           <termref def="dt-applicable"/> to this mode, any <code>NameTest</code>
                        used in the <code>ForwardStepP</code> of the first <code>StepExprP</code> of
                        a <code>RelativePathExprP</code> is interpreted as follows:</p>

                     <ulist>
                        <item>
                           <p>If the <code>NameTest</code> is an <code>EQName</code>
                              <var>E</var>, and the principal node kind of the axis of this step is
                                 <code>Element</code>, then:</p>
                           <ulist>
                                 <item>
                                    <p>It is a static error if the in-scope schema declarations do
                                       not include a global element declaration for element name
                                          <var>E</var>
                                    </p>
                                 </item>
                                 <item>
                                    <p>When matching templates in this mode, the element name
                                          <var>E</var> appearing in this step is interpreted as
                                          <code>schema-element(E)</code>. (Informally, this means
                                       that it will only match an element if it has been validated
                                       against this element declaration). </p>
                                 </item>
                              </ulist>
                        </item>
                        <item>
                           <p>Otherwise (the <code>NameTest</code> is a wildcard or the principal
                              node kind is <code>Attribute</code> or <code>Namespace</code>), the
                              template matching proceeds as if the <code>typed</code> attribute were
                              absent. </p>
                        </item>
                     </ulist>

                  </item>
                  <item>
                     <p>The value <code>lax</code> is equivalent to <code>yes</code>, with the
                        additional provision that in the match pattern of any template rule that is
                           <termref def="dt-applicable"/> to this mode, any <code>NameTest</code>
                        used in the <code>ForwardStepP</code> of the first <code>StepExprP</code> of
                        a <code>RelativePathExprP</code> is interpreted as follows:</p>

                     <ulist>
                        <item>
                           <p>If the <code>NameTest</code> is an <code>EQName</code>
                              <var>E</var>, and the principal node kind of the axis of this step is
                                 <code>Element</code>, and the in-scope schema declarations include
                              a global element declaration for element name <var>E</var>, then:</p>
                           <ulist>

                                 <item>
                                    <p>When matching templates in this mode, the element name
                                          <var>E</var> appearing in this step is interpreted as
                                          <code>schema-element(E)</code>. (Informally, this means
                                       that it will only match an element if it has been validated
                                       against this element declaration). </p>
                                 </item>
                              </ulist>
                        </item>
                        <item>
                           <p>Otherwise (the <code>NameTest</code> is a wildcard, or the principal
                              node kind is <code>Attribute</code> or <code>Namespace</code>, or
                              there is no element declaration for <var>E</var>), the template
                              matching proceeds as if the <code>typed</code> attribute were absent.
                           </p>
                        </item>
                     </ulist>

                  </item>

               </ulist>

               <p>
                  <error spec="XT" type="type" class="TE" code="3100">
                     <p>It is a <termref def="dt-type-error">type error</termref> if an
                           <elcode>xsl:apply-templates</elcode> instruction in a particular
                           <code>mode</code> selects an element or attribute whose type is
                           <code>xs:untyped</code> or <code>xs:untypedAtomic</code> when the
                           <code>typed</code> attribute of that mode specifies the value
                           <code>yes</code>, <code>strict</code>, or <code>lax</code>.</p>
                  </error>
               </p>

               <p>
                  <error spec="XT" type="static" class="SE" code="3105">
                     <p>It is a <termref def="dt-static-error">static error</termref> if a template
                        rule applicable to a mode that is defined with <code>typed="strict"</code>
                        uses a match pattern that contains a <code>RelativePathExprP</code> whose
                        first <code>StepExprP</code> is an <code>AxisStepP</code> whose
                           <code>ForwardStepP</code> uses an axis whose principal node kind is
                           <code>Element</code> and whose <code>NodeTest</code> is an
                           <code>EQName</code> that does not correspond to the name of any global
                        element declaration in the <termref def="dt-in-scope-schema-component">in-scope schema components</termref>.</p>
                  </error>
               </p>

               <p>
                  <error spec="XT" type="type" class="TE" code="3110">
                     <p>It is a <termref def="dt-type-error">type error</termref> if an
                           <elcode>xsl:apply-templates</elcode> instruction in a particular
                           <code>mode</code> selects an element or attribute whose type is anything
                        other than <code>xs:untyped</code> or <code>xs:untypedAtomic</code> when the
                           <code>typed</code> attribute of that mode specifies the value
                           <code>no</code>.</p>
                  </error>
               </p>


            </div3>
            
            <div3 id="mode-result-type" diff="add" at="A">
               <head>Declaring the result type of a mode</head>
               <p>Traditionally, template rules have most commonly been used to construct XDM nodes, and the <elcode>xsl:apply-templates</elcode>
               instruction has been used to add nodes to a result tree. However, it is also possible to use template rules to produce
               other kinds of value, for example strings, booleans, or maps. For the <elcode>xsl:apply-templates</elcode> 
               instruction to be useful, it will generally be the case that all template rules in a mode produce the same kind
               of value: for example, if one rule delivers a boolean, then the other rules will also deliver a boolean.</p>
               
               <p>XSLT 4.0 therefore allows the result type of the template rules in a mode to be declared using the <code>as</code>
               attribute on the <elcode>xsl:mode</elcode> declaration. If this is absent, it defaults to <code>item()*</code>.
               The presence of an <code>as</code> attribute on a mode provides useful documentation and consistency checking,
               and enables the XSLT processor to infer a static type for an <elcode>xsl:apply-templates</elcode> instruction,
               which can be useful for optimization.</p>
               
               <p>If a template rule <var>R</var> is <termref def="dt-applicable"/> to a mode <var>M</var>, 
                  and <var>M</var> is declared with an <code>as</code> attribute whose value is the <code>SequenceType</code> 
                  <var>T</var>, then:</p>
               
               <ulist>
                  <item><p>If <code>R</code> has an <code>as</code> attribute, the <code>SequenceType</code> <var>S</var> declared
                     by <var>R</var> must be a subtype of <var>T</var>,
                  according to the relationship <code>subtype(S, T)</code> defined in <xspecref spec="XP40" ref="XPath 2.5.6.1"/>.</p></item>
                  <item><p>If <code>R</code> has no <code>as</code> attribute, then it is treated as if it had an <code>as</code>
                     attribute set to <var>T</var>. If <code>R</code> is applicable
                     to more than one mode, then the implicit <code>SequenceType</code> inferred for any one of these modes
                     must be consistent with the <code>SequenceType</code> declared on all the other modes to which <code>R</code>
                  is applicable: for example, if <var>is</var> applicable to modes <var>M1</var> and <var>M2</var>, and if
                  <var>M1</var> declares a result type of <code>element(A)</code>, then a static error occurs if 
                     <code>element(A)</code> is not a subtype of the (explicit or implicit) result type for mode <var>M2</var>.</p>
                  <note><p>In practice this means that if a template rule is applicable to more than one mode (including
                  the case <code>mode="#all"</code>), then either (a) all those modes should have the same declared result type,
                  or (b) the template rule should declare an explicit result type that is compatible with each one of the relevant modes.</p></note>
                  <p>TODO: define the error code.</p></item>
               </ulist>
            </div3>
            
            <div3 id="enclosed-modes" diff="add" at="A">
               <head>Enclosed Modes</head>
               <p><termdef id="dt-enclosed-mode" term="enclosed mode">A mode declared by
                  an <elcode>xsl:mode</elcode> declaration that has one or more contained <elcode>xsl:template</elcode>
                  declarations is referred to as an <term>enclosed mode</term>.</termdef></p>
               <p>An enclosed mode ensures that all the template rules for a mode are together in one place, which
               makes it easier for someone reading the stylesheet to establish what is going to happen when an
               <elcode>xsl:apply-templates</elcode> instruction in that mode is evaluated.</p>
               <p>An enclosed mode <rfc2119>must</rfc2119> satisfy the following rules:</p>
               <olist>
                  <item><p>The mode must have a name.</p></item>
                  <item><p>Every contained <elcode>xsl:template</elcode> element must have a <code>match</code>
                  attribute and no <code>name</code> attribute.</p></item>
                  <item><p>Every contained <elcode>xsl:template</elcode> element must have no <code>mode</code>
                  attribute: the template is implicitly <termref def="dt-applicable"/> only to the containing mode.</p></item>
                  <item><p>An <elcode>xsl:mode</elcode> declaration with one or more <elcode>xsl:template</elcode>
                  children effectively has a <code>default-mode</code> attribute whose value is the mode's name;
                     it must not have a <code>default-mode</code> attribute with any other value.</p>
                  <note><p>This means that <elcode>xsl:apply-templates</elcode> instructions within the template
                  rules of the enclosed mode default to using the enclosing mode.</p></note></item>
                  <item><p>No <elcode>xsl:template</elcode> that is in the same <phrase diff="chg" at="B"><termref def="dt-package"/></phrase>
                     as the containing mode, but not declared within the containing mode, may be <termref def="dt-applicable"/>
                  to the containing mode.</p>
                  <note><p>Template rules in an enclosed mode may, however, be overridden within an 
                     <elcode>xsl:override</elcode> element in a using <termref def="dt-package"/>.</p></note></item>
               </olist>
               <example>
                  <head>An Enclosed Mode</head>
                  <p>The following mode might be used for formatting of numbers appearing in text:</p>
                  <eg role="xslt-declaration"><![CDATA[
<xsl:mode name="numbers-in-text" as="xs:string" visibility="final">
  <xsl:template match="type(xs:integer)[. gt 0 and . lt 21]">
    <xsl:number value="." format="w"/>
  </xsl:template>
  <xsl:template match="type(xs:integer)[. lt 10000]">
    <xsl:number value="." format="1"/>
  </xsl:template>
  <xsl:template match="type(xs:integer)">
    <xsl:number value="." format="1" grouping-separator="," grouping-size="3"/>
  </xsl:template>  
</xsl:mode>
                     ]]></eg>
               </example>
               <p>TODO: What happens if several mode declarations have the same name, and one or more of them 
                  is an enclosed mode?</p>
            </div3>

            <div3 id="streamable-templates">
               <head>Streamable Templates</head>
               <p>A template rule that is <termref def="dt-applicable"/> to a mode <var>M</var> is <termref def="dt-guaranteed-streamable"/> if and only if all the following conditions
                  are satisfied:</p>
               <olist>
                  <item>
                     <p>Mode <var>M</var> is declared in an <elcode>xsl:mode</elcode> declaration
                        that specifies <code>streamable="yes"</code>.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-pattern">pattern</termref> defined in the
                           <code>match</code> attribute of the <elcode>xsl:template</elcode> element
                           is a <termref def="dt-motionless"/>
                        pattern as defined in <specref ref="classifying-patterns"/>.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-sweep"/> of the <termref def="dt-sequence-constructor"/> forming the body of the <elcode>xsl:template</elcode> element is either
                           <termref def="dt-motionless"/> or <termref def="dt-consuming"/>.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-type-adjusted-posture-and-sweep">type-adjusted
                           posture</termref> of the <termref def="dt-sequence-constructor"/> forming
                        the body of the <elcode>xsl:template</elcode> element, with respect to the
                           <termref def="dt-utype"/> that corresponds to the declared return type of
                        the template (defaulting to <code>item()*</code>), is <termref def="dt-grounded"/>.</p>

                     <note>
                        <p>This means that either (a) the sequence constructor is grounded as
                           written (that is, it does not return streamed nodes), or (b) it
                           effectively becomes grounded because the declared result type of the
                           template is atomic, leading to implicit atomization of the result.</p>
                     </note>
                  </item>
                  
                  <item>
                     <p>Every <termref def="dt-expression">expression</termref> and contained
                           <termref def="dt-sequence-constructor"/> in a contained
                           <elcode>xsl:param</elcode> element (the construct that provides the
                        default value of the parameter) is
                        <termref def="dt-motionless"/>.</p>
                  </item>

               </olist>

               <p>Specifying <code>streamable="yes"</code> on an
                     <elcode>xsl:mode</elcode> declaration declares an intent that every template
                  rule <phrase diff="chg" at="A">to which that mode is <termref def="dt-applicable"/></phrase> 
                  (explicitly or implicitly, including by specifying
                     <code>#all</code>), should be streamable,
                     either because it is <termref def="dt-guaranteed-streamable"/>, or because it
                     takes advantage of streamability extensions offered by a particular
                     processor. The consequences of declaring the mode to be streamable
                  when there is such a template rule that is not guaranteed streamable depend on the
                  conformance level of the processor, and are explained in <specref ref="streamability-guarantees"/>.</p>

               <p>Processing of a document using streamable templates may be
                  initiated using code such as the following, where <code>S</code> is a mode
                  declared with <code>streamable="yes"</code>:</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:source-document streamable="yes" href="bigdoc.xml"&gt;
  &lt;xsl:apply-templates mode="S"/&gt;
&lt;/xsl:source-document&gt;</eg>

               <p>Alternatively, streamed processing may be initiated by invoking
                  the transformation with an <termref def="dt-initial-mode"/> declared as
                  streamable, while supplying the <termref def="dt-initial-match-selection"/> (in an <termref def="dt-implementation-defined"/> way) as a streamed document.</p>

               <imp-def-feature id="idf-api-streaming">Streamed processing may be initiated by
                  invoking the transformation with an <termref def="dt-initial-mode"/> declared as
                  streamable, while supplying the <termref def="dt-initial-match-selection"/> (in an <termref def="dt-implementation-defined"/> way) as a streamed
                  document.</imp-def-feature>

               <note>
                  <p>Invoking a streamable template using the construct
                        <code>&lt;xsl:apply-templates select="doc('bigdoc.xml')"/&gt;</code> does
                     not ensure streamed processing. As always, processors may use streamed
                     processing if they are able to do so, but when the <xfunction>doc</xfunction>
                     or <function>document</function> functions are used, processors are obliged to
                     ensure that the results are deterministic, which may be difficult to reconcile
                     with streaming (if the same document is read twice, the results must be
                     identical). The use of <elcode>xsl:source-document</elcode> 
                     with <code>streamable="yes"</code>
                     does not offer the same guarantees of determinism.</p>
               </note>

               <p>For an example of processing a collection of documents by use of the function
                     <xfunction>uri-collection</xfunction> in conjunction with
                     <elcode>xsl:source-document</elcode>, see <specref ref="stream-examples"/>.</p>

            </div3>

         </div2>



         <div2 id="built-in-rule">
            <head>Built-in Template Rules</head>
            <p>When an item is
               selected by <elcode>xsl:apply-templates</elcode> and there is no user-specified
                  <termref def="dt-template-rule">template rule</termref> in the <termref def="dt-stylesheet">stylesheet</termref> that can be used to process that item, then a built-in template rule is
               evaluated instead. </p>
            <p>The built-in <termref def="dt-template-rule">template rules</termref> have lower
                  <termref def="dt-import-precedence">import precedence</termref> than all other
               template rules. Thus, the stylesheet author can override a built-in template rule by
               including an explicit template rule.</p>
            <p>There are six sets of built-in template rules available. The set
               that is chosen is a property of the <termref def="dt-mode">mode</termref> selected by
               the <elcode>xsl:apply-templates</elcode> instruction. This property is set using the
                  <code>on-no-match</code> attribute of the <elcode>xsl:mode</elcode> declaration,
               which takes one of the six values <code>deep-copy</code>, <code>shallow-copy</code>,
                  <code>deep-skip</code>, <code>shallow-skip</code>, <code>text-only-copy</code>, or
                  <code>fail</code>, the default being <code>text-only-copy</code>. The effect of
               these six sets of built-in template rules is explained in the following
               subsections.</p>
            <div3 id="built-in-templates-text-only-copy">
               <head>Built-in Templates: Text-only Copy</head>
               <p>The effect of processing a
                     tree using a <termref def="dt-mode">mode</termref> that specifies
                        <code>on-no-match="text-only-copy"</code> is that the textual
                  content of the source document is retained while losing the markup, except where
                  explicit template rules dictate otherwise. When an element is encountered for
                  which there is no explicit <termref def="dt-template-rule">template
                  rule</termref>, the processing continues with the children of that element. Text
                  nodes are copied to the output.</p>
               <p>The built-in rule for document nodes and element nodes is equivalent to calling
                     <elcode>xsl:apply-templates</elcode> with no <code>select</code> attribute, and
                  with the <code>mode</code> attribute set to <code>#current</code>. If the built-in
                  rule was invoked with parameters, those parameters are passed on in the implicit
                     <elcode>xsl:apply-templates</elcode> instruction.</p>
               <p>This is equivalent to the following in the case where
                  there are no parameters:</p>

               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:template match="document-node()|element()" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;</eg>

               <p>The built-in <termref def="dt-template-rule">template
                     rule</termref> for text and attribute nodes returns a text node containing the
                     <termref def="dt-string-value">string value</termref> of the context node. It
                  is effectively:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="text()|@*" mode="M"&gt;
  &lt;xsl:value-of select="string(.)"/&gt;
&lt;/xsl:template&gt;</eg>
               <note>
                  <p>This text node may have a string value that is zero-length.</p>
               </note>
               <p>The built-in <termref def="dt-template-rule">template
                     rule</termref> for atomic values returns a
                  text node containing the value. It is effectively:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match=".[. instance of xs:anyAtomicType]" mode="M"&gt;
  &lt;xsl:value-of select="string(.)"/&gt;
&lt;/xsl:template&gt;</eg>
               <note>
                  <p>This text node may have a string value that is zero-length.</p>
               </note>
               <p>The built-in <termref def="dt-template-rule">template
                     rule</termref> for processing instructions, comments, and namespace nodes does
                  nothing (it returns the empty sequence).</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template 
   match="processing-instruction()|comment()|namespace-node()" 
   mode="M"/&gt;</eg>
               <p>The built-in <termref def="dt-template-rule">template
                     rule</termref> for functions (including
                     maps) does nothing (it returns the empty sequence).</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template 
   match=".[. instance of function(*)]" 
   mode="M"/&gt;</eg>
               
               
               <p>The built-in <termref def="dt-template-rule"/> for
               arrays (see <specref ref="arrays"/>) is to apply templates to the members of the array.
               It is equivalent to invoking <elcode>xsl:apply-templates</elcode> with the <code>select</code>
               attribute set to <code>?*</code> (which selects the members of the array), and with the 
                  <code>mode</code> attribute set to <code>#current</code>. If the built-in
                  rule was invoked with parameters, those parameters are passed on in the implicit
                  <elcode>xsl:apply-templates</elcode> instruction.</p>
               <p>This is equivalent to the following in the case where
                  there are no parameters:</p>
               
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:template match=".[. instance of array(*)]" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current" select="?*"/&gt;
&lt;/xsl:template&gt;</eg>
               <p>The following example illustrates the use of built-in template rules when there
                  are parameters.</p>
               <example>
                  <head>Using a Built-In Template Rule</head>
                  <p>Suppose the stylesheet contains the following instruction:</p>
                  <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:apply-templates select="title" mode="M"&gt;
  &lt;xsl:with-param name="init" select="10"/&gt;
&lt;/xsl:apply-templates&gt;</eg>
                  <p>If there is no explicit template rule that matches the <code>title</code>
                     element, then the following implicit rule is used:</p>
                  <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="title" mode="M"&gt;
  &lt;xsl:param name="init"/&gt;
  &lt;xsl:apply-templates mode="#current"&gt;
    &lt;xsl:with-param name="init" select="$init"/&gt;
  &lt;/xsl:apply-templates&gt;
&lt;/xsl:template&gt;</eg>
               </example>
            </div3>

            <div3 id="built-in-templates-deep-copy">
               <head>Built-in Templates: Deep Copy</head>
               <p>The effect of processing a tree using a
                        <termref def="dt-mode">mode</termref> that specifies
                        <code>on-no-match="deep-copy"</code> is that an unmatched element
                  in the source tree is copied unchanged to the output, together with its entire
                  subtree. Other unmatched items are also copied unchanged. The subtree is copied
                  unconditionally, without attempting to match nodes in the subtree against template
                  rules.</p>
               <p>When this default action is selected for a mode <var>M</var>, all items (nodes, atomic values, and functions, including maps and arrays) are processed
                  using a template rule that is equivalent to the following:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:copy-of select="." validation="preserve"/&gt;
&lt;/xsl:template&gt;</eg>
            </div3>
            <div3 id="built-in-templates-shallow-copy">
               <head>Built-in Templates: Shallow Copy</head>
               <p>The effect of processing a tree using a
                        <termref def="dt-mode">mode</termref> that specifies
                        <code>on-no-match="shallow-copy"</code> is that the source tree is
                  copied unchanged to the output, except for nodes where different processing is
                  specified using an explicit <termref def="dt-template-rule">template
                     rule</termref>.</p>
               <p>When this default action is selected for a mode <var>M</var>, all items (nodes, atomic values, and functions, including maps and arrays) are processed
                  using a template rule that is equivalent to the following, except that all
                  parameters supplied in <elcode>xsl:with-param</elcode> elements are passed on
                  implicitly to the called templates:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:copy validation="preserve"&gt;
    &lt;xsl:apply-templates select="@*" mode="M"/&gt;
    &lt;xsl:apply-templates select="node()" mode="M"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</eg>
               <p>This rule is often referred to as the <emph>identity template</emph>, though it
                  should be noted that it does not preserve node identity.</p>
               <note>
                  <p>This rule differs from the traditional identity template rule by using two
                        <elcode>xsl:apply-templates</elcode> instructions, one to process the
                     attributes and one to process the children. The only observable difference from
                     the traditional <code>select="node() | @*"</code> is that with two separate
                     instructions, the value of <code>position()</code> in the called templates
                     forms one sequence starting at 1 for the attributes, and a new sequence
                     starting at 1 for the children.</p>
                  
               </note>
               <example>
                  <head>Modified Identity Transformation</head>
                  <p>The following stylesheet transforms an input document by deleting all elements
                     named <code>note</code>, together with their attributes and descendants:</p>
                  <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet version="3.0"
     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
				  
&lt;xsl:mode on-no-match="shallow-copy" streamable="true"/&gt;

&lt;xsl:template match="note"&gt;
  &lt;!-- no action --&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
               </example>

            </div3>
            <div3 id="built-in-templates-deep-skip">
               <head>Built-in Templates: Deep Skip</head>
               <p>The effect of processing a tree using a <termref def="dt-mode">mode</termref> that specifies
                     <code>on-no-match="deep-skip"</code> is that where no explicit template rule is
                  specified for an element, that element and all its descendants are ignored, and
                  are not copied to the result tree.</p>
               <p>The effect of choosing <code>on-no-match="deep-skip"</code> is as follows:</p>

               <ulist>
                  <item>
                     <p>The built-in rule for document nodes is equivalent to calling
                           <elcode>xsl:apply-templates</elcode> with no <code>select</code>
                        attribute, and with the <code>mode</code> attribute set to
                           <code>#current</code>. If the built-in rule was invoked with parameters,
                        those parameters are passed on in the implicit
                           <elcode>xsl:apply-templates</elcode> instruction.</p>
                     <p>In the case where there are no parameters, this
                        is equivalent to the following rule:</p>
                     <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="document-node()" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;</eg>
                  </item>
                  <item>
                     <p>The built-in rule for all items other than document nodes (that is, for all other kinds of node, as well as atomic
                           values and functions, including
                              maps and  and arrays) is to do nothing, that is, to return an empty
                        sequence (without applying templates to any children or ancestors).</p>
                     <p>This is equivalent to the following rule:</p>
                     <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:template match="." mode="M"/&gt;</eg>
                  </item>
               </ulist>

            </div3>
            <div3 id="built-in-templates-shallow-skip">
               <head>Built-in Templates: Shallow Skip</head>
               <p>The effect of processing a tree using a
                        <termref def="dt-mode">mode</termref> that specifies
                        <code>on-no-match="shallow-skip"</code> is to drop both the textual
                  content and the markup from the result document, except where there is an explicit
                  user-written <termref def="dt-template-rule">template rule</termref> that dictates
                  otherwise.</p>

               <p>The built-in rule for document nodes and element nodes  applies templates (in the current mode) first to the node’s
                     attributes and then to its children. If the built-in rule was invoked
                  with parameters, those parameters are passed on in the implicit
                     <elcode>xsl:apply-templates</elcode>
                  instructions.</p>

               <p>In the case where there are no parameters, this is
                  equivalent to the following rule:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="document-node()|element()" mode="M"&gt;
  &lt;xsl:apply-templates select="@*" mode="#current"/&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;</eg>


               <p>The built-in template rule for all other kinds of node, and for atomic values and
                  functions (including maps, but not arrays) is empty:
                  that is, when the item is matched, the built-in template rule returns an empty
                  sequence.</p>

               <p>This is equivalent to the following rule:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="." mode="M"/&gt;</eg>

               <p>The built-in <termref def="dt-template-rule"/> for
                  arrays (see <specref ref="arrays"/>) is to apply templates to the members of the array.
                  It is equivalent to invoking <elcode>xsl:apply-templates</elcode> with the <code>select</code>
                  attribute set to <code>?*</code> (which selects the members of the array), and with the 
                  <code>mode</code> attribute set to <code>#current</code>. If the built-in
                  rule was invoked with parameters, those parameters are passed on in the implicit
                  <elcode>xsl:apply-templates</elcode> instruction.</p>
               <p>This is equivalent to the following in the case where
                  there are no parameters:</p>
               
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:template match=".[. instance of array(*)]" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current" select="?*"/&gt;
&lt;/xsl:template&gt;</eg>

            </div3>
            <div3 id="built-in-templates-fail">
               <head>Built-in Templates: Fail</head>
               <p>The effect of choosing <code>on-no-match="fail"</code> for a
                     <termref def="dt-mode">mode</termref> is that every item selected in an <elcode>xsl:apply-templates</elcode> instruction
                  must be matched by an explicit user-written <termref def="dt-template-rule">template rule</termref>.</p>
               <p>The built-in template rule is effectively: </p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:message terminate="yes" error-code="err:XTDE0555"/&gt;
&lt;/xsl:template&gt;</eg>
               <p>with an <termref def="dt-implementation-dependent"/> message body.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0555">
                     <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>
                        or <elcode>xsl:next-match</elcode> is used to process 
                        <phrase diff="chg" at="A">an item</phrase> using a mode
                        whose declaration specifies <code>on-no-match="fail"</code> when there is no
                           <termref def="dt-template-rule"/> in the <termref def="dt-stylesheet"/>
                        whose match pattern matches that <phrase diff="chg" at="A">item</phrase>. </p>
                  </error>
               </p>
            </div3>
         </div2>
         <div2 id="apply-imports">
            <head>Overriding Template Rules</head>
            <?element xsl:apply-imports?>
            <?element xsl:next-match?>
            <p>A <termref def="dt-template-rule">template rule</termref> that is being used to
               override another template rule (see <specref ref="conflict"/>) can use the
                  <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> instruction
               to invoke the overridden template rule. The <elcode>xsl:apply-imports</elcode>
               instruction only considers template rules in imported stylesheet modules; the
                  <elcode>xsl:next-match</elcode> instruction considers all other template rules of
               lower <termref def="dt-import-precedence">import precedence</termref> and/or
               priority, and also declarations of the same
                  precedence and priority that appear earlier in <termref def="dt-declaration-order"/>. Both instructions will invoke the built-in template rule for the
                  context item (see <specref ref="built-in-rule"/>) if no other template rule is found.</p>
            <p>
               <termdef id="dt-current-template-rule" term="current template rule">At any point in
                  the processing of a <termref def="dt-stylesheet">stylesheet</termref>, there may
                  be a <term>current template rule</term>. Whenever a <termref def="dt-template-rule">template rule</termref> is chosen as a result of
                  evaluating <elcode>xsl:apply-templates</elcode>,
                     <elcode>xsl:apply-imports</elcode>, or <elcode>xsl:next-match</elcode>, the
                  template rule becomes the current template rule for the evaluation of the rule’s
                  sequence constructor.</termdef>
             </p>
            
            <p>
               The <termref def="dt-current-template-rule"/> is cleared (becomes <termref def="dt-absent"/>)
                  by any instruction that evaluates an operand with changed focus. It is therefore cleared
                  when evaluating <termref def="dt-instruction">instructions</termref> contained within:
            </p>
            
            <ulist>
               <item><p><elcode>xsl:for-each</elcode></p></item>
               <item><p><elcode>xsl:for-each-group</elcode></p></item>
               <item><p><elcode>xsl:analyze-string</elcode></p></item>
               <item><p><elcode>xsl:iterate</elcode></p></item>
               <item><p><elcode>xsl:source-document</elcode></p></item>
               <item><p><elcode>xsl:merge</elcode></p></item>
               <item><p><elcode>xsl:sort</elcode></p></item>
               <item><p><elcode>xsl:key</elcode></p></item>
               <item><p><elcode>xsl:copy</elcode> if and only if there is a <code>select</code> attribute</p></item>
               <item><p>A global <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode></p></item>
               <item><p><elcode>xsl:function</elcode></p></item>
               <item><p><elcode>xsl:template</elcode> if and only if the called template specifies <code>&lt;xsl:context-item use="absent"/&gt;</code></p></item>              
            </ulist>
 
            <note>
               <p>The current template rule is not affected by invoking named attribute sets (see <specref ref="attribute-sets"/>), or named templates (see <specref ref="named-templates"/>) unless <code>&lt;xsl:context-item use="absent"/&gt;</code> is specified. 
                  While evaluating a <termref def="dt-global-variable">global variable</termref> or the default value of a <termref def="dt-stylesheet-parameter">stylesheet parameter</termref> (see <specref ref="global-variables"/>) the current template rule is <termref def="dt-absent"/>.</p>
            </note>
            
               <p>These rules ensure that when <elcode>xsl:apply-imports</elcode> or
                     <elcode>xsl:next-match</elcode> is called, the <termref def="dt-context-item">context item</termref> is the same as when the current template rule was
                     invoked.</p>
            
            <p> Both <elcode>xsl:apply-imports</elcode> and <elcode>xsl:next-match</elcode> search
               for a <termref def="dt-template-rule">template rule</termref> that matches the
                  <termref def="dt-context-item">context
                  item</termref>, and that is applicable to the <termref def="dt-current-mode">current mode</termref> (see <specref ref="modes"/>). In
               choosing a template rule, they use the usual criteria such as the priority and
                  <termref def="dt-import-precedence">import precedence</termref> of the template
               rules, but they consider as candidates only a subset of the template rules in the
                  <termref def="dt-stylesheet">stylesheet</termref>. This subset differs between the
               two instructions:</p>
            <ulist>
               <item>
                  <p>The <elcode>xsl:apply-imports</elcode> instruction considers as candidates only
                     those template rules contained in <termref def="dt-stylesheet-level">stylesheet
                        levels</termref> that are descendants in the <termref def="dt-import-tree">import tree</termref> of the <termref def="dt-stylesheet-level">stylesheet
                        level</termref> that contains the <termref def="dt-current-template-rule">current template rule</termref>.</p>
                  <note>
                     <p>This is <emph>not</emph> the same as saying that the search considers all
                        template rules whose import precedence is lower than that of the current
                        template rule.</p>
                  </note>
                  <p><error spec="XT" type="static" class="SE" code="3460">
                        <p>It is a <termref def="dt-static-error"/> if an
                              <elcode>xsl:apply-imports</elcode> element appears in a <termref def="dt-template-rule"/> declared within an
                              <elcode>xsl:override</elcode> element. (To invoke the template rule
                           that is being overridden, <elcode>xsl:next-match</elcode> should
                           therefore be used.)</p>
                     </error></p>
               </item>
               <item>
                  <p>The <elcode>xsl:next-match</elcode> instruction considers as candidates all
                     those template rules that come after the <termref def="dt-current-template-rule">current template rule</termref> in the
                     ordering of template rules implied by the conflict resolution rules given in
                        <specref ref="conflict"/>. That is, it considers all template rules with
                     lower <termref def="dt-import-precedence">import precedence</termref> than the
                        <termref def="dt-current-template-rule">current template rule</termref>,
                     plus the template rules that are at the same import precedence that have lower
                     priority than the current template rule, plus
                        the template rules with the same import precedence and priority
                     that occur before the current template rule in <termref def="dt-declaration-order">declaration order</termref>.</p>
                  <note>
                     <p>As explained in <specref ref="conflict"/>, a template rule with no <code>priority</code>
                           attribute, whose match pattern contains multiple alternatives
                        separated by <code>|</code>, is treated equivalently to a set of template
                        rules, one for each alternative. This means that where the same item matches more than one alternative, it is possible for an <elcode>xsl:next-match</elcode>
                        instruction to cause the current template rule to be invoked recursively.
                        This situation does not occur when the template rule has an explicit priority.</p>
                  </note>
                  <note>
                     <p>Because a template rule declared as a child of <elcode>xsl:override</elcode>
                        has higher precedence than any template rule declared in the used package
                        (see <specref ref="modes-and-packages"/>), the effect of
                           <elcode>xsl:next-match</elcode> within such a template rule is to
                        consider as candidates first any other template rules for the same mode within the
                        same <elcode>xsl:use-package</elcode> element (taking into account explicit and implicit
                        priority, and document order, in the usual way), and then all template rules in
                        the used package.</p>
                  </note>
               </item>
            </ulist>
            
            <p>If a matching template rule <var>R</var> is found, then the result
               of the <elcode>xsl:next-match</elcode> or <elcode>xsl:apply-imports</elcode> instruction is the 
               result of invoking <var>R</var>, with the values of parameters being set using the child
               <elcode>xsl:with-param</elcode> elements as described in <specref ref="with-param"/>. 
               The template rule <var>R</var> is evaluated with the same <termref def="dt-focus"/> as the <elcode>xsl:next-match</elcode> 
               or <elcode>xsl:apply-imports</elcode> instruction. The <termref def="dt-current-template-rule"/>
               changes to be <var>R</var>. The <termref def="dt-current-mode"/> does not change. 
            </p>
            <note><p>In the case where the current template rule <var>T</var> is 
               declared within an <elcode>xsl:override</elcode> element in a using package <var>P</var>, while 
               the selected rule <var>R</var> is declared within a different package <var>Q</var>, and where 
               the current mode is <var>M/P</var> (mode <var>M</var> in package <var>P</var>), the effect 
               is that the current mode for evaluation of <var>R</var> 
               remains <var>M/P</var> rather than reverting to its corresponding mode <var>M/Q</var> 
               (mode <var>M</var> in package <var>Q</var>). 
               If <var>R</var> contains an <elcode>xsl:apply-templates</elcode> instruction that uses
               <code>mode="#current"</code>, then the set of template rules considered by this instruction 
               will therefore include any overriding template rules declared in <var>P</var> as well as the original 
               rules declared in <var>Q</var>.
            </p></note>
            
            <p>If no matching template rule is found that satisfies these criteria, the built-in
               template rule for the context item is used (see
                  <specref ref="built-in-rule"/>).</p>
            <p>An <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> instruction
               may use <elcode>xsl:with-param</elcode> child elements to pass parameters to the
               chosen <termref def="dt-template-rule">template rule</termref> (see <specref ref="with-param"/>). It also passes on any <termref def="dt-tunnel-parameter">tunnel parameters</termref> as described in <specref ref="tunnel-params"/>.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0560">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if
                        <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode> is
                     evaluated when the <termref def="dt-current-template-rule">current template
                        rule</termref> is <termref def="dt-absent"/>.</p>
               </error>
            </p>
            <example>
               <head>Using <elcode>xsl:apply-imports</elcode>
               </head>
               <p>For example, suppose the stylesheet <code>doc.xsl</code> contains a <termref def="dt-template-rule">template rule</termref> for <code>example</code>
                  elements:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="example"&gt;
  &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;
&lt;/xsl:template&gt;</eg>
               <p>Another stylesheet could import <code>doc.xsl</code> and modify the treatment of
                     <code>example</code> elements as follows:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="example"&gt;
  &lt;div style="border: solid red"&gt;
     &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;</eg>
               <p>The combined effect would be to transform an <code>example</code> into an element
                  of the form:</p>
               <eg xml:space="preserve" role="xml">&lt;div style="border: solid red"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</eg>
            </example>
            <p>An <elcode>xsl:fallback</elcode> instruction appearing as a child of an
                  <elcode>xsl:next-match</elcode> instruction is ignored by an XSLT 2.0 or 3.0 processor, but can be used to define fallback
               behavior when the stylesheet is processed by an XSLT 1.0 processor with forwards
               compatible behavior.</p>
         </div2>
         <div2 id="parameters-to-template-rules">
            <head>Passing Parameters to Template Rules</head>
            <p>A template rule may have parameters. The parameters are declared in the body of the
               template using <elcode>xsl:param</elcode> elements, as described in <specref ref="parameters"/>.</p>

            <p>Values for these parameters may be supplied in the calling
                  <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, or
                  <elcode>xsl:next-match</elcode> instruction by means of
                  <elcode>xsl:with-param</elcode> elements appearing as children of the calling
               instruction. The <termref def="dt-expanded-qname">expanded QName</termref>
               represented by the <code>name</code> attribute of the <elcode>xsl:with-param</elcode>
               element must match the <termref def="dt-expanded-qname">expanded QName</termref>
               represented by the <code>name</code> attribute of the corresponding
                  <elcode>xsl:param</elcode> element. </p>



            <p>It is not an error for these instructions to supply a parameter that does not match
               any parameter declared in the template rule that is invoked; unneeded parameter
               values are simply ignored.</p>

            <p>A parameter may be declared as a <termref def="dt-tunnel-parameter">tunnel
                  parameter</termref> by specifying <code>tunnel="yes"</code> in the
                  <elcode>xsl:param</elcode> declaration; in this case the caller must supply the
               value as a tunnel parameter by specifying <code>tunnel="yes"</code> in the
               corresponding <elcode>xsl:with-param</elcode> element. Tunnel parameters differ from
               ordinary template parameters in that they are passed transparently through multiple
               template invocations. They are fully described in <specref ref="tunnel-params"/>.</p>

         </div2>
      </div1>
      <div1 id="repetition">
         <head>Repetition</head>
         <p>XSLT offers two constructs for processing each <phrase diff="chg">entry in a collection</phrase>:
               <elcode>xsl:for-each</elcode> and <elcode>xsl:iterate</elcode>.</p>
         <p diff="add" at="A">Both instructions can be used to process the items in a sequence, the
         elements in an array, or the entries in a map. Arrays and maps are processed by reducing them
         to a sequence of items, so in what follows, the terms <term>item</term> and <term>sequence</term> 
         are used generically.</p>
         <p>The main difference between the two constructs is that with
               <elcode>xsl:for-each</elcode>, the processing applied to each item in the sequence is
            independent of the processing applied to any other item; this means that the items may
            be processed in any order or in parallel, though the order of the output sequence is
            well defined and corresponds to the order of the input (sorted if so requested). By
            contrast, with <elcode>xsl:iterate</elcode>, the processing is explicitly sequential:
            while one item is being processed, values may be computed which are then available for
            use while the next item is being processed. This makes <elcode>xsl:iterate</elcode>
            suitable for tasks such as creating a running total over a sequence of financial
            transactions.</p>
         <p>A further difference is that <elcode>xsl:for-each</elcode> permits
            sorting of the input sequence, while <elcode>xsl:iterate</elcode> does not.</p>
         <div2 id="for-each">
            <head>The <code>xsl:for-each</code> instruction</head>
            <?element xsl:for-each?>
            <p diff="del" at="B">The attributes <code>select</code>, <code>array</code>, and <code>map</code>
            are mutually exclusive: exactly one of these three attributes must be present.</p>
            <p diff="del" at="B">Specifying <code>array="EXPR"</code> is equivalent to specifying
            <code>select="array:for-each(EXPR, function($x){map{'value':$x})?*</code>. That is, it maps the
            elements of an input array to a sequence of items, each item being a map having a single entry, whose
            key is the string <code>value</code> and whose corresponding value is the relevant element of the
            array. Within the contained sequence constructor, the current array element can be refered to
            as <code>?value</code>.</p>
            <p diff="del" at="B">Specifying <code>map="EXPR"</code> is equivalent to specifying
               <code>select="map:for-each(EXPR, function($k, $v){map{'key':$k, 'value':$v})</code>. That is, it maps the
               key-value entries of an input map to a sequence of items (in undefined order), each item being a map having 
               two entries, one entry holding the key, and the other holding the value. 
               Within the contained sequence constructor, the key and value of the current entry in the input map
               can be refered to as <code>?key</code> and <code>?value</code> respectively.</p>
            <p>The <elcode>xsl:for-each</elcode> instruction processes each  in a sequence of
               items, evaluating the <termref def="dt-sequence-constructor">sequence
                  constructor</termref> within the <elcode>xsl:for-each</elcode> instruction once
               for each item in that sequence.</p>
            <p> The <code>select</code> attribute is <rfc2119>required</rfc2119>; it contains an
                  <termref def="dt-expression">expression</termref> which is evaluated to produce a
               sequence, called the input sequence. If there is an <elcode>xsl:sort</elcode> element
               present (see <specref ref="sorting"/>) the input sequence is sorted to produce a
               sorted sequence. Otherwise, the sorted sequence is the same as the input
               sequence.</p>
            <p>The <elcode>xsl:for-each</elcode> instruction contains a <termref def="dt-sequence-constructor">sequence constructor</termref>. The <termref def="dt-sequence-constructor">sequence constructor</termref> is evaluated once for
               each item in the sorted sequence, with the <termref def="dt-focus">focus</termref>
               set as follows:</p>
            <ulist>
               <item>
                  <p>The <termref def="dt-context-item">context item</termref> is the item being
                     processed. 
                  </p>
               </item>
               <item>
                  <p>The <termref def="dt-context-position">context position</termref> is the
                     position of this item in the sorted sequence.</p>
               </item>
               <item>
                  <p>The <termref def="dt-context-size">context size</termref> is the size of the
                     sorted sequence (which is the same as the size of the input sequence).</p>
               </item>
            </ulist>
            <p> For each item in the input sequence, evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> produces a sequence
               of items (see <specref ref="sequence-constructors"/>). These output sequences are
               concatenated; if item <var>Q</var> follows item <var>P</var> in the sorted sequence,
               then the result of evaluating the sequence constructor with <var>Q</var> as the
               context item is concatenated after the result of evaluating the sequence constructor
               with <var>P</var> as the context item. The result of the
                  <elcode>xsl:for-each</elcode> instruction is the concatenated sequence of
               items.</p>
            
            <example>
               <head>Using <elcode>xsl:for-each</elcode> to process a sequence</head>
               <p>For example, given an XML document with this structure</p>
               <eg xml:space="preserve" role="xml">&lt;customers&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
&lt;/customers&gt;</eg>
               <p>the following would create an HTML document containing a table with a row for each
                     <code>customer</code> element</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Customers&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;table&gt;
	 &lt;tbody&gt;
	  &lt;xsl:for-each select="customers/customer"&gt;
	    &lt;tr&gt;
	      &lt;th&gt;
           &lt;xsl:apply-templates select="name"/&gt;
	      &lt;/th&gt;
	      &lt;xsl:for-each select="order"&gt;
           &lt;td&gt;
             &lt;xsl:apply-templates/&gt;
           &lt;/td&gt;
	      &lt;/xsl:for-each&gt;
	    &lt;/tr&gt;
	  &lt;/xsl:for-each&gt;
	&lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example diff="chg" at="B">
               <head>Using <elcode>xsl:for-each</elcode> to process an array</head>
               <p>Consider a JSON document of the form:</p>
               <eg>[
  { "city": "London", "latitude": 51.5099, "longitude": -0.1181 },
  { "city": "Paris",  "latitude": 48.8647, "longitude": 2.3488 },
  { "city": "Berlin", "latitude": 52.5200, "longitude": 13.4049 }                  
]</eg>
            <p>The following code processes this array to produce an XML representation of the same information. The
               cities are sorted by name:</p>
               <eg><![CDATA[<xsl:for-each select="json-doc('input.json')?*">
   <xsl:sort select="?city"/>
   <city number="{position()}" 
         name="{?city}" 
         latitude="{?latitude}" 
         longitude="{?longitude}"/>
</xsl:for-each>]]></eg>
               <p>In this example it is possible to use the expression <code>$array?*</code> to convert an array to a sequence.
               This works because the members of the array are all single items. In the more general case (a member
               of the array might be an empty sequence, corresponding to the JSON value <code>null</code>, or it
               might be a sequence containing several items), the function <code>array:members</code> can be
               used to deliver the contents of the array as a sequence of <emph>parcels</emph>, and the contents
               of each parcel can be extracted (as a sequence) using the <function>unparcel</function> function.</p>
            </example>
            <example diff="add" at="B">
               <head>Using <elcode>xsl:for-each</elcode> to process a map</head>
               <p>Consider a JSON document of the form:</p>
               <eg>{
  "London": {"latitude": 51.5099, "longitude": -0.1181 },
  "Paris":  {"latitude": 48.8647, "longitude": 2.3488 },
  "Berlin": {"latitude": 52.5200, "longitude": 13.4049 }                  
}</eg>
               <p>The following code processes this map to produce an XML representation of the same information. The
                  cities are sorted by name:</p>
               <eg><![CDATA[<xsl:for-each select="map:key-value-pairs(json-doc('input.json'))">
   <xsl:sort select="?key"/>
   <city number="{position()}" 
         name="{?key}" 
         latitude="{?value?latitude}" 
         longitude="{?value?longitude}"/>
</xsl:for-each>]]></eg>
               <p>In this example the map is decomposed to a sequence of key-value pairs, each represented as
               a map with two entries, <code>"key"</code> and <code>"value"</code>, which can be accessed using
               the lookup expressions <code>?key</code> and <code>?value</code>.</p>
            </example>
            <div3 id="for-each-separator" diff="add" at="A">
               <head>The <code>separator</code> attribute</head>
            
            <p>If the <code>separator</code> attribute is present, then its <termref def="dt-effective-value"/>
               is inserted, as a text node, into the output sequence, immediately after the results of processing each item in the sorted
               sequence other than the last.</p>
            <p>For example, the following instruction:</p>
            <eg><![CDATA[
<xsl:for-each select="6, 3, 9" separator="|">
   <xsl:sort select="."/>
   <xsl:sequence-of select="., .+1"/>
</xsl:for-each>]]></eg>
            <p>produces a sequence comprising, in order: the integer 3, the integer 4, a text node with string value <code>"|"</code>,
               the integer 6, the integer 7, another text node with string value <code>"|"</code>,
            the integer 9, and the integer 10.</p>
            <p>The node identity of any text nodes that are inserted is <termref def="dt-implementation-dependent"/>. Specifically,
            it is not defined whether all the text nodes inserted in the course of one evaluation of the instruction are identical
            to each other, nor whether they are identical to the text nodes inserted in the course of another evaluation of this
            instruction, nor whether they are identical to any other parentless text nodes having the same string value.</p>
            <p>If the separator is a zero-length string, then a zero-length text node is inserted into the sequence. (If the
            sequence is used for constructing the value of a node, then zero-length text nodes will be discarded: see
               <specref ref="constructing-simple-content"/> and <specref ref="constructing-complex-content"/>.)</p>
            </div3>
         </div2>
         <div2 id="iterate">
            <head>The <code>xsl:iterate</code> Instruction</head>
            
            <p>The <code>xsl:iterate</code> instruction processes the items in a sequence
            in order; unlike <code>xsl:for-each</code>, the result of processing one item can affect the way that
            subsequent items are processed.</p>
            
            <p diff="add" at="A">As with <code>xsl:for-each</code>, the instruction is extended in XSLT 4.0 to allow maps and arrays
            to be processed.</p>
            
            <?element xsl:iterate?>
            <?element xsl:next-iteration?>
            <?element xsl:break?>
            <?element xsl:on-completion?>
            <p diff="del" at="A">The attributes <code>select</code>, <code>array</code>, and <code>map</code>
               are mutually exclusive: exactly one of these three attributes must be present.</p>
            <p diff="del" at="A">Specifying <code>array="EXPR"</code> is equivalent to specifying
               <code>select="array:for-each(EXPR, function($x){map{'value':$x})?*</code>. That is, it maps the
               elements of an input array to a sequence of items, each item being a map having a single entry, whose
               key is the string <code>value</code> and whose corresponding value is the relevant element of the
               array. Within the contained sequence constructor, the current array element can be refered to
               as <code>?value</code>.</p>
            <p diff="del" at="A">Specifying <code>map="EXPR"</code> is equivalent to specifying
               <code>select="map:for-each(EXPR, function($k, $v){map{'key':$k, 'value':$v})</code>. That is, it maps the
               key-value entries of an input map to a sequence of items (in undefined order), each item being a map having 
               two entries, one entry holding the key, and the other holding the value. 
               Within the contained sequence constructor, the key and value of the current entry in the input map
               can be refered to as <code>?key</code> and <code>?value</code> respectively.</p>
            
            
            <p>The <code>select</code> attribute contains an
                  <termref def="dt-expression">expression</termref> which is evaluated to produce a
               sequence, called the input sequence.</p>
            <p>The <termref def="dt-sequence-constructor"/> contained in the
                  <elcode>xsl:iterate</elcode> instruction is evaluated once for each item in the
               input sequence, in order, or until the loop exits by evaluating an
                  <elcode>xsl:break</elcode> instruction, whichever is earlier. Within the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the body
               of the <elcode>xsl:iterate</elcode> instruction, the <termref def="dt-context-item">context item</termref> is set to each item from the value of the
                  <code>select</code> expression in turn; the <termref def="dt-context-position">context position</termref> reflects the position of this item in the input
               sequence, and the <termref def="dt-context-size">context size</termref> is the number
               of items in the input sequence (which may be greater than the number of iterations,
               if the loop exits prematurely using <elcode>xsl:break</elcode>).</p>
            <note>
               <p>If <elcode>xsl:iterate</elcode> is used in conjunction with
                     <elcode>xsl:source-document</elcode> to achieve streaming, calls on the function
                     <xfunction>last</xfunction> will be disallowed. </p>
            </note>

            <p>The <elcode>xsl:break</elcode> and
                  <elcode>xsl:on-completion</elcode> elements may have either a <code>select</code>
               attribute or a non-empty contained <termref def="dt-sequence-constructor"/> but not
               both. The effect of the element in both cases is obtained by evaluating the
                  <code>select</code> expression if present or the contained sequence constructor
               otherwise; if neither is present, the value is an empty sequence.</p>
            
            <note>
               <p>The <elcode>xsl:on-completion</elcode> element appears before other children
                  of <elcode>xsl:iterate</elcode>
                  to ensure that variables declared in the sequence constructor are not in scope
                  within <elcode>xsl:on-completion</elcode>, since such variables do not have a
                  defined value within <elcode>xsl:on-completion</elcode> especially in the case
                  where the value of the <code>select</code> attribute is an empty sequence.</p>
            </note>

            <p>The effect of <elcode>xsl:next-iteration</elcode> is to cause the iteration to
               continue by processing the next item in the input sequence, potentially with
               different values for the iteration parameters. The effect of
                  <elcode>xsl:break</elcode> is to cause the iteration to finish, whether or not all
               the items in the input sequence have been processed. In both cases the affected
               iteration is the one controlled by the innermost ancestor
                  <elcode>xsl:iterate</elcode> element.</p>
            <p>The instructions <elcode>xsl:next-iteration</elcode> and <elcode>xsl:break</elcode>
               are allowed only as descendants of an <elcode>xsl:iterate</elcode> instruction, and
               only in a <termref def="dt-tail-position">tail position</termref> within the <termref def="dt-sequence-constructor">sequence constructor</termref> forming the body of
               the <elcode>xsl:iterate</elcode> instruction. </p>

            <p>
               <termdef id="dt-tail-position" term="tail position" open="true">An <termref def="dt-instruction">instruction</termref>
                  <var>J</var> is in a <term>tail position</term> within a <termref def="dt-sequence-constructor">sequence constructor</termref>
                  <var>SC</var> if it satisfies one of the following conditions:</termdef></p>

            <ulist>
               <item>
                  <p><var>J</var> is the last instruction in <var>SC</var>, ignoring any
                        <elcode>xsl:fallback</elcode> instructions.</p>
               </item>
               <item>
                  <p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:if</elcode> instruction that is itself in a <termref def="dt-tail-position">tail position</termref> within <var>SC</var>.</p>
               </item>
               <item>
                  <p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:when</elcode> or <elcode>xsl:otherwise</elcode> branch of an
                        <elcode>xsl:choose</elcode> instruction that is itself in a <termref def="dt-tail-position">tail position</termref> within <var>SC</var>.</p>
               </item>

               <item>
                  <p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:try</elcode> instruction that is itself in a <termref def="dt-tail-position">tail position</termref> within <var>SC</var> (that
                     is, it is immediately followed by an <elcode>xsl:catch</elcode> element,
                     ignoring any <elcode>xsl:fallback</elcode> elements).</p>
               </item>
               <item>
                  <p><var>J</var> is in a <termref def="dt-tail-position">tail position</termref>
                     within the sequence constructor that forms the body of an
                        <elcode>xsl:catch</elcode> element within an <elcode>xsl:try</elcode>
                     instruction that is itself in a <termref def="dt-tail-position">tail
                        position</termref> within <var>SC</var>.</p>
               </item>
            </ulist>
            <p role="closetermdef"/>

            <p>
               <error spec="XT" type="static" class="SE" code="3120">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:break</elcode> or <elcode>xsl:next-iteration</elcode> element
                     appears other than in a <termref def="dt-tail-position">tail position</termref>
                     within the <termref def="dt-sequence-constructor">sequence
                        constructor</termref> forming the body of an <elcode>xsl:iterate</elcode>
                     instruction.</p>
               </error>
            </p>

            <p>
               <error spec="XT" type="static" class="SE" code="3125">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of <elcode>xsl:break</elcode> or
                        <elcode>xsl:on-completion</elcode> is present and the instruction has
                     children.</p>
               </error>
            </p>

            <p>
               <error spec="XT" type="static" class="SE" code="3130">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>name</code> attribute of an <elcode>xsl:with-param</elcode> child of
                     an <elcode>xsl:next-iteration</elcode> element does not match the
                        <code>name</code> attribute of an <elcode>xsl:param</elcode> child of the
                        innermost containing
                        <elcode>xsl:iterate</elcode> instruction.</p>
               </error>
            </p>

            <p>Parameter names in <elcode>xsl:with-param</elcode> must be unique: <errorref spec="XT" class="SE" code="0670"/>.</p>

            <p>The result of the <elcode>xsl:iterate</elcode> instruction is the concatenation of
               the sequences that result from the repeated evaluation of the contained <termref def="dt-sequence-constructor">sequence constructor</termref>, followed by the
               sequence that results from evaluating the <elcode>xsl:break</elcode> or
                  <elcode>xsl:on-completion</elcode> element if any.</p>
            <p>Any <elcode>xsl:param</elcode> element that appears as a child of
                  <elcode>xsl:iterate</elcode> declares a parameter whose value may vary from one
               iteration to the next. The initial value of the parameter is the value obtained
               according to the rules given in <specref ref="variable-values"/>. The dynamic context
               for evaluating the initial value of an <elcode>xsl:param</elcode> element is the same
               as the dynamic context for evaluating the <code>select</code> expression of the
                  <elcode>xsl:iterate</elcode> instruction (the context item is thus
                  <emph>not</emph> the first item in the input sequence).</p>
            <p>On the first iteration a parameter always takes its initial value (which may depend
               on variables or other aspects of the dynamic context). Subsequently:</p>
            <ulist>
               <item>
                  <p>If an <elcode>xsl:next-iteration</elcode> instruction is evaluated, then
                     parameter values for processing the next item in the input sequence can be set
                     in the <elcode>xsl:with-param</elcode> children of that instruction; in the
                     absence of an <elcode>xsl:with-param</elcode> element that names a particular
                     parameter, that parameter will retain its value from the previous
                     iteration.</p>
               </item>
               <item>
                  <p>If an <elcode>xsl:break</elcode> instruction is evaluated, no further items in
                     the input sequence are processed.</p>
               </item>
               <item>
                  <p>If neither an <elcode>xsl:next-iteration</elcode> nor an
                        <elcode>xsl:break</elcode> instruction is evaluated, then the next item in
                     the input sequence is processed using parameter values that are unchanged from
                     the previous iteration.</p>
               </item>
            </ulist>


            <p>The <elcode>xsl:next-iteration</elcode> instruction contributes nothing to the result
               sequence (technically, it returns an empty sequence). The instruction supplies
               parameter values for the next iteration, which are evaluated according to the rules
               given in <specref ref="with-param"/>; if there are no further items in the input
               sequence then it supplies parameter values for use while evaluating the body of the
                  <elcode>xsl:on-completion</elcode> element if any.</p>
            <p>The <elcode>xsl:break</elcode> instruction indicates that the iteration should
               terminate without processing any remaining items from the input sequence. The <code>select</code> expression or  contained sequence
               constructor is evaluated using the same context item, position, and size as the
                  <elcode>xsl:break</elcode> instruction itself, and the result is appended to the
               result of the <elcode>xsl:iterate</elcode> instruction as a whole.</p>
            <p>If neither an <elcode>xsl:next-iteration</elcode> nor an <elcode>xsl:break</elcode>
               instruction is evaluated, the next item in the input sequence is processed with
               parameter values unchanged from the previous iteration; if there are no further items
               in the input sequence, the iteration terminates.</p>
            <p>The optional <elcode>xsl:on-completion</elcode> element (which is not technically an
                  <termref def="dt-instruction">instruction</termref> and is not technically part of
               the <termref def="dt-sequence-constructor"/>) is evaluated when the input sequence is
               exhausted. It is not evaluated if the evaluation is terminated using
                  <elcode>xsl:break</elcode>. During evaluation of its <code>select</code> expression or sequence constructor
               the context item, position, and size are <termref def="dt-absent">absent</termref>
               (that is, any reference to these values is an error). However, the values of the
               parameters to <elcode>xsl:iterate</elcode> are available, and take the values
               supplied by the <elcode>xsl:next-iteration</elcode> instruction evaluated while
               processing the last item in the sequence.</p>
            <p>If the input sequence is empty, then the result of the
                  <elcode>xsl:iterate</elcode> instruction is the result of evaluating the <code>select</code> attribute or <termref def="dt-sequence-constructor">sequence constructor</termref> forming the body of
               the <elcode>xsl:on-completion</elcode> element, using the initial values of the
                  <elcode>xsl:param</elcode> elements. If there is no
                  <elcode>xsl:on-completion</elcode> element, the result is an empty sequence.</p>

            <note>
               <p>Conceptually, <elcode>xsl:iterate</elcode> behaves like a tail-recursive function.
                  The <elcode>xsl:next-iteration</elcode> instruction then represents the recursive
                  call, supplying the tail of the input sequence as an implicit parameter. There are
                  two main reasons for providing the <elcode>xsl:iterate</elcode> instruction. One
                  is that many XSLT users find writing recursive functions to be a difficult skill,
                  and this construct promises to be easier to learn. The other is that recursive
                  function calls are difficult for an optimizer to analyze. Because
                     <elcode>xsl:iterate</elcode> is more constrained than a general-purpose
                  head-tail recursive function, it should be more amenable to optimization. In
                  particular, when the instruction is used in conjunction with
                     <elcode>xsl:source-document</elcode>, it is designed to make it easy for the
                  implementation to use streaming techniques, processing the nodes in an input
                  document sequentially as they are read, without building the entire document tree
                  in memory.</p>
            </note>

            <p>The examples below use <elcode>xsl:iterate</elcode> in conjunction with the
                  <elcode>xsl:source-document</elcode> instruction. This is not the only way of using
                  <elcode>xsl:iterate</elcode>, but it illustrates the way in which the two features
               can be combined to achieve streaming of a large input document.</p>



            <example>
               <head>Using <elcode>xsl:iterate</elcode> to Compute Cumulative Totals</head>
               <p>Suppose that the input XML document has this structure</p>
               <eg xml:space="preserve" role="xml">&lt;transactions&gt;
  &lt;transaction date="2008-09-01" value="12.00"/&gt;
  &lt;transaction date="2008-09-01" value="8.00"/&gt;
  &lt;transaction date="2008-09-02" value="-2.00"/&gt;
  &lt;transaction date="2008-09-02" value="5.00"/&gt;
&lt;/transactions&gt;</eg>
               <p>and that the requirement is to transform this to:</p>
               <eg xml:space="preserve" role="xml">&lt;account&gt;
  &lt;balance date="2008-09-01" value="12.00"/&gt;
  &lt;balance date="2008-09-01" value="20.00"/&gt;
  &lt;balance date="2008-09-02" value="18.00"/&gt;
  &lt;balance date="2008-09-02" value="23.00"/&gt;
&lt;/account&gt;</eg>
               <p>This can be achieved using the following code, which is designed to process the
                  transaction file using streaming:</p>
               <eg xml:space="preserve" role="xslt-fragment">&lt;account&gt;
  &lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;balance date="{@date}" value="{format-number($newBalance, '0.00')}"/&gt;
      &lt;xsl:next-iteration&gt;
        &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
      &lt;/xsl:next-iteration&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:source-document&gt;
&lt;/account&gt;</eg>
               <p>The following example modifies this by only outputting the information for the
                  first day’s transactions:</p>
               <eg xml:space="preserve" role="xslt-fragment">&lt;account&gt;
  &lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:param name="prevDate" select="()" as="xs:date?"/&gt;
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;xsl:variable name="thisDate" 
                    select="xs:date(@date)"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="empty($prevDate) or $thisDate eq $prevDate"&gt;
          &lt;balance date="{$thisDate}" 
                   value="{format-number($newBalance, '0.00')}"/&gt;
          &lt;xsl:next-iteration&gt;
            &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
            &lt;xsl:with-param name="prevDate" select="$thisDate"/&gt;
          &lt;/xsl:next-iteration&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:break/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:iterate&gt;
  &lt;/xsl:source-document&gt;
&lt;/account&gt;</eg>
               <p>The following code outputs the balance only at the end of each day, together with
                  the final balance:</p>
               <eg xml:space="preserve" role="xslt-fragment">&lt;account&gt;
  &lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
    &lt;xsl:iterate select="transactions/transaction"&gt;
      &lt;xsl:param name="balance" select="0.00" as="xs:decimal"/&gt;
      &lt;xsl:param name="prevDate" select="()" as="xs:date?"/&gt;
      &lt;xsl:on-completion&gt;
        &lt;balance date="{$prevDate}" 
                 value="{format-number($balance, '0.00')}"/&gt;
      &lt;/xsl:on-completion&gt;     
      &lt;xsl:variable name="newBalance" 
                    select="$balance + xs:decimal(@value)"/&gt;
      &lt;xsl:variable name="thisDate" select="xs:date(@date)"/&gt;
      &lt;xsl:if test="exists($prevDate) and $thisDate ne $prevDate"&gt;
        &lt;balance date="{$prevDate}" 
                 value="{format-number($balance, '0.00')}"/&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:next-iteration&gt;
        &lt;xsl:with-param name="balance" select="$newBalance"/&gt;
        &lt;xsl:with-param name="prevDate" select="$thisDate"/&gt;
      &lt;/xsl:next-iteration&gt;     
    &lt;/xsl:iterate&gt;
  &lt;/xsl:source-document&gt;
&lt;/account&gt;</eg>
               <p>If the sequence of transactions is empty, this code outputs a single element:
                     <code>&lt;balance date="" value="0.00"/&gt;</code>.</p>
            </example>
            <example>
               <head>Collecting Multiple Values in a Single Pass</head>
               <p>Problem: Given a sequence of <code>employee</code> elements, find the employees
                  having the highest and lowest salary, while processing each employee only
                  once.</p>
               <p>Solution:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:source-document streamable="yes" href="si-iterate-035.xml"&gt;
            &lt;xsl:iterate select="employees/employee"&gt;
                &lt;xsl:param name="highest" as="element(employee)*"/&gt;
                &lt;xsl:param name="lowest" as="element(employee)*"/&gt;
                &lt;xsl:on-completion&gt;
                    &lt;highest-paid-employees&gt;
                        &lt;xsl:value-of select="$highest/name"/&gt;
                    &lt;/highest-paid-employees&gt;
                    &lt;lowest-paid-employees&gt;
                        &lt;xsl:value-of select="$lowest/name"/&gt;
                    &lt;/lowest-paid-employees&gt;  
                &lt;/xsl:on-completion&gt;
                &lt;xsl:variable name="this" select="copy-of()"/&gt;
                &lt;xsl:variable name="is-new-highest" as="xs:boolean"
                    select="empty($highest[@salary ge current()/@salary])"/&gt;
                &lt;xsl:variable name="is-equal-highest" as="xs:boolean" 
                    select="exists($highest[@salary eq current()/@salary])"/&gt; 
                &lt;xsl:variable name="is-new-lowest" as="xs:boolean" 
                    select="empty($lowest[@salary le current()/@salary])"/&gt;
                &lt;xsl:variable name="is-equal-lowest" as="xs:boolean" 
                    select="exists($lowest[@salary eq current()/@salary])"/&gt; 
                &lt;xsl:variable name="new-highest-set" as="element(employee)*"
                    select="if ($is-new-highest) then $this
                    else if ($is-equal-highest) then ($highest, $this)
                    else $highest"/&gt;
                &lt;xsl:variable name="new-lowest-set" as="element(employee)*"
                    select="if ($is-new-lowest) then $this
                    else if ($is-equal-lowest) then ($lowest, $this)
                    else $lowest"/&gt;
                &lt;xsl:next-iteration&gt;
                    &lt;xsl:with-param name="highest" select="$new-highest-set"/&gt;
                    &lt;xsl:with-param name="lowest" select="$new-lowest-set"/&gt;
                &lt;/xsl:next-iteration&gt;
            &lt;/xsl:iterate&gt;
        &lt;/xsl:source-document&gt;</eg>
               <p>If the input sequence is empty, this code outputs an empty
                     <code>highest-paid-employees</code> element and an empty
                     <code>lowest-paid-employees</code> element.</p>
            </example>
            <example>
               <head>Processing the Last Item in a Sequence Specially</head>
               <p>When streaming, it is not possible to determine whether the item being processed
                  is the last in a sequence without reading ahead. The <xfunction>last</xfunction>
                  function therefore cannot be used in <termref def="dt-guaranteed-streamable"/>
                  code. The <elcode>xsl:iterate</elcode> instruction provides a solution to this
                  problem.</p>
               <p>Problem: render the last paragraph in a section in some special way, for example
                  by using bold face. (The actual rendition is achieved by processing the paragraph
                  with mode <code>last-para</code>.)</p>
               <p>The solution uses <elcode>xsl:iterate</elcode>
                  together with the <function>copy-of</function>
                     function to maintain a one-element look-ahead by explicit coding:</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:template match="section" mode="streaming"&gt;
   &lt;xsl:iterate select="para"&gt;
     &lt;xsl:param name="prev" select="()" as="element(para)?"/&gt;
     &lt;xsl:on-completion&gt;
       &lt;xsl:apply-templates select="$prev" mode="last-para"/&gt;      
     &lt;/xsl:on-completion&gt;
     &lt;xsl:if test="$prev"&gt;
       &lt;xsl:apply-templates select="$prev"/&gt;
     &lt;/xsl:if&gt;
     &lt;xsl:next-iteration&gt;
       &lt;xsl:with-param name="prev" select="copy-of(.)"/&gt;
     &lt;/xsl:next-iteration&gt;
   &lt;/xsl:iterate&gt;
 &lt;/xsl:template&gt;</eg>

            </example>
            <example diff="add" at="A">
               <head>Processing an array using <code>xsl:iterate</code></head>
               <p>Consider the following JSON document representing transactions in a bank account:</p>
               <eg>[
   {"date":"2008-09-01", credit:12.00},
   {"date":"2008-09-01", credit:8.00},
   {"date":"2008-09-02", debit:2.00},
   {"date":"2008-09-02", credit:12.00}
]</eg>
               <p>The following code converts this to an XML representation that includes a running balance:</p>
               <eg><![CDATA[<xsl:iterate array="json-doc('account.json')">
   <xsl:param name="balance" as="xs:decimal" select="0"/>               
   <xsl:variable name="delta" select="?value?credit otherwise -?value?debit"/>               
   <entry date="{?value?date}"
          amount="{$delta}"
          balance="{$balance + $delta}"/>
   <xsl:next-iteration>
      <xsl:with-param name="balance" select="$balance + $delta"/>
   </xsl:next-iteration>   
</xsl:iterate>]]></eg>
            </example>
         </div2>
      </div1>
      <div1 id="conditionals">
         <head>Conditional Processing</head>
         <p>There are several instructions in XSLT that support conditional processing:
               <elcode>xsl:if</elcode>, <elcode>xsl:choose</elcode><phrase diff="add" at="A">, and <elcode>xsl:switch</elcode></phrase>. 
            The <elcode>xsl:if</elcode>
            instruction provides simple if-then conditionality; the <elcode>xsl:choose</elcode>
            instruction supports selection of one choice when there are several possibilities,
            <phrase diff="add" at="A">and <elcode>xsl:switch</elcode> allows a branch to be selected based on the value of a given
         expression.</phrase></p>
         <p>XSLT 3.0 also supports <elcode>xsl:try</elcode> and
               <elcode>xsl:catch</elcode> which define conditional processing to handle <termref def="dt-dynamic-error">dynamic errors</termref>.</p>
         <div2 id="xsl-if">
            <head>Conditional Processing with <elcode>xsl:if</elcode>
            </head>
            <?element xsl:if?>
            <p>The <elcode>xsl:if</elcode> element has a mandatory <code>test</code> attribute,
               which specifies an <termref def="dt-expression">expression</termref>. The content is
               a <termref def="dt-sequence-constructor"/>.</p>
            <p diff="add" at="A">If the <elcode>xsl:if</elcode> element has a <code>then</code> attribute, then it
               <rfc2119>must</rfc2119> have no children. That is, the <code>then</code> attribute and the
               contained sequence constructor are mutually exclusive.</p>
            <p>The result of the <elcode>xsl:if</elcode> instruction depends on the <xtermref
               spec="XP40" ref="dt-ebv">effective boolean value</xtermref> of the expression in
               the <code>test</code> attribute. The rules for determining the effective boolean
               value of an expression are given in <bibref ref="xpath-30"/>: they are the same as
               the rules used for XPath conditional expressions.</p>
            <p diff="add" at="A">If the effective boolean value of the <termref def="dt-expression"
               >expression</termref> is true, then:</p>
            <ulist diff="add" at="A">
               <item><p>If there is a <code>then</code> attribute, the expression in the <code>then</code>
                  attribute is evaluated, and the resulting value is returned as the result of the 
                  <elcode>xsl:if</elcode> instruction.</p></item>
               <item><p>If there is a non-empty sequence constructor, it is evaluated and the
                  resulting value is returned as the result of the 
                  <elcode>xsl:if</elcode> instruction.</p></item>
               <item><p>Otherwise, the result of the 
                  <elcode>xsl:if</elcode> instruction is an empty sequence.</p></item>
            </ulist>
            
            <p diff="add" at="A">If the effective boolean value of the <termref def="dt-expression"
               >expression</termref> is false, then:</p>
            <ulist diff="add" at="A">
               <item><p>If there is an <code>else</code> attribute, the expression in the <code>else</code>
                  attribute is evaluated, and the resulting value is returned as the result of the 
                  <elcode>xsl:if</elcode> instruction.</p></item>
               <item><p>Otherwise, the result of the 
                  <elcode>xsl:if</elcode> instruction is an empty sequence.</p></item>
            </ulist>
            
            <example>
               <head>Using <elcode>xsl:if</elcode>
               </head>
               <p>In the following example, the names in a group of names are formatted as a comma
                  separated list:</p>
               <eg xml:space="preserve" role="xslt-declaration"><![CDATA[<xsl:template match="namelist/name">
  <xsl:apply-templates/>
  <xsl:if test="not(position()=last())">, </xsl:if>
</xsl:template>]]></eg>
               <p diff="add" at="A">The following colors alternating table rows red and yellow:</p>
               <eg xml:space="preserve" role="xslt-declaration" diff="chg" at="A"><![CDATA[<xsl:template match="item">
  <tr>
    <xsl:attribute name="bgcolor">
       <xsl:if test="position() mod 2 = 0" then "'red'" else "'yellow'"/>
    </xsl:attribute>
    <xsl:apply-templates/>
  </tr>
</xsl:template>]]></eg>
            </example>
         </div2>
         <div2 id="xsl-choose">
            <head>Conditional Processing with <elcode>xsl:choose</elcode>
            </head>
            <?element xsl:choose?>
            <?element xsl:when?>
            <?element xsl:otherwise?>
            <p>The <elcode>xsl:choose</elcode> element selects one among a number of possible
               alternatives. It consists of a sequence of one or more <elcode>xsl:when</elcode>
               elements followed by an optional <elcode>xsl:otherwise</elcode> element. Each
               <elcode>xsl:when</elcode> element has <phrase diff="chg" at="A">an</phrase> attribute, <code>test</code>, which
               specifies an <termref def="dt-expression">expression</termref>. The <phrase diff="chg" at="A">result of each
                  <elcode>xsl:when</elcode> and <elcode>xsl:otherwise</elcode> element is determined by either a
                  <code>select</code> attribute or a contained
                  <termref def="dt-sequence-constructor"/>.</phrase></p>
            <p diff="add" at="A">The effective value of an <elcode>xsl:when</elcode> or <elcode>xsl:otherwise</elcode>
               branch may be supplied using either a <code>select</code> attribute or a contained
               <termref def="dt-sequence-constructor"/>. These are
               mutually exclusive: if the <code>select</code> attribute is present then the
               sequence constructor must be empty, and if the sequence constructor is non-empty
               then the <code>select</code> attribute must be absent. If the <code>select</code>
               attribute is absent and the sequence constructor is empty, then the
               effective value is an empty sequence.</p>
            <p>When an <elcode>xsl:choose</elcode> element is processed, each of the
               <elcode>xsl:when</elcode> elements is tested in turn (that is, in the order that
               the elements appear in the stylesheet), until one of the <elcode>xsl:when</elcode>
               elements is satisfied. If none of the <elcode>xsl:when</elcode> elements is
               satisfied, then the <elcode>xsl:otherwise</elcode> element is considered, as
               described below.</p>
            <p>An <elcode>xsl:when</elcode> element is satisfied if the <xtermref spec="XP40"
               ref="dt-ebv">effective boolean value</xtermref> of the <termref
                  def="dt-expression">expression</termref> in its <code>test</code> attribute is
               <code>true</code>. The rules for determining the effective boolean value of an
               expression are given in <bibref ref="xpath-30"/>: they are the same as the rules used
               for XPath conditional expressions.</p>
            <p>The <phrase diff="del" at="A">content of the</phrase> first, and only the first, <elcode>xsl:when</elcode> element that
               is satisfied is evaluated, and the resulting sequence <phrase diff="add" at="A">(that is,
                  the result of evaluating its <code>select</code> attribute or contained <termref def="dt-sequence-constructor"/> 
                  as appropriate)</phrase> is returned as the result of
               the <elcode>xsl:choose</elcode> instruction. If no <elcode>xsl:when</elcode> element
               is satisfied, the content of the <elcode>xsl:otherwise</elcode> element is evaluated,
               and the resulting sequence is returned as the result of the
               <elcode>xsl:choose</elcode> instruction. If no <elcode>xsl:when</elcode> element
               is satisfied, and no <elcode>xsl:otherwise</elcode> element is present, the result of
               the <elcode>xsl:choose</elcode> instruction is an empty sequence.</p>
            <p><phrase diff="chg" at="A">The <code>select expressions</code> and sequence constructors of  
               <elcode>xsl:when</elcode> and
               <elcode>xsl:otherwise</elcode> instructions after the selected one are not evaluated.</phrase> 
               The <code>test</code>
               expressions for <elcode>xsl:when</elcode> instructions after the selected one are not
               evaluated.</p>
            <example>
               <head>Using <elcode>xsl:choose</elcode>
               </head>
               <p>The following example enumerates items in an ordered list using arabic numerals,
                  letters, or roman numerals depending on the depth to which the ordered lists are
                  nested.</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'"><![CDATA[<xsl:template match="orderedlist/listitem">
  <fo:list-item indent-start='2pi'>
    <fo:list-item-label>
      <xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/>
      <xsl:choose>
        <xsl:when test='$level=1'>
          <xsl:number format="i"/>
        </xsl:when>
        <xsl:when test='$level=2'>
          <xsl:number format="a"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:number format="1"/>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:text>. </xsl:text>
    </fo:list-item-label>
    <fo:list-item-body>
      <xsl:apply-templates/>
    </fo:list-item-body>
  </fo:list-item>
</xsl:template>]]></eg>
            </example>
            <example diff="add" at="A">
               <p>The following example is equivalent to the one above:</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'"><![CDATA[<xsl:template match="orderedlist/listitem">
  <fo:list-item indent-start='2pi'>
    <fo:list-item-label>
      <xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/>
      <xsl:variable name="format" as="xs:string">
        <xsl:choose>
          <xsl:when test='$level=1' select="'i'"/>
          <xsl:when test='$level=2' select="'a'"/>
          <xsl:otherwise select="'1'"/>
        </xsl:choose>
      </xsl:variable>  
      <xsl:number format="{$format}"/>
      <xsl:text>. </xsl:text>
    </fo:list-item-label>
    <fo:list-item-body>
      <xsl:apply-templates/>
    </fo:list-item-body>
  </fo:list-item>
</xsl:template>]]></eg>
            </example>
         </div2>
         
         <div2 diff="add" at="A" id="xsl-switch">
            <head>Conditional Processing with <elcode>xsl:switch</elcode>
            </head>
            <?element xsl:switch?>
            <?element xsl:when?>
            <?element xsl:otherwise?>
            <p>The <elcode>xsl:switch</elcode> element selects one among a number of possible
               alternatives. It consists of a sequence of one or more <elcode>xsl:when</elcode>
               elements followed by an optional <elcode>xsl:otherwise</elcode> element. Each
               <elcode>xsl:when</elcode> element has <phrase diff="chg">an</phrase> attribute, <code>test</code>, which
               specifies an <termref def="dt-expression">expression</termref>. The result of each
                  <elcode>xsl:when</elcode> and <elcode>xsl:otherwise</elcode> element is determined by either a
                  <code>select</code> attribute or a contained
                  <termref def="dt-sequence-constructor"/>.</p>
            <p>The effective value of an <elcode>xsl:when</elcode> or <elcode>xsl:otherwise</elcode>
               branch may be supplied using either a <code>select</code> attribute or a contained
               <termref def="dt-sequence-constructor"/>. These are
               mutually exclusive: if the <code>select</code> attribute is present then the
               sequence constructor must be empty, and if the sequence constructor is non-empty
               then the <code>select</code> attribute must be absent. If the <code>select</code>
               attribute is absent and the sequence constructor is empty, then the
               effective value is an empty sequence.</p>
            <p>Any <elcode>xsl:fallback</elcode> children are ignored by an XSLT 4.0 processor, but
               can be used to define the recovery action to be taken by a processor for an earlier version of XSLT when
               operating with <termref def="dt-forwards-compatible-behavior"/>.</p>
            <p>An <elcode>xsl:switch</elcode> element is processed as follows:</p>
            <ulist>
               <item><p>The <code>select</code> expression of the <elcode>xsl:switch</elcode>
                  element is evaluated.</p></item>
               <item><p>The result of the evaluation is converted to a single atomic value
                  by applying the <termref def="dt-coercion-rules"/>; a type error occurs
                  if this conversion is not possible. This value is referred to below as the
                  <term>selector</term>.</p></item>
               <item><p>Each of the
                  <elcode>xsl:when</elcode> elements is tested in turn (that is, in the order that
                  the elements appear in the stylesheet), until one of the <elcode>xsl:when</elcode>
                  elements is satisfied. If none of the <elcode>xsl:when</elcode> elements is
                  satisfied, then the <elcode>xsl:otherwise</elcode> element is considered, as
                  described below.</p>
                  <p>An <elcode>xsl:when</elcode> element is tested by first evaluating its <code>test</code>
                     expression and converting the result to a sequence of atomic values
                     by applying the <termref def="dt-coercion-rules"/>, and then
                     comparing this sequence of atomic values with the <code>selector</code> value. The
                     comparison is performed using the rules of the XPath "<code>=</code>" operator,
                     using the default collation that is in scope for the <elcode>xsl:switch</elcode>
                     instruction.</p>
                  
                  
                  <p>An <elcode>xsl:when</elcode> element is satisfied if the result of this comparison is
                     <code>true</code>.</p></item>
               <item><p>The first, and only the first, <elcode>xsl:when</elcode> element that
                  is satisfied is evaluated, and the resulting sequence <phrase diff="add" at="A">(that is,
                     the result of evaluating its <code>select</code> attribute or contained <termref def="dt-sequence-constructor"/> 
                     as appropriate)</phrase> is returned as the result of
                  the <elcode>xsl:switch</elcode> instruction. If no <elcode>xsl:when</elcode> element
                  is satisfied, the content of the <elcode>xsl:otherwise</elcode> element is evaluated,
                  and the resulting sequence is returned as the result of the
                  <elcode>xsl:switch</elcode> instruction. If no <elcode>xsl:when</elcode> element
                  is satisfied, and no <elcode>xsl:otherwise</elcode> element is present, the result of
                  the <elcode>xsl:switch</elcode> instruction is an empty sequence.</p></item>
               <item><p>The <code>select expressions</code> and sequence constructors of  
                  <elcode>xsl:when</elcode> and
                  <elcode>xsl:otherwise</elcode> instructions after the selected one are not evaluated. 
                  The <code>test</code>
                  expressions for <elcode>xsl:when</elcode> instructions after the selected one are not
                  evaluated.</p></item>
            </ulist>
            <note><p>There is no requirement that the values of <code>select</code> expressions
               should be literals, nor that the values should be distinct.</p></note>
            <example>
               <head>Using <elcode>xsl:switch</elcode>
               </head>
               <p>The following example shows a simple function to convert a month number to a month name:</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'"><![CDATA[<xsl:function name="f:month-name" as="xs:string">
    <xsl:param name="month-number" as="xs:integer">
    <xsl:switch select="$month-number">
      <xsl:when test="1" select="'January'"/>
      <xsl:when test="2" select="'February'"/>
      <xsl:when test="3" select="'March'"/>
      <xsl:when test="4" select="'April'"/>
      <xsl:when test="5" select="'May'"/>
      <xsl:when test="6" select="'June'"/>
      <xsl:when test="7" select="'July'"/>
      <xsl:when test="8" select="'August'"/>
      <xsl:when test="9" select="'September'"/>
      <xsl:when test="10" select="'October'"/>
      <xsl:when test="11" select="'November'"/>
      <xsl:when test="12" select="'December'"/>
      <xsl:otherwise select="error('Unknown month')"/>
    </xsl:switch>
  </xsl:function>]]></eg>
            </example>
            
            <p>The following example shows a function to return the number of days in the month (it returns
               an empty sequence if the supplied month is invalid):</p>
            <example>
            <eg xml:space="preserve"><![CDATA[<xsl:function name="f:days-in-month" as="xs:integer?">
    <xsl:param name="month-number" as="xs:integer">
    <xsl:param name="leap-year" as="xs:boolean">
    <xsl:switch select="$month-number">
      <xsl:when test="1, 3, 5, 7, 8, 10, 12" select="31"/>
      <xsl:when test="4, 6, 9, 11" select="30"/>
      <xsl:when test="2">
         <xsl:if test="$leap-year" then="29" else="28"/>
      </xsl:when>
    </xsl:switch>
  </xsl:function>]]></eg>
  </example>
            
         </div2>

         <div2 id="try-catch">
            <head>Try/Catch</head>

            <p>The <elcode>xsl:try</elcode> instruction can be used to trap
               dynamic errors occurring within the expression it wraps; the recovery action if such
               errors occur is defined using a child <elcode>xsl:catch</elcode> element.</p>

            <?element xsl:try?>
            <note>
               <p>Because a sequence constructor may contain an <elcode>xsl:fallback</elcode>
                  element, the effect of this content model is that an <elcode>xsl:fallback</elcode>
                  instruction may appear as a child of <elcode>xsl:try</elcode> in any position.</p>
            </note>
            <?element xsl:catch?>

            <p>An <elcode>xsl:try</elcode> instruction evaluates either the expression contained in
               its <code>select</code> attribute, or its contained <termref def="dt-sequence-constructor">sequence constructor</termref>, and returns the
               result of that evaluation if it succeeds without error. If a <termref def="dt-dynamic-error">dynamic error</termref> occurs during the evaluation, the
               processor evaluates the first <elcode>xsl:catch</elcode> child element applicable to
               the error, and returns that result instead.</p>

            <p>If the <elcode>xsl:try</elcode> element has a <code>select</code> attribute, then it
                  <rfc2119>must</rfc2119> have no children other than <elcode>xsl:catch</elcode> and
                  <elcode>xsl:fallback</elcode>. That is, the <code>select</code> attribute and the
               contained sequence constructor are mutually exclusive. If neither is present, the
               result of the <elcode>xsl:try</elcode> is an empty sequence (no dynamic error can
               occur in this case).</p>

            <p>The <code>rollback-output</code> attribute is described in
                  <specref ref="recovery"/>. The default value is <code>yes</code>.</p>

            <p>
               <error spec="XT" type="static" class="SE" code="3140">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:try</elcode> element is
                     present and the element has children other than <elcode>xsl:catch</elcode> and
                        <elcode>xsl:fallback</elcode> elements.</p>
               </error>
            </p>

            <p>Any <elcode>xsl:fallback</elcode> children of the <elcode>xsl:try</elcode> element
               are ignored by an XSLT 3.0 processor, but can be used to define the recovery action
               taken by an XSLT 1.0 or XSLT 2.0 processor operating with <termref def="dt-forwards-compatible-behavior"/>.</p>

            <p>The <elcode>xsl:catch</elcode> element has an optional <code>errors</code> attribute,
               which lists the error conditions that the <elcode>xsl:catch</elcode> element is
               designed to intercept. The default value is <code>errors="*"</code>, which catches
               all errors. The value is a whitespace-separated list of <xnt spec="XP40" ref="prod-xpath40-NameTest">NameTests</xnt>; an <elcode>xsl:catch</elcode> element
               catches an error condition if this list includes a <code>NameTest</code> that matches
               the error code associated with that error condition.</p>

            <note>
               <p>Error codes are QNames. Those defined in this specification and in related
                  specifications are all in the <termref def="dt-standard-error-namespace">standard
                     error namespace</termref>, and may therefore be caught using an
                     <elcode>xsl:catch</elcode> element such as <code>&lt;xsl:catch
                     errors="err:FODC0001 err:FODC0005"&gt;</code> where the namespace prefix
                     <code>err</code> is bound to this namespace. Errors defined by implementers,
                  and errors raised by an explicit call of the <xfunction>error</xfunction> function
                  or by use of the <elcode>xsl:message</elcode>
                  or <elcode>xsl:assert</elcode> instruction, may
                  use error codes in other namespaces.</p>
            </note>

            <p>If more than one <elcode>xsl:catch</elcode> element matches an error, the error is
               processed using the first one that matches, in document order. If no
                  <elcode>xsl:catch</elcode> matches the error, then the error is not caught (that
               is, evaluation of the <elcode>xsl:try</elcode> element fails with the dynamic
               error).</p>

            <p>An <elcode>xsl:catch</elcode> element may have either a <code>select</code>
               attribute, or a contained <termref def="dt-sequence-constructor">sequence
                  constructor</termref>.</p>

            <p>
               <error spec="XT" type="static" class="SE" code="3150">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:catch</elcode> element is
                     present unless the element has empty content.</p>
               </error>
            </p>


            <p>The result of evaluating the <elcode>xsl:catch</elcode> element is the result of
               evaluating the XPath expression in its <code>select</code> attribute or the result of
               evaluating the contained sequence constructor; if neither is present, the result is
               an empty sequence. This result is delivered as the result of the <elcode>xsl:try</elcode>
               instruction.</p>

            <p>If a dynamic error occurs during the evaluation of <elcode>xsl:catch</elcode>, it
               causes the containing <elcode>xsl:try</elcode> to fail with this error. The error is
               not caught by other sibling <elcode>xsl:catch</elcode> elements within the same
                  <elcode>xsl:try</elcode> instruction, but it may be caught by an
                  <elcode>xsl:try</elcode> instruction at an outer level, or by an
                  <elcode>xsl:try</elcode> instruction nested within the <elcode>xsl:catch</elcode>. </p>

            <p>Within the <code>select</code> expression, or within the sequence constructor
               contained by the <elcode>xsl:catch</elcode> element, a number of variables are
               implicitly declared, giving information about the error that occurred. These are
               lexically scoped to the <elcode>xsl:catch</elcode> element. These variables are all in
               the <termref def="dt-standard-error-namespace">standard error namespace</termref>,
               and they are initialized as described in the following table:</p>
            

            <table class="data">
               <caption>Variables Available within <code>xsl:catch</code></caption>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Variable</th>
                     <th rowspan="1" colspan="1">Type</th>
                     <th rowspan="1" colspan="1">Value</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td rowspan="1" colspan="1">err:code</td>
                     <td rowspan="1" colspan="1">xs:QName</td>
                     <td rowspan="1" colspan="1">The error code</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">err:description</td>
                     <td rowspan="1" colspan="1">xs:string?</td>
                     <td rowspan="1" colspan="1">A description of the error condition; an empty sequence if no description is available (for example, if
                           the <xfunction>error</xfunction> function was called with one
                           argument).</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">err:value</td>
                     <td rowspan="1" colspan="1">item()*</td>
                     <td rowspan="1" colspan="1">Value associated with the error. For an error raised by
                        calling the <xfunction>error</xfunction> function, this is the value of the
                        third argument (if supplied). For an error raised by evaluating
                           <elcode>xsl:message</elcode> with <code>terminate="yes"</code>, or a failing <elcode>xsl:assert</elcode>, this
                        is the document node at the root of the tree containing the XML message
                        body.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">err:module</td>
                     <td rowspan="1" colspan="1">xs:string?</td>
                     <td rowspan="1" colspan="1">The URI (or system ID) of the stylesheet module containing the
                        instruction where the error occurred; an empty sequence if the information
                        is not available.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">err:line-number</td>
                     <td rowspan="1" colspan="1">xs:integer?</td>
                     <td rowspan="1" colspan="1">The line number within the stylesheet module of the
                        instruction where the error occurred; an empty sequence if the information
                        is not available. The value <rfc2119>may</rfc2119> be approximate.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">err:column-number</td>
                     <td rowspan="1" colspan="1">xs:integer?</td>
                     <td rowspan="1" colspan="1">The column number within the stylesheet module of the
                        instruction where the error occurred; an empty sequence if the information
                        is not available. The value <rfc2119>may</rfc2119> be approximate.</td>
                  </tr>
               </tbody>
            </table>

            <p>Variables declared within the sequence constructor of the <elcode>xsl:try</elcode>
               element (and not within an <elcode>xsl:catch</elcode>) are not visible within the
                  <elcode>xsl:catch</elcode> element.</p>

            <note>
               <p>Within an <elcode>xsl:catch</elcode> it is possible to re-throw the error using
                  the function call <code>error($err:code, $err:description, $err:value)</code>.</p>
            </note>

            <p>The following additional rules apply to the catching of errors:</p>

            <olist>
               <item>
                  <p>All dynamic errors occurring during the evaluation of the
                        <elcode>xsl:try</elcode> sequence constructor or <code>select</code>
                     expression are caught (provided they match one of the
                        <elcode>xsl:catch</elcode> elements). </p>

                  <note>
                     <ulist>
                        <item>
                           <p>This includes errors occurring in functions or templates invoked in
                              the course of this evaluation, unless already caught by a nested
                                 <elcode>xsl:try</elcode>.</p>
                        </item>
                        <item>
                           <p>It also includes (for
                                 example) errors caused by calling the
                                 <xfunction>error</xfunction> function, or the
                                 <elcode>xsl:message</elcode> instruction with
                                 <code>terminate="yes"</code>, or the 
                                 <elcode>xsl:assert</elcode> instruction, or the <code>xs:error</code> constructor
                                 function. </p>
                        </item>
                        <item>
                           <p>It does not include errors that occur while evaluating references to
                              variables whose declaration and initialization is outside the
                                 <elcode>xsl:try</elcode>.</p>
                        </item>
                     </ulist>
                  </note>
               </item>
               
               <item>
                  <p>The existence of an <elcode>xsl:try</elcode> instruction does not affect the
                     obligation of the processor to signal certain errors as static errors, or its
                     right to choose whether to signal some errors (such as <termref def="dt-type-error">type errors</termref>) statically or dynamically. Static
                     errors are never caught.</p>
               </item>
               <item>
                  <p>Some fatal errors arising in the processing environment, such as running out of
                     memory, may cause termination of the transformation despite the presence of an
                        <elcode>xsl:try</elcode> instruction. This is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
               </item>

               <item>
                  <p>If the sequence constructor or <code>select</code> expression of the
                        <elcode>xsl:try</elcode> causes execution of
                        <elcode>xsl:result-document</elcode>, <elcode>xsl:message</elcode>, or <elcode>xsl:assert</elcode> instructions and
                     fails with a dynamic error that is caught, it is implementation-dependent
                     whether these instructions have any externally visible effect. The processor is
                        <rfc2119>not required</rfc2119> to roll back any changes made by these
                     instructions. The same applies to any side effects caused by extension
                     functions or extension instructions.</p>
               </item>
               <item>
                  
                  <p>A serialization error that occurs during the serialization of
                     a <termref def="dt-secondary-result"/> produced
                     using <elcode>xsl:result-document</elcode> is treated as a dynamic error in the
                     evaluation of the <elcode>xsl:result-document</elcode> instruction, and may be
                     caught (for example by an <elcode>xsl:try</elcode> instruction that contains
                     the <elcode>xsl:result-document</elcode> instruction). A serialization error
                     that occurs while serializing the <termref def="dt-principal-result"/>
                      is
                     treated as occurring after the transformation has finished, and cannot be
                     caught. </p>
               </item>
               <item>
                  
                  
                  <p>A validation error is treated as occurring in the instruction
                     that requested validation. For example, if the stylesheet is producing XHTML
                     output and requests validation of the entire result document by means of the
                     attribute <code>validation="strict"</code> on the instruction that creates the
                     outermost <code>html</code> element, then a validation failure can be caught
                     only at that level. Although the validation error might be detected, for
                     example, while writing a <code>p</code> element at a location where no
                        <code>p</code> element is allowed, it is not treated as an error in the
                     instruction that writes the <code>p</code> element and cannot be caught at that
                     level.</p>
               </item>
               <item>
                  <p>A type error may be caught if the processor raises it dynamically; this does
                     not affect the processor’s right to raise the error statically if it
                     chooses.</p>

                  <p>The following rules are provided to define which expression is considered to
                     fail when a type error occurs, and therefore where the error can be caught. The
                     general principle is that where the semantics of a construct <var>C</var> place
                     requirements on the type of some subexpression, a type error is an error in the
                     evaluation of <var>C</var>, not in the evaluation of the subexpression.</p>

                  <p>For example, consider the following construct:</p>

                  <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:variable name="v" as="xs:integer"&gt;
  &lt;xsl:sequence select="$foo"/&gt;
&lt;/xsl:variable&gt;</eg>

                  <p>The expected type of the result of the sequence constructor is
                        <code>xs:integer</code>; if the value of variable <code>$foo</code> turns
                     out to be a string, then a type error will occur. It is not possible to catch
                     this by writing:</p>

                  <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:variable name="v" as="xs:integer"&gt;
  &lt;xsl:try&gt;
    &lt;xsl:sequence select="$foo"/&gt;
    &lt;xsl:catch&gt;...&lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:variable&gt;</eg>

                  <p>This fails to catch the error because the <elcode>xsl:sequence</elcode>
                     instruction is deemed to evaluate successfully; the failure only occurs when
                     the result of this instruction is bound to the variable.</p>

                  <p>A similar rule applies to functions: if the body of a function computes a
                     result which does not conform to the required type of the function result, it
                     is not possible to catch this error within the function body itself; it can
                     only be caught by the caller of the function. Similarly, if an expression used
                     to compute an argument to a function returns a value of the wrong type for the
                     function signature, this is not considered an error in this expression, but an
                     error in evaluating the function call as a whole.</p>

                  <p>A consequence of these rules is that when a type error occurs while
                     initializing a global variable (because the initializer returns a value of the
                     wrong type, given the declared type of the variable), then this error cannot be
                     caught.</p>

                  <note>
                     <p>Because processors are permitted to report type errors during static
                        analysis, it is unwise to attempt to recover from type errors dynamically.
                        The best strategy is generally to prevent their occurrence. For example,
                        rather than writing <code>$p + 1</code> where <code>$p</code> is a parameter
                        of unknown type, and then catching the type error that occurs if
                           <code>$p</code> is not numeric, it is better first to test whether
                           <code>$p</code> is numeric, perhaps by means of an expression such as
                           <code>$p instance of my:numeric</code>, where <code>my:numeric</code> is
                        a union type with <code>xs:double</code>, <code>xs:float</code>, and
                           <code>xs:decimal</code> as its member types.</p>
                  </note>


               </item>
               <item>
                  <p>The fact that the application tries to catch errors does not prevent the
                     processor from organizing the evaluation in such a way as to prevent errors
                     occurring. For example <code>exists(//a[10 div . gt 5])</code> may still do an
                     “early exit”, rather than examining every item in the sequence just to see if
                     it triggers a divide-by-zero error.</p>
               </item>

               <item>
                  <p>Except as specified above, the optimizer must not rearrange the evaluation (at
                     compile time or at run time) so that expressions written to be subject to the
                     try/catch are evaluated outside its scope, or expressions written to be
                     external to the try/catch are evaluated within its scope. This does not prevent
                     expressions being rearranged, but any expression that is so rearranged must
                     carry its try/catch context with it.</p>
               </item>
            </olist>

            

            

            <div3 id="recovery">
               <head>Recovery of Result Trees</head>

               <p>The XSLT language is designed so that a processor that chooses to execute
                  instructions in document order will always append nodes to the result tree in
                  document order, and never needs to update a result tree in situ. As a result, it
                  is normal practice for XSLT processors to stream the result tree directly to its
                  final destination (for example, a serializer) without ever holding the tree in
                  memory. This applies whether or not the processor is streamable, and whether or
                  not source documents are streamed.</p>

               <p>The language specification states (see <specref ref="errors"/>) that when a
                  transformation terminates with a dynamic error, the state of persistent resources
                  affected by the transformation (for example, serialized result documents) is
                     <termref def="dt-implementation-defined"/>, so processors are not required to
                  take any special steps to recover such resources to their pre-transformation
                  state; at the same time, there is no guarantee that secondary result documents
                  produced before the failure occurs will be in a usable state.</p>

               <p>The situation becomes more complicated when dynamic errors occur while writing to
                  a result tree, and the dynamic error is caught by an
                     <elcode>xsl:try</elcode>/<elcode>xsl:catch</elcode> instruction. The semantics
                  of these instructions requires that when an error occurring during the evaluation
                  of <elcode>xsl:try</elcode> is caught, the result of the <elcode>xsl:try</elcode>
                  instruction is the result of the relevant <elcode>xsl:catch</elcode>. To achieve
                  this, any output written to the result tree during the execution of
                     <elcode>xsl:try</elcode> until the point where the error occurs must
                  effectively be undone. There are two basic strategies for achieving this: either
                  the updates are not committed to persistent storage until the
                     <elcode>xsl:try</elcode> instruction is completed, or the updates are written
                  in such a way that they can be rolled back in the event of a failure.</p>

               <p>Both these strategies are potentially expensive, and both have an adverse effect
                  on streaming, in that they affect the amount of memory needed to transform large
                  amounts of data. XSLT 3.0 therefore provides an option to relax the requirement to
                  recover result trees when failures occur in the course of evaluating an
                     <elcode>xsl:try</elcode> instruction. This option is invoked by specifying
                     <code>rollback-output="no"</code> on the <elcode>xsl:try</elcode>
                  instruction.</p>

               <p>The default value of the attribute is <code>rollback-output="yes"</code>.</p>

               <p>The effect of specifying <code>rollback-output="no"</code> on
                     <elcode>xsl:try</elcode> is as follows: if a dynamic error occurs in the course
                  of evaluating the <elcode>xsl:try</elcode> instruction, and if the failing
                  construct is evaluated in <termref def="dt-final-output-state"/> while writing to
                  some result document, then it is <termref def="dt-implementation-dependent"/>
                  whether an attempt to catch this error using <elcode>xsl:catch</elcode> will be
                  successful. If the attempt is successful, then the <elcode>xsl:try</elcode>
                  instruction succeeds, delivering the result of evaluating the
                     <elcode>xsl:catch</elcode> clause, and the transformation proceeds as normal.
                  If the attempt is unsuccessful (typically, because non-recoverable updates have
                  already been made to the result tree), then the <elcode>xsl:try</elcode>
                  instruction as a whole fails with a dynamic error. The state of this result
                  document will then be undefined, but the transformation can ignore the failure and
                  continue to produce other result documents, for example by wrapping the
                     <elcode>xsl:result-document</elcode> instruction in an <elcode>xsl:try</elcode>
                  instruction that catches the relevant error.</p>

               <p>
                  <error spec="XT" class="DE" code="3530" type="dynamic">
                     <p>It is a <termref def="dt-dynamic-error"/> if an <elcode>xsl:try</elcode>
                        instruction is unable to recover the state of a final result tree because
                        recovery has been disabled by use of the attribute
                           <code>rollback-output="no"</code>.</p>
                  </error>
               </p>

               <p>For example, consider the following:</p>

               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:result-document href="out.xml"&gt;     
  &lt;xsl:try rollback-output="no"&gt;
    &lt;xsl:source-document streamable="yes" href="in.xml"&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:source-document&gt;
    &lt;xsl:catch errors="*"&gt;
       &lt;error code="{$err:code}" message="{$err:description}" file="in.xml"/&gt;
    &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:result-document&gt;</eg>

               <p>The most likely failure to occur here is a failure to read the streamed input file
                     <code>in.xml</code>. In the common case where this failure is detected
                  immediately, for example if the file does not exist or the network connection is
                  down, no output will have been written to the result document, and the attempt to
                  catch the error is likely to be successful. If however a failure is detected after
                  several megabytes of data have been copied to <code>out.xml</code>, for example an
                  XML well-formedness error in the input file, or a network failure that occurs
                  while reading the file, recovery of the output file may be impossible. In this
                  situation the <elcode>xsl:result-document</elcode> instruction will fail with a
                  dynamic error. It is possible to catch this error, but the state of the file
                     <code>out.xml</code> will be unpredictable.</p>

               <p>Note that adding an <elcode>xsl:try</elcode> instruction as a child of
                     <elcode>xsl:source-document</elcode> does not help. Any error reading the input file
                  (such as a well-formedness error) is an error in the <elcode>xsl:source-document</elcode>
                  instruction and can only be caught at that level.</p>

               <p>When <code>rollback-output="no"</code> is specified, it is still possible to
                  ensure recovery of errors happens predictably by evaluating the
                  potentially-failing code in <termref def="dt-temporary-output-state"/>: typically,
                  within an <elcode>xsl:variable</elcode>. In effect the variable acts as an
                  explicit buffer for temporary results, which is only copied to the final output if
                  evaluation succeeds.</p>

               <note>
                  <p>An application might wish to ensure that when a fatal error occurs while
                     reading an input stream, data written to persistent storage up to the point of
                     failure is available after the transformation terminates. Setting
                        <code>rollback-output="no"</code> does not guarantee this, but a processor
                     might choose to interpret this as the intent.</p>
               </note>

               <p>Changing the attribute to <code>rollback-output="yes"</code> makes the stylesheet
                  more robust and able to handle error conditions predictably, but the cost may be
                  substantial; for example it may be necessary to buffer the whole of the result
                  document in memory.</p>
            </div3>


            <div3 id="try-catch-examples">
               <head>Try/Catch Examples</head>

               <example>
                  <head>Catching a Divide-by-Zero Error</head>

                  <p>The following example divides an employee’s salary by the number of
                     years they have served, catching the divide-by-zero error if the latter is
                     zero.</p>
                  <eg role="xslt-instruction xmlns:err='http://www.w3.org/2005/xqt-errors'" xml:space="preserve">&lt;xsl:try select="salary div length-of-service"&gt;
  &lt;xsl:catch errors="err:FOAR0001" select="()"/&gt;
&lt;/xsl:try&gt;</eg>
               </example>

               <example>
                  <head>Catching an Error during Result-tree Validation</head>

                  <p>The following example generates a result tree and performs schema validation,
                     outputting a warning message and serializing the invalid tree if validation
                     fails.</p>

                  <eg role="xslt-instruction xmlns:err='http://www.w3.org/2005/xqt-errors'" xml:space="preserve">&lt;xsl:result-document href="out.xml"&gt;
  &lt;xsl:variable name="result"&gt;
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:try&gt;
    &lt;xsl:copy-of select="$result" validation="strict"/&gt;
    &lt;xsl:catch&gt;
      &lt;xsl:message&gt;Warning: validation of result document failed:
          Error code: &lt;xsl:value-of select="$err:code"/&gt;
          Reason: &lt;xsl:value-of select="$err:description"/&gt;
      &lt;/xsl:message&gt;
      &lt;xsl:sequence select="$result"/&gt;
    &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:result-document&gt;
</eg>

                  <p>The reason that the result tree is constructed in a variable in this example is
                     so that the unvalidated tree is available to be used within the
                        <elcode>xsl:catch</elcode> element. An alternative approach would be to
                     repeat the logic for constructing the tree:</p>
                  <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:try&gt;
  &lt;xsl:result-document href="out.xml" validation="strict"&gt;  
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:catch&gt;
    &lt;xsl:message&gt;Warning: validation of result document failed:
          Error code: &lt;xsl:value-of select="$err:code"/&gt;
          Reason: &lt;xsl:value-of select="$err:description"/&gt;
    &lt;/xsl:message&gt;
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:catch&gt;
&lt;/xsl:try&gt;</eg>
               </example>
            </div3>

         </div2>
         <div2 id="conditional-content-construction">
            <head>Conditional Content Construction</head>

            <p>The facilities described in this section are designed to make it easier to generate
               result trees conditionally depending on what is found in the input, without violating
               the rules for streamability. These facilities are available whether or not streaming
               is in use, but they are introduced to the language specifically to make streaming
               easier.</p>

            <p>The facilities are introduced first by example:</p>

            <example>
               <head>Generating a Wrapper Element for a non-Empty Sequence</head>
               <p>The following example generates an <code>events</code> element if and only if
                  there are one or more <code>event</code> elements. The code could be written like
                  this:</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:if test="exists(event)"&gt;
  &lt;events&gt;
    &lt;xsl:copy-of select="event"/&gt;
  &lt;/events&gt;
&lt;/xsl:if&gt;</eg>
               <p>However, the above code would not be <termref def="dt-guaranteed-streamable"/>,
                  because it processes the child <code>event</code> elements more than once. To make
                  it streamable, it can be rewritten as:</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:where-populated&gt;
  &lt;events&gt;
    &lt;xsl:copy-of select="event"/&gt;
  &lt;/events&gt;
&lt;/xsl:where-populated&gt;</eg>
               <p>The effect of the <elcode>xsl:where-populated</elcode> instruction, as explained
                  later, is to avoid outputting the <code>events</code> element if it would have no
                  children. A streaming implementation will typically hold the start tag of the
                     <code>events</code> element in a buffer, to be sent to the output destination
                  only if and when a child node is generated.</p>
            </example>
            <example>
               <head>Generating a Header and Footer only if there is Content</head>
               <p>The following example generates an <code>h3</code> element and a summary paragraph
                  only if a list of items is non-empty. The code could be written like this:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:if test="exists(item-for-sale)"&gt;
  &lt;h1&gt;Items for Sale&lt;/h1&gt;
&lt;/xsl:if&gt;  
&lt;xsl:apply-templates select="item-for-sale"/&gt;
&lt;xsl:if test="exists(item-for-sale)"&gt;
  &lt;p&gt;Total value: {accumulator-before('total-value')}&lt;/p&gt;
&lt;/xsl:if&gt;</eg>
               <p>However, the above code would not be <termref def="dt-guaranteed-streamable"/>,
                  because it processes the child <code>item-for-sale</code> elements more than once.
                  To make it streamable, it can be rewritten as:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:sequence&gt;
  &lt;xsl:on-non-empty&gt;
    &lt;h1&gt;Items for Sale&lt;/h1&gt;
  &lt;/xsl:on-non-empty&gt;  
  &lt;xsl:apply-templates select="item-for-sale"/&gt;
  &lt;xsl:on-non-empty&gt;
    &lt;p&gt;Total value: {accumulator-before('total-value')}&lt;/p&gt;
  &lt;/xsl:on-non-empty&gt;  
&lt;/xsl:sequence&gt;</eg>
               <p>The effect of the <elcode>xsl:on-non-empty</elcode> instruction, as explained
                  later, is to output the enclosed content only if the containing sequence
                  constructor also generates “ordinary” content, that is, if there is content
                  generated by instructions other than <elcode>xsl:on-empty</elcode> and
                     <elcode>xsl:on-non-empty</elcode> instructions.</p>
            </example>
            <example>
               <head>Generating Substitute Text when there is no Content</head>
               <p>The following example generates a summary paragraph only if a list of items is
                  empty. The code could be written like this:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:apply-templates select="item-for-sale"/&gt;
&lt;xsl:if test="empty(item-for-sale)"&gt;
  &lt;p&gt;There are no items for sale.&lt;/p&gt;
&lt;/xsl:if&gt;</eg>
               <p>However, the above code would not be <termref def="dt-guaranteed-streamable"/>,
                  because it processes the child <code>item-for-sale</code> elements more than once
                  (the fact that the list is empty is irrelevant, because streamability is
                  determined statically). To make the code streamable, it can be rewritten as:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:sequence&gt;
  &lt;xsl:apply-templates select="item-for-sale"/&gt;
  &lt;xsl:on-empty&gt;
    &lt;p&gt;There are no items for sale.&lt;/p&gt;
  &lt;/xsl:on-empty&gt;
&lt;/xsl:sequence&gt;</eg>
               <p>The effect of the <elcode>xsl:on-empty</elcode> instruction, as explained later,
                  is to output the enclosed content only if the containing sequence constructor
                  generates no “ordinary” content, that is, if there is no content generated by
                  instructions other than <elcode>xsl:on-empty</elcode> and
                     <elcode>xsl:on-non-empty</elcode> instructions.</p>
            </example>
            <note>
               <p>In some cases, similar effects can be achieved by using the
                     <xfunction>has-children</xfunction> function, which tests whether an element
                  has child nodes without consuming the children. However, use of
                     <xfunction>has-children</xfunction> has the drawback that the function is
                  unselective: it cannot be used to test whether there are any children of relevance
                  to the application. In particular, it returns true if an element contains comments
                  or whitespace text nodes that the application might consider to be
                  insignificant.</p>
            </note>
            <note>
               <p>There are no special streamability rules for the three instructions
                     <elcode>xsl:where-populated</elcode>, <elcode>xsl:on-empty</elcode>, or
                     <elcode>xsl:on-non-empty</elcode>. The <termref def="dt-general-streamability-rules"/> apply. In many cases the
                     <elcode>xsl:on-empty</elcode> and <elcode>xsl:on-non-empty</elcode>
                  instructions will generate content that does not depend on the source document,
                  and they will therefore be <termref def="dt-motionless"/>, but this is not
                  required.</p>
            </note>
            <div3 id="where-populated">
               <head>The <code>xsl:where-populated</code> instruction</head>
               <?element xsl:where-populated?>
               <p>The <elcode>xsl:where-populated</elcode> instruction encloses a <termref def="dt-sequence-constructor"/>. The result of the instruction is established
                  as follows:</p>
               <olist>
                  <item>
                     <p>The sequence constructor is evaluated in the usual way (taking into account
                        any <elcode>xsl:on-empty</elcode> and <elcode>xsl:on-non-empty</elcode>
                        instructions) to produce a result <var>$R</var>.</p>
                  </item>
                  <item>
                     <p>The result of the instruction is the value of the expression
                           <code>$R[not(deemed-empty(.))]</code> where the function
                           <code>deemed-empty($item as item())</code> returns true if and only if
                           <code>$item</code> is one of the following:</p>

                     <ulist>
                        <item>
                           <p>A document or element node that has no children.</p>
                           <note>
                              <p>If an element has attributes or namespaces, these do not prevent
                                 the element being deemed empty.</p>
                              <p>If a document or element node has children, the node is not deemed
                                 empty, even if the children are empty. For example, a document node
                                 created using an <elcode>xsl:variable</elcode> instruction in the
                                 form
                                    <code>&lt;xsl:variable name="temp"&gt;&lt;a/&gt;&lt;/xsl:variable&gt;</code>
                                 is not deemed empty, even though the contained &lt;a/&gt;
                                 element is empty.</p>
                           </note>
                        </item>
                        <item>
                           <p>A node, other than a document or element node, whose string value is
                              zero-length.</p>
                           <note>
                              <p>A whitespace-only text node is not deemed empty.</p>
                           </note>
                        </item>
                        <item>
                           <p>An atomic value such that the result of casting the atomic value to a
                              string is zero-length.</p>
                           <note>
                              <p>This can happen only when the atomic value is of type
                                    <code>xs:string</code>, <code>xs:anyURI</code>,
                                    <code>xs:untypedAtomic</code>, <code>xs:hexBinary</code>, or
                                    <code>xs:base64Binary</code>.</p>
                           </note>
                        </item>
                        <item>
                           <p>A map whose size (number of key/value
                              pairs) is zero.</p>
                        </item>
                        <item>
                           <p>An array (see <specref ref="arrays"/>) where the result 
                              of flattening the array using the <xfunction spec="FO40">array:flatten</xfunction> function is 
                              either an empty sequence, or a sequence in which every item is deemed empty 
                              (applying these rules recursively).</p>
                        </item>
                     </ulist>
                  </item>
               </olist>

               <example>
                  <head>Generating an HTML list</head>
                  <p>The following example generates an HTML unnumbered list, if and only if the
                     list is non-empty. Note that the presence of the <code>class</code> attribute
                     does not make the list non-empty. The code is written to be streamable.</p>
                  <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:where-populated&gt;
  &lt;ul class="my-list"&gt;
    &lt;xsl:for-each select="source-item"&gt;
       &lt;li&gt;&lt;xsl:value-of select="."/&gt;&lt;/li&gt;
    &lt;/xsl:for-each&gt;
  &lt;/ul&gt;
&lt;/xsl:where-populated&gt;</eg>
               </example>
            </div3>
            <div3 id="on-empty">
               <head>The <code>xsl:on-empty</code> instruction</head>
               <?element xsl:on-empty?>
               <p>The <elcode>xsl:on-empty</elcode> instruction has the same content model as
                     <elcode>xsl:sequence</elcode>, and when it is evaluated, the same rules apply.
                  In particular, the <code>select</code> attribute and the contained sequence
                  constructor are mutually exclusive <errorref spec="XT" class="SE" code="3185"/>.</p>
               <p>When an <elcode>xsl:on-empty</elcode> instruction
                  appears in a sequence constructor, then:</p>
               <olist>
                  <item>
                     <p>It must be the only <elcode>xsl:on-empty</elcode> instruction in the
                        sequence constructor, and</p>
                  </item>
                  <item>
                     <p>It must not be followed in the sequence constructor by any other <termref def="dt-instruction"/>, other than <elcode>xsl:fallback</elcode>, or by a
                        significant text node (that is, a text node that has not been discarded
                        under the provisions of <specref ref="stylesheet-stripping"/>), or by a
                           <termref def="dt-literal-result-element"/>. It may, however, be followed
                        by non-instructions such as <elcode>xsl:catch</elcode> where
                        appropriate.</p>
                  </item>
               </olist>
               
               <p><termdef id="dt-vacuous" term="vacuous">An item is <term>vacuous</term> if
               it is one of the following: a zero-length text node; a document node with no children; an atomic value which, 
               on casting to <code>xs:string</code>, produces a zero-length string; or <phrase diff="del" at="A">(when XPath 3.1 is supported)</phrase> an array 
                  which on flattening using the <xfunction spec="FO40">array:flatten</xfunction> function produces either an empty sequence 
                  or a sequence consisting entirely of <termref def="dt-vacuous"/> items.</termdef></p>
                                
               <p>An <elcode>xsl:on-empty</elcode> instruction is triggered only if every 
                  preceding sibling instruction, text node, and literal result element in the same <termref def="dt-sequence-constructor"/> 
                  returns either an empty sequence, or a sequence consisting entirely of <termref def="dt-vacuous"/> items.
               </p>
                  
               <p>If an <elcode>xsl:on-empty</elcode> instruction is triggered, then the result 
                  of the containing <termref def="dt-sequence-constructor"/> is the result of the <elcode>xsl:on-empty</elcode> instruction.
               </p>
               
               <note><p>This means that the (vacuous) results produced by other instructions in the 
                  sequence constructor are discarded. This is relevant mainly when the result of the sequence constructor 
                  is used for something other than constructing a node: for example if it forms the result of a function, 
                  or the value of a variable, and the function or variable specifies a required type.</p>
                  <p>When streaming, it may be necessary to buffer vacuous items in the result sequence until it is 
                     known whether the result will contain items that are non-vacuous. In many common situations, however
                     — in particular, when the sequence constructor is being used to create the content of a node — 
                     vacuous items can be discarded immediately because they do not affect the content of the node being constructed.
                  </p>
               </note>
                  
               <note><p>In nearly all cases, the rules for <elcode>xsl:on-empty</elcode> are aligned 
                  with the rules for constructing complex content. If the sequence constructor within a literal result element 
                  or an <elcode>xsl:element</elcode> instruction includes an <elcode>xsl:on-empty</elcode> instruction, 
                  then the content of the element will be the value delivered by the <elcode>xsl:on-empty</elcode> instruction 
                  if and only if the content would otherwise be empty.</p>
                  <p>There is one minor exception to this rule: if the sequence constructor delivers multiple zero-length strings, 
                     then in the absence of the <elcode>xsl:on-empty</elcode> instruction the new element would contain whitespace, 
                     made up of the separators between these zero-length strings; but <elcode>xsl:on-empty</elcode> takes no account 
                     of these separators.</p></note>
                  
               <note><p>Attribute and namespace nodes created by the sequence constructor 
                  are significant; the <elcode>xsl:on-empty</elcode> instruction will not be triggered if such nodes are present. 
                  If this is not the desired effect, it is possible to partition the sequence constructor to change the scope of 
                  <elcode>xsl:on-empty</elcode>, for example:</p>
                     
                     <eg role="xslt-instruction" xml:space="preserve">&lt;ol&gt;
  &lt;xsl:attribute name="class" select="numbered-list"/&gt;
  &lt;xsl:sequence&gt;
    &lt;xsl:value-of select="xyz"/&gt;
    &lt;xsl:on-empty select="'The list is empty'"/&gt;
  &lt;/xsl:sequence&gt;
&lt;/ol&gt;</eg>
                     
                  </note>
                  
               <note><p>Where the sequence constructor is a child of an instruction with
               an <code>[xsl:]use-attribute-sets</code> attribute, any attribute nodes created by expanding the referenced
               attribute set(s) are not part of the result of the sequence constructor and therefore play no role in determining
               whether an <elcode>xsl:on-empty</elcode> or <elcode>xsl:on-non-empty</elcode> instruction is triggered. 
                  Equally, when the sequence constructor is a child
               of a <termref def="dt-literal-result-element"/>, attribute nodes generated by expanding the attributes
               of the literal result element are not taken into account.</p></note>
                  


               <note>
   
                  <p>If <elcode>xsl:on-empty</elcode> is the only instruction in a sequence
                     constructor then it is always evaluated.</p>
                  <p>If <elcode>xsl:on-empty</elcode> and <elcode>xsl:on-non-empty</elcode> appear
                     in the same sequence constructor, then the rules ensure that only one of them
                     will be evaluated.</p>
               </note>




            </div3>
            <div3 id="on-non-empty">
               <head>The <elcode>xsl:on-non-empty</elcode> instruction</head>
               <?element xsl:on-non-empty?>
               <p>The <elcode>xsl:on-non-empty</elcode> instruction has the same content model as
                     <elcode>xsl:sequence</elcode>, and when it is evaluated, the same rules apply.
                  In particular, the <code>select</code> attribute and the contained sequence
                  constructor are mutually exclusive <errorref spec="XT" class="SE" code="3185"/>.</p>
               
               <p>An <elcode>xsl:on-non-empty</elcode> instruction is evaluated only 
                  if there is at least one sibling node in the same <termref def="dt-sequence-constructor"/>, 
                  excluding <elcode>xsl:on-empty</elcode> and <elcode>xsl:on-non-empty</elcode> instructions, 
                  whose evaluation yields a sequence containing an item that is not <termref def="dt-vacuous"/>. 
                  If this condition applies, then all <elcode>xsl:on-non-empty</elcode> instructions in the 
                  containing sequence constructor are evaluated, and their results are included in the result 
                  of the containing sequence constructor in their proper positions.
               </p>
               <note>
                  <p>The <elcode>xsl:on-non-empty</elcode> instruction is typically used to generate headers or 
                     footers appearing before or after a list of items, where the header or footer is to be 
                     omitted if there are no items in the list.
              </p> </note>
               

               <note>
                  <p>Unlike <elcode>xsl:on-empty</elcode>, the <elcode>xsl:on-non-empty</elcode>
                     instruction can appear anywhere in a sequence constructor, and can appear more
                     than once.</p>
               </note>

            </div3>
            <div3 id="evaluating-on-empty">
               <head>Evaluating <elcode>xsl:on-empty</elcode> and <elcode>xsl:on-non-empty</elcode>
                  Instructions</head>
               <p>The following non-normative algorithm explains one possible strategy for streamed
                  evaluation of a <termref def="dt-sequence-constructor"/> containing
                     <elcode>xsl:on-empty</elcode> and/or <elcode>xsl:on-non-empty</elcode>
                  instructions.</p>
               <p>The algorithm makes use of the following mutable variables:</p>
               <ulist>
                  <item>
                     <p><var>L</var> : a list of instructions awaiting evaluation. Initially
                        empty.</p>
                  </item>
                  <item>
                     <p><var>R</var> : a list of items to act as the result of the evaluation.
                        Initially empty.</p>
                  </item>
                  <item>
                     <p><var>F</var> : a boolean flag, initially false, to indicate whether any
                           <termref def="dt-vacuous">non-vacuous</termref> items have been written to <var>R</var> by
                           <term>ordinary instructions</term>. The term <term>ordinary instruction</term>
                        means any node in the sequence constructor other than an
                           <elcode>xsl:on-empty</elcode> or <elcode>xsl:on-non-empty</elcode>
                        instruction.</p>
                  </item>
               </ulist>
               <p>The algorithm is as follows:</p>
               <olist>
                  <item>
                     <p>The nodes in the sequence constructor are evaluated in document order.</p>
                  </item>
                  <item>
                     <p>When an <elcode>xsl:on-non-empty</elcode> instruction is encountered,
                        then:</p>
                     <olist>
                        <item>
                           <p>If <var>F</var> is true, the instruction is evaluated and the result
                              is appended to <var>R</var>.</p>
                        </item>
                        <item>
                           <p>Otherwise, the instruction is appended to <var>L</var>.</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>When an <term>ordinary instruction</term> is evaluated:</p>
                     <olist>
                        <item>
                           <p>The results of the evaluation are appended to <var>R</var>, in
                              order.</p>
                        </item>
                        <item>
                           <p>When a <termref def="dt-vacuous">non-vacuous</termref> item is about to be appended to
                                 <var>R</var>, and <var>F</var> is false, then before appending the
                              item to <var>R</var>, the following actions are taken:</p>
                           <olist>
                              <item>
                                 <p>Any <elcode>xsl:on-non-empty</elcode> instructions in
                                       <var>L</var> are evaluated, in order, and their results are
                                    appended to <var>R</var>.</p>
                              </item>
                              <item>
                                 <p><var>F</var> is set to true.</p>
                              </item>
                           </olist>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>When an <elcode>xsl:on-empty</elcode> instruction is encountered, then:</p>
                     <olist>
                        <item>
                           <p>If <var>F</var> is true, the instruction is ignored.</p>
                        </item>
                        <item>
                           <p>Otherwise, the existing contents of <var>R</var> are discarded, 
                              the instruction is evaluated, and its results are appended to <var>R</var>.</p> 
                           
                           <note><p>The need to discard items from <var>R</var> 
                              arises only when all the items in <var>R</var> are <termref def="dt-vacuous"/>. 
                              Streaming implementations may therefore need a limited amount of buffering to retain 
                              insignificant items until it is known whether they will be needed. 
                              However, in many common cases an optimized implementation will be able 
                              to discard <termref def="dt-vacuous"/> items such as empty text nodes immediately, 
                              because when a node is being constructed using the rules in 
                              <specref ref="constructing-complex-content"/> or <specref ref="constructing-simple-content"/>, 
                              such items have no effect on the final outcome.</p></note>
                                                     
                           <p>Otherwise, the instruction is evaluated and its results are appended
                              to <var>R</var>.</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>The result of the sequence constructor is the list of items in
                        <var>R</var>.</p>
                  </item>
               </olist>

            </div3>
            <div3 id="where-populated-example">
               <head>A More Complex Example</head>
               <p>This example shows how the three instructions
                  <elcode>xsl:where-populated</elcode>, <elcode>xsl:on-empty</elcode>, and
                     <elcode>xsl:on-non-empty</elcode> may be combined.</p>
               <example>
                  <head>Generating a Table only if there is Content</head>
                  <p>The following example generates a table containing the names and ages of a set
                     of students; if there are no students, it substitutes a paragraph explaining
                     this.</p>
                  <eg role="xslt-fragment" xml:space="preserve">&lt;div id="students"&gt;
&lt;xsl:where-populated&gt;
   &lt;table&gt;
      &lt;xsl:on-non-empty&gt;
         &lt;thead&gt;
            &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Age&lt;/th&gt;&lt;/tr&gt;
         &lt;/thead&gt;
      &lt;/xsl:on-non-empty&gt;
      &lt;xsl:where-populated&gt;
         &lt;tbody&gt;
            &lt;xsl:for-each select="student/copy-of()"&gt;
               &lt;tr&gt;
                  &lt;td&gt;&lt;xsl:value-of select="name"/&gt;&lt;/td&gt;
                  &lt;td&gt;&lt;xsl:value-of select="age"/&gt;&lt;/td&gt;
               &lt;/tr&gt;
            &lt;/xsl:for-each&gt;
         &lt;/tbody&gt;
      &lt;/xsl:where-populated&gt;
   &lt;/table&gt;
&lt;/xsl:where-populated&gt;
&lt;xsl:on-empty&gt;
   &lt;p&gt;There are no students&lt;/p&gt;
&lt;/xsl:on-empty&gt;
&lt;/div&gt;</eg>
                  <p>Explanation:</p>
                  <ulist>
                     <item>
                        <p>The <elcode>xsl:where-populated</elcode> around the <code>table</code>
                           element ensures that if there is no <code>thead</code> and no
                              <code>tbody</code>, then there will be no <code>table</code>. </p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:on-non-empty</elcode> surrounding the <code>thead</code>
                           element ensures that the <code>thead</code> element is not output unless
                           the <code>tbody</code> element is output. </p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:where-populated</elcode> around the <code>tbody</code>
                           element ensures that the <code>tbody</code> element is not output unless
                           there is at least one table row (<code>tr</code>). </p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:on-empty</elcode> around the <code>p</code> element
                           ensures that if no <code>table</code> is output, then the paragraph
                           <code>There are no students</code> is output instead. </p>
                     </item>
                  </ulist>
               </example>
            </div3>
         </div2>
      </div1>


      <div1 id="variables-and-parameters">
         <head>Variables and Parameters</head>
         <p>
            <termdef id="dt-variable-binding-element" term="variable-binding element">The two
               elements <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> are referred to
               as <term>variable-binding elements</term>.</termdef></p>
         <p>
            <termdef id="dt-variable" term="variable">The <elcode>xsl:variable</elcode> element
               declares a <term>variable</term>, which may be a <termref def="dt-global-variable">global variable</termref> or a <termref def="dt-local-variable">local
                  variable</termref>.</termdef>
         </p>
         <p>
            <termdef id="dt-parameter" term="parameter">The <elcode>xsl:param</elcode> element
               declares a <term>parameter</term>, which may be a <termref def="dt-stylesheet-parameter">stylesheet parameter</termref>, a <termref def="dt-template-parameter">template parameter</termref>, a <termref def="dt-function-parameter">function parameter</termref>, or an <elcode>xsl:iterate</elcode> parameter. A parameter is a
                  <termref def="dt-variable">variable</termref> with the additional property that
               its value can be set by the caller.</termdef>
         </p>
         <p>
            <termdef id="dt-value" term="value">A variable is a binding between a name and a value.
               The <term>value</term> of a variable is any sequence (of nodes, atomic values,
                  and/or function items), as defined in <bibref ref="xpath-datamodel-30"/>.</termdef>
         </p>

         <div2 id="variables">
            <head>Variables</head>
            <?element xsl:variable?>
            <p>The <elcode>xsl:variable</elcode> element has a <rfc2119>required</rfc2119>
               <code>name</code> attribute, which specifies the name of the variable. The value of
               the <code>name</code> attribute is an <termref def="dt-eqname">EQName</termref>, which is expanded as described in
                  <specref ref="qname"/>.</p>
            <p>The <elcode>xsl:variable</elcode> element has an optional <code>as</code> attribute,
               which specifies the <termref def="dt-required-type">required type</termref> of the
               variable. The value of the <code>as</code> attribute is a 
               <termref def="dt-sequence-type"/>.</p>
            <p>
               <termdef id="dt-supplied-value" term="supplied value">The value of the variable is
                  computed using the <termref def="dt-expression">expression</termref> given in the
                     <code>select</code> attribute or the contained <termref def="dt-sequence-constructor">sequence constructor</termref>, as described in
                     <specref ref="variable-values"/>. This value is referred to as the
                     <term>supplied value</term> of the variable.</termdef> If the
                  <elcode>xsl:variable</elcode> element has a <code>select</code> attribute, then
               the sequence constructor <rfc2119>must</rfc2119> be empty.</p>
            <p>If the <code>as</code> attribute is specified, then the <termref def="dt-supplied-value">supplied value</termref> of the variable is converted to
               the required type, using the <termref def="dt-coercion-rules"/>.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0570">
                  <p>It is a <termref def="dt-type-error">type error</termref> if the <termref def="dt-supplied-value">supplied value</termref> of a variable cannot be
                     converted to the required type.</p>
               </error>
            </p>
            <p>If the <code>as</code> attribute is omitted, the <termref def="dt-supplied-value">supplied value</termref> of the variable is used directly, and no conversion
               takes place.</p>
            <p>For the effect of the <code>static</code> attribute, see <specref ref="static-params"/>.</p>
            <p>The <code>visibility</code> attribute <rfc2119>must not</rfc2119>
               be specified for a <termref def="dt-local-variable"/>: that is, it is allowed only when the parent
               element is <elcode>xsl:stylesheet</elcode>, <elcode>xsl:transform</elcode>, 
               <elcode>xsl:package</elcode> or
                  <elcode>xsl:override</elcode>.</p>
            <p>If the <code>visibility</code> attribute is present with the value
                  <code>abstract</code> then the <code>select</code> attribute
                  <rfc2119>must</rfc2119> be absent and the contained <termref def="dt-sequence-constructor"/>
               <rfc2119>must</rfc2119> be empty. In this situation there is no <termref def="dt-supplied-value">supplied value</termref>, and therefore the constraint
               that the supplied value is consistent with the required type does not apply.</p>
         </div2>
         <div2 id="parameters">
            <head>Parameters</head>
            <?element xsl:param?>
            <p>The <elcode>xsl:param</elcode> element may be used:</p>
            <ulist>
               <item>
                  <p>As a child of <elcode>xsl:stylesheet</elcode>
                     or <elcode>xsl:package</elcode>, to
                     define a parameter to the transformation. <termref def="dt-stylesheet-parameter">Stylesheet parameters</termref> are set by the
                     calling application: see <specref ref="priming-stylesheet"/>. </p>
               </item>
               <item>
                  <p>As a child of <elcode>xsl:template</elcode> to define a parameter to a
                     template, which may be supplied when the template is invoked using
                        <elcode>xsl:call-template</elcode>, <elcode>xsl:apply-templates</elcode>,
                        <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode>.
                        <termref def="dt-template-parameter">Template parameters</termref> are set
                     by means of an <elcode>xsl:with-param</elcode> child element of the invoking
                     instruction, as described in <specref ref="with-param"/>.</p>
               </item>
               <item>
                  <p>As a child of <elcode>xsl:function</elcode> to define a parameter to a
                     stylesheet function, which may be supplied when the function is called from an
                     XPath <termref def="dt-expression">expression</termref>. <termref def="dt-function-parameter">Function parameters</termref> are set
                     positionally by means of the argument list in an XPath function call. </p>
               </item>
               <item>
                  <p>As a child of <elcode>xsl:iterate</elcode> to define a parameter that can vary
                     from one iteration to the next. Iteration parameters always take their default
                     values for the first iteration, and in subsequent iterations are set using an
                        <elcode>xsl:with-param</elcode> child of the
                        <elcode>xsl:next-iteration</elcode> instruction.</p>
               </item>
            </ulist>

            <p>The attributes applicable to <elcode>xsl:param</elcode>
               depend on its parent element in the stylesheet, as defined by the following
               table:</p>

            <table class="data">
               <caption>Attributes of the <code>xsl:param</code> Element</caption>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Parent Element</th>
                     <th rowspan="1" colspan="1">name</th>
                     <th rowspan="1" colspan="1">select</th>
                     <th rowspan="1" colspan="1">as</th>
                     <th rowspan="1" colspan="1">required</th>
                     <th rowspan="1" colspan="1">tunnel</th>
                     <th rowspan="1" colspan="1">static</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <th rowspan="1" colspan="1"><elcode>xsl:package</elcode></th>
                     <td rowspan="1" colspan="1">mandatory</td>
                     <td rowspan="1" colspan="1">optional</td>
                     <td rowspan="1" colspan="1">optional</td>
                     <td rowspan="1" colspan="1">yes|<term>no</term></td>
                     <td rowspan="1" colspan="1"><term>no</term></td>
                     <td rowspan="1" colspan="1">yes|<term>no</term></td>
                  </tr>
                  <tr>
                     <th rowspan="1" colspan="1"><elcode>xsl:stylesheet</elcode></th>
                     <td rowspan="1" colspan="1">mandatory</td>
                     <td rowspan="1" colspan="1">optional</td>
                     <td rowspan="1" colspan="1">optional</td>
                     <td rowspan="1" colspan="1">yes|<term>no</term></td>
                     <td rowspan="1" colspan="1"><term>no</term></td>
                     <td rowspan="1" colspan="1">yes|<term>no</term></td>
                  </tr>
                  <tr>
                     <th rowspan="1" colspan="1"><elcode>xsl:template</elcode></th>
                     <td rowspan="1" colspan="1">mandatory</td>
                     <td rowspan="1" colspan="1">optional</td>
                     <td rowspan="1" colspan="1">optional</td>
                     <td rowspan="1" colspan="1">yes|<term>no</term></td>
                     <td rowspan="1" colspan="1">yes|<term>no</term></td>
                     <td rowspan="1" colspan="1"><term>no</term></td>
                  </tr>
                  <tr>
                     <th rowspan="1" colspan="1"><elcode>xsl:function</elcode></th>
                     <td rowspan="1" colspan="1">mandatory</td>
                     <td rowspan="1" colspan="1">disallowed</td>
                     <td rowspan="1" colspan="1">optional</td>
                     <td rowspan="1" colspan="1"><term>yes</term></td>
                     <td rowspan="1" colspan="1"><term>no</term></td>
                     <td rowspan="1" colspan="1"><term>no</term></td>
                  </tr>
                  <tr>
                     <th rowspan="1" colspan="1"><elcode>xsl:iterate</elcode></th>
                     <td rowspan="1" colspan="1">mandatory</td>
                     <td rowspan="1" colspan="1">mandatory</td>
                     <td rowspan="1" colspan="1">optional</td>
                     <td rowspan="1" colspan="1"><term>no</term></td>
                     <td rowspan="1" colspan="1"><term>no</term></td>
                     <td rowspan="1" colspan="1"><term>no</term></td>
                  </tr>

               </tbody>
            </table>

            <p>In the table, the entries for the <code>name</code>,
                  <code>select</code>, and <code>as</code> attributes indicate whether the attribute
               must appear, is optional, or must be absent; the entries for the
                  <code>required</code>, <code>tunnel</code>, and <code>static</code> attributes
               indicate the values that are permitted if the attribute is present, with the default
               value shown in bold. (The value <code>yes</code> can also be written
                  <code>true</code> or <code>1</code>, while <code>no</code> can also be written
                  <code>false</code> or <code>0</code>.)</p>

            <p>The <code>name</code> attribute is mandatory: it specifies the name of the parameter.
               The value of the <code>name</code> attribute is an <termref def="dt-eqname">EQName</termref>, which is expanded as described in
                  <specref ref="qname"/>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0580">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the values of
                     the <code>name</code> attribute of two sibling
                           <elcode>xsl:param</elcode> elements represent the same <termref def="dt-expanded-qname">expanded QName</termref>.</p>
               </error>
            </p>

            <p>If the <elcode>xsl:param</elcode> element has a <code>select</code> attribute, then
               the sequence constructor <rfc2119>must</rfc2119> be empty.</p>

            <p>The <code>static</code> attribute can take the value <code>yes</code> only on <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, and is explained in
                  <specref ref="global-variables"/>.</p>
            <note>
               <p>Local variables may <termref def="dt-shadows">shadow</termref> template parameters
                  and function parameters: see <specref ref="scope-of-variables"/>.</p>
            </note>

            <p>The optional <code>tunnel</code> attribute may be used to indicate that a parameter
               is a <termref def="dt-tunnel-parameter">tunnel parameter</termref>. The default is
                  <code>no</code>; the value <code>yes</code> may be specified only for <termref def="dt-template-parameter">template parameters</termref>. Tunnel parameters are
               described in <specref ref="tunnel-params"/>
            </p>



            <div3 id="parameter-type">
               <head>The Required Type of a Parameter</head>
               <p>The <elcode>xsl:param</elcode> element has an optional <code>as</code> attribute,
                  which specifies the <termref def="dt-required-type"/> of the parameter. The value
                  of the <code>as</code> attribute is a 
                  <termref def="dt-sequence-type"/>. 
                  If the <code>as</code> attribute is omitted, then the
                  required type is <code>item()*</code>.</p>

               <p>The <termref def="dt-supplied-value">supplied value</termref> of the parameter is
                  the value supplied by the caller. If no value was supplied by the caller, and if
                  the parameter is not mandatory, then the default value is used as the supplied
                  value as described in <specref ref="default-values-of-parameters"/>.</p>

               <p>The <termref def="dt-supplied-value">supplied value</termref> of the parameter is
                  converted to the <termref def="dt-required-type"/> using the <termref def="dt-coercion-rules"/>.</p>
               <p diff="chg" at="A">
                  <error spec="XT" type="type" class="TE" code="0590">
                     <p>It is a <termref def="dt-type-error">type error</termref> if the conversion
                        of the <termref def="dt-supplied-value">supplied value</termref> of a
                        parameter, or of the context item, does not match the <termref def="dt-required-type"/>,
                        after applying any permitted conversions. [XSLT 3.0 Erratum E22, bug 30238].</p>
                  </error>
               </p>

            </div3>
            <div3 id="default-values-of-parameters">
               <head>Default Values of Parameters</head>

               <p>The optional <code>required</code> attribute of
                     <elcode>xsl:param</elcode> may be used to indicate whether a <termref def="dt-stylesheet-parameter"/>, 
                  <termref def="dt-template-parameter"/><phrase diff="add" at="A">, or <termref def="dt-function-parameter"/></phrase> is
                  mandatory or optional. The only value <phrase diff="del" at="A">permitted for a <termref def="dt-function-parameter"/>
                  is <code>yes</code> (these are always mandatory), and the only value</phrase> permitted for
                  a parameter to <elcode>xsl:iterate</elcode> is <code>no</code> (these are always
                  initialized to a default value).</p>
               
               <p diff="add" at="A">The default value for a <termref def="dt-function-parameter"/> is <code>required="yes"</code>; in all
               other cases it is <code>required="no"</code>.</p>

               <p><termdef id="dt-explicitly-mandatory" term="explicitly mandatory">A parameter is
                        <term>explicitly mandatory</term> if it is a 
                  <termref def="dt-function-parameter">function parameter</termref> 
                  <phrase diff="add" at="A">with no <code>required</code> attribute</phrase>, or if the
                        <code>required</code> attribute is present and has the value
                        <code>yes</code>.</termdef> If a parameter is explicitly mandatory, then the
                     <elcode>xsl:param</elcode> element <rfc2119>must</rfc2119> be empty and
                     <rfc2119>must not</rfc2119> have a <code>select</code> attribute.</p>

               <p diff="add" at="A">The static context for evaluating the default value depends on where the
               relevant expression appears in the stylesheet, in the usual way. The dynamic context is different
               for different kinds of parameter:</p>
               
               <ulist diff="add" at="A">
                  <item><p>For <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, the 
                  context is the same as the context for evaluating global variables.</p></item>
                  <item><p>For <termref def="dt-template-parameter">template parameters</termref>, the 
                     context is that of the called template. This means that the evaluation of the
                  default has access to the other parameters supplied in the call, provided they are declared
                  earlier. It also means, for example, that if the evaluation of the default value invokes
                  <elcode>xsl:next-match</elcode>, the <termref def="dt-current-template-rule"/> is the called
                  template rather than the calling template.</p></item>
                  <item><p>For <termref def="dt-function-parameter">function parameters</termref>, the dynamic
                     context for evaluating defaults is the dynamic context of the caller, except that no
                     local variables are in scope. This means that it is possible to declare a parameter
                     with <code>&lt;xsl:param name="dot" required="no" select="."/></code> to take its
                     default value from the context item of the caller.
                     
              </p>
                  <p>TODO: Reconsider this rule.</p>
                  </item>
               </ulist>

               <p>If a parameter is not <termref def="dt-explicitly-mandatory"/>, then it may have a
                  default value. The default value is obtained by evaluating the <termref def="dt-expression">expression</termref> given in the <code>select</code>
                  attribute or the contained <termref def="dt-sequence-constructor">sequence
                     constructor</termref>, as described in <specref ref="variable-values"/>.</p>

               <note>
                  <p>This specification does not dictate whether and when the default value of a
                     parameter is evaluated. For example, if the default is specified as
                        <code>&lt;xsl:param name="p"&gt;&lt;foo/&gt;&lt;/xsl:param&gt;</code>, then
                     it is not specified whether a distinct <code>foo</code> element node will be
                     created on each invocation of the template, or whether the same
                        <code>foo</code> element node will be used for each invocation. However, it
                     is permissible for the default value to depend on the values of other
                     parameters, or on the evaluation context, in which case the default must
                     effectively be evaluated on each invocation.</p>
               </note>

               <p><termdef id="dt-explicit-default" term="explicit default">An <term>explicit
                        default</term> for a parameter is indicated by the presence of either a
                        <code>select</code> attribute or a non-empty sequence
                  constructor.</termdef></p>

               <p><termdef id="dt-implicit-default" term="implicit default">If a parameter that is
                     not <termref def="dt-explicitly-mandatory"/> has no <termref def="dt-explicit-default"/> value, then it has an <term>implicit
                        default</term> value, which is the empty sequence if there is an
                        <code>as</code> attribute, or a zero-length string if not.</termdef></p>

               <p><termdef id="dt-implicitly-mandatory" term="implicitly mandatory">If a parameter
                     has an <termref def="dt-implicit-default"/> value which cannot be converted to
                     the <termref def="dt-required-type"/> (that is, if it has an <code>as</code>
                     attribute which does not permit the empty sequence), then the parameter is
                        <term>implicitly mandatory</term>.</termdef></p>

               <note>
                  <p>The effect of these rules is that specifying <code>&lt;xsl:param name="p"
                        as="xs:date" select="2"/&gt;</code> is an error, but if the default value of
                     the parameter is never used, then the processor has discretion whether or not
                     to report the error. By contrast, <code>&lt;xsl:param name="p"
                        as="xs:date"/&gt;</code> is treated as if <code>required="yes"</code> had
                     been specified: the empty sequence is not a valid instance of
                        <code>xs:date</code>, so in effect there is no default value and the
                     parameter is therefore treated as being mandatory.</p>
               </note>

               <p>Various errors can arise with regard to mandatory parameters when no value is
                  supplied. In the rules below, <term>non-tunnel</term> means: not having a
                     <code>tunnel</code> attribute with the value <code>yes</code>.</p>

               <ulist>

                  <item>
                     <p>
                        <error spec="XT" type="static" class="SE" code="3520">
                           <p>It is a static error if a parameter to <elcode>xsl:iterate</elcode> is
                                 <termref def="dt-implicitly-mandatory"/>.</p>
                        </error>
                     </p>
                  </item>
                  <item>
                     <p>
                        <error spec="XT" type="static" class="SE" code="0690">
                           <p>It is a <termref def="dt-static-error">static error</termref> if a
                                 <termref def="dt-package">package</termref> contains both (a) a
                              named template named <var>T</var> that is not overridden by another
                              named template of higher import precedence and that has an <termref def="dt-explicitly-mandatory"/> non-tunnel parameter named
                                 <var>P</var>, and (b) an <elcode>xsl:call-template</elcode>
                              instruction whose <code>name</code> attribute equals <var>T</var> and
                              that has no non-tunnel <elcode>xsl:with-param</elcode> child element
                              whose <code>name</code> attribute equals <var>P</var>. (All names are
                              compared as QNames.)</p>
                        </error>
                     </p>

                  </item>
                  <item>
                     <p>
                        <error spec="XT" type="dynamic" class="DE" code="0700">
                           <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if a template
                              that has an <termref def="dt-explicitly-mandatory"/> or <termref def="dt-implicitly-mandatory"/> parameter is invoked without
                              supplying a value for that parameter.</p>
                        </error>
                     </p>

                     <p>This includes the following cases:</p>

                     <ulist>
                        <item>
                           <p>The template is invoked using <elcode>xsl:apply-templates</elcode>,
                                 <elcode>xsl:apply-imports</elcode>, or
                                 <elcode>xsl:next-match</elcode> and there is no
                                 <elcode>xsl:with-param</elcode> child whose <code>name</code> and
                                 <code>tunnel</code> attributes match the corresponding attributes
                              of the mandatory parameter.</p>
                        </item>
                        <item>
                           <p>The mandatory parameter is a tunnel parameter, and the template is
                              invoked using <elcode>xsl:call-template</elcode>, and there is no
                                 <elcode>xsl:with-param</elcode> child whose <code>name</code> and
                                 <code>tunnel</code> attributes match the corresponding attributes
                              of the mandatory parameter.</p>
                        </item>
                        <item>
                           <p>The template is invoked as the entry point to the transformation,
                              either by invoking an initial mode (<specref ref="invoking-initial-mode"/>) or by invoking an initial template
                                 (<specref ref="invoking-initial-template"/>) and no value is
                              supplied for the mandatory parameter by the calling application.</p>
                        </item>
                     </ulist>


                  </item>
               </ulist>

            </div3>











         </div2>
         <div2 id="variable-values">
            <head>Values of Variables and Parameters</head>
            <p>A <termref def="dt-variable-binding-element">variable-binding element</termref> may
               specify the <termref def="dt-supplied-value">supplied value</termref> of a <termref def="dt-variable">variable</termref>
               or the default value of a
               <termref def="dt-parameter">parameter</termref> in four different ways.</p>
            <ulist>
               <item>
                  <p>If the <termref def="dt-variable-binding-element">variable-binding
                        element</termref> has a <code>select</code> attribute, then the value of the
                     attribute <rfc2119>must</rfc2119> be an <termref def="dt-expression">expression</termref> and the <termref def="dt-supplied-value">supplied
                        value</termref> of the variable is the value that results from evaluating
                     the expression. In this case, the content of the variable-binding element
                        <rfc2119>must</rfc2119> be empty.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-variable-binding-element">variable-binding
                        element</termref> has empty content and has neither a <code>select</code>
                     attribute nor an <code>as</code> attribute, then the <termref def="dt-supplied-value">supplied value</termref> of the variable is a
                     zero-length string. Thus</p>
                  <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="x"/&gt;</eg>
                  <p>is equivalent to</p>
                  <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="x" select="''"/&gt;</eg>
               </item>
               <item>
                  <p>If a <termref def="dt-variable-binding-element">variable-binding
                        element</termref> has no <code>select</code> attribute and has non-empty
                     content (that is, the variable-binding element has one or more child nodes),
                     and has no <code>as</code> attribute, then the content of the variable-binding
                     element specifies the <termref def="dt-supplied-value">supplied
                     value</termref>. The content of the variable-binding element is a <termref def="dt-sequence-constructor">sequence constructor</termref>; a new document
                     is constructed with a document node having as its children the sequence of
                     nodes that results from evaluating the sequence constructor and then applying
                     the rules given in <specref ref="constructing-complex-content"/>. The value of
                     the variable is then a singleton sequence containing this document node. For
                     further information, see <specref ref="temporary-trees"/>. </p>
               </item>
               <item>
                  <p>If a <termref def="dt-variable-binding-element">variable-binding
                        element</termref> has an <code>as</code> attribute but no
                        <code>select</code> attribute, then the <termref def="dt-supplied-value">supplied value</termref> is the sequence that results from evaluating the
                     (possibly empty) <termref def="dt-sequence-constructor">sequence
                        constructor</termref> contained within the variable-binding element (see
                        <specref ref="sequence-constructors"/>). </p>
               </item>
            </ulist>
            <p>These combinations are summarized in the table below.</p>
            <table class="data">
               <caption>Effect of Different Attribute Combinations on <code>xsl:variable</code></caption>
               <col width="12%" span="1"/>
               <col width="12%" span="1"/>
               <col width="12%" span="1"/>
               <col span="1"/>
               <thead>
                  <tr>
                     <th align="left" rowspan="1" colspan="1">select attribute</th>
                     <th align="left" rowspan="1" colspan="1">as attribute</th>
                     <th align="left" rowspan="1" colspan="1">content</th>
                     <th align="left" rowspan="1" colspan="1">Effect</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">absent</td>
                     <td rowspan="1" colspan="1">empty</td>
                     <td rowspan="1" colspan="1">Value is obtained by evaluating the <code>select</code>
                        attribute</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">empty</td>
                     <td rowspan="1" colspan="1">Value is obtained by evaluating the <code>select</code>
                        attribute, adjusted to the type required by the <code>as</code>
                        attribute</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">absent</td>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">Static error</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">Static error</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">absent</td>
                     <td rowspan="1" colspan="1">absent</td>
                     <td rowspan="1" colspan="1">empty</td>
                     <td rowspan="1" colspan="1">Value is a zero-length string</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">absent</td>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">empty</td>
                     <td rowspan="1" colspan="1">Value is an empty sequence, provided the <code>as</code>
                        attribute permits an empty sequence</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">absent</td>
                     <td rowspan="1" colspan="1">absent</td>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">Value is a document node whose content is obtained by
                        evaluating the sequence constructor</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">absent</td>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">present</td>
                     <td rowspan="1" colspan="1">Value is obtained by evaluating the sequence constructor,
                        adjusted to the type required by the <code>as</code> attribute</td>
                  </tr>
               </tbody>
            </table>
            <p>
               <error spec="XT" type="static" class="SE" code="0620">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a <termref def="dt-variable-binding-element">variable-binding element</termref> has a
                        <code>select</code> attribute and has non-empty content.</p>
               </error>
            </p>
            <example>
               <head>Values of Variables</head>
               <p>The value of the following variable is the sequence of integers (1, 2, 3):</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="i" as="xs:integer*" select="1 to 3"/&gt;</eg>
               <p>The value of the following variable is an integer, assuming that the attribute
                     <code>@size</code> exists, and is annotated either as an integer, or as
                     <code>xs:untypedAtomic</code>:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="i" as="xs:integer" select="@size"/&gt;</eg>
               <p>The value of the following variable is a zero-length string:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="z"/&gt;</eg>
               <p>The value of the following variable is a document node containing an empty element
                  as a child:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="doc"&gt;&lt;c/&gt;&lt;/xsl:variable&gt;</eg>
               <p>The value of the following variable is a sequence of integers (2, 4, 6):</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="seq" as="xs:integer*"&gt;
  &lt;xsl:for-each select="1 to 3"&gt;
    &lt;xsl:sequence select=".*2"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;</eg>
               <p>The value of the following variable is a sequence of parentless attribute
                  nodes:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="attset" as="attribute()+"&gt;
  &lt;xsl:attribute name="x"&gt;2&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="y"&gt;3&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="z"&gt;4&lt;/xsl:attribute&gt;    
&lt;/xsl:variable&gt;</eg>
               <p>The value of the following variable is an empty sequence:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="empty" as="empty-sequence()"/&gt;</eg>
            </example>
            <p>The actual value of the variable depends on the <termref def="dt-supplied-value">supplied value</termref>, as described above, and the required type, which is
               determined by the value of the <code>as</code> attribute.</p>
            <example>
               <head>Pitfalls with Numeric Predicates</head>
               <p>When a variable is used to select nodes by position, be careful not to do:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</eg>
               <p>This will output the values of all the <code>td</code> elements, space-separated
                  (or with <termref def="dt-xslt-10-behavior">XSLT 1.0
                        behavior</termref>, the value of the first <code>td</code>
                  element), because the variable <code>n</code> will be bound to a node, not a
                  number. Instead, do one of the following:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:variable name="n" select="2"/&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</eg>
               <p>or</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[position()=$n]"/&gt;</eg>
               <p>or</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:variable name="n" as="xs:integer"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</eg>
            </example>
         </div2>
         <div2 id="temporary-trees">
            <head>Creating Implicit Document Nodes</head>
            <p>A document node is created implicitly when evaluating an
                  <elcode>xsl:variable</elcode>, <elcode>xsl:param</elcode>, or
                  <elcode>xsl:with-param</elcode> element that has non-empty content and that has no
                  <code>as</code> attribute. The value of the <termref def="dt-variable">variable</termref> is this newly constructed
                  document node.
                The content of the
               document node is formed from the result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> contained within the
               variable-binding element, as described in <specref ref="constructing-complex-content"/>. </p>
            <note>
               <p>The construct:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="tree"&gt;
  &lt;a/&gt;
&lt;/xsl:variable&gt;</eg>
               <p>can be regarded as a shorthand for:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="preserve"&gt;
    &lt;a/&gt;
  &lt;/xsl:document&gt;  
&lt;/xsl:variable&gt;</eg>
            </note>
            <p>The base URI of the document node is taken from the base URI of the variable binding
               element in the stylesheet. (See <xspecref spec="DM30" ref="dm-base-uri"/> in <bibref ref="xpath-datamodel-30"/>)</p>
            <p>No document-level validation takes place (which means, for example, that there is no
               checking that ID values are unique). However, <termref def="dt-type-annotation">type
                  annotations</termref> on nodes within the new tree are copied unchanged.</p>
            <note>
               <p>The base URI of other nodes in the tree is determined by the rules for
                  constructing complex content (see <specref ref="constructing-complex-content"/>).
                  The effect of these rules is that the base URI of a node in the temporary tree is
                  determined as if all the nodes in the temporary tree came from a single entity
                  whose URI was the base URI of the <termref def="dt-variable-binding-element">variable-binding element</termref>. Thus, the base URI of the document node
                  will be equal to the base URI of the variable-binding element, while an
                     <code>xml:base</code> attribute within the temporary tree will change the base
                  URI for its parent element and that element’s descendants, just as it would
                  within a document constructed by parsing.</p>
            </note>
            <p>The <code>document-uri</code> and <code>unparsed-entities</code> properties of the
               new document node are set to empty.</p>
            <p>A <termref def="dt-temporary-tree">temporary tree</termref> is available for
               processing in exactly the same way as any source document. For example, its nodes are
               accessible using path expressions, and they can be processed using instructions such
               as <elcode>xsl:apply-templates</elcode> and <elcode>xsl:for-each</elcode>. Also, the
                  <function>key</function> and <xfunction>id</xfunction> functions can be used to
               find nodes within a temporary tree,  by supplying the
                  document node at the root of the tree as an argument to the function or by making
                  it the context node.</p>
            <example>
               <head>Two-Phase Transformation</head>
               <p>The following stylesheet uses a temporary tree as the intermediate
                  result of a two-phase transformation, using different <termref def="dt-mode">modes</termref> for the two phases (see <specref ref="modes"/>). Typically,
                  the template rules in module <code>phase1.xsl</code> will be declared with
                     <code>mode="phase1"</code>, while those in module <code>phase2.xsl</code> will
                  be declared with <code>mode="phase2"</code>: </p>
               <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:import href="phase1.xsl"/&gt;
&lt;xsl:import href="phase2.xsl"/&gt;

&lt;xsl:variable name="intermediate"&gt;
  &lt;xsl:apply-templates select="/" mode="phase1"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates select="$intermediate" mode="phase2"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
            </example>
            <note>
               <p>The algorithm for matching nodes against template rules is exactly the same
                  regardless which tree the nodes come from. If different template rules are to be
                  used when processing different trees, then unless nodes from different trees can
                  be distinguished by means of <termref def="dt-pattern">patterns</termref>, it is a
                  good idea to use <termref def="dt-mode">modes</termref> to ensure that each tree
                  is processed using the appropriate set of template rules.</p>
            </note>
         </div2>
         <div2 id="global-variables">
            <head>Global Variables and Parameters</head>
            <p>Both <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> are allowed as
                  <termref def="dt-declaration">declaration</termref> elements: that is, they may
               appear as children of the <elcode>xsl:package</elcode> or
               <elcode>xsl:stylesheet</elcode> element.</p>
            <p>
               <termdef id="dt-global-variable" term="global variable">A <termref def="dt-top-level"/> <termref def="dt-variable-binding-element">variable-binding element</termref> declares a
                     <term>global variable</term> that is visible everywhere 
                  <phrase diff="del" at="A">(except within its own declaration, and where it is 
                  <termref def="dt-shadows">shadowed</termref> by another binding)</phrase>
                  <phrase diff="add" at="A">except (a) within the <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode> 
                     element itself, (b) within any other global variable declaration that binds a variable with the same name, 
                     and (c) within any region where it is <termref def="dt-shadows">shadowed</termref> 
                     by another variable binding.</phrase>.</termdef>
            </p>
            <p>
               <termdef id="dt-stylesheet-parameter" term="stylesheet parameter">A <termref def="dt-top-level"/>
                     <elcode>xsl:param</elcode> element declares a <term>stylesheet
                  parameter</term>. A stylesheet parameter is a global variable with the additional
                  property that its value can be supplied by the caller when a transformation is
                  initiated.</termdef> As described in <specref ref="parameters"/>, a stylesheet
               parameter may be declared as being mandatory, or may have a default value specified
               for use when no value is supplied by the caller. The mechanism by which the caller
               supplies a value for a stylesheet parameter is <termref def="dt-implementation-defined">implementation-defined</termref>. An XSLT <termref def="dt-processor">processor</termref>
               <rfc2119>must</rfc2119> provide such a mechanism.</p>
            <imp-def-feature id="idf-api-params">The mechanism by which the caller supplies a value
               for a <termref def="dt-stylesheet-parameter"/> is <termref def="dt-implementation-defined">implementation-defined</termref>.</imp-def-feature>
            <p>It is an error if no value is supplied for a mandatory stylesheet parameter <errorref spec="XT" class="DE" code="0050"/>.</p>
            <p>If a <termref def="dt-stylesheet">stylesheet</termref> contains more than one binding
               for a global variable of a particular name, then the binding with the highest
                  <termref def="dt-import-precedence">import precedence</termref> is used.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0630">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a <termref def="dt-package">package</termref> contains more
                     than one non-hidden binding of a global
                     variable with the same name and same <termref def="dt-import-precedence">import
                        precedence</termref>, unless it also contains another binding with the same
                     name and higher import precedence.</p>
               </error>
            </p>
            <p>For a global variable or the default value of a stylesheet parameter, the <termref def="dt-expression">expression</termref> or <termref def="dt-sequence-constructor">sequence constructor</termref> specifying the variable value is evaluated with a
                  <termref def="dt-singleton-focus">singleton focus</termref> as follows:</p>

            <ulist>
               <item>
                  <p>If the declaration appears within the <termref def="dt-top-level-package"/>
                     (including within an <elcode>xsl:override</elcode> element in the top-level
                     package), then the focus is based on the <termref def="dt-global-context-item"/> if supplied, or <termref def="dt-absent"/> otherwise.</p>
               </item>
               <item>
                  <p>If the declaration appears within a <termref def="dt-library-package"/>, then the focus is <termref def="dt-absent"/>.</p>
               </item>
            </ulist>

            <p>An XPath error will be reported if the evaluation of a global variable or parameter
               references the context item, context position, or context size when the <termref def="dt-focus"/> is <termref def="dt-absent"/>. The values of other components of
               the dynamic context are the initial values as defined in <specref ref="xpath-dynamic-context"/> and <specref ref="additional-dynamic-context"/>.</p>
            
  

            <p>The <termref def="dt-visibility"/> of a <termref def="dt-stylesheet-parameter"/> is always (implicitly) <code>private</code> if the
               parameter is <code>static</code>, or <code>public</code> if the parameter is
               non-static.</p>


            <note>
               <p>This rule has the effect that after combining all the packages making up a
                  stylesheet, the non-static stylesheet parameters whose values are required
                  necessarily have distinct names, which simplifies the design of APIs.</p>
            </note>

            <p>For the effect of the <code>static</code> attribute, see <specref ref="static-params"/>.</p>

            <p>The <code>visibility</code> attribute <rfc2119>must
                  not</rfc2119> be specified for a local variable: that is, it is allowed only when
               the parent element is <elcode>xsl:package</elcode>, <elcode>xsl:stylesheet</elcode>,
                  <elcode>xsl:transform</elcode>, or <elcode>xsl:override</elcode>.</p>

            <p>If the <code>visibility</code> attribute is present with the value
                  <code>abstract</code> then the <code>select</code> attribute
                  <rfc2119>must</rfc2119> be absent and the contained <termref def="dt-sequence-constructor"/>
               <rfc2119>must</rfc2119> be empty. In this situation there is no <termref def="dt-supplied-value">supplied value</termref>, and therefore the constraint
               that the supplied value is consistent with the required type does not apply.</p>
            <example>
               <head>A Stylesheet Parameter</head>
               <p>The following example declares a global parameter <code>para-font-size</code>,
                  which is referenced in an <termref def="dt-attribute-value-template">attribute
                     value template</termref>.</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:param name="para-font-size" as="xs:string"&gt;12pt&lt;/xsl:param&gt;

&lt;xsl:template match="para"&gt;
 &lt;fo:block font-size="{$para-font-size}"&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</eg>
               <p>The implementation must provide a mechanism allowing the user to supply a value
                  for the parameter <code>para-font-size</code> when invoking the stylesheet; the
                  value <code>12pt</code> acts as a default.</p>
            </example>
         </div2>








         <div2 id="static-params">
            <head>Static Variables and Parameters</head>
            <p>Static variables and parameters are global variables and can be used in the same way
               as other global variables. In addition, they can be used in
                  <code>[xsl:]use-when</code> expressions and in shadow attributes.</p>
            <p>
               <termdef id="dt-static-variable" term="static variable">A <termref def="dt-top-level"/>
                  <termref def="dt-variable-binding-element">variable-binding element</termref>
                  having the attribute <code>static="yes"</code> declares a <term>static
                     variable</term>: that is, a <termref def="dt-global-variable"/> whose value is
                  known during static analysis of the stylesheet.</termdef>
            </p>
            <p>
               <termdef id="dt-static-parameter" term="static parameter">A <termref def="dt-static-variable"/> declared using an <elcode>xsl:param</elcode> element
                  is referred to as a <term>static parameter</term>.</termdef>
            </p>
            <p>The <code>static</code> attribute <rfc2119>must not</rfc2119>
               take the value <code>yes</code> on an
                  <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode> element unless it is a
                  <termref def="dt-top-level"/> element.</p>
            <p>When the <code>static</code> attribute is present with the value
                  <code>yes</code>, the <code>visibility</code> attribute <rfc2119>must
                  not</rfc2119> have a value other than <code>private</code>.</p>
            <note>
               <p>This rule prevents static variables being overridden in another package. Since the
                  values of such variables may be used at compile time (for example, during
                  processing of <code>[xsl:]use-when</code> expressions), the rule is necessary to
                  ensure that packages can be independently compiled.</p>
               
               <p>It is possible to make the value of a static variable
                  or parameter available in a using package by binding a non-static public variable
                  to its value, for example:</p>
               <eg role="xslt-declaration" xml:space="preserve">
     &lt;xsl:param name="DEBUG" static="yes" select="true()"/&gt;
     &lt;xsl:variable name="tracing" static="no" visibility="public" select="$DEBUG"/&gt;</eg>
            </note>
            <p>When the attribute <code>static="yes"</code> is specified, the
                  <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode> element
                  <rfc2119>must</rfc2119> have empty content. In the case of
                  <elcode>xsl:variable</elcode> the <code>select</code> attribute must be present to
               define the value of the variable <errorref spec="XT" class="SE" code="0010"/>.</p>
            <p>If the <code>select</code> attribute is present, then it is evaluated using the rules
               for <termref def="dt-static-expression">static expressions</termref>.</p>

            <p>The rules for the scope of static variables, and the
               handling of duplicate declarations, are similar to the rules for non-static
               variables, but with additional constraints designed to disallow forwards references.
               The reason for disallowing forwards references is to ensure that
                  <code>use-when</code> attributes can always be evaluated as early as possible, and
               in particular to ensure that the value of a <code>use-when</code> attribute never has
               circular dependencies. The additional constraints are as follows:</p>

            <olist>
               <item>
                  <p>The static context for evaluation of a <termref def="dt-static-expression"/>
                     only contains those <termref def="dt-static-variable">static
                        variables</termref> visible within the containing package whose declarations
                     occur prior to the element containing the static expression in stylesheet tree
                     order. Stylesheet tree order is the order that results when all
                        <elcode>xsl:import</elcode> and <elcode>xsl:include</elcode> declarations
                     are replaced by the declarations in the imported or included stylesheet module.
                     A static variable is not in scope within its own declaration.</p>
               </item>
               <item>
                  <p>If two static variables declared within the same package have the same name,
                     the one that has higher <termref def="dt-import-precedence"/> is used (it is a
                     consequence of rules defined elsewhere that there cannot be more than one
                     declaration with highest import precedence). However, if the declaration with
                     higher import precedence occurs after the one with lower import precedence in
                     stylesheet tree order, then the two declarations must be consistent. For this
                     purpose two declarations are consistent if (a) they are either both
                        <elcode>xsl:variable</elcode> elements, or both <elcode>xsl:param</elcode>
                     elements, and (b) if the variables are initialized (that is, if the elements
                     are <elcode>xsl:variable</elcode> elements, or if they are
                        <elcode>xsl:param</elcode> elements and no value for the parameter is
                     externally supplied) then the values of both variables must be <xtermref spec="FO40" ref="dt-identical">identical</xtermref>, and must not contain
                     function items.</p>

                  <note>
                     <p>This rule ensures that when a static variable reference is encountered, the
                        value of the most recently declared static variable with that name can be
                        used, knowing that this value cannot be overridden by a subsequent
                        declaration having higher import precedence.</p>
                  </note>

                  <p><error spec="XT" type="static" class="SE" code="3450">
                        <p>It is a <termref def="dt-static-error">static error</termref> if a
                           variable declared with <code>static="yes"</code> is inconsistent with
                           another static variable of the same name that is declared earlier in
                           stylesheet tree order and that has lower <termref def="dt-import-precedence"/>.</p>
                     </error></p>

               </item>
            </olist>
            
            <note diff="add" at="A">
               <p>It is not an error to have two global variables or parameters with the same name, 
                  one static and one non-static, provided that they have different import precedence. 
                  If the static variable has higher precedence, then it will be used as the selected 
                  binding for all global variable references with this name, whether or not they appear 
                  in static expressions. If the non-static variable has higher precedence, then the 
                  static variable will be used as the selected binding for variable references appearing 
                  in static expressions, while the non-static variable will be used for variable 
                  references in non-static expressions. The two variables may have different values. 
                  In the case of global parameters, however, a transformation API may restrict 
                  them to have the same value.</p>
                  
                  <p>If the two variable declarations have the same import precedence, and there is 
                     no declaration with higher import precedence, then error condition 
                     <errorref class="SE" code="0630"/> applies.
                  [XSLT 3.0 Erratum E34, bug 30301].</p>
            </note>

         </div2>
         <div2 id="static-expression">
            <head>Static Expressions</head>
            <p><termdef id="dt-static-expression" term="static expression">A <term>static
                     expression</term> is an XPath <termref def="dt-expression"/> whose value must
                  be computed during static analysis of the stylesheet.</termdef></p>
            <p>Static expressions appear in a number of contexts, in particular:</p>
            <ulist>
               <item>
                  <p>In <code>[xsl:]use-when</code> attributes (see <specref ref="conditional-inclusion"/>);</p>
               </item>
               <item>
                  <p>In the <code>select</code> attribute of <termref def="dt-static-variable"/>
                     declarations (<elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode> with
                        <code>static="yes"</code>);</p>
               </item>
               <item>
                  <p>In shadow attributes (see <specref ref="shadow-attributes"/>).</p>
               </item>
            </ulist>
            <p>There are no syntactic constraints on the XPath expression that can be used as a
                  <termref def="dt-static-expression"/>. However, there are severe constraints on
               the information provided in its evaluation context. These constraints are designed to
               ensure that the expression can be evaluated at the earliest possible stage of
               stylesheet processing, without any dependency on information contained in the
               stylesheet itself or in any source document.</p>
            <p>Specifically, the components of the static and dynamic context are defined by the
               following two tables:</p>
            <table class="def">
               <caption>Static Context Components for Static Expressions</caption>
               <col align="left" width="30%" span="1"/>
               <col align="left" span="1"/>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Component</th>
                     <th rowspan="1" colspan="1">Value</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td rowspan="1" colspan="1">XPath 1.0 compatibility mode</td>
                     <td rowspan="1" colspan="1">false</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Statically known namespaces</td>
                     <td rowspan="1" colspan="1">determined by the in-scope namespaces for the containing element in the
                        stylesheet</td>
                  </tr>
                  <tr diff="chg" at="A">
                     <td rowspan="1" colspan="1">Default element namespace</td>
                     <td rowspan="1" colspan="1">determined by the <code>xpath-default-namespace</code> attribute if present
                        (see <specref ref="unprefixed-qnames"/>); otherwise the null namespace</td>
                  </tr>
                  <tr diff="chg" at="A">
                     <td rowspan="1" colspan="1">Default type namespace</td>
                     <td rowspan="1" colspan="1">determined by the <code>xpath-default-namespace</code> attribute if present
                        (see <specref ref="unprefixed-qnames"/>); otherwise the null namespace</td>
                  </tr>
                  <tr diff="chg" at="A">
                     <td rowspan="1" colspan="1">Function name resolver</td>
                     <td rowspan="1" colspan="1">Prefixed function names are resolved using the in-scope namespaces of
                        the containing element; unprefixed function names are taken as being in the <termref def="dt-standard-function-namespace"/>.
                     </td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">In-scope schema types</td>
                     <td rowspan="1" colspan="1">The type definitions that would be available in the absence of any
                           <elcode>xsl:import-schema</elcode> declaration</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">In-scope element declarations</td>
                     <td rowspan="1" colspan="1">None</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">In-scope attribute declarations</td>
                     <td rowspan="1" colspan="1">None</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">In-scope variables</td>
                     <td rowspan="1" colspan="1">The <termref def="dt-static-variable">static
                           variables</termref> visible within the containing package whose
                        declarations occur prior to the element containing the static expression in
                        stylesheet tree order. Stylesheet tree order is the order that results when
                        all <elcode>xsl:import</elcode> and <elcode>xsl:include</elcode>
                        declarations are replaced by the declarations in the imported or included
                        stylesheet module. A static variable is not in scope within its own
                        declaration, and it is in scope only within its
                           declaring package, not in any using packages. If two static
                        variables satisfying this rule have the same name and are both in scope, the
                        one that appears most recently in stylesheet tree order is used; as a
                        consequence of rules defined elsewhere this will always be consistent with
                        the declaration having highest import precedence.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Context item static type</td>
                     <td rowspan="1" colspan="1"><termref def="dt-absent">Absent</termref></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Statically known function
                        signatures</td>
                     <td rowspan="1" colspan="1">The functions defined in <bibref ref="xpath-functions-40"/> in the <code>fn</code>
                        <code>math</code>, <phrase diff="add" at="A"><code>map</code>, and <code>array</code></phrase>  namespaces, together with:
                        <olist>
                           <item><p>the functions
                              <function>element-available</function>,
                              <function>function-available</function>,
                              <function>type-available</function>,
                              <function>available-system-properties</function>,
                              and
                              <function>system-property</function> defined in this specification;</p></item>
                           <item><p>functions that appear in both this specification and in <bibref ref="xpath-functions-31"/>
                           (for example, the functions in the <code>map</code> namespaces, and a few others such as <code>collation-key</code>
                           and <code>json-to-xml</code>);</p></item>
                           <item diff="del" at="A"><p>if XPath 3.1 is supported, functions defined in <bibref ref="xpath-functions-31"/>
                              in the <code>fn</code>, <code>math</code>, <code>map</code>, and <code>array</code> namespaces;</p></item>
                           <item><p>constructor functions for built-in types;</p></item>
                           <item><p>the set of extension functions that are present in the static context of
                              every XPath expression (other than a static expression) within the content
                              of the element that contains the static expression. </p></item>
                        </olist>
                        
                        Note that <termref def="dt-stylesheet-function">stylesheet functions</termref> are
                           <emph>not</emph> included in the context, which means that the function
                           <function>function-available</function> will return <code>false</code> in
                        respect of such functions, and <xfunction>function-lookup</xfunction> will
                        fail to find them. The effect of this rule is to ensure that
                           <function>function-available</function> returns true in respect of
                        functions that can be called within the static expression. It also has the
                        effect that these extension functions will be recognized within the static
                        expression itself; however, the fact that a function is available in this
                        sense gives no guarantee that a call on the function will succeed.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Statically known collations</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Default collation</td>
                     <td rowspan="1" colspan="1">The Unicode Codepoint Collation</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Static Base URI</td>
                     <td rowspan="1" colspan="1">The base URI of the containing element in the stylesheet document (see <xspecref spec="DM30" ref="dm-base-uri"/>)</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Statically known documents</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Statically known collections</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Statically known default collection type</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Statically known decimal formats</td>
                     <td rowspan="1" colspan="1">A single unnamed <termref def="dt-decimal-format">decimal format</termref>
                        equivalent to the decimal format that is created by an
                           <elcode>xsl:decimal-format</elcode> declaration with no attributes.</td>
                  </tr>
               </tbody>
            </table>
            <p> </p>
            <table class="def">
               <caption>Dynamic Context Components for Static Expressions</caption>
               <col align="left" width="30%" span="1"/>
               <col align="left" span="1"/>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Component</th>
                     <th rowspan="1" colspan="1">Value</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td rowspan="1" colspan="1">Context item, position, and size</td>
                     <td rowspan="1" colspan="1"><termref def="dt-absent">Absent</termref></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Variable values</td>
                     <td rowspan="1" colspan="1">A value for every variable present in the in-scope variables. For <termref def="dt-static-parameter">static parameters</termref> where an external
                        value is supplied: the externally-supplied value of the parameter. In all
                        other cases: the value of the variable as defined in <specref ref="variable-values"/>.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Named functions</td>
                     <td rowspan="1" colspan="1">The function implementation corresponding to each function signature in the
                        statically known function signatures</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Current dateTime</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Implicit timezone</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Default language</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Default calendar</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Default place</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Available documents</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Available collections</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Default collection</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Environment variables</td>
                     <td rowspan="1" colspan="1">Implementation-defined</td>
                  </tr>
               </tbody>
            </table>
            <p>Within a <termref def="dt-stylesheet-module">stylesheet module</termref>, all static
               expressions are evaluated in a single <xtermref spec="FO40" ref="execution-scope">execution scope</xtermref>. This need not be the same execution scope as that
               used for static expressions in other stylesheet modules, or as that used when
               evaluating XPath expressions appearing elsewhere in the stylesheet module. This means
               that a function such as <xfunction>current-date</xfunction> will return the same
               result when called in different <code>[xsl:]use-when</code> expressions within the
               same stylesheet module, but will not necessarily return the same result as the same
               call in an <code>[xsl:]use-when</code> expression within a different stylesheet
               module, or as a call on the same function executed during the transformation
               proper.</p>
            <p>If a <termref def="dt-static-error"/> is present in a
                  <termref def="dt-static-expression"/>, it is treated in the same way as any other
               static error in the stylesheet module. If a <termref def="dt-dynamic-error"/> occurs
               during evaluation of a static expression, it is treated as a static error in the
               analysis of the stylesheet, while retaining its original error code.</p>
         </div2>
         <div2 id="local-variables">
            <head>Local Variables and Parameters</head>
            <p>
               <termdef id="dt-local-variable" term="local variable">As well as being allowed as a
                     <termref def="dt-declaration">declaration</termref>, the
                     <elcode>xsl:variable</elcode> element is also allowed in <termref def="dt-sequence-constructor">sequence constructors</termref>. Such a variable
                  is known as a <term>local variable</term>.</termdef>
            </p>
            <p>An <elcode>xsl:param</elcode> element may also be used to create a variable binding
               with local scope:</p>
            <ulist>
               <item>
                  <p>
                     <termdef id="dt-template-parameter" term="template parameter"> An
                           <elcode>xsl:param</elcode> element may appear as a child of an
                           <elcode>xsl:template</elcode> element, before any
                           non-<elcode>xsl:param</elcode> children of that element. Such a parameter
                        is known as a <term>template parameter</term>. A template parameter is a
                           <termref def="dt-local-variable">local variable</termref> with the
                        additional property that its value can be set when the template is called,
                        using any of the instructions <elcode>xsl:call-template</elcode>,
                           <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
                        or <elcode>xsl:next-match</elcode>.</termdef>
                  </p>
               </item>
               <item>
                  <p>
                     <termdef id="dt-function-parameter" term="function parameter"> An
                           <elcode>xsl:param</elcode> element may appear as a child of an
                           <elcode>xsl:function</elcode> element, before any
                           non-<elcode>xsl:param</elcode> children of that element. Such a parameter
                        is known as a <term>function parameter</term>. A function parameter is a
                           <termref def="dt-local-variable">local variable</termref> with the
                        additional property that its value can be set when the function is called,
                        using a function call in an XPath <termref def="dt-expression">expression</termref>.</termdef>
                  </p>
               </item>
               <item>
                  <p>An <elcode>xsl:param</elcode> element may appear as a child
                     of an <elcode>xsl:iterate</elcode> instruction, before any
                        non-<elcode>xsl:param</elcode> children of that element. This defines a
                     parameter whose value may be initialized on entry to the iteration, and which
                     may be varied each time round the iteration by use of an
                        <elcode>xsl:with-param</elcode> element in the
                        <elcode>xsl:next-iteration</elcode> instruction. </p>
               </item>
            </ulist>
            <p>The result of evaluating a local <elcode>xsl:variable</elcode> or
                  <elcode>xsl:param</elcode> element (that is, the contribution it makes to the
               result of the <termref def="dt-sequence-constructor"/> it is part of) is an empty
               sequence.</p>
         </div2>
         <div2 id="scope-of-variables">
            <head>Scope of Variables</head>
            <p>For any <termref def="dt-variable-binding-element">variable-binding
               element</termref>, there is a region (more specifically, a set of  nodes) of the <termref def="dt-stylesheet">stylesheet</termref> within which the binding is visible. The set of variable
               bindings in scope for an XPath <termref def="dt-expression">expression</termref>
               consists of those bindings that are visible at the point in the stylesheet where the
               expression occurs.</p>
            <p>A global <termref def="dt-variable-binding-element">variable binding
                  element</termref> is visible everywhere in the containing <termref def="dt-package"/>
                   (including other <termref def="dt-stylesheet-module">stylesheet modules</termref>) except within the <elcode>xsl:variable</elcode> or
                  <elcode>xsl:param</elcode> element itself and any region where it is <termref def="dt-shadows">shadowed</termref> by another variable binding.
               (For rules regarding the visibility of the variable
               in other packages, see <specref ref="visibility"/>.)
            </p>
            <p>A local <termref def="dt-variable-binding-element">variable binding element</termref>
               is visible for all following siblings and their descendants, with the following exceptions:</p>
            <olist>
               <item>
                  <p>It is not visible in any region where it is <termref def="dt-shadows">shadowed</termref> by another variable binding.</p>
               </item>
               <item>
                  <p>It is not visible within the subtree rooted at an <elcode>xsl:fallback</elcode>
                     instruction that is a sibling of the variable binding element.</p>
               </item>
               <item>
                  <p>It is not visible within the subtree rooted at an
                        <elcode>xsl:catch</elcode> instruction that is a sibling of the variable
                     binding element.</p>
               </item>
               <item diff="add" at="A">
                  <p>Within an <elcode>xsl:function</elcode> declaration, a <termref def="dt-function-parameter"/>
                     is not visible within sibling <elcode>xsl:param</elcode> elements.</p>
               </item>
            </olist>

            <p>The binding is not visible for the <elcode>xsl:variable</elcode> or
                  <elcode>xsl:param</elcode> element itself.</p>
            <p>If a binding is visible for an element then it is visible for every
               attribute of that element and for every text node child of that element.</p>
            <p diff="add" at="A">An <elcode>xsl:param</elcode> element specifying <code>tunnel="yes"</code>
            is also visible in the <code>test</code> attribute of the containing <elcode>xsl:template</elcode>
            element.</p>
            <p diff="del" at="A">
               A binding <term>shadows</term> another
                  binding if the binding occurs at a point where the other binding is visible, and
                  the bindings have the same name. It is not an error if a binding
               established by a local <elcode>xsl:variable</elcode> or <elcode>xsl:param</elcode>
               <termref def="dt-shadows">shadows</termref> a global binding. In this case, the
               global binding will not be visible in the region of the 
               <termref def="dt-stylesheet">stylesheet</termref> where it is shadowed by the other binding.</p>
            <p diff="add" at="A"><termdef id="dt-shadows" term="shadows">Within a region of the 
               stylesheet where a binding <var>B</var>1 is visible, <var>B1</var> shadows another 
               binding <var>B2</var> having the same name as <var>B1</var> if <var>B1</var> occurs at 
               a point where <var>B2</var> is visible.</termdef> [XSLT 3.0 Erratum E5, bug 30171].</p>
            <example>
               <head>Local Variable Shadowing a Global Variable</head>
               <p>The following is allowed:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:param name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <p>It is also not an error if a binding established by a local
                  <elcode>xsl:variable</elcode> element <termref def="dt-shadows">shadows</termref>
               a binding established by another local <elcode>xsl:variable</elcode> or
                  <elcode>xsl:param</elcode>.</p>
            <example>
               <head>Misuse of Variable Shadowing</head>
               <p>The following is not an error, but the effect is probably not what was intended.
                  The template outputs <code>&lt;x value="1"/&gt;</code>, because the declaration of
                  the inner variable named <code>$x</code> has no effect on the value of the outer
                  variable named <code>$x</code>.</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:for-each select="1 to 5"&gt;
    &lt;xsl:variable name="x" select="$x+1"/&gt;
  &lt;/xsl:for-each&gt;
  &lt;x value="{$x}"/&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <note>
               <p>Once a variable has been given a value, the value cannot subsequently be changed.
                  XSLT does not provide an equivalent to the assignment operator available in many
                  procedural programming languages. </p>
               <p>This is because an assignment operator would make it harder to create an
                  implementation that processes a document other than in a batch-like way, starting
                  at the beginning and continuing through to the end.</p>
            </note>
            <p>As well as global variables and local variables, an XPath <termref def="dt-expression">expression</termref> may also declare range variables for use
               locally within an expression. For details, see <bibref ref="xpath-30"/>.</p>
            <p>Where a reference to a variable occurs in an XPath expression, it is resolved first
               by reference to range variables that are in scope, then by reference to local
               variables and parameters, and finally by reference to global variables and
               parameters. A range variable may shadow a local variable or a global variable. XPath
               also allows a range variable to shadow another range variable.</p>
         </div2>
         <div2 id="with-param">
            <head>Setting Parameter Values</head>
            <?element xsl:with-param?>
            <p>Parameters are passed to templates using the <elcode>xsl:with-param</elcode> element.
               The <rfc2119>required</rfc2119>
               <code>name</code> attribute specifies the name of the <termref def="dt-template-parameter">template parameter</termref> (the variable the value
               of whose binding is to be replaced). The value of the <code>name</code> attribute is
               an <termref def="dt-eqname">EQName</termref>,
               which is expanded as described in <specref ref="qname"/>.</p>
            <p>The <elcode>xsl:with-param</elcode> element is also used
                  when passing parameters to an iteration of the <elcode>xsl:iterate</elcode>
                  instruction, or to a dynamic invocation of an XPath expression using
                     <elcode>xsl:evaluate</elcode>. In consequence, 
               <elcode>xsl:with-param</elcode> may appear within
                  <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>,
                  <elcode>xsl:call-template</elcode>, <elcode>xsl:evaluate</elcode>, <elcode>xsl:next-iteration</elcode>, 
               and <elcode>xsl:next-match</elcode>. (Arguments to <termref def="dt-stylesheet-function">stylesheet functions</termref>, however, are supplied
               as part of an XPath function call: see <specref ref="stylesheet-functions"/>.) </p>
            <p>
               <error spec="XT" type="static" class="SE" code="0670">
                  <p>It is a <termref def="dt-static-error">static error</termref>
                     if two or more sibling <elcode>xsl:with-param</elcode> elements have
                        <code>name</code> attributes that represent the same <termref def="dt-expanded-qname">expanded QName</termref>.</p>
               </error>
            </p>
            <p>The value of the parameter is specified in the same way as for
                  <elcode>xsl:variable</elcode> and <elcode>xsl:param</elcode> (see <specref ref="variable-values"/>), taking account of the values of the <code>select</code>
               and <code>as</code> attributes and the content of the <elcode>xsl:with-param</elcode>
               element, if any.</p>
            <note>
               <p>It is possible to have an <code>as</code> attribute on the
                     <elcode>xsl:with-param</elcode> element that differs from the <code>as</code>
                  attribute on the corresponding <elcode>xsl:param</elcode> element.</p>
               <p>In this situation, the supplied value of the parameter will first be processed
                  according to the rules of the <code>as</code> attribute on the
                     <elcode>xsl:with-param</elcode> element, and the resulting value will then be
                  further processed according to the rules of the <code>as</code> attribute on the
                     <elcode>xsl:param</elcode> element.</p>
               <p>For example, suppose the supplied value is a node with <termref def="dt-type-annotation"/>
                  <code>xs:untypedAtomic</code>, and the <elcode>xsl:with-param</elcode> element
                  specifies <code>as="xs:integer"</code>, while the <elcode>xsl:param</elcode>
                  element specifies <code>as="xs:double"</code>. Then the node will first be
                  atomized and the resulting untyped atomic value will be cast to
                     <code>xs:integer</code>. If this succeeds, the <code>xs:integer</code> will
                  then be promoted to an <code>xs:double</code>.</p>
            </note>
            <p>The <termref def="dt-focus">focus</termref> used for computing the value specified by
               the <elcode>xsl:with-param</elcode> element is the same as that used for its parent <termref def="dt-instruction">instruction</termref>.</p>

            <p>The optional <code>tunnel</code> attribute may be used to indicate that a parameter
               is a <termref def="dt-tunnel-parameter">tunnel parameter</termref>. The default is
                  <code>no</code>. Tunnel parameters are described in <specref ref="tunnel-params"/>. They are used only when passing parameters to templates: for an
                  <elcode>xsl:with-param</elcode> element that is a child of
                  <elcode>xsl:evaluate</elcode> or <elcode>xsl:next-iteration</elcode> the
                  <code>tunnel</code> attribute <rfc2119>must</rfc2119> either be omitted or take
               the value <code>no</code>. </p>

            <p> In other cases it is a <termref def="dt-dynamic-error"> dynamic error</termref> if the template that is
               invoked declares a <termref def="dt-template-parameter">template parameter</termref>
               with <code>required="yes"</code> and no value for this parameter is supplied by the
               calling instruction. <errorref spec="XT" class="DE" code="0700"/>
            </p>

         </div2>
         <div2 id="circularity">
            <head>Circular Definitions</head>
            <p>
               <termdef id="dt-circularity" term="circularity">A <term>circularity</term> is said to
                  exist if a construct such as a <termref def="dt-global-variable">global
                     variable</termref>, an <termref def="dt-attribute-set">attribute set</termref>,
                  or a <termref def="dt-key">key</termref>, is defined in terms of itself. For
                  example, if the <termref def="dt-expression">expression</termref> or <termref def="dt-sequence-constructor">sequence constructor</termref> specifying the
                  value of a <termref def="dt-global-variable">global variable</termref>
                  <var>X</var> references a global variable <var>Y</var>, then the value for
                     <var>Y</var>
                  <rfc2119>must</rfc2119> be computed before the value of <var>X</var>. A
                  circularity exists if it is impossible to do this for all global variable
                  definitions.</termdef>
            </p>
            <example>
               <head>Circular Variable Definitions</head>
               <p>The following two declarations create a circularity:</p>
               <eg role="error" xml:space="preserve">&lt;xsl:variable name="x" select="$y+1"/&gt;
&lt;xsl:variable name="y" select="$x+1"/&gt;</eg>
            </example>
            <example>
               <head>Circularity involving Variables and Functions</head>
               <p>The definition of a global variable can be circular even if no other variable is
                  involved. For example the following two declarations (see <specref ref="stylesheet-functions"/> for an explanation of the
                     <elcode>xsl:function</elcode> element) also create a circularity:</p>
               <eg role="error" xml:space="preserve">&lt;xsl:variable name="x" select="my:f()"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:sequence select="$x"/&gt;
&lt;/xsl:function&gt;
</eg>
            </example>
            <example>
               <head>Circularity involving Variables and Templates</head>
               <p>The definition of a variable is also circular if the evaluation of the variable
                  invokes an <elcode>xsl:apply-templates</elcode> instruction and the variable is
                  referenced in the pattern used in the <code>match</code> attribute of any template
                  rule in the <termref def="dt-stylesheet">stylesheet</termref>. For example the
                  following definition is circular:</p>
               <eg role="error" xml:space="preserve">&lt;xsl:variable name="x"&gt;
  &lt;xsl:apply-templates select="//param[1]"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="param[$x]"&gt;1&lt;/xsl:template&gt;
</eg>
            </example>
            <example>
               <head>Circularity involving Variables and Keys</head>
               <p>Similarly, a variable definition is circular if it causes a call on the
                     <function>key</function> function, and the definition of that <termref def="dt-key">key</termref> refers to that variable in its <code>match</code> or
                     <code>use</code> attributes. So the following definition is circular:</p>
               <eg role="error" xml:space="preserve">&lt;xsl:variable name="x" select="my:f(10, /)"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="arg1"/&gt;
  &lt;xsl:param name="top"/&gt;
  &lt;xsl:sequence select="key('k', $arg1, $top)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:key name="k" match="item[@code=$x]" use="@desc"/&gt;
</eg>
            </example>

            <example>
               <head>Circularity involving Attribute Sets</head>
               <p>An attribute set is circular if its <code>use-attribute-sets</code> attribute
                  references itself, directly or indirectly. So the following definitions establish
                  a circularity:</p>
               <eg role="error" xml:space="preserve">&lt;xsl:attribute-set name="a" use-attribute-sets="b"/&gt;
&lt;xsl:attribute-set name="b" use-attribute-sets="a"/&gt;                  
</eg>
               <p>Because attribute sets can invoke functions, global variables, or templates, and
                  can also include instructions such as literal result elements that themselves
                  invoke attribute sets, examples of circularity involving attribute sets can be
                  more complex than this simple example illustrates. It is also possible to
                  construct examples in which self-reference among attribute sets could be regarded
                  as (terminating or non-terminating) recursion. However, because such
                  self-references have no practical utility, any requirement to evaluate an
                  attribute set in the course of its own evaluation is considered an error.</p>

               <note>
                  <p>In previous versions of this specification, self-reference among attribute sets
                     was defined as a static error. In XSLT 3.0 it is not always detectable
                     statically, because attribute sets can bind to each other across package
                     boundaries. Nevertheless, in cases where a processor can detect a static
                     circularity, it can report this error during the analysis phase, under the
                     general provision for reporting dynamic errors during stylesheet analysis if
                     execution can never succeed.</p>
               </note>
            </example>

            <p>
               <error spec="XT" type="dynamic" class="DE" code="0640">
                  <p>In general, a <termref def="dt-circularity">circularity</termref> in a <termref def="dt-stylesheet">stylesheet</termref> is a <termref def="dt-dynamic-error">
                        dynamic error</termref>.</p>
               </error> However, as with all other dynamic errors, an implementation will signal the
               error only if it actually executes the instructions and expressions that participate
               in the circularity. Because different implementations may optimize the execution of a
               stylesheet in different ways, it is <termref def="dt-implementation-dependent">implementation-dependent</termref> whether a particular circularity will actually
               be signaled.</p>
            <p>For example, in the following declarations, the function declares a local variable
                  <code>$b</code>, but it returns a result that does not require the variable to be
               evaluated. It is <termref def="dt-implementation-dependent">implementation-dependent</termref> whether the value is actually evaluated, and
               it is therefore implementation-dependent whether the circularity is signaled as an
               error:</p>
            <eg role="error" xml:space="preserve">&lt;xsl:variable name="x" select="my:f(1)"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="a"/&gt;
  &lt;xsl:variable name="b" select="$x"/&gt;  
  &lt;xsl:sequence select="$a + 2"/&gt;
&lt;/xsl:function&gt;
</eg>
            <p>Although a circularity is detected as a dynamic error,
               there is no unique instruction whose evaluation triggers the error condition, and the
               result of any attempt to catch the error using an <elcode>xsl:try</elcode>
               instruction is therefore <termref def="dt-implementation-dependent"/>.</p>

            <p>Circularities usually involve global variables or parameters, but they can also exist
               between <termref def="dt-key">key</termref> definitions (see <specref ref="key"/>),
               between named <termref def="dt-attribute-set">attribute sets</termref> (see <specref ref="attribute-sets"/>), or between any combination of these constructs. For
               example, a circularity exists if a key definition invokes a function that references
               an attribute set that calls the <function>key</function> function, supplying the name
               of the original key definition as an argument.</p>
            <p>Circularity is not the same as recursion. Stylesheet functions (see <specref ref="stylesheet-functions"/>) and named templates (see <specref ref="named-templates"/>) may call other functions and named templates without
               restriction. With careless coding, recursion may be non-terminating. Implementations
               are <rfc2119>required</rfc2119> to signal circularity as a <termref def="dt-dynamic-error">dynamic error</termref>, but they are not
                  <rfc2119>required</rfc2119> to detect non-terminating recursion.</p>
            <p>The requirement to report a circularity as a dynamic error
               overrides the rule that dynamic errors in evaluating <termref def="dt-pattern">patterns</termref> are normally masked (by treating the pattern as not
               matching).</p>
         </div2>
      </div1>
      <div1 id="callable-components">
         <head>Callable Components</head>
         <p>This section describes three constructs that can be used to provide subroutine-like
            functionality that can be invoked from anywhere in the stylesheet: named templates (see
               <specref ref="named-templates"/>), named attribute sets (see <specref ref="attribute-sets"/>), and <termref def="dt-stylesheet-function">stylesheet
               functions</termref> (see <specref ref="stylesheet-functions"/>).</p>

         <p><termdef id="dt-invocation-construct" term="invocation construct">The following <termref def="dt-construct">constructs</termref> are classified as <term>invocation constructs</term>: the
               instructions <elcode>xsl:call-template</elcode>,
               <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, and
                  <elcode>xsl:next-match</elcode>; XPath function calls that bind to <termref def="dt-stylesheet-function">stylesheet functions</termref>; XPath dynamic
               function calls; the functions <function>accumulator-before</function> and
                  <function>accumulator-after</function>; the <code>[xsl:]use-attribute-sets</code>
               attribute. These all have the characteristic that they can cause evaluation of
               constructs that are not lexically contained within the calling
            construct.</termdef></p>

         <div2 id="named-templates">
            <head>Named Templates</head>
            
            <div3 id="declaring-named-templates">
               <head>Declaring Named Templates</head>
            
            
            <p>
               <termdef id="dt-named-template" term="named template">Templates can be invoked by
                  name. An <elcode>xsl:template</elcode> element with a <code>name</code> attribute
                  defines a <term>named template</term>.</termdef> The value of the
                  <code>name</code> attribute is an <termref def="dt-eqname">EQName</termref>, which is expanded as described in
                  <specref ref="qname"/>. If an <elcode>xsl:template</elcode> element has a
                  <code>name</code> attribute, it may, but need not, also have a <code>match</code>
               attribute. </p>
            <p>The <code>match</code>, <code>mode</code> and <code>priority</code> attributes on an
                  <elcode>xsl:template</elcode> element have no effect when the <termref def="dt-template">template</termref> is invoked by an
                  <elcode>xsl:call-template</elcode> instruction. Similarly, the <code>name</code>
                and <code>visibility</code> attributes on an
                  <elcode>xsl:template</elcode> element have no effect when the template is invoked
               by an <elcode>xsl:apply-templates</elcode> instruction.</p>
            
            <p>
               <error spec="XT" type="static" class="SE" code="0660">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a <!--<termref
                  def="dt-stylesheet">stylesheet</termref>-->
                     
                        <termref def="dt-package">package</termref> contains more than one
                        non-hidden
                     <termref def="dt-template">template</termref> with the same name and the same
                        <termref def="dt-import-precedence">import precedence</termref>, unless it
                     also contains a <termref def="dt-template">template</termref> with the same
                     name and higher <termref def="dt-import-precedence">import
                     precedence</termref>.</p>
               </error>
            </p>

            
            <p>The template name <code>xsl:initial-template</code> is specially
               recognized in that it provides a default entry point for stylesheet execution (see
                  <specref ref="initiating"/>.) </p>
            </div3>
            <div3 id="invoking-named-templates">
               <head>Invoking Named Templates</head>
               <?element xsl:call-template?>
               
               <p>An <elcode>xsl:call-template</elcode> instruction invokes a template by
                  name; it has a <rfc2119>required</rfc2119>
                  <code>name</code> attribute that identifies the template to be invoked. Unlike
                  <elcode>xsl:apply-templates</elcode>, the <elcode>xsl:call-template</elcode>
                  instruction does not change the <termref def="dt-focus">focus</termref>.</p>
               
               <p>
                  <error spec="XT" type="static" class="SE" code="0650">
                     <p>It is a <termref def="dt-static-error">static error</termref> if a <termref def="dt-package">package</termref> contains an
                        <elcode>xsl:call-template</elcode> instruction whose <code>name</code>
                        attribute does not match the <code>name</code> attribute of any <termref def="dt-named-template">named template</termref>
                        visible in the containing <termref def="dt-package">package</termref> (this
                        includes any template defined in this package, as well as templates accepted
                        from used packages whose visibility in this package is not
                        <code>hidden</code>). For more details of the process of binding the
                        called template, see <specref ref="component-references"/>.</p>
                  </error>
               </p>
               
               <p>The target <termref def="dt-template">template</termref>
                  for an <elcode>xsl:call-template</elcode> instruction is established using the
                  binding rules described in <specref ref="component-references"/>. This will always
                  be a template whose <code>name</code> attribute matches the <code>name</code>
                  attribute of the <elcode>xsl:call-template</elcode> instruction. It may be a
                  template defined in the same package that has higher <termref def="dt-import-precedence">import precedence</termref> than any other template
                  with this name, or it may be a template accepted from a used package, or (if the
                  template is not defined as <code>private</code> or <code>final</code>) it may be
                  an overriding template in a package that uses the containing package. 
                  The result of evaluating an <elcode>xsl:call-template</elcode> instruction is the
                  sequence produced by evaluating the <termref def="dt-sequence-constructor">sequence
                     constructor</termref> contained in its target <termref def="dt-template">template</termref> (see <specref ref="sequence-constructors"/>).</p>
              
              <p>Parameters for a named template can be supplied using <elcode>xsl:with-param</elcode> elements as children
              of the <elcode>xsl:call-template</elcode> instruction: see <specref ref="with-param"/>.</p>
              
            </div3>
            
            <div3 id="invoking-templates-with-extension-instructions" diff="add" at="A">
               <head>Invoking Named Templates using Extension Instructions</head>
               <p>As an alternative to the use of <elcode>xsl:call-template</elcode>, it is
               possible to invoke a named template using an instruction. For example, given
               the named template:</p>
               
               <eg><![CDATA[<xsl:template name="log:message">
    <xsl:param name="message" as="xs:string"/>
    <message>{$message}</message>
</xsl:template>]]></eg>
               
               <p>a call on the template written as:</p>
               
               <eg><![CDATA[<xsl:call-template name="log:message">
    <xsl:with-param name="message" select="'Good morning'"/>
</xsl:call-template>]]></eg>
               
               <p>can be replaced with the instruction:</p>
               
               <eg><![CDATA[<log:message message="Good morning"/>]]></eg>
               
               <p>For this to work, the name of the template must be in a non-null namespace, and
               this namespace must be designated as an extension element namespace using the
               attribute <code>[xsl:]extension-element-prefixes</code> on the instruction itself,
               or on some containing element (see <specref ref="standard-attributes"/>).</p>
               
               <p>The name of the instruction must match the name of the called template, and the
               names of its attributes (other than <termref def="dt-standard-attributes"/>)
                  are matched against the names of the template's parameters. 
                  <termref def="dt-standard-attributes">Standard attributes</termref> are recognized
               (they must be in the <termref def="dt-xslt-namespace"/>) and have their standard meaning;
               for example <code>xsl:default-collation</code> affects the evaluation of any XPath expression
               used to compute a parameter value.</p>
               
               <p>The way in which attribute values are handled depends on the type declaration
               of the template parameter:</p>
               
               <olist>
                  <item><p>If the declared type is <code>xs:boolean</code>, with no occurrence indicator,
                     then the attribute is treated
                     as an <termref def="dt-attribute-value-template"/> whose <termref def="dt-effective-value"/>
                     (after whitespace trimming) must be one of <code>yes</code>, <code>true</code>, or <code>1</code>,
                     or <code>no</code>, <code>false</code>, or <code>0</code>, in the same way as boolean
                     attributes on XSLT instructions. 
                  </p></item>
                  <item><p>If the declared type is any other atomic or union type, with no occurrence indicator, 
                     then the attribute is treated as an <termref def="dt-attribute-value-template"/>,
                     and its <termref def="dt-effective-value"/> is treated as an <code>xs:untypedAtomic</code> value,
                     which forces conversion to the required type by applying the casting rules.</p></item>
                  <item><p>In all other cases (that is, if the type of the parameter is not declared, 
                     or if it is not atomic, or if there is an occurrence
                  indicator) the attribute is treated as an XPath expression and its value is converted
                  to the required type using the <termref def="dt-coercion-rules"/>.</p></item>
               </olist>
               
               <p>If an instruction is recognized as an implicit call on a named template, then the static
                  and dynamic rules that apply are the same as if it were expanded into an 
                  <elcode>xsl:call-template</elcode> instruction. The instruction</p>
               
               <eg><![CDATA[<N A1="E1" A2="E2" A3="E3"/>]]></eg>
               
               <p>is essentially equivalent to:</p>
               
               <eg><![CDATA[<xsl:call-template name="N">
  <xsl:with-param name="A1" select="E1"/>
  <xsl:with-param name="A2" select="E2"/>
  <xsl:with-param name="A3" select="E3"/>
</xsl:call-template>]]></eg>
               
               <p>except that the interpretation of the parameter values <code>E1</code>, <code>E2</code>, and <code>E3</code>
               depends on the declared type as explained above.</p>
               
               <p>Some of the implications of this equivalence are:</p>
               
               <ulist>
                  <item><p>The binding of the instruction to a specific named template (for example, if there
                     are overriding declarations in multiple packages) follows the binding rules in
                     <specref ref="component-references"/>.</p></item>
                  <item><p>A value must be supplied for any parameter declared with <code>required="yes"</code>.</p></item>
                  <item><p>The context item for the evaluation of the extension instruction must satisfy any constraints
                  defined in an <elcode>xsl:context-item</elcode> declaration in the called template.</p></item>
                  <item><p>It is an error if the instruction has attributes that do not correspond to the names
                  of parameters declared on the named template.</p></item>
               </ulist>
                  
               <p>It is not possible to supply values for 
                  <termref def="dt-tunnel-parameter">tunnel parameters</termref>, but existing
               tunnel parameters are passed through unchanged.</p>
               
               <p>For backwards compatibility, if an external implementation of an extension instruction
               is available to the implementation, then that takes precedence over the existence of 
               a named template with a matching name.</p>
               
               <p>The XSLT namespace cannot be designated as an extension element namespace, so the template
               names <code>xsl:initial-template</code> and <code>xsl:original</code> cannot be used as
               extension instructions.</p>
            </div3>

            <div3 id="declaring-context-item">
               <head>Declaring the Context Item for a Template</head>

               <p>The <elcode>xsl:context-item</elcode> element is used as a child of
                     <elcode>xsl:template</elcode>, to declare the required type of the context
                  item. It is intended particularly for use when the containing template is called
                  using an <elcode>xsl:call-template</elcode> instruction, but it also constrains
                  the context item if the same template is invoked using
                     <elcode>xsl:apply-templates</elcode>, <elcode>xsl:apply-imports</elcode>, or
                     <elcode>xsl:next-match</elcode>. </p>


               <?element xsl:context-item?>



               <p>If the <code>as</code> attribute is present then its value must be an <xnt spec="XP40" ref="prod-xpath40-ItemType">ItemType</xnt>. If the attribute is
                  omitted this is equivalent to specifying <code>as="item()"</code>.</p>

               <p><error spec="XT" type="static" class="SE" code="3088">
                     <p>It is a <termref def="dt-static-error"/> if the <code>as</code> attribute is
                        present <error.extra>on the <elcode>xsl:context-item</elcode>
                           element</error.extra> when <code>use="absent"</code> is specified.</p>
                  </error></p>

               <p>A <termref def="dt-type-error"/> is signaled if the supplied
                  context item does not match its required type. No attempt is made to convert the
                  context item to the required type (using the coercion rules or
                  otherwise). The error code is the same as for <elcode>xsl:param</elcode>:
                     <errorref spec="XT" class="TE" code="0590"/>.</p>





               <p>If an <elcode>xsl:context-item</elcode> element is present as
                  the first child element of <elcode>xsl:template</elcode>, it defines whether the
                  template requires a context item to be supplied, and if so, what the type of the
                  context item must be. If this template is the <termref def="dt-initial-named-template"/>, then this has the effect of placing
                  constraints on the <termref def="dt-global-context-item">global context
                     item</termref> for the transformation as a whole.</p>
               <p>The <code>use</code> attribute of
                     <elcode>xsl:context-item</elcode> takes the value <code>required</code>,
                     <code>optional</code>, or <code>absent</code>.
                     The default is
                     <code>optional</code>.</p>
               <p>If the containing <elcode>xsl:template</elcode> element has no <code>name</code>
                  attribute then the only permitted value is <code>required</code>.</p>

               <ulist>
                  <item>
                     <p>If the value <code>required</code> is specified, then there must be a
                        context item. (This will automatically be the case if the template is
                        invoked using <elcode>xsl:apply-templates</elcode>,
                           <elcode>xsl:apply-imports</elcode>, or <elcode>xsl:next-match</elcode>,
                        but not if it is invoked using <elcode>xsl:call-template</elcode>.) </p>
                  </item>
                  <item>
                     <p>If the value <code>optional</code> is specified, or if the attribute is
                        omitted, or if the <elcode>xsl:context-item</elcode> element is omitted,
                        then there may or may not be a context item when the template is
                        invoked.</p>
                  </item>
                  <item>
                     <p>If the value <code>absent</code> is specified, then the contained sequence
                        constructor, and any <elcode>xsl:param</elcode> elements, are evaluated with
                        an absent focus.</p>
                     <note>
                        <p>It is not an error to call such a template with a non-absent focus; the
                           context item is simply treated as absent. This option is useful when
                           streaming, since an <elcode>xsl:call-template</elcode> instruction may
                           become streamable if the referenced template is declared to make no use
                           of the context item.</p>
                     </note>
                  </item>
               </ulist>



               <p> The processor <rfc2119>may</rfc2119>
                  signal a <termref def="dt-type-error">type error</termref> statically if the
                  required context item type is incompatible with the <code>match</code> pattern,
                  that is, if no item that satisfies the match pattern can also satisfy the required
                  context item type.</p>
               <p>The <elcode>xsl:context-item</elcode> element plays no part in
                  deciding whether and when the template rule is invoked in response to an
                     <elcode>xsl:apply-templates</elcode> instruction. </p>
               <p>
                  <error spec="XT" type="type" class="TE" code="3090">
                     <p>It is a <termref def="dt-type-error">type error</termref> if the
                           <elcode>xsl:context-item</elcode> child of <elcode>xsl:template</elcode>
                        specifies that a context item is required and none is supplied by the
                        caller, that is, if the context item is absent at the point where
                           <elcode>xsl:call-template</elcode> is evaluated.</p>
                  </error>
               </p>



            </div3>

            <div3 id="call-template-params">
               <head>Passing Parameters to Named Templates</head>

               <p>Parameters are passed to named templates using the <elcode>xsl:with-param</elcode>
                  element as a child of the <elcode>xsl:call-template</elcode> instruction.</p>

               <p>
                  <error spec="XT" type="static" class="SE" code="0680">
                     <p>In the case of <elcode>xsl:call-template</elcode>, it is a <termref def="dt-static-error">static error</termref> to pass a non-tunnel
                        parameter named <var>x</var> to a template that does not have a non-tunnel
                        <!-- see bug 10534 --><termref def="dt-template-parameter">template
                           parameter</termref> named <var>x</var>, unless the <elcode>xsl:call-template</elcode> instruction is processed with
                              <termref def="dt-xslt-10-behavior">XSLT 1.0
                           behavior</termref>.</p>
                  </error> This is not an error in the case of <elcode>xsl:apply-templates</elcode>,
                     <elcode>xsl:apply-imports</elcode>, and <elcode>xsl:next-match</elcode>; in
                  these cases the parameter is simply ignored.</p>
               <p>The optional <code>tunnel</code> attribute may be used to indicate that a
                  parameter is a <termref def="dt-tunnel-parameter">tunnel parameter</termref>. The
                  default is <code>no</code>. Tunnel parameters are described in <specref ref="tunnel-params"/>.
               </p>


               <example>
                  <head>Calling a Named Template with a Parameter</head>
                  <p>This example defines a named template for a <code>numbered-block</code> with a
                     parameter to control the format of the number.</p>
                  <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template name="numbered-block"&gt;
  &lt;xsl:param name="format"&gt;1. &lt;/xsl:param&gt;
  &lt;fo:block&gt;
    &lt;xsl:number format="{$format}"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ol//ol/li"&gt;
  &lt;xsl:call-template name="numbered-block"&gt;
    &lt;xsl:with-param name="format"&gt;a. &lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</eg>
               </example>

            </div3>
            <div3 id="tunnel-params">
               <head>Tunnel Parameters</head>
               <p>
                  <termdef id="dt-tunnel-parameter" term="tunnel parameter">A parameter passed to a
                     template may be defined as a <term>tunnel parameter</term>. Tunnel parameters
                     have the property that they are automatically passed on by the called template
                     to any further templates that it calls, and so on recursively.</termdef> Tunnel
                  parameters thus allow values to be set that are accessible during an entire phase
                  of stylesheet processing, without the need for each template that is used during
                  that phase to be aware of the parameter.</p>
               <note>
                  <p>Tunnel parameters are conceptually similar to the dynamically scoped variables found in
                     some functional programming languages (for example, early versions of LISP), where 
                     evaluating a variable reference involves searching down the dynamic call stack for
                     a matching variable name. There are two main use cases for the feature:</p>
                  
                  <olist>
                     <item><p>They provide a way to supply context information that might be needed by many
                     templates (for example, the fact that the output is to be localized for a particular language),
                     but which cannot be placed in a global variable because it might vary from one phase of processing
                     to another. Passing such information using conventional parameters is error-prone, because
                     a single <elcode>xsl:apply-templates</elcode> or <elcode>xsl:call-template</elcode> instruction
                     that neglects to pass the information on will lead to failures that are difficult to diagnose.</p>
                     
                     <p diff="add" at="A">This style of processing is even more useful when handling JSON input,
                     because with maps and arrays, there is no ancestor axis to examine properties of nodes further
                     up the tree; with a recursive descent of the tree, all context information needs to be passed down
                     explicitly. One way of handling this is for each level of processing in the tree to bind a tunnel
                     parameter to the map or array encountered at that level, which then becomes available to all
                     template rules processing data further down the tree.</p>
                     
                     </item>
                     
                     <item><p>They are particularly useful when writing a customization layer for an existing stylesheet. For
                     example, if you want to override a template rule that displays chemical formulae, you might want the
                     new rule to be parameterized so you can apply the house-style of a particular scientific journal.
                     Tunnel parameters allow you to pass this information to the overriding template rule without
                     requiring modifications to all the intermediate template rules. Again, a global variable could be used,
                     but only if the same house-style is to be used for all chemical formulae processed during a single
                     transformation.</p></item>
                  </olist>
                  
                  
               </note>
               <p>A <termref def="dt-tunnel-parameter">tunnel parameter</termref> is created by
                  using an <elcode>xsl:with-param</elcode> element that specifies
                     <code>tunnel="yes"</code>. A template that requires access to the value of a
                  tunnel parameter must declare it using an <elcode>xsl:param</elcode> element that
                  also specifies <code>tunnel="yes"</code>.</p>
               <p>On any template call using an <elcode>xsl:apply-templates</elcode>,
                     <elcode>xsl:call-template</elcode>, <elcode>xsl:apply-imports</elcode> or
                     <elcode>xsl:next-match</elcode> instruction, a set of <termref def="dt-tunnel-parameter">tunnel parameters</termref> is passed from the
                  calling template to the called template. This set consists of any parameters
                  explicitly created using <code>&lt;xsl:with-param tunnel="yes"&gt;</code>,
                  overlaid on a base set of tunnel parameters. If the
                     <elcode>xsl:apply-templates</elcode>, <elcode>xsl:call-template</elcode>,
                     <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode>
                  instruction has an <elcode>xsl:template</elcode> declaration as an ancestor
                  element in the stylesheet, then the base set consists of the tunnel parameters
                  that were passed to that template; otherwise (for example, if the instruction is
                  within a global variable declaration, an <termref def="dt-attribute-set">attribute
                     set</termref> declaration, or a <termref def="dt-stylesheet-function">stylesheet function</termref>), the base set is empty. If a parameter created
                  using <code>&lt;xsl:with-param tunnel="yes"&gt;</code> has the same <termref def="dt-expanded-qname">expanded QName</termref> as a parameter in the base
                  set, then the parameter created using <elcode>xsl:with-param</elcode> overrides
                  the parameter in the base set; otherwise, the parameter created using
                     <elcode>xsl:with-param</elcode> is added to the base set.</p>
               <p diff="chg" at="A">When a template specifies <code>&lt;xsl:param tunnel="yes"></code>,
                  this declares the intention to make use of a <termref def="dt-tunnel-parameter">tunnel
                     parameter</termref>; it does not remove the parameter from the base set
                  of tunnel parameters that is passed on to any templates called by this
                  template. [XSLT 3.0 Erratum E23, bug 30240].</p>
               <p>Two sibling <elcode>xsl:with-param</elcode> elements <rfc2119>must</rfc2119> have
                  distinct parameter names, even if one is a <termref def="dt-tunnel-parameter">tunnel parameter</termref> and the other is not. Equally, two sibling
                     <elcode>xsl:param</elcode> elements representing <termref def="dt-template-parameter">template parameters</termref>
                  <rfc2119>must</rfc2119> have distinct parameter names, even if one is a <termref def="dt-tunnel-parameter">tunnel parameter</termref> and the other is not.
                  However, the tunnel parameters that are implicitly passed in a template call
                     <rfc2119>may</rfc2119> have names that duplicate the names of non-tunnel
                  parameters that are explicitly passed on the same call.</p>
               <p>
                  <termref def="dt-tunnel-parameter">Tunnel parameters</termref> are not passed in
                  calls to <termref def="dt-stylesheet-function">stylesheet functions</termref>.</p>
               <p>All other options of <elcode>xsl:with-param</elcode> and
                     <elcode>xsl:param</elcode> are available with <termref def="dt-tunnel-parameter">tunnel parameters</termref> just as with non-tunnel
                  parameters. For example, parameters may be declared as mandatory or optional, a
                  default value may be specified, and a required type may be specified. If any
                  conversion is required from the supplied value of a tunnel parameter to the
                  required type specified in <elcode>xsl:param</elcode>, then the converted value is
                  used within the receiving template, but the value that is passed on in any further
                  template calls is the original supplied value before conversion. Equally, any
                  default value is local to the template: specifying a default value for a tunnel
                  parameter does not change the set of tunnel parameters that is passed on in
                  further template calls.</p>
               
               <p>
                  <termref def="dt-tunnel-parameter">Tunnel parameters</termref> are passed
                  unchanged through a built-in template rule (see <specref ref="built-in-rule"/>).</p>
               <p>If a tunnel parameter is declared in an
                     <elcode>xsl:param</elcode> element with the attribute
                  <code>tunnel="yes"</code>, and if the
                  parameter is <termref def="dt-explicitly-mandatory">explicitly</termref>
                  or <termref def="dt-implicitly-mandatory">implicitly</termref> mandatory,
                  then a  dynamic error occurs <errorref spec="XT" class="DE" code="0700"/> if the set of tunnel parameters passed to the template does not
                  include a parameter with a matching <termref def="dt-expanded-qname">expanded
                     QName</termref>.</p>
               <example>
                  <head>Using Tunnel Parameters</head>
                  <p>Suppose that the equations in a scientific paper are to be sequentially
                     numbered, but that the format of the number depends on the context in which the
                     equations appear. It is possible to reflect this using a rule of the form:</p>
                  <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="equation"&gt;
  &lt;xsl:param name="equation-format" select="'(1)'" tunnel="yes"/&gt;
  &lt;xsl:number level="any" format="{$equation-format}"/&gt;
&lt;/xsl:template&gt;</eg>
                  <p>At any level of processing above this level, it is possible to determine how
                     the equations will be numbered, for example:</p>
                  <eg xml:space="preserve" role="non-xml">&lt;xsl:template match="appendix"&gt;
  ...
  &lt;xsl:apply-templates&gt;
    &lt;xsl:with-param name="equation-format" select="'[i]'" tunnel="yes"/&gt;
  &lt;/xsl:apply-templates&gt;
  ...
&lt;/xsl:template&gt;</eg>
                  <p>The parameter value is passed transparently through all the intermediate layers
                     of template rules until it reaches the rule with <code>match="equation"</code>.
                     The effect is similar to using a global variable, except that the parameter can
                     take different values during different phases of the transformation.</p>
               </example>
            </div3>
         </div2>
         <div2 id="attribute-sets">
            <head>Named Attribute Sets</head>
            <?element xsl:attribute-set?>
            <p>Attribute sets generate named collections of attributes that can be used repeatedly on
               different constructed elements. The <elcode>xsl:attribute-set</elcode> declaration is
               used to declare attribute sets. The <rfc2119>required</rfc2119>
               <code>name</code> attribute specifies the name of the attribute set. The value of the
                  <code>name</code> attribute is an <code>EQName</code>, which is expanded as
               described in <specref ref="qname"/>.</p>
            <p>
               <termdef id="dt-attribute-set" term="attribute set">An <term>attribute set</term> is
                  defined as a set of <elcode>xsl:attribute-set</elcode> declarations in the same
                     <termref def="dt-package"/> that share the same <termref def="dt-expanded-qname"/>.</termdef>
            </p>
            <p>The content of the <elcode>xsl:attribute-set</elcode> element consists of zero or
               more <elcode>xsl:attribute</elcode> instructions that are evaluated to produce the
               attributes in the set.</p>

            <div3 id="using-attribute-sets">
               <head>Using Attribute Sets</head>

               <p>
                  <termref def="dt-attribute-set">Attribute sets</termref> are used by specifying a
                     <code>use-attribute-sets</code> attribute on the <elcode>xsl:element</elcode>
                  or <elcode>xsl:copy</elcode> instruction, or by specifying an
                     <code>xsl:use-attribute-sets</code> attribute on a literal result element. An
                  attribute set may be defined in terms of other attribute sets by using the
                     <code>use-attribute-sets</code> attribute on the
                     <elcode>xsl:attribute-set</elcode> element itself. The value of the
                     <code>[xsl:]use-attribute-sets</code> attribute is in each case a
                  whitespace-separated list of names of attribute sets. Each name is specified as an
                     <termref def="dt-eqname">EQName</termref>,
                  which is expanded as described in <specref ref="qname"/>.</p>

               <p>
                  <error spec="XT" type="static" class="SE" code="0710">
                     <p>It is a <termref def="dt-static-error">static error</termref> if the value
                        of the <code>use-attribute-sets</code> attribute of an
                           <elcode>xsl:copy</elcode>, <elcode>xsl:element</elcode>, or
                           <elcode>xsl:attribute-set</elcode> element, or the
                           <code>xsl:use-attribute-sets</code> attribute of a <termref def="dt-literal-result-element">literal result element</termref>, is not
                        a whitespace-separated sequence of <termref def="dt-eqname">EQNames</termref>, or if it contains an
                        EQName that does not match the <code>name</code> attribute of any
                           <elcode>xsl:attribute-set</elcode> declaration in the containing <termref def="dt-package">package</termref>.</p>
                  </error>
               </p>




               <p>An <termref def="dt-attribute-set"/> may be considered
                  as comprising a sequence of instructions, each of which is either an
                     <elcode>xsl:attribute</elcode> instruction or an <termref def="dt-attribute-set-invocation"/>. Starting with the declarations making up
                  an attribute set, this sequence of instructions can be generated by the following
                  rules: </p>

               <olist>
                  <item>
                     <p>The relevant attribute set <termref def="dt-declaration">declarations</termref> (that is, all declarations of attribute sets
                        within a package sharing the same <termref def="dt-expanded-qname"/>) are
                        considered in order: first in increasing order of <termref def="dt-import-precedence"/>, and within each precedence, in <termref def="dt-declaration-order"/>. </p>
                  </item>
                  <item>
                     <p>Each declaration is expanded to a sequence of instructions as follows.
                        First, one <termref def="dt-attribute-set-invocation"/> is generated for
                        each EQName present in the <code>use-attribute-sets</code> attribute, if
                        present, retaining the order in which the EQNames appear. This is followed
                        by the sequence of contained <elcode>xsl:attribute</elcode> instructions, in
                        order. </p>
                     <p><termdef id="dt-attribute-set-invocation" term="attribute set invocation">An
                              <term>attribute set invocation</term> is a pseudo-instruction
                           corresponding to a single EQName appearing within an
                              <code>[xsl:]use-attribute-sets</code> attribute; the effect of the
                           pseudo-instruction is to cause the referenced <termref def="dt-attribute-set"/> to be evaluated.</termdef></p>
                  </item>
               </olist>

               <p>Similarly, an <code>[xsl:]use-attribute-sets</code>
                  attribute of an <elcode>xsl:copy</elcode>, <elcode>xsl:element</elcode>, or
                     <elcode>xsl:attribute-set</elcode> element, or of a literal result element, is
                  expanded to a sequence of <termref def="dt-attribute-set-invocation">attribute set
                     invocations</termref>, one for each EQName in order. </p>

               <p>An <termref def="dt-attribute-set"/> is a named
                     <termref def="dt-component"/>, and the binding of QNames appearing in an
                     <termref def="dt-attribute-set-invocation"/> to attribute set components
                  follows the rules in <specref ref="component-references"/>. </p>

               <p>The following two (mutually recursive) rules define how
                  an <code>[xsl:]use-attribute-set</code> attribute is expanded:</p>

               <olist>
                  <item>
                     <p>An <termref def="dt-attribute-set"/> is evaluated by evaluating each of the
                        contained <termref def="dt-attribute-set-invocation">attribute set
                           invocations</termref> and <elcode>xsl:attribute</elcode> instructions in
                        order, to deliver a sequence of attribute nodes. </p>
                  </item>
                  <item>
                     <p>An <termref def="dt-attribute-set-invocation"/> is evaluated by evaluating
                        the <termref def="dt-attribute-set"/> to which it is bound, as determined by
                        the rules in <specref ref="component-references"/>. </p>
                  </item>
               </olist>

               <p>For rules regarding cycles in attribute set
                  declarations, see <specref ref="circularity"/>.</p>

               <note>
                  <p>The effect of an <termref def="dt-attribute-set-invocation"/> on the dynamic
                     context is the same as the effect of an <elcode>xsl:call-template</elcode>
                     instruction. In particular, it does not change the <termref def="dt-focus"/>.
                     Although attribute sets are often defined with fixed values, or with values
                     that depend only on global variables, it is possible to define an attribute set
                     in such a way that the values of the constructed attributes are dependent on
                     the context item.</p>
               </note>

               <note>
                  <p>In all cases the result of evaluating an <termref def="dt-attribute-set"/> is
                     subsequently used to create the attributes of an element node, using the rules
                     in <specref ref="constructing-complex-content"/>. The effect of those rules is
                     that when the result of evaluating the attribute set contains attributes with
                     duplicate names, the last duplicate wins. The optimization rules allow a
                     processor to avoid evaluating or validating an attribute if it is able to
                     determine that the attribute will subsequently be discarded as a duplicate.
                  </p>
               </note>

            </div3>
            

            <div3 id="visibility-of-attribute-sets">
               <head>Visibility of Attribute Sets</head>


               <p>The <code>visibility</code> attribute determines the
                  potential visibility of the attribute set in packages other than the containing
                  package. If the <code>visibility</code> attribute is present on any of the
                     <elcode>xsl:attribute-set</elcode> declarations making up the definition of an
                     <termref def="dt-attribute-set"/> (that is, all declarations within the same
                  package sharing the same name), then it <rfc2119>must</rfc2119> be present, with
                  the same value, on every <elcode>xsl:attribute-set</elcode> declaration making up
                  the definition of that <termref def="dt-attribute-set"/>.</p>

               <p>If the <code>visibility</code> attribute is present with the
                  value <code>abstract</code> then there must be no <elcode>xsl:attribute</elcode>
                  children and no <code>use-attribute-sets</code>
                     attribute.</p>

            </div3>

            <div3 id="streamability-of-attribute-sets">
               <head>Streamability of Attribute Sets</head>
               <p>An <termref def="dt-attribute-set">attribute set</termref> may be designated as
                  streamable by including the attribute <code>streamable="yes"</code> on each
                     <elcode>xsl:attribute-set</elcode> declaration making up the attribute set. If
                  any <elcode>xsl:attribute-set</elcode> declaration for an attribute set has the
                  attribute <code>streamable="yes"</code>, then every
                     <elcode>xsl:attribute-set</elcode> declaration for that attribute set
                     <rfc2119>must</rfc2119> have the attribute <code>streamable="yes"</code>.</p>

               <p>An <termref def="dt-attribute-set">attribute set</termref> is
                     <termref def="dt-guaranteed-streamable"/> if all the following conditions are
                  satisfied:</p>

               <olist>
                  <item>
                     <p>Every <elcode>xsl:attribute-set</elcode>
                        declaration for the attribute set has the attribute
                           <code>streamable="yes"</code>.</p>
                  </item>
                  <item>
                     <p>Every <elcode>xsl:attribute-set</elcode> declaration for the attribute set
                        is <termref def="dt-grounded"/> and <termref def="dt-motionless"/> according to the analysis in <specref ref="classifying-attribute-sets"/>.</p>
                  </item>
               </olist>

               <p>Specifying <code>streamable="yes"</code> on an
                     <elcode>xsl:attribute-set</elcode> element declares an intent that the
                  attribute set should be streamable, either
                     because it is <termref def="dt-guaranteed-streamable"/>, or because it takes
                     advantage of streamability extensions offered by a particular
                     processor. The consequences of declaring the attribute set to be
                  streamable when it is not in fact guaranteed streamable depend on the conformance
                  level of the processor, and are explained in <specref ref="streamability-guarantees"/>.</p>

               <p><error spec="XT" type="static" class="SE" code="0730">
                     <p>If an <elcode>xsl:attribute</elcode> set element specifies
                           <code>streamable="yes"</code> then every attribute set referenced in its
                           <code>use-attribute-sets</code> attribute (if present) must also specify
                           <code>streamable="yes"</code>.</p>
                  </error></p>

               <note>
                  <p>It is common for attribute sets to create attributes with constant values, and
                     such attribute sets will always be grounded and motionless and therefore streamable.
                     Although such cases are fairly simple for a processor to detect, references to
                     attribute sets are not guaranteed streamable unless the attribute set is
                     declared with the attribute <code>streamable="yes"</code>, which should
                     therefore be used if interoperable streaming is required.</p>
               </note>
            </div3>

            <div3 id="evaluating-attribute-sets">
               <head>Evaluating Attribute Sets</head>
               <p>Attribute sets are evaluated as follows:</p>
               <ulist>
                  <item>
                     <p>The <elcode>xsl:copy</elcode> and <elcode>xsl:element</elcode> instructions
                        have a <code>use-attribute-sets</code> attribute. The sequence of attribute
                        nodes produced by evaluating this attribute is prepended to the sequence
                        produced by evaluating the <termref def="dt-sequence-constructor">sequence
                           constructor</termref> contained within the instruction.</p>
                  </item>
                  <item>
                     <p>
                        <termref def="dt-literal-result-element">Literal result elements</termref>
                        allow an <code>xsl:use-attribute-sets</code> attribute, which is evaluated
                        in the same way as the <code>use-attribute-sets</code> attribute of
                           <elcode>xsl:element</elcode> and <elcode>xsl:copy</elcode>. The sequence
                        of attribute nodes produced by evaluating this attribute is prepended to the
                        sequence of attribute nodes produced by evaluating the attributes of the
                        literal result element, which in turn is prepended to the sequence produced
                        by evaluating the <termref def="dt-sequence-constructor">sequence
                           constructor</termref> contained with the literal result element.</p>
                  </item>
               </ulist>

               <p>The <elcode>xsl:attribute</elcode> instructions are evaluated using the same
                     <termref def="dt-focus">focus</termref> as is used for evaluating the 
                  <termref def="dt-sequence-constructor"/> contained by the
                  element that is the parent of the <code>[xsl:]use-attribute-sets</code> attribute forming
                  the initial input to the algorithm. However, the static context for the evaluation
                  depends on the position of the <elcode>xsl:attribute</elcode> instruction in the
                  stylesheet: thus, only local variables declared within an
                     <elcode>xsl:attribute</elcode> instruction, and global variables, are
                  visible.</p>
               <note><p>The above rule means that for an <elcode>xsl:copy</elcode>
               element with a <code>select</code> attribute, the focus for evaluating any referenced attribute
               sets is the node selected by the <code>select</code> attribute, rather than the context item of 
                  the <elcode>xsl:copy</elcode> instruction.</p></note>
               <p>The set of attribute nodes produced by expanding
                     <code>xsl:use-attribute-sets</code> may include several attributes with the
                  same name. When the attributes are added to an element node, only the last of the
                  duplicates will take effect.</p>
               <p>The way in which each instruction uses the results of expanding the
                     <code>[xsl:]use-attribute-sets</code> attribute is described in the
                  specification for the relevant instruction: see <specref ref="literal-result-element"/>, <specref ref="xsl-element"/>, and <specref ref="copying"/>.</p>

               <p>The result of evaluating an attribute set is a sequence of attribute nodes.
                  Evaluating the same attribute set more than once can produce different results,
                  because although an attribute set does not have parameters, it may contain
                  expressions or instructions whose value depends on the evaluation context.</p>

               <p>Each attribute node produced by expanding an attribute set has a <termref def="dt-type-annotation"/> determined by the rules for the
                     <elcode>xsl:attribute</elcode> instruction that created the attribute node: see
                     <specref ref="annotation-for-constructed-attribute"/>. These type annotations
                  may be preserved, stripped, or replaced as determined by the rules for the
                  instruction that creates the element in which the attributes are used.</p>

            </div3>
            <div3 id="attribute-sets-examples">
               <head>Attribute Sets: Examples</head>
               <example>
                  <head>A Simple Attribute Set</head>
                  <p>The following example creates a named <termref def="dt-attribute-set">attribute
                        set</termref>
                     <code>title-style</code> and uses it in a <termref def="dt-template-rule">template rule</termref>.</p>
                  <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template match="chapter/heading"&gt;
  &lt;fo:block font-stretch="condensed" xsl:use-attribute-sets="title-style"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:attribute-set name="title-style"&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;</eg>
               </example>
               <example>
                  <head>Overriding Attributes in an Attribute Set</head>
                  <p>The following example creates a named attribute set <code>base-style</code> and
                     uses it in a template rule with multiple specifications of the attributes:</p>
                  <glist>
                     <gitem>
                        <label>font-family</label>
                        <def>
                           <p>is specified only in the attribute set</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label>font-size</label>
                        <def>
                           <p>is specified in the attribute set, is specified on the literal result
                              element, and in an <elcode>xsl:attribute</elcode> instruction</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label>font-style</label>
                        <def>
                           <p>is specified in the attribute set, and on the literal result
                              element</p>
                        </def>
                     </gitem>
                     <gitem>
                        <label>font-weight</label>
                        <def>
                           <p>is specified in the attribute set, and in an
                                 <elcode>xsl:attribute</elcode> instruction</p>
                        </def>
                     </gitem>
                  </glist>
                  <!--
<table cellspacing="5">
<tbody>
<tr><td valign="top"><code>font-family</code></td>is specified only in the attribute set<td></td></tr>
 <tr><td valign="top"><code>font-size</code></td><td>is specified in the attribute set, is specified
             on the literal result element, and in an
             <elcode>xsl:attribute</elcode> element</td></tr>
 <tr><td valign="top"><code>font-style</code></td><td>is specified in the attribute set, and on
             the literal result element</td></tr>
 <tr><td valign="top"><code>font-weight</code></td><td>is specified in the attribute set, and in an
             <elcode>xsl:attribute</elcode> element</td></tr>
</tbody>             
</table>-->
                  <p>Stylesheet fragment:</p>
                  <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:attribute-set name="base-style"&gt;
  &lt;xsl:attribute name="font-family"&gt;Univers&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-size"&gt;10pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-style"&gt;normal&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;normal&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;

&lt;xsl:template match="o"&gt;
  &lt;fo:block xsl:use-attribute-sets="base-style"
            font-size="12pt"
            font-style="italic"&gt;
    &lt;xsl:attribute name="font-size"&gt;14pt&lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg>
                  <p>Result:</p>
                  <eg xml:space="preserve" role="non-xml">&lt;fo:block font-family="Univers"
          font-size="14pt"
          font-style="italic"
          font-weight="bold"&gt;
...
&lt;/fo:block&gt;
</eg>
               </example>
            </div3>
         
            
         </div2>
         <div2 id="stylesheet-functions">
            <head>Stylesheet Functions</head>
            <p>
               <termdef id="dt-stylesheet-function" term="stylesheet function">An
                     <elcode>xsl:function</elcode> declaration declares the name, parameters, and
                  implementation of a <term>stylesheet function</term> that can be called from any
                  XPath <termref def="dt-expression">expression</termref> within the <termref def="dt-stylesheet">stylesheet</termref>
                  (subject to visibility
                  rules).</termdef>
            </p>
            <?element xsl:function?>
            <p>The <elcode>xsl:function</elcode> declaration defines a <termref def="dt-stylesheet-function">stylesheet function</termref> that can be called from
               any XPath <termref def="dt-expression">expression</termref> used in the <termref def="dt-stylesheet">stylesheet</termref> (including an XPath expression used
               within a predicate in a <termref def="dt-pattern">pattern</termref>). The
                  <code>name</code> attribute specifies the name of the function. The value of the
                  <code>name</code> attribute is an <termref def="dt-eqname">EQName</termref>, which is expanded as described in
                  <specref ref="qname"/>.</p>
            
            <p diff="add" at="A">More strictly, the <elcode>xsl:function</elcode> declaration declares a set of 
               <termref def="dt-stylesheet-function">stylesheet functions</termref> having the same name but (potentially)
            different <termref def="dt-arity"/>: see <specref ref="xsl-function-name"/> below.</p>
            <p>An <elcode>xsl:function</elcode> declaration can only appear as a <termref def="dt-top-level"/> element in a stylesheet module.</p>

            <p>The content of the <elcode>xsl:function</elcode> element consists of zero or more
                  <elcode>xsl:param</elcode> elements that specify the formal arguments of the
               function, followed by a <termref def="dt-sequence-constructor">sequence
                  constructor</termref> that defines the value to be returned by the function.</p>

            <div3 id="xsl-function-name">
               <head>Function Name and Arity</head>

               <p>The name of the function is given by the <code>name</code>
                  attribute; the arguments are defined by child <elcode>xsl:param</elcode> elements;
                  and the return type is defined by the <code>as</code> attribute. Together these
                  definitions constitute the <emph>function signature</emph>.</p>
               
               <p>
                  <error spec="XT" type="static" class="SE" code="0740">
                     <p>It is a <termref def="dt-static-error">static error</termref> if a <termref def="dt-stylesheet-function">stylesheet function</termref> has a name
                        that is in no namespace.</p>
                  </error></p>
               
               <note>
                  <p>To prevent the namespace declaration used for the function name appearing in
                     the result document, use the <code>exclude-result-prefixes</code> attribute on
                     the <elcode>xsl:stylesheet</elcode> element: see <specref ref="lre-namespaces"/>.</p>
                  <p>The name of the function must not be in a <termref def="dt-reserved-namespace">reserved namespace</termref>: <errorref spec="XT" class="SE" code="0080"/>
                  </p>
               </note>
               
               
               <p diff="chg" at="A">
                  <termdef id="dt-arity" term="arity">The <term>arity</term> of a stylesheet
                     function is the number of arguments that must be supplied when calling
                     the function.</termdef></p>

               <p diff="add" at="A">A function parameter may be declared to be optional by specifying <code>required="no"</code>
               on the <elcode>xsl:param</elcode> element. An optional parameter <rfc2119>must</rfc2119> have
               a <code>select</code> attribute or a contained sequence constructor to define its default
               value. A function parameter <rfc2119>must not</rfc2119> be declared optional unless all
               subsequent function parameters are also declared optional: that is, the sequence of <elcode>xsl:param</elcode>
               elements comprises a sequence of required parameters followed by a sequence of optional parameters.</p>
               
               <p diff="add" at="A">The <elcode>xsl:function</elcode> declaration declares a set of 
                  <termref def="dt-stylesheet-function">stylesheet functions</termref> having the same name,
               and with arities in the range <var>M</var> to <var>N</var> inclusive, where <var>M</var>
               is the number of required parameters and <var>N</var> is the total number of parameters
               (required or optional).</p>
               
               <p diff="add" at="A">The body of the <elcode>xsl:function</elcode> declaration (if the <code>visibility</code>
               is not <code>abstract</code>) defines the implementation of the function with maximum arity
               <var>N</var>, that is the function with all arguments supplied. The implementation of
               a function with lower arity <var>R</var> is defined as the result of invoking the function with
               arity <var>R+1</var> with the first <var>R</var> arguments supplied unchanged,
               and the additional argument obtained by evaluating the <code>select</code> expression
               or the contained sequence constructor of the corresponding <elcode>xsl:param</elcode>
               element.</p>
               
               <p diff="add" at="A">For example, the following <elcode>xsl:function</elcode> declaration
               declares two functions, both named <code>f:compare</code>, one having arity 2 and one having
               arity 3. The effect of calling <code>f:compare($a, $b)</code> is the same as the effect
               of calling <code>f:compare($a, $b, map{"order":"ascending"})</code>.</p>
               
               <eg><![CDATA[
<xsl:function name="f:compare" as="xs:boolean">
  <xsl:param name="arg1" as="xs:double"/>
  <xsl:param name="arg2" as="xs:double"/>
  <xsl:param name="options" as="map(*)" required="no" select="map{'order':'ascending'}"/>
  <xsl:if test="$options?order = 'descending'" then="$arg1 gt $arg2" else="$arg2 gt $arg1"/>
</xsl:function>]]></eg>

              
               

               <note>
                  <p>Functions are not polymorphic. Although the XPath function call mechanism
                     allows two functions to have the same name and different <termref def="dt-arity">arity</termref>, 
                     it does not allow them to be distinguished
                     by the types of their arguments.</p>
               </note>
            </div3>
            <div3 id="function-arguments">
               <head>Arguments</head>
               <p>The <elcode>xsl:param</elcode> elements define the formal parameters to the
                  function. These are interpreted positionally. When the function is called using a
                  function call in an XPath <termref def="dt-expression">expression</termref>, the
                  first argument supplied is assigned to the first <elcode>xsl:param</elcode>
                  element, the second argument supplied is assigned to the second
                     <elcode>xsl:param</elcode> element, and so on.</p>
               
               <p diff="del" at="A">Because arguments to a stylesheet function call <rfc2119>must</rfc2119> all
                  be specified, the <elcode>xsl:param</elcode> elements within an
                  <elcode>xsl:function</elcode> element <rfc2119>must not</rfc2119> specify
                  a default value: this means they <rfc2119>must</rfc2119> be empty, and
                  <rfc2119>must not</rfc2119> have a <code>select</code> attribute.</p>
               
              
               <p>
                  <error spec="XT" type="static" class="SE" code="0760">
                     <p>It is a static error if an <elcode>xsl:param</elcode> child of
                        an <elcode>xsl:function</elcode> element has either a <code>select</code>
                        attribute or non-empty content<phrase diff="add" at="A">, unless it
                        specifies <code>required="no"</code></phrase></p>
                  </error>
               </p>
               
               <p diff="add" at="A">
                  <error spec="XT" type="static" class="SE" code="0761">
                     <p>It is a static error if an <elcode>xsl:param</elcode> child of
                        an <elcode>xsl:function</elcode> element specifies
                     <code>required="no"</code>, unless all following-sibling
                        <elcode>xsl:param</elcode> elements also specify <code>required="no"</code>.</p>
                  </error>
               </p>


               <p>The <code>as</code> attribute of the <elcode>xsl:param</elcode> element defines
                  the required type of the parameter. The rules for converting the values of the
                  actual arguments supplied in the function call to the types required by each
                     <elcode>xsl:param</elcode> element, and the
                     errors that can occur, are defined in <bibref ref="xpath-30"/>. The
                  rules that apply are those for the case where <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is set to <code>false</code>.</p>
               
               <p>If the <code>as</code> attribute is omitted, no conversion takes place and any
                  value is accepted.</p>
               
               <note diff="add" at="A"><p>When considering function overriding, dynamic function calls,
               and details such as the <code>function-lookup</code> function, it is useful to think
               of an <elcode>xsl:function</elcode> declaration with optional parameters as a syntactic 
                  short-cut for a set of <elcode>xsl:function</elcode> declarations of varying arity, each
               of which calls the function with next-higher arity, supplying the default value of the parameter
               explicitly in the function call.</p></note>

            </div3>

            <div3 id="function-result">
               <head>Function Result</head>

               <p>The result of the function<phrase diff="add" at="A">, if all arguments are supplied,</phrase> 
                  is the result of evaluating the contained <termref def="dt-sequence-constructor"/>.</p>
               
               <p diff="add" at="A">If a reduced-arity form of the function is invoked by omitting optional arguments, then
               the result of the function is obtained by evaluating the sequence constructor after binding the
               omitted arguments to their default values, which are obtained by evaluating the <code>select</code>
               attribute or sequence constructor of the relevant <elcode>xsl:param</elcode> element, as
               described in <specref ref="default-values-of-parameters"/>.</p>

               <p>Within the sequence constructor, the <termref def="dt-focus">focus</termref> is
                  initially <termref def="dt-absent">absent</termref>; this means that any attempt
                  to reference the context item, context position, or context size is a <termref def="dt-dynamic-error">
                     dynamic error</termref>. (See <xerrorref spec="XP40" class="DY" code="0002"/>.)</p>

               <p>It is not possible within the body of the <termref def="dt-stylesheet-function">stylesheet function</termref> to access the values of local variables that
                  were in scope in the place where the function call was written. Global variables,
                  however, remain available.</p>

               <p>The optional <code>as</code> attribute indicates the <termref def="dt-required-type">required type</termref> of the result of the function.
                  The value of the <code>as</code> attribute is a
                  <termref def="dt-sequence-type"/>.</p>
               <p>
                  <error spec="XT" type="type" class="TE" code="0780">
                     <p>If the <code>as</code> attribute <error.extra>of
                              <elcode>xsl:function</elcode>
                        </error.extra> is specified, then the result evaluated by the <termref def="dt-sequence-constructor">sequence constructor</termref> (see
                           <specref ref="sequence-constructors"/>) is converted to the required
                        type, using the <termref def="dt-coercion-rules"/>. It is a <termref def="dt-type-error">type
                           error</termref> if this conversion fails.</p>
                  </error> If the <code>as</code> attribute is omitted, the calculated result is
                  used as supplied, and no conversion takes place.</p>



            </div3>
            <div3 id="function-visibility-and-overriding">
               <head>Visibility and Overriding of Functions</head>

               <p>If the <code>visibility</code> attribute is present with the
                  value <code>abstract</code> then the <termref def="dt-sequence-constructor"/>
                  defining the function body <rfc2119>must</rfc2119> be empty.</p>

               <p>The XPath specification states that the function that is executed as the result of
                  a function call is identified by looking in the in-scope functions of the static
                  context for a function whose name and <termref def="dt-arity">arity</termref>
                  matches the name and number of arguments in the function call. In XSLT 3.0, final determination of the function to be called cannot be
                     made until all packages have been assembled: see <specref ref="component-references"/>.</p>

               <p>An <elcode>xsl:function</elcode> declaration defines <phrase diff="chg" at="A">one or more</phrase> 
                  <termref def="dt-stylesheet-function">stylesheet functions</termref>, <phrase diff="add" at="A">each of</phrase> which forms a
                     <termref def="dt-component"/> in its containing <termref def="dt-package"/>,
                  unless </p>
               <ulist>
                  <item>
                     <p>there is another <termref def="dt-stylesheet-function">stylesheet
                           function</termref> with the same name and <termref def="dt-arity">arity</termref>, and higher <termref def="dt-import-precedence">import
                           precedence</termref>, or</p>
                  </item>
                  <item>
                     <p>the <code>override-extension-function</code> or <code>override</code>
                        attribute has the value <code>no</code> and there is already a function with
                        the same name and <termref def="dt-arity">arity</termref> in the in-scope
                        functions.</p>
                  </item>
               </ulist>
               
               <note diff="add" at="A"><p>Note that overriding of functions works independently for each <termref def="dt-arity">arity</termref>.
               An <elcode>xsl:function</elcode> declaration <code>f:x</code> with two mandatory parameters might override the <code>f:x#2</code>
                  function declared by another lower-precedence <elcode>xsl:function</elcode> element having three optional
                  parameters, without overriding
                  the <code>f:x#1</code> or <code>f:x#3</code> functions also declared by that lower-precedence declaration. 
                  A call on <code>f:x(1)</code> with
               a single argument then takes the default for the second argument from the overridden <elcode>xsl:function</elcode>
               declaration (say this is 2), and makes a call on <code>f:x(1, 2)</code>, which has the effect of invoking the 
                  overriding declaration of <code>f:x#2</code>.</p></note>


               <p>The <termref def="dt-visibility">visibility</termref> of the
                  function in other packages depends on the value of the <code>visibility</code>
                  attribute and other factors, as described in <specref ref="packages"/>.</p>

               <p>The optional <code>override-extension-function</code> attribute defines what
                  happens if this function has the same name and <termref def="dt-arity">arity</termref> as a function provided by the implementer or made available in
                  the static context using an implementation-defined mechanism. If the <code>override-extension-function</code> attribute
                  has the value <code>yes</code>, then this function is used in preference; if it
                  has the value <code>no</code>, then the other function is used in preference. The
                  default value is <code>yes</code>.</p>
               <note>
                  <p>Specifying <code>override-extension-function="yes"</code> ensures
                     interoperable behavior: the same code will execute with all processors.
                     Specifying <code>override-extension-function="no"</code> is useful when
                     writing a fallback implementation of a function that is available with some
                     processors but not others: it allows the vendor’s implementation of the
                     function (or a user’s implementation written as an extension function)
                     to be used in preference to the stylesheet implementation, which is useful when
                     the extension function is more efficient.</p>
                  <p>The <code>override-extension-function</code> attribute does <emph>not</emph>
                     affect the rules for deciding which of several <termref def="dt-stylesheet-function">stylesheet functions</termref> with the same
                     name and <termref def="dt-arity">arity</termref> takes precedence.</p>
               </note>
               <p>The <code>override</code> attribute is a <termref def="dt-deprecated"/> synonym of <code>override-extension-function</code>,
                  retained for compatibility with XSLT 2.0. If both attributes are present then they
                     <rfc2119>must</rfc2119> have the same value.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0770">
                     <p>It is a <termref def="dt-static-error">static error</termref> for a <termref def="dt-package">package</termref> to
                        contain <phrase diff="chg" at="A"><elcode>xsl:function</elcode>
                           declarations declaring two or more functions</phrase> with the same <termref def="dt-expanded-qname">expanded QName</termref>, 
                        the same <termref def="dt-arity">arity</termref>, and the same <termref def="dt-import-precedence">import
                           precedence</termref>, unless there is another <elcode>xsl:function</elcode> declaration with the same
                           <termref def="dt-expanded-qname">expanded QName</termref> and arity, and
                        a higher import precedence.</p>
                  </error>
               </p>
               <p>When the <elcode>xsl:function</elcode> declaration appears as a
                  child of <elcode>xsl:override</elcode>, there <rfc2119>must</rfc2119> be a
                  stylesheet function with the same <termref def="dt-expanded-qname">expanded
                     QName</termref> and <termref def="dt-arity">arity</termref> in the <termref def="dt-package">package</termref> referenced by the containing
                     <elcode>xsl:use-package</elcode> element; the <termref def="dt-visibility">visibility</termref> of that function must be <code>public</code> or
                     <code>abstract</code>, and the overriding and overridden functions
                     <rfc2119>must</rfc2119> have the same argument types and result type.</p>
               
               <note diff="add" at="A"><p>For the interpretation of this rule in the presence of optional parameters, see
               <specref ref="package-overriding-components"/>.</p></note>

            </div3>
            <div3 id="streamability-of-stylesheet-functions">
               <head>Streamability of Stylesheet Functions</head>

               <p>The <code>streamability</code> attribute of <elcode>xsl:function</elcode> is used
                  to assign the function to one of a number of <termref def="dt-streamability-category">streamability categories</termref>. The various
                  categories, and their effect on the streamability of function calls, are described
                  in <specref ref="streamable-stylesheet-functions"/>.</p>

               <p>The streamability category of a function characterizes the way in which the
                  function processes any streamed nodes supplied in the first argument to the
                  function. (In general, streamed nodes cannot be supplied in other arguments,
                  unless they are atomized by the <termref def="dt-coercion-rules"/>.)
                  The <code>streamability</code> attribute is therefore not applicable unless the
                  function takes at least one argument.</p>

               <p><error spec="XT" type="dynamic" class="SE" code="3155">
                     <p>It is a static error if an <elcode>xsl:function</elcode> element with no
                           <elcode>xsl:param</elcode> children has a <code>streamability</code>
                        attribute with any value other than <code>unclassified</code>.</p>
                  </error></p>

            </div3>
            <div3 id="function-lookup">
               <head>Dynamic Access to Functions</head>

               <p>If a <termref def="dt-stylesheet-function">stylesheet
                     function</termref> with a particular <termref def="dt-expanded-qname">expanded
                     QName</termref> and <termref def="dt-arity">arity</termref> exists in the
                  stylesheet, then a call to the <xfunction>function-lookup</xfunction> function
                  supplying that name and arity will return the function as a value. This applies
                  only if the static context for the call on <xfunction>function-lookup</xfunction>
                  includes the stylesheet function, which implies that the function is visible in
                  the containing package.</p>

               <p>The <function>function-available</function> function, when
                  called with a particular <termref def="dt-expanded-qname">expanded QName</termref>
                  and <termref def="dt-arity">arity</termref>, returns true if and only if a call on
                     <xfunction>function-lookup</xfunction> with the same arguments, in the same
                  static context, would return a function item.</p>

               <note>
                  <p>For legacy reasons there is also a single-argument version of
                        <function>function-available</function>, which returns true if there is a
                     function with the given name regardless of arity.</p>
               </note>

               <p>The standard rules for
                     <xfunction>function-lookup</xfunction> require that if the supplied name and
                  arity identify a context-dependent function such as <xfunction>name#0</xfunction>
                  or <xfunction>lang#1</xfunction> (call it <var>F</var>), then the returned
                  function value includes in its closure a copy of the static and dynamic context of
                  the call to <xfunction>function-lookup</xfunction>, and the context item for a
                  subsequent dynamic call of <var>F</var> is taken from this saved context. In the
                  case where the context item is a node in a streamed input document, saving the
                  node is not possible. In this case, therefore, the context is saved with an absent
                  focus, so the call on <var>F</var> will fail with a dynamic error saying that
                  there is no context item available.</p>



            </div3>
            <div3 id="function-determinism">
               <head>Determinism of Functions</head>

               <p>Stylesheet functions have been designed to be largely deterministic: unless a
                  stylesheet function calls some <termref def="dt-extension-function">extension
                     function</termref> which is itself nondeterministic, the function will return
                  results that depend only on the supplied arguments. This property (coupled with
                  the fact that the effect of calling extension functions is entirely <termref def="dt-implementation-dependent"/>) enables a processor to implement various
                  optimizations, such as removing invariant function calls from the body of a loop,
                  or combining common subexpressions.</p>

               <p>One exception to the intrinsic determinism of stylesheet functions arises because
                  constructed nodes have distinct identity. This means that when a function that
                  creates a new node is called, two calls on the function will return nodes that can
                  be distinguished: for example, with such a function, <code>f:make-node() is
                     f:make-node()</code> will return false.</p>

               <p>Three classes of functions can be identified:</p>

               <olist>
                  <item>
                     <p><xtermref spec="FO40" ref="dt-deterministic">Deterministic</xtermref>
                        functions: as the term is defined in <bibref ref="xpath-functions-31"/>,
                        these offer a guarantee that when a function is called repeatedly with the
                        same arguments, it returns the same results. A classic example is the
                           <xfunction>doc</xfunction> function, which offers the guarantee that
                           <code>doc($X) is doc($X)</code>: that is, two calls supplying the same
                        URI return the same node.</p>
                  </item>
                  <item>
                     <p>Proactive functions: these offer the guarantee that each invocation of the
                        function causes a single execution of the function body, or behaves exactly
                        as if it did so. In particular this means that when the function creates new
                        nodes, it creates new nodes on each invocation. By default, <termref def="dt-stylesheet-function">stylesheet functions</termref> are
                        proactive.</p>
                  </item>
                  <item>
                     <p>Elidable functions: these offer no guarantee of determinism, and no
                        guarantee of proactive evaluation. If the function creates new nodes, then
                        two calls on the function with the same arguments may or may not return the
                        same nodes, at the implementation’s discretion. Examples of elidable functions include
                        the <bibref ref="xpath-functions-31"/> functions
                           <xfunction>analyze-string</xfunction> and
                           <function>json-to-xml</function>.</p>
                  </item>
               </olist>

               <p>The <code>new-each-time</code> attribute of <elcode>xsl:function</elcode> allows a
                  stylesheet function to be assigned to one of these three categories. The value
                     <code>new-each-time="no"</code> means the function is deterministic; the value
                     <code>new-each-time="yes"</code> means it is proactive; and the value
                     <code>new-each-time="maybe"</code> means it is elidable.</p>

               <p>The definition of <xtermref spec="FO40" ref="dt-deterministic">determinism</xtermref> requires a definition of what it means for a function
                  to be called twice with “the same” arguments and to return “the same” result. This
                  is defined in <bibref ref="xpath-functions-31"/>, specifically by the definition
                  of the term <xtermref spec="FO40" ref="dt-identical">identical</xtermref>.</p>

               <p>Processors have considerable freedom to optimize execution of stylesheets, and of
                  function calls in particular, but the strategies that are adopted must respect the
                  specification as to whether functions are deterministic, proactive, or elidable.
                  For example, consider a function call that appears within an
                     <elcode>xsl:for-each</elcode> instruction, where the supplied arguments to the
                  function do not depend on the context item or on any variables declared within the
                     <elcode>xsl:for-each</elcode> instruction. A possible optimization is to
                  execute the function call only once, rather than executing it repeatedly each time
                  round the loop (this is sometimes called loop-lifting). This optimization is safe
                  when the function is deterministic or elidable, but it requires great care if the
                  function is proactive; it is permitted only if the processor is able to determine
                  that the results of stylesheet execution are equivalent to the results that would
                  be obtained if the optimization had not been performed. Declaring a function call
                  to be elidable (by writing <code>new-each-time="maybe"</code>) makes it more
                  likely that an implementation will be able to apply this optimization, as well as
                  other optimizations such as caching or memoization.</p>





            </div3>

            <div3 id="memoization">
               <head>Memoization</head>

               <p>The <code>cache</code> attribute is an optimization hint which the processor can
                  use or ignore at its discretion; however it <rfc2119>should</rfc2119> be taken
                  seriously, because it may make a difference to whether execution of a stylesheet
                  is practically feasible or not.</p>

               <p>The default value is <code>cache="no".</code></p>

               <p>The value <code>cache="yes"</code> encourages the processor to retain memory of
                     previous calls of this function
                  during the same transformation and to reuse results from this memory whenever
                  possible. The default value <code>cache="no"</code> encourages the
                  processor not to retain memory of previous calls.</p>

               <p>In all cases the results must respect the semantics. If a function is proactive
                     (<code>new-each-time="yes"</code>) then caching of results may be infeasible,
                  especially if the function result can include nodes; but it is not an error to
                  request it, since some implementations may be able to provide caching, or
                  analogous optimizations, even for proactive functions. (One possible strategy is
                  to return a copy of the cached result, thus creating the illusion that the
                  function has been evaluated anew.)</p>

               <note>
                  <p>Memoization is essentially a trade-off between time and space; a memoized
                     function can be expected to use more memory to deliver faster execution.
                     Achieving an optimum balance may require configuring the size of the cache that
                     is used; implementations <rfc2119>may</rfc2119> use additional <termref def="dt-extension-attribute">extension attributes</termref> or other
                     mechanisms to provide finer control of this kind.</p>
               </note>

               <note>
                  <p>Memoization of a function generally involves creating an associative table (for
                     example, a hash map) that maps argument values to function results. To get this
                     right, it is vital that the key for this table should correctly reflect what it
                     means for two function calls to have “the same arguments”. Does it matter, for
                     example, that one call passes the <code>xs:string</code> value "Paris", while
                     another passes the <code>xs:untypedAtomic</code> value "Paris"? If the function
                     is declared with <code>new-each-time="maybe"</code>, then the rules say that
                     these cannot be treated as “the same arguments”: the definition of <xtermref spec="FO40" ref="dt-identical"/> requires them to have exactly the same type
                     as well as being equal. However, an implementation that is able to determine
                     that all references to the argument within the function body only make use of
                     its string value might be able to take advantage of this fact, and thus perform
                     more efficient caching.</p>
               </note>


            </div3>

            <div3 id="function-examples">
               <head>Examples of Stylesheet Functions</head>

               <example diff="chg" at="A">
                  <head>A Stylesheet Function</head>
                  <p>The following example creates a recursive <termref def="dt-stylesheet-function">stylesheet function</termref> named <code>str:reverse</code> that reverses
                     the words in a supplied sentence, and then invokes this function from within a
                        <termref def="dt-template-rule">template rule</termref>. </p>
                  <eg xml:space="preserve" role="xslt-document">&lt;xsl:transform 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  default-type-namespace="http://www.w3.org/2001/XMLSchema"
  xmlns:str="http://example.com/namespace"
  version="3.0"
  exclude-result-prefixes="str"&gt; 

&lt;xsl:function name="str:reverse" as="string"&gt;
  &lt;xsl:param name="sentence" as="string"/&gt;
  &lt;xsl:sequence  
     select="if (contains($sentence, ' '))
             then concat(str:reverse(substring-after($sentence, ' ')),
                         ' ',
                         substring-before($sentence, ' '))
             else $sentence"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:template match="/"&gt;
  &lt;output&gt;
    &lt;xsl:value-of select="str:reverse('DOG BITES MAN')"/&gt;
  &lt;/output&gt;
&lt;/xsl:template&gt;

&lt;/xsl:transform&gt;</eg>
                  <p>An alternative way of writing the same function is to implement the conditional
                     logic at the XSLT level, thus:</p>
                  <eg xml:space="preserve" role="xslt-declaration xmlns:str='str'">&lt;xsl:function name="str:reverse" as="xs:string"&gt;
  &lt;xsl:param name="sentence" as="string"/&gt;
  &lt;xsl:if test="contains($sentence, ' ')" 
             then="concat(str:reverse(substring-after($sentence, ' ')),
                                ' ',
                                substring-before($sentence, ' '))" 
             else="$sentence"/&gt;
&lt;/xsl:function&gt;</eg>
               </example>
               <example>
                  <head>Declaring the Return Type of a Function</head>
                  <p>The following example illustrates the use of the <code>as</code> attribute in a
                     function definition. It returns a string containing the representation of its
                     integer argument, expressed as a roman numeral. For example, the function call
                        <code>num:roman(7)</code> will return the string <code>"vii"</code>. This
                     example uses the <elcode>xsl:number</elcode> instruction, described in 
                     <specref ref="number"/>. The <elcode>xsl:number</elcode> instruction returns a text
                     node, and the <termref def="dt-coercion-rules"/> are invoked to convert this text node to the type declared
                     in the <elcode>xsl:function</elcode> element, namely <code>xs:string</code>. So
                     the text node is <termref def="dt-atomization">atomized</termref> to a
                     string.</p>
                  <eg xml:space="preserve" role="xslt-declaration xmlns:num='num'">&lt;xsl:function name="num:roman" as="xs:string"&gt;
  &lt;xsl:param name="value" as="xs:integer"/&gt;
  &lt;xsl:number value="$value" format="i"/&gt;
&lt;/xsl:function&gt;</eg>
               </example>
               <example>
                  <head>A Higher-Order Function</head>
                  <p>XPath 3.0 introduces the ability to pass function items as arguments to a
                     function. A function that takes function items as arguments is known as a
                     higher-order function.</p>
                  <p>The following example is a higher-order function that operates on any
                     tree-structured data, for example an organization chart. Given as input a
                     function that finds the direct subordinates of a node in this tree structure
                     (for example, the direct reports of a manager, or the geographical subdivisions
                     of an administrative area), it determines whether one object is present in the
                     subtree rooted at another object (for example, whether one person is among the
                     staff managed directly or indirectly by a manager, or whether one parcel of
                     land is contained directly or indirectly within another parcel). The function
                     does not check for cycles in the data.</p>
                  <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">&lt;xsl:function name="f:is-subordinate" as="xs:boolean"&gt;
    &lt;xsl:param name="superior" 
               as="node()"/&gt;
    &lt;xsl:param name="subordinate" 
               as="node()"/&gt;
    &lt;xsl:param name="get-direct-children" 
               as="function(node()) as node()*"/&gt;
    &lt;xsl:sequence select="
               some $sub in $get-direct-children($superior) satisfies
                 ($sub is $subordinate or
                  f:is-subordinate($sub, $subordinate, 
                                      $get-direct-children))"/&gt;
&lt;/xsl:function&gt;</eg>
                  <p>Given source data representing an organization chart in the form of elements
                     such as:</p>
                  <eg role="xml" xml:space="preserve">&lt;employee id="P57832" manager="P68951"/&gt;</eg>
                  <p>the following function can be defined to get the direct reports of a
                     manager:</p>
                  <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">&lt;xsl:function name="f:direct-reports" 
               as="element(employee)*"&gt;
    &lt;xsl:param name="manager" as="element(employee)"/&gt;
    &lt;xsl:sequence select="$manager/../employee
                               [@manager = $manager/@id]"/&gt;
&lt;/xsl:function&gt;</eg>
                  <p>It is then possible to test whether one employee <code>$E</code> reports
                     directly or indirectly to another employee <code>$M</code> by means of the
                     function call:</p>
                  <eg role="non-xml" xml:space="preserve">f:is-subordinate($M, $E, f:direct-reports#1)</eg>
               </example>
            </div3>
         </div2>
         <div2 id="dynamic-xpath">
            <head>Dynamic XPath Evaluation</head>

            <?element xsl:evaluate?>
            <p>The <elcode>xsl:evaluate</elcode> instruction constructs an XPath expression in the
               form of a string, evaluates the expression in a specified context, and returns the
               result of the evaluation.</p>
            <p>The expression given as the value of the <code>xpath</code> attribute is evaluated
               and the result is converted to a string using the <termref def="dt-coercion-rules"/>.</p>

            <p><termdef id="dt-target-expression" term="target expression">The string that results
                  from evaluating the expression in the <code>xpath</code> attribute is referred to
                  as the <term>target expression</term>.</termdef></p>

            <p><error spec="XT" type="dynamic" class="DE" code="3160">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the <termref def="dt-target-expression">target expression</termref>
                     <error.extra>of an <elcode>xsl:evaluate</elcode> instruction</error.extra> is
                     not a valid <termref def="dt-expression"/> (that is, if a static error occurs when analyzing the string
                     according to the rules of the XPath specification).</p>
               </error></p>

            <p>The <code>as</code> attribute, if present, indicates the required type of the result.
               If the attribute is absent, the required type is <code>item()*</code>, which allows
               any result. The result of evaluating the <termref def="dt-target-expression">target
                  expression</termref> is converted to the required type using the <termref def="dt-coercion-rules"/>. This may
               cause a <termref def="dt-type-error">type error</termref> if conversion is not
               possible. The result after conversion is returned as the result of the
                  <elcode>xsl:evaluate</elcode> instruction.</p>

            <p>The target expression may contain variable references; the values
               of such variables may be supplied using an <elcode>xsl:with-param</elcode> child
               instruction if the names of the variables are known statically, or using a map
               supplied as the value of the expression in the <code>with-params</code> attribute if
               the names are only known dynamically. If the <code>with-params</code> attribute is
               present then it must contain an expression whose value, when evaluated, is of type
                  <code>map(xs:QName, item()*)</code> (see <specref ref="map"/> for details of
               maps).</p>
            
            <p>
               <error spec="XT" type="type" class="TE" code="3165">
                  <p>It is a <termref def="dt-type-error">type error</termref> if the
                     result of evaluating the expression in the <code>with-params</code>
                     attribute of the <elcode>xsl:evaluate</elcode> instruction is
                     anything other than a single map of type
                     <code>map(xs:QName, item()*)</code>.</p>
               </error>
            </p>
            
            

            <div3 id="evaluate-static-context">
               <head>Static context for the target expression</head>

               <p>The <xtermref spec="XP40" ref="dt-static-context">static context</xtermref> for
                  the <termref def="dt-target-expression">target expression</termref> is as
                  follows:</p>
               <ulist>
                  <item>
                     <p>XPath 1.0 compatibility mode is <code>false</code>.</p>
                  </item>
                  <item diff="chg" at="A">
                     <p>Statically known namespaces and default namespaces for 
                        elements and for types:</p>
                     <ulist>
                        <item>
                           <p>if the <code>namespace-context</code> attribute is present, then its
                              value is an <termref def="dt-expression">expression</termref> whose
                              required type is a single node. The expression is evaluated, and the
                              in-scope namespaces of the resulting node are used as the statically
                              known namespaces for the target expression. The binding for the
                              default namespace in the in-scope namespaces is used as the default
                              namespace for <phrase diff="add" at="A">both</phrase>
                              elements and types in the target expression.</p>
                           <p>
                              <error spec="XT" type="type" class="TE" code="3170">
                                 <p>It is a <termref def="dt-type-error">type error</termref> if the
                                    result of evaluating the <code>namespace-context</code>
                                    attribute of the <elcode>xsl:evaluate</elcode> instruction is
                                    anything other than a single node.</p>
                              </error>
                           </p>
                        </item>
                        <item>
                           <p>if the <code>namespace-context</code> attribute is absent, then the
                              in-scope namespaces of the <elcode>xsl:evaluate</elcode> instruction
                              (with the exception of any binding for the default namespace) are used
                              as the statically known namespaces for the target expression, and the
                              values of the attributes <code>[xsl:]default-element-namespace</code>,
                              <code>[xsl:]default-type-namespace</code>, and <code>[xsl:]xpath-default-namespace</code>
                              if any, are used to establish the default namespaces for elements and
                              types in the target expression, as described in <specref ref="unprefixed-qnames"/>.</p>
                        </item>
                     </ulist>
                     <note>
                        <p>XPath 3.0 allows expanded names to be written in a context-independent
                           way using the syntax <code>Q{namespace-uri}local-name</code></p>
                     </note>
                  </item>
                  <item>
                     <p>Default function namespace: the <termref def="dt-standard-function-namespace">standard function
                           namespace</termref>.</p>
                  </item>
                  <item>
                     <p>In-scope schema definitions: if the <code>schema-aware</code> attribute is
                        present and has the <termref def="dt-effective-value">effective
                           value</termref>
                        <code>yes</code>, then the in-scope schema definitions from the stylesheet
                        context (that is, the schema definitions imported using
                           <elcode>xsl:import-schema</elcode>). Otherwise, the built-in types (see
                           <specref ref="built-in-types"/>).</p>
                  </item>
                  <item>
                     <p>In-scope variables: the names of the in-scope variables
                        are the union of the names appearing in the <code>name</code> attribute of
                        the contained <elcode>xsl:with-param</elcode> elements, and the names
                        present as keys in the map obtained by evaluating the
                           <code>with-params</code> attribute, if present. The corresponding type is
                           <code>item()*</code> in the case of a name found as a key in the
                           <code>with-params</code> map, or the type named in the <code>as</code>
                        attribute of <elcode>xsl:with-param</elcode> child (defaulting to
                           <code>item()*</code>) otherwise.</p>
                     <p>If a variable name is present both the static
                           <elcode>xsl:with-param</elcode> children and also in the dynamic
                           <code>with-params</code> map, the value from the latter takes
                        precedence.</p>
                     <note>
                        <p>Variables declared in the stylesheet in <elcode>xsl:variable</elcode> or
                              <elcode>xsl:param</elcode> elements are <emph>not</emph> in-scope
                           within the target expression.</p>

                     </note>
                  </item>
                  <item>
                     <p>Function signatures:</p>
                     <ulist>
                        <item><p>All functions defined in <bibref ref="xpath-functions-40"/> in the
                           <code>fn</code> and <code>math</code>, <phrase diff="add" at="A"><code>map</code>, and <code>array</code></phrase> namespaces;</p></item>
                        
                        <item><p>Constructor functions for named simple types included in the in-scope schema definitions;</p></item>
                        <item><p>All user-defined functions present in the containing package provided their visibility is
                           not <code>hidden</code> or <code>private</code>;</p></item>
                        <item><p>An <termref def="dt-implementation-defined">implementation-defined</termref> set of
                           <termref def="dt-extension-function">extension functions</termref>.</p></item>
                     </ulist>
                    
                     <p>Note that this set deliberately excludes XSLT-defined functions in the
                           <termref def="dt-standard-function-namespace">standard function
                           namespace</termref> including for example, <function>key</function>,
                           <function>current-group</function>, and
                           <function>system-property</function>. A list of these functions is in
                           <specref ref="XSLT-defined-functions"/>.</p>
                     <imp-def-feature id="idf-ext-evaluatefunctions">The set of extension functions
                        available in the static context for the target expression of
                           <elcode>xsl:evaluate</elcode> is <termref def="dt-implementation-defined"/>.</imp-def-feature>

                  </item>
                  <item>
                     <p>Statically known collations: the same as the collations available at this
                        point in the stylesheet.</p>
                  </item>
                  <item>
                     <p>Default collation: the same as the default collation defined at this point
                        in the stylesheet (for example, by use of the
                           <code>[xsl:]default-collation</code> attribute)</p>
                  </item>
                  <item>
                     <p>Base URI: if the <code>base-uri</code> attribute is present, then its
                           <termref def="dt-effective-value">effective value</termref>; otherwise,
                        the base URI of the <elcode>xsl:evaluate</elcode> instruction.</p>
                  </item>
                  <item>
                     <p>Statically known documents: the empty set</p>
                  </item>
                  <item>
                     <p>Statically known collections: the empty set</p>
                  </item>
                  <item>
                     <p>Statically known default collection type: <code>node()*</code></p>
                  </item>
               </ulist>

            </div3>
            <div3 id="evaluate-dynamic-context">
               <head>Dynamic context for the target expression</head>

               <p>The dynamic context for evaluation of the target expression is
                  as follows:</p>
               <ulist>
                  <item>
                     <p>The context item, position, and size depend on the result of evaluating the
                        expression in the <code>context-item</code> attribute. If this attribute is
                        absent, or if the result is an empty sequence, then the context item,
                        position, and size for evaluation of the target expression are all <termref def="dt-absent"/>. If the result of evaluating the
                           <code>context-item</code> expression is a single item, then the target
                        expression is evaluated with a <termref def="dt-singleton-focus"/> based on
                        this item.</p>
                     <p><error spec="XT" type="type" class="TE" code="3210">
                           <p>If the result of evaluating the <code>context-item</code> expression
                                 <error.extra>of an <elcode>xsl:evaluate</elcode>
                                 instruction</error.extra> is a sequence containing more than one
                              item, then a <termref def="dt-type-error"/> is signaled.</p>
                        </error></p>
                  </item>
                  <item>
                     <p>The <term>variable values</term> consists of the values
                        bound to parameters defined either in the contained
                           <elcode>xsl:with-param</elcode> elements, which are evaluated as
                        described in <specref ref="variable-values"/>, or in the map that results
                        from evaluation of the expression in the <code>with-params</code> attribute;
                        if the same QName is bound in both, the value in the
                           <code>with-params</code> map takes precedence.</p>
                  </item>
                  <item>
                     <p>The XSLT-specific aspects of the dynamic context described in <specref ref="additional-dynamic-context"/> are all <termref def="dt-absent"/>.</p>
                  </item>
                  <item>
                     <p>The <xtermref spec="XP40" ref="dt-named-functions">named functions</xtermref>
                        (representing the functions accessible using <function>function-available</function> or <xfunction>function-lookup</xfunction>)
                        include all the functions available in the static context, and may also include an additional 
                        <termref def="dt-implementation-defined"/> set of functions that are available dynamically but not statically.
                     </p>
                  </item>
                  <item>
                     <p>All other aspects of the dynamic context are the same as the dynamic context
                        for the <elcode>xsl:evaluate</elcode> instruction itself, except that an implementation <code>may</code> restrict
                           the availability of external resources (for example, available documents)
                           or provide options to restrict their availability, for security
                           reasons.</p>
                     <note>
                        <p>For example, a processor may disallow access using the
                              <xfunction>doc</xfunction> or <xfunction>collection</xfunction> functions
                           to documents in local filestore.</p>
                     </note>
                     
                  </item>
               </ulist>

            </div3>
            <div3 id="evaluate-effect">
               <head>The effect of the <code>xsl:evaluate</code> instruction</head>


               <p>The XPath expression is evaluated in the same <xtermref ref="execution-scope" spec="FO40">execution scope</xtermref> as the calling XSLT transformation; this
                  means that the results of <xtermref spec="FO40" ref="dt-deterministic">deterministic</xtermref> functions such as <xfunction>doc</xfunction> or
                     <xfunction>current-dateTime</xfunction> will be consistent between the calling
                  stylesheet and the called XPath expression.</p>
               <p>It is a <termref def="dt-dynamic-error"/> if evaluation of the
                  XPath expression fails with a dynamic error. The XPath-defined error code is used
                  unchanged.</p>
               <note>
                  <p>Implementations wanting to avoid the cost of repeated compilation of the same
                     XPath expression should cache the compiled form internally.</p>
               </note>



               <p>Stylesheet authors need to be aware of the security risks
                  associated with the use of <elcode>xsl:evaluate</elcode>. The instruction should
                  not be used to execute code from an untrusted source. To avoid the risk of code
                  injection, user-supplied data should never be inserted into the expression using
                  string concatenation, but should always be referenced by use of parameters.</p>



            </div3>
            <div3 id="evaluation-as-optional-feature">
               <head><elcode>xsl:evaluate</elcode> as an optional feature</head>

               <p>The <elcode>xsl:evaluate</elcode> instruction is newly introduced in XSLT 3.0. It
                  is part of the dynamic evaluation feature, which is an optional feature of the
                  specification (see <specref ref="dynamic-evaluation-feature"/>). An XSLT 3.0
                  processor <rfc2119>may</rfc2119> disable the feature, or allow users to disable
                  the feature. The processor <rfc2119>may</rfc2119> be able to determine during
                  static analysis whether or not the feature is available, or it
                     <rfc2119>may</rfc2119> only be able to determine this during dynamic
                  evaluation. In the first case we refer to the feature being <term>statically
                     disabled</term>, in the second case to it being <term>dynamically
                     disabled</term>.</p>

               <p>If the feature is statically disabled, then:</p>

               <ulist>
                  <item>
                     <p>A call to <code>element-available('xsl:evaluate')</code> returns false,
                        wherever it appears;</p>
                  </item>
                  <item>
                     <p>A call to <code>system-property('xsl:supports-dynamic-evaluation')</code>
                        returns the string <code>"no"</code>, wherever it appears;</p>
                  </item>
                  <item>
                     <p>If an <elcode>xsl:evaluate</elcode> instruction has an
                           <elcode>xsl:fallback</elcode> child, fallback processing takes place;</p>
                  </item>
                  <item>
                     <p>No static error is raised if an <elcode>xsl:evaluate</elcode> instruction is
                        present in the stylesheet (an error occurs only if it is actually
                        evaluated).</p>
                  </item>
               </ulist>

               <p>If the feature is dynamically disabled, then:</p>

               <ulist>
                  <item>
                     <p>A call to <code>element-available('xsl:evaluate')</code> appearing in a
                           <termref def="dt-static-expression">static expression</termref> (for
                        example, in an <code>[xsl:]use-when</code> attribute) returns true;</p>
                  </item>
                  <item>
                     <p>A call to <code>element-available('xsl:evaluate')</code> appearing anywhere
                        else returns false;</p>
                  </item>
                  <item>
                     <p>A call to <code>system-property('xsl:supports-dynamic-evaluation')</code>
                        appearing in a <termref def="dt-static-expression">static
                           expression</termref> (for example, in an <code>[xsl:]use-when</code>
                        attribute) returns the string <code>"yes"</code>;</p>
                  </item>
                  <item>
                     <p>A call to <code>system-property('xsl:supports-dynamic-evaluation')</code>
                        appearing anywhere else returns the string <code>"no"</code>;</p>
                  </item>
                  <item>
                     <p>If an <elcode>xsl:evaluate</elcode> instruction has an
                           <elcode>xsl:fallback</elcode> child, fallback processing takes place;</p>
                  </item>
                  <item>
                     <p>In the absence of an <elcode>xsl:fallback</elcode> child, a dynamic error is
                        raised if an <elcode>xsl:evaluate</elcode> instruction is evaluated. The
                        dynamic error may be caught using <elcode>xsl:try</elcode> and
                           <elcode>xsl:catch</elcode>.</p>
                  </item>
               </ulist>
               
               <p>If a processor supports the dynamic evaluation feature, 
                  it is <termref def="dt-implementation-defined"/> how the processor allows users to disable 
                  dynamic evaluation and it is implementation-defined whether the mechanism is static or dynamic.</p>
               
               <p><error spec="XT" type="dynamic" class="DE" code="3175">
                     <p>It is a <termref def="dt-dynamic-error"/> if an
                           <elcode>xsl:evaluate</elcode> instruction is evaluated when use of
                           <elcode>xsl:evaluate</elcode> has been statically or dynamically
                        disabled. </p>
                  </error></p>

               <p>In consequence of these rules, the recommended approach for stylesheet authors to
                  write code that works whether or not <elcode>xsl:evaluate</elcode> is enabled is
                  to use an <elcode>xsl:fallback</elcode> child instruction. For example:</p>

               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:variable name="isValid" as="xs:boolean"&gt;
  &lt;xsl:evaluate xpath="$validityCondition"&gt;
     &lt;xsl:fallback&gt;&lt;xsl:sequence select="true()"/&gt;&lt;/xsl:fallback&gt;
  &lt;/xsl:evaluate&gt;
&lt;/xsl:variable&gt;</eg>

               <note>
                  <p>There may be circumstances where it is inappropriate to allow use of
                        <elcode>xsl:evaluate</elcode>. For example:</p>
                  <ulist>
                     <item>
                        <p>There may be security risks associated with the ability to execute code
                           from an untrusted source, which cannot be inspected during static
                           analysis.</p>
                     </item>
                     <item>
                        <p>There may be environments where the available computing resources are
                           sufficient to enable pre-compiled stylesheets to be executed, but not to
                           enable XPath expressions to be compiled into executable code.</p>
                     </item>
                  </ulist>


                  <p> Processors that implement <elcode>xsl:evaluate</elcode> should provide
                     mechanisms allowing calls on <elcode>xsl:evaluate</elcode> to be disabled.
                     Implementations may disable the feature by default, and they may disable it
                     unconditionally. </p>


               </note>


            </div3>
            <div3 id="evaluate-examples">
               <head>Examples of <elcode>xsl:evaluate</elcode></head>

               <example>
                  <head>Using a Dynamic Sort Key</head>
                  <p>A common requirement is to sort a table on the value of an expression which is
                     selected at run-time, perhaps by supplying the expression as a string-valued
                     parameter to the stylesheet. Suppose that such an expression is supplied to the
                     parameter:</p>
                  <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:param name="sortkey" as="xs:string" select="'@name'"/&gt;</eg>
                  <p>Then the data may be sorted as follows:</p>
                  <eg role="non-xml" xml:space="preserve">&lt;xsl:sort&gt;
   &lt;xsl:evaluate xpath="$sortkey" as="xs:string" context-item="."/&gt;
&lt;/xsl:sort&gt;</eg>
                  <p>Note the importance in this use case of caching the compiled expression, since
                     it is evaluated repeatedly, once for each item in the list being sorted.</p>
               </example>

               <example>
                  <head>Getting a Function if it Exists</head>
                  <p>If the <xfunction>function-lookup</xfunction> function were not available
                     in the standard library, then a very similar function could be implemented like this:</p>
                  <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">&lt;xsl:function name="f:function-lookup"&gt;
  &lt;xsl:param name="name" as="xs:QName"/&gt;
  &lt;xsl:param name="arity" as="xs:integer"/&gt;
  &lt;xsl:try&gt;
    &lt;xsl:evaluate xpath="'Q{' || namespace-uri-from-QName($name) || '}' 
                || local-name-from-QName($name) || '#' || $arity"&gt;
      &lt;xsl:with-param name="name" as="xs:QName" select="$name"/&gt;
      &lt;xsl:with-param name="arity" as="xs:integer" select="$arity"/&gt;
    &lt;/xsl:evaluate&gt;
    &lt;xsl:catch errors="err:XTDE3160" select="()"/&gt;
  &lt;/xsl:try&gt;  
&lt;/xsl:function&gt;  
     </eg>
                  <note><p>The main difference between this function and the standard <xfunction>function-lookup</xfunction>
                     function is that there are differences in the functions that are visible: for example <xfunction>function-lookup</xfunction>
                  gives access to user-defined functions with private visibility, whereas <elcode>xsl:evaluate</elcode> does not.</p></note>
                  <p>The <elcode>xsl:evaluate</elcode> instruction uses the supplied QName and arity
                     to construct an expression of the form
                     <code>Q{namespace-uri}local#arity</code>, which is then evaluated to return a
                     function item representing the requested function.</p>
               </example>

            </div3>
         </div2>
      </div1>
      <div1 id="creating-new-nodes">
         <head>Creating Nodes and Sequences</head>
         <p>This section describes instructions that directly create new nodes, or sequences of
            nodes, atomic values, and/or function items.</p>
         <div2 id="literal-result-element">
            <head>Literal Result Elements</head>
            <p>
               <termdef id="dt-literal-result-element" term="literal result element">In a <termref def="dt-sequence-constructor">sequence constructor</termref>, an element in the
                     <termref def="dt-stylesheet">stylesheet</termref> that does not belong to the
                     <termref def="dt-xslt-namespace">XSLT namespace</termref> and that is not an
                     <termref def="dt-extension-instruction">extension instruction</termref> (see
                     <specref ref="extension-instruction"/>) is classified as a <term>literal result
                     element</term>.</termdef> A literal result element is evaluated to construct a
               new element node with the same <termref def="dt-expanded-qname">expanded
                  QName</termref> (that is, the same namespace URI, local name, and namespace
               prefix). The result of evaluating a literal result element is a node sequence
               containing one element, the newly constructed element node.</p>
            <p>The content of the element is a <termref def="dt-sequence-constructor">sequence
                  constructor</termref> (see <specref ref="sequence-constructors"/>). The sequence
               obtained by evaluating this sequence constructor, after prepending any attribute
               nodes produced as described in <specref ref="attributes-for-lres"/> and namespace
               nodes produced as described in <specref ref="lre-namespaces"/>, is used to construct
               the content of the element, following the rules in <specref ref="constructing-complex-content"/>
            </p>
            <p>The base URI of the new element is copied from the base URI of the literal result
               element in the stylesheet, unless the content of the new element includes an
                  <code>xml:base</code> attribute, in which case the base URI of the new element is
               the value of that attribute, resolved (if it is a relative URI reference) against the base URI of the literal result element in
               the stylesheet. (Note, however, that this is only relevant when creating a parentless
               element. When the literal result element is copied to form a child of an element or
               document node, the base URI of the new copy is taken from that of its new
               parent.)</p>
            <div3 id="setting-annotation-for-lre">
               <head>Setting the Type Annotation for Literal Result Elements</head>
               <p>The attributes <code>xsl:type</code> and <code>xsl:validation</code> may be used
                  on a literal result element to invoke validation of the contents of the element
                  against a type definition or element declaration in a schema, and to determine the
                     <termref def="dt-type-annotation"/> that the new element node will carry. These
                  attributes also affect the type annotation carried by any elements and attributes
                  that have the new element node as an ancestor. These two attributes are both
                  optional, and if one is specified then the other <rfc2119>must</rfc2119> be
                  omitted.</p>
               <p>The value of the <code>xsl:validation</code> attribute, if present, must be one of
                  the values <code>strict</code>, <code>lax</code>, <code>preserve</code>, or
                     <code>strip</code>. The value of the <code>xsl:type</code> attribute, if
                  present, must be an <termref def="dt-eqname">EQName</termref> identifying a type definition that is present in
                  the <termref def="dt-in-scope-schema-component">in-scope schema
                     components</termref> for the stylesheet. Neither attribute may be specified as
                  an <termref def="dt-attribute-value-template">attribute value template.</termref>
                  The effect of these attributes is described in <specref ref="validation"/>.</p>
            </div3>
            <div3 id="attributes-for-lres">
               <head>Attribute Nodes for Literal Result Elements</head>
               <p>Attribute nodes for a literal result element may be created by including
                     <elcode>xsl:attribute</elcode> instructions within the <termref def="dt-sequence-constructor">sequence constructor</termref>. Additionally,
                  attribute nodes are created corresponding to the attributes of the literal result
                  element in the stylesheet, and as a result of expanding the
                     <code>xsl:use-attribute-sets</code> attribute of the literal result element, if
                  present.</p>
               <p>The sequence that is used to construct the content of the literal result element
                  (as described in <specref ref="constructing-complex-content"/>) is the
                  concatenation of the following four sequences, in order:</p>
               <olist>
                  <item>
                     <p>The sequence of namespace nodes produced as described in <specref ref="lre-namespaces"/>.</p>
                  </item>
                  <item>
                     <p>The sequence of attribute nodes produced by expanding the
                           <code>xsl:use-attribute-sets</code> attribute (if present) following the
                        rules given in <specref ref="attribute-sets"/>
                     </p>
                  </item>
                  <item>
                     <p>The attributes produced by processing the attributes of the literal result
                        element itself, other than attributes in the <termref def="dt-xslt-namespace">XSLT namespace</termref>. The way these are
                        processed is described below.</p>
                  </item>
                  <item>
                     <p>The sequence produced by evaluating the contained <termref def="dt-sequence-constructor">sequence constructor</termref>, if the
                        element is not empty.</p>
                  </item>
               </olist>
               <note>
                  <p>The significance of this order is that an attribute produced by an
                        <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>, or
                        <elcode>xsl:copy-of</elcode> instruction in the content of the literal
                     result element takes precedence over an attribute produced by expanding an
                     attribute of the literal result element itself, which in turn takes precedence
                     over an attribute produced by expanding the <code>xsl:use-attribute-sets</code>
                     attribute. This is because of the rules in <specref ref="constructing-complex-content"/>, which specify that when two or more
                     attributes in the sequence have the same name, all but the last of the
                     duplicates are discarded.</p>
                  <p>Although the above rules place namespace nodes before attributes, this is not
                     strictly necessary, because the rules in <specref ref="constructing-complex-content"/> allow the namespaces and attributes to
                     appear in any order so long as both come before other kinds of node. The order
                     of namespace nodes and attribute nodes in the sequence has no effect on the
                     relative position of the nodes in document order once they are added to a
                     tree.</p>
               </note>
               <p>Each attribute of the literal result element, other than an attribute in the
                     <termref def="dt-xslt-namespace">XSLT namespace</termref>, is processed to
                  produce an attribute for the element in the <termref def="dt-result-tree">result
                     tree</termref>.</p>
               <p>The value of such an attribute is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>: it can
                  therefore contain <termref def="dt-expression">expressions</termref> contained in
                  curly brackets (<code>{}</code>). The new attribute node will have the same
                     <termref def="dt-expanded-qname">expanded QName</termref> (that is, the same
                  namespace URI, local name, and namespace prefix) as the attribute in the
                  stylesheet tree, and its <termref def="dt-string-value">string value</termref>
                  will be the same as the <termref def="dt-effective-value">effective
                     value</termref> of the attribute in the stylesheet tree. The <termref def="dt-type-annotation">type annotation</termref> on the attribute will
                  initially be <code>xs:untypedAtomic</code>, and the <termref def="dt-typed-value">typed value</termref> of the attribute node will be the same as its <termref def="dt-string-value">string value</termref>.</p>
               <note>
                  <p>The eventual <termref def="dt-type-annotation"/> of the attribute in the
                        <termref def="dt-result-tree">result tree</termref> depends on the
                        <code>xsl:validation</code> and <code>xsl:type</code> attributes of the
                     parent literal result element, and on the instructions used to create its
                     ancestor elements. If the <code>xsl:validation</code> attribute is set to
                        <code>preserve</code> or <code>strip</code>, the type annotation will be
                        <code>xs:untypedAtomic</code>, and the <termref def="dt-typed-value">typed
                        value</termref> of the attribute node will be the same as its <termref def="dt-string-value">string value</termref>. If the
                        <code>xsl:validation</code> attribute is set to <code>strict</code> or
                        <code>lax</code>, or if the <code>xsl:type</code> attribute is used, the
                     type annotation on the attribute will be set as a result of the schema
                     validation process applied to the parent element. If neither attribute is
                     present, the type annotation on the attribute will be
                        <code>xs:untypedAtomic</code>.</p>
               </note>
               <p>If the name of a constructed attribute is <code>xml:id</code>, the processor must
                  perform attribute value normalization by effectively applying the
                     <xfunction>normalize-space</xfunction> function to the value of the attribute,
                  and the resulting attribute node must be given the <code>is-id</code>
                  property.</p>
               <note>
                  <p> If the attribute name is <code>xml:space</code>, it is <emph>not</emph> an
                     error when the value is something other than <code>default</code> or
                        <code>preserve</code>. Although the XML specification states that other
                     values are erroneous, a document containing such values is well-formed; if
                     erroneous values are to be rejected, schema validation should be used. </p>
               </note>
               
               <note>
                  <p>The <code>xml:base</code>, <code>xml:lang</code>, <code>xml:space</code>, and
                        <code>xml:id</code> attributes have two effects in XSLT. They behave as
                     standard XSLT attributes, which means for example that if they appear on a
                     literal result element, they will be copied to the <termref def="dt-result-tree">result tree</termref> in the same way as any other
                     attribute. In addition, they have their standard meaning as defined in the core
                     XML specifications. Thus, an <code>xml:base</code> attribute in the stylesheet
                     affects the base URI of the element on which it appears, and an
                        <code>xml:space</code> attribute affects the interpretation of <termref def="dt-whitespace-text-node">whitespace text nodes</termref> within that
                     element. One consequence of this is that it is inadvisable to write these
                     attributes as attribute value templates: although an XSLT processor will
                     understand this notation, the XML parser will not. See also <specref ref="namespace-aliasing"/> which describes how to use
                        <elcode>xsl:namespace-alias</elcode> with these attributes.</p>
                  <p>The same is true of the schema-defined attributes <code>xsi:type</code>,
                        <code>xsi:nil</code>, <code>xsi:noNamespaceSchemaLocation</code>, and
                        <code>xsi:schemaLocation</code>. If the stylesheet is processed by a schema
                     processor, these attributes will be recognized and interpreted by the schema
                     processor, but in addition the XSLT processor treats them like any other
                     attribute on a literal result element: that is, their <termref def="dt-effective-value">effective value</termref> (after expanding <termref def="dt-attribute-value-template">attribute value templates</termref>) is
                     copied to the result tree in the same way as any other attribute. If the
                        <termref def="dt-result-tree">result tree</termref> is validated, the copied
                     attributes will again be recognized and interpreted by the schema
                     processor.</p>
                  <p>None of these attributes will be generated in the <termref def="dt-result-tree">result tree</termref> unless the stylesheet writes them to the result tree
                     explicitly, in the same way as any other attribute.</p>
               </note>
               <p>
                  <error spec="XT" type="static" class="SE" code="0805">
                     <p>It is a <termref def="dt-static-error">static error</termref> if an
                        attribute on a literal result element is in the <termref def="dt-xslt-namespace">XSLT namespace</termref>, unless it is one of the
                        attributes explicitly defined in this specification.</p>
                  </error>
               </p>
               <note>
                  <p>If there is a need to create attributes in the XSLT namespace, this can be
                     achieved using <elcode>xsl:attribute</elcode>, or by means of the
                        <elcode>xsl:namespace-alias</elcode> declaration.</p>
               </note>
            </div3>
            <div3 id="lre-namespaces">
               <head>Namespace Nodes for Literal Result Elements</head>
               <p>The created element node will have a copy of the namespace nodes that were present
                  on the element node in the stylesheet tree with the exception of any namespace
                  node whose <termref def="dt-string-value">string value</termref> is designated as
                  an <term>excluded namespace</term>. Special considerations apply to aliased
                  namespaces: see <specref ref="namespace-aliasing"/>.
               </p>
               <p>The following namespaces are designated as excluded namespaces:</p>
               <ulist>
                  <item>
                     <p>The <termref def="dt-xslt-namespace">XSLT namespace</termref> URI
                           (<code>http://www.w3.org/1999/XSL/Transform</code>)</p>
                  </item>
                  <item>
                     <p>A namespace URI declared as an extension namespace (see <specref ref="extension-instruction"/>)</p>
                  </item>
                  <item>
                     <p>A namespace URI designated by using an
                           <code>[xsl:]exclude-result-prefixes</code> attribute either on the
                        literal result element itself or on an ancestor element. The attribute
                           <rfc2119>must</rfc2119> be in the XSLT namespace only if its parent
                        element is <emph>not</emph> in the XSLT namespace.</p>
                     <p>The value of the attribute is either <code>#all</code>, or a
                        whitespace-separated list of tokens, each of which is either a namespace
                        prefix or <code>#default</code>. The namespace bound to each of the prefixes
                        is designated as an excluded namespace.</p>
                     <p>
                        <error class="SE" type="static" spec="XT" code="0808">
                           <p>It is a <termref def="dt-static-error">static error</termref> if a
                              namespace prefix is used within the
                                 <code>[xsl:]exclude-result-prefixes</code> attribute and there is
                              no namespace binding in scope for that prefix.</p>
                        </error>
                     </p>
                     <p>The default namespace of the parent element of the
                           <code>[xsl:]exclude-result-prefixes</code> attribute (see <xspecref spec="DM30" ref="ElementNode"/>) may be designated as an excluded
                        namespace by including <code>#default</code> in the list of namespace
                        prefixes.</p>
                     <p>
                        <error class="SE" type="static" spec="XT" code="0809">
                           <p>It is a <termref def="dt-static-error">static error</termref> if the
                              value <code>#default</code> is used within the
                                 <code>[xsl:]exclude-result-prefixes</code> attribute and the parent
                              element of the <code>[xsl:]exclude-result-prefixes</code> attribute
                              has no default namespace.</p>
                        </error>
                     </p>
                     <p>The value <code>#all</code> indicates that all namespaces that are in scope
                        for the stylesheet element that is the parent of the
                           <code>[xsl:]exclude-result-prefixes</code> attribute are designated as
                        excluded namespaces.</p>
                     <p>The designation of a namespace as an excluded namespace is effective within
                        the subtree of the stylesheet module rooted at the element bearing the
                           <code>[xsl:]exclude-result-prefixes</code> attribute; a subtree rooted at
                        an <elcode>xsl:stylesheet</elcode> element does not include any stylesheet
                        modules imported or included by children of that
                           <elcode>xsl:stylesheet</elcode> element.</p>
                  </item>
               </ulist>
               <p>The excluded namespaces, as described above, <emph>only</emph> affect namespace
                  nodes copied from the stylesheet when processing a literal result element. There
                  is no guarantee that an excluded namespace will not appear on the <termref def="dt-result-tree">result tree</termref> for some other reason. Namespace
                  nodes are also written to the result tree as part of the process of namespace
                  fixup (see <specref ref="namespace-fixup"/>), or as the result of instructions
                  such as <elcode>xsl:copy</elcode> and <elcode>xsl:element</elcode>.</p>
               <note>
                  <p>When a stylesheet uses a namespace declaration only for the purposes of
                     addressing a <termref def="dt-source-tree">source tree</termref>, specifying
                     the prefix in the <code>[xsl:]exclude-result-prefixes</code> attribute will
                     avoid superfluous namespace declarations in the serialized <termref def="dt-result-tree">result tree</termref>. The attribute is also useful to
                     prevent namespaces used solely for the naming of stylesheet functions or
                     extension functions from appearing in the serialized result tree.</p>
               </note>
               <example>
                  <head>Excluding Namespaces from the Result Tree</head>
                  <p>Consider the following stylesheet:</p>
                  <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:a="a.uri"
  xmlns:b="b.uri"
  exclude-result-prefixes="#all"&gt;
  
&lt;xsl:template match="/"&gt;
  &lt;foo xmlns:c="c.uri" xmlns:d="d.uri" xmlns:a2="a.uri" 
       xsl:exclude-result-prefixes="c"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
                  <p>The result of this stylesheet will be:</p>
                  <eg xml:space="preserve" role="xml">&lt;foo xmlns:d="d.uri"/&gt;</eg>
                  <p>The namespaces <code>a.uri</code> and <code>b.uri</code> are excluded by virtue
                     of the <code>exclude-result-prefixes</code> attribute on the
                        <elcode>xsl:stylesheet</elcode> element, and the namespace
                        <code>c.uri</code> is excluded by virtue of the
                        <code>xsl:exclude-result-prefixes</code> attribute on the <code>foo</code>
                     element. The setting <code>#all</code> does not affect the namespace
                        <code>d.uri</code> because <code>d.uri</code> is not an in-scope namespace
                     for the <elcode>xsl:stylesheet</elcode> element. The element in the <termref def="dt-result-tree">result tree</termref> does not have a namespace node
                     corresponding to <code>xmlns:a2="a.uri"</code> because the effect of
                        <code>exclude-result-prefixes</code> is to designate the namespace URI
                        <code>a.uri</code> as an excluded namespace, irrespective of how many
                     prefixes are bound to this namespace URI.</p>
                  <p>If the stylesheet is changed so that the literal result element has an
                     attribute <code>b:bar="3"</code>, then the element in the <termref def="dt-result-tree">result tree</termref> will typically have a namespace
                     declaration <code>xmlns:b="b.uri"</code> (the processor may choose a different
                     namespace prefix if this is necessary to avoid conflicts). The
                        <code>exclude-result-prefixes</code> attribute makes <code>b.uri</code> an
                     excluded namespace, so the namespace node is not automatically copied from the
                     stylesheet, but the presence of an attribute whose name is in the namespace
                        <code>b.uri</code> forces the namespace fixup process (see <specref ref="namespace-fixup"/>) to introduce a namespace node for this
                     namespace.</p>
               </example>
               <p>A literal result element may have an optional <code>xsl:inherit-namespaces</code>
                  attribute, with the value <code>yes</code> or <code>no</code>. The default value
                  is <code>yes</code>. If the value is set to <code>yes</code>, or is omitted, then
                  the namespace nodes created for the newly constructed element are copied to the
                  children and descendants of the newly constructed element, as described in
                     <specref ref="constructing-complex-content"/>. If the value is set to
                     <code>no</code>, then these namespace nodes are not automatically copied to the
                  children. This may result in namespace undeclarations (such as
                     <code>xmlns=""</code> or, in the case of XML 1.1, <code>xmlns:p=""</code>)
                  appearing on the child elements when they are serialized.</p>
            </div3>
            
            <div3 id="namespace-aliasing">
               <head>Namespace Aliasing</head>
               <p>When a stylesheet is used to define a transformation whose output is itself a
                  stylesheet module, or in certain other cases where the result document uses
                  namespaces that it would be inconvenient to use in the stylesheet, namespace
                  aliasing can be used to declare a mapping between a namespace URI used in the
                  stylesheet and the corresponding namespace URI to be used in the result
                  document.</p>
               <p>
                  <termdef id="dt-literal-namespace-uri" term="literal namespace URI">A namespace
                     URI in the stylesheet tree that is being used to specify a namespace URI in the
                        <termref def="dt-result-tree">result tree</termref> is called a
                        <term>literal namespace URI</term>.</termdef>
               </p>
               <p>
                  <termdef id="dt-target-namespace-uri" term="target namespace URI">The namespace
                     URI that is to be used in the <termref def="dt-result-tree">result
                        tree</termref> as a substitute for a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> is called the <term>target namespace
                        URI</term>.</termdef>
               </p>
               <p>Either of the <termref def="dt-literal-namespace-uri">literal namespace
                     URI</termref> or the <termref def="dt-target-namespace-uri">target namespace
                     URI</termref> can be <emph>null</emph>: this is treated as a reference to the
                  set of names that are in no namespace.</p>
               <?element xsl:namespace-alias?>
               <p>
                  <termdef id="dt-alias" term="alias">A stylesheet can use the
                        <elcode>xsl:namespace-alias</elcode> element to declare that a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> is being used
                     as an <term>alias</term> for a <termref def="dt-target-namespace-uri">target
                        namespace URI</termref>.</termdef>
               </p>
               <p>The effect is that when names in the namespace identified by the <termref def="dt-literal-namespace-uri">literal namespace URI</termref> are copied to
                  the <termref def="dt-result-tree">result tree</termref>, the namespace URI in the
                  result tree will be the <termref def="dt-target-namespace-uri">target namespace
                     URI</termref>, instead of the literal namespace URI. This applies to:</p>
               <ulist>
                  <item>
                     <p>the namespace URI in the <termref def="dt-expanded-qname">expanded
                           QName</termref> of a literal result element in the stylesheet</p>
                  </item>
                  <item>
                     <p>the namespace URI in the <termref def="dt-expanded-qname">expanded
                           QName</termref> of an attribute specified on a literal result element in
                        the stylesheet</p>
                  </item>
               </ulist>
               <p>The effect of an <elcode>xsl:namespace-alias</elcode>
                  declaration is local to the <termref def="dt-package">package</termref> in which
                  it appears: that is, it only affects the result of <termref def="dt-literal-result-element">literal result elements</termref> within the
                  same package.</p>
               <p>Where namespace aliasing changes the namespace URI part of the <termref def="dt-expanded-qname">expanded QName</termref> containing the name of an
                  element or attribute node, the namespace prefix in that expanded QName is replaced
                  by the prefix indicated by the <code>result-prefix</code> attribute of the
                     <elcode>xsl:namespace-alias</elcode> declaration.</p>
               <p>The <elcode>xsl:namespace-alias</elcode> element declares that the namespace URI
                  bound to the prefix specified by the <code>stylesheet-prefix</code> is the
                     <termref def="dt-literal-namespace-uri">literal namespace URI</termref>, and
                  the namespace URI bound to the prefix specified by the <code>result-prefix</code>
                  attribute is the <termref def="dt-target-namespace-uri">target namespace
                     URI</termref>. Thus, the <code>stylesheet-prefix</code> attribute specifies the
                  namespace URI that will appear in the stylesheet, and the
                     <code>result-prefix</code> attribute specifies the corresponding namespace URI
                  that will appear in the <termref def="dt-result-tree">result tree</termref>. </p>
               <p>The default namespace (as declared by <code>xmlns</code>) may be specified by
                  using <code>#default</code> instead of a prefix. If no default namespace is in
                  force, specifying <code>#default</code> denotes the null namespace URI. This
                  allows elements that are in no namespace in the stylesheet to acquire a namespace
                  in the result document, or vice versa. <phrase diff="add" at="A">
                     Defining an alias for the null namespace URI does not affect no-namespace attributes; 
                     these remain in no namespace. However, where <code>result-prefix="#default"</code> is specified and 
                     no default namespace is in force, attributes whose namespace matches the literal namespace 
                     URI are renamed to be in no namespace. [XSLT 3.0 Erratum E48, bug 30397]
                  </phrase></p>
               <p>If a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> is
                  declared to be an alias for multiple different <termref def="dt-literal-namespace-uri">target namespace URIs</termref>, then the
                  declaration with the highest <termref def="dt-import-precedence">import
                     precedence</termref> is used.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0810">
                     <p>It is a <termref def="dt-static-error">static error</termref> if within a <termref def="dt-package">package</termref> there is more than one such declaration
                           <error.extra>more than one <elcode>xsl:namespace-alias</elcode>
                           declaration</error.extra> with the same <termref def="dt-literal-namespace-uri">literal namespace URI</termref> and the
                        same <termref def="dt-import-precedence">import precedence</termref> and
                        different values for the <termref def="dt-target-namespace-uri">target
                           namespace URI</termref>, unless there is also an
                           <elcode>xsl:namespace-alias</elcode> declaration with the same <termref def="dt-literal-namespace-uri">literal namespace URI</termref> and a
                        higher import precedence. </p>
                  </error>
               </p>
               <p>No error occurs if there is more than one such
                     <elcode>xsl:namespace-alias</elcode> declaration having the same <termref def="dt-literal-namespace-uri">literal namespace URI</termref> and the same
                     <termref def="dt-target-namespace-uri">target namespace URI</termref>, even if
                  the <code>result-prefix</code> differs; in this case the
                     <code>result-prefix</code> used is the one that appears last in <termref def="dt-declaration-order">declaration order</termref>. </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0812">
                     <p>It is a <termref def="dt-static-error">static error</termref> if a value
                        other than <code>#default</code> is specified for either the
                           <code>stylesheet-prefix</code> or the <code>result-prefix</code>
                        attributes of the <elcode>xsl:namespace-alias</elcode> element when there is
                        no in-scope binding for that namespace prefix.</p>
                  </error>
               </p>
               <p>When a literal result element is processed, its namespace nodes are handled as
                  follows:</p>
               <ulist>
                  <item>
                     <p>A namespace node whose string value is a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> is not
                        copied to the <termref def="dt-result-tree">result tree</termref>.</p>
                  </item>
                  <item>
                     <p>A namespace node whose string value is a <termref def="dt-target-namespace-uri">target namespace URI</termref> is copied to
                        the <termref def="dt-result-tree">result tree</termref>, whether or not the
                        URI identifies an excluded namespace.</p>
                  </item>
               </ulist>
               <p>In the event that the same URI is used as a <termref def="dt-literal-namespace-uri">literal namespace URI</termref> and a <termref def="dt-target-namespace-uri">target namespace URI</termref>, the second of
                  these rules takes precedence.</p>
               <note>
                  <p>These rules achieve the effect that the element generated from the literal
                     result element will have an in-scope namespace node that binds the
                        <code>result-prefix</code> to the <termref def="dt-target-namespace-uri">target namespace URI</termref>, provided that the namespace declaration
                     associating this prefix with this URI is in scope for both the
                        <elcode>xsl:namespace-alias</elcode> instruction and for the literal result
                     element. Conversely, the <code>stylesheet-prefix</code> and the <termref def="dt-literal-namespace-uri">literal namespace URI</termref> will not
                     normally appear in the <termref def="dt-result-tree">result tree</termref>.</p>
               </note>
               <example>
                  <head>Using <elcode>xsl:namespace-alias</elcode> to Generate a Stylesheet</head>
                  <p>When literal result elements are being used to create element, attribute, or
                     namespace nodes that use the <termref def="dt-xslt-namespace">XSLT
                        namespace</termref> URI, the stylesheet may use an alias. </p>
                  <p>For example, the stylesheet</p>
                  <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="file://namespace.alias"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;axsl:stylesheet version="3.0"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/axsl:stylesheet&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="elements"&gt;
  &lt;axsl:template match="/"&gt;
     &lt;axsl:comment select="system-property('xsl:version')"/&gt;
     &lt;axsl:apply-templates/&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="block"&gt;
  &lt;axsl:template match="{.}"&gt;
     &lt;fo:block&gt;&lt;axsl:apply-templates/&gt;&lt;/fo:block&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
                  <p>will generate an XSLT stylesheet from a document of the form:</p>
                  <eg xml:space="preserve" role="xml">&lt;elements&gt;
&lt;block&gt;p&lt;/block&gt;
&lt;block&gt;h1&lt;/block&gt;
&lt;block&gt;h2&lt;/block&gt;
&lt;block&gt;h3&lt;/block&gt;
&lt;block&gt;h4&lt;/block&gt;
&lt;/elements&gt;</eg>
                  <p>The output of the transformation will be a stylesheet such as the following.
                     Whitespace has been added for clarity. Note that an implementation may output
                     different namespace prefixes from those appearing in this example; however, the
                     rules guarantee that there will be a namespace node that binds the prefix
                        <code>xsl</code> to the URI
                        <code>http://www.w3.org/1999/XSL/Transform</code>, which makes it safe to
                     use the QName <code>xsl:version</code> in the content of the generated
                     stylesheet.</p>
                  <eg xml:space="preserve" role="xslt-document">&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:comment select="system-property('xsl:version')"/&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="p"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h1"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h2"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h3"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h4"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>

               </example>
               <note>
                  <p>It may be necessary also to use aliases for namespaces other than the XSLT
                     namespace URI. For example, it can be useful to define an alias for the
                     namespace <code>http://www.w3.org/2001/XMLSchema-instance</code>, so that the
                     stylesheet can use the attributes <code>xsi:type</code>, <code>xsi:nil</code>,
                     and <code>xsi:schemaLocation</code> on a literal result element, without
                     running the risk that a schema processor will interpret these as applying to
                     the stylesheet itself. Equally, literal result elements belonging to a
                     namespace dealing with digital signatures might cause XSLT stylesheets to be
                     mishandled by general-purpose security software; using an alias for the
                     namespace would avoid the possibility of such mishandling.</p>
               </note>
               <example>
                  <head>Aliasing the XML Namespace</head>
                  <p>It is possible to define an alias for the XML namespace.</p>
                  <eg xml:space="preserve" role="xslt-document">
&lt;xsl:stylesheet xmlns:axml="http://www.example.com/alias-xml"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="3.0"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axml" result-prefix="xml"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;name axml:space="preserve"&gt;
    &lt;first&gt;James&lt;/first&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;last&gt;Clark&lt;/last&gt;
  &lt;/name&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
                  <p>produces the output:</p>
                  <eg xml:space="preserve" role="xml">&lt;name xml:space="preserve"&gt;&lt;first&gt;James&lt;/first&gt; &lt;last&gt;Clark&lt;/last&gt;&lt;/name&gt;</eg>
                  <p>This allows an <code>xml:space</code> attribute to be generated in the output
                     without affecting the way the stylesheet is parsed. The same technique can be
                     used for other attributes such as <code>xml:lang</code>, <code>xml:base</code>,
                     and <code>xml:id</code>.</p>
               </example>
               <note>
                  <p>Namespace aliasing is only necessary when literal result elements are used. The
                     problem of reserved namespaces does not arise when using
                        <elcode>xsl:element</elcode> and <elcode>xsl:attribute</elcode> to construct
                     the <termref def="dt-result-tree">result tree</termref>. Therefore, as an
                     alternative to using <elcode>xsl:namespace-alias</elcode>, it is always
                     possible to achieve the desired effect by replacing literal result elements
                     with <elcode>xsl:element</elcode> and <elcode>xsl:attribute</elcode>
                     instructions.</p>
               </note>
            </div3>
            
         </div2>
         <div2 id="xsl-element">
            <head>Creating Element Nodes Using <code>xsl:element</code>
            </head>
            <?element xsl:element?>
            <p>The <elcode>xsl:element</elcode> instruction allows an element to be created with a
               computed name. The <termref def="dt-expanded-qname">expanded QName</termref> of the
               element to be created is specified by a <rfc2119>required</rfc2119>
               <code>name</code> attribute and an optional <code>namespace</code> attribute.</p>
            <p>The result of evaluating the <elcode>xsl:element</elcode> instruction, in usual circumstances, is the newly constructed
               element node.</p>

            <div3 id="xsl-element-content">
               <head>The Content of the Constructed Element Node</head>

               <p>The content of the <elcode>xsl:element</elcode> instruction is a <termref def="dt-sequence-constructor">sequence constructor</termref> for the children,
                  attributes, and namespaces of the created element. The sequence obtained by
                  evaluating this sequence constructor (see <specref ref="sequence-constructors"/>)
                  is used to construct the content of the element, as described in <specref ref="constructing-complex-content"/>.</p>
               <p>The <elcode>xsl:element</elcode> element may have a
                     <code>use-attribute-sets</code> attribute, whose value is a
                  whitespace-separated list of QNames that identify
                     <elcode>xsl:attribute-set</elcode> declarations. If this attribute is present,
                  it is expanded as described in <specref ref="attribute-sets"/> to produce a
                  sequence of attribute nodes. This sequence is prepended to the sequence produced
                  as a result of evaluating the <termref def="dt-sequence-constructor"/>, as
                  described in <specref ref="constructing-complex-content"/>.</p>
            </div3>
            <div3 id="xsl-element-name">
               <head>The Name of the Constructed Element Node</head>

               <p>The <code>name</code> attribute is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>, whose
                     <termref def="dt-effective-value">effective value</termref>
                  <rfc2119>must</rfc2119> be a <termref def="dt-lexical-qname">lexical
                     QName</termref>.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0820">
                     <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the <termref def="dt-effective-value">effective value</termref> of the
                           <code>name</code> attribute <error.extra>of the
                              <elcode>xsl:element</elcode> instruction</error.extra> is not a
                           <termref def="dt-lexical-qname">lexical QName</termref>. </p>
                  </error>
               </p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0830">
                     <p>In the case of an <elcode>xsl:element</elcode> instruction with no
                           <code>namespace</code> attribute, it is a <termref def="dt-dynamic-error"> dynamic
                           error</termref> if the <termref def="dt-effective-value">effective
                           value</termref> of the <code>name</code> attribute is a <termref def="dt-lexical-qname">lexical QName</termref> whose prefix is not
                        declared in an in-scope namespace declaration for the
                           <elcode>xsl:element</elcode> instruction.</p>
                  </error>
               </p>
               <p>If the <code>namespace</code> attribute is not present then the <termref def="dt-lexical-qname">lexical QName</termref> is expanded into an <termref def="dt-expanded-qname">expanded QName</termref> using the namespace
                  declarations in effect for the <elcode>xsl:element</elcode> element, including any
                  default namespace declaration.</p>
               <p>If the <code>namespace</code> attribute is present, then it too is interpreted as
                  an <termref def="dt-attribute-value-template">attribute value template</termref>.
                  The <termref def="dt-effective-value">effective value</termref>
                  <rfc2119>must</rfc2119> be in the lexical space of the <code>xs:anyURI</code>
                  type. If the string is zero-length, then the <termref def="dt-expanded-qname">expanded QName</termref> of the element has a null namespace URI. Otherwise,
                  the string is used as the namespace URI of the <termref def="dt-expanded-qname">expanded QName</termref> of the element to be created. The local part of the
                     <termref def="dt-lexical-qname">lexical QName</termref> specified by the
                     <code>name</code> attribute is used as the local part of the <termref def="dt-expanded-qname">expanded QName</termref> of the element to be
                  created.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="0835">
                     <!--Text replaced by erratum E6 change 2"-->
                     <p> It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the <termref def="dt-effective-value">effective value</termref> of the
                           <code>namespace</code> attribute <error.extra>of the
                              <elcode>xsl:element</elcode> instruction</error.extra> is not in the
                        lexical space of the <code>xs:anyURI</code> datatype or if it is the string
                           <code>http://www.w3.org/2000/xmlns/</code>.</p>
                     <!--End of text replaced by erratum E6-->
                  </error>
               </p>
               <note>
                  <p>The XDM data model requires the name of a node to be an instance of
                        <code>xs:QName</code>, and XML Schema defines the namespace part of an
                        <code>xs:QName</code> to be an instance of <code>xs:anyURI</code>. However,
                     the schema specification, and the specifications that it refers to, give
                     implementations some flexibility in how strictly they enforce these
                     constraints.</p>
               </note>
               <p>The prefix of the <termref def="dt-lexical-qname">lexical QName</termref>
                  specified in the <code>name</code> attribute (or the absence of a prefix) is
                  copied to the prefix part of the <termref def="dt-expanded-qname">expanded
                     QName</termref> representing the name of the new element node. In the event of
                  a conflict a prefix may subsequently be added, changed, or removed during the
                  namespace fixup process (see <specref ref="namespace-fixup"/>).<!--Text inserted by erratum E6 change 3"--> The term <emph>conflict</emph>
                  here means any violation of the constraints defined in <bibref ref="xpath-datamodel-30"/>, for example the use of the same prefix to refer to
                  two different namespaces in the element and in one of its attributes, the use of
                  the prefix <code>xml</code> to refer to a namespace other than the XML namespace,
                  or any use of the prefix
                  <code>xmlns</code>.<!--End of text inserted by erratum E6--></p>
            </div3>
            <div3 id="xsl-element-properties">
               <head>Other Properties of the Constructed Element Node</head>

               <p>The <elcode>xsl:element</elcode> instruction has an optional
                     <code>inherit-namespaces</code> attribute, with the value <code>yes</code> or
                     <code>no</code>. The default value is <code>yes</code>. If the value is set to
                     <code>yes</code>, or is omitted, then the namespace nodes created for the newly
                  constructed element (whether these were copied from those of the source node, or
                  generated as a result of namespace fixup) are copied to the children and
                  descendants of the newly constructed element, as described in <specref ref="constructing-complex-content"/>. If the value is set to <code>no</code>,
                  then these namespace nodes are not automatically copied to the children. This may
                  result in namespace undeclarations (such as <code>xmlns=""</code> or, in the case
                  of XML Namespaces 1.1, <code>xmlns:p=""</code>) appearing on the child elements
                  when 
                  the element is serialized.</p>
               <p>The base URI of the new element is copied from the base URI of the
                     <elcode>xsl:element</elcode> instruction in the stylesheet, unless the content
                  of the new element includes an <code>xml:base</code> attribute, in which case the
                  base URI of the new element is the value of that attribute, resolved (if it is a
                  relative URI) against the base URI of the <elcode>xsl:element</elcode> instruction
                  in the stylesheet. (Note, however, that this is only relevant when creating
                  parentless elements. When the new element is copied to form a child of an element
                  or document node, the base URI of the new copy is taken from that of its new
                  parent.)</p>
               <p>The values of the <code>nilled</code>,
                     <code>is-id</code>, and <code>is-idrefs</code> properties of the new element
                  depend on the <code>type</code> and <code>validation</code> attributes of the
                     <elcode>xsl:element</elcode> instruction, as explained in <specref ref="validation"/>.</p>
            </div3>
            <div3 id="annotation-for-constructed-element">
               <head>The Type Annotation of the Constructed Element Node</head>
               <p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <elcode>xsl:element</elcode> instruction to invoke validation of the
                  contents of the element against a type definition or element declaration in a
                  schema, and to determine the <termref def="dt-type-annotation">type
                     annotation</termref> that the new element node will carry. These attributes
                  also affect the type annotation carried by any elements and attributes that have
                  the new element node as an ancestor. These two attributes are both optional, and
                  if one is specified then the other <rfc2119>must</rfc2119> be omitted. The
                  permitted values of these attributes and their semantics are described in <specref ref="validation"/>.</p>
               <note>
                  <p>The final type annotation of the element in the <termref def="dt-result-tree">result tree</termref> also depends on the <code>type</code> and
                        <code>validation</code> attributes of the instructions used to create the
                     ancestors of the element.</p>
               </note>
            </div3>
            
         </div2>
         <div2 id="creating-attributes">
            <head>Creating Attribute Nodes Using <code>xsl:attribute</code>
            </head>
            <?element xsl:attribute?>
            <p>The <elcode>xsl:attribute</elcode> element can be used to add attributes to result
               elements whether created by literal result elements in the stylesheet or by
               instructions such as <elcode>xsl:element</elcode> or <elcode>xsl:copy</elcode>. The
                  <termref def="dt-expanded-qname">expanded QName</termref> of the attribute to be
               created is specified by a <rfc2119>required</rfc2119>
               <code>name</code> attribute and an optional <code>namespace</code> attribute. Except
               in error cases, the result of evaluating an <elcode>xsl:attribute</elcode>
               instruction is the newly constructed attribute node.</p>
            <p>The string value of the new attribute node may be defined either by using the
                  <code>select</code> attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the content of the
                  <elcode>xsl:attribute</elcode> element. These are
                  mutually exclusive: if the <code>select</code> attribute is present then the
                  sequence constructor must be empty, and if the sequence constructor is non-empty
                  then the <code>select</code> attribute must be absent. If the <code>select</code>
                  attribute is absent and the sequence constructor is empty, then the
               string value of the new attribute node will be a zero-length string. The way in which
               the value is constructed is specified in <specref ref="constructing-simple-content"/>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0840">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:attribute</elcode> element
                     is present unless the element has empty content.</p>
               </error>
            </p>
            <p>If the <code>separator</code> attribute is present, then the <termref def="dt-effective-value">effective value</termref> of this attribute is used to
               separate adjacent items in the result sequence, as described in <specref ref="constructing-simple-content"/>. In the absence of this attribute, the default
               separator is a single space (#x20) when the content is specified using the
                  <code>select</code> attribute, or a zero-length string when the content is
               specified using a <termref def="dt-sequence-constructor">sequence
                  constructor</termref>.</p>
            <p>The <code>name</code> attribute is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>, whose
                  <termref def="dt-effective-value">effective value</termref>
               <rfc2119>must</rfc2119> be a <termref def="dt-lexical-qname">lexical
               QName</termref>.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0850">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the <termref def="dt-effective-value">effective value</termref> of the <code>name</code>
                     attribute <error.extra>of an <elcode>xsl:attribute</elcode>
                        instruction</error.extra> is not a <termref def="dt-lexical-qname">lexical
                        QName</termref>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0855">
                  <p>In the case of an <elcode>xsl:attribute</elcode> instruction with no
                        <code>namespace</code> attribute, it is a <termref def="dt-dynamic-error"> dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>name</code> attribute is the string
                        <code>xmlns</code>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0860">
                  <p>In the case of an <elcode>xsl:attribute</elcode> instruction with no
                        <code>namespace</code> attribute, it is a <termref def="dt-dynamic-error"> dynamic
                        error</termref> if the <termref def="dt-effective-value">effective
                        value</termref> of the <code>name</code> attribute is a <termref def="dt-lexical-qname">lexical QName</termref> whose prefix is not declared
                     in an in-scope namespace declaration for the <elcode>xsl:attribute</elcode>
                     instruction.</p>
               </error>
            </p>
            <p>If the <code>namespace</code> attribute is not present, then the <termref def="dt-lexical-qname">lexical QName</termref> is expanded into an <termref def="dt-expanded-qname">expanded QName</termref> using the namespace declarations
               in effect for the <elcode>xsl:attribute</elcode> element, <emph>not</emph> including
               any default namespace declaration.</p>
            <p>If the <code>namespace</code> attribute is present, then it too is interpreted as an
                  <termref def="dt-attribute-value-template">attribute value template</termref>. The
                  <termref def="dt-effective-value">effective value</termref>
               <rfc2119>must</rfc2119> be in the lexical space of the <code>xs:anyURI</code> type.
               If the string is zero-length, then the <termref def="dt-expanded-qname">expanded
                  QName</termref> of the attribute has a null namespace URI. Otherwise, the string
               is used as the namespace URI of the <termref def="dt-expanded-qname">expanded
                  QName</termref> of the attribute to be created. The local part of the <termref def="dt-lexical-qname">lexical QName</termref> specified by the <code>name</code>
               attribute is used as the local part of the <termref def="dt-expanded-qname">expanded
                  QName</termref> of the attribute to be created.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0865">
                  <!--Text replaced by erratum E6 change 4"-->
                  <p> It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the <termref def="dt-effective-value">effective value</termref> of the
                        <code>namespace</code> attribute <error.extra>of the
                           <elcode>xsl:attribute</elcode> instruction</error.extra> is not in the
                     lexical space of the <code>xs:anyURI</code> datatype or if it is the string
                        <code>http://www.w3.org/2000/xmlns/</code>.</p>
                  <!--End of text replaced by erratum E6-->
               </error>
            </p>
            <note>
               <p>The same considerations apply as for elements: <errorref spec="XT" class="DE" code="0835"/> in <specref ref="xsl-element"/>.</p>
            </note>
            <!--Text replaced by erratum E18 change 1"-->
            <p>The prefix of the <termref def="dt-lexical-qname">lexical QName</termref> specified
               in the <code>name</code> attribute (or the absence of a prefix) is copied to the
               prefix part of the <termref def="dt-expanded-qname">expanded QName</termref>
               representing the name of the new attribute node. In the event of a conflict this
               prefix may subsequently be added, changed, or removed during the namespace fixup
               process (see <specref ref="namespace-fixup"/>). If the attribute is in a non-null
               namespace and no prefix is specified, then the namespace fixup process will invent a
               prefix. The term <emph>conflict</emph> here means any violation of the constraints
               defined in <bibref ref="xpath-datamodel-30"/>, for example the use of the same prefix
               to refer to two different namespaces in the element and in one of its attributes, the
               use of the prefix <code>xml</code> to refer to a namespace other than the XML
               namespace, or any use of the prefix <code>xmlns</code>.</p>
            <!--End of text replaced by erratum E18-->
            <p>If the name of a constructed attribute is <code>xml:id</code>, the processor must
               perform attribute value normalization by effectively applying the
                  <xfunction>normalize-space</xfunction> function to the value of the attribute, and
               the resulting attribute node must be given the <code>is-id</code> property. This
               applies whether the attribute is constructed using the <elcode>xsl:attribute</elcode>
               instruction or whether it is constructed using an attribute of a literal result
               element. This does not imply any constraints on the value of the attribute, or on its
               uniqueness, and it does not affect the <termref def="dt-type-annotation">type
                  annotation</termref> of the attribute, unless the containing document is
               validated.</p>
            <note>
               <p>The effect of setting the <code>is-id</code> property is that the parent element
                  can be located within the containing document by use of the
                     <xfunction>id</xfunction> function. In effect, XSLT when constructing a
                  document performs some of the functions of an <code>xml:id</code> processor, as
                  defined in <bibref ref="xml-id"/>; the other aspects of <code>xml:id</code>
                  processing are performed during validation.</p>
            </note>
            <example>
               <head>Creating a List-Valued Attribute</head>
               <p>The following instruction creates the attribute <code>colors="red green
                     blue"</code>:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:attribute name="colors" select="'red', 'green', 'blue'"/&gt;</eg>
            </example>
            <example>
               <head>Namespaces are not Attributes</head>
               <p>It is not an error to write:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:attribute name="xmlns:xsl" 
   namespace="file://some.namespace"
   select="'http://www.w3.org/1999/XSL/Transform'"/&gt;</eg>
               <p>However, this will not result in the namespace declaration
                     <code>xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</code> being output.
                  Instead, it will produce an attribute node with local name <code>xsl</code>, and
                  with a system-allocated namespace prefix mapped to the namespace URI
                     <code>file://some.namespace</code>. This is because the namespace fixup process
                  is not allowed to use <code>xmlns</code> as the name of a namespace node.</p>
            </example>
            <p>As described in <specref ref="constructing-complex-content"/>, in a sequence that is
               used to construct the content of an element, any attribute nodes
                  <rfc2119>must</rfc2119> appear in the sequence before any element, text, comment,
               or processing instruction nodes. Where the sequence contains two or more attribute
               nodes with the same <termref def="dt-expanded-qname">expanded QName</termref>, the
               one that comes last is the only one that takes effect.</p>
            <note>
               <p>If a collection of attributes is generated repeatedly, this can be done
                  conveniently by using named attribute sets: see <specref ref="attribute-sets"/>
               </p>
            </note>
            <div3 id="annotation-for-constructed-attribute">
               <head>Setting the Type Annotation for a Constructed Attribute Node</head>
               <p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <elcode>xsl:attribute</elcode> instruction to invoke validation of the
                  contents of the attribute against a type definition or attribute declaration in a
                  schema, and to determine the <termref def="dt-type-annotation">type
                     annotation</termref> that the new attribute node will carry. These two
                  attributes are both optional, and if one is specified then the other
                     <rfc2119>must</rfc2119> be omitted. The permitted values of these attributes
                  and their semantics are described in <specref ref="validation"/>.</p>
               <p>The process of validation also determines the values of
                  the <code>is-id</code> and <code>is-idrefs</code> properties on the new attribute
                  node.</p>
               <note>
                  <p>The final <termref def="dt-type-annotation"/> of the attribute in the <termref def="dt-result-tree">result tree</termref> also depends on the
                        <code>type</code> and <code>validation</code> attributes of the instructions
                     used to create the ancestors of the attribute.</p>
               </note>
            </div3>
            
         </div2>
         <div2 id="creating-text-nodes">
            <head>Creating Text Nodes</head>
            <p>This section describes three different ways of creating text nodes: by means of
               literal text nodes in the stylesheet, or by using the <elcode>xsl:text</elcode> and
                  <elcode>xsl:value-of</elcode> instructions. It is also possible to create text
               nodes using the <elcode>xsl:number</elcode> instruction described in <specref ref="number"/>.</p>
            <p>If and when the sequence that results from evaluating a <termref def="dt-sequence-constructor">sequence constructor</termref> is used to form the
               content of a node, as described in <specref ref="constructing-simple-content"/> and
                  <specref ref="constructing-complex-content"/>, adjacent text nodes in the sequence
               are merged. Within the sequence itself, however, they exist as distinct nodes.</p>
            <example>
               <head>A Sequence of Text Nodes</head>
               <p>The following function returns a sequence of three text nodes:</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:f='f'">&lt;xsl:function name="f:wrap"&gt;
  &lt;xsl:param name="s"/&gt;
  &lt;xsl:text&gt;(&lt;/xsl:text&gt;
  &lt;xsl:value-of select="$s"/&gt;
  &lt;xsl:text&gt;)&lt;/xsl:text&gt;
&lt;/xsl:function&gt;</eg>
               <p>When this function is called as follows:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:value-of select="f:wrap('---')"/&gt;</eg>
               <p>the result is:</p>
               <eg xml:space="preserve" role="non-xml">(---)</eg>
               <p>No additional spaces are inserted, because the calling
                     <elcode>xsl:value-of</elcode> instruction merges adjacent text nodes before
                  atomizing the sequence. However, the result of the instruction:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:value-of select="data(f:wrap('---'))"/&gt;</eg>
               <p>is:</p>
               <eg xml:space="preserve" role="non-xml">( --- )</eg>
               <p>because in this case the three text nodes are atomized to form three strings, and
                  spaces are inserted between adjacent strings.</p>
            </example>
            <p>It is possible to construct text nodes whose string value is zero-length. A
               zero-length text node, when atomized, produces a zero-length string. However,
               zero-length text nodes are ignored when they appear in a sequence that is used to
               form the content of a node, as described in <specref ref="constructing-complex-content"/> and <specref ref="constructing-simple-content"/>.</p>
            <div3 id="literal-text-nodes">
               <head>Literal Text Nodes</head>
               <p>A <termref def="dt-sequence-constructor"/> can contain text nodes. Each text node
                  in a sequence constructor remaining after <termref def="dt-whitespace-text-node">whitespace text nodes</termref> have been stripped as specified in <specref ref="stylesheet-stripping"/> will construct a new text node with the same
                     <termref def="dt-string-value">string value</termref>. The resulting text node
                  is added to the result of the containing sequence constructor.</p>
               <p>Text is processed at the tree level. Thus, markup of <code>&amp;lt;</code> in a
                  template will be represented in the stylesheet tree by a text node that includes
                  the character <code>&lt;</code>. This will create a text node in the <termref def="dt-result-tree">result tree</termref> that contains a <code>&lt;</code>
                  character, which will be represented by the markup <code>&amp;lt;</code> (or an
                  equivalent character reference) when the result tree is serialized as an XML
                  document, unless otherwise specified using <termref def="dt-character-map">character maps</termref> (see <specref ref="character-maps"/>) or
                     <code>disable-output-escaping</code> (see <specref ref="disable-output-escaping"/>).</p>
            </div3>
            <div3 id="xsl-text">
               <head>Creating Text Nodes Using <code>xsl:text</code>
               </head>
               <?element xsl:text?>
               <p>The <elcode>xsl:text</elcode> element is evaluated to construct a new text
                  node.</p>

               <p>If the element or one of its ancestors has an
                     <code>[xsl:]expand-text</code> attribute, and the nearest ancestor with such an
                  attribute has the value <code>yes</code>, then any unescaped curly brackets in the
                  value of the element indicate the presence of <termref def="dt-text-value-template">text value templates</termref>, which are expanded
                  as described in <specref ref="text-value-templates"/>.</p>

               <p>In the absence of such an attribute, or if the
                     effective value is <code>no</code>, the content of the
                     <elcode>xsl:text</elcode> element is a single text node whose value forms the
                     <termref def="dt-string-value">string value</termref> of the new text node. An
                     <elcode>xsl:text</elcode> element may be empty, in which case the result of
                  evaluating the instruction is a text node whose string value is the zero-length
                  string.</p>
               <p>The result of evaluating an <elcode>xsl:text</elcode> instruction is the newly
                  constructed text node.</p>
               <p>A text node that is an immediate child of an <elcode>xsl:text</elcode> instruction
                  will not be stripped from the stylesheet tree, even if it consists entirely of
                  whitespace (see <specref ref="strip"/>).</p>
               <p>For the effect of the <termref def="dt-deprecated">deprecated</termref>
                  <code>disable-output-escaping</code> attribute, see <specref ref="disable-output-escaping"/>
               </p>
               <note>
                  <p>It is not always necessary to use the <elcode>xsl:text</elcode> instruction to
                     write text nodes to the <termref def="dt-result-tree">result tree</termref>.
                     Literal text can be written to the result tree by including it anywhere in a
                        <termref def="dt-sequence-constructor"/>, while computed text can be output
                     using the <elcode>xsl:value-of</elcode> instruction. The principal reason for
                     using <elcode>xsl:text</elcode> is that it offers improved control over
                     whitespace handling.</p>
               </note>
            </div3>
            <div3 id="value-of">
               <head>Generating Text with <elcode>xsl:value-of</elcode>
               </head>
               <p>Within a <termref def="dt-sequence-constructor"/>, the
                     <elcode>xsl:value-of</elcode> instruction can be used to generate computed text
                  nodes. The <elcode>xsl:value-of</elcode> instruction computes the text using an
                     <termref def="dt-expression">expression</termref> that is specified as the
                  value of the <code>select</code> attribute, or by means of contained instructions.
                  This might, for example, extract text from a <termref def="dt-source-tree">source
                     tree</termref> or insert the value of a variable. </p>
               <?element xsl:value-of?>
               <p>The <elcode>xsl:value-of</elcode> instruction is evaluated to construct a new text
                  node; the result of the instruction is the newly constructed text node.</p>
               <p>The string value of the new text node may be defined either by using the
                     <code>select</code> attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> (see <specref ref="sequence-constructors"/>)
                  that forms the content of the <elcode>xsl:value-of</elcode> element. These are mutually exclusive: if the <code>select</code>
                     attribute is present then the sequence constructor must be empty, and if the
                     sequence constructor is non-empty then the <code>select</code> attribute must
                     be absent. If the <code>select</code> attribute is absent and the sequence
                     constructor is empty, then the result of the instruction is a text node whose
                     string value is zero-length. The way in which the value is constructed
                  is specified in <specref ref="constructing-simple-content"/>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="0870">
                     <p>It is a <termref def="dt-static-error">static error</termref> if the
                           <code>select</code> attribute of the <elcode>xsl:value-of</elcode>
                        element is present when the content of the element is non-empty.</p>
                  </error>
               </p>
               <p>If the <code>separator</code> attribute is present, then the <termref def="dt-effective-value">effective value</termref> of this attribute is used to
                  separate adjacent items in the result sequence, as described in <specref ref="constructing-simple-content"/>. In the absence of this attribute, the
                  default separator is a single space (#x20) when the content is specified using the
                     <code>select</code> attribute, or a zero-length string when the content is
                  specified using a <termref def="dt-sequence-constructor">sequence
                     constructor</termref>.</p>
               <p>Special rules apply when the instruction is processed
                     with <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref>.
                  If no <code>separator</code> attribute is present, and if the <code>select</code>
                  attribute is present, then all items in the <termref def="dt-atomization">atomized</termref> result sequence other than the first are ignored.</p>
               <example>
                  <head>Generating a List with Separators</head>
                  <p>The instruction:</p>
                  <eg xml:space="preserve" role="xslt-fragment">&lt;x&gt;&lt;xsl:value-of select="1 to 4" separator="|"/&gt;&lt;/x&gt;</eg>
                  <p>produces the output:</p>
                  <eg xml:space="preserve" role="xml">&lt;x&gt;1|2|3|4&lt;/x&gt;</eg>
               </example>
               <note>
                  <p>The <elcode>xsl:copy-of</elcode> element can be used to copy a sequence of
                     nodes to the <termref def="dt-result-tree">result tree</termref> without
                        <termref def="dt-atomization">atomization</termref>. See <specref ref="copy-of"/>.</p>
               </note>
               <p>For the effect of the <termref def="dt-deprecated">deprecated</termref>
                  <code>disable-output-escaping</code> attribute, see <specref ref="disable-output-escaping"/>
               </p>
            </div3>
         </div2>
         <div2 id="creating-document-nodes">
            <head>Creating Document Nodes</head>
            <?element xsl:document?>
            <p>The <elcode>xsl:document</elcode> instruction is used to create a new document node.
               The content of the <elcode>xsl:document</elcode> element is a <termref def="dt-sequence-constructor">sequence constructor</termref> for the children of
               the new document node. A document node is created, and the sequence obtained by
               evaluating the sequence constructor is used to construct the content of the document,
               as described in <specref ref="constructing-complex-content"/>. </p>
            <p>Except in error situations, the result of evaluating the
                  <elcode>xsl:document</elcode> instruction is a single node, the newly constructed
               document node.</p>
            <note>
               <p>The new document is not serialized. To construct a document that is to form a
                  final result rather than an intermediate result, use the
                     <elcode>xsl:result-document</elcode> instruction described in <specref ref="creating-result-trees"/>.</p>
            </note>
            <p>The optional attributes <code>type</code> and <code>validation</code> may be used on
               the <elcode>xsl:document</elcode> instruction to validate the contents of the new
               document, and to determine the <termref def="dt-type-annotation"/> that elements and
               attributes within the <termref def="dt-result-tree">result tree</termref> will carry.
               The permitted values and their semantics are described in <specref ref="validating-document-nodes"/>.</p>
            <p>The base URI of the new document node is taken from the base URI of the
                  <elcode>xsl:document</elcode> instruction.</p>
            <p>The <code>document-uri</code> and <code>unparsed-entities</code> properties of the
               new document node are set to empty.</p>
            <example>
               <head>Checking Uniqueness Constraints in a Temporary Tree</head>
               <p>The following example creates a temporary tree held in a variable. The use of an
                  enclosed <elcode>xsl:document</elcode> instruction ensures that uniqueness
                  constraints defined in the schema for the relevant elements are checked.</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:document&gt;
&lt;/xsl:variable&gt;</eg>
            </example>
         </div2>
         <div2 id="creating-processing-instructions">
            <head>Creating Processing Instructions</head>
            <?element xsl:processing-instruction?>
            <p>The <elcode>xsl:processing-instruction</elcode> element is evaluated to create a
               processing instruction node.</p>
            <p>The <elcode>xsl:processing-instruction</elcode> element has a
                  <rfc2119>required</rfc2119>
               <code>name</code> attribute that specifies the name of the processing instruction
               node. The value of the <code>name</code> attribute is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>.</p>
            <p>The string value of the new processing-instruction node may be defined either by
               using the <code>select</code> attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the
               content of the <elcode>xsl:processing-instruction</elcode> element. These are mutually exclusive: if the <code>select</code>
                  attribute is present then the sequence constructor must be empty, and if the
                  sequence constructor is non-empty then the <code>select</code> attribute must be
                  absent. If the <code>select</code> attribute is absent and the sequence
                  constructor is empty, then the string value of the new
               processing-instruction node will be a zero-length string. The way in which the value
               is constructed is specified in <specref ref="constructing-simple-content"/>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0880">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the
                        <elcode>xsl:processing-instruction</elcode> element is present unless the
                     element has empty content.</p>
               </error>
            </p>
            <p>Except in error situations, the result of evaluating the
                  <elcode>xsl:processing-instruction</elcode> instruction is a single node, the
               newly constructed processing instruction node.</p>
            <example>
               <head>Creating a Processing Instruction</head>
               <p>This instruction:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:processing-instruction name="xml-stylesheet"
  select="('href=&amp;quot;book.css&amp;quot;', 'type=&amp;quot;text/css&amp;quot;')"/&gt;</eg>
               <p>creates the processing instruction</p>
               <eg xml:space="preserve" role="non-xml">&lt;?xml-stylesheet href="book.css" type="text/css"?&gt;</eg>
               <p>Note that the <code>xml-stylesheet</code> processing instruction contains
                     <emph>pseudo-attributes</emph> in the form <code>name="value"</code>. Although
                  these have the same textual form as attributes in an element start tag, they are
                  not represented as XDM attribute nodes, and cannot therefore be constructed using
                     <elcode>xsl:attribute</elcode> instructions.</p>
            </example>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0890">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the <termref def="dt-effective-value">effective value</termref> of the <code>name</code>
                     attribute <error.extra>of the <elcode>xsl:processing-instruction</elcode>
                        instruction</error.extra> is not both an <xnt spec="Names" ref="NT-NCName">NCName</xnt> and a <xnt spec="XML" ref="PITarget">PITarget</xnt>.</p>
               </error>
            </p>
            <note>
               <p>Because these rules disallow the name <code>xml</code>, the
                     <elcode>xsl:processing-instruction</elcode> cannot be used to output an XML
                  declaration. The <elcode>xsl:output</elcode> declaration should be used to control
                  this instead (see <specref ref="serialization"/>).</p>
            </note>
            <p>If the result of evaluating the content of the
                  <elcode>xsl:processing-instruction</elcode> contains the string
               <code>?&gt;</code>, this string is modified by inserting a space between the
                  <code>?</code> and <code>&gt;</code> characters.</p>
            <p>The base URI of the new processing-instruction is copied from the base URI of the
                  <elcode>xsl:processing-instruction</elcode> element in the stylesheet. (Note,
               however, that this is only relevant when creating a parentless processing
               instruction. When the new processing instruction is copied to form a child of an
               element or document node, the base URI of the new copy is taken from that of its new
               parent.)</p>
         </div2>
         <div2 id="creating-namespace-nodes">
            <head>Creating Namespace Nodes</head>
            <?element xsl:namespace?>
            <p>The <elcode>xsl:namespace</elcode> element is evaluated to create a namespace node.
               Except in error situations, the result of evaluating the
                  <elcode>xsl:namespace</elcode> instruction is a single node, the newly constructed
               namespace node.</p>
            <p>The <elcode>xsl:namespace</elcode> element has a <rfc2119>required</rfc2119>
               <code>name</code> attribute that specifies the name of the namespace node (that is,
               the namespace prefix). The value of the <code>name</code> attribute is interpreted as
               an <termref def="dt-attribute-value-template">attribute value template</termref>. If
               the <termref def="dt-effective-value">effective value</termref> of the
                  <code>name</code> attribute is a zero-length string, a namespace node is added for
               the default namespace.</p>
            <p>The string value of the new namespace node (that is, the namespace URI) may be
               defined either by using the <code>select</code> attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the
               content of the <elcode>xsl:namespace</elcode> element. These are mutually exclusive: if the <code>select</code> attribute is present
                  then the sequence constructor must be empty, and if the sequence constructor is
                  non-empty then the <code>select</code> attribute must be absent. Since
               the string value of a namespace node cannot be a zero-length string, either a <code>select</code> attribute or a non-empty sequence
                  constructor <rfc2119>must</rfc2119> be present. The way in which the
               value is constructed is specified in <specref ref="constructing-simple-content"/>.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0905">
                  <!--Text replaced by erratum E6 change 6"-->
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the string value of
                     the new namespace node is not valid in the lexical space of the datatype
                        <code>xs:anyURI</code>, or if it is the string
                        <code>http://www.w3.org/2000/xmlns/</code>.</p>
                  <!--End of text replaced by erratum E6-->
               </error>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="0910">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:namespace</elcode> element
                     is present when the element has content other than one or more
                        <elcode>xsl:fallback</elcode> instructions, or if the <code>select</code>
                     attribute is absent when the element has empty content.</p>
               </error>
            </p>
            <p>Note the restrictions described in <specref ref="constructing-complex-content"/> for
               the position of a namespace node relative to other nodes in the node sequence
               returned by a sequence constructor.</p>
            <example>
               <head>Constructing a QName-Valued Attribute</head>
               <p>This literal result element:</p>
               <eg xml:space="preserve" role="non-xml">&lt;data xsi:type="xs:integer" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;xsl:namespace name="xs" 
                 select="'http://www.w3.org/2001/XMLSchema'"/&gt;
  &lt;xsl:text&gt;42&lt;/xsl:text&gt;
&lt;/data&gt;</eg>
               <p>would typically cause the output document to contain the element:</p>
               <eg xml:space="preserve" role="non-xml">&lt;data xsi:type="xs:integer"
     xmlns:xs="http://www.w3.org/2001/XMLSchema"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;42&lt;/data&gt;</eg>
               <p>In this case, the element is constructed using a literal result element, and the
                  namespace <code>xmlns:xs="http://www.w3.org/2001/XMLSchema"</code> could therefore
                  have been added to the <termref def="dt-result-tree">result tree</termref> simply
                  by declaring it as one of the in-scope namespaces in the stylesheet. In practice,
                  the <elcode>xsl:namespace</elcode> instruction is more likely to be useful in
                  situations where the element is constructed using an <elcode>xsl:element</elcode>
                  instruction, which does not copy all the in-scope namespaces from the
                  stylesheet.</p>
            </example>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0920">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the <termref def="dt-effective-value">effective value</termref> of the <code>name</code>
                     attribute <error.extra>of the <elcode>xsl:namespace</elcode>
                        instruction</error.extra> is neither a zero-length string nor an <xnt spec="Names" ref="NT-NCName">NCName</xnt>, or if it is <code>xmlns</code>.
                  </p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0925">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the
                        <elcode>xsl:namespace</elcode> instruction generates a namespace node whose
                     name is <code>xml</code> and whose string value is not
                        <code>http://www.w3.org/XML/1998/namespace</code>, or a namespace node whose
                     string value is <code>http://www.w3.org/XML/1998/namespace</code> and whose
                     name is not <code>xml</code>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0930">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if evaluating the
                        <code>select</code> attribute or the contained <termref def="dt-sequence-constructor"/> of an <elcode>xsl:namespace</elcode>
                     instruction results in a zero-length string. </p>
               </error>
            </p>
            <p>For details of other error conditions that may arise, see <specref ref="sequence-constructors"/>.</p>
            <note>
               <p>It is rarely necessary to use <elcode>xsl:namespace</elcode> to create a namespace
                  node in the <termref def="dt-result-tree">result tree</termref>; in most
                  circumstances, the required namespace nodes will be created automatically, as a
                  side-effect of writing elements or attributes that use the namespace. An example
                  where <elcode>xsl:namespace</elcode> is needed is a situation where the required
                  namespace is used only within attribute values in the result document, not in
                  element or attribute names; especially where the required namespace prefix or
                  namespace URI is computed at run-time and is not present in either the source
                  document or the stylesheet.</p>
               <p>Adding a namespace node to the <termref def="dt-result-tree">result tree</termref>
                  will never change the <termref def="dt-expanded-qname">expanded QName</termref> of
                  any element or attribute node in the result tree: that is, it will never change
                  the namespace URI of an element or attribute. It might, however, constrain the
                  choice of prefixes when namespace fixup is performed.</p>
               <!--Text replaced by erratum E7 change 1"-->
               <p>Namespace prefixes for element and attribute names are initially established by
                  the rules of the instruction that creates the element or attribute node, and in
                  the event of conflicts, they may be changed by the namespace fixup process
                  described in <specref ref="namespace-fixup"/>. The fixup process ensures that an
                  element has in-scope namespace nodes for the namespace URIs used in the element
                  name and in its attribute names, and the serializer will typically use these
                  namespace nodes to determine the prefix to use in the serialized output. The fixup
                  process cannot generate namespace nodes that are inconsistent with those already
                  present in the tree. This means that it is not possible for the processor to
                  decide the prefix to use for an element or for any of its attributes until all the
                  namespace nodes for the element have been added.</p>
               <!--End of text replaced by erratum E7-->
               <p>If a namespace prefix is mapped to a particular namespace URI using the
                     <elcode>xsl:namespace</elcode> instruction, or by using
                     <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode> to copy a namespace
                  node, this prevents the namespace fixup process (and hence the serializer) from
                  using the same prefix for a different namespace URI on the same element.</p>
            </note>
            <example>
               <head>Conflicting Namespace Prefixes</head>
               <p>Given the instruction:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:element name="p:item" 
                 xmlns:p="http://www.example.com/p"&gt;
  &lt;xsl:namespace name="p"&gt;http://www.example.com/q&lt;/xsl:namespace&gt;
&lt;/xsl:element&gt;</eg>
               <p>a possible serialization of the <termref def="dt-result-tree">result
                     tree</termref> is:</p>
               <eg xml:space="preserve" role="xml">&lt;ns0:item 
    xmlns:ns0="http://www.example.com/p" 
    xmlns:p="http://www.example.com/q"/&gt;</eg>
               <p>The processor must invent a namespace prefix for the URI <code>p.uri</code>; it
                  cannot use the prefix <code>p</code> because that prefix has been explicitly
                  associated with a different URI.</p>
            </example>
            <note>
               <p>The <elcode>xsl:namespace</elcode> instruction cannot be used to generate a
                     <term>namespace undeclaration</term> of the form <code>xmlns=""</code> (nor the
                  new forms of namespace undeclaration permitted in <bibref ref="xml-names11"/>).
                  Namespace undeclarations are generated automatically by the serializer if
                     <code>undeclare-prefixes="yes"</code> is specified on
                     <elcode>xsl:output</elcode>, whenever a parent element has a namespace node for
                  the default namespace prefix, and a child element has no namespace node for that
                  prefix.</p>
            </note>
         </div2>
         <div2 id="creating-comments">
            <head>Creating Comments</head>
            <?element xsl:comment?>
            <p>The <elcode>xsl:comment</elcode> element is evaluated to construct a new comment
               node. Except in error cases, the result of evaluating the
                  <elcode>xsl:comment</elcode> instruction is a single node, the newly constructed
               comment node.</p>
            <p>The string value of the new comment node may be defined either by using the
                  <code>select</code> attribute, or by the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the content of the
                  <elcode>xsl:comment</elcode> element. These are mutually
                  exclusive: if the <code>select</code> attribute is present then the sequence
                  constructor must be empty, and if the sequence constructor is non-empty then the
                     <code>select</code> attribute must be absent. If the <code>select</code>
                  attribute is absent and the sequence constructor is empty, then the
               string value of the new comment node will be a zero-length string. The way in which
               the value is constructed is specified in <specref ref="constructing-simple-content"/>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="0940">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:comment</elcode> element is
                     present unless the element has empty content.</p>
               </error>
            </p>
            <example>
               <head>Generating a Comment Node</head>
               <p>For example, this</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:comment&gt;This file is automatically generated. Do not edit!&lt;/xsl:comment&gt;</eg>
               <p>would create the comment</p>
               <eg xml:space="preserve" role="non-xml">&lt;!--This file is automatically generated. Do not edit!--&gt;</eg>
            </example>
            <p>In the generated comment node, the processor <rfc2119>must</rfc2119> insert a space
               after any occurrence of <code>x2D</code> (hyphen) that is followed by another occurrence of <code>x2D</code> (hyphen) or
               that ends the comment.</p>
         </div2>
         <div2 id="copying">
            <head>Copying Nodes</head>
            <div3 id="shallow-copy">
               <head>Shallow Copy</head>

               <?element xsl:copy?>
               <p>The <elcode>xsl:copy</elcode> instruction provides a way of copying a selected item. The selected item is the item selected by
                     evaluating the expression in the <code>select</code> attribute if present, or
                     the <termref def="dt-context-item">context item</termref> otherwise.
                  If the selected item is a node, evaluating the <elcode>xsl:copy</elcode>
                  instruction constructs a copy of the selected node, and the result of the
                     <elcode>xsl:copy</elcode> instruction is this newly constructed node. By
                  default, the namespace nodes of the context node are automatically copied as well,
                  but the attributes and children of the node are not automatically copied.</p>
               <p>
                  <error spec="XT" type="type" class="TE" code="0945">
                     <p>It is a <termref def="dt-type-error">type error</termref> to use the
                           <elcode>xsl:copy</elcode> instruction with no <code>select</code>
                        attribute when the context item is absent. </p>
                  </error>
               </p>

               <p>If the <code>select</code> expression returns an empty sequence,
                  the <elcode>xsl:copy</elcode> instruction returns an empty sequence, and the
                  contained <termref def="dt-sequence-constructor"/> is not evaluated.</p>
               <p><error spec="XT" type="type" class="TE" code="3180">
                     <p>It is a <termref def="dt-type-error">type error</termref> if the result of
                        evaluating the <code>select</code> expression <error.extra>of the
                              <elcode>xsl:copy</elcode> element</error.extra> is a sequence of more
                        than one item.</p>
                  </error></p>

               <p>When the selected item is an atomic value
                     or function item, the
                     <elcode>xsl:copy</elcode> instruction returns this value. The <termref def="dt-sequence-constructor">sequence constructor</termref> is not evaluated.
                     </p>
               <p>When the selected item is an attribute node,
                  text node, comment node, processing instruction node, or namespace node, the
                     <elcode>xsl:copy</elcode> instruction returns a new node that is a copy of the
                  context node. The new node will have the same node kind, name, and string value as
                  the context node. In the case of an attribute node, it will also have the same
                  values for the <code>is-id</code> and <code>is-idrefs</code> properties. The
                     <termref def="dt-sequence-constructor"/> is not evaluated. </p>

               <p>When the selected item is a document node or
                  element node, the <elcode>xsl:copy</elcode> instruction returns a new node that
                  has the same node kind and name as the selected
                  node. The content of the new node is formed by evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> contained in the
                     <elcode>xsl:copy</elcode> instruction. If the
                        <code>select</code> attribute is present then the sequence constructor is
                     evaluated with the selected item as the <termref def="dt-singleton-focus">singleton focus</termref>; otherwise it is evaluated using the context of
                     the <elcode>xsl:copy</elcode> instruction unchanged. The sequence
                  obtained by evaluating this sequence constructor is used (after prepending any
                  attribute nodes or namespace nodes as described in the following paragraphs) to
                  construct the content of the document or element node, as described in <specref ref="constructing-complex-content"/>.</p>

               <p>When the selected item is a document node, the
                     <code>unparsed-entities</code> property of the existing document node is copied
                  to the new document node.</p>

               <p>When the selected item is an element or attribute node,
                  the values of the <code>is-id</code>, <code>is-idrefs</code>, and
                     <code>nilled</code> properties of the new element or attribute depend on the
                  values of the <code>validation</code> and <code>type</code> attributes, as defined
                  in <specref ref="validation"/>.</p>


               
               <p>The <elcode>xsl:copy</elcode> instruction has an optional
                     <code>use-attribute-sets</code> attribute, whose value is a
                  whitespace-separated list of QNames that identify
                     <elcode>xsl:attribute-set</elcode> declarations. This attribute is used only
                  when copying element nodes. This list is expanded as described in <specref ref="attribute-sets"/> to produce a sequence of attribute nodes. This sequence
                  is prepended to the sequence produced as a result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref>.</p>
               <p>The <elcode>xsl:copy</elcode> instruction has an optional
                     <code>copy-namespaces</code> attribute, with the value <code>yes</code> or
                     <code>no</code>. The default value is <code>yes</code>. The attribute is used
                  only when copying element nodes. If the value is set to <code>yes</code>, or is
                  omitted, then all the namespace nodes of the source element are copied as
                  namespace nodes for the result element. These copied namespace nodes are prepended
                  to the sequence produced as a result of evaluating the <termref def="dt-sequence-constructor">sequence constructor</termref> (it is immaterial
                  whether they come before or after any attribute nodes produced by expanding the
                     <code>use-attribute-sets</code> attribute). If the value is set to
                     <code>no</code>, then the namespace nodes are not copied. However, namespace
                  nodes will still be added to the result element as <rfc2119>required</rfc2119> by
                  the namespace fixup process: see <specref ref="namespace-fixup"/>.</p>
               <p>The <elcode>xsl:copy</elcode> instruction has an optional
                     <code>inherit-namespaces</code> attribute, with the value <code>yes</code> or
                     <code>no</code>. The default value is <code>yes</code>. The attribute is used
                  only when copying element nodes. If the value is set to <code>yes</code>, or is
                  omitted, then the namespace nodes created for the newly constructed element
                  (whether these were copied from those of the source node, or generated as a result
                  of namespace fixup) are copied to the children and descendants of the newly
                  constructed element, as described in <specref ref="constructing-complex-content"/>. If the value is set to <code>no</code>, then these namespace nodes are not
                  automatically copied to the children. This may result in namespace undeclarations
                  (such as <code>xmlns=""</code> or, in the case of XML Namespaces 1.1,
                     <code>xmlns:p=""</code>) appearing on the child elements when a <termref def="dt-final-result-tree">final result tree</termref> is serialized.</p>
               <p>
                  <error spec="XT" type="type" class="TE" code="0950">
                     <p>It is a <termref def="dt-type-error">type error</termref> to use the
                           <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode> instruction to
                        copy a node that has namespace-sensitive content if the
                           <code>copy-namespaces</code> attribute has the value <code>no</code> and
                        its explicit or implicit <code>validation</code> attribute has the value
                           <code>preserve</code>. It is also a type error if either of these
                        instructions (with <code>validation="preserve"</code>) is used to copy an
                        attribute having namespace-sensitive content, unless the parent element is
                        also copied. A node has namespace-sensitive content if its typed value
                        contains an item of type <code>xs:QName</code> or <code>xs:NOTATION</code>
                        or a type derived therefrom. The reason this is an error is because the
                        validity of the content depends on the namespace context being
                        preserved.</p>
                  </error>
               </p>
               <note>
                  <p>When attribute nodes are copied, whether with <elcode>xsl:copy</elcode> or with
                        <elcode>xsl:copy-of</elcode>, the processor does not automatically copy any
                     associated namespace information. The namespace used in the attribute name
                     itself will be declared by virtue of the namespace fixup process (see <specref ref="namespace-fixup"/>) when the attribute is added to an element in the
                        <termref def="dt-result-tree">result tree</termref>, but if namespace
                     prefixes are used in the content of the attribute (for example, if the value of
                     the attribute is an XPath expression) then it is the responsibility of the
                     stylesheet author to ensure that suitable namespace nodes are added to the
                        <termref def="dt-result-tree">result tree</termref>. This can be achieved by
                     copying the namespace nodes using <elcode>xsl:copy</elcode>, or by generating
                     them using <elcode>xsl:namespace</elcode>.</p>
               </note>
               <p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <elcode>xsl:copy</elcode> instruction to validate the contents of an
                  element, attribute or document node against a type definition, element
                  declaration, or attribute declaration in a schema, and thus to determine the
                     <termref def="dt-type-annotation"/> that the new copy of an element or
                  attribute node will carry. These attributes are ignored when copying an item that
                  is not an element, attribute or document node. When the node being copied is an
                  element or document node, these attributes also affect the type annotation carried
                  by any elements and attributes that have the copied element or document node as an
                  ancestor. These two attributes are both optional, and if one is specified then the
                  other <rfc2119>must</rfc2119> be omitted. The permitted values of these attributes
                  and their semantics are described in <specref ref="validation"/>.</p>
               <note>
                  <p>The final <termref def="dt-type-annotation"/> of the node in the <termref def="dt-result-tree">result tree</termref> also depends on the
                        <code>type</code> and <code>validation</code> attributes of the instructions
                     used to create the ancestors of the node.</p>
               </note>
               

               <p>When a node is copied, its base URI is copied, except
                  when the result of the <elcode>xsl:copy</elcode> instruction is an element node
                  having an <code>xml:base</code> attribute, in which case the base URI of the new
                  node is taken as the value of its <code>xml:base</code> attribute, resolved if it
                  is relative against the base URI of the <elcode>xsl:copy</elcode> instruction. </p>


               <p>When an <code>xml:id</code> attribute is copied, using either the
                     <elcode>xsl:copy</elcode> or <elcode>xsl:copy-of</elcode> instruction, it is
                     <termref def="dt-implementation-defined"/> whether the value of the attribute
                  is subjected to attribute value normalization (that is, effectively applying the
                     <xfunction>normalize-space</xfunction> function).</p>
               <note>
                  <p>In most cases the value will already have been subjected to attribute value
                     normalization on the source tree, but if this processing has not been performed
                     on the source tree, it is not an error for it to be performed on the result
                     tree.</p>
               </note>
               <imp-def-feature id="idf-feature-xmlid">If an <code>xml:id</code> attribute that has
                  not been subjected to attribute value normalization is copied from a source tree
                  to a result tree, it is implementation-defined whether attribute value
                  normalization will be applied during the copy process.</imp-def-feature>
               

            </div3>
            <div3 id="copy-of">
               <head>Deep Copy</head>
               <?element xsl:copy-of?>
               <p>The <elcode>xsl:copy-of</elcode> instruction can be used to construct a copy of a
                  sequence of nodes, atomic values, and/or function
                     items with each new node containing copies of all the children,
                  attributes, and (by default) namespaces of the original node, recursively. The
                  result of evaluating the instruction is a sequence of items corresponding
                  one-to-one with the supplied sequence, and retaining its order.</p>
               <p>The <rfc2119>required</rfc2119>
                  <code>select</code> attribute contains an <termref def="dt-expression">expression</termref>, whose value may be any sequence of nodes, atomic values,
                     and/or function items. The items in this
                  sequence are processed as follows:</p>
               <ulist>
                  <item>
                     <p>If the item is an element node, a new element is constructed and appended to
                        the result sequence. The new element will have the same <termref def="dt-expanded-qname">expanded QName</termref> as the original, and it
                        will have deep copies of the attribute nodes and children of the element
                        node.</p>
                     <p>The new element will also have namespace nodes copied from the original
                        element node, unless they are excluded by specifying
                           <code>copy-namespaces="no"</code>. If this attribute is omitted, or takes
                        the value <code>yes</code>, then all the namespace nodes of the original
                        element are copied to the new element. If it takes the value
                        <code>no</code>, then none of the namespace nodes are copied: however,
                        namespace nodes will still be created in the <termref def="dt-result-tree">result tree</termref> as <rfc2119>required</rfc2119> by the namespace
                        fixup process: see <specref ref="namespace-fixup"/>. This attribute affects
                        all elements copied by this instruction: both elements selected directly by
                        the <code>select</code>
                        <termref def="dt-expression">expression</termref>, and elements that are
                        descendants of nodes selected by the <code>select</code> expression. </p>
                     <p>The values of the <code>is-id</code>,
                           <code>is-idrefs</code>, and <code>nilled</code> properties of the new
                        element depend on the values of the <code>validation</code> and
                           <code>type</code> attributes, as defined in <specref ref="validation"/>.</p>
                  </item>
                  <item>
                     <p>If the item is a document node, the instruction adds a new document node to
                        the result sequence; the children of this document node will be one-to-one
                        copies of the children of the original document node (each copied according
                        to the rules for its own node kind). The
                              <code>unparsed-entities</code> property of the original document node
                           is copied to the new document node.</p>
                  </item>
                  <item>
                     <p>If the item is an attribute or namespace node, or a text node, a comment, or
                        a processing instruction, the same rules apply as with
                           <elcode>xsl:copy</elcode> (see <specref ref="shallow-copy"/>).</p>
                  </item>
                  <item>
                     <p>If the item is an atomic value or a function
                           item, the value is appended to the result sequence, as with
                           <elcode>xsl:sequence</elcode>.</p>
                  </item>
               </ulist>
               <p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <elcode>xsl:copy-of</elcode> instruction to validate the contents of an
                  element, attribute or document node against a type definition, element
                  declaration, or attribute declaration in a schema and thus to determine the
                     <termref def="dt-type-annotation"/> that the new copy of an element or
                  attribute node will carry. These attributes are applied individually to each
                  element, attribute, and document node that is selected by the expression in the
                     <code>select</code> attribute. These attributes are ignored when copying an
                  item that is not an element, attribute or document node.</p>
               <p>The specified <code>type</code> and <code>validation</code> apply directly only to
                  elements, attributes and document nodes created as copies of nodes actually
                  selected by the <code>select</code> expression, they do not apply to nodes that
                  are implicitly copied because they have selected nodes as an ancestor. However,
                  these attributes do indirectly affect the <termref def="dt-type-annotation">type
                     annotation</termref> carried by such implicitly copied nodes, as a consequence
                  of the validation process.</p>
               <p>These two attributes are both optional, and if one is specified then the other
                     <rfc2119>must</rfc2119> be omitted. The permitted values of these attributes
                  and their semantics are described in <specref ref="validation"/>.</p>
               <p>Errors may occur when copying namespace-sensitive elements or attributes using
                     <code>validation="preserve"</code>. <errorref class="TE" code="0950"/>.</p>
               <p>If removal of namespaces is requested using
                     <code>copy-namespaces="no"</code>, then any validation that is requested is
                  applied to the tree that remains after the relevant namespaces have been removed.
                  This will cause validation to fail if there is namespace-sensitive content that
                  depends on the presence of the removed namespaces.</p>
               <p diff="del" at="A">The base URI of a node is copied, except in the case of an element node having an
                     <code>xml:base</code> attribute, in which case the base URI of the new node is
                  taken as the value of the <code>xml:base</code> attribute, resolved if it is
                  relative against the base URI of the <elcode>xsl:copy-of</elcode> instruction. If
                  the copied node is subsequently attached as a child to a new element or document
                  node, the final copy of the node inherits its base URI from its parent node,
                  unless this is overridden using an <code>xml:base</code> attribute.</p>
               
               <p diff="add" at="A">
                  For any node <var>N</var> that is explicitly selected by the evaluation of the 
                  <code>select</code> expression, the base URI of the new copy is as follows:</p>
               <ulist diff="add" at="A">
                  <item><p>If <var>N</var> is an element node having an <code>xml:base</code> attribute, 
                     the base URI of the new node is taken as the value of the <code>xml:base</code> attribute, 
                     resolved if it is relative against the static base URI of the <code>xsl:copy-of</code> instruction.
                  </p></item>
                  <item><p>Otherwise, the base URI of the new copy is the same as the base URI of <var>N</var>.
                  </p></item>
               </ulist>   
               <p diff="add" at="A">For any element or processing-instruction node that has <var>N</var> as an ancestor, 
                     the base URI of the new copy is set to be the same as that of its new parent, 
                     with the following exception: if a copied element has an <code>xml:base</code> 
                     attribute, then its base URI is set to the value of that attribute, 
                     resolved if it is relative against the base URI of the new parent node.
                  </p>
               <note diff="add" at="A"><p>If two elements in a subtree have different base URIs for some reason 
                     unconnected with <code>xml:base</code> attributes (for example, if they originated in different 
                     external entities), then these differences are lost when the subtree is copied.
                  </p></note>
                  
               <note diff="add" at="A">
                     <p>As a consequence of rules specified elsewhere (see <specref ref="constructing-complex-content"/>), 
                        if a node created using the <code>xsl:copy-of</code> instruction is subsequently attached 
                        as a child to a new element or document node, the final copy of the node inherits 
                        its base URI from its new parent node, unless this is overridden using an <code>xml:base</code> attribute.
                     </p></note>
               <p diff="add" at="A">[XSLT 3.0 Erratum E16, bug 30222]</p>
               <p>The effect of the <code>copy-accumulators</code> attribute is described in
                  <specref ref="applicability-of-accumulators"/>.</p>
            </div3>
         </div2>
         <div2 id="constructing-sequences">
            <head>Constructing Sequences</head>
            <?element xsl:sequence?>
            <p>The <elcode>xsl:sequence</elcode> instruction may be used within a <termref def="dt-sequence-constructor">sequence constructor</termref> to construct a
               sequence of nodes, atomic values, and/or function
                  items. This sequence is returned as the result of the instruction. Unlike
               most other instructions, <elcode>xsl:sequence</elcode> can return a sequence
               containing existing nodes, rather than constructing new nodes. When
                  <elcode>xsl:sequence</elcode> is used to select atomic values or function items, the effect is very similar to the
                  <elcode>xsl:copy-of</elcode> instruction.</p>
            <p>The items comprising the result sequence are evaluated either using
               the <code>select</code> attribute, or using the contained <termref def="dt-sequence-constructor"/>. These are mutually exclusive; if the instruction
               has a <code>select</code> attribute, then it <rfc2119>must</rfc2119> have no children
               other than <elcode>xsl:fallback</elcode> instructions. If there is no
                  <code>select</code> attribute and no contained <termref def="dt-sequence-constructor"/>, the result is an empty sequence.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="3185">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of <elcode>xsl:sequence</elcode> is present
                     and the instruction has children other than <elcode>xsl:fallback</elcode>.</p>
               </error>
            </p>
            <p>Any contained <elcode>xsl:fallback</elcode> instructions are ignored by an XSLT 2.0
                  or 3.0 processor, but can be used to define
               fallback behavior for an XSLT 1.0 processor running in forwards compatibility
               mode.</p>
            <example>
               <head>Constructing a Sequence of Integers</head>
               <p>The following code:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:variable name="values" as="xs:integer*"&gt;
    &lt;xsl:sequence select="(1,2,3,4)"/&gt;
    &lt;xsl:sequence select="(8,9,10)"/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="sum($values)"/&gt;</eg>
               <p>produces the output: <code>37</code>
               </p>
            </example>
            <example>
               <head>Using <code>xsl:for-each</code> to Construct a Sequence</head>
               <p>The following code constructs a sequence containing the value of the
                     <code>@price</code> attribute for selected elements (which we assume to be
                  typed as <code>xs:decimal</code>), or a computed price for those elements that
                  have no <code>@price</code> attribute. It then returns the average price:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:variable name="prices" as="xs:decimal*"&gt;
  &lt;xsl:for-each select="//product"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@price"&gt;
        &lt;xsl:sequence select="@price"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:sequence select="@cost * 1.5"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="avg($prices)"/&gt;</eg>
               <p>Note that the existing <code>@price</code> attributes could equally have been
                  added to the <code>$prices</code> sequence using <elcode>xsl:copy-of</elcode> or
                     <elcode>xsl:value-of</elcode>. However, <elcode>xsl:copy-of</elcode> would
                  create a copy of the attribute node, which is not needed in this situation, while
                     <elcode>xsl:value-of</elcode> would create a new text node, which then has to
                  be converted to an <code>xs:decimal</code>. Using <elcode>xsl:sequence</elcode>,
                  which in this case atomizes the existing attribute node and adds an
                     <code>xs:decimal</code> atomic value to the result sequence, is a more direct
                  way of achieving the same result.</p>
               <p>This example could alternatively be solved at the XPath level:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:value-of select="avg(//product/(+@price, @cost*1.5)[1])"/&gt;</eg>
               <p>The apparently redundant <code>+</code> operator is there to atomize the attribute
                  value: the expression on the right hand side of the <code>/</code> operator must
                  not return a  sequence containing both nodes and
                     non-nodes (atomic values or function items).</p>
            </example>
            <note>
               <p>The main use case for allowing <elcode>xsl:sequence</elcode> to contain a sequence
                  constructor is to allow the instructions within an <elcode>xsl:fork</elcode>
                  element to be divided into groups.</p>
               <p>It can also be used to limit the scope of local variables or of standard
                  attributes such as <code>[xsl:]default-collation</code>.</p>
            </note>
         </div2>
      </div1>
      <div1 id="number">
         <head>Numbering</head>
         <?element xsl:number?>
         <p>The <elcode>xsl:number</elcode> instruction is used to create a formatted number. The
            result of the instruction is a newly constructed text node containing the formatted
            number as its <termref def="dt-string-value">string value</termref>.</p>
         <p>
            <termdef id="dt-place-marker" term="place marker">The <elcode>xsl:number</elcode>
               instruction performs two tasks: firstly, determining a <term>place marker</term>
               (this is a sequence of integers, to allow for hierarchic numbering schemes such as
                  <code>1.12.2</code> or <code>3(c)ii</code>), and secondly, formatting the place
               marker for output as a text node in the result sequence.</termdef> The place marker
            to be formatted can either be supplied directly, in the <code>value</code> attribute, or
            it can be computed based on the position of a selected node within the tree that
            contains it.</p>
         <p>
            <error spec="XT" type="static" class="SE" code="0975">
               <p>It is a <termref def="dt-static-error">static error</termref> if the
                     <code>value</code> attribute of <elcode>xsl:number</elcode> is present unless
                  the <code>select</code>, <code>level</code>, <code>count</code>, and
                     <code>from</code> attributes are all absent.</p>
            </error>
         </p>
         <note>
            <p>The facilities described in this section are specifically designed to enable the
               calculation and formatting of section numbers, paragraph numbers, and the like. For
               formatting of other numeric quantities, the <xfunction>format-number</xfunction>
               function may be more suitable.</p>
            <p>Furthermore, formatting of integers where there is no requirement to calculate the
               position of a node in the document can now be accomplished using the
                  <xfunction>format-integer</xfunction> function, which borrows many concepts from
               the <elcode>xsl:number</elcode> specification.</p>
         </note>

         <div2 id="start-at">
            <head>The <code>start-at</code> Attribute</head>

            <p>The <termref def="dt-effective-value"/> of the
                  <code>start-at</code> attribute <rfc2119>must</rfc2119> be a string representing a
               whitespace-separated sequence of one or more integers, each one optionally preceded
               by a minus sign, separated by whitespace. More specifically, the value must be a
               string matching the regular expression <code>-?[0-9]+(\s+-?[0-9]+)*</code>. This
               sequence of integers is used to <term>re-base</term> the sequence of integers being
               formatted. Specifically if <var>$S</var> is the sequence of integers represented by
               the <code>start-at</code> attribute, and <var>$V</var> is the sequence of integers to
               be formatted, then the following transformation is applied to <var>$V</var>:</p>

            <eg role="non-xml" xml:space="preserve">
for $i in 1 to count($V) return
  if ($i le count($S))
  then $V[$i] + $S[$i] - 1
  else $V[$i] + $S[last()] - 1
</eg>

            <note>
               <p>This means that if there are <var>N</var> integers in the <code>start-at</code>
                  attribute, then these are used to re-base the first <var>N</var> numbers, while
                  numbers after the <var>Nth</var> are re-based using the last (<var>Nth</var>)
                  integer in the <code>start-at</code> attribute. If the <code>start-at</code>
                  attribute contains more integers than are required, the surplus is ignored.</p>
            </note>

            <p>For example, if the attribute is given as
                  <code>start-at="3 0 0"</code>, and the number sequence to be formatted is
                  <code>(1, 1, 1, 1)</code>, then the re-based sequence is <code>3, 0, 0,
               0</code>.</p>
         </div2>

         <div2 id="formatting-supplied-number">
            <head>Formatting a Supplied Number</head>
            <p>The <termref def="dt-place-marker">place marker</termref> to be formatted may be
               specified by an expression. The <code>value</code> attribute contains the <termref def="dt-expression">expression</termref>. The value of this expression is <termref def="dt-atomization">atomized</termref> using the procedure defined in <bibref ref="xpath-30"/>, and each value <var>$V</var> in the atomized sequence is then
               converted to the integer value returned by the XPath expression
                  <code>xs:integer(round(number($V)))</code>. If
                  the <code>start-at</code> attribute is present, this sequence is then re-based as
                  described in <specref ref="start-at"/>. The resulting sequence of
               integers is used as the place marker to be formatted.</p>
            <p>If the instruction is processed with <termref def="dt-xslt-10-behavior">XSLT 1.0 behavior</termref>, then:</p>
            <ulist>
               <item>
                  <p>All items in the <termref def="dt-atomization">atomized</termref> sequence
                     after the first are discarded;</p>
               </item>
               <item>
                  <p>If the atomized sequence is empty, it is replaced by a sequence containing the
                        <code>xs:double</code> value <code>NaN</code> as its only item;</p>
               </item>
               <item>
                  <p>If any value in the sequence cannot be converted to an integer (this includes
                     the case where the sequence contains a <code>NaN</code> value) then the string
                        <code>NaN</code> is inserted into the formatted result string in its proper
                     position. The error described in the following paragraph does not apply in this
                     case.</p>
               </item>
            </ulist>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="0980">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if any undiscarded item
                     in the atomized sequence supplied as the value of the <code>value</code>
                     attribute of <elcode>xsl:number</elcode> cannot be converted to an integer, or
                     if the resulting integer is less than 0 (zero). </p>
               </error>
            </p>
            <note>
               <p>The value zero does not arise when numbering nodes in a source document, but it
                  can arise in other numbering sequences. It is permitted specifically because the
                  rules of the <elcode>xsl:number</elcode> instruction are also invoked by functions
                  such as <xfunction>format-time</xfunction>: the minutes and seconds component of a
                  time value can legitimately be zero.</p>
            </note>
            <p>The resulting sequence is formatted as a string using the <termref def="dt-effective-value">effective values</termref> of the attributes specified in
                  <specref ref="convert"/>; each of these attributes is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>. After
               conversion, the <elcode>xsl:number</elcode> element constructs a new text node
               containing the resulting string, and returns this node.</p>
            <example>
               <head>Numbering a Sorted List</head>
               <p>The following example numbers a sorted list:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="items"&gt;
  &lt;xsl:for-each select="item"&gt;
    &lt;xsl:sort select="."/&gt;
    &lt;p&gt;
      &lt;xsl:number value="position()" format="1. "/&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</eg>
            </example>
         </div2>
         <div2 id="numbering-based-on-position">
            <head>Numbering based on Position in a Document </head>
            <p>If no <code>value</code> attribute is specified, then the <elcode>xsl:number</elcode>
               instruction returns a new text node containing a formatted <termref def="dt-place-marker">place marker</termref> that is based on the position of a
               selected node within its containing document. If the <code>select</code> attribute is
               present, then the expression contained in the <code>select</code> attribute is
               evaluated to determine the selected node. If the <code>select</code> attribute is
               omitted, then the selected node is the <termref def="dt-context-node">context
                  node</termref>.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="0990">
                  <p>It is a <termref def="dt-type-error">type error</termref> if the
                        <elcode>xsl:number</elcode> instruction is evaluated, with no
                        <code>value</code> or <code>select</code> attribute, when the <termref def="dt-context-item">context item</termref> is not a node. </p>
               </error>
            </p>
            <p>
               <error spec="XT" type="type" class="TE" code="1000">
                  <p>It is a <termref def="dt-type-error">type error</termref> if the result of
                     evaluating the <code>select</code> attribute of the <elcode>xsl:number</elcode>
                     instruction is anything other than a single node.</p>
               </error>
            </p>
            
            <p> The following attributes control how the selected node is to be numbered:</p>
            <ulist>
               <item>
                  <p>The <code>level</code> attribute specifies rules for selecting the nodes that
                     are taken into account in allocating a number; it has the values
                        <code>single</code>, <code>multiple</code> or <code>any</code>. The default
                     is <code>single</code>.</p>
               </item>
               <item>
                  <p>The <code>count</code> attribute is a <termref def="dt-pattern">pattern</termref> that specifies which nodes are to be counted at those
                     levels. If <code>count</code> attribute is not specified, then it defaults to
                     the pattern that matches any node with the same node kind as the selected node
                     and, if the selected node has an <termref def="dt-expanded-qname">expanded
                        QName</termref>, with the same <termref def="dt-expanded-qname">expanded
                        QName</termref> as the selected node.</p>
               </item>
               <item>
                  <p>The <code>from</code> attribute is a <termref def="dt-pattern">pattern</termref> that specifies where counting starts.</p>
               </item>
            </ulist>
            <p>In addition, the attributes specified in <specref ref="convert"/> are used for number
               to string conversion, as in the case when the <code>value</code> attribute is
               specified.</p>
            <p>The <elcode>xsl:number</elcode> element first constructs a sequence of positive
               integers using the <code>level</code>, <code>count</code> and <code>from</code>
               attributes. Where <code>level</code> is <code>single</code> or <code>any</code>, this
               sequence will either be empty or contain a single number; where <code>level</code> is
                  <code>multiple</code>, the sequence may be of any length. The sequence is
               constructed as follows:</p>
            <p>Let <code>matches-count($node)</code> be a function that returns true if and only if
               the given node <code>$node</code> matches the pattern given in the <code>count</code>
               attribute, or the implied pattern (according to the rules given above) if the
                  <code>count</code> attribute is omitted.</p>
            <p>Let <code>matches-from($node)</code> be a function that returns true if and only if
               the given node <code>$node</code> matches the pattern given in the <code>from</code>
               attribute, or if <code>$node</code> is the root node of a tree. If the
                  <code>from</code> attribute is omitted, then the function returns true if and only
               if <code>$node</code> is the root node of a tree.</p>
            <p>Let <code>$S</code> be the selected node.</p>
            <p>When <code>level="single"</code>: </p>
            <ulist>
               <item>
                  <p>Let <code>$A</code> be the node sequence selected by the following
                     expression:</p>
                  <p>
                     <code>   $S/ancestor-or-self::node()[matches-count(.)][1]</code>
                  </p>
                  <p>(this selects the innermost ancestor-or-self node that matches the
                        <code>count</code> pattern)</p>
               </item>
               <item>
                  <p>Let <code>$F</code> be the node sequence selected by the expression:</p>
                  <p>
                     <code>   $S/ancestor-or-self::node()[matches-from(.)][1]</code>
                  </p>
                  <p>(this selects the innermost ancestor-or-self node that matches the
                        <code>from</code> pattern)</p>
               </item>
               <item>
                  <p>Let <code>$AF</code> be the value of:</p>
                  <p>
                     <code>   $A[ancestor-or-self::node()[. is $F]]</code>
                  </p>
                  <p>(this selects $A if it is in the subtree rooted at $F, or the empty sequence
                     otherwise)</p>
               </item>
               <item>
                  <p>If <code>$AF</code> is empty, return the empty sequence, <code>()</code>
                  </p>
               </item>
               <item>
                  <p>Otherwise return the value of:</p>
                  <p>
                     <code>   1 + count($AF/preceding-sibling::node()[matches-count(.)])</code>
                  </p>
                  <p>(the number of preceding siblings of the counted node that match the
                        <code>count</code> pattern, plus one).</p>
               </item>
            </ulist>
            <p>When <code>level="multiple"</code>: </p>
            <ulist>
               <item>
                  <p>Let <code>$A</code> be the node sequence selected by the expression:</p>
                  <p>
                     <code>   $S/ancestor-or-self::node()[matches-count(.)]</code>
                  </p>
                  <p>(the set of ancestor-or-self nodes that match the <code>count</code>
                     pattern)</p>
               </item>
               <item>
                  <p>Let <code>$F</code> be the node sequence selected by the expression:</p>
                  <p>
                     <code>   $S/ancestor-or-self::node()[matches-from(.)][1]</code>
                  </p>
                  <p>(the innermost ancestor-or-self node that matches the <code>from</code>
                     pattern)</p>
               </item>
               <item>
                  <p>Let <code>$AF</code> be the value of:</p>
                  <p>
                     <code>   $A[ancestor-or-self::node()[. is $F]]</code>
                  </p>
                  <p>(the nodes selected in the first step that are in the subtree rooted at the
                     node selected in the second step)</p>
               </item>
               <item>
                  <p>Return the result of the expression:</p>
                  <p>
                     <code>   for $af in $AF return
                        1+count($af/preceding-sibling::node()[matches-count(.)])</code>
                  </p>
                  <p>(a sequence of integers containing, for each of these nodes, one plus the
                     number of preceding siblings that match the <code>count</code> pattern)</p>
               </item>
            </ulist>
            <p>When <code>level="any"</code>: </p>
            <ulist>
               <item>
                  <p>Let <code>$A</code> be the node sequence selected by the expression:</p>
                  <p>
                     <code>   $S/(preceding::node()|ancestor-or-self::node())[matches-count(.)]</code>
                  </p>
                  <p>(the set of nodes consisting of the selected node together with all nodes,
                     other than attributes and namespaces, that precede the selected node in
                     document order, provided that they match the <code>count</code> pattern)</p>
               </item>
               <item>
                  <p>Let <code>$F</code> be the node sequence selected by the expression:</p>
                  <p>
                     <code>   $S/(preceding::node()|ancestor-or-self::node())[matches-from(.)][last()]</code>
                  </p>
                  <p>(the last node in document order that matches the <code>from</code> pattern and
                     that precedes the selected node, using the same definition)</p>
               </item>
               <item>
                  <p>Let <code>$AF</code> be the node sequence <code>$A[. is $F or . &gt;&gt;
                        $F]</code></p>
                  <p>(the nodes selected in the first step, excluding those that precede the node
                     selected in the second step)</p>
               </item>
               <item>
                  <p>If <code>$AF</code> is empty, return the empty sequence, <code>()</code>
                  </p>
               </item>
               <item>
                  <p>Otherwise return the value of the expression <code>count($AF)</code>
                  </p>
               </item>
            </ulist>

            <p>The resulting sequence of numbers is referred to as the <termref def="dt-place-marker">place marker</termref>.</p>

            <p>If the <code>start-at</code> attribute is present, then the
                  <termref def="dt-place-marker">place marker</termref> is re-based as described in <specref ref="start-at"/>.</p>

            <p>The sequence of numbers is then converted into a string using the <termref def="dt-effective-value">effective values</termref> of the attributes specified in
                  <specref ref="convert"/>; each of these attributes is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>. After
               conversion, the resulting string is used to create a text node, which forms the
               result of the <elcode>xsl:number</elcode> instruction.</p>
            <example>
               <head>Numbering the Items in an Ordered List</head>
               <p>The following will number the items in an ordered list:</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template match="ol/item"&gt;
  &lt;fo:block&gt;
    &lt;xsl:number/&gt;
    &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Multi-Level Numbering</head>
               <p>The following two rules will number <code>title</code> elements. This is intended
                  for a document that contains a sequence of chapters followed by a sequence of
                  appendices, where both chapters and appendices contain sections, which in turn
                  contain subsections. Chapters are numbered 1, 2, 3; appendices are numbered A, B,
                  C; sections in chapters are numbered 1.1, 1.2, 1.3; sections in appendices are
                  numbered A.1, A.2, A.3. Subsections within a chapter are numbered 1.1.1, 1.1.2,
                  1.1.3; subsections within an appendix are numbered A.1.1, A.1.2, A.1.3.</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template match="title"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="appendix//title" priority="1"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Numbering Notes within a Chapter</head>
               <p>This example numbers notes sequentially within a chapter, starting from the number 100: :</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:fo='fo'">&lt;xsl:template match="note"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="any" from="chapter" format="(1) " start-at="100"/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</eg>
            </example>
         </div2>
         <div2 id="convert">
            <head>Number to String Conversion Attributes</head>

            <note>
               <p>This specification is aligned with that of the
                     <xfunction>format-integer</xfunction> function, but there are differences; for
                  example grouping separators are part of the primary format token in
                     <xfunction>format-integer</xfunction>, but are indicated by separate attributes
                  in <elcode>xsl:number</elcode>.</p>
            </note>

            <p>The following attributes are used to control conversion of a sequence of numbers into
               a string. The numbers are integers greater than or equal to 0 (zero). The attributes
               are all optional.</p>
            <p>The main attribute is <code>format</code>. The default value for the
                  <code>format</code> attribute is <code>1</code>. The <code>format</code> attribute
               is split into a sequence of tokens where each token is a maximal sequence of
               alphanumeric characters or a maximal sequence of non-alphanumeric characters.
                  <emph>Alphanumeric</emph> means any character that has a Unicode category of Nd,
               Nl, No, Lu, Ll, Lt, Lm or Lo (see <bibref ref="UNICODE"/>). The alphanumeric tokens (<emph>format tokens</emph>)
               indicate the format to be used for each number in the sequence; in most cases the
               format token is the same as the required representation of the number 1 (one).</p>
            <p>Each non-alphanumeric token is either a prefix, a separator, or a suffix. If there is
               a non-alphanumeric token but no format token, then the single non-alphanumeric token
               is used as both the prefix and the suffix. The prefix, if it exists, is the
               non-alphanumeric token that precedes the first format token: the prefix always
               appears exactly once in the constructed string, at the start. The suffix, if it
               exists, is the non-alphanumeric token that follows the last format token: the suffix
               always appears exactly once in the constructed string, at the end. All other
               non-alphanumeric tokens (those that occur between two format tokens) are
                  <emph>separator tokens</emph> and are used to separate numbers in the
               sequence.</p>
            <p>The <var>n</var>th format token is used to format the <var>n</var>th number in the
               sequence. If there are more numbers than format tokens, then the last format token is
               used to format remaining numbers. If there are no format tokens, then a format token
               of <code>1</code> is used to format all numbers. Each number after the first is
               separated from the preceding number by the separator token preceding the format token
               used to format that number, or, if that is the first format token, then by
                  <code>.</code> (dot).</p>
            <example>
               <head>Formatting a List of Numbers</head>
               <p>Given the sequence of numbers <code>5, 13, 7</code> and the format token
                     <code>A-001(i)</code>, the output will be the string <code>E-013(vii)</code>
               </p>
            </example>
            <p>Format tokens are interpreted as follows:</p>
            <ulist>
               <item>
                  <p>Any token where the last character has a decimal digit value of 1 (as specified
                     in the Unicode character property database, see <bibref ref="UNICODE"/>), and the Unicode
                     value of preceding characters is one less than the Unicode value of the last
                     character generates a decimal representation of the number where each number is
                     at least as long as the format token. The digits used in the decimal
                     representation are the set of digits containing the digit character used in the
                     format token. Thus, a format token <code>1</code> generates the sequence
                        <code>0 1 2 ... 10 11 12 ...</code>, and a format token <code>01</code>
                     generates the sequence <code>00 01 02 ... 09 10 11 12 ... 99 100 101</code>. A
                     format token of <code>&amp;#x661;</code> (Arabic-Indic digit one) generates the
                     sequence <code>١</code> then <code>٢</code> then
                        <code>٣</code> ...</p>
               </item>
               <item>
                  <p>A format token <code>A</code> generates the sequence <code>A B C ... Z AA AB
                        AC...</code>.</p>
               </item>
               <item>
                  <p>A format token <code>a</code> generates the sequence <code>a b c ... z aa ab
                        ac...</code>.</p>
               </item>
               <item>
                  <p>A format token <code>i</code> generates the sequence <code>i ii iii iv v vi vii
                        viii ix x ...</code>.</p>
               </item>
               <item>
                  <p>A format token <code>I</code> generates the sequence <code>I II III IV V VI VII
                        VIII IX X ...</code>.</p>
               </item>
               <item>
                  <p>A format token <code>w</code> generates numbers written as lower-case words,
                     for example in English, <code>one two three four ...</code>.
                  </p>
               </item>
               <item>
                  <p>A format token <code>W</code> generates numbers written as upper-case words,
                     for example in English, <code>ONE TWO THREE FOUR ...</code>.
                  </p>
               </item>
               <item>
                  <p>A format token <code>Ww</code> generates numbers written as title-case words,
                     for example in English, <code>One Two Three Four ...</code>.
                  </p>
               </item>
               <item>
                  <p>Any other format token indicates a numbering sequence in which that token
                     represents the number 1 (one) (but see the note below).
                     <!-- Where possible (given the constraint that format tokens
						must be alphanumeric, and that they must be distinct) the format token
						used to represent a numbering sequence should be the same as the representation
						of the number 1 (one) in that sequence.-->
                     It is <termref def="dt-implementation-defined"/> which numbering sequences,
                     additional to those listed above, are supported. If an implementation does not
                     support a numbering sequence represented by the given token, it
                        <rfc2119>must</rfc2119> use a format token of <code>1</code>.</p>
                  <note>
                     <p>In some traditional numbering sequences additional signs are added to denote
                        that the letters should be interpreted as numbers; these are not included in
                        the format token. An example, see also the example below, is classical Greek
                        where a <emph>dexia keraia</emph> and sometimes an <emph>aristeri
                           keraia</emph> is added.</p>
                  </note>
               </item>
            </ulist>
            <imp-def-feature id="idf-local-numbering">The combinations of languages and numbering
               sequences recognized by the <elcode>xsl:number</elcode> instruction, beyond those
               defined as mandatory in this specification, are <termref def="dt-implementation-defined"/>. There <rfc2119>may</rfc2119> be
               implementation-defined upper bounds on the numbers that can be formatted using any
               particular numbering sequence. There <rfc2119>may</rfc2119> be constraints on the
               values of the <code>ordinal</code> attribute recognized for any given
               language.</imp-def-feature>
            <p>For all format tokens other than the first kind above (one that consists of decimal
               digits), there <rfc2119>may</rfc2119> be <termref def="dt-implementation-defined">implementation-defined</termref> lower and upper bounds on the range of numbers
               that can be formatted using this format token; indeed, for some numbering sequences
               there may be intrinsic limits. For example, the format
                  token <code>&amp;#x2460;</code> (circled digit one, ①) has a range imposed
                  by the Unicode character repertoire (zero to 20 in Unicode versions prior to 3.2,
                  or zero to 50 in subsequent versions). For the numbering sequences
               described above any upper bound imposed by the implementation <rfc2119>must
                  not</rfc2119> be less than 1000 (one thousand) and any lower bound must not be
               greater than 1. Numbers that fall outside this range <rfc2119>must</rfc2119> be
               formatted using the format token <code>1</code>. The numbering sequence associated
               with the format token <code>1</code> has a lower bound of 0 (zero).</p>

            <p>The above expansions of numbering sequences for format tokens such as <code>a</code>
               and <code>i</code> are indicative but not prescriptive. There are various conventions
               in use for how alphabetic sequences continue when the alphabet is exhausted, and
               differing conventions for how roman numerals are written (for example,
                  <code>IV</code> versus <code>IIII</code> as the representation of the number 4).
               Sometimes alphabetic sequences are used that omit letters such as <code>i</code> and
                  <code>o</code>. This specification does not prescribe the detail of any sequence
               other than those sequences consisting entirely of decimal digits.</p>
            <p>Many numbering sequences are language-sensitive. This applies especially to the
               sequence selected by the tokens <code>w</code>, <code>W</code> and <code>Ww</code>.
               It also applies to other sequences, for example different languages using the
               Cyrillic alphabet use different sequences of characters, each starting with the
               letter #x410 (Cyrillic capital letter A). In such cases, the <code>lang</code>
               attribute specifies which language’s conventions are to be used; its <termref def="dt-effective-value">effective
                     value</termref>
                  <rfc2119>must</rfc2119> either be a string in the value space of
                     <code>xs:language</code>, or a zero-length string. If no
                  <code>lang</code> value is specified, or if the
                  value is a zero-length string, the language that is used is <termref def="dt-implementation-defined">implementation-defined</termref>. The set of
               languages for which numbering is supported is <termref def="dt-implementation-defined">implementation-defined</termref>. If a language is
               requested that is not supported, the processor <rfc2119>may</rfc2119> use a fallback language identified by removing
                  successive hyphen-separated suffixes from the supplied value until a supported
                  language code is obtained; failing this, the processor  uses the language
               that it would use if the <code>lang</code> attribute were omitted.</p>

            <p>The optional <code>ordinal</code> attribute is used to
               indicate whether cardinal or ordinal numbers are required, and to select other
               options relating to the grammatical context of the number to be formatted. The
               allowed set of values is <termref def="dt-implementation-defined"/>. If the attribute
               is absent, or if its value is zero-length, or if its value is <code>no</code> or
                  <code>0</code> or <code>false</code>, then cardinal numbers appropriate to the
               selected language are output. If the value is <code>yes</code> or <code>1</code> or
                  <code>true</code>, then ordinal numbers appropriate to the target language are
               output. Other values are <termref def="dt-implementation-defined"/>.</p>

            <p>For example, in English, the value <code>ordinal="yes"</code> when used with the
               format token <code>1</code> outputs the sequence <code>1st 2nd 3rd 4th ...</code>,
               and when used with the format token <code>w</code> outputs the sequence <code>first
                  second third fourth ...</code>.</p>

            <note>
               <p>In some languages, the form of numbers (especially ordinal numbers) varies
                  depending on the grammatical context: they may have different genders and may
                  decline with the noun that they qualify. In such cases the value of the
                     <code>ordinal</code> attribute may be used to indicate the variation of the
                  cardinal or ordinal number required, in an <termref def="dt-implementation-defined"/> way. </p>
               <p>The way in which the variation is indicated will depend on the conventions of the
                  language.</p>

               <p>For inflected languages that vary the ending of the word, the approach recommended
                  in the previous version of this specification was to indicate the required ending,
                  preceded by a hyphen: for example in German, appropriate values might be
                     <code>ordinal="-e"</code>, <code>ordinal="-er"</code>,
                     <code>ordinal="-es"</code>, <code>ordinal="-en"</code>. </p>
               <p>Another approach, which might usefully be adopted by an implementation based on
                  the open-source ICU localization library <bibref ref="ICU"/>, or any other library
                  making use of the Unicode Common Locale Data Repository <bibref ref="CLDR"/>, is
                  to allow the value of the attribute to be the name of a registered numbering rule
                  set for the language in question, conventionally prefixed with a percent sign: for
                  example, <code>ordinal="%spellout-ordinal-masculine"</code>, or
                     <code>ordinal="%spellout-cardinal-year"</code>. (The attribute name
                     <code>ordinal</code> in this case is a misnomer, but serves the purpose.) </p>
            </note>




            <example>
               <head>Ordinal Numbering in Italian</head>
               <p>The specification <code>format="1" ordinal="-º" lang="it"</code>, if supported,
                  should produce the sequence:</p>
               <eg xml:space="preserve" role="non-xml">1º 2º 3º 4º ...</eg>
               <p>The specification <code>format="Ww" ordinal="-o" lang="it"</code>, if supported,
                  should produce the sequence:</p>
               <eg xml:space="preserve" role="non-xml">Primo Secondo Terzo Quarto Quinto ...</eg>
            </example>
            <p>The <code>letter-value</code> attribute disambiguates between numbering sequences
               that use letters. In many languages there are two commonly used numbering sequences
               that use letters. One numbering sequence assigns numeric values to letters in
               alphabetic sequence, and the other assigns numeric values to each letter in some
               other manner traditional in that language. In English, these would correspond to the
               numbering sequences specified by the format tokens <code>a</code> and <code>i</code>.
               In some languages, the first member of each sequence is the same, and so the format
               token alone would be ambiguous. A value of <code>alphabetic</code> specifies the
               alphabetic sequence; a value of <code>traditional</code> specifies the other
               sequence. If the <code>letter-value</code> attribute is not specified, then it is
                  <termref def="dt-implementation-dependent">implementation-dependent</termref> how
               any ambiguity is resolved.</p>
            <note>
               <p>Implementations may use <termref def="dt-extension-attribute">extension
                     attributes</termref> on <elcode>xsl:number</elcode> to provide additional
                  control over the way in which numbers are formatted.</p>
            </note>
            <p>The <code>grouping-separator</code> attribute gives the separator used as a grouping
               (for example, thousands) separator in decimal numbering sequences, and the optional
                  <code>grouping-size</code> specifies the size (normally 3) of the grouping. For
               example, <code>grouping-separator=","</code> and <code>grouping-size="3"</code> would
               produce numbers of the form <code>1,000,000</code> while
                  <code>grouping-separator="."</code> and <code>grouping-size="2"</code> would
               produce numbers of the form <code>1.00.00.00</code>. If only one of the
                  <code>grouping-separator</code> and <code>grouping-size</code> attributes is
               specified, then it is ignored.</p>

            <p>The <termref def="dt-effective-value">effective
                  value</termref> of the <code>grouping-separator</code> attribute
                  <rfc2119>may</rfc2119> be any string, including a zero-length string. </p>
            <p>The <termref def="dt-effective-value">effective
                  value</termref> of the <code>grouping-size</code> attribute
                  <rfc2119>must</rfc2119> be a string in the lexical space of
                  <code>xs:integer</code>. If the resulting integer is positive then it defines the
               number of digits between adjacent grouping separators; it if is zero or negative,
               then no grouping separators are inserted. </p>
            <example>
               <head>Format Tokens and the Resulting Sequences</head>
               <p>These examples use non-Latin characters which might not display correctly in all
                  browsers, depending on the system configuration.</p>
               <table class="data">
                  <caption>Format tokens for use with xsl:number</caption>
                  <thead>
                     <tr>
                        <th align="left" rowspan="1" colspan="1">Description</th>
                        <th align="left" rowspan="1" colspan="1">Format Token</th>
                        <th align="left" rowspan="1" colspan="1">Sequence</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td rowspan="1" colspan="1">French cardinal words</td>
                        <td rowspan="1" colspan="1">
                           <code>format="Ww" lang="fr"</code>
                        </td>
                        <td rowspan="1" colspan="1">Un, Deux, Trois, Quatre</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">German ordinal words</td>
                        <td rowspan="1" colspan="1">
                           <code>format="w" ordinal="-e" lang="de"</code>
                        </td>
                        <td rowspan="1" colspan="1">erste, zweite, dritte, vierte</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Katakana numbering</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x30A2;"</code>
                        </td>
                        <td rowspan="1" colspan="1">ア, イ, ウ, エ, オ, カ, キ,
                           ク, ケ, コ, サ, シ, ス, セ,
                           ソ, タ, チ, ツ, テ, ト, ナ,
                           ニ, ヌ, ネ, ノ, ハ, ヒ, フ,
                           ヘ, ホ, マ, ミ, ム, メ, モ,
                           ヤ, ユ, ヨ, ラ, リ, ル, レ,
                           ロ, ワ, ヰ, ヱ, ヲ, ン</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Katakana numbering in iroha order</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x30A4;"</code>
                        </td>
                        <td rowspan="1" colspan="1">イ, ロ, ハ, ニ, ホ, ヘ, ト,
                           チ, リ, ヌ, ル, ヲ, ワ, カ,
                           ヨ, タ, レ, ソ, ツ, ネ, ナ,
                           ラ, ム, ウ, ヰ, ノ, オ, ク,
                           ヤ, マ, ケ, フ, コ, エ, テ,
                           ア, サ, キ, ユ, メ, ミ, シ,
                           ヱ, ヒ, モ, セ, ス</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Thai numbering</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x0E51;"</code>
                        </td>
                        <td rowspan="1" colspan="1">๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘,
                           ๙, ๑๐, ๑๑, ๑๒, ๑๓,
                           ๑๔, ๑๕, ๑๖, ๑๗,
                           ๑๘, ๑๙, ๒๐</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Traditional Hebrew numbering</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x05D0;" letter-value="traditional"</code>
                        </td>
                        <td rowspan="1" colspan="1">א, ב, ג, ד, ה, ו, ז, ח,
                           ט, י, יא, יב, יג,
                           יד, טו, טז, יז,
                           יח, יט, כ</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Traditional Georgian numbering</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x10D0;" letter-value="traditional"</code>
                        </td>
                        <td rowspan="1" colspan="1">ა, ბ, გ, დ, ე, ვ, ზ,
                           ჱ, თ, ი, ია, იბ,
                           იგ, იდ, იე, ივ,
                           იზ, იჱ, ით, კ </td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Classical Greek numbering (see note)</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x03B1;" letter-value="traditional"</code>
                        </td>
                        <td rowspan="1" colspan="1"><phrase role="normalize-nfc"> αʹ, βʹ, γʹ, δʹ,
                           εʹ, ϛʹ, ζʹ, ηʹ,
                           θʹ, ιʹ, ιαʹ,
                           ιβʹ, ιγʹ, ιδʹ,
                           ιεʹ, ιϛʹ, ιζʹ,
                           ιηʹ, ιθʹ, κʹ</phrase></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Old Slavic numbering</td>
                        <td rowspan="1" colspan="1">
                           <code>format="&amp;#x0430;" letter-value="traditional"</code>
                        </td>
                        <td rowspan="1" colspan="1">А, В, Г, Д, Е, Ѕ, З, И,
                           Ѳ, Ӏ, АӀ, ВӀ, ГӀ,
                           ДӀ, ЕӀ, ЅӀ, ЗӀ,
                           ИӀ, ѲӀ, К</td>
                     </tr>
                  </tbody>
               </table>
               <p>Note that Classical Greek is an example where the format token is not the same as
                  the representation of the number 1.</p>
            </example>
         </div2>
      </div1>
      <div1 id="sorting">
         <head>Sorting</head>
         <p>
            <termdef id="dt-sort-key-specification" term="sort key specification">A <term>sort key
                  specification</term> is a sequence of one or more adjacent
                  <elcode>xsl:sort</elcode> elements which together define rules for sorting the
               items in an input sequence to form a sorted sequence.</termdef>
         </p>
         <p>
            <termdef id="dt-sort-key-component" term="sort key component">Within a <termref def="dt-sort-key-specification">sort key specification</termref>, each
                  <elcode>xsl:sort</elcode> element defines one <term>sort key
               component</term>.</termdef> The first <elcode>xsl:sort</elcode> element specifies the
            primary component of the sort key specification, the second <elcode>xsl:sort</elcode>
            element specifies the secondary component of the sort key specification, and so on.</p>
         <p>A sort key specification may occur immediately within an
               <elcode>xsl:apply-templates</elcode>, <elcode>xsl:for-each</elcode>,
               <elcode>xsl:perform-sort</elcode>, or <elcode>xsl:for-each-group</elcode>
            element.</p>
         <note>
            <p>When used within <elcode>xsl:for-each</elcode>, <elcode>xsl:for-each-group</elcode>,
               or <elcode>xsl:perform-sort</elcode>, <elcode>xsl:sort</elcode> elements must occur
               before any other children.</p>
         </note>

         <div2 id="xsl-sort">
            <head>The <elcode>xsl:sort</elcode> Element</head>
            <?element xsl:sort?>
            <p>The <elcode>xsl:sort</elcode> element defines a <termref def="dt-sort-key-component">sort key component</termref>. A sort key component specifies how a <termref def="dt-sort-key-value">sort key value</termref> is to be computed for each item
               in the sequence being sorted, and also how two sort key values are to be
               compared.</p>
            <p>The value of a <termref def="dt-sort-key-component">sort key component</termref> is
               determined either by its <code>select</code> attribute or by the contained <termref def="dt-sequence-constructor">sequence constructor</termref>. If neither is
               present, the default is <code>select="."</code>, which has the effect of sorting on
               the actual value of the item if it is an atomic value, or on the typed-value of the
               item if it is a node. If a <code>select</code> attribute is present, its value
                  <rfc2119>must</rfc2119> be an XPath <termref def="dt-expression">expression</termref>.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1015">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:sort</elcode> element with a <code>select</code> attribute has
                     non-empty content.</p>
               </error>
            </p>
            <p>Those attributes of the <elcode>xsl:sort</elcode> elements whose values are <termref def="dt-attribute-value-template">attribute value templates</termref> are
               evaluated using the same <termref def="dt-focus">focus</termref> as is used to
               evaluate the <code>select</code> attribute of the containing instruction
               (specifically, <elcode>xsl:apply-templates</elcode>, <elcode>xsl:for-each</elcode>,
                  <elcode>xsl:for-each-group</elcode>, or <elcode>xsl:perform-sort</elcode>).</p>
            <p>The <code>stable</code> attribute is permitted only on the first
                  <elcode>xsl:sort</elcode> element within a <termref def="dt-sort-key-specification">sort key specification</termref>.
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="1017">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:sort</elcode> element other than the first in a sequence of
                     sibling <elcode>xsl:sort</elcode> elements has a <code>stable</code>
                     attribute.</p>
               </error>
            </p>
            <p>
               <termdef id="dt-stable" term="stable">A <termref def="dt-sort-key-specification">sort
                     key specification</termref> is said to be <term>stable</term> if its first
                     <elcode>xsl:sort</elcode> element has no <code>stable</code> attribute, or has
                  a <code>stable</code> attribute whose <termref def="dt-effective-value">effective
                     value</termref> is <code>yes</code>.</termdef>
            </p>
            <div3 id="sorting-process">
               <head>The Sorting Process</head>
               <p>
                  <termdef id="dt-initial-sequence" term="initial sequence">The sequence to be
                     sorted is referred to as the <term>initial sequence</term>.</termdef>
               </p>
               <p>
                  <termdef id="dt-sorted-sequence" term="sorted sequence">The sequence after sorting
                     as defined by the <elcode>xsl:sort</elcode> elements is referred to as the
                        <term>sorted sequence</term>.</termdef>
               </p>
               <p>
                  <termdef id="dt-sort-key-value" term="sort key value"> For each item in the
                        <termref def="dt-initial-sequence">initial sequence</termref>, a value is
                     computed for each <termref def="dt-sort-key-component">sort key
                        component</termref> within the <termref def="dt-sort-key-specification">sort
                        key specification</termref>. The value computed for an item by using the
                        <var>N</var>th sort key component is referred to as the <var>N</var>th
                        <term>sort key value</term> of that item.</termdef>
               </p>
               <p>The items in the <termref def="dt-initial-sequence">initial sequence</termref> are
                  ordered into a <termref def="dt-sorted-sequence">sorted sequence</termref> by
                  comparing their <termref def="dt-sort-key-value">sort key values</termref>. The
                  relative position of two items <var>A</var> and <var>B</var> in the sorted
                  sequence is determined as follows. The first sort key value of <var>A</var> is
                  compared with the first sort key value of <var>B</var>, according to the rules of
                  the first <termref def="dt-sort-key-component">sort key component</termref>. If,
                  under these rules, <var>A</var> is less than <var>B</var>, then <var>A</var> will
                  precede <var>B</var> in the sorted sequence, unless the <code>order</code>
                  attribute of this <termref def="dt-sort-key-component">sort key
                     component</termref> specifies <code>descending</code>, in which case
                     <var>B</var> will precede <var>A</var> in the sorted sequence. If, however, the
                  relevant sort key values compare equal, then the second sort key value of
                     <var>A</var> is compared with the second sort key value of <var>B</var>,
                  according to the rules of the second <termref def="dt-sort-key-component">sort key
                     component</termref>. This continues until two sort key values are found that
                  compare unequal. If all the sort key values compare equal, and the <termref def="dt-sort-key-specification">sort key specification</termref> is <termref def="dt-stable">stable</termref>, then <var>A</var> will precede <var>B</var>
                  in the <termref def="dt-sorted-sequence">sorted sequence</termref> if and only if
                     <var>A</var> preceded <var>B</var> in the <termref def="dt-initial-sequence">initial sequence</termref>. If all the sort key values compare equal, and the
                     <termref def="dt-sort-key-specification">sort key specification</termref> is
                  not <termref def="dt-stable">stable</termref>, then the relative order of
                     <var>A</var> and <var>B</var> in the <termref def="dt-sorted-sequence">sorted
                     sequence</termref> is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
               <note>
                  <p>If two items have equal <termref def="dt-sort-key-value">sort key
                        values</termref>, and the sort is <termref def="dt-stable">stable</termref>,
                     then their order in the <termref def="dt-sorted-sequence">sorted
                        sequence</termref> will be the same as their order in the <termref def="dt-initial-sequence">initial sequence</termref>, regardless of whether
                        <code>order="descending"</code> was specified on any or all of the <termref def="dt-sort-key-component">sort key components</termref>.</p>
               </note>
               <p>The <var>N</var>th sort key value is computed by evaluating either the
                     <code>select</code> attribute or the contained <termref def="dt-sequence-constructor">sequence constructor</termref> of the
                     <var>N</var>th <elcode>xsl:sort</elcode> element, or the expression
                     <code>.</code> (dot) if neither is present. This evaluation is done with the
                     <termref def="dt-focus">focus</termref> set as follows:</p>
               <ulist>
                  <item>
                     <p>The <termref def="dt-context-item">context item</termref> is the item in the
                           <termref def="dt-initial-sequence">initial sequence</termref> whose
                           <termref def="dt-sort-key-value">sort key value</termref> is being
                        computed.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-context-position">context position</termref> is the
                        position of that item in the initial sequence.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-context-size">context size</termref> is the size of the
                        initial sequence.</p>
                  </item>
               </ulist>
               <note>
                  <p>As in any other XPath expression, the <function>current</function> function may
                     be used within the <code>select</code> expression of <elcode>xsl:sort</elcode>
                     to refer to the item that is the context item for the expression as a whole;
                     that is, the item whose <termref def="dt-sort-key-value">sort key
                        value</termref> is being computed.</p>
               </note>
               <p>The <termref def="dt-sort-key-value">sort key values</termref> are <termref def="dt-atomization">atomized</termref>, and are then compared. The way they
                  are compared depends on their datatype, as described in the next section.</p>
            </div3>
            <div3 id="comparing-sort-keys">
               <head>Comparing Sort Key Values</head>
               <p>It is possible to force the system to compare <termref def="dt-sort-key-value">sort key values</termref> using the rules for a particular datatype by
                  including a cast as part of the <termref def="dt-sort-key-component">sort key
                     component</termref>. For example, <code>&lt;xsl:sort
                     select="xs:date(@dob)"/&gt;</code> will force the attributes to be compared as
                  dates. In the absence of such a cast, the sort key values are compared using the
                  rules appropriate to their datatype. Any values of type
                     <code>xs:untypedAtomic</code> are cast to <code>xs:string</code>.</p>
               <p>For backwards compatibility with XSLT 1.0, the <code>data-type</code> attribute
                  remains available. If this has the <termref def="dt-effective-value">effective
                     value</termref>
                  <code>text</code>, the atomized <termref def="dt-sort-key-value">sort key
                     values</termref> are converted to strings before being compared. If it has the
                  effective value <code>number</code>, the atomized sort key values are converted to
                  doubles before being compared. The conversion is done by using the
                     <xfunction>string</xfunction> or <xfunction>number</xfunction> function as
                  appropriate. If the <code>data-type</code> attribute has
                     any other <termref def="dt-effective-value">effective value</termref>, then
                     this value <rfc2119>must</rfc2119> be an <termref def="dt-eqname">EQName</termref> denoting an <termref def="dt-expanded-qname">expanded
                        QName</termref> with a non-absent namespace, and the effect of the
                  attribute is <termref def="dt-implementation-defined"/>.</p>
               <imp-def-feature id="idf-ext-sortdatatype">If the <code>data-type</code> attribute of
                  the <elcode>xsl:sort</elcode> element has a value other than <code>text</code> or
                     <code>number</code>, the effect is implementation-defined.</imp-def-feature>
               <p>
                  <error spec="XT" type="type" class="TE" code="1020">
                     <p>If any <termref def="dt-sort-key-value">sort key value</termref>, after
                           <termref def="dt-atomization">atomization</termref> and any type
                        conversion <rfc2119>required</rfc2119> by the <code>data-type</code>
                        attribute, is a sequence containing more than one item, then the effect
                        depends on whether the <elcode>xsl:sort</elcode> element is processed with <termref def="dt-xslt-10-behavior">XSLT 1.0
                              behavior</termref>. With XSLT 1.0 behavior, the effective
                        sort key value is the first item in the sequence. In other cases, this is a
                           <termref def="dt-type-error">type error</termref>.</p>
                  </error>
               </p>
               <p>The set of <termref def="dt-sort-key-value">sort key values</termref> (after any
                  conversion) is first divided into two categories: empty values, and ordinary
                  values. The empty sort key values represent those items where the sort key value
                  is an empty sequence. These values are considered for sorting purposes to be equal
                  to each other, but less than any other value. The remaining values are classified
                  as ordinary values.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1030">
                     <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if, for any <termref def="dt-sort-key-component">sort key component</termref>, the set of
                           <termref def="dt-sort-key-value">sort key values</termref> evaluated for
                        all the items in the <termref def="dt-initial-sequence">initial
                           sequence</termref>, after any type conversion requested, contains a pair
                        of ordinary values for which the result of the XPath <code>lt</code>
                        operator is an error. If the processor is
                           able to detect the error statically, it <rfc2119>may</rfc2119> optionally
                           signal it as a <termref def="dt-static-error">static
                           error</termref>.</p>
                  </error>
               </p>
               <note>
                  <p>The above error condition may occur if the values to be sorted are of a type
                     that does not support ordering (for example, <code>xs:QName</code>) or if the
                     sequence is heterogeneous (for example, if it contains both strings and
                     numbers). The error can generally be prevented by invoking a cast or
                     constructor function within the sort key component.</p>
                  <p>The error condition is subject to the usual caveat that a processor is not
                     required to evaluate any expression solely in order to determine whether it
                     raises an error. For example, if there are several sort key components, then a
                     processor is not required to evaluate or compare minor sort key values unless
                     the corresponding major sort key values are equal.</p>
               </note>
               <!--Text replaced by erratum E13 change 1"-->
               <p>In general, comparison of two ordinary values is performed according to the rules
                  of the XPath <code>lt</code> operator. To ensure a total ordering, the same
                  implementation of the <code>lt</code> operator <rfc2119>must</rfc2119> be used for
                  all the comparisons: the one that is chosen is the one appropriate to the most
                  specific type to which all the values can be converted by subtype substitution
                  and/or type promotion. For example, if the sequence contains both
                     <code>xs:decimal</code> and <code>xs:double</code> values, then the values are
                  compared using <code>xs:double</code> comparison, even when comparing two
                     <code>xs:decimal</code> values. NaN values, for sorting purposes, are
                  considered to be equal to each other, and less than any other numeric value.
                  Special rules also apply to the <code>xs:string</code> and <code>xs:anyURI</code>
                  types, and types derived by restriction therefrom, as described in the next
                  section.</p>
               <!--End of text replaced by erratum E13-->
            </div3>
            <div3 id="collating-sequences">
               <head>Sorting Using Collations</head>
               <p>The rules given in this section apply when comparing values whose type is
                     <code>xs:string</code> or a type derived by restriction from
                     <code>xs:string</code>, or whose type is <code>xs:anyURI</code> or a type
                  derived by restriction from <code>xs:anyURI</code>.</p>
               <p>
                  <termdef id="dt-collation" term="collation">Facilities in XSLT 3.0 and XPath 3.0 that
                     require strings to be ordered rely on the concept of a named
                        <term>collation</term>. A collation is a set of rules that determine whether
                     two strings are equal, and if not, which of them is to be sorted before the
                     other.</termdef> A collation is identified by a URI, but the manner in which
                  this URI is associated with an actual rule or algorithm is largely <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
               <p>For more information about collations, see <xspecref spec="FO40" ref="string-compare"/> in <bibref ref="xpath-functions-40"/>. Some
                  specifications, for example <bibref ref="UNICODE-TR10"/>, use the term “collation”
                  to describe rules that can be tailored or parameterized for various purposes. In
                  this specification, a collation URI refers to a collation in which all such
                  parameters have already been fixed. Therefore, if a collation URI is specified,
                  other attributes such as <code>case-order</code> and <code>lang</code> are
                  ignored. </p>
               <imp-def-feature id="idf-local-collations">The facilities for defining collations and
                  allocating URIs to identify them are largely
                  implementation-defined.</imp-def-feature>
               <p>Every implementation <rfc2119>must</rfc2119>
                     recognize the collation URI 
                  <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>, which
                  provides the ability to compare strings based on the Unicode codepoint values of
                  the characters in the string.</p>

               <p>Furthermore, every implementation must recognize collation URIs
                  representing tailorings of the Unicode Collation Algorithm (UCA), as described in
                     <specref ref="uca-collations"/>. Although this form of collation URI must be
                  recognized, implementations are not required to support every possible
                  tailoring.</p>



               <p>If the <elcode>xsl:sort</elcode> element has a <code>collation</code> attribute,
                  then the strings are compared according to the rules for the named <termref def="dt-collation">collation</termref>: that is, they are compared using the
                  XPath function call <code>compare($a, $b, $collation)</code>.</p>
               <p>If the <termref def="dt-effective-value">effective value</termref> of the
                     <code>collation</code> attribute of <elcode>xsl:sort</elcode> is a relative
                  URI, then it is resolved against the base URI of the <elcode>xsl:sort</elcode>
                  element.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1035">
                     <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the
                           <code>collation</code> attribute of <elcode>xsl:sort</elcode> (after
                        resolving against the base URI) is not a URI that is recognized by the
                        implementation as referring to a collation.</p>
                  </error>
               </p>
               <note>
                  <p>It is entirely for the implementation to determine whether it recognizes a
                     particular collation URI. For example, if the implementation allows collation
                     URIs to contain parameters in the query part of the URI, it is the
                     implementation that determines whether a URI containing an unknown or invalid
                     parameter is or is not a recognized collation URI. The fact that this situation
                     is described as an error thus does not prevent an implementation applying a
                     fallback collation if it chooses to do so.</p>
               </note>
               <p>The <code>lang</code> and <code>case-order</code> attributes are ignored if a
                     <code>collation</code> attribute is present. But in the absence of a
                     <code>collation</code> attribute, these attributes provide input to an <termref def="dt-implementation-defined">implementation-defined</termref> algorithm to
                  locate a suitable collation:</p>
               <imp-def-feature id="idf-local-implicitcollations">The algorithm used by
                     <elcode>xsl:sort</elcode> to locate a collation, given the values of the
                     <code>lang</code> and <code>case-order</code> attributes, is
                  implementation-defined.</imp-def-feature>
               <ulist>
                  <item>
                     <p>The <code>lang</code> attribute indicates that a collation suitable for a
                        particular natural language <rfc2119>should</rfc2119> be used. The <termref def="dt-effective-value">effective value</termref> of the attribute
                           <rfc2119>must</rfc2119>
                         either be a string in the value space of
                              <code>xs:language</code>, or a zero-length string. Supplying the
                           zero-length string has the same effect as omitting the attribute. If a
                           language is requested that is not supported, the processor
                              <rfc2119>may</rfc2119> use a fallback language identified by removing
                           successive hyphen-separated suffixes from the supplied value until a
                           supported language code is obtained; failing this, the processor behaves
                           as if the <code>lang</code> attribute were omitted. </p>
                     
                     <note><p>The fallback algorithm described above is 
                        identical to the rules in RFC4647 Basic Filtering used in BCP 47,
                     and is specified in <bibref ref="RFC4647"/> in greater detail.</p></note>
                  </item>
                  <item>
                     <p>The <code>case-order</code> attribute indicates whether the desired
                        collation <rfc2119>should</rfc2119> sort upper-case letters before
                        lower-case or vice versa. The <termref def="dt-effective-value">effective
                           value</termref> of the attribute <rfc2119>must</rfc2119> be either
                           <code>lower-first</code> (indicating that lower-case letters precede
                        upper-case letters in the collating sequence) or <code>upper-first</code>
                        (indicating that upper-case letters precede lower-case).</p>
                     <!--Text inserted by erratum E26 change 1"-->
                     <p>When <code>lower-first</code> is requested, the returned collation
                           <rfc2119>should</rfc2119> have the property that when two strings differ
                        only in the case of one or more characters, then a string in which the first
                        differing character is lower-case should precede a string in which the
                        corresponding character is title-case, which should in turn precede a string
                        in which the corresponding character is upper-case. When upper-first is
                        requested, the returned collation <rfc2119>should</rfc2119> have the
                        property that when two strings differ only in the case of one or more
                        characters, then a string in which the first differing character is
                        upper-case should precede a string in which the corresponding character is
                        title-case, which should in turn precede a string in which the corresponding
                        character is lower-case.</p>
                     <p>So, for example, if <code>lang="en"</code>, then <code>A a B b</code> are
                        sorted with <code>case-order="upper-first"</code> and <code>a A b B</code>
                        are sorted with <code>case-order="lower-first"</code>.</p>
                     <p>As a further example, if <code>lower-first</code> is requested, then a sorted sequence
                        might be “MacAndrew, macintosh, macIntosh, Macintosh, MacIntosh,
                        macintoshes, Macintoshes, McIntosh”. If <code>upper-first</code> is requested, the same
                        sequence would sort as “MacAndrew, MacIntosh, Macintosh, macIntosh,
                        macintosh, MacIntoshes, macintoshes, McIntosh”.</p>
                     <!--End of text inserted by erratum E26-->
                  </item>
               </ulist>
               <p>If none of the <code>collation</code>, <code>lang</code>, or
                     <code>case-order</code> attributes is present, the collation is chosen in an
                     <termref def="dt-implementation-defined"/> way. It is not
                     <rfc2119>required</rfc2119> that the default collation for sorting should be
                  the same as the <termref def="dt-default-collation">default collation</termref>
                  used when evaluating XPath expressions, as described in <specref ref="static-context"/> and <specref ref="default-collation-attribute"/>.</p>
               <imp-def-feature id="idf-local-defaultsortcollation">If none of the
                     <code>collation</code>, <code>lang</code>, or <code>case-order</code>
                  attributes is present (on <elcode>xsl:sort</elcode>), the collation is chosen in
                  an <termref def="dt-implementation-defined"/> way.</imp-def-feature>
               <note>
                  <p>It is usually appropriate, when sorting, to use a strong collation, that is,
                     one that takes account of secondary differences (accents) and tertiary
                     differences (case) between strings that are otherwise equal. A weak collation,
                     which ignores such differences, may be more suitable when comparing strings for
                     equality.</p>
                  <p>Useful background information on international sorting is provided in <bibref ref="UNICODE-TR10"/>. The <code>case-order</code> attribute may be
                     interpreted as described in section 6.6 of <bibref ref="UNICODE-TR10"/>.</p>
               </note>
               
               <p diff="add" at="A">
                  The <code>collation</code>, <code>case-order</code>, and <code>lang</code> attributes are 
                  ignored when no string comparisons are performed during the sorting process; this 
                  includes the cases where (a) the sequences to be sorted are empty, (b) the sort 
                  keys are of a non-string type such as <code>xs:integer</code>, or (c) <code>data-type="number"</code> is 
                  specified. In these cases, an implementation may report errors in the value 
                  of these attributes, but is not required to do so. As always, an implementation 
                  may issue warnings. [XSLT 3.0 Erratum E45, bug 30386]
               </p>
            </div3>
         </div2>
         <div2 id="creating-sorted-sequence">
            <head>Creating a Sorted Sequence</head>
            <?element xsl:perform-sort?>
            <p>The <elcode>xsl:perform-sort</elcode> instruction is used to return a <termref def="dt-sorted-sequence">sorted sequence</termref>.</p>
            <p>The <termref def="dt-initial-sequence">initial sequence</termref> is obtained either
               by evaluating the <code>select</code> attribute or by evaluating the contained
               sequence constructor (but not both). If there is no <code>select</code> attribute and
               no sequence constructor then the <termref def="dt-initial-sequence">initial
                  sequence</termref> (and therefore, the <termref def="dt-sorted-sequence">sorted
                  sequence</termref>) is an empty sequence.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1040">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:perform-sort</elcode> instruction with a <code>select</code>
                     attribute has any content other than <elcode>xsl:sort</elcode> and
                        <elcode>xsl:fallback</elcode> instructions.</p>
               </error>
            </p>
            <p>The result of the <elcode>xsl:perform-sort</elcode> instruction is the result of
               sorting its <termref def="dt-initial-sequence">initial sequence</termref> using its
               contained <termref def="dt-sort-key-specification">sort key
               specification</termref>.</p>
            <example>
               <head>Sorting a Sequence of Atomic Values</head>
               <p>The following stylesheet function sorts a sequence of atomic values using the
                  value itself as the sort key.</p>
               <eg xml:space="preserve" role="xslt-declaration xmlns:local='local'">&lt;xsl:function name="local:sort" 
          as="xs:anyAtomicType*"&gt;
  &lt;xsl:param name="in" as="xs:anyAtomicType*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="."/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;</eg>
            </example>
            <example>
               <head>Writing a Function to Perform a Sort</head>
               <p>The following example defines a function that sorts books by price, and uses this
                  function to output the five books that have the lowest prices:</p>
               <eg xml:space="preserve" role="non-xml">&lt;xsl:function name="bib:books-by-price" 
          as="schema-element(bib:book)*"&gt;
  &lt;xsl:param name="in" as="schema-element(bib:book)*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="xs:decimal(bib:price)"/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;
   ...
   &lt;xsl:copy-of select="bib:books-by-price(//bib:book)
                             [position() = 1 to 5]"/&gt;

 </eg>
            </example>
         </div2>
         <div2 id="sorted-iteration">
            <head>Processing a Sequence in Sorted Order</head>
            <p>When used within <elcode>xsl:for-each</elcode> or
                  <elcode>xsl:apply-templates</elcode>, a <termref def="dt-sort-key-specification">sort key specification</termref> indicates that the sequence of items selected by
               that instruction is to be processed in sorted order, not in the order of the supplied
               sequence.</p>
            <example>
               <head>Processing Elements in Sorted Order</head>
               <p>For example, suppose an employee database has the form</p>
               <eg xml:space="preserve" role="xml">&lt;employees&gt;
  &lt;employee&gt;
    &lt;name&gt;
      &lt;given&gt;James&lt;/given&gt;
      &lt;family&gt;Clark&lt;/family&gt;
    &lt;/name&gt;
    ...
  &lt;/employee&gt;
&lt;/employees&gt;
</eg>
               <p>Then a list of employees sorted by name could be generated using:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="employees"&gt;
  &lt;ul&gt;
    &lt;xsl:apply-templates select="employee"&gt;
      &lt;xsl:sort select="name/family"/&gt;
      &lt;xsl:sort select="name/given"/&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="employee"&gt;
  &lt;li&gt;
    &lt;xsl:value-of select="name/given"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="name/family"/&gt;
  &lt;/li&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <p>When used within <elcode>xsl:for-each-group</elcode>, a <termref def="dt-sort-key-specification">sort key specification</termref> indicates the
               order in which the groups are to be processed. For the effect of
                  <elcode>xsl:for-each-group</elcode>, see <specref ref="grouping"/>. </p>
         </div2>
         <div2 id="uca-collations" diff="del" at="A">
            <head>The Unicode Collation Algorithm</head>


            <p><emph>The description of the Unicode Collation Algorithm in this section is
                  technically identical to the description found in <bibref ref="xpath-31"/>. The
                  description here is to be used by a processor that does not implement the XPath 3.1 feature;
                  if the processor does implement the XPath 3.1 feature, the description in <bibref ref="xpath-31"/>
                  applies.</emph></p>


            <p>XSLT 3.0 defines a family of collation URIs representing tailorings of the Unicode
               Collation Algorithm (UCA) as defined in <bibref ref="UNICODE-TR10"/>. The parameters
               used for tailoring the UCA are based on the parameters defined in the Locale Data
               Markup Language (LDML), defined in <bibref ref="UNICODE-TR35"/>.</p>

            <p>This family of URIs use the scheme and path
                  <code>http://www.w3.org/2013/collation/UCA</code> followed by an optional query
               part. The query part, if present, consists of a question mark followed by a sequence
               of zero or more semicolon-separated parameters. Each parameter is a keyword-value
               pair, the keyword and value being separated by an equals sign.</p>

            <p>All implementations must recognize URIs in this family. This applies to all places
               where collations are used, including (for example) the <elcode>xsl:sort</elcode>,
                  <elcode>xsl:key</elcode>, <elcode>xsl:for-each-group</elcode>, and
                  <elcode>xsl:merge-key</elcode> elements, the <code>[xsl:]default-collation</code>
               attribute, and the <code>collation</code> argument of functions such as <xfunction>contains</xfunction>,
               <xfunction>max</xfunction>,
                and <function>collation-key</function>.
                If the <code>fallback</code> parameter is present with the
               value <code>no</code>, then the implementation <rfc2119>must</rfc2119> either use a
               collation that conforms with the rules in the Unicode specifications for the
               requested tailoring, or fail with a static or dynamic error indicating that it does
               not provide the collation (the error code should be the same as if the collation URI
               were not recognized). If the <code>fallback</code> parameter is omitted or takes the
               value <code>yes</code>, and if the collation URI is well-formed according to the
               rules in this section, then the implementation <rfc2119>must</rfc2119> accept the
               collation URI, and <rfc2119>should</rfc2119> use the available collation that most
               closely reflects the user’s intentions. For example, if the collation URI
               requested is <code>http://www.w3.org/2013/collation/UCA?lang=se;fallback=yes</code>
               and the implementation does not include a fully conformant version of the UCA
               tailored for Swedish, then it <rfc2119>may</rfc2119> choose to use a Swedish
               collation that is known to differ from the UCA definition, or one whose conformance
               has not been established. It might even, as a last resort, fall back to using
               codepoint collation.</p>
            <p>If two query parameters use the same keyword then the last one wins. If a query
               parameter uses a keyword or value which is not defined in this specification then the
               meaning is <termref def="dt-implementation-defined"/>. If the implementation
               recognizes the meaning of the keyword and value then it <rfc2119>should</rfc2119>
               interpret it accordingly; if it does not recognize the keyword or value then if the
                  <code>fallback</code> parameter is present with the value <code>no</code> it
               should reject the collation as unsupported, otherwise it should ignore the
               unrecognized parameter.</p>

            <p>The following query parameters are defined. If any parameter is absent, the default
               is <termref def="dt-implementation-defined"/> except where otherwise stated. The
               meaning given for each parameter is non-normative; the normative specification is
               found in <bibref ref="UNICODE-TR35"/>.</p>

            <imp-def-feature id="idf-local-ucaextensions">When using the family of URIs that invoke
               the Unicode Collation Algorithm, the effect of supplying a query keyword or value not
               defined in this specification is <termref def="dt-implementation-defined"/>. The
               defaults for query keywords are also implementation-defined unless otherwise
               stated.</imp-def-feature>

            <table class="data">
               <caption>Options for the Unicode Collation Algorithm</caption>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Keyword</th>
                     <th rowspan="1" colspan="1">Values</th>
                     <th rowspan="1" colspan="1">Meaning</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td rowspan="1" colspan="1">fallback</td>
                     <td rowspan="1" colspan="1">yes | no (default yes)</td>
                     <td rowspan="1" colspan="1">Determines whether the processor uses a fallback collation if a conformant
                        collation is not available.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">lang</td>
                     <td rowspan="1" colspan="1">language code, as defined for the <code>lang</code> attribute of
                           <elcode>xsl:sort</elcode></td>
                     <td rowspan="1" colspan="1">The language whose collation conventions are to be used.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">version</td>
                     <td rowspan="1" colspan="1">string</td>
                     <td rowspan="1" colspan="1">The version number of the UCA to be used.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">strength</td>
                     <td rowspan="1" colspan="1">primary | secondary | tertiary | quaternary | identical, or 1|2|3|4|5 as
                        synonyms</td>
                     <td rowspan="1" colspan="1">The collation strength as defined in UCA. Primary strength takes only the
                        base form of the character into account (so A=a=Â=â); secondary strength
                        ignores case but considers accents and diacritics as significant (so A=a and
                        Â=â but â!=a); tertiary considers case as significant (A!=a!=Â!=â);
                        quaternary considers spaces and punctuation that would otherwise be ignored
                        (for example <code>data-base</code>=<code>database</code>).</td>
                  </tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">maxVariable</td>
                     <td valign="top" rowspan="1" colspan="1">space | punct | symbol | currency (default punct)</td>
                     <td valign="top" rowspan="1" colspan="1">
                     Indicates that all characters in the specified group and earlier groups are treated as "noise" characters 
                     to be handled as defined by the <code>alternate</code> parameter. 
                        For example, <code>maxVariable=punct</code> indicates 
                     that characters classified as whitespace or punctuation get this treatment.</td></tr>
                  <tr>
                     <td valign="top" rowspan="1" colspan="1">alternate</td>
                     <td valign="top" rowspan="1" colspan="1">non-ignorable | shifted | blanked (default non-ignorable)</td>
                     <td valign="top" rowspan="1" colspan="1">Controls the handling of characters such as spaces and hyphens;
                        specifically, the “noise” characters in the groups selected by the <code>maxVariable</code> parameter. 
                        The value <code>non-ignorable</code>
                     indicates that such characters are treated as distinct at the primary level 
                     (so <code>data base</code> sorts before <code>datatype</code>);
                     <code>shifted</code> indicates that they are used to differentiate two strings only at the 
                        <code>quaternary</code> level,
                     and <code>blanked</code> indicates that they are taken into account only at the <code>identical</code> level.
                     </td></tr>
                  
                  
                  <tr>
                     <td rowspan="1" colspan="1">backwards</td>
                     <td rowspan="1" colspan="1">yes | no (default no)</td>
                     <td rowspan="1" colspan="1">The value <code>backwards=yes</code> indicates that the last accent in the
                        search term is the most significant.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">normalization</td>
                     <td rowspan="1" colspan="1">yes | no (default no)</td>
                     <td rowspan="1" colspan="1">Indicates whether search terms are converted to normalization form D.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">caseLevel</td>
                     <td rowspan="1" colspan="1">yes | no (default no)</td>
                     <td rowspan="1" colspan="1">When used with primary strength, setting <code>caseLevel=yes</code> has the
                        effect of ignoring accents while taking account of case.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">caseFirst</td>
                     <td rowspan="1" colspan="1">upper | lower</td>
                     <td rowspan="1" colspan="1">Indicates whether upper-case precedes lower-case or vice versa.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">numeric</td>
                     <td rowspan="1" colspan="1">yes | no (default no)</td>
                     <td rowspan="1" colspan="1">When <code>numeric=yes</code> is specified, a sequence of consecutive
                        digits is interpreted as a number, for example <code>chap2</code> sorts
                        before <code>chap12</code>.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">reorder</td>
                     <td rowspan="1" colspan="1">a comma-separated sequence of reorder codes, where a reorder code is one of
                           <code>space</code>, <code>punct</code>, <code>symbol</code>,
                           <code>currency</code>, <code>digit</code>, or a four-letter script code
                        defined in <bibref ref="ISO15924_register"/>, the register of scripts
                        maintained by the Unicode Consortium in its capacity as registration
                        authority for <bibref ref="ISO15924"/>.</td>
                     <td rowspan="1" colspan="1">Determines the relative ordering of text in different scripts; for example
                        the value <code>digit,Grek,Latn</code> indicates that digits precede Greek
                        letters, which precede Latin letters.</td>
                  </tr>


               </tbody>
            </table>

            <note>
               <p>This list excludes parameters that are inconvenient to express in a URI, or that
                  are applicable only to substring matching.</p>
            </note>
         </div2>
      </div1>
      <div1 id="grouping">
         <head>Grouping</head>
         <p>The facilities described in this section are designed to allow items in a sequence to be
            grouped based on common values; for example it allows grouping of elements having the
            same value for a particular attribute, or elements with the same name, or elements with
            common values for any other <termref def="dt-expression">expression</termref>. Since
            grouping identifies items with duplicate values, the same facilities also allow
            selection of the distinct values in a sequence of items, that is, the elimination of
            duplicates.</p>
         <note>
            <p>Simple elimination of duplicates can also be achieved using the function
                  <xfunction>distinct-values</xfunction>: see <bibref ref="xpath-functions-40"/>.</p>
         </note>
         <p>In addition these facilities allow grouping based on sequential position, for example
            selecting groups of adjacent <code>para</code> elements. The facilities also provide an
            easy way to do fixed-size grouping, for example identifying groups of three adjacent
            nodes, which is useful when arranging data in multiple columns.</p>
         <p>For each group of items identified, it is possible to evaluate a <termref def="dt-sequence-constructor">sequence constructor</termref> for the group. Grouping
            is nestable to multiple levels so that groups of distinct items can be identified, then
            from among the distinct groups selected, further sub-grouping of distinct items in the
            current group can be done. </p>
         <p>It is also possible for one item to participate in more than one group.</p>

         <div2 id="xsl-for-each-group">
            <head>The <code>xsl:for-each-group</code> Element</head>
            
            <p>The <elcode>xsl:for-each-group</elcode> <termref def="dt-instruction">instruction</termref> 
               allows a flat sequence of items to be processed as a sequence
               of groups, allowing a number of criteria to be used to define the grouping. The
               instruction may be used anywhere within a <termref def="dt-sequence-constructor">sequence
               constructor</termref>.</p>
            
            <p diff="add" at="A">As with <code>xsl:for-each</code>, the instruction is extended in XSLT 4.0 to allow maps and arrays
               to be processed.</p>
            
 
 
            <?element xsl:for-each-group?>
            
            
            <p diff="del" at="A">The attributes <code>select</code>, <code>array</code>, and <code>map</code>
               are mutually exclusive: exactly one of these three attributes must be present.</p>
            <p diff="del" at="A">Specifying <code>array="EXPR"</code> is equivalent to specifying
               <code>select="array:for-each(EXPR, function($x){map{'value':$x})?*</code>. That is, it maps the
               elements of an input array to a sequence of items, each item being a map having a single entry, whose
               key is the string <code>value</code> and whose corresponding value is the relevant element of the
               array. Within the contained sequence constructor, the current array element can be refered to
               as <code>?value</code>.</p>
            <p diff="del" at="A">Specifying <code>map="EXPR"</code> is equivalent to specifying
               <code>select="map:for-each(EXPR, function($k, $v){map{'key':$k, 'value':$v})</code>. That is, it maps the
               key-value entries of an input map to a sequence of items (in undefined order), each item being a map having 
               two entries, one entry holding the key, and the other holding the value. 
               Within the contained sequence constructor, the key and value of the current entry in the input map
               can be refered to as <code>?key</code> and <code>?value</code> respectively.</p>
            
            
            <p>The <code>select</code> attribute <phrase diff="add" at="A">(whether written explicitly, or constructed
               as described above)</phrase> contains an
               <termref def="dt-expression">expression</termref> which is evaluated to produce a
               sequence, called the <termref def="dt-population"/>.</p>
            
            <p>
               <termdef id="dt-group" term="group">The <elcode>xsl:for-each-group</elcode>
                  instruction allocates the items in an input sequence into <term>groups</term> of
                  items (that is, it establishes a collection of sequences) based either on common
                  values of a grouping key, or on a <termref def="dt-pattern">pattern</termref> that
                  the initial or final item in a group must
                  match.</termdef> The <termref def="dt-sequence-constructor">sequence
                  constructor</termref> that forms the content of the
                  <elcode>xsl:for-each-group</elcode> instruction is evaluated once for each of
               these groups.</p>
            <p>
               <termdef id="dt-population" term="population">The sequence of items to be grouped,
                  which is referred to as the <term>population</term>, is determined by evaluating
                  the XPath <termref def="dt-expression">expression</termref> contained in the
                  <code>select</code> attribute, <phrase diff="add" at="A">or constructed from the expressions in the 
                  <code>array</code> or <code>map</code> attributes</phrase>.</termdef>
            </p>
            <p>
               <termdef id="dt-population-order" term="population order">The population is treated
                  as a sequence; the order of items in this sequence is referred to as
                     <term>population order</term>.</termdef></p>
            <p>A group is never empty. If the population is empty, the number of groups will be
               zero.</p>
            <p>The assignment of items to groups depends on the <code>group-by</code>,
                  <code>group-adjacent</code>, <code>group-starting-with</code>, 
                  <code>group-ending-with</code>, <phrase diff="add" at="A">and <code>break-when</code></phrase> attributes. </p>
            <p>
               <error spec="XT" type="static" class="SE" code="1080">
                  <p>These <phrase diff="add" at="A">five</phrase> attributes <error.extra>the <code>group-by</code>,
                           <code>group-adjacent</code>, <code>group-starting-with</code>, 
                     <code>group-ending-with</code>, 
                     <phrase diff="add" at="A">and <code>break-when</code></phrase> attributes of
                           <elcode>xsl:for-each-group</elcode>
                     </error.extra> are mutually exclusive: it is a <termref def="dt-static-error">static error</termref> 
                     if none of these attributes is present or if
                     more than one of them is present.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="1090">
                  <p>It is a <termref def="dt-static-error">static error</termref> to specify the
                        <code>collation</code> attribute or the
                           <code>composite</code> attribute if neither the
                        <code>group-by</code> attribute nor <code>group-adjacent</code> attribute is
                     specified.</p>
               </error>
            </p>

            <p>
               <termdef id="dt-grouping-key" term="grouping key">If either of the
                     <code>group-by</code> or <code>group-adjacent</code> attributes is present,
                  then for each item in the <termref def="dt-population">population</termref> a set
                  of <term>grouping keys</term> is calculated, as follows: the expression contained
                  in the <code>group-by</code> or <code>group-adjacent</code> attribute is
                  evaluated; the result is atomized; and any <code>xs:untypedAtomic</code> values
                  are cast to <code>xs:string</code>. If
                        <code>composite="yes"</code> is specified, there is a single grouping key
                     whose value is the resulting sequence; otherwise, there is a set of grouping
                     keys, consisting of the distinct atomic values present in the result
                     sequence.</termdef>
            </p>
            <p>When calculating grouping keys for an item in the population, the <termref def="dt-expression">expression</termref> contained in the <code>group-by</code> or
                  <code>group-adjacent</code> attribute is evaluated with that item as the <termref def="dt-context-item">context item</termref>, with its position in <termref def="dt-population-order">population order</termref> as the <termref def="dt-context-position">context position</termref>, and with the size of the
               population as the <termref def="dt-context-size">context size</termref>.</p>
            <p>If the <code>group-by</code> attribute is present, and if
                  the <code>composite</code> attribute is omitted or takes the value
                  <code>no</code>, then an item in the population <rfc2119>may</rfc2119>
               have multiple grouping keys: that is, the <code>group-by</code> expression evaluates
               to a sequence, and each item in the sequence is treated as
                  a separate grouping key.  The item is included in as many groups as there
               are distinct grouping keys (which may be zero).</p>
            <p>If the <code>group-adjacent</code> attribute is used, and
                  if the <code>composite</code> attribute is omitted or takes the value
                     <code>no</code>, then each item in the population
                  <rfc2119>must</rfc2119> have exactly one grouping key value.</p>
            <p>
               <error spec="XT" type="type" class="TE" code="1100">
                  <p>It is a <termref def="dt-type-error">type error</termref> if the result of
                     evaluating the <code>group-adjacent</code> expression is an empty sequence or a
                     sequence containing more than one item, unless
                           <code>composite="yes"</code> is specified.</p>
               </error>
            </p>
            <p diff="chg" at="A">
               <termref def="dt-grouping-key">Grouping keys</termref> are compared using
               the rules of the <function>distinct-values</function> function, using the relevant collation.
               The relevant collation is the collation specified as the 
               <termref def="dt-effective-value">effective value</termref> of the <code>collation</code>
               attribute, resolved if relative against the base URI of the
               <elcode>xsl:for-each-group</elcode> element; if there is no <code>collation</code>
               attribute then the <termref def="dt-default-collation">default collation</termref> is
               used. Given this collation, two grouping keys <var>K1</var> and <var>K2</var>
               are considered equal if <code>count(distinct-values(($K1, $K2), $collation)) = 1</code>.
            </p>
            
    
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1110">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the collation URI
                     specified to <elcode>xsl:for-each-group</elcode> (after resolving against the
                     base URI) is a collation that is not recognized by the implementation. (For
                     notes, <errorref class="DE" code="1035"/>.)</p>
               </error>
            </p>
            <p>For more information on collations, see <specref ref="collating-sequences"/>.</p>
            
            <p>The way in which an <elcode>xsl:for-each-group</elcode> element is
               evaluated depends on which of the four group-defining attributes is present:</p>
            <ulist>
               <item>
                  <p>If the <code>group-by</code> attribute is present, the items in the <termref def="dt-population">population</termref> are examined, in population order.
                     For each item <var>J</var>, the expression in the <code>group-by</code>
                     attribute is evaluated to produce a sequence of zero or more <termref def="dt-grouping-key">grouping key</termref> values. If <code>composite="yes"</code> is specified, there will be a single
                        grouping key, which will in general be a sequence of zero or more atomic
                        values; otherwise, there will be zero or more grouping keys, each of which
                        will be a single atomic value. For each one of these <termref def="dt-grouping-key">grouping keys</termref>, if there is already a group
                     created to hold items having that grouping key value, <var>J</var> is appended to that group; otherwise a new group is
                     created for items with that grouping key value, and <var>J</var> becomes its
                     first member.</p>
                  <!--</p>					
						<p>If the <code>group-by</code> attribute is present, then  
all items that have the same <termref def="dt-grouping-key">grouping key</termref> are assigned to 
the same group, and the-->
                  <p>An item in the population may thus be appended to zero, one, or many groups. An item will never be
                        appended more than once to the same
                     group; if two or more grouping keys for the same item are equal, then the
                     duplicates are ignored. An <emph>item</emph> here means the item at a
                     particular position within the population—<!--em dash-->if the
                     population contains the same node at several different positions in the
                     sequence then a group may indeed contain duplicate nodes.</p>
                  <p>The number of groups will be the same as the number of distinct grouping key
                     values present in the <termref def="dt-population">population</termref>. </p>
                  <!--Text inserted by erratum E25 change 2"-->
                  <p diff="del" at="A">If the population contains values of different numeric types that differ from
                     each other by small amounts, then the <code>eq</code> operator is not
                     transitive, because of rounding effects occurring during type promotion. The
                     effect of this is described in <specref ref="non-transitivity"/>.</p>
                  <!--End of text inserted by erratum E25-->
               </item>
               <item>
                  <p>If the <code>group-adjacent</code> attribute is present, the items in the
                        <termref def="dt-population">population</termref> are examined, in
                     population order. If an item has the same value for the <termref def="dt-grouping-key">grouping key</termref> as its preceding item within
                     the <termref def="dt-population">population</termref> (in <termref def="dt-population-order">population order</termref>), then it is appended to the same group as its preceding item;
                     otherwise a new group is created and the item becomes its first member.</p>
               </item>
               <item>
                  <p>If the <code>group-starting-with</code> attribute is present, then its value
                        <rfc2119>must</rfc2119> be a <nt def="Pattern40">pattern</nt>. </p>
                  <p>The items in the <termref def="dt-population">population</termref> are examined in <termref def="dt-population-order">population order</termref>. If an item matches the pattern, or is the first item in the population, then a new group is
                     created and the item becomes its first
                     member. Otherwise, the item is appended to the same group as its preceding
                        item within the population.</p>
               </item>
               <item>
                  <p>If the <code>group-ending-with</code> attribute is present, then its value
                        <rfc2119>must</rfc2119> be a <nt def="Pattern40">pattern</nt>. </p>
                  <p>The items in the <termref def="dt-population">population</termref> are examined in <termref def="dt-population-order">population order</termref>. If an item is the first item in the population, or if the previous item in the population matches the pattern, then a new group
                     is created and the item becomes its first
                     member. Otherwise, the item is appended to the same group as its preceding
                        item within the population.</p>
               </item>
               <item diff="add" at="A">
                  <p>If the <code>break-when</code> attribute is present, then its value
                     <rfc2119>must</rfc2119> be an expression.
                     This expression is evaluated once for every item in the <termref def="dt-population"/>
                     except the first. The context item is that item, the context position is its position
                     in the <termref def="dt-population"/>, and the context size is the size of the population.
                     The <termref def="dt-current-group"/> is set to contain all items that have already
                     been added to the latest group. It is supplied with two variables: <code>$group</code> is set to the 
                     current group being constructed, and <code>$next</code> is the next item in the population. 
                     If the <xtermref ref="dt-effective-boolean-value" spec="XP40">effective boolean value</xtermref>
                     of the expression is <code>true</code>, then this
                  item forms the start of a new group; if it is <code>false</code>, the item is added to the existing
                  group.</p>
                  <p>For example:</p>
                  <ulist>
                     <item><p><code>break-when="count($group) = 3"</code> starts a new
                     group whenever the existing group has exactly three members; that is, it partitions the
                     population into groups of size 3 (with the last group being smaller if necessary).</p></item>
                     <item><p><code>break-when="$next[self::h1]"</code> starts a new
                        group whenever an <code>h1</code> element is encountered. The effect is the
                     same as specifying <code>group-starting-with="h1"</code></p></item>
                     <item><p><code>break-when="$group[last()]/@continued='no'"</code> starts a new
                        group immediately after any element having <code>@continued="no"</code>. The effect is the
                        same as specifying <code>group-ending-with="*[@continued='no']"</code></p></item>
                     <item><p><code>break-when="node-name($group[last()] != node-name($next)"</code> 
                        starts a new group whenever the name of an item differs from the name of the previous
                     item. The effect is the same as specifying <code>group-adjacent="node-name(.)"</code>.</p></item>
                     <item><p><code>break-when="$group[last()][self::hr] or $next[self::hr]"</code> 
                        starts a new group immediately before and immediately after every <code>hr</code>
                        element. (That is, <code>hr</code> elements become singleton groups.)</p></item>
                     <item><p><code>break-when="$next ne $group[last()] + 1"</code> 
                        starts a new group whenever the current item is not equal to the previous item
                     plus one. For example <code>1, 2, 5, 6, 7, 10, 11</code> is grouped as <code>(1, 2), (5, 6, 7),
                     (10, 11)</code>.</p></item>
                     <item><p><code>break-when="sum($group/string-length()) gt 40"</code> starts a new
                     group when the sum of the string lengths of the items in the current group exceeds 40.</p></item>
                     <item><p><code>break-when="ends-with($group[last()], '.') and matches($next, '^\p{Lu}')"</code> 
                        starts a new group when the last item in the current group ends with <code>"."</code> and the
                        next item starts with a capital letter.</p></item>
                     <item><p><code>break-when="deep-equal(slice($group, -2 to -1), ('', ''))"</code> 
                        starts a new group after two consecutive zero-length strings.</p></item>
                     <item><p><code>break-when="count($group) gt 1 and $group[1]/@name = $group[last()]/@name"</code> 
                        starts a new group if the last item in the current group has the same value for <code>@name</code>
                        as the first item in that group (provided they are not the same item).</p></item>
                  </ulist>
                  
               </item>
            </ulist>
            <p>In all cases the order of items within each group is predictable,
               and reflects the original <termref def="dt-population-order">population
                  order</termref>, in that the items are processed in population order and each item
               is appended at the end of zero or more groups.</p>
            <note>
               <p>As always, a different algorithm may be used if it achieves the same effect.</p>
            </note>
            <p>
               <termdef id="dt-initial-item" term="initial item">For each <termref def="dt-group">group</termref>, the item within the group that is first in <termref def="dt-population-order">population order</termref> is known as the
                     <term>initial item</term> of the group.</termdef>
            </p>
            <p>The <termref def="dt-sequence-constructor"/> contained in the
                  <elcode>xsl:for-each-group</elcode> element is evaluated once for each of the
                  <termref def="dt-group">groups</termref>, in <termref def="dt-processing-order">processing order</termref>. The sequences that result are concatenated, in
                  <termref def="dt-processing-order">processing order</termref>, to form the result
               of the <elcode>xsl:for-each-group</elcode> element. Within the <termref def="dt-sequence-constructor">sequence constructor</termref>, the <termref def="dt-context-item">context item</termref> is the <termref def="dt-initial-item">initial item</termref> of the relevant group, the <termref def="dt-context-position">context position</termref> is the position of this
                  group in the <termref def="dt-processing-order">processing order</termref> of the groups, and the <termref def="dt-context-size">context size</termref> is the number of groups This has the effect
               that within the <termref def="dt-sequence-constructor"/>, a call on
                  <code>position()</code> takes successive values <code>1, 2, ... last()</code>.</p>

         </div2>
         <div2 id="information-about-group">
            <head>Accessing Information about the Current Group Value</head>

            <p>Two pieces of information are available during the processing of each group (that is,
               while evaluating the sequence constructor contained in the
                  <elcode>xsl:for-each-group</elcode> instruction, and also while evaluating the
               sort key of a group as expressed by the <code>select</code> attribute or sequence
               constructor of an <elcode>xsl:sort</elcode> child of the
                  <elcode>xsl:for-each-group</elcode> element):</p>

            <ulist>
               <item>
                  <p><termdef id="dt-current-group" term="current group">The <term>current
                           group</term> is the <termref def="dt-group">group</termref> itself, as a
                        sequence of items</termdef>.</p>
               </item>
               <item>
                  <p><termdef id="dt-current-grouping-key" term="current grouping key">The
                           <term>current grouping key</term> is a single atomic value, or in the
                        case of a composite key, a sequence of atomic values, containing the
                           <termref def="dt-grouping-key"/> of the items in the <termref def="dt-current-group"/>.</termdef></p>
               </item>
            </ulist>

  

            <p>Information about the <termref def="dt-current-group"/>
               and the <termref def="dt-current-grouping-key"/> is held in the dynamic context, and
               is available using the <function>current-group</function> and
                  <function>current-grouping-key</function> functions respectively.</p>

            <p>In XSLT 2.0, the <termref def="dt-current-group"/> and the
                  <termref def="dt-current-grouping-key"/> were passed unchanged through calls of
                  <elcode>xsl:apply-templates</elcode> and <elcode>xsl:call-template</elcode>, and
               also <elcode>xsl:apply-imports</elcode> and <elcode>xsl:next-match</elcode>. This
               behavior is retained in XSLT 3.0 except in the case where streaming is in use:
               specifically, if the <elcode>xsl:apply-templates</elcode>,
                  <elcode>xsl:call-template</elcode>, <elcode>xsl:apply-imports</elcode>, or
                  <elcode>xsl:next-match</elcode> instruction occurs within a <termref def="dt-declared-streamable"/> construct (typically, within an
                  <elcode>xsl:source-document</elcode> instruction, or within a streamable <termref def="dt-template-rule"/>), then the current group and current grouping key are set
               to <termref def="dt-absent"/> in the called template. The reason for this is to allow
               the streamability of an <elcode>xsl:for-each-group</elcode> instruction to be
               assessed statically, as described in <specref ref="streamability-xsl-for-each-group"/>.</p>

            <note diff="add" at="A">
               <p>If the <code>array</code> attribute of <elcode>xsl:for-each-group</elcode> is used, the value
               of the <termref def="dt-current-group"/> will be a sequence of maps, each having a single entry
               with the key <code>value</code>. It is therefore possible to process the array elements making
               up the current group with an expression such as <code>current-group()?value</code>. Similarly,
               if the <code>map</code> attribute is used, the expressions <code>current-group()?key</code>
               and <code>current-group()?value</code> can be used to refer to the grouped keys and values respectively.</p>
            </note>


            <div3 id="func-current-group">
               <head><?function fn:current-group?></head>

            </div3>
            <div3 id="func-current-grouping-key">
               <head><?function fn:current-grouping-key?></head>

            </div3>
         </div2>


         <div2 id="order-of-groups">
            <head>Ordering among Groups</head>
            <p>
               <termdef id="dt-first-appearance" term="order of first appearance">There is a total ordering among <termref def="dt-group">groups</termref> referred to as the <term>order of first appearance</term>. A
                  group <var>G</var> is defined to precede a group <var>H</var> in order of first
                  appearance if the <termref def="dt-initial-item">initial item</termref> of
                     <var>G</var> precedes the initial item of <var>H</var> in population order. If
                  two groups <var>G</var> and <var>H</var> have the same initial item (because the
                  item is in both groups) then <var>G</var> precedes <var>H</var> if the <termref def="dt-grouping-key">grouping key</termref> of <var>G</var> precedes the
                  grouping key of <var>H</var> in the sequence that results from evaluating the
                     <code>group-by</code> expression of this initial item.</termdef>
            </p>
            <p>
               <termdef id="dt-processing-order" term="processing order">There is another total ordering among groups referred to as
                     <term>processing order</term>. If group <var>R</var> precedes group
                     <var>S</var> in processing order, then in the result sequence returned by the
                     <elcode>xsl:for-each-group</elcode> instruction the items generated by
                  processing group <var>R</var> will precede the items generated by processing group
                     <var>S</var>.</termdef>
            </p>
            <p>If there are no <elcode>xsl:sort</elcode> elements immediately within the
                  <elcode>xsl:for-each-group</elcode> element, the <termref def="dt-processing-order">processing order</termref> of the <termref def="dt-group">groups</termref> is the <termref def="dt-first-appearance">order of
                  first appearance</termref>.</p>
            <!--Text replaced by erratum E8 change 1"-->
            <p>Otherwise, the <elcode>xsl:sort</elcode> elements immediately within the
                  <elcode>xsl:for-each-group</elcode> element define the processing order of the
                  <termref def="dt-group">groups</termref> (see <specref ref="sorting"/>). They do
               not affect the order of items within each group. Multiple <termref def="dt-sort-key-component">sort key components</termref> are allowed, and are
               evaluated in major-to-minor order. If two groups have the same values for all their
               sort key components, they are processed in <termref def="dt-first-appearance"/> if
               the <termref def="dt-sort-key-specification">sort key specification</termref> is
                  <termref def="dt-stable">stable</termref>, otherwise in an <termref def="dt-implementation-dependent">implementation-dependent</termref> order.</p>
            <!--End of text replaced by erratum E8-->
            <p>The <code>select</code>
               <termref def="dt-expression">expression</termref> of an <elcode>xsl:sort</elcode>
               element is evaluated once for each <termref def="dt-group">group</termref>. During
               this evaluation, the <termref def="dt-context-item">context item</termref> is the
                  <termref def="dt-initial-item">initial item</termref> of the group, the <termref def="dt-context-position">context position</termref> is the position of this item
               within the set of initial items (that is, one item for each group in the <termref def="dt-population">population</termref>) in <termref def="dt-population-order">population order</termref>, the <termref def="dt-context-size">context
                  size</termref> is the number of groups, the <termref def="dt-current-group"/> is
               the group whose <termref def="dt-sort-key-value">sort key value</termref> is being
               determined, and the <termref def="dt-current-grouping-key"/> is the grouping key for
               that group. If the <elcode>xsl:for-each-group</elcode> instruction uses the
               <code>group-starting-with</code>, <code>group-ending-with</code><phrase diff="add" at="A">,
                  or <code>break-when</code></phrase>
               attributes, then the <termref def="dt-current-grouping-key"/> is <termref def="dt-absent"/>.</p>
            <example>
               <head>Sorting Groups</head>
               <p>For example, this means that if the <termref def="dt-grouping-key">grouping
                     key</termref> is <code>@category</code>, you can sort the groups in order of
                  their grouping key by writing <code>&lt;xsl:sort
                     select="current-grouping-key()"/&gt;</code>; or you can sort the groups in
                  order of size by writing <code>&lt;xsl:sort
                     select="count(current-group())"/&gt;</code>
               </p>
            </example>
         </div2>
         <div2 id="grouping-examples">
            <head>Examples of Grouping</head>
            
            <example>
               <head>Grouping Nodes based on Common Values</head>
               <p>The following example groups a list of nodes based on common values. The resulting
                  groups are numbered and sorted, and a
                  total is calculated for each group. </p>
               <p>Source XML document:</p>
               <eg xml:space="preserve" role="xml">&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"      pop="5"/&gt;
  &lt;city name="Paris"   country="France"      pop="7"/&gt;
  &lt;city name="München" country="Deutschland" pop="4"/&gt;
  &lt;city name="Lyon"    country="France"      pop="2"/&gt;
  &lt;city name="Venezia" country="Italia"      pop="1"/&gt;
&lt;/cities&gt;</eg>
               <p>More specifically, the aim is to produce a four-column table, containing one row
                  for each distinct country. The four columns are to contain first, a sequence
                  number giving the number of the row; second, the name of the country, third, a
                  comma-separated alphabetical list of the city names within that country, and
                  fourth, the sum of the <code>pop</code> attribute for the cities in that
                  country.</p>
               <p>Desired output:</p>
               <eg xml:space="preserve" role="xml">&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;List of Cities&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;Italia&lt;/td&gt;
    &lt;td&gt;Milano, Venezia&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;France&lt;/td&gt;
    &lt;td&gt;Lyon, Paris&lt;/td&gt;
    &lt;td&gt;9&lt;/td&gt;
  &lt;/tr&gt;  
  &lt;tr&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;Deutschland&lt;/td&gt;
    &lt;td&gt;München&lt;/td&gt;
    &lt;td&gt;4&lt;/td&gt;
  &lt;/tr&gt;  
&lt;/table&gt;</eg>
               <p>Solution:</p>
               <eg xml:space="preserve" role="xml">&lt;table xsl:version="3.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;City List&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;xsl:for-each-group select="cities/city" group-by="@country"&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;xsl:value-of select="position()"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="current-grouping-key()"/&gt;&lt;/td&gt;
      &lt;td&gt;
        &lt;xsl:for-each select="current-group()/@name"&gt;
          &lt;xsl:sort select="."/&gt;
          &lt;xsl:if test="position() ne 1"&gt;, &lt;/xsl:if&gt;
          &lt;xsl:value-of select="."/&gt;
        &lt;/xsl:for-each&gt;  
      &lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="sum(current-group()/@pop)"/&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/table&gt;</eg>
            </example>
            <!--
				<example>
					<p>The following example uses the same source document, this time
	 grouping the cities according to the initial letter of the city name. The groups
	 are sorted, and the result includes a count of the nodes within the group.
	 The heading contains a count of the number of groups:</p>
					<p>Desired output:</p>
					<eg role="xml"><![CDATA[<html>
  <body>
    <h2>L (1)</h2><p>Lyon</p>
    <h2>M (2)</h2><p>Milano</p><p>München</p>
    <h2>P (1)</h2><p>Paris</p>
    <h2>V (1)</h2><p>Venezia</p>
  </body>
    </html>]]></eg>
					<p>Solution:</p>
					<eg role="xml"><![CDATA[<html xsl:version="3.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <body>
    <xsl:for-each-group select="cities/city" group-by="substring(@name,1,1)">
      <xsl:sort select="current-grouping-key()"/>
      <h2>
        <xsl:value-of select="upper-case(current-grouping-key())"/>
        <xsl:text> (</xsl:text>
        <xsl:value-of select="count(current-group())"/>
        <xsl:text>)</xsl:text>
      </h2>
      <xsl:for-each select="current-group()">
        <p><xsl:value-of select="@name"/></p>
      </xsl:for-each>
    </xsl:for-each-group>
  </body>
</html>]]></eg>
				</example>
-->
            <example>
               <head>A Composite Grouping Key</head>
               <p>Sometimes it is necessary to use a composite grouping key: for example, suppose
                  the source document is similar to the one used in the previous examples, but
                  allows multiple entries for the same country and city, such as:</p>
               <eg xml:space="preserve" role="xml">&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"  year="1950"   pop="5.23"/&gt;
  &lt;city name="Milano"  country="Italia"  year="1960"   pop="5.29"/&gt;  
  &lt;city name="Padova"  country="Italia"  year="1950"   pop="0.69"/&gt;
  &lt;city name="Padova"  country="Italia"  year="1960"   pop="0.93"/&gt;    
  &lt;city name="Paris"   country="France"  year="1951"   pop="7.2"/&gt;
  &lt;city name="Paris"   country="France"  year="1961"   pop="7.6"/&gt;
&lt;/cities&gt;</eg>
               <p>Now suppose we want to list the average value of <code>@pop</code> for each
                  (country, name) combination. One way to handle this is to concatenate the parts of
                  the key, for example <code>&lt;xsl:for-each-group select="concat(@country, '/',
                     @name)"&gt;</code>. A second solution is to nest one
                     <elcode>xsl:for-each-group</elcode> element directly inside another. XSLT 3.0
                  introduces a third option, which is to define the grouping key as composite:</p>
               <eg xml:space="preserve" role="xslt-instruction">
&lt;xsl:for-each-group select="cities/city" 
                    group-by="@name, @country" 
                    composite="yes"&gt;
  &lt;p&gt;
    &lt;xsl:value-of select="current-grouping-key()[1] || ', ' ||
                          current-grouping-key()[2] || ': ' || 
                          avg(current-group()/@pop)"/&gt;
  &lt;/p&gt;
&lt;/xsl:for-each-group&gt;</eg>
               <note>
                  <p>The string concatenation operator <code>||</code> is new in XPath 3.0.</p>
               </note>
            </example>
            <example>
               <head>Identifying a Group by its Initial Element</head>
               <p>The next example identifies a group not by the presence of a common value, but
                  rather by adjacency in document order. A group consists of an <code>h2</code>
                  element, followed by all the <code>p</code> elements up to the next
                     <code>h2</code> element.</p>
               <p>Source XML document:</p>
               <eg xml:space="preserve" role="xml">&lt;body&gt;
  &lt;h2&gt;Introduction&lt;/h2&gt;
  &lt;p&gt;XSLT is used to write stylesheets.&lt;/p&gt;
  &lt;p&gt;XQuery is used to query XML databases.&lt;/p&gt;
  &lt;h2&gt;What is a stylesheet?&lt;/h2&gt;
  &lt;p&gt;A stylesheet is an XML document used to define a transformation.&lt;/p&gt;
  &lt;p&gt;Stylesheets may be written in XSLT.&lt;/p&gt;
  &lt;p&gt;XSLT 2.0 introduces new grouping constructs.&lt;/p&gt;
&lt;/body&gt;</eg>
               <p>Desired output:</p>
               <eg xml:space="preserve" role="xml">&lt;chapter&gt;
  &lt;section title="Introduction"&gt;
    &lt;para&gt;XSLT is used to write stylesheets.&lt;/para&gt;
    &lt;para&gt;XQuery is used to query XML databases.&lt;/para&gt;
  &lt;/section&gt; 
  &lt;section title="What is a stylesheet?"&gt;
    &lt;para&gt;A stylesheet is used to define a transformation.&lt;/para&gt;
    &lt;para&gt;Stylesheets may be written in XSLT.&lt;/para&gt;
    &lt;para&gt;XSLT 2.0 introduces new grouping constructs.&lt;/para&gt;
  &lt;/section&gt;
&lt;/chapter&gt;</eg>
               <p>Solution:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="body"&gt;
  &lt;chapter&gt;
    &lt;xsl:for-each-group select="*" group-starting-with="h2"&gt;
      &lt;section title="{self::h2}"&gt;
        &lt;xsl:for-each select="current-group()[self::p]"&gt;
          &lt;para&gt;&lt;xsl:value-of select="."/&gt;&lt;/para&gt;
        &lt;/xsl:for-each&gt; 
      &lt;/section&gt;
    &lt;/xsl:for-each-group&gt;
  &lt;/chapter&gt;
&lt;/xsl:template&gt;</eg>
               <p>The use of <code>title="{self::h2}"</code> rather than <code>title="{.}"</code> is
                  to handle the case where the first element is not an <code>h2</code> element.</p>
            </example>
            <example>
               <head>Identifying a Group by its Final Element</head>
               <p>The next example illustrates how a group of related elements can be identified by
                  the last element in the group, rather than the first. Here the absence of the
                  attribute <code>continued="yes"</code> indicates the end of the group.</p>
               <p>Source XML document:</p>
               <eg xml:space="preserve" role="xml">&lt;doc&gt;
  &lt;page continued="yes"&gt;Some text&lt;/page&gt;
  &lt;page continued="yes"&gt;More text&lt;/page&gt;    
  &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;page continued="yes"&gt;Some words&lt;/page&gt;
  &lt;page continued="yes"&gt;More words&lt;/page&gt;    
  &lt;page&gt;Yet more words&lt;/page&gt;        
&lt;/doc&gt;</eg>
               <p>Desired output:</p>
               <eg xml:space="preserve" role="xml">&lt;doc&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some text&lt;/page&gt;
    &lt;page&gt;More text&lt;/page&gt;    
    &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;/pageset&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some words&lt;/page&gt;
    &lt;page&gt;More words&lt;/page&gt;    
    &lt;page&gt;Yet more words&lt;/page&gt;
  &lt;/pageset&gt;
&lt;/doc&gt;</eg>
               <p>Solution:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="doc"&gt;
&lt;doc&gt;
  &lt;xsl:for-each-group select="*" 
                      group-ending-with="page[not(@continued='yes')]"&gt;
    &lt;pageset&gt;
      &lt;xsl:for-each select="current-group()"&gt;
        &lt;page&gt;&lt;xsl:value-of select="."/&gt;&lt;/page&gt;
      &lt;/xsl:for-each&gt; 
    &lt;/pageset&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/doc&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Adding an Element to Several Groups</head>
               <p>The next example shows how an item can be added to multiple groups. Book titles
                  will be added to one group for each indexing term marked up within the title.</p>
               <p>Source XML document:</p>
               <eg xml:space="preserve" role="xml">&lt;titles&gt;
    &lt;title&gt;A Beginner's Guide to &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Learning &lt;ix&gt;XML&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Using &lt;ix&gt;XML&lt;/ix&gt; with &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
&lt;/titles&gt;</eg>
               <p>Desired output:</p>
               <eg xml:space="preserve" role="xml">&lt;h2&gt;Java&lt;/h2&gt;
    &lt;p&gt;A Beginner's Guide to Java&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;
&lt;h2&gt;XML&lt;/h2&gt;
    &lt;p&gt;Learning XML&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;</eg>
               <p>Solution:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="titles"&gt;
    &lt;xsl:for-each-group select="title" group-by="ix"&gt;
      &lt;h2&gt;&lt;xsl:value-of select="current-grouping-key()"/&gt;&lt;/h2&gt;
      &lt;xsl:for-each select="current-group()"&gt;
        &lt;p&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example>
               <head>Grouping Alternating Sequences of Elements</head>
               <p>In this example, the membership of a node within a group is based both on
                  adjacency of the nodes in document order, and on common values. In this case, the
                  grouping key is a boolean condition, true or false, so the effect is that a
                  grouping establishes a maximal sequence of nodes for which the condition is true,
                  followed by a maximal sequence for which it is false, and so on.</p>
               <p>Source XML document:</p>
               <eg xml:space="preserve" role="xml">&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    while you are in the cinema.&lt;/p&gt;</eg>
               <p>Desired output:</p>
               <eg xml:space="preserve" role="xml">&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:&lt;/p&gt;
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;while you are in the cinema.&lt;/p&gt;</eg>
               <p>Solution:</p>
               <p>This requires creating a <code>p</code> element around the maximal sequence of
                  sibling nodes that does not include a <code>ul</code> or <code>ol</code>
                  element.</p>
               <p>This can be done by using <code>group-adjacent</code>, with a grouping key that is
                  true if the element is a <code>ul</code> or <code>ol</code> element, and false
                  otherwise:</p>
               <eg xml:space="preserve" role="xslt-declaration">&lt;xsl:template match="p"&gt;
    &lt;xsl:for-each-group select="node()" 
            group-adjacent="self::ul or self::ol"&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="current-grouping-key()"&gt;
                &lt;xsl:copy-of select="current-group()"/&gt;  
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;p&gt;
                    &lt;xsl:copy-of select="current-group()"/&gt;
                &lt;/p&gt;
            &lt;/xsl:otherwise&gt;  
        &lt;/xsl:choose&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <example diff="add" at="A">
               <head>Grouping entries in a Map</head>
               <p>Consider a map with composite keys that might appear in a JSON document as:</p>
               <eg>{
   "Africa/Abidjan": {"offset": "+00:00", "DST-offset": "+00:00" },
   "Africa/Algiers": {"offset": "+01:00", "DST-offset": "+01:00" },
   "Africa/Nairobi": {"offset": "+03:00", "DST-offset": "+03:00" },
   "America/Anchorage": {"offset": "-09:00", "DST-offset": "-08:00" },
   "America/Los_Angeles": {"offset": "-08:00", "DST-offset": "-07:00" },
   "Asia/Dubai": {"offset": "+04:00", "DST-offset": "+04:00" },
   "Asia/Kolkata": {"offset": "+05:30", "DST-offset": "+05:30" }                 
}</eg>
               <p>And suppose we wish to group this into a two-level map, thus:</p>
               <eg>{
   "Africa": {
       "Abidjan": {"offset": "+00:00", "DST-offset": "+00:00" },
       "Algiers": {"offset": "+01:00", "DST-offset": "+01:00" },
       "Nairobi": {"offset": "+03:00", "DST-offset": "+03:00" }
   },    
   "America": {
       "Anchorage": {"offset": "-09:00", "DST-offset": "-08:00" },
       "Los_Angeles": {"offset": "-08:00", "DST-offset": "-07:00" }
   },    
   "Asia": {
       "Dubai": {"offset": "+04:00", "DST-offset": "+04:00" },
       "Kolkata": {"offset": "+05:30", "DST-offset": "+05:30" }
   }    
}</eg>
               <p>This can be achieved as follows:</p>
               <eg><![CDATA[<xsl:map>
   <xsl:for-each-group map="json-doc('tz.json')" group-by="substring-before(?key, '/')">
     <xsl:map-entry key="current-grouping-key()">
       <xsl:map>
         <xsl:for-each select="current-group()">
           <xsl:map-entry key="substring-after(?key, '/')" select="?value"/>
         </xsl:for-each>
       </xsl:map>
     </xsl:map-entry>
   </xsl:for-each-group>
</xsl:map>]]></eg>
            </example>
         </div2>
         <!--Text inserted by erratum E25 change 3"-->
         <div2 id="non-transitivity" diff="del" at="A">
            <head>Non-Transitivity</head>
            <p>If the population contains values of different numeric types that differ from each
               other by small amounts, then the <code>eq</code> operator is not transitive, because
               of rounding effects occurring during type promotion. It is thus possible to have
               three values <var>A</var>, <var>B</var>, and <var>C</var> among the grouping keys of
               the population such that <code>A eq B</code>, <code>B eq C</code>, but <code>A ne
                  C</code>.</p>
            <p>For example, this arises when computing</p>
            <eg xml:space="preserve" role="xslt-instruction">
      &lt;xsl:for-each-group group-by="." select="
             xs:float('1.0'),
             xs:decimal('1.0000000000100000000001'),
             xs:double('1.00000000001')"/&gt;</eg>
            <p>because the values of type <code>xs:float</code> and <code>xs:double</code> both
               compare equal to the value of type <code>xs:decimal</code> but not equal to each
               other.</p>
            <p>In this situation the results <rfc2119>must</rfc2119> be equivalent to the results
               obtained by the following algorithm:</p>
            <ulist>
               <item>
                  <p>For each item <var>J</var> in the <termref def="dt-population">population</termref> in <termref def="dt-population-order">population
                        order</termref>, for each of the <termref def="dt-grouping-key">grouping
                        keys</termref>
                     <var>K</var> for that item in sequence, the processor identifies those existing
                     groups <var>G</var> such that the grouping key of the <termref def="dt-initial-item">initial item</termref> of <var>G</var> is equal to
                        <var>K</var>.</p>
               </item>
               <item>
                  <p>If there is exactly one group <var>G</var>, then <var>J</var> is added to this
                     group, unless <var>J</var> is already a member of this group.</p>
               </item>
               <item>
                  <p>If there is no group <var>G</var>, then a new group is created with
                        <var>J</var> as its first item.</p>
               </item>
               <item>
                  <p>If there is more than one group <var>G</var> (which can only happen in
                     exceptional circumstances involving non-transitivity), then one of these groups
                     is selected in an implementation-dependent way, and <var>J</var> is added to
                     this group, unless <var>J</var> is already a member of this group.</p>
               </item>
            </ulist>
            <p>The effect of these rules is that (a) every item in a non-singleton group has a
               grouping key that is equal to that of at least one other item in that group, (b) for
               any two distinct groups, there is at least one pair of items (one from each group)
               whose grouping keys are not equal to each other.</p>
         </div2>
         <!--End of text inserted by erratum E25-->
      </div1>
      <div1 id="merging">
         <head>Merging</head>
         <p>The <elcode>xsl:merge</elcode> instruction allows a sorted sequence of items to be
            constructed by merging several input sequences. Each
            input sequence <rfc2119>must</rfc2119> have a merge key (one or more
            atomic values that can be computed as a function of the items in the sequence); the
            input sequence <rfc2119>must</rfc2119> either already be sorted on the value of
            its merge keys, or pre-sorting on these values must be requested. 
            The merge keys for the different input sequences <rfc2119>must</rfc2119> be compatible in the sense that key
               values from an item in one sequence are always comparable with key values from an
               item in a different sequence.</p>

         <p>For example, if two log files contain details of events sorted by date and time, then
            the <elcode>xsl:merge</elcode> instruction can be used to combine these into a single
            sequence that is also sorted by date and time.</p>

         <p>The data written to the output sequence can be computed in an arbitrary way from the
            data in the input sequences, provided it follows the ordering of the input
            sequences.</p>

         <p>The <elcode>xsl:merge</elcode> instruction can be used to merge several sequences of
            items that all have the same structure (more precisely, sequences whose merge keys are
            computed in the same way): for example, log files created by the same application
            running on different machines in a server farm. Alternatively,
               <elcode>xsl:merge</elcode> can be used to merge sequences that have different
            structure (sequences whose merge keys are computed in different ways), provided that the
            computed merge keys are compatible: an example might be two log files created by
            different applications, using different XML vocabularies, that both contain timestamped
            events but represent the timestamp in different ways. The
               <elcode>xsl:merge-source</elcode> element represents a set
               of input sequences that follow common rules, including the rules for
            computing the merge key. The <elcode>xsl:merge</elcode> operation may take any number of
               <elcode>xsl:merge-source</elcode> elements representing different rules for input sequences, and each <elcode>xsl:merge-source</elcode>
            element may describe any number (zero or more) of input sequences. The number of input
            sequences to the merging operation is thus fixed only at the
               time the <elcode>xsl:merge</elcode> instruction is evaluated, and
                  <rfc2119>may</rfc2119> vary from one evaluation to another.</p>

         <p>The following examples illustrate some of the possibilities. The detailed explanation of
            the constructs used follows later in this section.</p>

         <example>
            <head>Merging All the Files in a Collection</head>
            <p>This example takes as input a homogeneous collection of XML log files each of which
               contains a sorted sequence of <code>event</code> elements with a
                  <code>timestamp</code> attribute validated as an instance of
                  <code>xs:dateTime</code>. It merges the events from the input files into a single
               sorted output file.</p>
            <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:result-document href="merged-events.xml"&gt;
  &lt;events&gt;
    &lt;xsl:merge&gt;
      &lt;xsl:merge-source for-each-source="uri-collection('log-files')"
                        select="events/event"&gt;
        &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:copy-of select="current-merge-group()"/&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/events&gt;
&lt;/xsl:result-document&gt;
</eg>


            <p>The example assumes that there are several input files each
                  of which has a structure similar to the following, in which the
                  <code>timestamp</code> attribute has a typed value that is an instance of
                  <code>xs:dateTime</code>:</p>
            <eg role="xml" xml:space="preserve">
&lt;events&gt;
   &lt;event timestamp="2009-08-20T12:01:01Z"&gt;Transaction T1234 started&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:08Z"&gt;Transaction T1235 started&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:12Z"&gt;Transaction T1235 ended&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:15Z"&gt;Transaction T1234 ended&lt;/event&gt;
&lt;/events&gt;</eg>
            <p>The output file will have the same structure, and will contain copies of all the
                  <code>event</code> elements from all of the input files, in sorted order. Note that multiple events with the same timestamp can occur
                  either within a single file or across multiple files: the order of appearance of
                  these events in the output file corresponds to the order of the log files within
                  the collection (which might or might not be predictable, depending on the
                  implementation).</p>
         </example>

         <example>
            <head>Merging Two Heterogeneous Files</head>
            <p>This example takes as input two log files with different structure, producing a
               single merged output in which the entries have a common structure:</p>

            <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:result-document href="merged-events.xml"&gt;
  &lt;events&gt;
    &lt;xsl:merge&gt;
      &lt;xsl:merge-source select="doc('log-file-1.xml')/events/event"&gt;
        &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-source select="doc('log-files-2.xml')/log/day/record"&gt;
        &lt;xsl:merge-key select="dateTime(../@date, time)"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:apply-templates select="current-merge-group()" 
                             mode="standardize-log-entry"/&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/events&gt;
&lt;/xsl:result-document&gt;
</eg>


            <p>Here the first input file has a structure similar to that shown in the previous
               example, while the second input has a different structure, of the form:</p> <eg role="xml" xml:space="preserve">
&lt;log&gt;
  &lt;day date="2009-08-20"&gt;
    &lt;record&gt;
      &lt;time&gt;12:01:09-05:00&lt;/time&gt;
      &lt;message&gt;Temperature 15.4C&lt;/message&gt;
    &lt;/record&gt;
    &lt;record&gt;
      &lt;time&gt;12:03:00-05:00&lt;/time&gt;
      &lt;message&gt;Temperature 18.2C&lt;/message&gt;
    &lt;/record&gt;
  &lt;/day&gt;
&lt;/log&gt;</eg>
            <p>The templates in mode <code>standardize-log-entry</code> convert the log entries to a
               common output format, for example:</p>
            <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:template match="event" mode="standardize-log-entry" 
                            as="schema-element(event)"&gt;
  &lt;xsl:copy-of select="." validation="preserve"/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="record" mode="standardize-log-entry" 
                             as="schema-element(event)"&gt;
  &lt;event timestamp="{dateTime(../@date, time)}" xsl:validation="strict"&gt;
    &lt;xsl:value-of select="message"/&gt;
  &lt;/event&gt;
&lt;/xsl:template&gt;</eg>
         </example>

         <note>
            <p>The <elcode>xsl:merge</elcode> instruction is designed to enable streaming of data,
               so that there is no need to allocate memory to hold the input sequences. However, it can also be used in cases where streamed
                  processing is not possible, for example when the input needs to be
               sorted.</p>
         </note>


         <div2 id="merge-terminology">
            <head>Terminology for Merging</head>
            <p><termdef id="dt-merge-source-definition" term="merge source definition">A <term>merge
                     source definition</term> is the definition of one kind of input to the merge
                  operation. It selects zero or more <termref def="dt-merge-input-sequence">merge
                     input sequences</termref>, and it includes a <termref def="dt-merge-key-specification">merge key specification</termref> to define
                  how the <termref def="dt-merge-key-value">merge key
                        values</termref> are computed for each such merge input
                  sequence.</termdef> A merge source definition corresponds to an
                  <elcode>xsl:merge-source</elcode> element in the stylesheet.</p>

            <p><termdef id="dt-merge-input-sequence" term="merge input sequence">A <term>merge input
                     sequence</term> is an arbitrary <xtermref spec="DM30" ref="dt-sequence">sequence</xtermref> of items which is already sorted according to the <termref def="dt-merge-key-specification">merge key specification</termref> for the
                  corresponding <termref def="dt-merge-source-definition">merge source
                     definition</termref>.</termdef></p>

            <p><termdef id="dt-merge-key-specification" term="merge key specification">A <term>merge
                     key specification</term> consists of one or more adjacent
                     <elcode>xsl:merge-key</elcode> elements which together define how the <termref def="dt-merge-input-sequence">merge input sequences</termref> selected by a
                     <termref def="dt-merge-source-definition">merge source definition</termref> are
                  sorted. Each <elcode>xsl:merge-key</elcode> element defines one <termref def="dt-merge-key-component">merge key component</termref>.</termdef> For
               example, a merge key specification for a log file might specify two merge key
               components, <code>date</code> and <code>time</code>.</p>

            <p><termdef id="dt-merge-key-component" term="merge key component">A <term>merge key
                     component</term> specifies one component of a <termref def="dt-merge-key-specification">merge key specification</termref>; it
                  corresponds to a single <elcode>xsl:merge-key</elcode> element in the
                  stylesheet.</termdef></p>

            <p><termdef id="dt-merge-key-value" term="merge key value"> For each item in a <termref def="dt-merge-input-sequence">merge input sequence</termref>, a value is
                  computed for each <termref def="dt-merge-key-component">merge key
                     component</termref> within the <termref def="dt-merge-key-specification">merge
                     key specification</termref>. The value computed for an item by using the
                     <var>N</var>th <termref def="dt-merge-key-component"/> is referred to as the
                     <var>N</var>th <term>merge key value</term> of that item.</termdef></p>

            

            <p><termdef id="dt-composite-merge-key-value" term="composite merge key value"> The
                  ordered collection of <termref def="dt-merge-key-value">merge key values</termref>
                  computed for one item in a <termref def="dt-merge-input-sequence">merge input
                     sequence</termref> (one for each <termref def="dt-merge-key-component">merge
                     key component</termref> within the <termref def="dt-merge-key-specification">merge key specification</termref>) is referred to as a <term>composite merge
                     key value</term>.</termdef></p>
            <p><termdef id="dt-merge-activation" term="merge activation">A <term>merge
                     activation</term> is a single evaluation of the sequence constructor contained
                  within the <elcode>xsl:merge-action</elcode> element, which occurs once for each
                  distinct <termref def="dt-composite-merge-key-value">composite merge key
                     value</termref>.</termdef></p>

         </div2>

         <div2 id="merge-instruction">
            <head>The <elcode>xsl:merge</elcode> Instruction</head>
            <?element xsl:merge?>
            <p>The effect of the <elcode>xsl:merge</elcode> instruction is to produce a sorted
               result sequence from a number of input sequences.</p>

            <p>The input sequences to the merge operation are defined by the
                  <elcode>xsl:merge-source</elcode> child elements, as described in the next
               section.</p>

            <p>The sequence constructor contained in the
                  <elcode>xsl:merge-action</elcode> element is evaluated once for each distinct
                  <termref def="dt-composite-merge-key-value"/> to form a partial result sequence.
               The result of the <elcode>xsl:merge</elcode> instruction is the concatenation of
               these partial result sequences. For example, the action might be to copy the items
               from all the input sequences to the result sequence without change; or it might be to
               select the items from one input sequence in preference to the others. In the general
               case, the items in the partial result sequence are produced by an arbitrary
               computation that has access to the items (from the various input sequences) that
               share the same value for the composite merge key.</p>

            <p>The <elcode>xsl:merge-source</elcode> and
                  <elcode>xsl:merge-action</elcode> elements are described in the following
               sections.</p>

            

            

            <p>Any <elcode>xsl:fallback</elcode> children of the <elcode>xsl:merge</elcode>
               instruction are ignored by an XSLT 3.0 processor, but are used by an XSLT 1.0 or XSLT
               2.0 processor to perform fallback processing.</p>

            <note>
               <p>An <elcode>xsl:merge</elcode> instruction that has no input sequences returns an
                  empty sequence. An <elcode>xsl:merge</elcode> instruction with a single input
                  sequence performs processing that is very similar in concept to
                     <elcode>xsl:for-each-group</elcode> with the <code>group-adjacent</code>
                  attribute, except that it requires the input to be sorted on the grouping key.</p>
            </note>
         </div2>
         <div2 id="merge-input-sequences">
            <head>Selecting the Sequences to be Merged</head>
            <?element xsl:merge-source?>


            <p>Each <elcode>xsl:merge-source</elcode> element defines one or more <termref def="dt-merge-input-sequence">merge input sequences</termref>.</p>

            <p>The <code>name</code> attribute provides a means of
               distinguishing items from different merge sources within the
                  <elcode>xsl:merge-action</elcode> instructions. If the <code>name</code> attribute
               is present on an <elcode>xsl:merge-source</elcode> element, then it must not be equal
               to the <code>name</code> attribute of any sibling <elcode>xsl:merge-source</elcode>
               element. If the <code>name</code> attribute is absent, then an <termref def="dt-implementation-dependent"/> name, different from all explicitly specified
               names, is allocated to the merge source.</p>

            <p><error spec="XT" class="SE" type="static" code="3195">
                  <p>If the <code>for-each-item</code> attribute is present then the
                        <code>for-each-source</code>, <code>use-accumulators</code>, and <code>streamable</code> attributes
                     must all be absent. If <phrase diff="chg" at="A">either or both of the
                        <code>use-accumulators</code> or <code>streamable</code> attributes is present </phrase>
                     then the <code>for-each-source</code> attribute must be present. If the
                        <code>for-each-source</code> attribute is present then the
                     <code>for-each-item</code> attribute must be absent. 
                     <phrase diff="add" at="A">[XSLT 3.0 Erratum E40, bugs 30265 and 30378].</phrase></p>
               </error></p>

            <p>The <code>use-accumulators</code> attribute defines the
               set of accumulators that are applicable to the streamed document, as explained in
                  <specref ref="applicability-of-accumulators"/>.</p>

            <p>If neither of
                     <code>for-each-item</code> and <code>for-each-source</code> is
               present, the <elcode>xsl:merge-source</elcode> element defines a single
               merge input sequence. This sequence is the result of evaluating the expression in the
                  <code>select</code> attribute. This is evaluated using the dynamic context of the
               containing <elcode>xsl:merge</elcode> instruction. This sequence will be merged with
               the sequences defined by other <elcode>xsl:merge-source</elcode> elements, if
               present.</p>

            <p>When the <code>for-each-item</code>
               attribute is present, the <elcode>xsl:merge-source</elcode> element defines a
               collection of merge input sequences. The selection of items in these input sequences
               is a two-stage process: the <code>for-each-item</code> attribute of the
                  <elcode>xsl:merge-source</elcode> element is an expression that selects a sequence
               of <emph>anchor items</emph>, and for each anchor item, the <code>select</code>
               attribute is evaluated to select the items that make up one merge input sequence. The
                  <code>for-each-item</code> expression is evaluated with
               the dynamic context of the containing <elcode>xsl:merge</elcode> instruction, while
               the <code>select</code> attribute is evaluated with the <termref def="dt-focus">focus</termref> for the evaluation as follows:</p>

            <ulist>
               <item>
                  <p>The <termref def="dt-context-item">context item</termref> is the anchor
                     item</p>
               </item>
               <item>
                  <p>The <termref def="dt-context-position">context position</termref> is the
                     position of the anchor item within the sequence of anchor items</p>
               </item>
               <item>
                  <p>The <termref def="dt-context-size">context size</termref> is the number of
                     anchor items.</p>
               </item>
            </ulist>

            <p>When the <code>for-each-source</code> attribute is
               present, its value must be an expression that returns a sequence of URIs. 
               The expression is evaluated with the same
               dynamic context as the containing <elcode>xsl:merge</elcode> instruction. The
               expected type of the expression is <code>xs:string*</code>, and the actual result of
               the expression is converted to this type using the <termref def="dt-coercion-rules"/>. Each of these URIs is used to obtain a
               document node. Each <rfc2119>must</rfc2119> be a valid URI reference. If it is an
               absolute URI reference, it is used as is; if it is a relative URI reference, it is
               made absolute by resolving it against the base URI of the
                  <elcode>xsl:merge-source</elcode> element. The process of obtaining a document
               node given a URI is the same as for the <xfunction>doc</xfunction> function, and may trigger the same error conditions.
               However, unlike the <xfunction>doc</xfunction> function, the
                  <elcode>xsl:merge</elcode> instruction offers no guarantee that the resulting
               document will be stable (that is, that multiple calls specifying the same URI will
               return the same document). The resulting document nodes act as the <term>anchor
                  items</term>. These anchor items are then used in the same way as a sequence of
               anchor items selected directly using the <code>for-each-item</code> attribute:
               in particular, the <termref def="dt-focus"/> is
               determined in the same way.</p>

            <note>
               <p>Examples of expressions that return a sequence of URIs are:</p>
               <ulist>
                  <item>
                     <p><code>for-each-source="'inputA.xml', 'inputB.xml'"</code></p>
                  </item>
                  <item>
                     <p><code>for-each-source="(1 to $N) ! ('input' || $N || '.xml')"</code></p>
                  </item>
                  <item>
                     <p><code>for-each-source="uri-collection('input/dir/')</code></p>
                  </item>
               </ulist>
               <p>Relative URIs are resolved relative to the base URI of the
                     <elcode>xsl:merge-source</elcode> element.</p>
            </note>

            <p>The attributes <code>validation</code> and
                  <code>type</code> are used to control schema validation of documents read by
               virtue of their appearance in the result of the <code>for-each-source</code>
               expression. These attributes are mutually exclusive <errorref spec="XT" class="SE" code="1505"/>. 
               <phrase diff="del" at="A">The rules are the same as for an <elcode>xsl:source-document</elcode>
               instruction specifying <code>streamable="yes"</code>. </phrase>
               If the <code>for-each-source</code> attribute is absent, then the
                  <code>validation</code> and <code>type</code> attributes <rfc2119>must</rfc2119>
               both be absent. <phrase diff="add" at="A">The process of validation follows
               the rules defined in <specref ref="validation"/> [XSLT 3.0 Erratum E44, bug 30384].</phrase></p>

            

            <p>If the <code>sort-before-merge</code> attribute is absent or has
               the value <code>no</code>, then each merge input sequence <rfc2119>must</rfc2119> already
               be in the correct order for merging (a dynamic error occurs if it is not). If the
               attribute is present with the value <code>yes</code>, then each input sequence will
               first be sorted to ensure that it is in the correct order. <phrase diff="add" at="A">
                  The sorting is carried out as if by evaluating an <elcode>xsl:perform-sort</elcode> 
                  instruction with <elcode>xsl:sort</elcode> children corresponding one-to-one with 
                  the <elcode>xsl:merge-key</elcode> children of the <elcode>xsl:merge-source</elcode> 
                  element, differing only (a) in the change of element name, 
                  and (b) in the addition of the attribute <code>stable="yes"</code> to the first such element.
                  [XSLT 3.0 Erratum E41, bug 30380].
               </phrase></p>



            <example>
               <head>Merging Several Documents with the Same Structure</head>
               <p>The following <elcode>xsl:merge-source</elcode> element selects two anchor items
                  (the root nodes of two documents), and for each of these it selects an input
                  sequence consisting of selected <code>event</code> elements within the relevant
                  document.</p>

               <eg role="xslt-fragment" xml:space="preserve">
&lt;xsl:merge-source for-each-source="'log-A.xml', 'log-B.xml'"
                  streamable="yes"
                  select="events/event"&gt;
   &lt;xsl:merge-key select="@timestamp" order="ascending"/&gt;
&lt;/xsl:merge-source&gt;</eg>

               <p>This example can be extended to merge any number of input documents with the same
                  structure:</p>
               <eg role="xslt-fragment" xml:space="preserve">
&lt;xsl:merge-source for-each-source="uri-collection('log-collection')"
                  streamable="yes"
                  select="events/event"&gt;
   &lt;xsl:merge-key select="@time" order="ascending"/&gt;
&lt;/xsl:merge-source&gt;</eg>
               <p>In both the above examples the anchor items are document nodes, and the items in
                  the input sequence are elements within the document that is rooted at this node.
                  This is a common usage pattern, but by no means the only way in which the
                  construct can be used.</p>
            </example>

            <p>The number of anchor items selected by an <elcode>xsl:merge-source</elcode> element,
               and therefore the number of input sequences, is variable, but the input sequences
               selected by one <elcode>xsl:merge-source</elcode> element must all use the same
               expressions to select the items in the input sequence and to compute their merge
               keys. If different expressions are needed for different input sequences, then
               multiple <elcode>xsl:merge-source</elcode> elements can be used.</p>

            <example>
               <head>Merging Two Documents with Different Structure</head>
               <p>The following code merges two log files having different internal structure:</p>

               <eg role="xslt-fragment" xml:space="preserve">
&lt;xsl:merge-source for-each-source="'event-log.xml'" 
                  streamable="yes" select="/*/event"&gt;
  &lt;xsl:merge-key select="@timestamp"/&gt;
&lt;/xsl:merge-source&gt;
&lt;xsl:merge-source for-each-source="'error-log.xml'" 
                  streamable="yes" select="/*/error"&gt;
  &lt;xsl:merge-key select="dateTime(@date, @time)"/&gt;
&lt;/xsl:merge-source&gt;</eg>

               <p>Although the merge keys are computed in different ways for the two input
                  sequences, the keys must be compatible across the two sequences: in this case they
                  are both atomic values of type <code>xs:dateTime</code>.</p>
            </example>

            <p>In the common case where there is only one input sequence of a particular kind, the
                  <code>for-each-item</code> attribute of
                  <elcode>xsl:merge-source</elcode> may be omitted; the <code>select</code>
               expression is then evaluated relative to the <termref def="dt-focus">focus</termref>
               of the <elcode>xsl:merge</elcode> instruction itself.</p>
            <example>
               <head>Sorting before Merging</head>
               <p>Where one or more of the inputs to the merging process is not pre-sorted, a sort
                  can be requested using the <code>sort-before-merge</code> attribute. For
                  example:</p>
               <eg role="xslt-fragment" xml:space="preserve">
&lt;xsl:merge-source select="doc('event-log.xml')/*/event"&gt;
  &lt;xsl:merge-key select="@timestamp"/&gt;
&lt;/xsl:merge-source&gt;
&lt;xsl:merge-source select="doc('error-log.xml')//error" 
                  sort-before-merge="yes"&gt;
  &lt;xsl:merge-key select="dateTime(current-date(), @time)"/&gt;
&lt;/xsl:merge-source&gt;
</eg>
            </example>

            <!--<p diff="chg" at="I">An <elcode>xsl:merge-source</elcode> element has an optional
                  <code>name</code> attribute, whose value is an <termref def="dt-expanded-qname"
                  >NCName</termref>. This name, if specified, may be used while evaluating the
                  <elcode>xsl:merge-action</elcode> element to identify from which source a particular item
               was read. If the <code>name</code> attribute is omitted then the system allocates
               a name formed by concatenating the string <code>"source"</code> with the integer
               position of the <elcode>xsl:merge-source</elcode> element among its siblings: thus
               the first is named <code>source1</code>, the second <code>source2</code>, and so on.
               For details of how the names are used, see <specref ref="selective-processing-of-merge-inputs"/></p>-->

            <p>
               <error spec="XT" type="static" class="SE" code="3190">
                  <p>It is a <termref def="dt-static-error">static error</termref> if two sibling
                        <elcode>xsl:merge-source</elcode> elements have the same name.</p>
               </error>
            </p>



         </div2>
         <div2 id="streamable-merging">
            <head>Streamable Merging</head>
            <p>Any input to a merging operation, provided it is selected
               by means of the <elcode>xsl:merge-source</elcode> element with a
                  <code>for-each-source</code> attribute, may be designated as streamable by
               including the attribute <code>streamable="yes"</code> on the
                  <elcode>xsl:merge-source</elcode> element. </p>

            <p>When <code>streamable="yes"</code> is specified on an
                  <elcode>xsl:merge-source</elcode> element, then (whether or not streamed
               processing is actually used, and whether or not the processor supports streaming) the
               expression appearing in the <code>select</code> attribute is implicitly used as the
               argument of a call on the <function>snapshot</function> function, which means that
               merge keys for each selected node are computed with reference to this snapshot, and
               the <function>current-merge-group</function> function, when used within the
                  <elcode>xsl:merge-action</elcode> sequence constructor, delivers snapshots of the
               selected nodes.</p>

            <note>
               <p>There are therefore no constraints on the navigation
                  that may be performed in computing the merge key, or in the course of evaluating
                  the <elcode>xsl:merge-action</elcode> body. An attempt to navigate outside the
                  portion of the source document delivered by the <function>snapshot</function>
                  function will typically not cause an error, but will return empty results.</p>
               <p>There is no
                  rule to prevent the <code>select</code> expression returning atomic values, or grounded nodes from a
                  different source document, or newly constructed nodes, but they are still
                  processed using the <function>snapshot</function> function.</p>
               <p>Because the <function>snapshot</function> copies
                  accumulator values as described in <specref ref="copying-accumulators"/>, the
                  functions <function>accumulator-before</function> and
                     <function>accumulator-after</function> may be used to gain access to
                  information that is not directly available in the nodes that are present within
                  each snapshot (for example, information in a header section of the merge input
                  document).</p>
            </note>

            <p>An <elcode>xsl:merge-source</elcode> element is <termref def="dt-guaranteed-streamable"/> if it satisfies all the following conditions:</p>


            <olist>
               <item>
                  <p>The <elcode>xsl:merge-source</elcode> element has the 
                     attribute value <code>streamable="yes"</code>;</p>
               </item>
               <item>
                  <p>The <code>for-each-source</code> attribute is
                     present on that <elcode>xsl:merge-source</elcode> element;</p>
               </item>
               <item>
                  <p>The expression in the <code>select</code> attribute of that
                        <elcode>xsl:merge-source</elcode> element, assessed with a
                  <termref def="dt-context-posture"/> of <termref def="dt-striding"/>
                  and a <termref def="dt-context-item-type"/> of <var>U{document-node()}</var>,
                  has <termref def="dt-striding"/> or <termref def="dt-grounded"/> <termref def="dt-posture"/>
                     and <termref def="dt-motionless"/> or <termref def="dt-consuming"/> <termref def="dt-sweep"/>;
                  </p>
               </item>
               <item>
                  <p>The <code>sort-before-merge</code> attribute of that
                        <elcode>xsl:merge-source</elcode> element is either absent or takes its
                     default value of <code>no</code>.</p>
               </item>
               
               
            </olist>

            <p>Specifying <code>streamable="yes"</code> on an
               <elcode>xsl:merge-source</elcode> element declares an intent that the
                  <elcode>xsl:merge</elcode> instruction should be streamable with respect to that particular source, either because it is <termref def="dt-guaranteed-streamable"/>, or because it takes advantage of
                  streamability extensions offered by a particular processor. The
               consequences of declaring the instruction to be streamable when it is not in fact
               guaranteed streamable depend on the conformance level of the processor, and are
               explained in <specref ref="streamability-guarantees"/>.</p>

            <example>
               <head>Streamed Merging</head>
               <p>The following example merges two log files, processing each of them using
                  streaming.</p>
               <eg role="xslt-fragment" xml:space="preserve">
&lt;events&gt;
   &lt;xsl:merge&gt;
      &lt;xsl:merge-source for-each-source="'log-file-1.xml'" 
                        select="/events/event" 
                        streamable="yes"&gt;
         &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-source for-each-source="'log-files-2.xml'" 
                        select="/log/day/record" 
                        streamable="yes"&gt;
         &lt;xsl:merge-key select="dateTime(../@date, time)"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
         &lt;events time="{current-merge-key()}"&gt;
            &lt;xsl:copy-of select="current-merge-group()"/&gt;
         &lt;/events&gt;   
      &lt;/xsl:merge-action&gt;
   &lt;/xsl:merge&gt;
&lt;/events&gt;</eg>
            </example>
            <p>Note that the merge key for the second merge source includes data from a child
               element of the selected element and also from an attribute of the parent element.
               This works because the merge key is evaluated on the result of implicitly applying
               the <function>snapshot</function> function.</p>
            
            <example>
               <head>Merging XML and non-XML Data</head>
               <p>The following example merges two log files, one in text format and one in XML format.</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;events&gt;
   &lt;xsl:merge&gt;
      &lt;xsl:merge-source name="fax" 
                        select="unparsed-text-lines('fax-log.txt')"&gt;
         &lt;xsl:merge-key select="xs:dateTime(substring-before(., ' '))"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-source name="mail"
                        for-each-source="'mail-log.xml'" 
                        select="/log/day/message" 
                        streamable="yes"&gt;
         &lt;xsl:merge-key select="dateTime(../@date, @time)"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
         &lt;messages at="{current-merge-key()}"&gt;
            &lt;xsl:where-populated&gt;
               &lt;fax&gt;
                  &lt;xsl:for-each select="current-merge-group('fax')"&gt;
                     &lt;message xsl:expand-text="true"&gt;{
                        substring-after(., ' ')
                     }&lt;/message&gt;
                  &lt;/xsl:for-each&gt;   
               &lt;/fax&gt;
               &lt;mail&gt;
                  &lt;xsl:sequence select="current-merge-group('mail')/*"/&gt;
               &lt;/mail&gt;
            &lt;/xsl:where-populated&gt;   
         &lt;/messages&gt;   
      &lt;/xsl:merge-action&gt;
   &lt;/xsl:merge&gt;
&lt;/events&gt;</eg>
            </example>
         </div2>
         <div2 id="merge-keys">
            <head>Defining the Merge Keys</head>

            <p>The keys on which the input sequences are sorted are referred to as merge keys. If
               the attribute <code>sort-before-merge</code> has the value <code>yes</code>, the
               input sequences will be sorted into the correct sequence before the merge operation
               takes place (alternatively, the processor <rfc2119>may</rfc2119> use an algorithm
               that has the same effect as sorting followed by merging). If the attribute is absent
               or has the value <code>no</code>, then the input sequences <rfc2119>must</rfc2119>
               already be in the correct order.</p>

            <p>The merge key for each type of input sequence (that is, for each
                  <elcode>xsl:merge-source</elcode> element) is defined by a sequence of
                  <elcode>xsl:merge-key</elcode> element children of the
                  <elcode>xsl:merge-source</elcode> element. Each <elcode>xsl:merge-key</elcode>
               element defines one merge key component. The syntax and semantics of an
                  <elcode>xsl:merge-key</elcode> element are closely based on the rules for the
                  <elcode>xsl:sort</elcode> element (<phrase diff="chg" at="A">with minor exceptions
                  noted below; the only difference in syntax is</phrase> the absence of the
                  <code>stable</code> attribute); the <phrase diff="add" at="A">main</phrase> difference is that
                  <elcode>xsl:merge-key</elcode> elements do not cause a sort to take place, they
               merely declare the existing sort order of the input sequence. 
               <phrase diff="add" at="A">[See XSLT 3.0 Erratum E42, bugs 30130 and 30382].</phrase></p>

            <?element xsl:merge-key?>

            <p>The <code>select</code> attribute and the contained <termref def="dt-sequence-constructor">sequence constructor</termref> are mutually
               exclusive:</p>

            <p>
               <error spec="XT" type="static" class="SE" code="3200">
                  <p>It is a <termref def="dt-static-error">static error</termref> if an
                        <elcode>xsl:merge-key</elcode> element with a <code>select</code> attribute
                     has non-empty content.</p>
               </error>
            </p>
            
            <p diff="chg" at="A">The value of <var>N</var>th item in the merge key of an item
               <var>J</var> in a <termref def="dt-merge-input-sequence">merge input
                  sequence</termref>
               <var>S</var> is computed as follows, where <var>K</var> is the <var>N</var>th
               <elcode>xsl:merge-key</elcode> element of the relevant <elcode>xsl:merge-source</elcode>:</p>
            
            <olist diff="chg" at="A">
               <item><p>If <var>K</var> has a <code>select</code> attribute, then the result 
                  of evaluating and atomizing that <code>select</code> expression;</p></item>
               <item><p>If <var>K</var> contains a non-empty sequence constructor, then the 
                  result of evaluating and atomizing that sequence constructor;</p></item>
               <item><p>Otherwise, the result of atomizing the context item.</p></item>
            </olist>
            
            <p diff="chg" at="A">In each case the evaluation uses a <termref def="dt-singleton-focus"/> 
               based on <var>J</var>, or, if <code>streamable="yes"</code> is specified on the
               <elcode>xsl:merge-source</elcode> element, a <termref def="dt-singleton-focus"/> based on 
               a snapshot of <var>J</var> (see <specref ref="streamable-merging"/>). 
               [XSLT 3.0 Erratum E42, bugs 30130 and 30382].</p>
  
            
            <note>
               <p>This means that <code>position()</code> and <code>last()</code> return 1 (one).
                  This differs from the way <elcode>xsl:sort</elcode> keys are evaluated, where
                  <code>position()</code> is the position in the unsorted sequence, and
                  <code>last()</code> is the size of the unsorted sequence.</p>
            </note>

            <p>The effect of the <elcode>xsl:merge-key</elcode> elements is defined in terms of the
               rules for an equivalent sequence of <elcode>xsl:sort</elcode> elements: if the rules
               for sorting (see <specref ref="sorting-process"/>) with <code>stable="yes"</code>
               would place an item <var>A</var> before an item <var>B</var> in the <termref def="dt-sorted-sequence">sorted sequence</termref> produced by the sorting
               process, then <var>A</var> must precede <var>B</var> in the input sequence to the
               merging process.</p>

            <p>The merge keys of the various input sequences to a merge operation must be compatible
               with each other, since the merge operation will decide the ordering of the result
               sequence by comparing merge key values across input sequences. This means that across
               all the <elcode>xsl:merge-source</elcode> children of an <elcode>xsl:merge</elcode>
               instruction:</p>

            <ulist>
               <item>
                  <p>Each <elcode>xsl:merge-source</elcode> element <rfc2119>must</rfc2119> have the
                     same number of <elcode>xsl:merge-key</elcode> child elements; let this number
                     be <var>N</var>.</p>
               </item>
               <item diff="chg" at="A">
                  <p>For each integer <var>J</var> in 1..<var>N</var>, consider the set <var>S</var> of
                        <elcode>xsl:merge-key</elcode> elements that are in position <var>J</var>
                     among the <elcode>xsl:merge-key</elcode> children of their parent
                        <elcode>xsl:merge-source</elcode> element. 
                     For each attribute <var>A</var> in the set <code>lang</code>, <code>order</code>, <code>collation</code>,
                     <code>case-order</code>, and <code>data-type</code> it must be the case that for
                     any two elements <var>s1</var> and <var>s2</var> in <var>S</var>, the
                     <termref def="dt-effective-value"/> of attribute <var>A</var> on <var>s1</var>
                     is the same as the <termref def="dt-effective-value"/> of attribute <var>A</var> on <var>s2</var>,
                     where two attributes are said to have the same effective value if either (a) both attributes
                     are absent, or (b) both attributes are present and the results of evaluating them 
                     (they are attribute value templates) are codepoint-equal. Furthermore, in the case
                     of the <code>collation</code> attribute, the absolute collation URI must be the same
                     after resolving against the base URI. [XSLT 3.0 Erratum E29, bug 30267].</p>
                     
               </item>
            </ulist>

            <p>If any of the attributes <code>lang</code>, <code>order</code>,
                  <code>collation</code>, <code>case-order</code>, or <code>data-type</code> are
                  <termref def="dt-attribute-value-template">attribute value templates</termref>,
               then their <termref def="dt-effective-value">effective values</termref> are evaluated
               using the <termref def="dt-focus">focus</termref> of the containing
                  <elcode>xsl:merge</elcode> instruction.</p>



            <p>
               <error spec="XT" type="static" class="SE" code="2200">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the number of
                        <elcode>xsl:merge-key</elcode> children of a
                        <elcode>xsl:merge-source</elcode> element is not equal to the number of
                        <elcode>xsl:merge-key</elcode> children of another
                        <elcode>xsl:merge-source</elcode> child of the same
                        <elcode>xsl:merge</elcode> instruction.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="2210">
                  <p>It is a <termref def="dt-dynamic-error">dynamic
                        error</termref> if there are two <elcode>xsl:merge-key</elcode> elements
                     that occupy corresponding positions among the <elcode>xsl:merge-key</elcode>
                     children of two different <elcode>xsl:merge-source</elcode> elements and that
                     have differing <termref def="dt-effective-value">effective values</termref> for
                     any of the attributes <code>lang</code>, <code>order</code>,
                        <code>collation</code>, <code>case-order</code>, or <code>data-type</code>.
                     Values are considered to differ if the attribute is present on one element and
                     not on the other, or if it is present on both elements with <termref def="dt-effective-value">effective values</termref> that are not equal to
                     each other. In the case of the <code>collation</code> attribute, the values are
                     compared as absolute URIs after resolving against the base URI. The error
                        <rfc2119>may</rfc2119> be reported statically if it is detected
                     statically.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="2220">
                  <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if any input
                     sequence to an <elcode>xsl:merge</elcode> instruction contains two items that
                     are not correctly sorted according to the merge key values defined on the
                        <elcode>xsl:merge-key</elcode> children of the corresponding
                        <elcode>xsl:merge-source</elcode> element, when compared using the collation
                     rules defined by the attributes of the corresponding
                        <elcode>xsl:merge-key</elcode> children of the <elcode>xsl:merge</elcode>
                     instruction, unless the attribute <code>sort-before-merge</code> is present
                     with the value <code>yes</code>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="type" class="TE" code="2230">
                  <p>It is a <termref def="dt-type-error">type error</termref> if some item selected
                     by a particular merge key in one input sequence is not comparable using the
                     XPath <code>le</code> operator with some item selected by the corresponding
                     sort key in another input sequence.</p>
               </error>
            </p>

         </div2>
         <div2 id="current-merge-group-and-key">
            <head>The Current Merge Group and Key</head>
            <p>During processing of an <elcode>xsl:merge</elcode> instruction, two additional values
               are available within the dynamic context:</p>
            <ulist>
               <item>
                  <p><termdef id="dt-current-merge-group" term="current merge group">The
                           <term>current merge group</term> is a map. During
                        evaluation of an <elcode>xsl:merge</elcode> instruction, as each group of
                        items with equal <termref def="dt-composite-merge-key-value">composite merge
                           key values</termref> is processed, the current merge group is set to a
                        map whose keys are the names of the various merge sources, and whose
                        associated values are the items from each merge source having the relevant
                        composite merge key value.</termdef></p>
               </item>
               <item>
                  <p><termdef id="dt-current-merge-key" term="current merge key">The <term>current
                           merge key</term> is a sequence of atomic values. During evaluation of an
                           <elcode>xsl:merge</elcode> instruction, as each group of items with equal
                           <termref def="dt-composite-merge-key-value">composite merge key
                           values</termref> is processed, the current merge key is set to the
                        composite merge key value that these items have in common.</termdef></p>
               </item>
            </ulist>

            
            <p>These values are made available through the functions
                  <function>current-merge-group</function> and
                  <function>current-merge-key</function>.</p>
            
            <p>The <termref def="dt-current-merge-group"/> and <termref def="dt-current-merge-key"/> are available within the sequence
            constructor contained by an <elcode>xsl:merge-action</elcode> element. The values are initially
            <termref def="dt-absent"/> during the evaluation of global variables and stylesheet parameters,
            during the evaluation of the <code>use</code> attribute or contained sequence constructor of
            <elcode>xsl:key</elcode>, and during the evaluation of the <code>initial-value</code> attribute of
            <elcode>xsl:accumulator</elcode> and the <code>select</code> attribute of contained sequence constructor of
            <elcode>xsl:accumulator-rule</elcode>. All <termref def="dt-invocation-construct">invocation constructs</termref>
               set the <termref def="dt-current-merge-group"/> and <termref def="dt-current-merge-key"/> to <termref def="dt-absent"/>. </p>
            
            <note><p>Taken together, these rules mean that any invocation of
            <function>current-merge-group</function> or <function>current-merge-key</function> that is not lexically scoped by an
            <elcode>xsl:merge-action</elcode> element will raise a dynamic error.</p></note>
            
            <p>When an inner <elcode>xsl:merge</elcode> instruction is lexically nested within the
            <elcode>xsl:merge-action</elcode> element of an outer <elcode>xsl:merge</elcode> instruction, any use of
            <function>current-merge-group</function> or <function>current-merge-key</function> that appears within the
            <elcode>xsl:merge-action</elcode> of the inner <elcode>xsl:merge</elcode> instruction is a reference to the
               <termref def="dt-current-merge-group"/> or <termref def="dt-current-merge-key"/> of the inner
               <elcode>xsl:merge</elcode> instruction, while any such
            reference that appears within the outer <elcode>xsl:merge-action</elcode> element, but not
               within the inner <elcode>xsl:merge-action</elcode>, is a reference to the <termref def="dt-current-merge-group"/> or <termref def="dt-current-merge-key"/>
             of the outer <elcode>xsl:merge</elcode> instruction. This means, for example, that a
            reference to the current merge group of the outer <elcode>xsl:merge</elcode> can appear in the
            <code>select</code> attribute of an <elcode>xsl:merge-source</elcode> child of the inner <elcode>xsl:merge</elcode>.</p>
            
            <p>On completion of the evaluation of the <elcode>xsl:merge-action</elcode> sequence constructor, the current merge group
               and current merge key revert to their previous values.</p>
            

            

            <div3 id="func-current-merge-group">
               <head><?function fn:current-merge-group?></head>

            </div3>
            <div3 id="func-current-merge-key">
               <head><?function fn:current-merge-key?></head>

            </div3>
         </div2>
         <div2 id="merge-action">
            <head>The <elcode>xsl:merge-action</elcode> Element</head>
            <p>The <elcode>xsl:merge-action</elcode> child of an <elcode>xsl:merge</elcode>
               instruction defines the processing to be applied for each distinct <termref def="dt-composite-merge-key-value"/> found in the input sequences to the
                  <elcode>xsl:merge</elcode> instruction.</p>
            <?element xsl:merge-action?>

            <p>The merge key values for each item in an input sequence are calculated based on the
               corresponding <elcode>xsl:merge-key</elcode> elements, in the same way as <termref def="dt-sort-key-value">sort key values</termref> are calculated using a sequence
               of <elcode>xsl:sort</elcode> elements (see <specref ref="sorting-process"/>). If
               several items from the same or from different input sequences have the same values
               for all their merge keys (comparing pairwise), then they are considered to form a
               group. The sequence constructor contained in the <elcode>xsl:merge-action</elcode>
               element is evaluated once for each such group of items, and the result of the
                  <elcode>xsl:merge</elcode> instruction is the concatenation of the results
               obtained by processing each group in turn.</p>

            <p>The groups are processed one by one, based on the values of
                  the merge keys for the group. If group <var>G</var> has a set of merge
               key values <var>M</var>, while group <var>H</var> has a set of merge key values
                  <var>N</var>, then in the result of the <elcode>xsl:merge</elcode> instruction,
               the result of processing group <var>G</var> will precede the result of processing
                  <var>H</var> if and only if <var>M</var> precedes <var>N</var> in the sort order
               defined by the <code>lang</code>, <code>order</code>, <code>collation</code>,
                  <code>case-order</code>, and <code>data-type</code> attributes of the merge key
               definitions.</p>

            <p><phrase diff="chg" at="A">Comparison of merge key values follows the rules for 
               <elcode>xsl:sort</elcode> given in <specref ref="comparing-sort-keys"/>. 
               This means that except for special cases such as empty sequences and NaN</phrase>, 
               two sets of merge key values are distinct if any corresponding items in
               the two sets of values do not compare equal under the rules for the XPath
                  <code>eq</code> operator, under the collating rules for the corresponding merge
               key definition. In rare cases, when considering more than two sets of merge key
               values, ambiguities may arise because of the non-transitivity of the <code>eq</code>
               operator when applied across different numeric types. In this situation, the
               partitioning of items into sets having distinct key values is handled in the same way
               as for <elcode>xsl:for-each-group</elcode> (see <specref ref="non-transitivity"/>),
               and is to some extent <termref def="dt-implementation-dependent">implementation-dependent</termref>. 
            <phrase diff="add" at="A">[XSLT 3.0 Erratum E39, bug 30377].</phrase>
            </p>

            

            

            

            



            

            <p>The <termref def="dt-focus">focus</termref> for evaluation of the sequence
               constructor contained in the <elcode>xsl:merge-action</elcode> element is as
               follows:</p>

            <ulist>
               <item>
                  <p>The <termref def="dt-context-item">context item</termref> is the first item in
                     the group being processed, that is
                           <code>current-merge-group()[1]</code></p>
               </item>
               <item>
                  <p>The <termref def="dt-context-position">context position</termref> is the
                     position of the current group within the sequence of groups (so the first
                     evaluation of <elcode>xsl:merge-action</elcode> has <code>position()=1</code>,
                     the second has <code>position()=2</code>, and so on).</p>
               </item>
               <item>
                  <p>The <termref def="dt-context-size">context size</termref> is as follows:</p>
                  
                  <ulist>
                     <item><p>If any of the <elcode>xsl:merge-source</elcode> elements within the <elcode>xsl:merge</elcode> instruction specifies 
                        <code>streamable="yes"</code> (explicitly or implicitly), then absent.</p>
                        <note><p>This means that within the <elcode>xsl:merge-action</elcode> of a streamable <elcode>xsl:merge</elcode>, 
                           calling <code>last()</code> throws error <xerrorref spec="XP40" class="DY" code="0002"/>.</p></note>
                     </item>
                     <item><p>Otherwise, the number of groups, that is, the number of distinct sets of merge key values.
                        </p></item>
                  </ulist>

               </item>
            </ulist>





            <example>
               <head>Selective Processing of Merge Inputs</head>
               <p>Consider a situation where there are two merge sources, named <code>"master"</code> and
                  <code>"update"</code>; the master source identifies a single merge input file (the master
                  file), while the update source identifies a set of <var>N</var> update files,
                  perhaps one for each day of the week. The required logic is that if a merge key is
                  present only in the master file, then the corresponding item should be copied to
                  the output; if it is present in a single update file then that item replaces the
                  corresponding item from the master file; if it is present in several update files,
                  then an error is raised. This can be achieved as follows:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:merge&gt;
  &lt;xsl:merge-source name="master" 
                    for-each-source="'master.xml'"
                    streamable="yes"
                    select="/events/event"&gt;
      &lt;xsl:merge-key select="@key"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source name="updates" 
                    for-each-source="uri-collection('updates')"
                    streamable="yes"
                    select="/events/event-change"&gt;
      &lt;xsl:merge-key select="@affected-key"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="empty(current-merge-group('master'))"&gt;
        &lt;xsl:message&gt;
           Error: update is present with no matching master record!
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="empty(current-merge-group('updates'))"&gt;
        &lt;xsl:copy-of select="current-merge-group('master')"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="count(current-merge-group('updates')) = 1"&gt;
        &lt;xsl:copy-of select="current-merge-group('updates')"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:message&gt;
           Conflict: multiple updates for the same master record!
        &lt;/xsl:message&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
            </eg>
               <p>Some words of explanation:</p>
               <ulist>

                  <item>
                     <p>Error messages are produced if there is an update element
                        whose key does not correspond to any element in the master source, or if
                        there is more than one update element corresponding to the same master
                        element.</p>
                  </item>
                  <item>
                     <p>In the absence of errors, if there is a single update
                        element then it is copied to the output; if there is none, then the master
                        element is copied.</p>
                  </item>
               </ulist>
            </example>
         </div2>

         <div2 id="merge-examples">
            <head>Examples of xsl:merge</head>
            <p>Previous sections introduced examples designed to illustrate some specific features
               of the <elcode>xsl:merge</elcode> instruction. This section provides some further
               examples to illustrate different ways in which the instruction can be used.</p>


            <example>
               <head>Applying Transactions to a Master File</head>
               <p>This example applies transactions from a transaction file to a master file.
                  Records in the master file for which there is no corresponding transaction are
                  copied unchanged. The transaction file contains instructions to delete, replace,
                  or insert records identified by an ID value. The master file is known to be sorted
                  on the ID value; the transaction file is unsorted.</p>
               <p>Master file document structure:</p>
               <eg xml:space="preserve" role="xml">&lt;data&gt;
  &lt;record ID="A0001"&gt;...&lt;/record&gt;
  &lt;record ID="A0002"&gt;...&lt;/record&gt;
  &lt;record ID="A0003"&gt;...&lt;/record&gt;
&lt;/data&gt;</eg>
               <p>Transaction file document structure:</p>
               <eg xml:space="preserve" role="xml">&lt;transactions&gt;
  &lt;update record="A0004" action="insert"&gt;...&lt;/update&gt;
  &lt;update record="A0002" action="delete"/&gt;
  &lt;update record="A0003" action="replace"&gt;...&lt;/update&gt;
&lt;/transactions&gt;</eg>
               <p>Solution:</p>
               <eg xml:space="preserve" role="xslt-instruction">
 &lt;xsl:merge&gt;
  &lt;xsl:merge-source name="master" 
                    select="doc('master.xml')/data/record"&gt;
      &lt;xsl:merge-key select="@ID"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source name="updates"
                    sort-before-merge="yes"
                    select="doc('transactions.xml')/transactions/update"&gt;     
      &lt;xsl:merge-key select="@record"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="empty(current-merge-group('updates'))"&gt;
        &lt;xsl:copy-of select="current-merge-group('master')"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="current-merge-group('updates')/@action=('insert', 'replace')"&gt;
        &lt;record ID="{current-merge-key()}"&gt;
          &lt;xsl:copy-of select="current-merge-group('updates')/*"/&gt;
        &lt;/record&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="current-merge-group('updates')/@action='delete'"/&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:merge-action&gt;
  &lt;/xsl:merge&gt;</eg>




            </example>
            <example>
               <head>Merging Two Sequences of Numbers</head>
               <p>The <elcode>xsl:merge</elcode> instruction can be used to determine the union,
                  intersection, or difference of two sequences of numbers (or other atomic values).
                  This code gives the union:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:merge&gt;
  &lt;xsl:merge-source select="1 to 30"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source select="20 to 40"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:sequence select="current-merge-key()"/&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
               </eg>
               <p>While this gives the intersection:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:merge&gt;
  &lt;xsl:merge-source select="1 to 30"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source select="20 to 40"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:if test="count(current-merge-group()) eq 2"&gt;
      &lt;xsl:sequence select="current-merge-key()"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;
               </eg>
            </example>
         </div2>
      </div1>
      <div1 id="splitting">
         <head>Splitting</head>

         <p>Sometimes it is convenient to be able to compute multiple results during a single scan
            of the input data. For example, a transformation may wish to rename selected elements,
            and also to output a count of how many elements have been renamed. Traditionally in a
            functional language this means computing two separate functions of the input sequence,
            which (in the absence of sophisticated optimization) will result in the input being
            scanned twice. This is inconsistent with streaming, where the input is only available to
            be scanned once, and it can also lead to poor performance in non-streaming
            applications.</p>

         <p>To meet this requirement, XSLT 3.0 introduces the instruction <elcode>xsl:fork</elcode>.
            The content of this instruction is a restricted form
               of
            <termref def="dt-sequence-constructor">sequence constructor</termref>, and in a formal
            sense the effect of the instruction is simply to return the result of evaluating the
            sequence constructor. However, the presence of the instruction affects the analysis of
            streamability (see <specref ref="streamability"/>). In particular, when
               <elcode>xsl:fork</elcode> is used in a context where streaming is required, each
            independent instruction within the sequence constructor must be streamable, but the
            analysis assumes that these instructions can all be evaluated during a single pass of
            the streamed input document.</p>

         <note>
            <p>The semantics of the instruction require a number of result sequences to be computed
               during a single pass of the input. A processor may interpret this as a request to use
               multiple threads. However, implementations using a single thread are feasible, and
               this instruction is not intended primarily as a means for stylesheet authors to
               express their intentions with regard to multi-threaded execution.</p>
         </note>

         <note>
            <p>Because multiple results are computed during a single pass of the input, and then
               concatenated into a single sequence, this instruction will generally involve some
               buffering of results. The amount of memory used should not exceed that needed to hold
               the results of the instruction. However, within this principle, implementations may
               adopt a variety of strategies for evaluation; for example, there may be cases where
               buffering of the input is more efficient than buffering of output.</p>
            <p>Generally, stylesheet authors indicate that buffering of input is the preferred
               strategy by using the <function>copy-of</function> or <function>snapshot</function>
               functions, and indicate that buffering of output is preferred by using
                  <elcode>xsl:fork</elcode>. However, conformant processors are not constrained in
               their choice of evaluation strategies.</p>
         </note>


         

         <p>The content model of the <elcode>xsl:fork</elcode>
            instruction (given that an XSLT 3.0 processor ignores <elcode>xsl:fallback</elcode>)
            takes two possible forms:</p>

         <olist>
            <item>
               <p>A sequence of <elcode>xsl:sequence</elcode> instructions</p>
            </item>
            <item>
               <p>A single <elcode>xsl:for-each-group</elcode> instruction. This will normally use
                  the <code>group-by</code> attribute, because in all other cases the containing
                     <elcode>xsl:fork</elcode> instruction has no useful effect.</p>
            </item>
         </olist>

         <p>The first form is appropriate when splitting a single input
            stream into a fixed number of output streams, known statically: for example, one output
            stream for credit transactions, a second for debit transactions. The second form is
            appropriate when the number of output streams depends on the data: for example, one
            output stream for each distinct city name found in the input data.</p>

         <p>The following section describes the <elcode>xsl:fork</elcode> instruction more
            formally.</p>


         <div2 id="fork-instruction">
            <head>The <code>xsl:fork</code> Instruction</head>
            <?element xsl:fork?>


            <note>
               <p>The content model can be described as follows: there is either a single
                     <elcode>xsl:for-each-group</elcode> instruction, or a sequence of zero or more
                     <elcode>xsl:sequence</elcode> instructions; in addition,
                     <elcode>xsl:fallback</elcode> instructions may be added anywhere.</p>
            </note>

            <p>The result of the <elcode>xsl:fork</elcode> instruction is the sequence formed by
               concatenating the results of evaluating each of its contained  instructions, in order.
               That is, the result can be determined by treating the content as a <termref def="dt-sequence-constructor">sequence constructor</termref> and evaluating it as
               such.</p>

            <note>
               <p>Any <elcode>xsl:fallback</elcode> children will be ignored by an XSLT 3.0
                  processor.</p>
            </note>


            <p>By using the <elcode>xsl:fork</elcode> instruction, the
               stylesheet author is suggesting to the <termref def="dt-processor">processor</termref> that buffering of output is acceptable even though this might
               use unbounded memory and thus violate the normal expectations of streamable
               processing</p>

            <p>The presence of an <elcode>xsl:fork</elcode> instruction affects the analysis of
               streamability, as described in <specref ref="streamability"/>.</p>



         </div2>


         <div2 id="splitting-examples">
            <head>Examples of Splitting with Streamed Data</head>
            <p>This section gives examples of how splitting using <elcode>xsl:fork</elcode> can be
               used to enable streaming of input documents in cases where several results need to be
               computed during a single pass over the input data.</p>



            <example>
               <head>Splitting a Transaction File into Credits and Debits</head>
               <p>Consider a transaction file that contains a sequence of debits and credits:</p>
               <eg role="xml" xml:space="preserve">&lt;transactions&gt;
  &lt;transaction value="5.60"/&gt;
  &lt;transaction value="11.20"/&gt;
  &lt;transaction value="-3.40"/&gt;
  &lt;transaction value="8.90"/&gt;
  &lt;transaction value="-1.99"/&gt;
&lt;/transactions&gt;</eg>
               <p>where the requirement is to split this into two separate files containing credits
                  and debits respectively.</p>
               <p>This can be achieved in <termref def="dt-guaranteed-streamable"/> code as
                  follows:</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:result-document href="credits.xml"&gt;
        &lt;credits&gt;
          &lt;xsl:for-each select="transactions/transaction[@value &amp;gt;= 0]"&gt;
            &lt;xsl:copy-of select="."/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/credits&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:sequence&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:result-document href="debits.xml"&gt;
        &lt;debits&gt;
          &lt;xsl:for-each select="transactions/transaction[@value &amp;lt; 0]"&gt;
            &lt;xsl:copy-of select="."/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/debits&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:sequence&gt;  
  &lt;/xsl:fork&gt;
&lt;/xsl:source-document&gt;
               </eg>
               <p>In the absence of the <elcode>xsl:fork</elcode> instruction, this would not be
                  streamable, because the sequence constructor includes two <termref def="dt-consuming"/> instructions. With the addition of the
                     <elcode>xsl:fork</elcode> instruction, however, each
                     <elcode>xsl:result-document</elcode> instruction is allowed to make a downwards
                  selection. </p>
               <p>One possible implementation model for this is as follows: a single thread reads
                  the source document, and sends parsing events such as start-element and
                  end-element to two other threads, each of which is writing one of the two result
                  documents. Each of these implements the downwards-selecting path expression using
                  a process that waits until the next <code>transaction</code> start-element event
                  is received; when this event is received, the process examines the
                     <code>@value</code> attribute to determine whether or not this transaction is
                  to be copied; if it is, then all events until the matching
                     <code>transaction</code> end-element event are copied to the serializer for the
                  result document; otherwise, these events are discarded.</p>
            </example>

            <example>
               <head>Splitting a Transaction File by Customer Account</head>
               <p>Consider a transaction file that contains a sequence of debits and credits:</p>
               <eg role="xml" xml:space="preserve">&lt;transactions&gt;
  &lt;transaction value="5.60" account="01826370"/&gt;
  &lt;transaction value="11.20" account="92741838"/&gt;
  &lt;transaction value="-3.40" account="01826370"/&gt;
  &lt;transaction value="8.90" account="92741838"/&gt;
  &lt;transaction value="-1.99" account="43861562"/&gt;
&lt;/transactions&gt;</eg>
               <p>where the requirement is to split this into a number of separate files, one for
                  each account number found in the input.</p>
               <p>This can be achieved in <termref def="dt-guaranteed-streamable"/> code as
                  follows:</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:for-each-group select="transactions/transaction" group-by="@account"&gt;
      &lt;xsl:result-document href="account{current-grouping-key()}.xml"&gt;
        &lt;transactions account="{current-grouping-key()}"&gt;
          &lt;xsl:copy-of select="current-group()"/&gt;
        &lt;/transactions&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:for-each-group&gt;
  &lt;/xsl:fork&gt;
&lt;/xsl:source-document&gt;
               </eg>
               <p>In the absence of the <elcode>xsl:fork</elcode> instruction, this would not be
                  streamable, because in the general case the output of
                     <elcode>xsl:for-each-group</elcode> with a <code>group-by</code> attribute
                  needs to be buffered. (The streamability rules do not recognize an
                     <elcode>xsl:for-each-group</elcode> whose body comprises an
                     <elcode>xsl:result-document</elcode> instruction as a special case.) With the
                  addition of the <elcode>xsl:fork</elcode> instruction, however, the code becomes
                  guaranteed streamable. </p>
               <p>One possible implementation model for this is as follows: the processor opens a
                  new serializer each time a new account number is encountered in the input, and
                  writes the <code>&lt;transactions&gt;</code> start tag to the serializer. When a
                     <code>transaction</code> element is encountered in the input, it is copied to
                  the relevant serializer, according to the value of the <code>account</code>
                  attribute. At the end of the input, a <code>&lt;transactions&gt;</code> end tag is
                  written to each of the serializers, and each output file is closed.</p>
               <p>In the more general case, where the body of the
                     <elcode>xsl:for-each-group</elcode> instruction contributes output to the
                  principal result document, the output generated by processing each group needs to
                  be buffered in memory. The requirement to use <elcode>xsl:fork</elcode> exists so
                  that this use of (potentially unbounded) memory has to be a conscious decision by
                  the stylesheet author.</p>
            </example>



            <example>
               <head>Arithmetic using Multiple Child Elements as Operands</head>
               <p>The rules for streamability do not allow two instructions in a sequence
                  constructor to both read child or descendant elements of the context node, which
                  makes it tricky to perform a calculation in which multiple child elements act as
                  operands. This restriction can be avoided by using <elcode>xsl:fork</elcode>, as
                  shown below, where each of the two branches of the <elcode>xsl:fork</elcode>
                  instruction selects children of the context node.</p>
               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:template match="order" mode="a-streamable-mode"&gt;                  
  &lt;xsl:variable name="price-and-discount" as="xs:decimal+"&gt;
    &lt;xsl:fork&gt;
      &lt;xsl:sequence select="xs:decimal(price)"/&gt;
      &lt;xsl:sequence select="xs:decimal(discount)"/&gt;
    &lt;/xsl:fork&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:value-of select="$price-and-discount[1] - $price-and-discount[2]"/&gt;
  &lt;/xsl:template&gt;</eg>
               <p>A possible implementation strategy here is for events from the XML parser to be
                  sent to two separate agents (perhaps but not necessarily running in different
                  threads), one of which computes <code>xs:decimal(price)</code> and the other
                     <code>xs:decimal(discount)</code>; on completion the results computed by the
                  two agents are appended to the sequence that forms the value of the variable.</p>
               <p>With this strategy, the processor would require sufficient memory to hold the
                  results of evaluating each branch of the fork. If these results (unlike this
                  example) are large, this could defeat the purpose of streaming by requiring large
                  amounts of memory; nevertheless, this code is treated as streamable.</p>

               <note>
                  <p>An alternative solution to this requirement is to use map constructors: see
                        <specref ref="map-constructors"/>.</p>
               </note>
            </example>



            <example>
               <head>Deleting Elements, and Counting Deletions</head>
               <p>In this example the input is a narrative document containing <code>note</code>
                  elements at any level of nesting. The requirement is to output a copy of the input
                  document in which (a) the <code>note</code> elements have been removed, and (b) a
                     <code>footnote</code> is added at the end indicating how many <code>note</code>
                  elements have been deleted.</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:mode on-no-match="shallow-copy" streamable="yes"/&gt;

&lt;xsl:template match="note"/&gt;

&lt;xsl:template match="/*"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:sequence&gt;
    &lt;xsl:sequence&gt;
      &lt;footnote&gt;
        &lt;p&gt;Removed &lt;xsl:value-of select="count(.//note)"/&gt; 
                 note elements.&lt;/p&gt;
      &lt;/footnote&gt;
    &lt;/xsl:sequence&gt;  
  &lt;/xsl:fork&gt;
&lt;/xsl:template&gt;
               </eg>
               <p>The <elcode>xsl:fork</elcode> instruction contains two independent branches. These
                  can therefore be evaluated in the same pass over the input data. The first branch
                  (the <elcode>xsl:apply-templates</elcode> instruction) causes everything except
                  the <code>note</code> elements to be copied to the result; the second instruction
                  (the literal result element <code>footnote</code>) outputs a count of the number
                  of descendant <code>note</code> elements.</p>
               <p>Note that although the processing makes a single pass over the input stream, there
                  is some buffering of results required, because the results of the instructions
                  within the <elcode>xsl:fork</elcode> instruction need to be concatenated. In this
                  case an intelligent implementation might be able to restrict the buffered data to
                  a single integer.</p>
               <p>In a formal sense, however, the result is exactly the same as if the
                     <elcode>xsl:fork</elcode> element were not there.</p>
               <p>An alternative way of solving this example problem would be to
                  count the number of <code>note</code> elements using an accumulator: see <specref ref="accumulators"/>.</p>
            </example>



         </div2>


      </div1>
      <div1 id="regular-expressions">
         <head>Regular Expressions</head>
         <p>The function library for XPath 3.0
            defines several functions that make use of
            regular expressions:</p>
         <ulist>
            <item>
               <p>
                  <xfunction>matches</xfunction> returns a boolean result that indicates whether or
                  not a string matches a given regular expression.</p>
            </item>
            <item>
               <p>
                  <xfunction>replace</xfunction> takes a string as input and returns a string
                  obtained by replacing all substrings that match a given regular expression with a
                  replacement string.</p>
            </item>
            <item>
               <p>
                  <xfunction>tokenize</xfunction> returns a sequence of strings formed by breaking a
                  supplied input string at any separator that matches a given regular
                  expression.</p>
            </item>
            <item>
               <p>
                  <xfunction>analyze-string</xfunction> returns a tree of nodes that effectively add
                  markup to a string indicating the parts of the string that matched the regular
                  expression, as well as its captured groups.</p>
            </item>
         </ulist>

         <p>These functions are described in <bibref ref="xpath-functions-40"/>.</p>
         <p>Supplementing these functions, XSLT provides
            an instruction <elcode>xsl:analyze-string</elcode>, which is defined in this
            section.</p>
         <note>
            <p>The <elcode>xsl:analyze-string</elcode> instruction predates the
                  <xfunction>analyze-string</xfunction> function, and provides very similar
               functionality, though in a different way. The two constructs are not precisely
               equivalent; for example, <elcode>xsl:analyze-string</elcode> allows a regular
               expression that matches a zero-length string while the
                  <xfunction>analyze-string</xfunction> function does not. The
                  <elcode>xsl:analyze-string</elcode> instruction (via the use of
                  <function>regex-group</function>) provides information about the value of captured
               substrings; the <xfunction>analyze-string</xfunction> function additionally provides
               information about the position of the captured substrings within the original
               string.</p>
         </note>
         <p>The regular expressions used by this instruction, and the flags that control the
            interpretation of these regular expressions, <rfc2119>must</rfc2119> conform to the
            syntax defined in <bibref ref="xpath-functions-40"/> (see <xspecref spec="FO40" ref="regex-syntax"/>), which is itself based on the syntax defined in <bibref ref="xmlschema-2"/>.</p>




         <div2 id="analyze-string">
            <head>The <code>xsl:analyze-string</code> Instruction</head>
            <?element xsl:analyze-string?>
            <?element xsl:matching-substring?>
            <?element xsl:non-matching-substring?>
            <p>The <elcode>xsl:analyze-string</elcode> instruction takes as input a string (the
               result of evaluating the expression in the <code>select</code> attribute) and a
               regular expression (the effective value of the <code>regex</code> attribute).</p>
            <p>If the result of evaluating the <code>select</code> expression <!--bug 7676-->is an empty sequence, it is treated as a zero-length string.
                  If the value is not a string, it is converted to a string by applying the
                  <termref def="dt-coercion-rules"/>.</p>
            <p>The <code>flags</code> attribute may be used to control the interpretation of the
               regular expression. If the attribute is omitted, the effect is the same as supplying
               a zero-length string. This is interpreted in the same way as the <code>$flags</code>
               attribute of the functions <xfunction>matches</xfunction>,
                  <xfunction>replace</xfunction>, and <xfunction>tokenize</xfunction>. Specifically,
               if it contains the letter <code>m</code>, the match operates in multiline mode. If it
               contains the letter <code>s</code>, it operates in dot-all mode. If it contains the
               letter <code>i</code>, it operates in case-insensitive mode. If it contains the
               letter <code>x</code>, then whitespace within the regular expression is ignored. For
               more detailed specifications of these modes, see <bibref ref="xpath-functions-40"/>
                  (<xspecref ref="flags" spec="FO40"/>).</p>
            <note>
               <p>Because the <code>regex</code> attribute is an attribute value template, curly
                  brackets within the regular expression must be doubled. For example, to match a
                  sequence of one to five characters, write <code>regex=".{{1,5}}"</code>. For
                  regular expressions containing many curly brackets it may be more convenient to
                  use a notation such as <code>regex="{'[0-9]{1,5}[a-z]{3}[0-9]{1,2}'}"</code>, or
                  to use a variable.</p>
            </note>
            <p>The <elcode>xsl:analyze-string</elcode> instruction may have two child elements:
                  <elcode>xsl:matching-substring</elcode> and
                  <elcode>xsl:non-matching-substring</elcode>. Both elements are optional, and
               neither may appear more than once. At least one of them must be present. If both are
               present, the <elcode>xsl:matching-substring</elcode> element must come first.</p>
            <p>The content of the <elcode>xsl:analyze-string</elcode> instruction must take one of
               the following forms:</p>
            <olist>
               <item>
                  <p>A single <elcode>xsl:matching-substring</elcode> instruction, followed by zero
                     or more <elcode>xsl:fallback</elcode> instructions</p>
               </item>
               <item>
                  <p>A single <elcode>xsl:non-matching-substring</elcode> instruction, followed by
                     zero or more <elcode>xsl:fallback</elcode> instructions</p>
               </item>
               <item>
                  <p>A single <elcode>xsl:matching-substring</elcode> instruction, followed by a
                     single <elcode>xsl:non-matching-substring</elcode> instruction, followed by
                     zero or more <elcode>xsl:fallback</elcode> instructions</p>
               </item>
            </olist>
            <p>
               <error spec="XT" type="static" class="SE" code="1130">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <elcode>xsl:analyze-string</elcode> instruction contains neither an
                        <elcode>xsl:matching-substring</elcode> nor an
                        <elcode>xsl:non-matching-substring</elcode> element.</p>
               </error>
            </p>
            <p>Any <elcode>xsl:fallback</elcode> elements among the children of the
                  <elcode>xsl:analyze-string</elcode> instruction are ignored by an XSLT 2.0 or 3.0 processor, but allow fallback behavior to be
               defined when the stylesheet is used with an XSLT 1.0 processor operating with
               forwards-compatible behavior.</p>
            <p>This instruction is designed to process all the non-overlapping substrings of the
               input string that match the regular expression supplied.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1140">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the <termref def="dt-effective-value">effective value</termref> of the <code>regex</code>
                     attribute <error.extra>of the <elcode>xsl:analyze-string</elcode>
                        instruction</error.extra> does not conform to the
                        <rfc2119>required</rfc2119> syntax for regular expressions, as specified in
                        <bibref ref="xpath-functions-40"/>. If the regular expression is known
                     statically (for example, if the attribute does not contain any <termref def="dt-expression">expressions</termref> enclosed in curly brackets) then
                     the processor <rfc2119>may</rfc2119> signal the error as a <termref def="dt-static-error">static error</termref>. </p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1145">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the <termref def="dt-effective-value">effective value</termref> of the <code>flags</code>
                     attribute <error.extra>of the <elcode>xsl:analyze-string</elcode>
                        instruction</error.extra> has a value other than the values defined in
                        <bibref ref="xpath-functions-40"/>. If the value of the attribute is known
                     statically (for example, if the attribute does not contain any <termref def="dt-expression">expressions</termref> enclosed in curly brackets) then
                     the processor <rfc2119>may</rfc2119> signal the error as a <termref def="dt-static-error">static error</termref>. </p>
               </error>
            </p>
            
            <p>To explain the behavior of the instruction it is useful to consider
               an input string of length <var>N</var> characters as having <var>N+1</var>
               inter-character positions, including one just before the first character and one just
               after the last. Each of these positions is a possible position for testing whether
               the regular expression matches. These positions are numbered from zero to
                  <code>N</code>.</p>

            <note>
               <p>The term <term>character</term>, here as elsewhere in this specification, means a
                  Unicode codepoint. When strings are held in decomposed form, the multiple
                  codepoints representing a composite character are considered to be multiple
                  characters. A codepoint greater than 65535 is considered as one character, not as
                  a surrogate pair.</p>
            </note>

            <p>The processor starts by setting the current position to position
               zero, and the current non-matching substring to a zero-length string. It then does
               the following repeatedly:</p>

            <olist>
               <item>
                  <p>Test whether the regular expression matches at the current position.</p>
               </item>
               <item>
                  <p>If there is a match:</p>
                  <olist>
                     <item>
                        <p>If the current non-matching substring has length greater than zero,
                           evaluate the <elcode>xsl:non-matching-substring</elcode> sequence
                           constructor with the current non-matching substring as the context
                           item.</p>
                     </item>
                     <item>
                        <p>Reset the current non-matching substring to a zero-length string.</p>
                     </item>
                     <item>
                        <p>Evaluate the <elcode>xsl:matching-substring</elcode> sequence constructor
                           with the matching substring as the context item.</p>
                     </item>
                     <item>
                        <p>Do the appropriate one of the following:</p>
                        <olist>
                           <item>
                              <p>If the matching substring is non-zero length, set the current
                                 position to coincide with the end of the matching substring, exit,
                                 and repeat.</p>
                           </item>
                           <item>
                              <p>If the matching substring is zero length and the current position
                                 is at the end of the input string, exit.</p>
                           </item>

                           <item>
                              <p>If the matching substring is zero length and the current position
                                 is not at the end of the input string, add the character that
                                 immediately follows the current position to the current
                                 non-matching substring, set the current position to the position
                                 immediately after this character, exit, and repeat.</p>
                           </item>
                        </olist>
                     </item>
                  </olist>
               </item>
               <item>
                  <p>If there is no match:</p>
                  <olist>
                     <item>
                        <p>If the current position is the last position (that is, just after the
                           last character):</p>
                        <olist>
                           <item>
                              <p>If the current non-matching substring has length greater than zero,
                                 evaluate the <elcode>xsl:non-matching-substring</elcode> sequence
                                 constructor with the current non-matching substring as the context
                                 item.</p>
                           </item>
                           <item>
                              <p>Exit.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>Otherwise, add the character at the current position to the current
                           non-matching substring, increment the current position, and repeat.</p>
                     </item>
                  </olist>
               </item>

            </olist>

            <p>When the matcher is looking for a match at a particular
                  starting position and there are  several alternatives within the regular
               expression that match at this position in the input string, then the match that is
               chosen is the first alternative that matches. For example, if the input string is
                  <code>The quick brown fox jumps</code> and the regular expression is
                  <code>jump|jumps</code>, then the match that is chosen is <code>jump</code>. </p>



            <p>The input string is thus partitioned into a sequence of substrings, some of which
               match the regular expression, others which do not match it. Each non-matching substring will contain at least one character, but a matching
                  substring may be zero-length.  This sequence of substrings is processed
               using the instructions within the contained
                     <elcode>xsl:matching-substring</elcode> and
                     <elcode>xsl:non-matching-substring</elcode> elements. A matching
               substring is processed using the <elcode>xsl:matching-substring</elcode> element, a
               non-matching substring using the <elcode>xsl:non-matching-substring</elcode> element.
               Each of these elements takes a <termref def="dt-sequence-constructor"/> as its
               content. If the element is absent, the effect is the same as if it were present with
               empty content. In processing each substring, the contents of the substring will be
               the <termref def="dt-context-item">context item</termref> (as a value of type
                  <code>xs:string</code>); the position of the substring within the sequence of
               matching and non-matching substrings will be the <termref def="dt-context-position">context position</termref>; and the number of matching and non-matching
               substrings will be the <termref def="dt-context-size">context size</termref>.</p>
            
         </div2>
         <div2 id="func-regex-group">
            <head><?function fn:regex-group?></head>
            <p><termdef id="dt-current-captured-substrings" term="current captured substrings" role="placemarker"/></p>
         </div2>
         <div2 id="regex-examples">
            <head>Examples of Regular Expression Matching</head>
            <example>
               <head>Replacing Characters by Elements</head>
               <p>Problem: replace all newline characters in the <code>abstract</code> element by
                  empty <code>br</code> elements:</p>
               <p>Solution:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:analyze-string select="abstract" regex="\n"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;br/&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;</eg>
            </example>
            <example>
               <head>Recognizing non-XML Markup Structure</head>
               <p>Problem: replace all occurrences of <code>[...]</code> in the <code>body</code> by
                     <code>cite</code> elements, retaining the content between the square brackets
                  as the content of the new element.</p>
               <p>Solution:</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:analyze-string select="body" regex="\[(.*?)\]"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;cite&gt;&lt;xsl:value-of select="regex-group(1)"/&gt;&lt;/cite&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;</eg>
               <p>Note that this simple approach fails if the <code>body</code> element contains
                  markup that needs to be retained. In this case it is necessary to apply the
                  regular expression processing to each text node individually. If the
                     <code>[...]</code> constructs span multiple text nodes (for example, because
                  there are elements within the square brackets) then it probably becomes necessary
                  to make two or more passes over the data.</p>
            </example>
            <example>
               <head>Parsing a Date</head>
               <p>Problem: the input string contains a date such as <code>23 March 2002</code>.
                  Convert it to the form <code>2002-03-23</code>.</p>
               <p>Solution (with no error handling if the input format is incorrect):</p>
               <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:variable name="months" 
        select="'January', 'February', 'March', ..."/&gt;

&lt;xsl:analyze-string select="normalize-space($input)" 
    regex="([0-9]{{1,2}})\s([A-Z][a-z]+)\s([0-9]{{4}})"&gt;
    &lt;xsl:matching-substring&gt;
        &lt;xsl:number value="regex-group(3)" format="0001"/&gt;          
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="index-of($months, regex-group(2))" format="01"/&gt;
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="regex-group(1)" format="01"/&gt;
    &lt;/xsl:matching-substring&gt;
&lt;/xsl:analyze-string&gt;</eg>
               <p>Note the use of <code>normalize-space</code> to simplify the work done by the
                  regular expression, and the use of doubled curly brackets because the
                     <code>regex</code> attribute is an attribute value template.</p>
            </example>
            <example>
               <head>Matching Zero-Length Strings</head>

               <p>This example removes all empty and whitespace-only lines from a file.</p>

               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:analyze-string select="unparsed-text('in.txt')"
                    regex="^[\t ]*$" flags="m" expand-text="yes"&gt;
  &lt;xsl:non-matching-substring&gt;{.}&lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;</eg>

            </example>
            <example>
               <head>Parsing comma-separated values</head>

               <p>There are many variants of CSV formats. This example is designed to handle input
                  where:</p>

               <ulist>
                  <item>
                     <p>Each record occupies one line.</p>
                  </item>
                  <item>
                     <p>Fields are separated by commas.</p>
                  </item>
                  <item>
                     <p>Quotation marks around a field are optional, unless the field contains a
                        comma or quotation mark, in which case they are mandatory.</p>
                  </item>
                  <item>
                     <p>A quotation mark within the value of a field is represented by a pair of two
                        adjacent quotation marks.</p>
                  </item>
               </ulist>

               <p>For example, the input record:</p>

               <eg role="non-xml" xml:space="preserve">Ten Thousand,10000,,"10,000","It's ""10 Grand"", mister",10K</eg>

               <p>contains six fields, specifically:</p>

               <ulist>
                  <item>
                     <p>Ten Thousand</p>
                  </item>
                  <item>
                     <p>10000</p>
                  </item>
                  <item>
                     <p>&lt;zero-length-string&gt;</p>
                  </item>
                  <item>
                     <p>10,000</p>
                  </item>
                  <item>
                     <p>It's "10 Grand", mister</p>
                  </item>
                  <item>
                     <p>10K</p>
                  </item>
               </ulist>

               <p>The following code parses such CSV input into an XML structure containing
                     <code>row</code> and <code>col</code> elements:</p>

               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:for-each select="unparsed-text-lines('in.csv')" expand-text="yes"&gt;
  &lt;row&gt;
    &lt;xsl:analyze-string select="." 
                        regex='(?:^|,)(?:"((?:[^"]|"")*)"|([^",]*))'&gt;
      &lt;xsl:matching-substring&gt;
        &lt;col&gt;{replace(regex-group(1), '""', '"')||regex-group(2)}&lt;/col&gt;
      &lt;/xsl:matching-substring&gt;
    &lt;/xsl:analyze-string&gt;
  &lt;/row&gt;
&lt;/xsl:for-each&gt;</eg>

               <p>Note that because this regular expression matches a zero-length string, it is not
                  permitted in XSLT 2.0.</p>
            </example>
         </div2>
      </div1>

      <div1 id="streaming">
         <head>Streaming</head>

         <p>XSLT 3.0 introduces a number of constructs that are specifically designed to enable
            streamed applications to be written, but which are also useful in their own right; it
            also includes some features that are very specialized to streaming.</p>

         <div2 id="source-document-instruction">
            <head>The <code>xsl:source-document</code> Instruction</head>
            <?element xsl:source-document?>
            <p>The <elcode>xsl:source-document</elcode> instruction reads a source document whose URI is
               supplied, and processes the content of the document  by evaluating the
               contained <termref def="dt-sequence-constructor"/>. 
               The <code>streamable</code> attribute (default <code>"no"</code>)
            allows streamed processing to be requested.</p>

            <p>For example, if a document represents a book holding a sequence of chapters, then the
               following code can be used to split the book into multiple XML files, one per
               chapter, without allocating memory to hold the entire book in memory at one time:</p>
            <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:source-document streamable="yes" href="book.xml"&gt;
  &lt;xsl:for-each select="book"&gt;             
    &lt;xsl:for-each select="chapter"&gt;
      &lt;xsl:result-document href="chapter{position()}.xml"&gt;
        &lt;xsl:copy-of select="."/&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:for-each&gt;  
&lt;/xsl:source-document&gt;</eg>
            
            <note><p>In earlier drafts of this specification the <elcode>xsl:source-document</elcode>
            element was named <code>xsl:stream</code>. The instruction has been generalised to handle both streamed and unstreamed
            input.</p></note>
            <p>The document to be read is determined by the <termref def="dt-effective-value">effective value</termref> of the <code>href</code> attribute (which is defined as
               an <termref def="dt-attribute-value-template">attribute value template</termref>).
                  This <rfc2119>must</rfc2119> be a valid URI reference.
                  If it is an absolute URI reference, it is used as is; if it is a relative URI
                  reference, it is made absolute by resolving it against the base URI of the
                     <elcode>xsl:source-document</elcode> element. The process of obtaining a
               document node given a URI is the same as for the <xfunction>doc</xfunction> function.
               However, unlike the <xfunction>doc</xfunction> function, the
                  <elcode>xsl:source-document</elcode> instruction offers no guarantee that the resulting
               document will be stable (that is, that multiple calls specifying the same URI will
               return the same document).</p>
            <p>Specifically, if an <elcode>xsl:source-document</elcode> instruction is evaluated several
               times (or if different <elcode>xsl:source-document</elcode> instructions are evaluated) with
               the same URI (after making it absolute) as the
               value of the <code>href</code> attribute, it is <termref def="dt-implementation-dependent">implementation-dependent</termref> whether the
               same nodes or different nodes are returned on each occasion; it is also possible that
               the actual document content will be different. </p>
            
            <note><p>A different node will necessarily be returned if there
               are differences in attributes such as <code>validation</code>, <code>type</code>,
               <code>streamable</code>, or <code>use-accumulators</code>, or if the calls are in different
               <termref def="dt-package">packages</termref> with variations in the rules for whitespace
               stripping or stripping of type annotations.</p></note>

            <p>The result of the <elcode>xsl:source-document</elcode> instruction is the same as the result
               of the following (non-streaming) process:</p>
            <olist>
               <item>
                  <p>The source document is read from the supplied URI and parsed to form a
                     tree of nodes in the XDM data model.</p>
               </item>
               <item>
                  <p>The contained sequence constructor is evaluated with the root node of this tree
                     as the context item, and with the context
                     position and context size set to one; and the resulting sequence is returned as
                     the result of the <elcode>xsl:source-document</elcode> instruction.</p>
               </item>
            </olist>

            <p>The <elcode>xsl:source-document</elcode> instruction is <termref def="dt-guaranteed-streamable"/> if both the following conditions are satisfied:</p>
            
            <olist>
               <item><p>It is <termref def="dt-declared-streamable"/>, by specifying
               <code>streamable="yes"</code>.</p></item>
               <item><p>the contained <termref def="dt-sequence-constructor"/> is <termref def="dt-grounded"/>, as assessed using
               the streamability analysis in <specref ref="streamability"/>. The consequences of
               being or not being guaranteed streamable depend on the processor conformance level,
               and are explained in <specref ref="streamability-guarantees"/>.</p></item>
            </olist>
            

            <p>The <code>use-accumulators</code> attribute defines the
               set of accumulators that are applicable to the document, as explained in
                  <specref ref="applicability-of-accumulators"/>.</p>
            
            <note>
               <p>The following notes apply specifically to streamed processing.</p>
               <p>The rules for <termref def="dt-guaranteed-streamable">guaranteed streamability</termref>
                  ensure that the sequence constructor (and therefore the
                     <elcode>xsl:source-document</elcode> instruction) cannot return any nodes from the
                     <termref def="dt-streamed-document">streamed document</termref>. For example,
                  it cannot contain the instruction <code>&lt;xsl:sequence
                     select="//chapter"/&gt;</code>. If nodes from this document are to be returned,
                  they must first be copied, for example by using the
                        <elcode>xsl:copy-of</elcode> instruction or by calling the
                     <function>copy-of</function> or <function>snapshot</function> functions.</p>

               <p>Because the <elcode>xsl:source-document</elcode> instruction cannot (if it satisfies the rules for guaranteed
                     streamability) return nodes from the streamed document, any nodes it
                  does return will be conventional (unstreamed) nodes that can be processed without
                  restriction. For example, if <elcode>xsl:source-document</elcode> is invoked within a
                     <termref def="dt-stylesheet-function">stylesheet function</termref>
                  <code>f:firstChapter</code>, and the sequence constructor consists of the
                  instruction <code>&lt;xsl:copy-of select="//chapter"/&gt;</code>, then the calling
                  code can manipulate the resulting <code>chapter</code> elements as ordinary trees
                  rooted at parentless element nodes.</p>

               <p>If the sequence constructor in an
                     <elcode>xsl:source-document</elcode> instruction were to return nodes from the document
                  for which streaming has been requested, the instruction would not be guaranteed
                  streamable. Processors which support the streaming feature would then not be
                  required to process it in a streaming manner, and this specification imposes no
                  restrictions on the processing of the nodes returned. (The ability of a streaming
                  processor to handle such stylesheets in a streaming manner might, of course,
                  depend on how the nodes returned are processed, but those details are out of scope
                  for this specification.) </p>

            </note>

            <div3 id="source-document-validation">
               <head>Validation of Source Documents</head>
               <p>The <code>validation</code> and <code>type</code> attributes of
                     <elcode>xsl:source-document</elcode> may be used to control schema validation of the
                  input document. They have the same effect as the
                  corresponding attributes of the <elcode>xsl:copy-of</elcode> instruction when
                  applied to a document node, except that 
                  when <code>streamable="yes"</code> is specified, 
                  the copy that is produced is itself a
                  streamed document. The process is described in more detail in <specref ref="validating-document-nodes"/>.</p>

               <p>These two attributes are both optional, and if one is specified then the other
                     <rfc2119>must</rfc2119> be omitted (<errorref spec="XT" class="SE" code="1505"/>).</p>

               <p>The presence of a <code>validation</code> or <code>type</code> attribute on an
                     <elcode>xsl:source-document</elcode> instruction causes any
                     <code>input-type-annotations</code> attribute to have no effect on any document
                  read using that instruction.</p>

               <note>
                  <p>In effect, setting <code>validation</code> to <code>strict</code> or
                        <code>lax</code>, or supplying the <code>type</code> attribute, requests
                     document-level validation of the input as it is read. Setting
                        <code>validation="preserve"</code> indicates that if the incoming document
                     contains type annotations (for example, produced by validating the output of a
                     previous step in a streaming pipeline) then they should be retained, while the
                     value <code>strip</code> indicates that any such type annotations should be
                     dropped.</p>
                  <p>It is a consequence of the way validation is defined in XSD that the type
                     annotation of an element node can be determined during the processing of its
                     start tag, although the actual validity of the element is not known until the
                     end tag is encountered. When validation is requested, a streamed document
                     should not present data to the stylesheet except to the extent that such data
                     could form the leading part of a valid document. If the document proves to be
                     invalid, the processor should not pass invalid data to the stylesheet to be
                     processed, but should immediately signal the appropriate error. For the
                     purposes of <elcode>xsl:try</elcode> and <elcode>xsl:catch</elcode>, this error
                     can only be caught at the level of the <elcode>xsl:source-document</elcode> instruction
                     that initiated validation, not at a finer level. If validation errors are
                     caught in this way, any output that has been computed up to the point of the
                     error is not added to the final result tree; the mechanisms to achieve this may
                     use memory, which may reduce the efficacy of streaming.</p>
                  <p>The analysis of guaranteed streamability (see <specref ref="streamability"/>)
                     takes no account of information that might be obtained from a schema-aware
                     static analysis of the stylesheet. Implementations may, however, be able to use
                     streaming strategies for stylesheets that are not guaranteed-streamable, by
                     taking advantage of such information. For example, an implementation might be
                     able to treat the expression <code>.//title</code> as <termref def="dt-striding"/> rather than <termref def="dt-crawling"/> if it can
                     establish from knowledge of the schema that two <code>title</code> elements
                     will never be nested one inside the
                        other.</p>
               </note>
            </div3>


            <div3 id="stream-examples">
               <head>Examples of <code>xsl:source-document</code></head>
               <p>The <elcode>xsl:source-document</elcode> instruction can be used to initiate processing of
                  a document using streaming with a variety of coding styles, illustrated in the
                  examples below.</p>
               
               <example>
                  <head>Using <elcode>xsl:source-document</elcode> with Aggregate Functions</head>
                  <p>The following example computes the number of transactions in a transaction
                     file</p>
                  <p>Input:</p>
                  <eg role="xml" xml:space="preserve">
&lt;transactions&gt;
  &lt;transaction value="12.51"/&gt;
  &lt;transaction value="3.99"/&gt;
&lt;/transactions&gt;</eg>
                  <p>Stylesheet code:</p>
                  <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
  &lt;count&gt;
    &lt;xsl:value-of select="count(transactions/transaction)"/&gt;
  &lt;/count&gt;
&lt;/xsl:source-document&gt;</eg>
                  <p>Result:</p>
                  <eg role="xml" xml:space="preserve">&lt;count&gt;2&lt;/count&gt;</eg>
                  <p>Analysis:</p>
                  <olist>
                     <item>
                        <p>The literal result element <code>count</code> has the same sweep as the
                              <elcode>xsl:value-of</elcode> instruction.</p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:value-of</elcode> instruction has the same sweep as its
                              <code>select</code> expression.</p>
                     </item>
                     <item>
                        <p>The call to <code>count</code> has the same sweep as its argument.</p>
                     </item>
                     <item>
                        <p>The argument to <code>count</code> is a <code>RelativePathExpr</code>.
                           Under the rules in <specref ref="streamability-of-path-expressions"/>,
                           this expression is <termref def="dt-striding"/> and <termref def="dt-consuming"/>. The
                              call on <code>count</code> is therefore <termref def="dt-grounded"/> and <termref def="dt-consuming"/>.
                        </p></item>
                     <item><p>The entire body of the <elcode>xsl:source-document</elcode> instruction is therefore
                        <termref def="dt-grounded"/> and <termref def="dt-consuming"/>.</p>
                     </item>
                  </olist>
                  <p>The following example computes the highest-value transaction in the same input
                     file:</p>
                  <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
  &lt;maxValue&gt;
    &lt;xsl:value-of select="max(transactions/transaction/@value)"/&gt;
  &lt;/maxValue&gt;
&lt;/xsl:source-document&gt;</eg>
                  <p>Result:</p>
                  <eg role="xml" xml:space="preserve">&lt;maxValue&gt;12.51&lt;/maxValue&gt;</eg>
                  <p>Analysis:</p>
                  <olist>
                     <item>
                        <p>The literal result element <code>maxValue</code> has the same sweep as
                           the <elcode>xsl:value-of</elcode> instruction.</p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:value-of</elcode> instruction has the same sweep as its
                              <code>select</code> expression.</p>
                     </item>
                     <item>
                        <p>The call to <code>max</code> has the same sweep as its argument.</p>
                     </item>
                     <item>
                        <p>The argument to <code>max</code> is a <code>RelativePathExpr</code> whose
                           two operands are the <code>RelativePathExpr</code>
                           <code>transactions/transaction</code> and the <code>AxisStep</code>
                           <code>@value</code>. The left-hand operand <code>transactions/transaction</code> has
                              <termref def="dt-striding"/>
                              <termref def="dt-posture"/>. The right-hand operand <code>@value</code>, given
                           that <phrase diff="chg" at="A">the context posture is striding</phrase>, is <termref def="dt-motionless"/>. The <code>RelativePathExpr</code> argument to <code>max</code> is
                           therefore consuming. <phrase diff="add" at="A">[XSLT 3.0 Erratum E9, bug 30130].</phrase></p>
                     </item>
                     <item>
                        <p>The entire body of the <elcode>xsl:source-document</elcode> instruction is
                           therefore <termref def="dt-consuming"/>.</p>
                     </item>
                  </olist>
                  <p>To compute both the count and the maximum value in a single pass over the
                     input, several approaches are possible. The simplest is to use maps (map constructors
                     are exempt from the usual rule that multiple downward selections are not allowed):</p>
                  
                  <eg xml:space="preserve" role="xslt-instruction">&lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
  &lt;xsl:variable name="tally" select="map{ 'count': count(transactions/transaction), 
                                          'max':   max(transactions/transaction/@value)}"/&gt;
  &lt;value count="{$tally('count')}" max="{$tally('max')}"/&gt;
&lt;/xsl:source-document&gt;</eg>
                  <p>Other options include the use of <elcode>xsl:fork</elcode>, or multiple <elcode>xsl:accumulator</elcode>
                  declarations, one for each value to be computed.</p>
               </example>
               <example>
                  <head>Using <elcode>xsl:source-document</elcode> with <elcode>xsl:for-each</elcode> to
                     Process a Collection of Input Documents </head>
                  <p>This example displays a list of the chapter titles extracted from each book in
                     a collection of books.</p>
                  <p>Each input document is assumed to have a structure such as:</p>
                  <eg role="xml" xml:space="preserve">&lt;book&gt;
  &lt;chapter number-of-pages="18"&gt;
    &lt;title&gt;The first chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter number-of-pages="15"&gt;
    &lt;title&gt;The second chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter number-of-pages="12"&gt;
    &lt;title&gt;The third chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
&lt;/book&gt;</eg>
                  <p>Stylesheet code:</p>
                  <eg xml:space="preserve" role="xslt-fragment">&lt;chapter-titles&gt;
  &lt;xsl:for-each select="uri-collection('books')"&gt;
    &lt;xsl:source-document streamable="yes" href="{.}"&gt;
      &lt;xsl:for-each select="book"&gt;
        &lt;xsl:for-each select="chapter"&gt;
           &lt;title&gt;&lt;xsl:value-of select="title"/&gt;&lt;/title&gt;
        &lt;/xsl:for-each&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:source-document&gt;
  &lt;/xsl:for-each&gt;
&lt;/chapter-titles&gt;</eg>
                  <p>Output:</p>
                  <eg role="xml" xml:space="preserve">&lt;chapter-titles&gt;
  &lt;title&gt;The first chapter of book A&lt;/title&gt;
  &lt;title&gt;The second chapter of book A&lt;/title&gt;
  ...
  &lt;title&gt;The first chapter of book B&lt;/title&gt;
  ...
&lt;/chapter-titles&gt;</eg>
                  <note>
                     <p>This example uses the function <xfunction>uri-collection</xfunction> to
                        obtain the document URIs of all the documents in a collection, so that each
                        one can be processed in turn using <elcode>xsl:source-document</elcode>.</p>
                  </note>
               </example>
               <example>
                  <head>Using <elcode>xsl:source-document</elcode> with <elcode>xsl:iterate</elcode>
                  </head>
                  <p>This example assumes that the input is a book with multiple chapters, as shown
                     in the previous example, with the page count for each chapter given as an
                     attribute of the chapter. The transformation determines the starting page
                     number for each chapter by accumulating the page counts for previous chapters,
                     and rounding up to an odd number if necessary.</p>
                  <eg xml:space="preserve" role="xslt-fragment">&lt;chapter-start-page&gt;
   &lt;xsl:source-document streamable="yes" href="book.xml"&gt;
      &lt;xsl:iterate select="book/chapter"&gt;
         &lt;xsl:param name="start-page" select="1"/&gt;
         &lt;chapter title="{title}" start-page="{$start-page}"/&gt;
         &lt;xsl:next-iteration&gt;
            &lt;xsl:with-param name="start-page" 
                            select="$start-page + @number-of-pages + 
                                      (@number-of-pages mod 2)"/&gt;
         &lt;/xsl:next-iteration&gt;
      &lt;/xsl:iterate&gt;
   &lt;/xsl:source-document&gt;
&lt;/chapter-start-page&gt;
</eg>
                  <p>Output:</p>
                  <eg role="xml" xml:space="preserve">&lt;chapter-start-page&gt;
  &lt;chapter title="The first chapter of book A" start-page="1"/&gt;
  &lt;chapter title="The second chapter of book A" start-page="19"/&gt;
  &lt;chapter title="The third chapter of book A" start-page="35"/&gt;
  ...
&lt;/chapter-start-page&gt;
                     </eg>
               </example>
               <example>
                  <head>Using <elcode>xsl:source-document</elcode> with <elcode>xsl:for-each-group</elcode>
                  </head>
                  <p>This example assumes that the input is a book with multiple chapters, and that
                     each chapter belongs to a part, which is present as an attribute of the chapter
                     (for example, chapters 1-4 might constitute Part 1, the next three chapters
                     forming Part 2, and so on):</p>
                  <eg role="xml" xml:space="preserve">&lt;book&gt;
  &lt;chapter part="1"&gt;
    &lt;title&gt;The first chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  &lt;chapter part="1"&gt;
    &lt;title&gt;The second chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
  ...
  &lt;chapter part="2"&gt;
    &lt;title&gt;The fifth chapter of book A&lt;/title&gt;
    ...
  &lt;/chapter&gt;
&lt;/book&gt;</eg>
                  <p>The transformation copies the full text of the chapters, creating an extra
                     level of hierarchy for the parts.</p>
                  <eg xml:space="preserve" role="xslt-fragment">&lt;book&gt;
   &lt;xsl:source-document streamable="yes" href="book.xml"&gt;
      &lt;xsl:for-each select="book"&gt;
         &lt;xsl:for-each-group select="chapter" group-adjacent="data(@part)"&gt;
            &lt;part number="{current-grouping-key()}"&gt;
               &lt;xsl:copy-of select="current-group()"/&gt;
            &lt;/part&gt;
         &lt;/xsl:for-each-group&gt;
      &lt;/xsl:for-each&gt;
   &lt;/xsl:source-document&gt;
&lt;/book&gt;
</eg>
                  <p>Output:</p>
                  <eg role="xml" xml:space="preserve">&lt;book&gt;
  &lt;part number="1"&gt;
    &lt;chapter part="1"&gt;
      &lt;title&gt;The first chapter of book A&lt;/title&gt;
      ...
    &lt;/chapter&gt;
    &lt;chapter part="1"&gt;
      &lt;title&gt;The second chapter of book A&lt;/title&gt;
      ...
    &lt;/chapter&gt;
    ...
  &lt;/part&gt;
  &lt;part number="2"&gt;
    &lt;chapter part="2"&gt;
      &lt;title&gt;The fifth chapter of book A&lt;/title&gt;
    ...
    &lt;/chapter&gt;
    ...
  &lt;/part&gt;
&lt;/book&gt;
    </eg>
               </example>
               <example>
                  <head>Using <elcode>xsl:source-document</elcode> with <elcode>xsl:apply-templates</elcode>
                  </head>
                  <p>This example copies an XML document while deleting all the <code>ednote</code>
                     elements at any level of the tree, together with their descendants. This
                     example is a complete stylesheet, which is intended to be evaluated by
                     nominating <code>main</code> as the <termref def="dt-initial-named-template"/>.
                     The use of <code>on-no-match="deep-copy"</code> in the
                        <elcode>xsl:mode</elcode> declaration means that the built-in template rule
                     copies nodes unchanged, except where overridden by a user-defined template
                     rule.</p>
                  <eg xml:space="preserve" role="xslt-document">&lt;xsl:transform version="3.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:mode name="delete-ednotes" streamable="yes" 
                                on-no-match="shallow-copy"/&gt;

&lt;xsl:template name="main"&gt;
   &lt;xsl:source-document streamable="yes" href="book.xml"&gt;
      &lt;xsl:apply-templates mode="delete-ednotes"/&gt;
   &lt;/xsl:source-document&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ednote" mode="delete-ednotes"/&gt;

&lt;/xsl:transform&gt;</eg>
                  <p>Additional template rules could be added to process other elements and
                     attributes in the same pass through the data: for example, to modify the value
                     of a <code>last-updated</code> attribute (wherever it appears) to the current
                     date and time, the following rule suffices:</p>
                  <eg xml:space="preserve" role="xslt-declaration">
&lt;xsl:template match="@last-updated" mode="delete-ednotes"&gt;
  &lt;xsl:attribute name="last-updated" select="current-dateTime()"/&gt;
&lt;/xsl:template&gt;</eg>
               </example>

               <!--              <example>
                  <head>Using <elcode>xsl:source-document</elcode> with <elcode>xsl:merge</elcode>
                  </head>
                  <p>This example builds a file representing the index of a book from files
                     containing the index for each chapter. The chapter-level index files contain
                     entries of the form <code>&lt;entry term="XML" page="27"/></code> sorted first
                     alphabetically by term and then numerically by page number; the sort order for
                     the combined index is the same.</p>
                  <eg xml:space="preserve"><![CDATA[<index>
   <xsl:merge>
     <xsl:merge-source select="uri-collection('chapter-indexes')">
         <xsl:source-document streamable="yes" href="{.}">
           <xsl:copy-of select="index/entry"/>
         </xsl:source-document>
         <xsl:merge-key select="string(@term)"/>
         <xsl:merge-key select="xs:integer(@page)"/>
    </xsl:merge-source>
    <xsl:merge-action>
       <xsl:copy-of select="current-group()[1]"/>
    </xsl:merge-action>
  </xsl:merge>
</index>]]></eg>

                  <p>In cases where two chapter indexes contain entries for the same term, they will
                     normally have different page numbers, and will therefore go in separate groups.
                     Their order in the output is based on the ordering of the merge keys, which
                     means entries with the same term appear in page number order. In the unlikely
                     case that two files contain entries where both the term and the page number are
                     the same (or, perhaps more plausibly, where such duplicates occur within a
                     single input file), the <elcode>xsl:merge-action</elcode> ensures that only the
                     first of the duplicates will be copied. </p>
               </example>-->
            </div3>
            <div3 id="func-stream-available">
               <head><?function fn:stream-available?></head>
            </div3>
         </div2>


         <div2 id="accumulators">
            <head>Accumulators</head>
            <p>Accumulators are introduced in XSLT 3.0 to enable data that is read during streamed
               processing of a document to be accumulated, processed or retained for later use.
               However, they may equally be used with non-streamed processing.</p>

            <p><termdef id="dt-accumulator" term="accumulator">An
                     <term>accumulator</term> defines a series of
                     values associated with the nodes of the tree. If an accumulator is
                  applicable to a particular tree, then for each node in the tree, other than
                  attribute and namespace nodes, there will be two values available, called the
                  pre-descent and post-descent values. These two values are available via a pair of
                  functions, <function>accumulator-before</function> and
                     <function>accumulator-after</function>.</termdef></p>

            <p>There are two ways the values of an accumulator can be
               established for a given tree: they can be computed by evaluating the rules appearing
               in the <elcode>xsl:accumulator</elcode> declaration, or they can be copied from the
               corresponding nodes in a different tree. The second approach (copying the values) is
               available via the <function>snapshot</function> and <function>copy-of</function>
               functions, or by use of the <elcode>xsl:copy-of</elcode> instruction specifying
                  <code>copy-accumulators="yes"</code>. Accumulator values are also copied during
               the implicit invocation of the snapshot function performed by the
                  <elcode>xsl:merge</elcode> instruction.</p>



            <note>
               <p>Accumulators can apply to trees rooted at any kind of node. But
                  because they are most often applied to trees rooted at a document node, this
                  section sometimes refers to the “document” to which an accumulator applies; use of
                  this term should be taken to include all trees whether or not they are rooted at a
                  document node.</p>
               <p>Accumulators can apply to trees rooted at nodes (such
                  as text nodes) that cannot have children, though this serves no useful purpose. In
                  the case of a tree rooted at an attribute or namespace node, there is no way to
                  obtain the value of the accumulator.</p>
            </note>

            <p>The following sections give first, the syntax rules for defining an accumulator; then
               an informal description of the semantics; then a more formal definition; and finally,
               examples. But to illustrate the concept intuitively, the following simple example
               shows how an accumulator can be used for numbering of nodes:</p>

            <example>
               <head>Numbering Figures within a Chapter</head>
               <p>This example assumes document input in which <code>figure</code> elements can
                  appear within <code>chapter</code> elements (which we assume are not nested), and
                  the requirement is to render the figures with a caption that includes the figure
                  number within its containing chapter.</p>
               <p>When the document is processed using streaming, the <elcode>xsl:number</elcode>
                  instruction is not available, so a solution using accumulators is needed.</p>
               <p>The required accumulator can be defined and used like this:</p>
               <eg role="xslt-declaration" xml:space="preserve">
   &lt;xsl:accumulator name="figNr" as="xs:integer" 
                    initial-value="0" streamable="yes"&gt;
     &lt;xsl:accumulator-rule match="chapter" select="0"/&gt;
     &lt;xsl:accumulator-rule match="figure" select="$value + 1"/&gt;
   &lt;/xsl:accumulator&gt;
   
   &lt;xsl:mode streamable="yes"/&gt;
   &lt;xsl:template match="figure"&gt;
     &lt;xsl:apply-templates/&gt;
     &lt;p&gt;Figure &lt;xsl:value-of select="accumulator-before('figNr')"/&gt;&lt;/p&gt;
   &lt;/xsl:template&gt;  
                  </eg>
            </example>


            <div3 id="accumulator-declaration">
               <head>Declaring an Accumulator</head>
               <?element xsl:accumulator?>
               <?element xsl:accumulator-rule?>

               <p>An <elcode>xsl:accumulator</elcode> element is a <termref def="dt-declaration">declaration</termref> of an accumulator. The
                     <code>name</code> attribute defines the name of the accumulator. The value of
                  the <code>name</code> attribute is an <termref def="dt-eqname">EQName</termref>,
                  which is expanded as described in <specref ref="qname"/>.</p>
               <p>An <elcode>xsl:accumulator</elcode> declaration can only appear as a <termref def="dt-top-level"/> element in a stylesheet module.</p>


               

               

               

               <p>The functions <function>accumulator-before</function>
                     and <function>accumulator-after</function> return, respectively, the
                  value of the accumulator before visiting the descendants of a given node, and the
                  value after visiting the descendants of a node. Each of these functions takes a single argument, the name of the
                  accumulator, and the function applies implicitly to the context node. The
                  type of the return value (for both functions) is determined by the <code>as</code>
                  attribute of the <elcode>xsl:accumulator</elcode> element.</p>

               <p><termdef id="dt-accumulator-function" term="accumulator function">The functions
                        <function>accumulator-before</function> and
                        <function>accumulator-after</function> are referred to as the
                        <term>accumulator functions</term>.</termdef></p>

               <p>For constructs that use accumulators to be
                        <termref def="dt-guaranteed-streamable"/>:</p>
               <ulist>
                  <item>
                     <p>The <function>accumulator-before</function> function for a streamed node can
                        be called at any time the node is available (it behaves like other
                        properties of the node such as <xfunction>name</xfunction> or
                           <xfunction>base-uri</xfunction>).</p>
                  </item>
                  <item>
                     <p>The <function>accumulator-after</function> function, however, is restricted
                            to appear after any instruction that reads the descendants
                        of the node in question. The constraints are expressed as static rules: see
                           <specref ref="streamability-fn-accumulator-after"/> for more details.</p>
                  </item>
               </ulist>



               

               

               

               <p>The initial value of the accumulator is obtained by evaluating the expression in
                  the <code>initial-value</code> attribute. This
                     attribute is mandatory. The expression in the
                     <code>initial-value</code> attribute is evaluated with a <termref def="dt-singleton-focus"/> based on the root node of
                     the streamed input tree to which the accumulator is being applied.</p>

               <p>The values of the accumulator for individual nodes in a tree are obtained by
                  applying the <elcode>xsl:accumulator-rule</elcode> rules contained within the
                     <elcode>xsl:accumulator</elcode> declaration, as described in subsequent
                  sections. The <code>match</code> attribute of
                        <elcode>xsl:accumulator-rule</elcode> is a <termref def="dt-pattern"/> which
                     determines which nodes trigger execution of the rule; the <code>phase</code>
                     attribute indicates whether the rule fires before descendants are processed
                        (<code>phase="start"</code>, which is the default), or after descendants are
                     processed (<code>phase="end"</code>).</p>

               <p>The <code>select</code> attribute and the contained sequence constructor of the
                     <elcode>xsl:accumulator-rule</elcode> element are mutually exclusive: if the
                     <code>select</code> attribute is present then the sequence constructor must be
                  empty. The expression in the <code>select</code>
                  attribute of <elcode>xsl:accumulator-rule</elcode>
                  or the contained sequence constructor
                  is evaluated with a static context that follows the normal rules for expressions
                  in stylesheets, except that:</p>
               <ulist>
                  <item>
                     <p>An additional variable is present in the context. The name of this variable
                        is <code>value</code> (in no namespace), and its type is the type that
                        appears in the <code>as</code> attribute of the
                           <elcode>xsl:accumulator</elcode> declaration.</p>
                  </item>
                  <item>
                     <p>The context item for evaluation of the expression or sequence constructor will always be a node
                        that matches the <termref def="dt-pattern">pattern</termref> in the
                           <code>match</code> attribute.</p>
                  </item>
               </ulist>

               <p>The result of both the <code>initial-value</code> and <code>select</code> expressions (or contained sequence
                     constructor) is converted to the type declared in the <code>as</code>
                  attribute by applying the <termref def="dt-coercion-rules"/>. A
                     <termref def="dt-type-error">type error</termref> occurs if conversion is not
                  possible. The <code>as</code> attribute defaults to <code>item()*</code>.</p>

               <p>The effect of the <code>streamable</code> attribute is defined in <specref ref="streamability-of-accumulators"/>.</p>

            </div3>
            <div3 id="applicability-of-accumulators">
               <head>Applicability of Accumulators</head>

               <p>It is not the case that every accumulator is applicable to every tree. The details
                  depend on how the accumulator is declared, and how the tree is created. The rules
                  are as follows:</p>
               
               <olist> 
                  <item><p>An accumulator is applicable to a tree unless otherwise specified in these rules.
                  (For example, when a document is read using the <function>document</function>,
                  <xfunction>doc</xfunction>, or <xfunction>collection</xfunction> functions,
                  all accumulators are applicable. Similarly, all accumulators are applicable
                  to a <termref def="dt-temporary-tree"/> created using <elcode>xsl:variable</elcode>.)</p></item>
                  <item><p>Regardless of the rules below, an accumulator is not applicable to a <termref def="dt-streamed-document"/>
                     unless the accumulator is declared with <code>streamable="yes"</code>. (The converse
                  does not apply: for unstreamed documents, accumulators are applicable regardless
                  of the value of the <code>streamable</code> attribute.)</p></item>
                  <item><p>For a document read using the
                     <elcode>xsl:source-document</elcode> instruction, the accumulators that are applicable 
                     are those determined by the <code>use-accumulators</code>
                  attribute of that instruction.</p></item>
                  <item><p>For a document read using the <code>for-each-source</code> attribute of an
                     <elcode>xsl:merge-source</elcode> child of an <elcode>xsl:merge</elcode> instruction,
                     the accumulators that are applicable are those determined by the <code>use-accumulators</code>
                     attribute of the <elcode>xsl:merge-source</elcode> element.</p></item>
                  <item><p>For a document containing nodes supplied in the
                     <termref def="dt-initial-match-selection"/>, the accumulators that are
                     applicable are those determined by the <elcode>xsl:mode</elcode>
                     declaration of the <termref def="dt-initial-mode"/>. This means that in the
                     absence of an <elcode>xsl:mode</elcode> declaration, no accumulators are applicable.</p></item>
                  <item><p>For a tree <var>T</var> created by copying a node in a tree <var>S</var>
                     using the <function>copy-of</function> or <function>snapshot</function>
                     functions, or the instruction <elcode>xsl:copy-of</elcode> with
                     <code>copy-accumulators="yes"</code>, an accumulator is applicable to
                     <var>T</var> if and only if it is applicable to <var>S</var>.</p></item>
                  
               </olist>


               <p>If an accumulator is not applicable to the tree containing the context item, calls
                  to the functions <function>accumulator-before</function> and
                     <function>accumulator-after</function>, supplying the name of that accumulator,
                  will fail with a dynamic error.</p>



               <note>
                  <p>The reason that accumulators are not automatically applicable to every streamed
                     document is to avoid the cost of evaluating them, and to avoid the possibility
                     of dynamic errors occuring if they are not designed to work with a particular
                     document structure.</p>
                  <p>In the case of unstreamed documents, there are no compelling reasons to
                     restrict which accumulators are applicable, because an implementation can avoid the cost of
                     evaluating every accumulator against every document by evaluating the
                     accumulator lazily, for example, by only evaluating the accumulator for a
                     particular tree the first time its value is requested for a node in that tree.
                     In the interests of orthogonality, however, restricting the applicable 
                     accumulators works in the same way for streamable and non-streamable documents.
                  </p>
               </note>

               <p>The value of the <code>use-accumulators</code> attribute of
               <elcode>xsl:source-document</elcode>, <elcode>xsl:merge-source</elcode>,
                  or <elcode>xsl:mode</elcode> must either be a
                  whitespace-separated list of <termref def="dt-eqname">EQNames</termref>, or the
                  special token <code>#all</code>. The list may be empty, and the default value is
                  an empty list. Every <code>EQName</code> in the list must be the name of an
                  accumulator, visible in the containing package, and declared with
                     <code>streamable="yes"</code>. The value <code>#all</code> indicates that all
                  accumulators that are visible in the containing package are applicable (except
                  that for a streamable input document, an accumulator is not applicable unless
                  it specifies <code>streamable="yes"</code>).</p>

               <p>
                  <error spec="XT" type="static" class="SE" code="3300">
                     <p>It is a <termref def="dt-static-error">static error</termref> if the list of
                        accumulator names <error.extra>in the <code>use-accumulators</code>
                           attribute</error.extra> contains an invalid token, contains the same
                        token more than once, or contains the token <code>#all</code> along with any
                        other value; or if any token (other than
                              <code>#all</code>) is not the name of a <termref def="dt-declared-streamable"/> accumulator visible in the containing
                           package.</p>
                  </error>
               </p>



            </div3>
            <div3 id="accumulator-informal-rules">
               <head>Informal Model for Accumulators</head>
               <p><emph>This section describes how accumulator values are
                     established by evaluating the rules in an <elcode>xsl:accumulator</elcode>
                     declaration. This process does not apply to trees created with accumulator
                     values copied from another document, for example by using the
                        <function>copy-of</function> or <function>snapshot</function>
                     functions.</emph></p>
               <p>Informally, an accumulator is evaluated by traversing a tree, as
                     follows.</p>
               
               <p>Each node is visited twice, once before processing its descendants, and once after
                  processing its descendants. For consistency, this applies even to leaf nodes: each
                  is visited twice. Attribute and namespace nodes, however, are not visited.</p>
               <p>Before the traversal starts, a variable (called the accumulator variable) is
                  initialized to the value of the expression given as the <code>initial-value</code>
                  attribute.</p>
               <p>On each node visit, the <elcode>xsl:accumulator-rule</elcode> elements are
                  examined to see if there is a matching rule. For a match to occur, the pattern in
                  the <code>match</code> attribute must match the node, and the <code>phase</code>
                  attribute must be <code>start</code> if this is the first visit, and
                     <code>end</code> if it is the second visit. If there is a matching rule, then a
                  new value is computed for the accumulator variable using the expression contained
                  in that rule’s <code>select</code>
                     attribute or the contained sequence constructor. If there is more than
                  one matching rule, the last in document order is used. If there is no matching
                  rule, the value of the accumulator variable does not change.</p>
               <p>Each node is labeled with a pre-descent value for the accumulator, which is the
                  value of the accumulator variable immediately <emph>after</emph> processing the
                  first visit to that node, and with a post-descent value for the accumulator, which
                  is the value of the accumulator variable immediately <emph>after</emph> processing the second visit.</p>

               <p>The function <function>accumulator-before</function> delivers
                  the pre-descent value of the accumulator at the context node; the function
                     <function>accumulator-after</function> delivers the post-descent value of the
                  accumulator at the context node.</p>
               <p>Although this description is expressed in procedural terms, it can be seen that
                  the two values of the accumulator for any given node depend only on the node and
                  its preceding and (in the case of the post-descent value) descendant nodes.
                  Calculation of both values is therefore deterministic and free of side-effects;
                  moreover, it is clear that the values can be computed during a streaming pass of a
                  document, provided that the rules themselves use only information that is
                  available without repositioning the input stream.</p>

               <p>It is permitted for the <code>select</code> expression of an accumulator rule, or the contained
                     sequence constructor, to invoke an accumulator function. For a streamable accumulator, the rules ensure that
                     a rule with <code>phase="start"</code> cannot call the
                        <function>accumulator-after</function> function. When such function calls
                     exist in an accumulator rule, they impose a dependency of one accumulator on
                     another, and create the possibility of cyclic dependencies. Processors are
                     allowed to report the error statically if they can detect it statically.
                     Failing this, processors are allowed to fail catastrophically in the event of a
                     cycle, in the same way as they might fail in the event of infinite function or
                     template recursion. Catastrophic failure might manifest itself, for example, as
                     a stack overflow, or as non-termination of the transformation.</p>
            </div3>
            <div3 id="accumulator-formal-rules">
               <head>Formal Model for Accumulators</head>
               <p><emph>This section describes how accumulator values are
                     established by evaluating the rules in an <elcode>xsl:accumulator</elcode>
                     declaration. This process does not apply to trees created with accumulator
                     values copied from another document, for example by using the
                        <function>copy-of</function> or <function>snapshot</function>
                     functions.</emph></p>
               <p><termdef id="dt-traversal" term="traversal">A <term>traversal</term> of a tree is
                     a sequence of <termref def="dt-traversal-event">traversal
                     events</termref>.</termdef></p>
               <p><termdef id="dt-traversal-event" term="traversal-event">a <term>traversal
                        event</term> (shortened to <term>event</term> in this section) is a pair
                     comprising a phase (start or end) and a node.</termdef> It is modelled as a map
                  with two entries: <code>map{"phase": p, "node": n}</code> where p is the string
                     <code>"start"</code> or <code>"end"</code> and <code>n</code> is a node.</p>
               <p>The traversal of a tree contains two
                  traversal events for each node in the tree, other than attribute and namespace
                  nodes. One of these events (the “start event”) has phase = "start", the other (the
                  "end event") has phase = "end".</p>
               <p>The order of traversal events within a traversal is such that, given any two nodes
                     <var>M</var> and <var>N</var> with start/end events denoted by <var>M0</var>,
                     <var>M1</var>, <var>N0</var>, and <var>N1</var>, :</p>
               <ulist>
                  <item>
                     <p>For any node <var>N</var>, <var>N0</var> precedes <var>N1</var>;</p>
                  </item>
                  <item>
                     <p>If <var>M</var> is an ancestor of <var>N</var> then <var>M0</var> precedes
                           <var>N0</var> and <var>N1</var> precedes <var>M1</var>;</p>
                  </item>
                  <item>
                     <p>If <var>M</var> is on the preceding axis of <var>N</var> then <var>M1</var>
                        precedes <var>N0</var>.</p>
                  </item>
               </ulist>
               <p>The accumulator defines a (private) delta function <var>Δ</var>. The delta
                  function computes the value of the accumulator for one traversal event in terms of
                  its value for the previous traversal event. The function is defined as
                  follows:</p>
               <olist>
                  <item>
                     <p>The signature of <var>Δ</var> is <code>function ($old-value as T,
                           $event as map(*)) as T</code>, where <var>T</var> is the sequence type
                        declared in the <code>as</code> attribute of the accumulator
                        declaration;</p>
                  </item>
                  <item>
                     <p>The implementation of the function is equivalent to the following
                        algorithm:</p>
                     <olist>
                        <!--<item>
                           <p diff="del" at="S-bug27660">If there is an <code>applies-to</code>
                              pattern, and if <code>$event("node")</code> has no ancestor-or-self
                              node that matches this pattern, return <code>$old-value</code>.</p>
                        </item>-->
                        <item>
                           <p>Let <var>R</var> be the set of <elcode>xsl:accumulator-rule</elcode>
                              elements among the children of the accumulator declaration whose
                                 <code>phase</code> attribute equals <code>$event("phase")</code>
                              and whose <code>match</code> attribute is a <termref def="dt-pattern">pattern</termref> that matches <code>$event("node")</code></p>
                        </item>
                        <item>
                           <p>If <var>R</var> is empty, return <code>$old-value</code></p>
                        </item>
                        <item>
                           <p>Let <var>Q</var> be the <elcode>xsl:accumulator-rule</elcode> in
                                 <var>R</var> that is last in document order</p>
                        </item>
                        <item>
                           <p>Return the value of the expression in the <code>select</code>
                              attribute of <var>Q</var>, or the
                                 contained sequence constructor, evaluating this with a
                                 <termref def="dt-singleton-focus">singleton focus</termref> set to
                                 <code>$event("node")</code> and with a dynamic context that binds
                              the variable whose name is <code>$value</code> (in no namespace) to the value
                                 <code>$old-value</code>.</p>
                           <note>
                              <p>The argument names <code>old-value</code> and <code>event</code>
                                 are used here purely for definitional purposes; these names are not
                                 available for use within the <code>select</code> expression or contained sequence
                                    constructor.</p>
                           </note>
                        </item>
                     </olist>
                  </item>
               </olist>
               <p>For every node <var>N</var>, other than attribute and namespace nodes, the
                  accumulator defines a pre-descent value <var>B/N</var> and a post-descent value
                     <var>A/N</var> whose values are as follows:</p>
               <olist>
                  <item>
                     <p>Let <var>T</var> be the <termref def="dt-traversal">traversal</termref> of
                        the tree rooted at <code>fn:root(N)</code>.</p>
                  </item>
                  <item>
                     <p>Let <var>SB</var> be the subsequence of <var>T</var> starting at the first
                        event in <var>T</var> and ending with the start event for node <var>N</var>
                        (that is, the event <code>map{ "phase":"start", "node":N }</code>).</p>
                  </item>
                  <item>
                     <p>Let <var>SA</var> be the subsequence of <var>T</var> starting at the first
                        event in <var>T</var>, and ending with the  end event
                        for node <var>N</var> (that is, the event <code>map{ "phase":"end", "node":N
                           }</code>).</p>
                  </item>
                  <item>
                     <p>Let <var>Z</var> be the result of evaluating the expression contained in the
                           <code>initial-value</code> attribute of the
                           <elcode>xsl:accumulator</elcode> declaration, evaluated with a <termref def="dt-singleton-focus"/>
                           based on <code>root(N)</code>.</p>
                  </item>
                  <item>
                     <p>Then the pre-descent value <var>B/N</var> is the value of
                           <code>fn:fold-left(SB, Z, Δ)</code>, and the post-descent value
                           <var>A/N</var> is the value of <code>fn:fold-left(SA, Z,
                        Δ)</code>.</p>
                  </item>
               </olist>
            </div3>
            <div3 id="errors-in-accumulators">
               <head>Dynamic Errors in Accumulators</head>
               <p>If a dynamic error occurs when evaluating the <code>initial-value</code> expression
               of <elcode>xsl:accumulator</elcode>, or the <code>select</code> expression of <elcode>xsl:accumulator-rule</elcode>,
                  <phrase diff="add" at="A">or the sequence constructor contained in <elcode>xsl:accumulator-rule</elcode>, </phrase>
               then the error is signaled as an error from any subsequent call on <function>accumulator-before</function>
                  or <function>accumulator-after</function> that references the accumulator. If no such call on <function>accumulator-before</function>
                  or <function>accumulator-after</function> happens, then the error goes unreported.
               <phrase diff="add" at="A">[XSLT 3.0 Erratum E38, bug 30376].</phrase></p>
               
               <note><p>In the above rule, the phrase <term>subsequent call</term> is to be understood in terms of functional dependency; that is, a call to
                  <function>accumulator-before</function> or <function>accumulator-after</function> signals an error if the accumulator value at the node in question is
               functionally dependent on a computation that fails with a dynamic error.</p></note>
               
               <note><p>Particularly in the case of streamed accumulators, this may mean that the implementation has to “hold back” the error
               until the next time the accumulator is referenced, to give applications the opportunity to catch the error using <elcode>xsl:try</elcode>
               and <elcode>xsl:catch</elcode> in a predictable way.</p></note>
               
               <note><p>Errors that occur during the evaluation of the pattern in the <code>match</code> attribute of
               <elcode>xsl:accumulator-rule</elcode> are handled as described in <specref ref="pattern-errors"/>:
               specifically, the pattern does not match the relevant node, and no error is signaled.</p></note>

            </div3>
            <div3 id="func-accumulator-before">
               <head><?function fn:accumulator-before?></head>
            </div3> 
            <div3 id="func-accumulator-after">
               <head><?function fn:accumulator-after?></head>
            </div3>
            <div3 id="accumulators-visibility-and-overriding">
               <head>Importing of Accumulators</head>

               <p>If a <termref def="dt-package">package</termref> contains more than one
                     <elcode>xsl:accumulator</elcode> declaration with a particular name, then the
                  one with the highest <termref def="dt-import-precedence"/> is used.</p>

               <p>
                  <error spec="XT" type="static" class="SE" code="3350">
                     <p>It is a <termref def="dt-static-error">static error</termref> for a 
                        <termref def="dt-package">package</termref> to contain two or more 
                        <phrase diff="del" at="A">non-hidden</phrase><!-- Erratum E47, bug 30394 -->
                        accumulators with the same <termref def="dt-expanded-qname">expanded
                           QName</termref> and the same <termref def="dt-import-precedence">import
                           precedence</termref>, unless there is another accumulator with the same
                           <termref def="dt-expanded-qname">expanded QName</termref>, and a higher
                        import precedence.</p>
                  </error>
               </p>

               <p>Accumulators cannot be referenced from, or overridden
                  in, a different package from the one in which they are declared.</p>

               


            </div3>
            <div3 id="streamability-of-accumulators">
               <head>Streamability of Accumulators</head>

               <p>An accumulator is <termref def="dt-guaranteed-streamable"/> if
                  it satisfies all the following
                  conditions:</p>
               <olist>
                  <item>
                     <p>The <elcode>xsl:accumulator</elcode> declaration has the attribute
                           <code>streamable="yes"</code>.</p>
                  </item>
                  
                  <item>
                     <p>In every contained <elcode>xsl:accumulator-rule</elcode>, the <termref def="dt-pattern">pattern</termref> in the <code>match</code> attribute is
                        a <termref def="dt-motionless"/> pattern (see <specref ref="classifying-patterns"/>).</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-expression">expression</termref> in the
                           <code>initial-value</code> attribute is <termref def="dt-grounded"/> and
                           <termref def="dt-motionless"/>.</p>
                  </item>
                  <item>
                     <p>The <termref def="dt-expression">expression</termref> in the <code>select</code> attribute or contained
                           sequence constructor is <termref def="dt-grounded"/> and
                        <termref def="dt-motionless"/>.</p>
                  </item>

               </olist>


               <p>Specifying <code>streamable="yes"</code> on an
                     <elcode>xsl:accumulator</elcode> element declares an intent that the
                  accumulator should be streamable, either
                     because it is <termref def="dt-guaranteed-streamable"/>, or because it takes
                     advantage of streamability extensions offered by a particular
                     processor. The consequences of declaring the accumulator to be
                  streamable when it is not in fact guaranteed streamable depend on the conformance
                  level of the processor, and are explained in <specref ref="streamability-guarantees"/>.</p>



               <p>When an accumulator is declared to be streamable, the
                  stylesheet author must ensure that the accumulator function
                     <function>accumulator-after</function> is only called at appropriate points in
                  the processing, as explained in <specref ref="streamability-fn-accumulator-after"/>.</p>



            </div3>

            <div3 id="copying-accumulators">
               <head>Copying Accumulator Values</head>

               <p>When nodes (including streamed nodes) are copied using the
                     <function>snapshot</function> or <function>copy-of</function> functions, or
                  using the <elcode>xsl:copy-of</elcode> instruction with the attribute
                     <code>copy-accumulators="yes"</code>, then the pre-descent and post-descent
                  values of accumulators for that tree are not determined by traversing the tree as
                  described in <specref ref="accumulator-informal-rules"/> and <specref ref="accumulator-formal-rules"/>. Instead the values are the same as the values
                  on the corresponding nodes of the source tree. </p>
               <p>This applies also to the implicit invocation of the <function>snapshot</function>
                  function that happens during the evaluation of <elcode>xsl:merge</elcode>.</p>

               <p>If an accumulator is not applicable to a tree <var>S</var>, then it is also not
                  applicable to any tree formed by copying nodes from <var>S</var> using the above
                  methods.</p>

               <note>
                  <p>During streamed processing, accumulator values will typically be computed “on
                     the fly”; when the <function>copy-of</function> or
                        <function>snapshot</function> functions are applied to a streamed node, the
                     computed accumulator values for the streamed document will typically be
                     materialized and saved as part of the copy.</p>

                  <p>Accumulator values for a non-streamed document will often be computed lazily,
                     that is, they will not be computed unless and until they are needed. A call on
                        <function>copy-of</function> or <function>snapshot</function> on a
                     non-streamed document whose accumulator values have not yet been computed can
                     then be handled in a variety of ways. The implementation might interpret the
                     call on <function>copy-of</function> or <function>snapshot</function> as a
                     trigger causing the accumulator values to be computed; or it might retain a
                     link between the nodes of the copied tree and the nodes of the original tree,
                     so that a request for accumulator values on the copied tree can trigger
                     computation of accumulator values for the original tree. </p>
               </note>

            </div3>

            <div3 id="accumulator-examples">
               <head>Examples of Accumulators</head>

               <example>
                  <head>Remember the Title of a Document</head>
                  <p>Consider an XHTML document in which the title of the document is represented by
                     the content of a <code>title</code> element appearing as a child of the
                        <code>head</code> element, which in turn appears as a child of the
                        <code>html</code> element. Suppose that we want to process the document in
                     streaming mode, and that we want to avoid outputting the content of the
                        <code>h1</code> element if it is the same as the document title.</p>
                  <p>This can be achieved by remembering the value of the title in an accumulator
                     variable.</p>
                  <eg role="xslt-declaration" xml:space="preserve">
  &lt;xsl:accumulator name="firstTitle" as="xs:string?" initial-value="()" 
                                                     streamable="yes"&gt;
    &lt;xsl:accumulator-rule match="/html/head/title/text()" select="string(.)"/&gt;
  &lt;/xsl:accumulator&gt;
  </eg>
                  <p>Subsequently, while processing an <code>h1</code> element appearing later in
                     the document, the value can be referenced:</p>
                  <eg role="xslt-declaration" xml:space="preserve">
  &lt;xsl:template match="h1"&gt;
    &lt;xsl:variable name="firstTitle" select="accumulator-before('firstTitle')"/&gt;
    &lt;xsl:variable name="thisTitle" select="string(.)"/&gt;
    &lt;xsl:if test="$thisTitle ne $firstTitle"&gt;
      &lt;div class="heading-1"&gt;&lt;xsl:value-of select="$thisTitle"/&gt;&lt;/div&gt;
    &lt;/xsl:if&gt;
    &lt;/xsl:template&gt;</eg>

                  

               </example>

               <example>
                  <head>Keep a Word Count</head>
                  <p>Suppose that there is a requirement to output, at the end of the HTML rendition
                     of a document, a paragraph giving the total number of words in the
                     document.</p>
                  <p>An accumulator can be used to maintain a (crude) word count as follows:</p>
                  <eg role="xslt-declaration" xml:space="preserve">
  &lt;xsl:accumulator name="word-count" 
                   as="xs:integer" 
                   initial-value="0"&gt;
    &lt;xsl:accumulator-rule match="text()" 
         select="$value + count(tokenize(.))"/&gt;
  &lt;/xsl:accumulator&gt;
  </eg>
                  <p diff="del" at="A"><emph>Note: the call on <code>tokenize#1</code> relies on XPath 3.1</emph></p>
                  <p>The final value can be output at the end of the document:</p>
                  <eg role="xslt-declaration" xml:space="preserve">
   &lt;xsl:template match="/"&gt;
     &lt;xsl:apply-templates/&gt;
     &lt;p&gt;Word count: &lt;xsl:value-of select="accumulator-after('word-count')"/&gt;&lt;/p&gt;
   &lt;/xsl:template&gt;</eg>
               </example>

               <example>
                  <head>Output Hierarchic Section Numbers</head>
                  <p>Consider a document in which <code>section</code> elements are nested within
                        <code>section</code> elements to arbitrary depth, and there is a requirement
                     to render the document with hierarchic section numbers of the form
                        <code>3.5.1.4</code>.</p>

                  <p>The current section number can be maintained in an accumulator in the form of a
                     sequence of integers, managed as a stack. The number of integers represents the
                     current level of nesting, and the value of each integer represents the number
                     of preceding sibling sections encountered at that level. For convenience the
                     first item in the sequence represents the top of the stack.</p>

                  <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:accumulator name="section-nr" as="xs:integer*" 
                 initial-value="0"&gt;
  &lt;xsl:accumulator-rule match="section" phase="start" 
                 select="0, head($value)+1, tail($value)"/&gt;
  &lt;xsl:accumulator-rule match="section" phase="end" 
                 select="tail($value) (:pop:)"/&gt;
&lt;/xsl:accumulator&gt;  
</eg>

                  <p>To illustrate this, consider the values after processing a series of start and
                     end tags:</p>

                  <table class="data">
                     <caption>Example data illustrating the effect of parsing events on an accumulator</caption>
                     <thead>
                        <tr>
                           <th rowspan="1" colspan="1">events</th>
                           <th rowspan="1" colspan="1">accumulator value</th>
                           <th rowspan="1" colspan="1">required section number</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>0, 1</code></td>
                           <td rowspan="1" colspan="1">1</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>0, 1, 1</code></td>
                           <td rowspan="1" colspan="1">1.1</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>1, 1</code></td>
                           <td rowspan="1" colspan="1"> </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>0, 2, 1</code></td>
                           <td rowspan="1" colspan="1">1.2</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>2, 1</code></td>
                           <td rowspan="1" colspan="1"> </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>0, 3, 1</code></td>
                           <td rowspan="1" colspan="1">1.3</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>0, 1, 3, 1</code></td>
                           <td rowspan="1" colspan="1">1.3.1</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>1, 3, 1</code></td>
                           <td rowspan="1" colspan="1"> </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>0, 2, 3, 1</code></td>
                           <td rowspan="1" colspan="1">1.3.2</td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>2, 3, 1</code></td>
                           <td rowspan="1" colspan="1"> </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>3, 1</code></td>
                           <td rowspan="1" colspan="1"> </td>
                        </tr>
                        <tr>
                           <td rowspan="1" colspan="1"><code>&lt;/section&gt;</code></td>
                           <td rowspan="1" colspan="1"><code>1</code></td>
                           <td rowspan="1" colspan="1"> </td>
                        </tr>
                     </tbody>
                  </table>
                  <p>The section number for a section can thus be generated as:</p>
                  <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:template match="section"&gt;
  &lt;p&gt;
    &lt;xsl:value-of select="reverse(tail(accumulator-before('section-nr')))" 
                  separator="."/&gt;
  &lt;/p&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
                  </eg>

               </example>

               <example>
                  <head>Compute a Histogram showing the Number of Books, by Publisher</head>

                  <eg role="xslt-declaration" xml:space="preserve">
 &lt;xsl:accumulator name="histogram" as="map(xs:string, xs:integer)"
    initial-value="map{}"&gt;
    &lt;xsl:accumulator-rule match="book"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="map:contains($value, @publisher)"&gt;
          &lt;xsl:sequence select="map:put($value, string(@publisher), 
                                        $value(@publisher)+1)"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:sequence select="map:put($value, string(@publisher), 1)"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:accumulator-rule&gt;  
 &lt;/xsl:accumulator&gt;</eg>
                  <p>The <code>contained sequence constructor</code> is
                     evaluated with the variable <code>$value</code> set to the current value, and
                     with the context node as the node being visited.</p>

                  <note>
                     <p>In the two calls on <code>map:put()</code>, it is necessary to explicitly
                        convert <code>@publisher</code> to an <code>xs:string</code> value, because
                        this is the declared type of the keys in the result map. Relying on
                        atomization would produce keys of type <code>xs:untypedAtomic</code>, which
                        would not satisfy the declared type of the map.</p>
                  </note>

                  <p>The accumulated histogram might be displayed as
                     follows:</p>
                  <eg role="xslt-instruction" xml:space="preserve">
 &lt;xsl:source-document streamable="yes" href="booklist.xml"&gt;
   .....
   &lt;h1&gt;Number of books, by publisher&lt;/h1&gt;
   &lt;table&gt;
     &lt;thead&gt;
       &lt;th&gt;Publisher&lt;/th&gt;
       &lt;th&gt;Number of books&lt;/th&gt;
     &lt;/thead&gt;
     &lt;tbody&gt;
       &lt;xsl:variable name="histogram" select="accumulator-after('histogram')"/&gt;
       &lt;xsl:for-each select="map:keys($histogram)"&gt;
         &lt;tr&gt;
           &lt;td&gt;&lt;xsl:value-of select="."/&gt;&lt;/td&gt;
           &lt;td&gt;&lt;xsl:value-of select="$histogram(.)"/&gt;&lt;/td&gt;
         &lt;/tr&gt;
       &lt;/xsl:for-each&gt;
     &lt;/tbody&gt;
   &lt;/table&gt;
 &lt;/xsl:source-document&gt;</eg>
               </example>

            </div3>
         </div2>
         <div2 id="func-copy-of">
            <head><?function fn:copy-of?></head>
         </div2>
         <div2 id="func-snapshot">
            <head><?function fn:snapshot?></head>
         </div2>


      </div1>



      <div1 id="streamability">
         <head>Streamability</head>

         <p>This section contains rules that can be used to determine
            properties of <termref def="dt-construct">constructs</termref> in the <termref def="dt-stylesheet"/> — specifically, the <termref def="dt-posture"/> and
               <termref def="dt-sweep"/> of a construct — which enable the streamability of
            the stylesheet to be assessed.</p>

         <p>These properties are used to determine the streamability
            of:</p>

         <ulist>
            <item>
               <p><termref def="dt-template-rule">Template rules</termref>: see <specref ref="streamable-templates"/></p>
            </item>
            <item>
               <p>The <elcode>xsl:source-document</elcode> instruction: see <specref ref="source-document-instruction"/></p>
            </item>
            <item>
               <p><termref def="dt-attribute-set">Attribute sets</termref>: see <specref ref="streamability-of-attribute-sets"/></p>
            </item>
            <item>
               <p><termref def="dt-accumulator">Accumulators</termref>: see <specref ref="streamability-of-accumulators"/></p>
            </item>
            <item>
               <p><termref def="dt-stylesheet-function">Stylesheet functions</termref>: see <specref ref="streamable-stylesheet-functions"/></p>
            </item>
            <item>
               <p>The <elcode>xsl:merge</elcode> instruction: see <specref ref="streamable-merging"/></p>
            </item>
         </ulist>

         <p>In each case, the conditions for constructs to be <termref def="dt-guaranteed-streamable"/> are defined in terms of these properties. The result
            of this analysis in turn (see <specref ref="streamability-guarantees"/>) imposes rules
            on how the constructs are handled by processors that implement the <termref def="dt-streaming-feature"/>. The analysis has no effect on the behavior of
            processors that do not implement this feature.</p>

         <p>The analysis is relevant to constructs such as streamable template rules and the
               <elcode>xsl:source-document</elcode> instruction that process a single streamed input
            document. The <elcode>xsl:merge</elcode> instruction, which processes multiple streamed
            inputs, has its own rules.</p>

         <p>The rules in this section operate on the expression tree (more properly, construct tree)
            that is typically output by the XSLT and XPath parser. For the most part, the rules
            depend only on identifying the syntactic constructs that are present.</p>

         <p>The rules in this section generally consider each <termref def="dt-component">component</termref> in the stylesheet (and in the case of <termref def="dt-template-rule">template rules</termref>, each template rule) in isolation.
            The exception is that where a component contains references to other components (such as
            global variables, functions, or named templates), then information from the signature of
            the referenced component is sometimes used. This is invariably information that cannot
            be changed if a component is overridden in a different <termref def="dt-package">package</termref>. The analysis thus requires as a pre-condition that function calls
            and calls on named templates have been resolved to the extent that the corresponding
            function/template signature is known. </p>

         <p>The detailed way in which the construct tree is derived from the lexical form of the
            stylesheet is not described in this specification. There are many ways in which the tree
            can be optimized without affecting the result of the rules in this section: for example,
            a sequence constructor containing a single instruction can be replaced by that
            instruction, and a parenthesized expression can be replaced by its content.</p>

         <p><termdef id="dt-construct" term="construct">The term <term>construct</term> refers to
               the union of the following: a <termref def="dt-sequence-constructor"/>, an <termref def="dt-instruction">instruction</termref>, an <termref def="dt-attribute-set">attribute set</termref>, a <termref def="dt-value-template">value
                  template</termref>, an <termref def="dt-expression">expression</termref>, or a
                  <termref def="dt-pattern">pattern</termref>.</termdef></p>


         <p>These <termref def="dt-construct">constructs</termref> are classified into
               <term>construct kinds</term>: in particular, <termref def="dt-instruction">instructions</termref> are classified according to the name of the XSLT instruction,
            and <termref def="dt-expression">expressions</termref> are classified according to the
            most specific production in the XPath grammar that the expression satisfies. (This
            means, for example, that <code>2+2</code> is classified as an <code>AdditiveExpr</code>,
            rather than say as a <code>UnionExpr</code>; although it also satisfies the production
            rule for <code>UnionExpr</code>, <code>AdditiveExpr</code> is more specific.)</p>

         <p><termdef id="dt-operand-role" term="operand role">For every construct kind, there is a
               set of zero or more <term>operand roles</term>.</termdef> For example, an
               <code>AdditiveExpr</code> has two operand roles, referred to as the left-hand operand
            and the right-hand operand, while an <code>IfExpr</code> has three, referred to as the
            condition, the then-clause, and the else-clause. A function call with three arguments
            has three operand roles, called the first, second, and third arguments. The names of the
            operand roles for each construct kind are not formally listed, but should be clear from
            the context.</p>

         <p><termdef id="dt-operand" term="operand">In an actual instance of a construct, there will
               be a number of <term>operands</term>. Each operand is itself a <termref def="dt-construct"/>; the construct tree can be defined as the transitive relation
            between constructs and their operands.</termdef> Each operand is associated with exactly one of
            the operand roles for the construct type. There may be operand roles where the operand
            is optional (for example, the <code>separator</code> attribute of the
               <elcode>xsl:value-of</elcode> instruction), and there may be operand roles that can
            be occupied by multiple operands (for example, the <code>xsl:when/@test</code> condition
            in <elcode>xsl:choose</elcode>, or the arguments of the <xfunction>concat</xfunction>
            function).</p>

         <p>Operand roles have a number of properties used in the analysis:</p>

         <ulist>
            <item>
               <p>The <termref def="dt-required-type"/> of the <termref def="dt-operand"/>. This is
                  explicit in the case of function calls (the required type is defined in the
                  function signature of the corresponding function). In other cases it is implicit
                  in the detailed rules for the construct in question. In practice streamability
                  analysis makes only modest use of the required type; the main case where it is
                  relevant is for a function or template call, where knowing that the required type
                  is atomic enables the inference that the <termref def="dt-operand-usage"/> for a
                  supplied node is <termref def="dt-absorption"/>.</p>
            </item>
            <item>
               <p><termdef id="dt-operand-usage" term="operand usage">The <term>operand
                     usage</term>. This gives information, in the case where the operand value
                     contains nodes, about how those nodes are used. The operand usage takes one of
                     the values <termref def="dt-absorption"/>, <termref def="dt-inspection"/>,
                        <termref def="dt-transmission"/>, or <termref def="dt-navigation"/>.</termdef>
                  The meanings of these terms are explained in <specref ref="operand-roles"/>. If the required type of the <termref def="dt-operand"/>
                  does not permit nodes to be supplied (for example
                     because the required type is a function item or a map), then the
                  operand usage is <termref def="dt-inspection"/>, because the only run-time
                  operation on a supplied node will be to inspect it, discover it is a node, and
                  raise a type error.</p>
               <p>In the particular case where the required type is atomic, and any supplied nodes
                  are atomized, the operand usage will be <termref def="dt-absorption"/>, because
                     <termref def="dt-atomization"/> is a special case of absorption.</p>
            </item>
            <item>
               <p><termdef id="dt-higher-order-operand" term="higher-order operand">Whether or not
                     the <termref def="dt-operand"/> is <term>higher-order</term>. For this purpose
                     an operand <var>O</var> of a construct <var>C</var> is higher-order if the
                     semantics of <var>C</var> potentially require <var>O</var> to be evaluated more
                     than once during a single evaluation of <var>C</var>.</termdef> More
                  specifically, <var>O</var> is a <term>higher-order</term> operand of <var>C</var>
                  if any of the following conditions is true:</p>
               <ulist>
                  <item>
                     <p>The <termref def="dt-context-item"/> for evaluation of <var>O</var> is
                        different from the context item for evaluation of <var>C</var>.</p>
                  </item>
                  <item>
                     <p><var>C</var> is an <termref def="dt-instruction"/> and <var>O</var> is a
                           <termref def="dt-pattern"/> (as with the <code>from</code> and
                           <code>count</code> attributes of <elcode>xsl:number</elcode>, and the
                           <code>group-starting-with</code> and <code>group-ending-with</code>
                        attributes of <elcode>xsl:for-each-group</elcode>).</p>
                  </item>
                  <item>
                     <p><var>C</var> is an XPath <code>for</code>, <code>some</code>, or
                           <code>every</code> expression and <var>O</var> is the expression in its
                           <code>return</code> or <code>satisfies</code> clause.</p>
                  </item>
                  <item>
                     <p><var>C</var> is an inline function declaration and <var>O</var> is the
                        expression in its body.</p>
                  </item>
               </ulist>
            </item>
         </ulist>
         
         <note><p>There is one known case where this definition makes
         an operand higher-order even though it is only evaluated once: specifically, the sequence
         constructor contained in the body of an <elcode>xsl:copy</elcode> instruction that has a 
            <code>select</code> attribute. See <specref ref="streamability-xsl-copy"/> for further details.</p></note>

         <p><termdef id="dt-choice-operand-group" term="choice operand group">For some construct
               kinds, one or more operand roles may be defined to form a <term>choice operand
                  group</term>. This concept is used where it is known that <termref def="dt-operand">operands</termref> are mutually exclusive (for example the
                  <code>then</code> and <code>else</code> clauses in a conditional
               expression).</termdef></p>

         <p><termdef id="dt-combined-posture" term="combined posture" open="true">The
                  <term>combined posture</term> of a <termref def="dt-choice-operand-group"/> is
               determined by the <termref def="dt-posture">postures</termref> of the <termref def="dt-operand">operands</termref> in the group (the <term>operand postures</term>), and is the first of
               the following that applies:</termdef></p>

         <olist>
            <item>
               <p>If any of the operand postures is
                     <termref def="dt-roaming"/>, then the combined posture is <termref def="dt-roaming"/>.</p>
            </item>
            <item>
               <p>If all of the operand postures are
                     <termref def="dt-grounded"/>, then the combined posture is <termref def="dt-grounded"/>.</p>
            </item>
            <item>
               <p>If one or more of the operand postures
                  is <termref def="dt-climbing"/> and the remainder (if any) are <termref def="dt-grounded"/>, then the combined posture is <termref def="dt-climbing"/>.</p>
            </item>
            <item>
               <p>If one or more of the operand postures
                  is <termref def="dt-striding"/> and the remainder (if any) are <termref def="dt-grounded"/>, then the combined posture is <termref def="dt-striding"/>.</p>
            </item>
            <item>
               <p>If one or more of the operand postures
                  is <termref def="dt-crawling"/> and each of the
                     remainder (if any) is either <termref def="dt-striding"/> or <termref def="dt-grounded"/>, then the combined posture is <termref def="dt-crawling"/>.</p>
            </item>
            <item>
               <p>Otherwise (for example, if the group includes both an operand with <termref def="dt-climbing"/> posture and one with <termref def="dt-crawling"/> posture),
                  the combined posture is <termref def="dt-roaming"/>. </p>
            </item>
         </olist>
         <p role="closetermdef"/>

         <p><termdef id="dt-type-determined-usage" term="type-determined usage">The
                  <term>type-determined usage</term> of an <termref def="dt-operand"/> is as
               follows: if the required type (ignoring occurrence indicator) is
                  <code>function(*)</code> or a subtype thereof, then <termref def="dt-inspection"/>; if the required type (ignoring occurrence indicator) is an atomic or union type, then <termref def="dt-absorption"/>; otherwise <termref def="dt-navigation"/>.</termdef></p>

         <p><termdef id="dt-type-adjusted-posture-and-sweep" term="type-adjusted posture and sweep">The <term>type-adjusted posture and
                  sweep</term> of a construct <var>C</var>, with respect to a type <var>T</var>, are
               the <termref def="dt-posture"/> and <termref def="dt-sweep"/> established by applying
               the <termref def="dt-general-streamability-rules"/> to a construct <var>D</var> whose
               single operand is the construct <var>C</var>, where the <termref def="dt-operand-usage"/> of <var>C</var> in <var>D</var> is the <termref def="dt-type-determined-usage"/> based on the required type
               <var>T</var>.</termdef></p>

         <note>
            <p>In effect, the type-adjusted posture and sweep are the posture and sweep of the
               implicit expression formed to apply the <termref def="dt-coercion-rules"/>
               to the argument of a function or template call, or to the result of a function or
               template, given knowledge of the required type. For example, an expression such as
                  <code>discount</code> in the function call <code>abs(discount)</code>, which would
               otherwise be <termref def="dt-striding"/> and <termref def="dt-consuming"/>, becomes
                  <termref def="dt-grounded"/> and <termref def="dt-consuming"/> because of the
               implicit atomization triggered by the coercion rules.</p>
         </note>

         <p>The process of determining whether a construct is streamable reduces to determining
            properties of the constructs in the construct tree. The properties in question (which
            are described in greater detail in subsequent sections) are:</p>

         <olist>
            <item>
               <p>The <term>static type</term> of the construct. When the construct is evaluated,
                  its value will always be an instance of this type. The value is a <termref def="dt-utype"/>; although type
                  inferencing is capable of determining information about the cardinality as well as
                  the item type, the streamability analysis makes no use of this.</p>
            </item>
            <item>
               <p>The <term>context item type</term>: that is, the static type of the <termref def="dt-context-item"/> potentially used as input to the construct. When the
                  construct is evaluated, the context item used to evaluate the construct (if it is
                  used at all) will be an instance of this type.</p>
            </item>
            <item>
               <p><termdef id="dt-posture" term="posture">The <term>posture</term> of the
                     expression. This captures information about the way in which the streamed input
                     document is positioned on return from evaluating the construct. The posture
                     takes one of the values <termref def="dt-climbing"/>, <termref def="dt-striding"/>, <termref def="dt-crawling"/>, <termref def="dt-roaming"/>, or <termref def="dt-grounded"/>.</termdef> The meanings of these terms are
                  explained in <specref ref="posture"/>.</p>
            </item>
            <item>
               <p><termdef id="dt-context-posture" term="context posture">The <term>context
                        posture</term>. This captures information about how the <termref def="dt-context-item"/> used as input to the construct is positioned
                     relative to the streamed input. The <term>context posture</term> of a construct
                     C is the posture of the expression whose value sets the focus for the
                     evaluation of C.</termdef> Rules for determining the
                     context posture of any construct are given in <specref ref="determining-context-posture"/>.</p>
            </item>
            <item>
               <p>The <term>sweep</term> of the construct. The sweep of a construct gives
                  information about whether and how the evaluation of the construct changes the
                  current position in a streamed input document. The possible values are <termref def="dt-motionless"/>, <termref def="dt-consuming"/>, and <termref def="dt-free-ranging"/>. These terms are explained in <specref ref="sweep"/>.</p>
            </item>
         </olist>

         <p>The values of these properties for a top-level construct such as the body of a template
            rule determine whether the construct is streamable.</p>

         <p>The values of these properties are not independent. For example, if the static type is
            atomic, then the posture will always be grounded; if the sweep is free-ranging, then the
            posture will always be roaming.</p>

         <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of a
               <termref def="dt-construct"/>, as defined above, are calculated in relation to a
            particular streamed input document. If there is more than one streamed input document,
            then a construct that is motionless with respect to one streamed input might be
            consuming with respect to another. In practice, though, the streamability analysis is
            only ever concerned with one particular streamed input at a time; constructs are
            analyzed in relation to the innermost containing <elcode>xsl:template</elcode>,
               <elcode>xsl:source-document</elcode>, <elcode>xsl:accumulator</elcode>, or
               <elcode>xsl:merge-source</elcode> element, and this container implicitly defines the
            streamed input document that is relevant. The streamed input document affecting a
            construct is always the document that contains the context item for evaluation of that
               construct.</p>

         

         <div2 id="determining-static-type">
            <head>Determining the Static Type of a Construct</head>

            <p><termdef id="dt-static-type" term="static type">The <term>static type</term> of a
                     <termref def="dt-construct">construct</termref> is such that all values
                  produced by evaluating the construct will conform to that type. The static type of
                  a construct is a <termref def="dt-utype"/>.</termdef></p>

            <p><termdef id="dt-utype" term="U-type">A <term>U-type</term> is a set of <termref def="dt-fundamental-item-type">fundamental item types</termref>.</termdef></p>

            <p><termdef id="dt-fundamental-item-type" term="fundamental item type">There are 28
                     <term>fundamental item types</term>: the 7 node kinds defined in <bibref ref="xpath-datamodel-30"/> (element, attribute, etc.), the 19 primitive atomic
                  types defined in <bibref ref="xmlschema-2"/>, plus the types
                     <code>function(*)</code> and <code>xs:untypedAtomic</code>. The fundamental
                  item types are disjoint, and every item is an instance of exactly one of
                  them.</termdef></p>

            <p>More specifically, the fundamental item types are:</p>

            <ulist>
               <item>
                  <p><code>document-node()</code>, <code>element()</code>, <code>attribute()</code>,
                        <code>text()</code>, <code>comment()</code>,
                        <code>processing-instruction()</code>, <code>namespace-node()</code>;</p>
               </item>
               <item>
                  <p><code>xs:boolean</code>, <code>xs:double</code>, <code>xs:decimal</code>,
                        <code>xs:float</code>, <code>xs:string</code>, <code>xs:dateTime</code>,
                        <code>xs:date</code>, <code>xs:time</code>, <code>xs:gYear</code>,
                        <code>xs:gYearMonth</code>, <code>xs:gMonth</code>,
                        <code>xs:gMonthDay</code>, <code>xs:gDay</code>, <code>xs:anyURI</code>,
                        <code>xs:QName</code>, <code>xs:NOTATION</code>,
                        <code>xs:base64Binary</code>, <code>xs:hexBinary</code>,
                        <code>xs:duration</code></p>
               </item>
               <item>
                  <p><code>function(*)</code></p>
               </item>
               <item>
                  <p><code>xs:untypedAtomic</code></p>
               </item>
            </ulist>

            <p>A value <var>V</var> (in general, a sequence) is an instance of a <termref def="dt-utype"/>
               <var>U</var> if every item in <var>V</var> is an instance of one of the <termref def="dt-fundamental-item-type">fundamental item types</termref> in <var>U</var>.
               For example, the sequence <code>(23, "Paris")</code> is an instance of the U-type
                  <code>U{xs:string, xs:decimal, xs:date}</code> because both items in the sequence
               belong to item types in this U-type. </p>

            <note>
               <p>It is a consequence of this rule that the empty sequence, <code>()</code>, is an
                  instance of every U-type.</p>
            </note>

            <p>A <termref def="dt-utype"/> is represented in this specification using the notation
                  <var>U{t1, t2, t3, ...}</var> where <code>t1, t2, t3, ...</code> are the names of
               the fundamental item types making up the U-type. The item types are represented using
               the syntax of the <xnt spec="XP40" ref="prod-xpath40-ItemType">ItemType</xnt>
               production in XPath, for example <code>comment()</code> or <code>xs:date</code>.</p>

            <note>
               <p>This means that the order of <code>t1, t2, t3, ...</code> has no significance:
                     <var>U{A, B}</var> is the same U-type as <var>U{B, A}</var>.</p>
            </note>

            <p>The smallest U-type is denoted <var>U{}</var>. This is not an empty type; like every
               other U-type, it has the empty sequence <code>()</code> as an instance. For
               convenience, the universal U-type is represented as <var>U{*}</var>; the U-type
               corresponding to the set of 7 node kinds is written <var>U{N}</var>, and the U-type
               corresponding to all atomic values (that is, the 19 primitive atomic types plus
                  <code>xs:untypedAtomic</code>) is written <var>U{A}</var>.</p>

            <p>Because a <termref def="dt-utype"/> is a set, the operations of union, intersection,
               and difference are defined over U-types, and the result is always a U-type. If one
               U-type <var>U</var> is a subset of another U-type <var>V</var>, then <var>U</var> is
               said to be a subtype of <var>V</var>, and <var>V</var> is said to be a supertype of
                  <var>U</var>.</p>

            <p>In some cases the inference of a <termref def="dt-static-type"/> depends on the
               declared types of variables or functions. Since declared types use the
               <termref def="dt-sequence-type"/> 
               syntax, there is therefore a mapping defined from
               SequenceTypes to U-types. The mapping is as follows:</p>

            <ulist>
               <item>
                  <p>The <termref def="dt-sequence-type"/> 
                     <code>empty-sequence()</code> maps to <var>U{}</var></p>
               </item>
               <item>
                  <p>For every other <termref def="dt-sequence-type"/>, 
                     the mapping depends only on the item type and
                     ignores the occurrence indicator. The mapping from item types is as
                     follows:</p>
                  <ulist>
                     <item>
                        <p><code>item()</code> maps to <var>U{*}</var></p>
                     </item>
                     <item>
                        <p><code>AnyKindTest</code> (<code>node()</code>) maps to
                           <var>U{N}</var></p>
                     </item>
                     <item>
                        <p><code>DocumentTest</code> maps to <var>U{document-node()}</var></p>
                     </item>
                     <item>
                        <p><code>ElementTest</code> and <code>SchemaElementTest</code> map to
                              <var>U{element()}</var></p>
                     </item>
                     <item>
                        <p><code>AttributeTest</code> and <code>SchemaAttributeTest</code> map to
                              <var>U{attribute()}</var></p>
                     </item>
                     <item>
                        <p><code>TextTest</code> maps to <var>U{text()}</var></p>
                     </item>
                     <item>
                        <p><code>CommentTest</code> maps to <var>U{comment()}</var></p>
                     </item>
                     <item>
                        <p><code>PITest</code> maps to <var>U{processing-instruction()}</var></p>
                     </item>
                     <item>
                        <p><code>NamespaceNodeTest</code> maps to <var>U{namespace-node()}</var></p>
                     </item>
                     <item>
                        <p><code>FunctionTest</code>, <code>MapTest</code>, 
                           and <phrase diff="del" at="A">(if the XPath 3.1 feature
                           is implemented) </phrase><code>ArrayTest</code> 
                           map to <var>U{function(*)}</var></p>
                     </item>
                     <item>
                        <p>The QName <code>xs:error</code> maps to <var>U{}</var></p>
                     </item>
                     <item>
                        <p>A QName <var>Q</var> representing an atomic type that is a fundamental
                           item type maps to <var>U{Q}</var></p>
                     </item>
                     <item>
                        <p>A QName <var>Q</var> representing an atomic type derived from a
                           fundamental item type <var>F</var> maps to <var>U{F}</var></p>
                     </item>
                     <item>
                        <p>A QName <var>Q</var> representing a pure union type maps to a U-type
                           containing the fundamental item types present in the transitive
                           membership of the union, or from which the transitive members of the
                           union are derived.</p>
                     </item>
                  </ulist>
               </item>
            </ulist>




            <p>Although all constructs have a <termref def="dt-static-type"/>, the streamability
               analysis only needs to know the static type of XPath expressions, so the rules here
               are largely confined to that case. For <termref def="dt-pattern">patterns</termref>, the <termref def="dt-static-type"/> is
                  deemed to be <var>U{xs:boolean}</var>, reflecting the fact that a pattern is
                  essentially a function that can be applied to items to deliver a true or false
                  (matching or non-matching) result.
               For constructs other than <termref def="dt-expression">expressions</termref>
                  and <termref def="dt-pattern">patterns</termref>, the <termref def="dt-static-type"/> for the
                  purpose of streamability analysis is taken as <var>U{*}</var>.</p>

            <p>The rules given here are deliberately simple. Implementations may well be able to
               compute a more precise <termref def="dt-static-type"/>, but this will rarely be
               useful for streamability analysis. The item type for each kind of XPath expression is
               determined by the rules below. In the first column, numbers in square brackets are
               production numbers from the XPath 3.0 and XPath 3.1 
                  specifications respectively. In the
                  second column, the <term>Proforma</term> uses an informal notation used both to
                  provide a reminder of the syntax of the construct in question, and to attach
                  labels to its operand roles so that they can be referred to in the text of the
                  third column.</p>

            <table class="data">
               <caption>Inferring a Static Type for XPath 3.0 Expressions</caption>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Construct</th>
                     <th rowspan="1" colspan="1">Proforma</th>
                     <th rowspan="1" colspan="1">Static Type</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td rowspan="1" colspan="1">Expr [6,6] </td>
                     <td rowspan="1" colspan="1"><code>E,F</code></td>
                     <td rowspan="1" colspan="1">the union of the static types of E and F</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">ForExpr [8,8] </td>
                     <td rowspan="1" colspan="1"><code>for $x in S return E</code></td>
                     <td rowspan="1" colspan="1">the static type of E</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">LetExpr [11,11] </td>
                     <td rowspan="1" colspan="1"><code>let $x := S return E</code></td>
                     <td rowspan="1" colspan="1">the static type of E</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">QuantifiedExpr [14,14]</td>
                     <td rowspan="1" colspan="1"><code>some|every $x in S satisfies C</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:boolean}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">IfExpr [15,15] </td>
                     <td rowspan="1" colspan="1"><code>if (C) then T else E</code></td>
                     <td rowspan="1" colspan="1">the union of the static types of T and E</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">OrExpr [16,16]</td>
                     <td rowspan="1" colspan="1"><code>E or F</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:boolean}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">AndExpr [17,17]</td>
                     <td rowspan="1" colspan="1"><code>E and F</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:boolean}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">ComparisonExpr [18,18]</td>
                     <td rowspan="1" colspan="1"><code>E = F, E eq F, E is F</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:boolean}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">StringConcatExpr [19,19]</td>
                     <td rowspan="1" colspan="1"><code>E || F</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:string}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">RangeExpr [20,20]</td>
                     <td rowspan="1" colspan="1"><code>E to F</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:decimal}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">AdditiveExpr [21,21]</td>
                     <td rowspan="1" colspan="1"><code>E + F</code></td>
                     <td rowspan="1" colspan="1"><var>U{A}</var>. But if the expression
                           is a predicate (that is, if it appears between square brackets in a
                           filter expression or axis step), then <var>U{xs:decimal, xs:double,
                              xs:float}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">MultiplicativeExpr [22,22]</td>
                     <td rowspan="1" colspan="1"><code>E * F</code></td>
                     <td rowspan="1" colspan="1"><var>U{A}</var>. But if the expression
                           is a predicate (that is, if it appears between square brackets in a
                           filter expression or axis step), then <var>U{xs:decimal, xs:double,
                              xs:float}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">UnionExpr [23,23] </td>
                     <td rowspan="1" colspan="1"><code>E | F</code></td>
                     <td rowspan="1" colspan="1">the union of the static types of E and F</td>
                  </tr>
                  <tr>
                     <td rowspan="2" colspan="1">IntersectExceptExpr [24,24] </td>
                     <td rowspan="1" colspan="1"><code>E intersect F</code></td>
                     <td rowspan="1" colspan="1">the intersection of the static types of E and F</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1"><code>E except F</code></td>
                     <td rowspan="1" colspan="1">the static type of E</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">InstanceOfExpr [25,25]</td>
                     <td rowspan="1" colspan="1"><code>E instance of T</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:boolean}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">TreatExpr [26,26]</td>
                     <td rowspan="1" colspan="1"><code>E treat as T</code></td>
                     <td rowspan="1" colspan="1">the U-type corresponding to the SequenceType T</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">CastableExpr [27,27]</td>
                     <td rowspan="1" colspan="1"><code>E castable as T</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:boolean}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">CastExpr [28,28] </td>
                     <td rowspan="1" colspan="1"><code>E cast as T</code></td>
                     <td rowspan="1" colspan="1">if T is an atomic or pure union type, the corresponding U-type. Otherwise,
                        for example if T is a list type, <var>U{A}</var>.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">UnaryExpr [29,30]</td>
                     <td rowspan="1" colspan="1"><code>-N</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:decimal, xs:double, xs:float}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">SimpleMapExpr [34,35] </td>
                     <td rowspan="1" colspan="1"><code>E ! F</code></td>
                     <td rowspan="1" colspan="1">the static type of F</td>
                  </tr>
                  <tr>
                     <td rowspan="3" colspan="1">PathExpr [35,36] </td>
                     <td rowspan="1" colspan="1"><code>/</code></td>
                     <td rowspan="1" colspan="1"><var>U{document-node()}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1"><code>/P</code></td>
                     <td rowspan="1" colspan="1">the static type of P</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1"><code>//P</code></td>
                     <td rowspan="1" colspan="1">the static type of P</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">RelativePathExpr [36,37] </td>
                     <td rowspan="1" colspan="1"><code>P/Q, P//Q</code></td>
                     <td rowspan="1" colspan="1">the static type of Q</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">AxisStep [38,39] </td>
                     <td rowspan="1" colspan="1"><code>E[P]</code></td>
                     <td rowspan="1" colspan="1">the static type of E: see <specref ref="static-type-of-steps"/></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">ForwardStep [39,40], ReverseStep [42,43]</td>
                     <td rowspan="1" colspan="1"><code>Axis::NodeTest</code></td>
                     <td rowspan="1" colspan="1">See <specref ref="static-type-of-steps"/></td>
                  </tr>
                  <tr>
                     <td rowspan="2" colspan="1">PostfixExpr [48,49]</td>
                     <td rowspan="1" colspan="1">Filter Expression <code>E[P]</code></td>
                     <td rowspan="1" colspan="1">the static type of E</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Dynamic Function Call <code>F(X, Y)</code></td>
                     <td rowspan="1" colspan="1"><var>U{*}</var>, unless ancillary information is available about the
                        function signature of F: see below.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Literal [53,57]</td>
                     <td rowspan="1" colspan="1"><code>"pH"</code>, <code>93.7</code></td>
                     <td rowspan="1" colspan="1"><var>U{xs:string}</var>, <var>U{xs:decimal}</var>, or
                           <var>U{xs:double}</var>, depending on the form of the literal</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">VarRef [55,59]</td>
                     <td rowspan="1" colspan="1"><code>$V</code></td>
                     <td rowspan="1" colspan="1">For a variable declared using <elcode>xsl:variable</elcode> or
                           <elcode>xsl:param</elcode>, and for parameters of inline function
                        expressions: the declared type of the variable, defaulting to
                           <var>U{*}</var>. For variables declared using <code>for</code>,
                           <code>let</code>, <code>some</code>, and <code>every</code> expressions:
                        the static type of the expression to which the variable is bound.</td>
                  </tr>
                  <tr>
                     <td rowspan="2" colspan="1">ParenthesizedExpr [57,61]</td>
                     <td rowspan="1" colspan="1"><code>(E)</code></td>
                     <td rowspan="1" colspan="1">the type of E</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1"><code>()</code></td>
                     <td rowspan="1" colspan="1"><var>U{}</var> (a type whose only instance is the empty sequence)</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">ContextItemExpr [58,62]</td>
                     <td rowspan="1" colspan="1"><code>.</code></td>
                     <td rowspan="1" colspan="1">the context item type: see below</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">FunctionCall [59,63]</td>
                     <td rowspan="1" colspan="1"><code>F(X, Y)</code></td>
                     <td rowspan="1" colspan="1">In general: the U-type corresponding to
                        the declared result type of function <var>F</var>. But:
                        <ulist>
                           <item><p>If one or more of
                              the arguments to the function have operand usage <termref def="dt-transmission"/>, then the intersection of the U-type
                              corresponding to the declared result type with the union of the static
                              types of the arguments having usage transmission. (For example, the
                              static type of the function call <code>head(//text())</code> is
                              <var>U{text()}</var>.)</p></item>
                           <item><p>Special rules apply to the
                           <function>current</function> function: see <specref ref="static-type-of-current-function"/>.</p></item>
                        </ulist></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">NamedFunctionRef [63,67]</td>
                     <td rowspan="1" colspan="1"><code>F#n</code></td>
                     <td rowspan="1" colspan="1"><var>U{function(*)}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">InlineFunctionExpr [64,68] </td>
                     <td rowspan="1" colspan="1"><code>function(P) {E}</code></td>
                     <td rowspan="1" colspan="1"><var>U{function(*)}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">MapConstructor [,69]</td>
                     <td rowspan="1" colspan="1"><code>map{"A":E, "B":F}</code></td>
                     <td rowspan="1" colspan="1"><var>U{function(*)}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Postfix Lookup [,49]</td>
                     <td rowspan="1" colspan="1"><code>E ? K</code></td>
                     <td rowspan="1" colspan="1">If the type of <var>E</var> is a map type <code>map(K, V)</code> or an
                        array type <code>array(V)</code>, then the U-type corresponding to the item
                        type of <var>V</var>; otherwise <var>U{*}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">(Unary) Lookup [,53]</td>
                     <td rowspan="1" colspan="1"><code>? K</code></td>
                     <td rowspan="1" colspan="1">If the context item type is a map type <code>map(K, V)</code> or an array
                        type <code>array(V)</code>, then the U-type corresponding to the item type
                        of <var>V</var>; otherwise <var>U{*}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">ArrowExpr [,29]</td>
                     <td rowspan="1" colspan="1"><code>X =&gt; F(Y, Z)</code></td>
                     <td rowspan="1" colspan="1">The static type of the equivalent static or dynamic function call 
                        <code>F(X, Y, Z)</code></td>
                  </tr>                 
                  <tr>
                     <td rowspan="1" colspan="1">SquareArrayConstructor [,74]</td>
                     <td rowspan="1" colspan="1"><code>[X, Y, ...]</code></td>
                     <td rowspan="1" colspan="1"><var>U{function(*)}</var></td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">CurlyArrayConstructor [,75]</td>
                     <td rowspan="1" colspan="1"><code>array{X, Y, ...}</code></td>
                     <td rowspan="1" colspan="1"><var>U{function(*)}</var></td>
                  </tr>
               </tbody>
            </table>

            <p>Where the <termref def="dt-static-type"/> of an expression is
                  <var>U{function(*)}</var>, it is useful to retain additional information:
               specifically, the signature of the function. This may be regarded as information
               ancillary to the U-type of the expression; it does not play any role in operations
               such as testing whether one U-type is a subtype of another, or forming the union of
               two U-types. This ancillary information is available for a
                  <code>NamedFunctionRef</code>, for an <code>InlineFunctionExpr</code>, for a
                  <code>MapConstructor</code>, for a <code>FunctionCall</code> whose static type is
                  <var>U{function(*)}</var>, and for a <code>VarRef</code> if the variable is bound
               to any of the forgoing, or if it has a declared type corresponding to
                  <var>U{function(*)}</var>.</p>

            <note>
               <p>The special case type inference used for an <code>AdditiveExpr</code> or
                     <code>MultiplicativeExpr</code> appearing as a predicate is possible because if
                  an arithmetic operation within a predicate produces any other result, for example
                  an <code>xs:duration</code> or <code>xs:dateTime</code>, this would cause a type
                  error (on the grounds that an <code>xs:duration</code> or <code>xs:dateTime</code>
                  has no effective boolean value), and static type inference only needs to consider
                  the type of non-error results. The benefit of this special rule is that filter
                  expressions such as <code>/descendant::section[$i + 1]</code> can be recognized as
                  returning a singleton, and therefore as being <termref def="dt-striding"/>, even
                  if the type of <code>$i</code> is unknown.</p>
            </note>
            
            <div3 id="static-type-of-steps">
               <head>Static Type of an Axis Step</head>
               
               <p>An <code>AxisStep</code> consists of either a <code>ForwardStep</code> or <code>ReverseStep</code>
               followed by zero or more predicates. The predicates have no effect on the inferred type of the
               <code>AxisStep</code>.</p>
               
               <p>The static type of an abbreviated step is the static type of its expansion, for example the
               static type of <code>@*</code> is the same as the static type of <code>attribute::*</code>.</p>
               
               <p>Both the constructs <code>ForwardStep</code> or <code>ReverseStep</code>, in their
                  unabbreviated form, are written as <code>Axis::NodeTest</code>. The static type depends
               on both the <code>Axis</code> and the <code>NodeTest</code>, and also on the
                  <termref def="dt-context-item-type"/>, determined as described in <specref ref="determining-context-item-type"/>.</p>
               
               <p>If the <termref def="dt-context-item-type"/> has an empty intersection with <code>U{N}</code>
                  (that is, if the context item type cannot be a node), then evaluation of the <code>AxisStep</code>
                  will always fail; it is permissible to raise a type error statically in this case, but for the
                  sake of the analysis, the static type of the <code>AxisStep</code> can be taken as <code>U{}</code>.
                  In other cases, let <var>CIT</var> be the intersection of the <termref def="dt-context-item-type"/>
                   with <code>U{N}</code>.</p>
               
               <p>Let <var>K(A, CIT)</var> be the set of <term>reachable node kinds</term> given an axis <var>A</var> 
                  (a <termref def="dt-utype"/>) as defined by the following table: </p>
                  

               <table>
                  <thead>
                     <tr>
                        <th rowspan="1" colspan="1">Axis</th>
                        <th rowspan="1" colspan="1">Reachable Node Kinds</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td rowspan="1" colspan="1">self</td>
                        <td rowspan="1" colspan="1"><var>CIT</var></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">attribute</td>
                        <td rowspan="1" colspan="1">if <var>CIT</var> includes <code>U{element()}</code> then <code>U{attribute()}</code> else <code>U{}</code></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">namespace</td>
                        <td rowspan="1" colspan="1">if <var>CIT</var> includes <code>U{element()}</code> then <code>U{namespace-node()}</code> else <code>U{}</code></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">child, descendant</td>
                        <td rowspan="1" colspan="1">if <var>CIT</var> includes <code>U{element()}</code> or <code>U{document-node()}</code> then 
                           <code>U{element(), text(), comment(), processing-instruction()}</code> else <code>U{}</code></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">following-sibling, preceding-sibling, following, preceding</td>
                        <td rowspan="1" colspan="1">if <var>CIT</var> is <code>U{document-node()}</code> then <code>U{}</code> else
                           <code>U{element(), text(), comment(), processing-instruction()}</code></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">parent, ancestor</td>
                        <td rowspan="1" colspan="1">if <var>CIT</var> is <code>U{document-node()}</code> then <code>U{}</code> else
                           <code>U{element(), document-node()}</code> </td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">ancestor-or-self</td>
                        <td rowspan="1" colspan="1">the union of <var>K(ancestor, CIT)</var> and <var>CIT</var></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">descendant-or-self</td>
                        <td rowspan="1" colspan="1">the union of <var>K(descendant, CIT)</var> and <var>CIT</var></td>
                     </tr>
                  </tbody>
               </table>
               
               <p>Let <code>T(NT)</code> be the set of node kinds that are capable of satisfying a <code>NodeTest</code> <var>NT</var>,
               defined by the following table:</p>
               
               <table>
                  <thead>
                     <tr>
                        <th rowspan="1" colspan="1">NodeTest</th>
                        <th rowspan="1" colspan="1">Possible Node Kinds</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td rowspan="1" colspan="1"><code>AnyKindTest</code> (that is, <code>node()</code>)</td>
                        <td rowspan="1" colspan="1"><var>U{N}</var> (that is, any node)</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Any other <code>KindTest</code></td>
                        <td rowspan="1" colspan="1">The corresponding <termref def="dt-utype"/> (for example, <code>U{text()}</code> 
                           for the <code>KindTest</code> <code>text()</code>)</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">NameTest</td>
                        <td rowspan="1" colspan="1">The <termref def="dt-utype"/> corresponding to the principal node kind of the
                        specified axis</td>
                     </tr>
                  </tbody>
               </table>
               
               <p>The static type of an <code>AxisStep</code> with axis <var>A</var> and node test <code>NT</code>,
                  given a context item type <var>CIT</var>, is then defined to be the 
               intersection of <code>K(A, CIT)</code> with <code>T(NT)</code>.</p>
               
           
            </div3>
            <div3 id="static-type-of-current-function">
               <head>Static Type of a Call to <code>current</code></head>
            
               <p>The rules in this section define the static type of a call to the <function>current</function>
               function.</p>
               
               <olist>
                  <item><p>If the call is within a <termref def="dt-pattern"/>, the static type of the function call is the <termref def="dt-match-type"/> of the pattern.</p>
                     <note><p>There is no circularity in this definition: a call to <function>current</function> in a pattern can only appear within a predicate, and
                        the match type of a pattern never depends on anything appearing in a predicate.</p></note>
                  </item>
                  <item><p>Otherwise (the function call is within an XPath expression), the static type of the function call is the
                     <termref def="dt-context-item-type"/> that applies to the outermost containing XPath expression, determined by the rules in 
                     <specref ref="determining-context-item-type"/>.
                  </p></item>
               </olist>
            </div3>
            
            <div3 id="notes-on-schema-aware-analysis">
               <head>Schema-Aware Streamability Analysis</head>


            <note>
               <p>The streamability analysis in this chapter is not schema-aware. There are cases
                  where use of schema type information might enable a processor to determine that a
                  construct is streamable when it would be unable to make this determination
                  otherwise. Two examples:</p>
               <ulist>
                  <item>
                     <p>A processor might decide that a construct such as <code>price +
                           salesTax</code> is streamable if both the child elements have a simple
                        type such as <code>xs:decimal</code>, or if the order in which they appear
                        in the input document is known.</p>
                  </item>
                  <item>
                     <p>A processor might decide that a step using the descendant axis, such as
                           <code>.//title</code>, has <termref def="dt-striding"/> rather than
                           <termref def="dt-crawling"/>
                        <termref def="dt-posture"/> if it can establish that two <code>title</code>
                        elements will never be nested
                        (that is, a <code>title</code> cannot contain another <code>title</code>).
                        This would allow the instruction <code>&lt;xsl:apply-templates
                           select=".//title"/&gt;</code> to be used in a streaming template rule.</p>
                  </item>
               </ulist>
               <p>Although such constructs are not guaranteed streamable according to this
                  specification, there is nothing to prevent a processor providing a streamed
                  implementation if it is able to do so.</p>
            </note>
            </div3>
         </div2>

         <div2 id="determining-context-item-type">
            <head>Determining the Context Item Type</head>

            <p><termdef id="dt-context-item-type" term="context item type">For every expression, it
                  is possible to establish by static analysis, information about the item type of
                  the context item for evaluation of that expression. This is called the
                     <term>context item type</term> of the expression.</termdef></p>

            <p>The <termref def="dt-context-item-type"/> of an expression
               is a <termref def="dt-utype"/>.</p>

            <p>The semantics of every <termref def="dt-construct">construct</termref>, defined in
               this specification or in the XPath specification, describe how the <termref def="dt-focus"/> for evaluating each <termref def="dt-operand"/> of the construct
               is determined. In most cases the focus is the same as that of the parent construct.
               In some cases the focus is determined by evaluating some other expression, for
               example in the expressions <code>A/B</code>, <code>A!B</code>, or <code>A[B]</code>,
               the focus for evaluating <var>B</var> is <var>A</var>. More generally:</p>

            <ulist>
               <item>
                  <p><termdef id="dt-focus-changing-construct" term="focus-changing construct">A
                           <term>focus-changing construct</term> is a <termref def="dt-construct"/>
                        that has one or more <termref def="dt-operand">operands</termref> that are
                        evaluated with a different <termref def="dt-focus"/> from the parent
                        construct.</termdef></p>
                  <note>
                     <p>Examples of focus-changing constructs include the instructions
                           <elcode>xsl:for-each</elcode>, <elcode>xsl:iterate</elcode>, and
                           <elcode>xsl:for-each-group</elcode>; path expressions, filter
                        expressions, and simple mapping expressions; and all patterns.</p>
                  </note>
               </item>
               <item>
                  <p><termdef id="dt-controlling-operand" term="controlling operand">Within a
                           <termref def="dt-focus-changing-construct"/> there is in many cases one
                           <termref def="dt-operand">operand</termref> whose value determines the
                           <termref def="dt-focus"/> for evaluating other operands; this is referred
                        to as the <term>controlling operand</term>.</termdef></p>
                  <note>
                     <p>For example, the controlling operand of an <elcode>xsl:for-each</elcode>,
                           <elcode>xsl:iterate</elcode>, or <elcode>xsl:for-each-group</elcode>
                        instruction is the expression in its <code>select</code> attribute; the
                        controlling operand of a filter expression <code>E[P]</code> is
                           <code>E</code>, and the controlling operand of a simple mapping
                        expression <code>A!B</code> is <code>A</code>.</p>
                  </note>
               </item>
               <item>
                  <p><termdef id="dt-controlled-operand" term="controlled operand">Within a <termref def="dt-focus-changing-construct"/> there are one or more <termref def="dt-operand">operands</termref> that are evaluated with a <termref def="dt-focus"/> determined by the <termref def="dt-controlling-operand"/>
                        (or in some cases such as
                              <elcode>xsl:on-completion</elcode>, with an <termref def="dt-absent"/>
                           <termref def="dt-focus"/>); these are referred to as
                           <term>controlled operands</term>.</termdef></p>
                  <note>
                     <p>For example, the main controlled operand of an
                        <elcode>xsl:for-each</elcode>, <elcode>xsl:iterate</elcode>, or
                           <elcode>xsl:for-each-group</elcode> instruction is the contained sequence
                        constructor; the controlled operand of a filter expression <code>E[P]</code>
                        is <code>P</code>, and the controlled operand of a simple mapping expression
                           <code>A!B</code> is <code>B</code>.</p>
                  </note>
               </item>
               <item>
                  <p><termdef id="dt-focus-setting-container" term="focus-setting container">The
                           <term>focus-setting container</term> of a construct <var>C</var> is the
                        innermost <termref def="dt-focus-changing-construct"/>
                        <var>F</var> (if one exists) such that <var>C</var> is directly or
                        indirectly contained in a <termref def="dt-controlled-operand"/> of
                           <var>F</var>. If there is no such construct
                              <var>F</var>, then the focus-setting container is the containing
                              <termref def="dt-declaration"/>, for example an
                              <elcode>xsl:function</elcode> or <elcode>xsl:template</elcode>
                           element.</termdef></p>
                  <note>
                     <p>For example, if an instruction appears as a child of
                           <elcode>xsl:for-each</elcode>, then its focus-setting container is the
                           <elcode>xsl:for-each</elcode> instruction; if an expression appears
                        within the predicate of a filter expression, its focus-setting container is
                        the filter expression.</p>
                  </note>
               </item>
            </ulist>

            <p>The <termref def="dt-context-item-type"/> of a construct <var>C</var> is the first of
               the following that applies:</p>

            <olist>

               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is an
                        <elcode>xsl:function</elcode> element, an inline function declaration, or an
                        <elcode>xsl:on-completion</elcode> element, then the context item type is
                        <code>U{}</code>.</p>
                  <note>
                     <p>This is essentially an error case; expressions that depend on the focus
                        should not normally appear within a construct that sets the focus to
                           <termref def="dt-absent"/>.</p>
                  </note>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is an
                        <elcode>xsl:source-document</elcode> instruction, then the context item type is <code>U{document-node()}</code>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is a
                        <termref def="dt-template-rule"/>, then the context item type is the
                        <termref def="dt-match-type"/> of the match pattern of the template rule,
                     defined below.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is a
                        <code>PredicatePattern</code>, then the context item type is <code>U{*}</code>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> is a <termref def="dt-global-variable"/>
                     declaration, the context item type is determined by the <code>type</code> attribute
                     of the <elcode>xsl:global-context-item</elcode> declaration, defaulting to <code>U{*}</code>,
                     or <code>U{}</code> if the <elcode>xsl:global-context-item</elcode> declaration specifies
                     <code>use="absent"</code>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> is any other <termref def="dt-declaration"/>, for example <elcode>xsl:key</elcode> or 
                     <elcode>xsl:accumulator</elcode>, the
                     context item type is <code>U{*}</code>.</p>
               </item>
               <item>
                  <p>Otherwise, the context item type is the <termref def="dt-static-type"/> (see
                        <specref ref="determining-static-type"/>) of the <termref def="dt-controlling-operand"/> of the <termref def="dt-focus-setting-container"/> of <var>C</var>.</p>
               </item>
            </olist>

            <p><termdef id="dt-match-type" term="match type">The
                     <term>match type</term> of a <termref def="dt-pattern"/> is the most specific
                     <termref def="dt-utype"/> that is known to match all items that the pattern can
                  match.</termdef> The match type of a pattern is the inferred <termref def="dt-static-type"/> of the pattern’s equivalent expression, determined
               according to the rules in <specref ref="determining-static-type"/>. For example, the
               match type of the pattern <code>para[1]</code> is <code>U{element()}</code>, while
               that of the pattern <code>@code[.='x']</code> is <code>U{attribute()}</code></p>

         </div2>



         <div2 id="operand-roles">
            <head>Operand Roles</head>

            <p>An <termref def="dt-operand-role"/> gives information about the <termref def="dt-operand">operands</termref> of a particular kind of construct. The two
               important properties of an operand role are the required type and the operand
               usage.</p>


            <p>The <termref def="dt-operand-usage">usage</termref> of an operand role is relevant
               only when the value of an <termref def="dt-operand"/> supplied in that role is a
               node, or a sequence that contains nodes. It is one of the following:</p>

            <ulist>
               <item>
                  <p><termdef id="dt-absorption" term="absorption">An operand usage of
                           <term>absorption</term> indicates that the construct reads the subtree(s)
                        rooted at a supplied node(s).</termdef> Examples are constructs that atomize
                     their <termref def="dt-operand">operands</termref>, or that obtain the string
                     value of a supplied node, or that copy the supplied node to a new tree. Another
                     example is the <xfunction>deep-equal</xfunction> function, which compares the
                     subtrees rooted at the nodes supplied in its first two arguments.</p>
               </item>
               <item>
                  <p><termdef id="dt-inspection" term="inspection">An operand usage of
                           <term>inspection</term> indicates that the construct accesses properties
                        of a supplied node that are available without reading its subtree.</termdef>
                     Examples are functions such as <xfunction>name</xfunction> and
                        <xfunction>base-uri</xfunction>, and the <code>instance of</code> expression
                     which tests the type of a node (or other item), or functions such as
                        <xfunction>count</xfunction>, <xfunction>exists</xfunction>, and
                        <xfunction>boolean</xfunction> which are only interested in the existence of
                     the node, and not in its properties.</p>
               </item>
               <item>
                  <p><termdef id="dt-transmission" term="transmission">An operand usage of
                           <term>transmission</term> indicates that the construct will (potentially)
                        return a supplied node as part of its result to the calling construct (that
                        is, to its parent in the construct tree).</termdef> It also indicates that
                     document order is preserved: if the input is in document order, then the result
                     must be in document order. An example is a filter expression, where nodes in
                     the base expression (the expression being filtered) will typically appear in
                     the result of the filter expression, in their original order.</p>
               </item>
               <item>
                  <p><termdef id="dt-navigation" term="navigation">An operand usage of
                           <term>navigation</term> indicates that the construct may navigate freely
                        from the supplied node to other nodes in the same tree, in a way that is not
                        constrained by the streamability rules.</termdef> This covers several cases:
                     cases where it is known that the construct performs impermissible navigation
                     (for example, the <elcode>xsl:number</elcode> instruction) or reordering (the
                        <xfunction>reverse</xfunction> function), or that require look-ahead (the
                        <xfunction>innermost</xfunction> function) and also cases where the analysis
                     is unable to determine what use is made of the node, for example because it is
                     passed as an argument to a user-defined function, or retained in a
                     variable.</p>
               </item>
            </ulist>

            <p>The concept of operand usage is not used for all
                  constructs (for example, it is not used in the analysis of path expressions).
                  Where it is used, the assignment of operand usages to each operand role
               of a construct is defined in <specref ref="classifying-constructs"/>.</p>




            <div3 id="operand-usage-examples">
               <head>Examples showing the Effect of Operand Usage</head>

               <example>
                  <head>The Effect of Operand Usage on the Streamability of a Context Item
                     Expression</head>

                  <p>Consider the following construct:</p>

                  <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:source-document streamable="yes" href="emps.xml"&gt;
  &lt;xsl:for-each select="*/emp"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:source-document&gt;</eg>

                  <p>To assess the streamability, we follow the following logic:</p>
                  <olist>
                     <item>
                        <p>The top-level construct is a <termref def="dt-sequence-constructor"/>. It
                           is evaluated with a document node as the context item, and with a
                              <termref def="dt-striding"/> posture.</p>
                     </item>
                     <item>
                        <p>The sequence constructor has one child <termref def="dt-instruction"/>,
                           which has an <termref def="dt-operand-usage"/> of <termref def="dt-transmission"/>.</p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:for-each</elcode> instruction evaluates its
                              <code>select</code> expression, with the context item and <termref def="dt-posture"/> unchanged.</p>
                     </item>
                     <item>
                        <p>The step <code>child::*</code> is evaluated with this context item and
                           posture. The posture transition rules permit this; we now have a sequence
                           of child elements, and still a <termref def="dt-striding"/> posture.</p>
                     </item>
                     <item>
                        <p>The same applies to the next step, <code>child::emp</code></p>
                     </item>
                     <item>
                        <p>The content of the <elcode>xsl:for-each</elcode> instruction is a
                              <termref def="dt-sequence-constructor"/> which itself has a single
                              <termref def="dt-operand"/>, the <elcode>xsl:value-of</elcode>
                           instruction.</p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:value-of</elcode> instruction is evaluated once for each
                              <code>emp</code> child, with that child as context item and in a
                              <termref def="dt-striding"/> posture. This instruction uses the
                              <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-usage"/> of the <code>select</code> expression is
                              <termref def="dt-absorption"/>. This means that the result of the
                              <elcode>xsl:value-of</elcode> instruction is <termref def="dt-grounded"/> and <termref def="dt-consuming"/>.</p>
                     </item>
                     <item>
                        <p>The result of the trivial sequence constructor contained in the
                              <elcode>xsl:for-each</elcode> instruction is therefore <termref def="dt-grounded"/> and <termref def="dt-consuming"/></p>
                     </item>
                     <item>
                        <p>The result of the <elcode>xsl:for-each</elcode> instruction (see <specref ref="streamability-xsl-for-each"/>) is therefore <termref def="dt-grounded"/> and <termref def="dt-consuming"/></p>
                     </item>
                     <item>
                        <p>The result of the trivial sequence constructor contained in the
                              <elcode>xsl:source-document</elcode> instruction is therefore <termref def="dt-grounded"/> and <termref def="dt-consuming"/></p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:source-document</elcode> instruction is therefore <termref def="dt-guaranteed-streamable"/>.</p>
                     </item>
                  </olist>

                  <p>Now consider a slightly different construct:</p>

                  <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:source-document streamable="yes" href="emps.xml"&gt;
  &lt;xsl:for-each select="*/emp"&gt;
    &lt;xsl:sequence select="."/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:source-document&gt;</eg>

                  <p>To assess the streamability, we follow the following logic:</p>
                  <olist>
                     <item>
                        <p>The top-level construct is a <termref def="dt-sequence-constructor"/>. It
                           is evaluated with a document node as the context item, and with a
                              <termref def="dt-striding"/> posture.</p>
                     </item>
                     <item>
                        <p>The sequence constructor has one child <termref def="dt-instruction"/>,
                           which has an <termref def="dt-operand-usage"/> of <termref def="dt-transmission"/>.</p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:for-each</elcode> instruction evaluates its
                              <code>select</code> expression, with the context item and <termref def="dt-posture"/> unchanged.</p>
                     </item>
                     <item>
                        <p>The step <code>child::*</code> is evaluated with this context item and
                           posture. The posture transition rules permit this; we now have a sequence
                           of child elements, and still a <termref def="dt-striding"/> posture.</p>
                     </item>
                     <item>
                        <p>The same applies to the next step, <code>child::emp</code></p>
                     </item>
                     <item>
                        <p>The content of the <elcode>xsl:for-each</elcode> instruction is a
                              <termref def="dt-sequence-constructor"/> which itself has a single
                           operand, the <elcode>xsl:sequence</elcode> instruction.</p>
                     </item>
                     <item>
                        <p>The <elcode>xsl:sequence</elcode> instruction is evaluated once for each
                              <code>emp</code> child, with that child as context item and in a
                              <termref def="dt-striding"/> posture. This instruction uses the
                              <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-usage"/> of the <code>select</code> expression is
                              <termref def="dt-transmission"/>. This means that the result of the
                              <elcode>xsl:sequence</elcode> instruction is <termref def="dt-striding"/> and <termref def="dt-motionless"/>.</p>
                     </item>
                     <item>
                        <p>The result of the trivial sequence constructor contained in the
                              <elcode>xsl:for-each</elcode> instruction is therefore also <termref def="dt-striding"/> and <termref def="dt-motionless"/>.</p>
                     </item>
                     <item>
                        <p>The result of the <elcode>xsl:for-each</elcode> instruction (see <specref ref="streamability-xsl-for-each"/>) is therefore <termref def="dt-striding"/> and <termref def="dt-consuming"/> (the wider of the sweeps of the
                                 <code>select</code> expression and the sequence
                              constructor).</p>
                     </item>
                     <item>
                        <p>The result of the trivial sequence constructor contained in the
                              <elcode>xsl:source-document</elcode> instruction is therefore <termref def="dt-striding"/> and <termref def="dt-consuming"/>.</p>
                     </item>
                     <item>
                        <p>Since the result is not <termref def="dt-grounded"/>,  the <elcode>xsl:source-document</elcode>
                           instruction is therefore not <termref def="dt-guaranteed-streamable"/>.</p>
                     </item>
                  </olist>
                  <p>Expressed informally, the result of a <termref def="dt-declared-streamable"/> 
                     <elcode>xsl:source-document</elcode> instruction
                     (or of a <termref def="dt-declared-streamable"/> template rule) 
                     must not contain streamed nodes. The reason
                     for this is that once streamed nodes are returned to constructs that are not
                     declared streamable and therefore have no streamability constraints, there is
                     no way to analyze what happens to them, and thus to guarantee
                     streamability.</p>
               </example>

               <example>
                  <head>The Effect of Operand Roles on the Streamability of Path Expressions</head>

                  <p>Consider the expression <code>.//chapter</code>.</p>

                  <p>When this appears as an argument to the function <xfunction>count</xfunction>
                     or <xfunction>exists</xfunction>, it can be streamed (it is a <termref def="dt-consuming"/> expression, meaning that the subtree rooted at the
                     context item needs to be read in order to evaluate the expression). A possible
                     strategy for performing a streamed evaluation is to read all descendants of the
                     context item in document order, checking each one to see whether its name is
                        <code>chapter</code>. The <termref def="dt-sweep"/> of the expression will
                     be <termref def="dt-consuming"/>, and its <termref def="dt-posture"/> will be
                        <termref def="dt-crawling"/>.</p>

                  <p>The <termref def="dt-operand-usage"/> (the usage of the argument to
                        <xfunction>count</xfunction> or <xfunction>exists</xfunction>) is defined as
                        <termref def="dt-inspection"/>. The <termref def="dt-general-streamability-rules"/> show that when the posture of an
                        <termref def="dt-operand"/> is <termref def="dt-crawling"/> and the <termref def="dt-operand-usage"/> is <termref def="dt-inspection"/>, the resulting
                     expression is <termref def="dt-grounded"/>
                        and <termref def="dt-consuming"/>. This means that (in the absence of other
                        consuming expressions) the containing template or function will generally be
                        streamable.</p>

                  <p>In the expression <code>tail(.//chapter)</code>, the
                        <termref def="dt-operand-usage"/> is classified as <termref def="dt-transmission"/>, meaning that the nodes are simply passed up the
                     tree to the next containing expression. In general, when a <termref def="dt-crawling"/> expression is passed as an argument and the operand role
                     is <termref def="dt-transmission"/>, the containing expression will also be
                        <termref def="dt-crawling"/>. However, there is an exception where the
                     expression is known to deliver a singleton (for example,
                        <code>head(.//chapter)</code>). In this case the returned sequence cannot
                     contain any nested nodes, so it is <termref def="dt-crawling"/>.</p>



                  <p>When the same expression appears as an argument to an atomizing function
                        <xfunction>string-join</xfunction>, the processor knows that it will need to
                     access the subtree of each selected <code>section</code> element in order to
                     compute the result of the function (the argument to
                        <xfunction>string-join</xfunction> is classified as having <termref def="dt-operand-usage"/>
                     <termref def="dt-absorption"/>). The processor does not know whether these
                     subtrees will be nested (one
                        <code>section</code> might contain another). In most cases they will not be nested, because atomizing a
                        sequence that contains nested nodes is not generally a useful thing to do.
                        The streamability analysis therefore makes an optimistic assumption, by
                        treating atomization of a <termref def="dt-crawling"/> expression as a
                        streamable operation. In the worst case, where it turns out that the
                        selected nodes are indeed nested, the processor must handle this, typically
                        by buffering the content of inner nodes until the end tag of the outer nodes
                        is reached.</p>

                  <p>This treatment of nodes in a <termref def="dt-crawling"/> expression applies to all cases in which the content of
                     the nodes is handled in a way defined entirely by the rules of this
                     specification: for example, operations such as atomization, obtaining the
                     string value of nodes, deep copy of nodes, and the
                        <xfunction>deep-equal</xfunction> function. It does not extend to cases
                     where the processing applied to the nodes is user-defined: for example,
                     operations such as <elcode>xsl:apply-templates</elcode>,
                        <elcode>xsl:for-each</elcode>, or <elcode>xsl:for-each-group</elcode>. In
                     these cases, the nodes selected for processing must not be nested (a <termref def="dt-crawling"/> <termref def="dt-posture"/> is not permitted in these contexts).</p>

                  <p>When a <termref def="dt-crawling"/> expression
                     appears as an argument to a call on a user-defined function, the effect depends on the <termref def="dt-streamability-category"/> of the function, as described in
                           <specref ref="streamable-stylesheet-functions"/>.</p>

                  




               </example>
            </div3>


         </div2>

         <div2 id="posture">
            <head>Determining the Posture of a Construct</head>


            <p>The <term>posture</term> of a construct indicates the relationship of the nodes
               selected by the <termref def="dt-construct"/> to a <termref def="dt-streamed-document">streamed input document</termref>. The value is one of
               the following:</p>
            <ulist>
               <item>
                  <p><termdef id="dt-grounded" term="grounded"><term>Grounded</term>: indicates that
                        the value returned by the construct does not contain nodes from the streamed
                        input document</termdef>. Atomic values and function items are always
                     grounded; nodes are grounded if it is known that they are in a non-streamed
                     document. For example the expressions <code>doc('x')</code> and
                        <code>copy-of(.)</code> both return grounded nodes.</p>
               </item>
               <item>
                  <p><termdef id="dt-climbing" term="climbing"><term>Climbing</term>: indicates that
                        streamed nodes returned by the construct are reached by navigating the parent,
                        ancestor[-or-self], attribute, and/or namespace axes from the node at the
                        current streaming position.</termdef> When the <termref def="dt-context-posture"/> is climbing, use of certain
                     axes such as <code>parent</code> and <code>ancestor</code> is permitted, but
                     use of other axes such as <code>child</code> or <code>descendant</code>
                     violates the streamability rules.</p>
               </item>
               <item>
                  <p><termdef id="dt-crawling" term="crawling"><term>Crawling</term>: typically
                        indicates that streamed nodes returned by a construct are reached by navigating the
                        descendant[-or-self] axis.</termdef> Nodes reached in this way are potentially nested (one might be an ancestor
                        of another), so further downward navigation is not permitted.
                        Expressions that can be statically determined to
                        return a singleton node (for example <code>head(.//title)</code>) generate a
                        result with no such nesting, so
                        they are striding rather than crawling.</p>
               </item>
               <item>
                  <p><termdef id="dt-striding" term="striding"><term>Striding</term>: indicates that
                        the result of a construct contains a sequence of streamed nodes, in document order, that
                        are peers in the sense that none of them is an ancestor or descendant of any
                        other.</termdef> This is typically achieved by using one or more steps
                     involving the child or attribute
                     axes only. Use of the <xfunction>outermost</xfunction> function can also result
                     in a striding posture, as can functions such as
                           <xfunction>head</xfunction> or <xfunction>zero-or-one</xfunction> that
                        ensure the result will be a singleton node.</p>
                  
               </item>
               <item>
                  <p><termdef id="dt-roaming" term="roaming"><term>Roaming</term>: indicates that
                        the nodes returned by an expression could be anywhere in the tree, which
                        inevitably means that the construct cannot be evaluated using
                        streaming.</termdef> For example, the <termref def="dt-posture"/> of an axis
                     step using the <code>following</code> or <code>preceding</code> axis will
                     typically be <termref def="dt-roaming"/>, which leads the analysis to conclude
                     that the construct is not streamable.</p>
               </item>
            </ulist>
            
            

            <note>
               <p>One way to think about the posture values is as labels for states in a finite
                  state automaton, where the alphabet of symbols accepted by the automaton is the
                  set of 13 XPath axes, and the sentence being parsed is a path expression
                  containing a sequence of axis steps. For example, use of the
                     <code>descendant</code> axis when the current state is <term>striding</term>
                  moves the new state to <term>crawling</term>, and use of the <code>parent</code>
                  axis then takes it to <term>climbing</term>. </p>
            </note>

            <p>The <termref def="dt-posture"/> of a construct is determined in one of several
               ways:</p>
            <ulist>
               <item>
                  <p>For axis steps, the posture of the expression is determined by the <termref def="dt-context-posture"/> and the
                     choice of axis. For example, an axis step using the ancestor axis always has a
                     posture of <termref def="dt-climbing"/>, while an axis step using the child
                     axis, if the <termref def="dt-context-posture"/> is <termref def="dt-striding"/>, will itself have a posture of
                        <termref def="dt-striding"/>. The rules for the posture transitions produced
                     by axis steps are given in <specref ref="streamability-of-axis-steps"/>.</p>
               </item>
               <item>
                  <p>For many other constructs, the posture is determined by the <termref def="dt-general-streamability-rules"/>. These determine the result posture
                     in terms of the <termref def="dt-operand">operands</termref> of the construct
                     and the way in which each operand is used. For example, a construct that
                     accepts a streamed node as the value of an operand, and atomizes that node,
                     will generally have a posture of <termref def="dt-grounded"/>.</p>
               </item>
               <item>
                  <p>Other constructs have their own special rules, which are all listed in this
                     chapter. For example, a call on the <xfunction>root</xfunction> function
                     behaves analogously to an axis step, and is described in <specref ref="streamability-fn-root"/>. Special rules are needed for:</p>
                  <ulist>
                     <item>
                        <p>Constructs that evaluate an <termref def="dt-operand"/> more than once,
                           such as an XPath <code>for</code> expression;</p>
                     </item>
                     <item>
                        <p>Constructs that have alternatives among their operands, such as an XPath
                              <code>if</code> expression;</p>
                     </item>
                     <item>
                        <p>Constructs that navigate relative to the context item, such as axis
                           steps;</p>
                     </item>
                     <item>
                        <p>Constructs with implicit inputs, such as the context item expression
                              <code>.</code> (dot);</p>
                     </item>
                     <item>
                        <p>Constructs that change the focus, such as a filter expression;</p>
                     </item>
                     <item>
                        <p>Constructs that invoke functions or templates.</p>
                     </item>
                  </ulist>

               </item>
            </ulist>


            <p>The characterization of an expression as striding, crawling, climbing, or
               roaming applies only to the streamed nodes in the result of the expression. The result of the expression
               may also contain non-streamed (grounded) nodes or atomic values. For example
               if <code>/x/y</code> is a striding expression, then <code>(/x/y | $doc//x)</code> is also striding, given
               that <code>$doc</code> contains non-streamed nodes. The assertion that the nodes in the result of a striding
               expression are in document order and are peers thus applies only to the subset of the nodes that are streamed.</p>
            
            <note>
               <p>A consequence of this is that when striding expressions are used in a context that requires sorting into
                  document order, for example <code>(/x/y | $doc//x) / @price</code>, the fact that the expression is striding
               does not eliminate the need for the sequence to be re-ordered. However, there will never be a need for the relative
               order of the streamed nodes in the value to change.</p>
               <p>Since the data model leaves the relative order of nodes in different trees implementation-defined, and since streamed
                  and unstreamed nodes will necessarily be in different trees, a useful
               implementation strategy might be to arrange that streamed nodes always precede unstreamed nodes in document order (or vice
               versa). An operation that needs to process the result of a striding expression in document order can then first deliver
               all the streamed nodes (by consuming the input stream) in the order they arrive, and then deliver the unstreamed nodes, 
               suitably sorted.</p>
            </note>



         </div2>

         <div2 id="determining-context-posture">
            <head>Determining the Context Posture</head>

            <p>In the same way as the type of the context item can be determined for any construct C
               by reference to the type of the construct that establishes the context for the
               evaluation of C, so the posture of the context item C can be determined by reference
               to the posture of the construct that establishes the context.</p>

            <p>The <termref def="dt-context-posture"/> of a construct <var>C</var> is the first of
               the following that applies:</p>

            <olist>

               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is an
                        <elcode>xsl:function</elcode> declaration, an inline function declaration,
                     or an <elcode>xsl:on-completion</elcode> element, then the context posture is
                        <termref def="dt-roaming"/>.</p>
                  <note>
                     <p>This is essentially an error case; expressions that depend on the context
                        item should not normally appear within these constructs.</p>
                  </note>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is an
                        <elcode>xsl:source-document</elcode> instruction, then the context posture is
                     <termref def="dt-striding"/> if the
                     instruction is <termref def="dt-declared-streamable"/>, or <termref def="dt-grounded"/> otherwise.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is a
                        <termref def="dt-template-rule"/> whose mode is declared with
                        <code>streamable="yes"</code>, then the context posture is <termref def="dt-striding"/>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is a
                        <termref def="dt-pattern"/>, then the context posture is <termref def="dt-striding"/>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> of <var>C</var> is an
                        <elcode>xsl:attribute-set</elcode> declaration with the attribute
                        <code>streamable="yes"</code>, then the context posture is <termref def="dt-striding"/>.</p>
               </item>
               <item>
                  <p>If the <termref def="dt-focus-setting-container"/> is any other <termref def="dt-declaration"/>, for example a global variable declaration, a
                        <termref def="dt-named-template"/>, or a template rule or attribute set that
                     does not specify <code>streamable="yes"</code>, then the context posture is
                        <termref def="dt-roaming"/>.</p>
               </item>
               <item>
                  <p>Otherwise, the context posture is the <termref def="dt-posture"/> of the
                        <termref def="dt-controlling-operand"/> of the <termref def="dt-focus-setting-container"/> of <var>C</var>.</p>
               </item>
            </olist>



         </div2>

         <div2 id="sweep">
            <head>The Sweep of a Construct</head>

            <p><termdef id="dt-sweep" term="sweep">Every construct has a <term>sweep</term>, which
                  is a measure of the extent to which the current position in the input stream moves
                  during the evaluation of the expression. The sweep is one of: <termref def="dt-motionless"/>, <termref def="dt-consuming"/>, or <termref def="dt-free-ranging"/>
                  .</termdef> This list of
               values is ordered: a <termref def="dt-free-ranging"/> expression has <term>wider
                  sweep</term> than a <termref def="dt-consuming"/> expression, which has
                  <term>wider sweep</term> than a <termref def="dt-motionless"/> expression. </p>

            <p><termdef id="dt-motionless" term="motionless">A <term>motionless</term> construct is
                  any <termref def="dt-construct"/> deemed motionless by the rules in this section
                     (<specref ref="streamability"/>).</termdef> Informally, a motionless construct
               is one that can be evaluated without changing the current position in the input
               stream.</p>

            <note>
               <p>The context item expression <code>.</code> is classified as motionless; however a
                  construct that uses <code>.</code> as an <termref def="dt-operand"/> (for example,
                     <code>string(.)</code>) might be <termref def="dt-consuming"/>. The
                  streamability rules effectively consider expressions such as <code>.</code> within
                  the context of the containing construct.</p>
            </note>

            


            <p><termdef id="dt-consuming" term="consuming">A <term>consuming</term> construct is any
                     <termref def="dt-construct"/> deemed consuming by the rules in this section
                     (<specref ref="streamability"/>).</termdef> Informally, a consuming construct
               is one whose evaluation requires repositioning of the input stream from the start of
               the current node to the end of the current node.</p>

            <p><termdef id="dt-free-ranging" term="free-ranging">A <term>free-ranging</term>
                  construct is any <termref def="dt-construct"/> deemed free-ranging by the rules in
                  this section (<specref ref="streamability"/>).</termdef> Informally, a
               free-ranging construct is one whose evaluation may require access to information that
               is not available from the subtree rooted at the current node, together with
               information about ancestors of the current node and their attributes.</p>

            

            

            <p>The table below shows some examples of expressions having
               different combinations of <termref def="dt-posture"/> and <termref def="dt-sweep"/>.</p>

            <table class="data">
               <caption>Combinations of Sweep and Posture</caption>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1"/>
                     <th rowspan="1" colspan="1">Motionless</th>
                     <th rowspan="1" colspan="1">Consuming</th>
                     <th rowspan="1" colspan="1">Free-Ranging</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <th rowspan="1" colspan="1">Grounded</th>
                     <td rowspan="1" colspan="1"><code>name()</code></td>
                     <td rowspan="1" colspan="1"><code>string(title)</code></td>
                     <td rowspan="1" colspan="1">See Note</td>
                  </tr>
                  <tr>
                     <th rowspan="1" colspan="1">Climbing</th>
                     <td rowspan="1" colspan="1"><code>parent::*</code></td>
                     <td rowspan="1" colspan="1"><code>child::x/ancestor::y</code></td>
                     <td rowspan="1" colspan="1">See Note</td>
                  </tr>
                  <tr>
                     <th rowspan="1" colspan="1">Striding</th>
                     <td rowspan="1" colspan="1"><code>@status</code></td>
                     <td rowspan="1" colspan="1"><code>child::*</code></td>
                     <td rowspan="1" colspan="1">See Note</td>
                  </tr>
                  <tr>
                     <th rowspan="1" colspan="1">Crawling</th>
                     <td rowspan="1" colspan="1">The subexpression <code>.</code> in <code>//a/.</code></td>
                     <td rowspan="1" colspan="1"><code>descendant::*</code></td>
                     <td rowspan="1" colspan="1"><code>//x[child::y]</code></td>
                  </tr>
                  <tr>
                     <th rowspan="1" colspan="1">Roaming</th>
                     <td rowspan="1" colspan="1">See Note</td>
                     <td rowspan="1" colspan="1">See Note</td>
                     <td rowspan="1" colspan="1"><code>preceding::*</code></td>
                  </tr>
               </tbody>
            </table>

            <note>
               <p>In all cases where either the <termref def="dt-posture"/> is <termref def="dt-roaming"/>, or the <termref def="dt-sweep"/> is <termref def="dt-free-ranging"/>, or both, the effect is to make an expression
                  non-streamable. For convenience, therefore, evaluation of the streamability rules
                  in most cases returns the values <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/> only in combination with each other. In cases where the
                  rules return a <termref def="dt-posture"/> of <termref def="dt-roaming"/> combined
                  with some other <termref def="dt-sweep"/>, or a <termref def="dt-sweep"/> of
                     <termref def="dt-free-ranging"/> with some other <termref def="dt-posture"/>,
                  the final result of the analysis is always the same as if the expression were both
                     <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>

               <p>For an example of a case where an expression is <termref def="dt-roaming"/> but
                  not <termref def="dt-free-ranging"/>, consider the right-hand operand of the
                  relative path expression <code>(preceding::x/.)</code>. The rules for the
                  streamability of a context item expression (see <specref ref="streamability-of-context-item-expression"/>) give "<code>.</code>" in this
                  context a <termref def="dt-roaming"/> posture, combined with <termref def="dt-motionless"/> sweep. But the relative path expression as a whole is
                     <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/> (see <specref ref="streamability-of-path-expressions"/>), so the apparent inconsistency is
                  transient.</p>
            </note>

         </div2>
         
         <div2 id="grounded-consuming-constructs">
            <head>Grounded Consuming Constructs</head>
            
            <p>A construct is grounded if the items it delivers do not include nodes from a 
               streamed document; it is consuming if evaluation of the construct reads nodes 
               from a streamed input in a way that requires advancing the current position in the input.
            </p>
            
            <p>Grounded consuming constructs play an important role in streaming, and this 
               section discusses some of their characteristics.
            </p>
            <p>Examples of grounded consuming constructs (assuming the context item is a streamed node) include:
            </p>
            
            <ulist>
               <item><p><code>sum(.//transaction/@value)</code></p></item>
               <item><p><code>copy-of(./account/history/event)</code></p></item>
               <item><p><code>distinct-values(./account/@account-nr)</code></p></item>
               <item><p><code>&lt;xsl:for-each select="transaction"&gt;&lt;t&gt;&lt;xsl:value-of select="@value"/&gt;&lt;/t&gt;&lt;/xsl:for-each&gt;</code></p></item>
            </ulist>
            
            <p>XSLT 3.0 provides the two functions <function>copy-of</function> and <code>snapshot</code>
               with the explicit purpose of creating a sequence of grounded nodes, that can be processed
               one-by-one without the usual restrictions that apply to streamed processing, such as the
               rule permitting at most one downward selection. The processing style that exploits these
               functions is often called “windowed streaming”.</p>
            
            <p>In general the result of a grounded consuming construct is a sequence. Depending on how 
               this sequence is used, it may or may not be necessary for the processor to allocate sufficient 
               memory to hold the entire sequence. The streamability rules in this specification place few 
               constraints on how a grounded sequence is used. This is deliberate, because it gives users 
               control: by creating a grounded sequence (for example, by use of the copy-of function) 
               stylesheet authors create the possibility to process data in arbitrary ways (for example, 
               by sorting the sequence), and accept the possibility that this may consume memory.
            </p>
            
            <p>Pipelined evaluation of a sequence is analogous to streamed processing of a source document. 
               Pipelined evaluation occurs when the items in a sequence can be processed one-by-one, without 
               materializing the entire sequence in memory. Pipelining is a common optimization technique in 
               all functional programming languages. Operations for which pipelined evaluation is commonly 
               performed include filtering (<code>$transactions[@value gt 1000]</code>), mapping 
               (<code>$transactions!(@value - @processing-fee)</code>), and aggregation 
               (<code>sum($transactions)</code>). Operations that cannot be pipelined (because, 
               for example, the first item in the result sequence cannot be computed without knowing 
               the last item in the input sequence) include those that change the order of items 
               (<code>reverse()</code>, <code>sort()</code>). Other operations such as <code>distinct-values()</code> 
               allow the input to be processed one item at a time, but require memory that potentially 
               increases as the sequence length increases. Saving a grounded sequence in a variable is 
               also likely in many cases to require allocation of memory to hold the entire sequence.
            </p>
            <p>When the input to an operation is a grounded consuming sequence (more accurately, 
               a sequence resulting from the evaluation of a grounded consuming construct), this specification 
               does not attempt to dictate whether the operation is pipelined or not. The goal of interoperable 
               streaming in finite memory can therefore only be achieved if stylesheet authors take care to avoid 
               constructing grounded sequences that occupy large amounts of memory. In practice, however, users 
               can expect that many grounded consuming constructs will be pipelined where the semantics permit this.
            </p>
            
            <note><p>Some processors may recognize an opportunity for pipelining only if the expression
            is written in a particular way. For example the constructs <code>copy-of(/a/b/c)</code> and
            <code>/a/b/c/copy-of(.)</code> are to all intents and purposes equivalent, but some processors
            might recognize the second form more easily as suitable for pipelining.</p>
            <p>(There is one minor difference between these expressions: the order of nodes in <code>copy-of(/a/b/c)</code>
            is required to reflect the document order of the nodes in <code>/a/b/c</code>, while the result
            of <code>/a/b/c/copy-of(.)</code> can be in any order, in consequence of the rule that document order
            for nodes in different trees is implementation-dependent.)</p></note>
            
            <p>The use of the <xfunction>last</xfunction> function requires particular care because of
               its effect on pipelining.  The streamability rules prevent the use of <code>last()</code> in 
               conjunction with an expression that returns streamed nodes (because it would require look-ahead 
               in the stream), but there is no similar constraint for grounded sequences. So for example it 
               is not permitted (in a context that requires streaming) to write
            </p>
            <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:for-each select="transaction"&gt;
  &lt;xsl:value-of select="position(), ' of ', last()"/&gt;
&lt;/xsl:for-each&gt;</eg>
            
            <p>but it is quite permissible to write</p>
            
            <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:for-each select="transaction/copy-of()"&gt;
  &lt;xsl:value-of select="position(), ' of ', last()"/&gt;
&lt;/xsl:for-each&gt;</eg>
            
            <p>because the call on <function>copy-of</function> makes the sequence grounded. This construct
               cannot be pipelined because computing the first item in the result sequence depends on knowing
               the length of the input sequence; in consequence, a processor might be obliged to buffer all
               the transactions (or their copies) in memory.
               In this simple example the impact of the call on <xfunction>last</xfunction> is easily detected 
               both by the human reader and by the XSLT processor, but there are other cases where the effect 
               is less obvious. For example if the stylesheet executes the instruction
            </p>
            <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:apply-templates select="transaction/copy-of(.)"/&gt;</eg>
               
               <p>then the presence of a call on <xfunction>last</xfunction> in one of the template rules 
                  that gets invoked might not be easily spotted; yet the effect is exactly the same 
                  in preventing the result being computed by processing input items strictly one at 
                  a time. Avoiding such effects is entirely the responsibility of the stylesheet author.
               </p> 
            
            <p>By contrast, there is no intrinsic reason why use of the <xfunction>position</xfunction> should
            prevent pipelined processing: all it requires is for the processor to count how many items have been
            processed so far. Processors may also be able to handle the construct <code>position() = last()</code>
            without storing the entire sequence in memory; rather than actually evaluating the numeric values of
            <code>position()</code> and <code>last()</code>, this can be done by testing whether the context item
            is the last item in the sequence, which only requires a one-item lookahead.</p>
         </div2>


         <div2 id="classifying-constructs">
            <head>Classifying Constructs</head>

            <p>This section defines the properties of every kind of <termref def="dt-construct"/>
               that may appear in a <termref def="dt-stylesheet"/>. It identifies the <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usage</termref>, and it gives the rules that define the
                  <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the construct. In
               cases where the <termref def="dt-general-streamability-rules"/> apply, there is still
               an entry for the construct in order to define its <termref def="dt-operand">operands</termref> and their usages, since this information is needed by the
               general rules.</p>


            <p>The following sections describe this categorization for each kind of construct:</p>

            <ulist>
               <item>
                  <p>Sequence constructors: see <specref ref="classifying-sequence-constructors"/></p>
               </item>
               <item>
                  <p>Instructions: see <specref ref="classifying-instructions"/></p>
               </item>
               <item>
                  <p>Stylesheet functions: see <specref ref="streamable-stylesheet-functions"/></p>
               </item>
               <item>
                  <p>Attribute sets: see <specref ref="classifying-attribute-sets"/></p>
               </item>
               <item>
                  <p>Value templates: see <specref ref="classifying-vts"/></p>
               </item>
               <item>
                  <p>Expressions: see <specref ref="classifying-expressions"/></p>
               </item>
               <item>
                  <p>Patterns: see <specref ref="classifying-patterns"/></p>
               </item>
               <item>
                  <p>Calls to built-in functions: see <specref ref="classifying-built-in-functions"/></p>
               </item>
            </ulist>



            <div3 id="general-streamability-rules">
               <head>General Rules for Streamability</head>

               <p><termdef id="dt-general-streamability-rules" term="general streamability rules">Many <termref def="dt-construct">constructs</termref> share the same
                     streamability rules. These rules, referred to as the <term>general
                        streamability rules</term>, are defined here.</termdef></p>


               <p>Examples of constructs that use these rules are: an arithmetic expression, an
                     <termref def="dt-attribute-value-template"/>, a <termref def="dt-sequence-constructor"/>, the <elcode>xsl:value-of</elcode> instruction,
                  and a call to the <xfunction>doc</xfunction> function.</p>

               <p>The rules determine both the <termref def="dt-posture"/> and <termref def="dt-sweep">sweep</termref> of a construct. To determine the posture and
                  sweep of a construct <var>C</var>, assuming these general rules are applicable to
                  that kind of construct:</p>

               <olist>
                  <item>
                     <p>For each <termref def="dt-operand"/> of <var>C</var>:</p>
                     <olist>
                        <item>
                           <p>Establish:</p>
                           <olist>
                              <item>
                                 <p>The <termref def="dt-static-type"/>
                                    <var>T</var> of the operand (see <specref ref="determining-static-type"/>). </p>
                                 <note>
                                    <p>The static type is a <termref def="dt-utype"/>. For example,
                                       the static type of the expression <code>(@*, *)</code> is
                                          <var>U{element(), attribute()}</var>.</p>
                                 </note>
                              </item>
                              <item>
                                 <p>The <termref def="dt-sweep"/>
                                    <var>S</var> and <termref def="dt-posture"/>
                                    <var>P</var> of the operand (by applying the rules in this
                                    section <specref ref="classifying-constructs"/> to that operand,
                                    recursively).</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-operand-usage"/>
                                    <var>U</var> corresponding to the <termref def="dt-operand-role">role</termref> of the operand within <var>C</var> (from the
                                    information in this section <specref ref="classifying-constructs"/>).</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>Compute the adjusted sweep <var>S'</var> of the <termref def="dt-operand"/> by taking the first of the following that
                              applies:</p>
                           <olist>

                              <item>
                                 <p>If <var>S</var> is <termref def="dt-free-ranging"/> or
                                       <var>P</var> is <termref def="dt-roaming"/>, then
                                       <var>S'</var> is <termref def="dt-free-ranging"/>. (In this
                                    case the posture and sweep of <var>C</var> are <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>,
                                    regardless of any other operands.)</p>
                              </item>

                              <item>
                                 <p>If <var>P</var> is <termref def="dt-grounded"/>, then
                                       <var>S'</var> is <var>S</var>.</p>
                              </item>
                              <item>
                                 <p>Otherwise (<var>P</var> is not <termref def="dt-grounded"/>,
                                    which implies that the <termref def="dt-operand"/> is capable of returning streamed
                                    nodes), compute <var>S'</var> as follows:</p>
                                 <olist>
                                    <item>
                                       <p>Compute the adjusted usage <var>U'</var> as follows:</p>
                                       <olist>
                                             <item>
                                                <p>If <var>U</var> is <termref def="dt-absorption"/>
                                                  and the
                                                  intersection of <var>T</var> with
                                                  <var>U{element(), document-node()}</var> is
                                                  <var>U{}</var> (that is, if <var>T</var> is a type
                                                  that does not allow nodes with children),
                                                  then <var>U'</var> is <termref def="dt-inspection"/>.</p>
                                                <note>
                                                  <p>This is because the entire subtree of nodes
                                                  such as text nodes is available without reading
                                                  further data from the input stream.</p>
                                                </note>
                                             </item>
                                             <item>
                                                <p>Otherwise, <var>U'</var> is <var>U</var>.</p>
                                             </item>
                                          </olist>
                                    </item>
                                    <item>
                                       <p>Compute the adjusted <termref def="dt-sweep"/>
                                          <var>S'</var> from the table below:</p>
                                       <table class="data">
                                          <caption>Computing the Adjusted Sweep of an Expression</caption>
                                          <thead>
                                             <tr>
                                                <th rowspan="2" colspan="1">Posture (P)</th>
                                                <th colspan="4" rowspan="1">Adjusted Usage (U')</th>
                                             </tr>
                                             <tr>
                                                <th rowspan="1" colspan="1">Absorption</th>
                                                <th rowspan="1" colspan="1">Inspection</th>
                                                <th rowspan="1" colspan="1">Transmission</th>
                                                <th rowspan="1" colspan="1">Navigation</th>
                                             </tr>
                                          </thead>
                                          <tbody>

                                             <tr>
                                                <th rowspan="1" colspan="1">Climbing</th>
                                                <td rowspan="1" colspan="1">Free-ranging</td>
                                                <td rowspan="1" colspan="1"><var>S</var></td>
                                                <td rowspan="1" colspan="1"><var>S</var></td>
                                                <td rowspan="1" colspan="1">Free-ranging</td>
                                             </tr>
                                             <tr>
                                                <th rowspan="1" colspan="1">Striding</th>
                                                <td rowspan="1" colspan="1">Consuming</td>
                                                <td rowspan="1" colspan="1"><var>S</var></td>
                                                <td rowspan="1" colspan="1"><var>S</var></td>
                                                <td rowspan="1" colspan="1">Free-ranging</td>
                                             </tr>
                                             <tr>
                                                <th rowspan="1" colspan="1">Crawling</th>
                                                <td rowspan="1" colspan="1">Consuming</td>
                                                <td rowspan="1" colspan="1"><var>S</var></td>
                                                <td rowspan="1" colspan="1"><var>S</var></td>
                                                <td rowspan="1" colspan="1">Free-ranging</td>
                                             </tr>
                                          </tbody>
                                       </table>
                                    </item>
                                 </olist>
                              </item>

                           </olist>
                        </item>
                        <item>
                           <p><termdef id="dt-potentially-consuming" term="potentially consuming" open="true">An
                                    <termref def="dt-operand"/> is <term>potentially
                                    consuming</term> if at least one of the following conditions
                                 applies:</termdef></p>

                           <olist>
                              <item>
                                 <p>The operand’s adjusted <termref def="dt-sweep"/>
                                    <var>S'</var> is <termref def="dt-consuming"/>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-operand-usage"/> is <termref def="dt-transmission"/> and the operand is not <termref def="dt-grounded"/>.</p>
                              </item>
                           </olist>
                           <p role="closetermdef"/>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>Having computed the adjusted sweep <var>S'(o)</var> of each <termref def="dt-operand"/>
                        <var>o</var>, the <termref def="dt-posture"/> and <termref def="dt-sweep">sweep</termref> of <var>C</var> are the first of the following that
                        applies:</p>


                     <olist>
                        <item>
                           <p>If <var>C</var> has no operands, then <termref def="dt-grounded"/> and
                                 <termref def="dt-motionless"/>.</p>
                        </item>
                        <item>
                           <p>If any operand <var>o</var> has an adjusted sweep <var>S'(o)</var> of
                                 <termref def="dt-free-ranging"/>, then <termref def="dt-roaming"/>
                              and <termref def="dt-free-ranging"/>.</p>
                        </item>
                        <item>
                           <p>If more than one operand is <termref def="dt-potentially-consuming"/>, then:</p>
                           <olist>
                              <item>
                                 <p>If all these operands form part of a <termref def="dt-choice-operand-group"/>, then the <termref def="dt-posture"/> of <var>C</var> is the <termref def="dt-combined-posture"/> of the operands in this group,
                                    and the <termref def="dt-sweep"/> of <var>C</var> is the widest
                                       <termref def="dt-sweep"/> of the operands in this group</p>
                              </item>
                              <item>
                                 <p>If all these operands have <var>S'</var> = <termref def="dt-motionless"/>, (which necessarily means they have
                                       <var>U'</var> = <var>U</var> = <termref def="dt-transmission"/>) and if they all have the same <termref def="dt-posture"/>
                                    <var>P0</var>, then <termref def="dt-motionless"/> with <termref def="dt-posture"/>
                                    <var>P0</var>.</p>
                                 <note>
                                    <p>For example, the expression <code>(@a, @b)</code> is
                                       motionless and striding.</p>
                                 </note>
                              </item>
                              <item>
                                 <p>Otherwise, <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>If exactly one operand <var>o</var>
                              is <termref def="dt-potentially-consuming"/>, then:</p>
                           <olist>
                              <item>
                                 <p>If <var>o</var> is a <termref def="dt-higher-order-operand"/> of
                                       <var>C</var>, then <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                              </item>
                              <item>
                                 <p>If the <termref def="dt-operand-usage"/> of <var>o</var> is
                                       <termref def="dt-absorption"/> or <termref def="dt-inspection"/>, then <termref def="dt-grounded"/> and
                                       <termref def="dt-consuming"/>.</p>
                              </item>
                              <item>
                                 <p>If the <termref def="dt-posture"/> of <var>o</var> is <termref def="dt-crawling"/> and <var>C</var> is a function call of a
                                       built-in function
                                    whose signature indicates a return type with a maximum
                                    cardinality of one then <termref def="dt-striding"/> and the
                                    adjusted <termref def="dt-sweep"/> of <var>o</var>.</p>
                                 <note>
                                    <p>Although this rule is written in
                                       general terms, the only functions that it applies to (at the
                                       time of publication) are <xfunction>head</xfunction>,
                                          <xfunction>exactly-one</xfunction>, and
                                          <xfunction>zero-or-one</xfunction>. This rule only
                                       applies if the argument usage is transmission (other cases
                                       having been handled by earlier rules); of the built-in
                                       functions, the three functions listed are the only ones
                                       having an argument with usage transmission and a return type
                                       with maximum cardinality one.</p>
                                 </note>
                              </item>
                              <item>
                                 <p>Otherwise (the <termref def="dt-operand-usage"/> of <var>o</var>
                                    is <termref def="dt-transmission"/>), the <termref def="dt-posture"/> and adjusted <termref def="dt-sweep"/> of
                                       <var>o</var>.</p>
                              </item>
                           </olist>

                        </item>
                        <item>
                           <p>Otherwise (all operands are <termref def="dt-motionless"/>) <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                        </item>

                     </olist>

                  </item>
               </olist>



               <note>
                  <p>The rules ensure that if more than one <termref def="dt-operand"/> is <termref def="dt-consuming"/>, that is, if more than one operand reads the subtree of
                     the context node in a way that would cause the current position of the input
                     stream to change, then the construct is not streamable.</p>

                  <p>The rules also prevent multiple streamed nodes being returned in the result of
                     an expression if they are delivered by
                        different operands. For example, the expression <code>count((..,
                        *))</code> is not guaranteed streamable. This is to make static analysis
                     possible: the posture needs to be statically determined to ensure that
                     streaming does not fail at execution time. It is permitted, however, for
                     streamed nodes to be mixed in a sequence with non-streamed nodes or with atomic
                     values; in this case the posture of the result will be that of the streamed
                     nodes. It is also permitted to have multiple
                        operands delivering streamed nodes in different branches of a conditional,
                        provided the sweep and posture are compatible: for example <code>if (X) then
                           @name else name</code> is guaranteed streamable.</p>
                  
                  <p>Expressions that have more than one operand
                  with usage <termref def="dt-transmission"/>, for example <code>(A, B)</code>,
                  or <code>(A | B)</code>, or <code>insert-before(A, n, B)</code>, generally allow only one of these operands to select
                  streamed nodes. The result of the expression will contain
                  a mixture of streamed and grounded nodes, but its posture and sweep will be
                  that of the streamed operand. The nodes in the result will not necessarily be in document order,
                  but the subset of the nodes that are streamed will always be in document order.</p>
               </note>

            </div3>
            <div3 id="general-streamability-examples">
               <head>Examples of the General Streamability Rules</head>

               <p>This section provides some examples of how the general streamability rules
                  operate. In each example, the emphasis is on the outermost construct shown;
                  explanations for how the sweep and posture of its operands are derived are not
                  given, though in many cases they are explained in earlier examples.</p>

               <p>The examples assume that the context item type for evaluation of the expression
                  shown is an element node, and that its posture is striding.</p>

               <ulist>
                  <item>
                     <p><code>2 + 2</code> is grounded and motionless, because both the operands are
                        grounded and motionless.</p>
                  </item>
                  <item>
                     <p><code>price * 2</code> is grounded and consuming, because one of the
                        operands is consuming and the relevant operand usage is absorption.</p>
                  </item>
                  <item>
                     <p><code>price - discount</code> is roaming and free-ranging, because both the
                        operands are consuming (and they are not members of a parallel operand
                        group).</p>
                  </item>
                  <item>
                     <p><code>price * @discount</code> is grounded and consuming. The left-hand operand is consuming and
                        the corresponding operand usage is absorption, while the right-hand operand is motionless, again with an
                        operand usage of absorption, and its item type is <code>attribute()</code>
                        which changes the effective usage to inspection.</p>
                  </item>
                  <item>
                     <p><code>a/b/c</code> is striding and consuming. This is determined not by the
                        general streamability rules, but by the rules for path expressions in
                           <specref ref="streamability-of-path-expressions"/>.</p>
                  </item>
                  <item>
                     <p><code>a//c</code> is crawling and consuming. This is similarly determined by
                        the rules for path expressions in <specref ref="streamability-of-path-expressions"/>.</p>
                  </item>
                  <item>
                     <p><code>count(a/b/c)</code> is grounded and consuming, because the operand
                        (the argument to the count function) is striding and consuming (see earlier
                        example) and the operand usage is inspection.</p>
                  </item>
                  <item>
                     <p><code>sum(a/b/c)</code> is grounded and consuming, because the operand (the
                        argument to the <code>sum</code>
                        function) is striding and consuming (see earlier example) and the operand
                        usage is absorption.</p>
                  </item>
                  <item>
                     <p><code>count(descendant::c)</code> is grounded and
                        consuming, because the operand (the argument to the <code>count</code>
                        function) is crawling and consuming (see earlier example) and the operand
                        usage is inspection.</p>
                  </item>
                  <item>
                     <p><code>tail(descendant::c)</code> is crawling and
                        consuming. The operand is crawling, the operand usage is transmission, so
                        the posture and sweep of the result are the same as the posture and sweep of
                        the consuming operand.</p>
                  </item>
                  <item>
                     <p><code>unordered(a|b)</code> is crawling and
                        consuming. The operand (the argument to the <code>unordered</code> function)
                        is crawling (see <specref ref="streamability-of-union-expressions"/>), and
                        the operand usage is transmission, so the posture and sweep of the result
                        are the same as the posture and sweep of the consuming operand.</p>
                  </item>

                  <item>
                     <p><code>zero-or-one(descendant::c)</code> is
                        striding and consuming. Although the operand is crawling, the operand usage
                        is transmission and the cardinality of the expression is zero or one, so the
                        posture of the result is striding. The same analysis applies to
                           <code>exactly-one(descendant::c)</code> and to
                           <code>head(descendant::c)</code>.</p>
                  </item>
                  <item>
                     <p><code>sum(descendant::c)</code> is grounded and
                        consuming, because the operand (the argument to the <code>sum</code>
                        function) is crawling and consuming (see earlier example) and the operand
                        usage is absorption. In theory (although it is unlikely in practice) the
                        selected <code>c</code> elements might be
                           nested one inside another. The processor is expected to handle
                        this situation, which may require some buffering. For example, given the
                        untyped source document
                           <code>&lt;a&gt;&lt;c&gt;&lt;c&gt;1&lt;/c&gt;&lt;c&gt;2&lt;/c&gt;&lt;c&gt;3&lt;/c&gt;&lt;/c&gt;&lt;/a&gt;</code>, the
                        result of the expression is <code>129</code> (123 + 1 + 2 + 3), and to
                        evaluate this, a streaming processor will typically maintain a stack of
                        buffers to accumulate the typed values of each of the four <code>c</code>
                        elements during a single pass of the source document. </p>
                  </item>
                  <item>
                     <p><code>"Q{" || namespace-uri(.) || "}" || local-name(.)</code> is grounded
                        and motionless. The two literal operands are grounded and motionless because
                        they have no operands; the two function calls are grounded and motionless
                        because they have a single operand that is striding and motionless, with an
                        operand usage of inspection.</p>
                  </item>
                  <item>
                     <p><code>copy-of(.)/head/following-sibling::*</code> is grounded and consuming.
                        The left-hand operand
                           <code>copy-of(.)/head</code> is grounded and consuming because, under the
                        rules in <specref ref="streamability-of-path-expressions"/>, its left-hand operand
                           <code>copy-of(.)</code> is grounded and consuming. This in turn is
                        because <code>.</code> is striding and motionless, and the operand usage is
                        absorption.</p>
                  </item>
                  
                  <item>
                     <p><code>if ($discounted) then price else discounted-price</code> is striding
                        and consuming, because the two branches of the conditional are both striding
                        and consuming, and they form a <termref def="dt-choice-operand-group"/> with
                        usage transmission.</p>
                  </item>
                  <item>
                     <p><code>if ($gratis) then 0 else price</code> is striding and consuming
                        because there is only one consuming operand (the fact that it is part of a
                           <termref def="dt-choice-operand-group"/> does not affect the
                        reasoning).</p>
                  </item>
                  <item>
                     <p><code>count((author, editor))</code> is roaming and free-ranging. The first
                        argument to the <code>count</code> function is an expression with two
                        operands, both having usage=transmission, and neither being grounded.</p>
                  </item>
                  <item>
                     <p><code>count((author | editor))</code> is grounded and consuming. A union
                        expression is not subject to the general streamability rules; it has its own
                        rules, defined in <specref ref="streamability-of-union-expressions"/>, which
                        establish in this case that the argument to the <xfunction>count</xfunction>
                        is <termref def="dt-crawling"/> and <termref def="dt-consuming"/>. The
                           <xfunction>count</xfunction> function does follow the general
                        streamability rules, with an operand usage of <termref def="dt-inspection"/>: under rule 1(b)(iii)(B) the adjusted sweep is <termref def="dt-consuming"/>, and rule 2(d)(iii) then applies.</p>
                  </item>
                  <item>
                     <p><code>('{', author, '}')</code> is striding and consuming. Exactly one
                        operand is consuming; it has usage <termref def="dt-transmission"/>, so the
                        result has the posture and sweep of that operand. (The formal analysis
                        treats comma as a binary operator, but the same result can be obtained by
                        treating the content of the parenthesized expression as an expression with
                        three operands.)</p>
                  </item>


               </ulist>





            </div3>




            <div3 id="classifying-sequence-constructors">
               <head>Classifying Sequence Constructors</head>

               <p>The <termref def="dt-posture"/> and <termref def="dt-sweep">sweep</termref> of a
                     <termref def="dt-sequence-constructor"/> are determined by the <termref def="dt-general-streamability-rules"/>.</p>

               <p>The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are:</p>

               <olist>
                  <item>
                     <p>The immediately contained
                           <termref def="dt-instruction">instructions</termref>
                        and <termref def="dt-literal-result-element">literal result elements</termref>,
                           including any <elcode>xsl:on-empty</elcode> or
                              <elcode>xsl:on-non-empty</elcode> instructions. The <termref def="dt-operand-usage"/> for these operands is <termref def="dt-transmission"/>.</p>
                  </item>
                  <item>
                     <p>Any <termref def="dt-text-value-template">text value templates</termref>
                        appearing in text nodes within the sequence constructor, if text value
                        templates are enabled. The <termref def="dt-operand-usage"/> for these
                        operands is <termref def="dt-absorption"/>.</p>
                  </item>
               </olist>


               <note>
                  <p>Some consequences of these rules are:</p>
                  <olist>
                     <item>
                        <p>An empty sequence constructor is <termref def="dt-motionless"/>, and its
                              <termref def="dt-posture"/> is <termref def="dt-grounded"/>.</p>
                     </item>
                     <item>
                        <p>A sequence constructor containing a single instruction has the same
                              <termref def="dt-sweep"/> and <termref def="dt-posture"/> as that
                           instruction. (This means that sequence constructors containing a single instruction
                           can usefully be dropped from the construct tree.)</p>
                     </item>
                     <item>
                        <p>Informally, a sequence constructor is not streamable if it contains more
                           than one instruction that moves the position of the input stream.</p>
                     </item>
                     <item>
                        <p><elcode>xsl:on-empty</elcode> or <elcode>xsl:on-non-empty</elcode>
                           instructions are not treated specially. For example, there is no attempt
                           to take into account that they are mutually exclusive: if one is
                           evaluated, the other will not be evaluated. In most use cases for these
                           instructions, they will be motionless, so the additional complexity of
                           doing more advanced analysis would rarely be justified.</p>
                     </item>
                  </olist>
               </note>


               




            </div3>

            <div3 id="classifying-instructions">
               <head>Classifying Instructions</head>

               <p>This section describes how <termref def="dt-instruction">instructions</termref>
                  are classified with respect to their streamability. The criteria are given first
                  for <termref def="dt-literal-result-element">literal result elements</termref> and
                     <termref def="dt-extension-instruction">extension instructions</termref>, then
                  for each XSLT instruction, listed alphabetically.</p>



               <div4 id="streamability-literal-result-elements">
                  <head>Streamability of Literal Result Elements</head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of a <termref def="dt-literal-result-element"/> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are:</p>
                  <olist>
                     <item>
                        <p>The contained sequence constructor (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>Any expressions contained in <termref def="dt-attribute-value-template">attribute value templates</termref> among the literal result
                           element’s attributes (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>Any <termref def="dt-attribute-set">attribute sets</termref> named in the
                           <code>xsl:use-attribute-sets</code> attribute (usage irrelevant, but can be taken as <termref def="dt-inspection"/>).</p>
                        <note><p>In practice, a reference to an attribute set that is <termref def="dt-declared-streamable"/> does not
                        affect the analysis, while a reference to any other attribute set makes the literal result element
                        <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p></note>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-extension-instructions">
                  <head>Streamability of extension instructions</head>

                  <p>For a processor that recognizes an <termref def="dt-extension-instruction"/>,
                     the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                     instruction are <termref def="dt-implementation-defined"/>.</p>

                  <imp-def-feature id="idf-ext-streamability">The <termref def="dt-posture"/> and
                        <termref def="dt-sweep"/> of <termref def="dt-extension-function">extension
                        functions (and references to extension functions)</termref> and <termref def="dt-extension-instruction">extension instructions</termref> are <termref def="dt-implementation-defined"/>.</imp-def-feature>

                  <p>For a processor that does not recognize an <termref def="dt-extension-instruction"/>, the <termref def="dt-posture"/> and
                        <termref def="dt-sweep"/> of the instruction are determined by applying the
                        <termref def="dt-general-streamability-rules"/>, The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are:</p>
                  <olist>
                     <item>
                        <p>The <termref def="dt-sequence-constructor">sequence
                              constructors</termref> contained in any <elcode>xsl:fallback</elcode>
                           children (usage <termref def="dt-transmission"/>)</p>
                     </item>
                  </olist>

                  <p>Instructions in the XSLT namespace that are present under the provisions for
                        <termref def="dt-forwards-compatible-behavior"/> are treated in the same way
                     as unrecognized extension instructions.</p>

                  <note>
                     <p>These rules mean that if there is no <elcode>xsl:fallback</elcode> child
                        instruction, the containing construct will be classified as streamable.
                        However, any attempt to execute the instruction will lead to a dynamic
                        error, so in fact, neither streamed nor unstreamed evaluation is
                        possible.</p>
                  </note>

               </div4>
               <div4 id="streamability-xsl-analyze-string">
                  <head>Streamability of <elcode>xsl:analyze-string</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:analyze-string</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are:</p>
                  <olist>
                     <item>
                        <p>the <code>select</code> expression (usage <termref def="dt-absorption"/>);</p>
                     </item>
                     <item>
                        <p>the <code>regex</code> attribute value template (usage <termref def="dt-absorption"/>);</p>
                     </item>
                     <item>
                        <p>the sequence constructors contained in the
                              <elcode>xsl:matching-substring</elcode> and
                              <elcode>xsl:non-matching-substring</elcode> elements. These have usage
                              <termref def="dt-navigation"/>, because they can be evaluated more
                           than once. The <termref def="dt-context-posture"/> for the two sequence
                           constructors is <termref def="dt-grounded"/>, reflecting the fact that
                           their context item type is <code>xs:string</code>.</p>
                     </item>
                  </olist>

                  <note>
                     <p>In practice, the <termref def="dt-sweep"/> of the
                        instruction will usually be the same as the sweep of the <code>select</code>
                        expression, and its <termref def="dt-posture"/> will be <termref def="dt-grounded"/>. Exceptions occur for example if the
                           <code>regex</code> attribute is not <termref def="dt-motionless"/>, or if
                        the contained sequence constructors refer to a grouping variable bound in a
                        contained <elcode>xsl:for-each-group</elcode> instruction.</p>
                  </note>


               </div4>
               <div4 id="streamability-xsl-apply-imports">
                  <head>Streamability of <elcode>xsl:apply-imports</elcode></head>

                  <p>The rules in this section apply also to <elcode>xsl:next-match</elcode>.</p>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of these two
                     instructions follow the <termref def="dt-general-streamability-rules"/>. The
                        <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are:</p>

                  <olist>
                     <item>
                        <p>An implicit operand: a context item expression (<code>.</code>), with
                           usage <termref def="dt-absorption"/>;</p>
                     </item>
                     <item>
                        <p>The <code>select</code> attribute or contained <termref def="dt-sequence-constructor"/> of each
                              <elcode>xsl:with-param</elcode> child element, with <termref def="dt-type-determined-usage"/> based on the type declared in the
                              <code>xsl:with-param/@as</code> attribute, or <code>item()*</code> if
                           absent.</p>
                     </item>

                  </olist>

                  <note>
                     <p>The instruction will normally be <termref def="dt-grounded"/> and <termref def="dt-consuming"/>, provided that nodes in a streamed document are not
                        passed as parameters to the called template rule.</p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-apply-templates">
                  <head>Streamability of <elcode>xsl:apply-templates</elcode></head>

                  <p>If there is no <code>select</code> attribute, the following
                     analysis assumes the presence of an implicit operand
                        <code>select="child::node()"</code>.</p>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                        <elcode>xsl:apply-templates</elcode> instruction are the first of the
                     following that apply:</p>

                  <olist>
                     <item>
                        <p>If the <code>select</code> expression is <termref def="dt-grounded"/>,
                           then the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                              <elcode>xsl:apply-templates</elcode> instruction follow the <termref def="dt-general-streamability-rules"/>, with the <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> as follows:</p>
                        <olist>
                           <item>
                              <p>The <code>select</code> expression (the <termref def="dt-operand-usage"/> is irrelevant, but can be taken as
                                    <termref def="dt-absorption"/>)</p>
                           </item>
                           <item>
                              <p>The <code>select</code> expressions and contained sequence
                                 constructors of any child <elcode>xsl:with-param</elcode> elements
                                 (usage <termref def="dt-type-determined-usage">type-determined</termref>, based on the type in the
                                    <code>xsl:with-param/@as</code> attribute, defaulting to
                                    <code>item()*</code>)</p>
                           </item>
                           <item>
                              <p>Any attribute value templates appearing in attributes of a child
                                    <elcode>xsl:sort</elcode> instruction (usage <termref def="dt-absorption"/>)</p>
                           </item>
                           <item>
                              <p>The <code>select</code> expression or contained sequence
                                 constructor of any <elcode>xsl:sort</elcode> children, assessed
                                 with a <termref def="dt-context-posture"/> of <termref def="dt-grounded"/> (usage <termref def="dt-absorption"/>).</p>
                           </item>

                        </olist>
                        <p>For example, <code>&lt;xsl:apply-templates
                              select="copy-of(.)"/&gt;</code> is <termref def="dt-grounded"/> and
                              <termref def="dt-consuming"/>.</p>
                     </item>
                     <item>
                        <p>If there is an <elcode>xsl:sort</elcode> child element, then <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If the implicit or explicit <code>mode</code> attribute identifies a
                              <termref def="dt-mode">mode</termref> that is not declared with
                              <code>streamable="yes"</code>, then <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>. </p>
                        <note>
                           <p>When <code>mode="#current"</code> is specified, this is treated as
                              equivalent to specifying a streamable mode; although it is not known
                              statically what the mode will be, it is always the case that if the
                              template is invoked with a streamed node as the context item, then the
                              current mode must be a streamable mode.</p>
                        </note>

                     </item>
                     <item>
                        <p>If the <code>select</code> expression is <termref def="dt-climbing"/> or
                              <termref def="dt-crawling"/>, then <termref def="dt-roaming"/> and
                              <termref def="dt-free-ranging"/></p>
                     </item>
                     <item>
                        <p>Otherwise, the <termref def="dt-posture"/> and <termref def="dt-sweep"/>
                           of the <elcode>xsl:apply-templates</elcode> instruction follow the
                              <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                        <olist>
                           <item>
                              <p>The (explicit or implicit) <code>select</code> expression, with
                                 usage <termref def="dt-absorption"/>; </p>
                           </item>
                           <item>
                              <p>The <code>select</code> attribute or contained <termref def="dt-sequence-constructor"/> of each
                                    <elcode>xsl:with-param</elcode> child element, with <termref def="dt-type-determined-usage"/> based on the type declared in
                                 the <code>xsl:with-param/@as</code> attribute, or
                                    <code>item()*</code> if absent.</p>
                           </item>
                        </olist>
                     </item>
                  </olist>



               </div4>


               <div4 id="streamability-xsl-assert">
                  <head>Streamability of <elcode>xsl:assert</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:assert</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>test</code> expression (usage <termref def="dt-inspection"/>)</p>
                     </item>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>error-code</code> attribute value template (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref def="dt-absorption"/>).</p>
                     </item>
                  </olist>

               </div4>

               <div4 id="streamability-xsl-attribute">
                  <head>Streamability of <elcode>xsl:attribute</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:attribute</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>name</code> attribute value template (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>namespace</code> attribute value template (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>separator</code> attribute value template (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>

               <div4 id="streamability-xsl-break">
                  <head>Streamability of <elcode>xsl:break</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:break</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-transmission"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref def="dt-transmission"/>).</p>
                     </item>
                  </olist>
               </div4>

               <div4 id="streamability-xsl-call-template">
                  <head>Streamability of <elcode>xsl:call-template</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:call-template</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>Unless the referenced template has a child
                              <elcode>xsl:context-item</elcode> element with the attribute
                              <code>use="prohibited"</code>, there is an implicit operand, a context
                           item expression (<code>.</code>): its <termref def="dt-operand-usage"/>
                           is the <termref def="dt-type-determined-usage"/> based on the type
                           declared in the <code>xsl:context-item/@as</code> attribute of the target
                           named template, defaulting to <code>item()*</code> if absent.</p>
                     </item>
                     <item>
                        <p>The <code>select</code> expression or sequence constructor content of any
                           contained <elcode>xsl:with-param</elcode> child element: its <termref def="dt-operand-usage"/> is the <termref def="dt-type-determined-usage"/> based on the type declared in the
                              <code>xsl:with-param/@as</code> attribute, or the
                              <code>xsl:param/@as</code> attribute of the corresponding parameter on
                           the target named template, whichever is more restrictive, defaulting to
                              <code>item()*</code> if both are absent.</p>
                     </item>
                  </olist>

                  <note>
                     <p>Calling <elcode>xsl:call-template</elcode> will usually make stylesheet code
                        unstreamable if a streamed node is passed explicitly or implicitly to the
                        called template, unless it is atomized by declaring the expected type to be
                        atomic.</p>
                  </note>
               </div4>
               <div4 id="streamability-xsl-choose">
                  <head>Streamability of <elcode>xsl:choose</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:choose</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>

                  <olist>
                     <item>
                        <p>The <code>test</code> attribute of contained <elcode>xsl:when</elcode>
                           elements (usage <termref def="dt-inspection"/>).</p>
                     </item>
                     <item>
                        <p>The sequence constructors contained within <elcode>xsl:when</elcode> and
                              <elcode>xsl:otherwise</elcode> child elements (usage <termref def="dt-transmission"/>). These sequence constructor operands form a
                              <termref def="dt-choice-operand-group"/>.</p>
                     </item>
                  </olist>

                  <note>
                     <p>The effect is to allow either of the following:</p>
                     <olist>
                        <item>
                           <p>Any or all of the sequence constructors in <elcode>xsl:when</elcode> and
                                 <elcode>xsl:otherwise</elcode> branch may be <termref def="dt-consuming"/>,  in
                              which case the <code>test</code> expressions must all be <termref def="dt-motionless"/>.</p>
                        </item>
                        <item>
                           <p>Any one of the <code>test</code> expressions may be <termref def="dt-consuming"/>, 
                              in which case all the other <code>test</code> expressions, and all the sequence constructors, must be <termref def="dt-motionless"/>.</p>
                        </item>
                     </olist>
                  </note>


               </div4>

               <div4 id="streamability-xsl-comment">
                  <head>Streamability of <elcode>xsl:comment</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:comment</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>

               <div4 id="streamability-xsl-copy">
                  <head>Streamability of <elcode>xsl:copy</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:copy</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>


                  <olist>
                     <item>
                        <p>The expression in the <code>select</code> attribute, defaulting to a
                           context item expression (<code>.</code>) (usage <termref def="dt-inspection"/>)</p>
                     </item>
                     <item>
                        <p>The contained sequence constructor (usage <termref def="dt-absorption"/>), assessed with <termref def="dt-context-posture"/> and context item
                           type based on the <code>select</code> expression if present, or the outer
                           focus otherwise.</p>
                     </item>
                     <item>
                        <p>Any <termref def="dt-attribute-set">attribute sets</termref> named in the
                           <code>use-attribute-sets</code> attribute (usage irrelevant, but can be taken as <termref def="dt-inspection"/>).</p>
                        <note><p>In practice, a reference to an attribute set that is <termref def="dt-declared-streamable"/> does not
                           affect the analysis, while a reference to any other attribute set makes the <elcode>xsl:copy</elcode> instruction
                           <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p></note>
                     </item>
                     
                  </olist>

                  <note><p>The effect of these rules is that when a <code>select</code>
                     attribute is present, the sequence constructor contained by the <elcode>xsl:copy</elcode>
                     instruction is deemed to be a <termref def="dt-higher-order-operand"/> of the instruction,
                     even though it can only be evaluated once.</p>
                  <p>This has the practical consequence that the following example is not <termref def="dt-guaranteed-streamable"/>,
                  even though it is possible to imagine a strategy for streamed evaluation:</p>
                     <eg role="xslt-instruction" xml:space="preserve">
 &lt;xsl:for-each-group select="product" group-adjacent="@category"&gt;
     &lt;xsl:copy select=".."&gt;
         &lt;xsl:copy-of select="current-group()"/&gt;
     &lt;/xsl:copy&gt;
 &lt;/xsl:for-each-group&gt;</eg>
                     <p>A workaround in this case might be to rewrite the code as follows:</p>
                     <eg role="xslt-instruction" xml:space="preserve">
 &lt;xsl:for-each-group select="product" group-adjacent="@category"&gt;
     &lt;xsl:element name="{name(..)}" namespace-uri="{namespace-uri(..)}"&gt;
         &lt;xsl:copy-of select="current-group()"/&gt;
     &lt;/xsl:element&gt;
 &lt;/xsl:for-each-group&gt;</eg>
                  </note>


               </div4>

               <div4 id="streamability-xsl-copy-of">
                  <head>Streamability of <elcode>xsl:copy-of</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:copy-of</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>

               <div4 id="streamability-xsl-document">
                  <head>Streamability of <elcode>xsl:document</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:document</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>

               <div4 id="streamability-xsl-element">
                  <head>Streamability of <elcode>xsl:element</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:element</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>name</code> attribute value template (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>namespace</code> attribute value template (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     
                     <item>
                        <p>Any <termref def="dt-attribute-set">attribute sets</termref> named in the
                           <code>use-attribute-sets</code> attribute (usage irrelevant, but can be taken as <termref def="dt-inspection"/>).</p>
                        <note><p>In practice, a reference to an attribute set that is <termref def="dt-declared-streamable"/> does not
                           affect the analysis, while a reference to any other attribute set makes the <elcode>xsl:element</elcode> instruction
                           <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p></note>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>

               <div4 id="streamability-xsl-evaluate">
                  <head>Streamability of <elcode>xsl:evaluate</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:evaluate</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>

                  <olist>
                     <item>
                        <p>The <code>xpath</code> expression (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>context-item</code> expression (usage <termref def="dt-navigation"/>)</p>
                     </item>
                     <item>
                        <p>The <code>with-params</code> expression (usage <termref def="dt-navigation"/>)</p>
                     </item>
                     <item>
                        <p>The <code>base-uri</code> attribute value template (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>namespace-context</code> expression (usage <termref def="dt-inspection"/>)</p>
                     </item>
                     <item>
                        <p>The <code>schema-aware</code> attribute value template (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>select</code> attributes and contained <termref def="dt-sequence-constructor">sequence constructors</termref> of any
                              <elcode>xsl:with-param</elcode> child elements (usage <termref def="dt-type-determined-usage">type-determined</termref>, based on the
                           type in the <code>xsl:with-param/@as</code> attribute, defaulting to
                              <code>item()*</code>)</p>
                     </item>

                  </olist>

                  <note>
                     <p>In practice, code containing an <elcode>xsl:evaluate</elcode> instruction
                        will usually be streamable provided that streamed nodes are not passed to
                        the dynamic expression either as the context item or as the value of a
                        parameter.</p>
                  </note>

               </div4>
               <div4 id="streamability-xsl-fallback">
                  <head>Streamability of <elcode>xsl:fallback</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                        <elcode>xsl:fallback</elcode> instruction depend on whether the processor is
                     performing fallback (which is known statically).</p>

                  <p>If the processor is performing fallback, then the <termref def="dt-posture"/>
                     and <termref def="dt-sweep"/> of the <elcode>xsl:fallback</elcode> instruction
                     are the posture and sweep of the contained sequence constructor.</p>

                  <p>If the processor is not performing fallback, then the instruction is <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
               </div4>
               <div4 id="streamability-xsl-for-each">
                  <head>Streamability of <elcode>xsl:for-each</elcode></head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                        <elcode>xsl:for-each</elcode> instruction are the first of the following
                     that applies:</p>

                  <olist>
                     <item>
                        <p>If the <code>select</code> expression is <termref def="dt-grounded"/>,
                           then the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                              <elcode>xsl:for-each</elcode> instruction follow the <termref def="dt-general-streamability-rules"/>, with the <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> as follows:</p>
                        <olist>
                           <item>
                              <p>The <code>select</code> expression (the <termref def="dt-operand-usage"/> is irrelevant, but can be taken as
                                    <termref def="dt-inspection"/>)</p>
                           </item>
                           <item>
                              <p>The contained <termref def="dt-sequence-constructor"/> (usage
                                    <termref def="dt-transmission"/>). This is a <termref def="dt-higher-order-operand">higher-order operand</termref>;
                                 its context posture is <termref def="dt-grounded"/>.</p>
                           </item>
                           <item>
                              <p>Any attribute value templates appearing in attributes of a child
                                    <elcode>xsl:sort</elcode> instruction (usage <termref def="dt-absorption"/>)</p>
                           </item>
                           <item>
                              <p>The <code>select</code> expression or contained sequence
                                 constructor of any <elcode>xsl:sort</elcode> children, assessed
                                 with a <termref def="dt-context-posture"/> of <termref def="dt-grounded"/> (usage <termref def="dt-absorption"/>).
                                 These are <termref def="dt-higher-order-operand">higher-order
                                    operands</termref>; their context posture is <termref def="dt-grounded"/>.</p>
                           </item>

                        </olist>

                     </item>
                     <item>
                        <p>If there is an <elcode>xsl:sort</elcode> child element, then <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>

                     <item>
                        <p>If the <termref def="dt-posture"/> of the
                              <code>select</code> expression is <termref def="dt-crawling"/> and the
                              <termref def="dt-sweep"/> of the contained <termref def="dt-sequence-constructor"/> is <termref def="dt-consuming"/>, then
                              <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>. </p>
                     </item>

                     <item>
                        <p>Otherwise:</p>

                        <olist>
                           <item>
                              <p>The <termref def="dt-posture"/> of the instruction is the <termref def="dt-posture"/> of the contained <termref def="dt-sequence-constructor"/>, assessed with the <termref def="dt-context-posture"/>
                                 and context item type set to the <termref def="dt-posture"/> and
                                 type of the <code>select</code> expression.</p>
                           </item>

                           <item>
                              <p>The <termref def="dt-sweep"/> of the instruction is the wider of
                                 the <termref def="dt-sweep"/> of the <code>select</code> expression
                                 and the <termref def="dt-sweep"/> of the contained <termref def="dt-sequence-constructor"/>.</p>
                              <note>
                                 <p>The ordering of sweep values is in increasing order: <termref def="dt-motionless"/>, <termref def="dt-consuming"/>,
                                       <termref def="dt-free-ranging"/>.</p>
                              </note>
                           </item>
                        </olist>

                        <note>
                           <p>Because the body of the <elcode>xsl:for-each</elcode> instruction is a
                                 <termref def="dt-higher-order-operand"/> of the instruction, any
                              variable reference within the body that is bound to a <termref def="dt-streaming-parameter"/> of a containing <termref def="dt-stylesheet-function"/> will not be singular, which in many
                              cases will make the entire function non-streamable.</p>
                        </note>
                     </item>
                  </olist>


               </div4>
               <div4 id="streamability-xsl-for-each-group">
                  <head>Streamability of <elcode>xsl:for-each-group</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                        <elcode>xsl:for-each-group</elcode> instruction are the first of the
                     following that applies:</p>

                  <olist>
                     <item>
                        <p>If the <code>select</code> expression is <termref def="dt-grounded"/>,
                           then the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                              <elcode>xsl:for-each-group</elcode> instruction follow the <termref def="dt-general-streamability-rules"/>, with the <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> as follows:</p>
                        <olist>
                           <item>
                              <p>The <code>select</code> expression (the <termref def="dt-operand-usage"/> is irrelevant, but can be taken as
                                    <termref def="dt-inspection"/>)</p>
                           </item>
                           <item>
                              <p>The <code>collation</code> attribute value template (usage <termref def="dt-absorption"/>)</p>
                           </item>
                           <item>
                              <p>Any attribute value templates appearing in attributes of a child
                                    <elcode>xsl:sort</elcode> instruction (usage <termref def="dt-absorption"/>)</p>
                           </item>
                           <item>
                              <p>The <code>group-by</code> or <code>group-adjacent</code>
                                 expression, assessed with a <termref def="dt-context-posture"/> of
                                    <termref def="dt-grounded"/> (usage <termref def="dt-absorption"/>).</p>
                           </item>
                           <item>
                              <p>The <code>select</code> expression or contained sequence
                                 constructor of any <elcode>xsl:sort</elcode> children, assessed
                                 with a <termref def="dt-context-posture"/> of <termref def="dt-grounded"/> (usage <termref def="dt-absorption"/>).</p>
                           </item>
                           <item>
                              <p>The <code>group-starting-with</code> or
                                    <code>group-ending-with</code> patterns if present; these are
                                    <termref def="dt-higher-order-operand">higher-order
                                    operands</termref> with usage <termref def="dt-inspection"/>.</p>
                           </item>

                        </olist>

                     </item>
                     <item>
                        <p>If there is a <code>group-by</code> attribute and the instruction is not a child of
                                 <elcode>xsl:fork</elcode>, then <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If there is a <code>group-by</code>
                              or
                           <code>group-adjacent</code> attribute that is not <termref def="dt-motionless"/>, then <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     
                     <item>
                        <p>If there is an <elcode>xsl:sort</elcode> child element 
                           and the instruction is not a child of <elcode>xsl:fork</elcode>, then <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     
                     

                     <item>
                        <p>If the <termref def="dt-posture"/> of the
                              <code>select</code> expression is <termref def="dt-crawling"/> and the
                              <termref def="dt-sweep"/> of the contained <termref def="dt-sequence-constructor"/> is <termref def="dt-consuming"/>, then
                              <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>

                     <item>
                        <p>Otherwise:</p>

                        <olist>
                           <item>
                              <p>The <termref def="dt-posture"/> of the instruction is the <termref def="dt-posture"/> of the contained <termref def="dt-sequence-constructor"/>, assessed with the <termref def="dt-context-posture"/>
                                 and context item type set to the <termref def="dt-posture"/> and
                                 type of the <code>select</code> expression.</p>
                           </item>

                           <item>
                              <p>The <termref def="dt-sweep"/> of the instruction is the wider of
                                 the <termref def="dt-sweep">sweeps</termref> of the
                                    <code>select</code> expression and the contained <termref def="dt-sequence-constructor"/>, where the ordering of
                                 increasing width is <termref def="dt-motionless"/>, <termref def="dt-consuming"/>, <termref def="dt-free-ranging"/>.</p>
                           </item>
                        </olist>

                        <note>
                           <p>Because the body of the <elcode>xsl:for-each-group</elcode>
                              instruction is a <termref def="dt-higher-order-operand"/> of the
                              instruction, any variable reference within the body that is bound to a
                                 <termref def="dt-streaming-parameter"/> of a containing <termref def="dt-stylesheet-function"/> will not be singular, which in many
                              cases will make the entire function non-streamable.</p>
                        </note>
                     </item>
                  </olist>

                  <note>
                     

                     <p>The above rules do not explicitly mention any
                        constraints on the presence or absence of a call on the
                           <function>current-group</function> function. In practice, however, this
                        plays an important role. In the most common case, the <code>select</code>
                        expression of <elcode>xsl:for-each-group</elcode> is likely to be striding,
                        for example an expression such as <code>select="*"</code>. Any call on
                           <function>current-group</function> associated with this
                           <elcode>xsl:for-each-group</elcode> instruction will ordinarily be
                           <termref def="dt-striding"/> and <termref def="dt-consuming"/>, which is
                        consistent with streaming provided there is only one such call, and if it
                        appears in a suitable context (for example, not within a predicate). If
                        there is more than one call, or if it appears in an unsuitable context (for
                        example, within a predicate), then this will have the same effect as
                        multiple appearances of other consuming expressions: the construct as a
                        whole will be free-ranging. These rules are not spelled out explicitly, but
                        rather emerge as a consequence of the general streamability rules.</p>
                  </note>


               </div4>
               <div4 id="streamability-xsl-fork">
                  <head>Streamability of <elcode>xsl:fork</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:fork</elcode> are the first of the following that applies:</p>

                  <olist>
                     <item>
                        <p>If there is a child <elcode>xsl:for-each-group</elcode> instruction, then
                           the <termref def="dt-posture"/> and the <termref def="dt-sweep"/> of that
                           instruction.</p>
                     </item>
                     <item>
                        <p>If there are no child <elcode>xsl:sequence</elcode> instructions (other than
                              <elcode>xsl:fallback</elcode>), then <termref def="dt-grounded"/> and
                              <termref def="dt-motionless"/>.</p>
                     </item>

                    
                     <item>
                        <p>If there is a child <elcode>xsl:sequence</elcode> instruction whose
                              <termref def="dt-posture"/> is not <termref def="dt-grounded"/>, then
                              <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>

                     <item>
                        <p>Otherwise, the <termref def="dt-posture"/> is <termref def="dt-grounded"/>, and the <termref def="dt-sweep"/> is the widest sweep of the
                              <elcode>xsl:sequence</elcode> child instructions.</p>
                     </item>

                  </olist>

                  <note>
                     <p>None of the branches of <elcode>xsl:fork</elcode> can return streamed nodes.
                        The reason for this is that <elcode>xsl:fork</elcode> has to assemble its
                        results in the correct order, and streamed nodes cannot be re-ordered.</p>

                     <p>The effect of the rules is that each of the child
                           <elcode>xsl:sequence</elcode> instructions can independently consume the
                        streamed input document, provided that the result of each child instruction
                        is <termref def="dt-grounded"/>.</p>

                     <p>Thus the following example is streamable:</p>

                     <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:fork&gt;
   &lt;xsl:sequence select="copy-of(author)"/&gt;
   &lt;xsl:sequence select="copy-of(editor)"/&gt;
&lt;/xsl:fork&gt;</eg>
                     <p>While the following is not streamable, because it returns streamed nodes in
                        an order that might not be document order:</p>

                     <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:fork&gt;
   &lt;xsl:sequence select="author"/&gt;
   &lt;xsl:sequence select="editor"/&gt;
&lt;/xsl:fork&gt;</eg>


                  </note>


               </div4>

               <div4 id="streamability-xsl-if">
                  <head>Streamability of <elcode>xsl:if</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:if</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>test</code> expression (usage <termref def="dt-inspection"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref def="dt-transmission"/>).</p>
                     </item>
                  </olist>
               </div4>

               <div4 id="streamability-xsl-iterate">
                  <head>Streamability of <elcode>xsl:iterate</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                        <elcode>xsl:iterate</elcode> instruction are the first of the following that
                     applies:</p>

                  <olist>
                     <item>
                        <p>If the <code>select</code> expression is <termref def="dt-grounded"/>,
                           then the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the
                              <elcode>xsl:iterate</elcode> instruction follow the <termref def="dt-general-streamability-rules"/>, with the <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> as follows:</p>
                        <olist>
                           <item>
                              <p>The <code>select</code> expression (the <termref def="dt-operand-usage"/> is irrelevant, but can be taken as
                                    <termref def="dt-inspection"/>)</p>
                           </item>

                           <item>
                              <p>The <code>select</code> expression or contained sequence
                                 constructor of any <elcode>xsl:param</elcode> children (usage
                                    <termref def="dt-navigation"/>)</p>
                           </item>

                           <item>
                              <p>The sequence constructor contained within the
                                    <elcode>xsl:iterate</elcode> instruction itself, assessed with
                                 its context item type and <termref def="dt-context-posture"/> based
                                 on the <code>select</code> expression (usage <termref def="dt-transmission"/>)</p>
                           </item>

                           <item>
                              <p>The <code>select</code> expression or contained sequence
                                 constructor of any child <elcode>xsl:on-completion</elcode>
                                 element, assessed with a context item type of <code>xs:error</code>
                                 and a <termref def="dt-context-posture"/> of <termref def="dt-roaming"/> to reflect the fact that any attempt to
                                 reference the context item within the
                                    <elcode>xsl:on-completion</elcode> element is an error (usage
                                    <termref def="dt-transmission"/>)</p>
                              <note>
                                 <p>The <code>on-completion</code>
                                    element can cause the instruction to become non-streamable if,
                                    for example, it contains a call on
                                       <function>current-group</function> or a variable reference
                                    bound to a <termref def="dt-streaming-parameter"/>.</p>
                              </note>
                           </item>

                        </olist>

                     </item>

                     <item>
                        <p>If there is an <elcode>xsl:param</elcode> child whose initializing
                              <code>select</code> expression or <termref def="dt-sequence-constructor"/> is not <termref def="dt-grounded"/>
                           and <termref def="dt-motionless"/>, then <termref def="dt-roaming"/> and
                              <termref def="dt-free-ranging"/>.</p>
                     </item>

                     <item>
                        <p>If there is an <elcode>xsl:on-completion</elcode> child whose
                              <code>select</code> expression or <termref def="dt-sequence-constructor"/> is not <termref def="dt-grounded"/>
                           and <termref def="dt-motionless"/>, then <termref def="dt-roaming"/> and
                              <termref def="dt-free-ranging"/>.</p>
                     </item>

                     <item>
                        <p>If the <termref def="dt-posture"/> of the
                              <code>select</code> expression is <termref def="dt-crawling"/> and the
                              <termref def="dt-sweep"/> of the contained <termref def="dt-sequence-constructor"/> is <termref def="dt-consuming"/>, then
                              <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>

                     <item>
                        <p>Otherwise:</p>

                        <olist>
                           <item>
                              <p>The <termref def="dt-posture"/> of the instruction is the <termref def="dt-posture"/> of the contained <termref def="dt-sequence-constructor"/>, assessed with the <termref def="dt-context-posture"/>
                                 and context item type set to the <termref def="dt-posture"/> and
                                 type of the <code>select</code> expression.</p>
                           </item>

                           <item>
                              <p>The <termref def="dt-sweep"/> of the instruction is the wider of
                                 the <termref def="dt-sweep">sweeps</termref> of the <code>select</code> expression and the
                                    contained <termref def="dt-sequence-constructor"/>,
                                 where the ordering of increasing width is <termref def="dt-motionless"/>, <termref def="dt-consuming"/>, <termref def="dt-free-ranging"/>.</p>
                           </item>
                        </olist>
                     </item>
                  </olist>

                  <note>
                     <p>If any <elcode>xsl:break</elcode> or <elcode>xsl:next-iteration</elcode>
                        instructions appear within the sequence constructor, their <termref def="dt-posture"/> and <termref def="dt-sweep"/> will be assessed in the
                        course of evaluating the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the sequence constructor, by reference to the rules
                        in <specref ref="streamability-xsl-break"/> and <specref ref="streamability-xsl-next-iteration"/> respectively.</p>
                  </note>

                  <note>
                     <p>Because the body of the <elcode>xsl:iterate</elcode> instruction is a
                           <termref def="dt-higher-order-operand"/> of the instruction, any variable
                        reference within the body that is bound to a <termref def="dt-streaming-parameter"/> of a containing <termref def="dt-stylesheet-function"/> will not be singular, which in many cases
                        will make the entire function non-streamable.</p>
                  </note>



                  <!--
                        
                        <p>The operands of the <elcode>xsl:iterate</elcode> instruction are 
                           divided into three groups, as follows.</p>
                        
                        <olist>
                        <item><p>The outer-focus operands are the following (these
                           are all evaluated with the same focus as the <elcode>xsl:iterate</elcode> 
                           instruction itself):</p>
                        
                        <ulist>
                           <item><p>The <code>select</code> expression</p></item>
                           <item><p>Any <code>select</code> expression of a child 
                              <elcode>xsl:param</elcode> element;</p></item>
                           <item><p>Any <termref def="dt-sequence-constructor"/> appearing as the content of a 
                              child <elcode>xsl:param</elcode> element.</p></item>
                        </ulist></item>
                        
                        <item><p>The inner-focus operands of the <elcode>xsl:iterate</elcode> instruction are the
                           following (these are all evaluated with a focus based on the sequence
                           selected by the <code>select</code> expression):</p>
                        
                        <ulist>
                           <item><p>The contained <termref def="dt-sequence-constructor"/>
                           (including any contained <elcode>xsl:break</elcode> instructions).</p></item>
                           
                        </ulist></item>
                        
                        <item><p>The no-focus operands of the <elcode>xsl:iterate</elcode> instruction are the
                        following (these are all evaluated with an absent focus):</p>
                        
                        <ulist>
                           <item><p>The <code>select</code> expression of any child 
                              <elcode>xsl:on-completion</elcode> element;</p></item>
                           <item><p>The <termref def="dt-sequence-constructor"/> appearing as the content of any 
                              child <elcode>xsl:on-completion</elcode> element.</p></item>
                        </ulist></item>
                           
                        </olist>
                        
                        <p>The <termref def="dt-sweep">sweep</termref> of the instruction is the
                        first of the following that applies:</p>
                        
                        <olist>
                           <item><p>If all outer-focus operands are <termref def="dt-motionless"/>, and if no operand
                              contains (at any level) a reference to a variable declared in the <code>bind-group</code>
                              attribute of an <elcode>xsl:for-each-group</elcode> instruction that is an ancestor of this
                              <elcode>xsl:iterate</elcode> instruction, then <termref def="dt-motionless"/>.</p></item>
                           <item diff="del" at="Q"><p>If all the following conditions are satisfied, then group-consuming:</p>
                              <olist>
                                 <item><p>the contained sequence constructor is <termref def="dt-motionless"/> or <termref def="dt-consuming"/></p></item>
                                 <item><p>the <code>select</code> expression is a variable reference
                                    to a variable declared in the <code>bind-group</code> attribute of
                                    the innermost ancestor <elcode>xsl:for-each-group</elcode>
                                    instruction.</p></item>
                                 <item><p>all other inner-focus and outer-focus operands are <termref def="dt-motionless"/>.</p></item>
                              </olist>
                           </item>
                           <item><p>If all the following conditions are satisfied, then <termref def="dt-consuming"/>:</p>
                              <olist>
                                 <item><p>the contained sequence constructor is <termref def="dt-motionless"/> or <termref def="dt-consuming"/></p></item>
                                 <item><p>the <code>select</code> expression has 
                                    <termref def="dt-striding"/> <termref def="dt-posture"/>.</p></item>
                                 <item><p>all other inner-focus and outer-focus operands are <termref def="dt-motionless"/>.</p></item>
                              </olist>
                           </item>
                           <item><p>Otherwise, <termref def="dt-free-ranging"/>.</p></item>
                        </olist>
                        <note><p>It is a consequence of the rules given that if an <elcode>xsl:iterate</elcode>
                        instruction is to be streamable, then all related <elcode>xsl:param</elcode>, 
                        <elcode>xsl:on-completion</elcode>,
                        <elcode>xsl:break</elcode>, and <elcode>xsl:next-iteration</elcode> elements
                        must be <termref def="dt-motionless"/>.</p></note>
                        -->
               </div4>
               <div4 id="streamability-xsl-map">
                  <head>Streamability of <elcode>xsl:map</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the <elcode>xsl:map</elcode> instruction are determined
                     by the first of the following that applies:</p>

                  <olist>
                     <item>
                        <p>If the sequence constructor within the instruction consists exclusively
                           of <elcode>xsl:map-entry</elcode> instructions (and
                              <elcode>xsl:fallback</elcode> instructions, which are ignored),
                           then:</p>
                        <olist>
                           <item>
                              <p>If any of these <elcode>xsl:map-entry</elcode> children is <termref def="dt-roaming"/> or <termref def="dt-free-ranging"/>, then
                                    <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>;</p>
                           </item>
                           <item>
                              <p>Otherwise, <termref def="dt-grounded"/> and the widest sweep of the
                                    <elcode>xsl:map-entry</elcode> children.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>Otherwise, the <termref def="dt-posture"/> and <termref def="dt-sweep"/>
                           of the <elcode>xsl:map</elcode> instruction are the posture and sweep of
                           the contained <termref def="dt-sequence-constructor"/>.</p>
                     </item>
                  </olist>

                  <note>
                     <p>See discussion in <specref ref="maps-streaming"/>.</p>
                     <p>The effect of the rules is that it is possible to compute multiple map
                        entries in a single pass of the streamed input document. For example, the
                        following is streamable:</p>
                     <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:map&gt;
  &lt;xsl:map-entry key="'authors'" select="copy-of(author)"/&gt;
  &lt;xsl:map-entry key="'editors'" select="copy-of(editor)"/&gt;
&lt;/xsl:map&gt;  
</eg>
                     <p>The call on <function>copy-of</function> is necessary to ensure that the
                        content of the map entry is grounded; it is not possible to create a map
                        whose entries contain references to streamed nodes.</p>
                  </note>
               </div4>

               <div4 id="streamability-xsl-map-entry">
                  <head>Streamability of <elcode>xsl:map-entry</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:map-entry</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>key</code> expression (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-navigation"/>)</p>
                        <note>
                           <p>This effectively means that the <code>select</code>
                              expression must not return nodes from a streamed input document.</p>
                        </note>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/>
                           (usage <termref def="dt-navigation"/>).</p>
                     </item>
                  </olist>
               </div4>

               <div4 id="streamability-xsl-merge">
                  <head>Streamability of <elcode>xsl:merge</elcode></head>

                  <note>
                     <p>This section is concerned with the (not very interesting) impact of the
                           <elcode>xsl:merge</elcode> instruction on the streamability of its
                        containing template rule or <elcode>xsl:source-document</elcode> instruction.</p>
                     <p>For the (more important) rules concerning the way in which
                           <elcode>xsl:merge</elcode> performs streamed processing of its own
                        inputs, see <specref ref="streamable-merging"/>.</p>
                  </note>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of <elcode>xsl:merge</elcode> are as follows:</p>

                  <olist>
                     <item>
                        <p>If every <elcode>xsl:merge-source</elcode> child element satisfies all
                           the following conditions:</p>
                        <olist>
                           <item>
                              <p>The expression in the <code>for-each-item</code> attribute is
                                 either absent, or <termref def="dt-grounded"/> and <termref def="dt-motionless"/>;</p>
                           </item>
                           <item>
                              <p>The expression in the <code>for-each-source</code> attribute is
                                 either absent, or <termref def="dt-grounded"/> and <termref def="dt-motionless"/>;</p>
                           </item>
                           <item>
                              <p>Either at least one of the attributes <code>for-each-item</code>
                                 and <code>for-each-source</code> is present, or the expression in
                                 the <code>select</code> attribute is <termref def="dt-grounded"/>
                                 and <termref def="dt-motionless"/></p>
                           </item>
                        </olist>
                        <p>then the <elcode>xsl:merge</elcode> instruction is <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                     </item>
                     <item>
                        <p>Otherwise, the <elcode>xsl:merge</elcode> instruction is 
                           <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                  </olist>


                  <!--
                  <p>If all <elcode>xsl:merge-source</elcode> children are <termref def="dt-motionless"/>
                     then the instruction is <phrase diff="add" at="R-bug24535"><termref def="dt-grounded"/> and</phrase> 
                     <termref def="dt-motionless"/>.</p>
                  <p>Otherwise, the instruction is <phrase diff="add" at="R-bug24535"><termref def="dt-roaming"/> and</phrase> <termref def="dt-free-ranging"/>.</p>
                     
                     -->

               </div4>

               <div4 id="streamability-xsl-message">
                  <head>Streamability of <elcode>xsl:message</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:message</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>terminate</code> attribute value template (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>error-code</code> attribute value template (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>

               <div4 id="streamability-xsl-namespace">
                  <head>Streamability of <elcode>xsl:namespace</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:namespace</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>name</code> attribute value template (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>

               <div4 id="streamability-xsl-next-iteration">
                  <head>Streamability of <elcode>xsl:next-iteration</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:next-iteration</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>select</code> expression or <termref def="dt-sequence-constructor"/> content of any contained
                              <elcode>xsl:with-param</elcode> child element: its <termref def="dt-operand-usage"/> is the <termref def="dt-type-determined-usage"/> based on the type declared in the
                              <code>xsl:with-param/@as</code> attribute, or the
                              <code>xsl:param/@as</code> attribute of the corresponding parameter on
                           the containing <elcode>xsl:iterate</elcode> instruction, whichever is
                           more restrictive, defaulting to <code>item()*</code> if both are
                           absent.</p>
                     </item>
                  </olist>
               </div4>

               <div4 id="streamability-xsl-next-match">
                  <head>Streamability of <elcode>xsl:next-match</elcode></head>

                  <p>The rules are the same as for <elcode>xsl:apply-imports</elcode>: see <specref ref="streamability-xsl-apply-imports"/>.</p>
               </div4>

               <div4 id="streamability-xsl-number">
                  <head>Streamability of <elcode>xsl:number</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:number</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>

                  <olist>
                     <item>
                        <p>The <code>value</code> attribute if present: usage <termref def="dt-absorption"/></p>
                     </item>
                     <item>
                        <p>The <code>select</code> attribute if there is
                           no <code>value</code> attribute, defaulting to the context item
                           expression (<code>.</code>) if the <code>select</code> attribute is also
                           absent: usage <termref def="dt-navigation"/></p>
                     </item>
                     <item>
                        <p>The attribute value templates in the <code>format</code>,
                              <code>lang</code>, <code>letter-value</code>, <code>ordinal</code>,
                              <code>start-at</code>, <code>grouping-separator</code>, and
                              <code>grouping-size</code> attributes (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>from</code> and <code>count</code> patterns if present. These can be treated as <termref def="dt-higher-order-operand">higher-order operands</termref> with
                              usage <termref def="dt-inspection"/>, though neither of these
                              properties affects the outcome.</p>
                     </item>
                  </olist>



                  <note>
                     <p>The effect of these rules is that <elcode>xsl:number</elcode> can be used
                        for formatting of numbers supplied directly using the <code>value</code>
                        attribute, and also for numbering of nodes in a non-streamed document, but
                        it cannot be used for numbering streamed nodes.</p>
                     <p>In practice the rules depend very little on the <code>from</code> and
                           <code>count</code> patterns. This is because when the instruction is
                        applied to a streamed node, the instruction will be <termref def="dt-free-ranging"/> regardless of these patterns; while if it is
                        applied to a grounded node or atomic value, the instruction will normally be
                           <termref def="dt-motionless"/> regardless of the values of these
                        patterns. The pattern does matter,
                           however, if it contains a variable reference bound to a <termref def="dt-streaming-parameter"/>;
                           because such a reference occurs within a <termref def="dt-higher-order-operand"/> of the <elcode>xsl:number</elcode>
                           instruction, its presence automatically makes the variable reference
                              <termref def="dt-free-ranging"/>, which in turn ensures that the
                           containing stylesheet function is not <termref def="dt-guaranteed-streamable"/>.</p>
                  </note>
               </div4>

               <div4 id="streamability-xsl-on-empty">
                  <head>Streamability of <elcode>xsl:on-empty</elcode></head>

                  <p>The streamability rules for the <elcode>xsl:on-empty</elcode> instruction are
                     the same as the rules for <elcode>xsl:sequence</elcode>: see <specref ref="streamability-xsl-sequence"/>.</p>

                  <note>
                     <p>The streamability rules for a sequence constructor containing an
                           <elcode>xsl:on-empty</elcode> instruction are given in <specref ref="classifying-sequence-constructors"/>.</p>
                  </note>
               </div4>

               <div4 id="streamability-xsl-on-non-empty">
                  <head>Streamability of <elcode>xsl:on-non-empty</elcode></head>

                  <p>The streamability rules for the <elcode>xsl:on-non-empty</elcode> instruction
                     are the same as the rules for <elcode>xsl:sequence</elcode>: see <specref ref="streamability-xsl-sequence"/>.</p>

                  <note>
                     <p>The streamability rules for a sequence constructor containing an
                           <elcode>xsl:on-non-empty</elcode> instruction are given in <specref ref="classifying-sequence-constructors"/>.</p>
                  </note>
               </div4>

               <div4 id="streamability-xsl-perform-sort">
                  <head>Streamability of <elcode>xsl:perform-sort</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:perform-sort</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>

                  <olist>
                     <item>
                        <p>The expression in the <code>select</code> attribute: usage <termref def="dt-navigation"/> (because order is not preserved)</p>
                     </item>
                     <item>
                        <p>The expressions in the attribute value templates of
                              <elcode>xsl:sort</elcode> child elements: usage <termref def="dt-absorption"/></p>
                     </item>
                     <item>
                        <p>The expression in the <code>select</code> attribute or contained sequence constructor in child
                              <elcode>xsl:sort</elcode> child elements, with usage <termref def="dt-absorption"/>, assessed with <termref def="dt-context-posture"/> based on the
                           expression in the <code>xsl:perform-sort/@select</code> attribute.</p>
                     </item>
                  </olist>

                  <note>
                     <p>In practice, the <elcode>xsl:perform-sort</elcode> instruction cannot be
                        used to sort nodes from the streamed input document, but it can be used to
                        sort atomic values or <termref def="dt-grounded"/> nodes, for example a copy
                        of nodes from the streamed document made using the
                           <function>copy-of</function> function.</p>
                  </note>

               </div4>

               <div4 id="streamability-xsl-processing-instruction">
                  <head>Streamability of <elcode>xsl:processing-instruction</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:processing-instruction</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>name</code> attribute value template (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>

               <div4 id="streamability-xsl-result-document">
                  <head>Streamability of <elcode>xsl:result-document</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:result-document</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>href</code> attribute value template (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The attribute value templates containing serialization properties (usage
                              <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>

               <div4 id="streamability-xsl-sequence">
                  <head>Streamability of <elcode>xsl:sequence</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:sequence</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>select</code> attribute value template (usage <termref def="dt-transmission"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref def="dt-transmission"/>).</p>
                     </item>
                  </olist>
               </div4>

               <div4 id="streamability-xsl-stream">
                  <head>Streamability of <elcode>xsl:source-document</elcode></head>

                  <note>
                     <p>The concern here is with the impact of <elcode>xsl:source-document</elcode> on any
                        streaming template, or ancestor <elcode>xsl:source-document</elcode> instruction, and
                        not with the streamed processing of the document accessed using the
                           <code>xsl:source-document/@href</code> attribute.</p>
                     <p>The streamability of the document opened by the <elcode>xsl:source-document</elcode>
                        instruction is not assessed using the rules in this section; it depends only
                        on the streamability properties of the contained sequence constructor, as
                        described in <specref ref="source-document-instruction"/></p>
                  </note>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:source-document</elcode> are the first of the following that applies:</p>

                  <olist>
                     <item>
                        <p>If the contained sequence constructor contains, at any depth, a call on the
                                 <function>current-group</function> function whose nearest
                              containing <elcode>xsl:for-each-group</elcode> instruction
                           exists and is an ancestor of the <elcode>xsl:source-document</elcode> instruction,
                           then <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>

                     <item>
                        <p>If the contained sequence constructor contains, at any depth, a call on the
                                 <function>current-merge-group</function> function whose nearest
                              containing <elcode>xsl:merge</elcode> instruction exists and
                           is an ancestor of the <elcode>xsl:source-document</elcode> instruction, then
                              <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>

                     <item>
                        <p>Otherwise, the <termref def="dt-posture"/> is <termref def="dt-grounded"/> and the <termref def="dt-sweep"/> is the <termref def="dt-sweep"/> of
                           the <code>href</code> attribute value template.</p>
                     </item>
                  </olist>

                  <!--<note>
                     <p>The effective prohibition on grouping variable references is largely to
                        avoid complicating the analysis. It means that posture and sweep for the
                        constructs within <elcode>xsl:source-document</elcode> need to be computed only with
                        respect to the <elcode>xsl:source-document</elcode> instruction itself, and not with
                        respect to the containing template, or an outer <elcode>xsl:source-document</elcode>
                        instruction.</p>
                  </note>-->




               </div4>

               <div4 id="streamability-xsl-text">
                  <head>Streamability of <elcode>xsl:text</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:text</elcode> follow the <termref def="dt-general-streamability-rules"/>. There are no operands.</p>

                  <note>
                     <p>The instruction is therefore <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                  </note>

               </div4>

               <div4 id="streamability-xsl-try">
                  <head>Streamability of <elcode>xsl:try</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep">sweep</termref> of the <elcode>xsl:try</elcode> instruction
                     follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and <termref def="dt-operand-usage">usages</termref> are as follows:</p>

                  <olist>
                     <item>
                        <p>The <code>select</code> expression or contained <termref def="dt-sequence-constructor"/> of the <elcode>xsl:try</elcode>
                           element. This has <termref def="dt-operand-usage"/>
                           <termref def="dt-transmission"/>. (Note that the
                              <elcode>xsl:catch</elcode> children of <elcode>xsl:try</elcode> are
                           not part of the sequence constructor and therefore not part of this
                           operand.)</p>
                     </item>
                     <item>
                        <p>The <code>select</code> expressions and/or contained <termref def="dt-sequence-constructor"/> of the <elcode>xsl:catch</elcode>
                           child elements. These form a <termref def="dt-choice-operand-group"/>
                           with <termref def="dt-operand-usage"/>
                           <termref def="dt-transmission"/>.</p>
                     </item>
                  </olist>

                  <note>
                     <p>The overall effect of these rules is that either the
                           <elcode>xsl:try</elcode> branch or the <elcode>xsl:catch</elcode> branch
                        may consume the streamed input, but not both. If there is more than one
                           <elcode>xsl:catch</elcode> branch then they may all consume the input,
                        since only one of these branches can be evaluated.</p>
                  </note>


               </div4>

               <div4 id="streamability-xsl-value-of">
                  <head>Streamability of <elcode>xsl:value-of</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:value-of</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref> are as follows:</p>
                  <olist>
                     <item>
                        <p>The <code>select</code> expression (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The <code>separator</code> attribute value template (usage <termref def="dt-absorption"/>)</p>
                     </item>
                     <item>
                        <p>The contained <termref def="dt-sequence-constructor"/> (usage <termref def="dt-absorption"/>).</p>
                     </item>
                  </olist>
               </div4>

               <div4 id="streamability-xsl-variable">
                  <head>Streamability of <elcode>xsl:variable</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                        <elcode>xsl:variable</elcode> follow the <termref def="dt-general-streamability-rules"/>. The <termref def="dt-operand-role">operand roles</termref> and their <termref def="dt-operand-usage">usages</termref>
                     depend on the <code>as</code> attribute,
                      as follows:</p>
                  <olist>
                     <item>
                        <p>If there is an <code>as</code> attribute, then:</p>
                        <olist>
                           <item>
                              <p>The <code>select</code> expression (with <termref def="dt-type-determined-usage"/> based on the <code>as</code>
                                 attribute).</p>
                           </item>
                           <item>
                              <p>The contained <termref def="dt-sequence-constructor"/> (with
                                    <termref def="dt-type-determined-usage"/> based on the
                                    <code>as</code> attribute).</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>If there is no <code>as</code> attribute,
                           then:</p>
                        <olist>
                           <item>
                              <p>The <code>select</code> expression (usage <termref def="dt-navigation"/>).</p>
                           </item>
                           <item>
                              <p>The contained <termref def="dt-sequence-constructor"/> (usage
                                    <termref def="dt-absorption"/>).</p>
                           </item>
                        </olist>
                     </item>
                  </olist>

                  <note>
                     <p>The effect of the initialization expression having usage <termref def="dt-navigation"/> is that it is not possible in streamable constructs
                        to bind a variable to a node in a streamed document.</p>
                  </note>
               </div4>

               <div4 id="streamability-xsl-where-populated">
                  <head>Streamability of <elcode>xsl:where-populated</elcode></head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of an
                        <elcode>xsl:where-populated</elcode> instruction are the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the contained <termref def="dt-sequence-constructor"/>.</p>
               </div4>





            </div3>

            <div3 id="streamable-stylesheet-functions">
               <head>Classifying Stylesheet Functions</head>

               <p>Under specific conditions, described in this section, a stylesheet function can be
                  used to process nodes from a <termref def="dt-streamed-document">streamed input
                     document</termref>.</p>

               <p><termdef id="dt-streamability-category" term="streamability category">Stylesheet
                     functions belong to one of a number of <term>streamability categories</term>:
                     the choice of category characterizes the way in which the function handles
                     streamed input.</termdef></p>


               <p>The <termref def="dt-streamability-category">category</termref> to which a
                  function belongs is declared in the <code>streamability</code> attribute of the
                     <elcode>xsl:function</elcode> declaration, and defaults to
                     <code>unclassified</code>.</p>

               <p>The streamability categories defined in this specification are:
                     <code>unclassified</code>, <code>absorbing</code>, <code>inspection</code>,
                     <code>filter</code>, <code>shallow-descent</code>, <code>deep-descent</code>,
                  and <code>ascent</code>. It is also possible to specify the streamability category
                  as a QName in an <termref def="dt-implementation-defined"/> namespace, in which
                  case the streamability rules are <termref def="dt-implementation-defined"/>; a
                  processor that does not recognize a category defined in this way
                     <rfc2119>must</rfc2119> analyze the function as if
                     <code>streamability="unclassified"</code> were specified. </p>

               <imp-def-feature id="idf-ext-streamingcategories">Additional <termref def="dt-streamability-category">streamability categories</termref> for
                  stylesheet functions may be defined by an implementation.</imp-def-feature>

               <p>A stylesheet function is <termref def="dt-declared-streamable"/> if the
                     <elcode>xsl:function</elcode> declaration has a <code>streamability</code>
                  attribute with a value other than <code>unclassified</code>.</p>

               <p>The only <termref def="dt-streamability-category">category</termref> permitted for
                  a zero-arity function (one with no arguments) is <code>unclassified</code>. All
                  function calls to zero-arity stylesheet functions are <termref def="dt-grounded"/>
                  and <termref def="dt-motionless"/>.</p>



               <p>In general (subject to more detailed rules below), a node belonging to a <termref def="dt-streamed-document"/> can be present within the value of an argument of
                  a call on a <termref def="dt-stylesheet-function"/> only if one of the following
                  conditions is true:</p>

               <olist>
                  <item>
                     <p>The stylesheet function is <termref def="dt-declared-streamable"/>, and the
                        argument in question is the first argument of the function call.</p>
                  </item>
                  <item>
                     <p>The corresponding <termref def="dt-function-parameter"/> is declared with a
                           <termref def="dt-required-type"/> that triggers <termref def="dt-atomization">atomization</termref> of any supplied node.</p>
                  </item>
               </olist>

               <p><termdef id="dt-streaming-parameter" term="streaming parameter">The first <termref def="dt-function-parameter">parameter</termref> of a <termref def="dt-declared-streamable"/>
                     <termref def="dt-stylesheet-function"/> is referred to as a <term>streaming
                        parameter</term>.</termdef></p>

               <note>
                  <p>If a stylesheet function returns streamed nodes, then these nodes can only
                     derive from streamed nodes passed in an argument to the function. This is
                     because streamed nodes cannot be bound to global variables, and they cannot be
                     returned by an <elcode>xsl:source-document</elcode> instruction within the function body
                     (the result of <elcode>xsl:source-document</elcode> is always grounded).</p>
               </note>



               <p>The choice of <termref def="dt-streamability-category">category</termref> places
                  constraints on the function body, and also on calls to the function. These constraints
                  are defined below, separately for each category. A function is <termref def="dt-guaranteed-streamable"/> only if the constraints are satisfied,
                and a static function call is
               guaranteed-streamable only if the function is guaranteed-streamable and the
               function call itself satisfies the constraints for the chosen category.</p>
   
   <p>Dynamic function calls are <termref def="dt-guaranteed-streamable"/> only
   in trivial cases, for example where the function signature indicates that an argument is required to
   be a text node or an attribute node. For details, see <specref ref="streamability-of-dynamic-function-calls"/>.</p>

               <p>The constraints on the function body are expressed in terms of the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the function result. The
                     <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the function
                  result are the <termref def="dt-type-adjusted-posture-and-sweep"/> of the <termref def="dt-sequence-constructor"/> contained within the
                     <elcode>xsl:function</elcode> element, given the declared return type of the
                  function, which defaults to <code>item()*</code>.</p>

               <note>
                  <p>Determining the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                     the function result requires first determining the <termref def="dt-posture"/>
                     and <termref def="dt-sweep"/> of the contained <termref def="dt-sequence-constructor"/>, which is done according to the rules in
                        <specref ref="classifying-sequence-constructors"/>. This in turn will
                     usually involve examination of variable references that are bound to the
                     function’s parameters. The analysis of these variable references is described
                     in <specref ref="streamability-of-variable-references"/>.</p>
               </note>



               <p>If the function is <termref def="dt-declared-streamable"/> but does not satisfy
                  the constraints that make it <termref def="dt-guaranteed-streamable"/>, the
                  consequences are explained in <specref ref="streamability-guarantees"/>.</p>

               <p>If a stylesheet function is overridden in another package (using
                     <elcode>xsl:override</elcode>), then the overriding stylesheet function must
                  belong to the same <termref def="dt-streamability-category"/> as the function that
                  it overrides. This ensures that overriding a function cannot affect the
                  streamability of calls to that function.</p>

               <p>The rules for each <termref def="dt-streamability-category"/> are given in the
                  following sections.</p>

               <div4 id="category-unclassified">
                  <head>Streamability Category: unclassified</head>
                  <p><term>Informal description:</term> Functions in this category cannot be called
                     with streamed nodes supplied in an argument, unless the function signature
                     causes such nodes to be atomized.</p>
                  
                  <p><term>Rules for the function signature:</term> there are no constraints.</p>
                  
                  <p><term>Rules for the function body:</term> there are no constraints.</p>
                  <p><term>Rules for references to the streaming
                        parameter:</term> not applicable, because there is no streaming
                     parameter.</p>
                  <p><term>Rules for function calls:</term> the <termref def="dt-general-streamability-rules"/> apply. The operands are the
                     expressions appearing in the argument list of the function call, with the
                        <termref def="dt-operand-usage"/> of each operand being the <termref def="dt-type-determined-usage"/> based on the declared type of the
                     corresponding parameter in the function signature. </p>
                  <example>
                     <head>An unclassified stylesheet function that accepts nodes</head>
                     <p>The <termref def="dt-streamability-category"/> is
                        <code>unclassified</code>.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:exclude-first" as="node()*"&gt;
  &lt;xsl:param name="nodes" as="node()*"/&gt;
  &lt;xsl:sequence select="$nodes[not(node-name() = preceding-sibling::*/node-name())]"/&gt;
&lt;/xsl:function&gt;  
                        </eg>
                     <p>The effect of the rules is that a call to this function is guaranteed
                        streamable if and only if the sequence supplied as the value of the
                           <code>$nodes</code> argument is <termref def="dt-grounded"/> (that is, it
                        contains no streamed nodes).</p>
                  </example>

                  <example>
                     <head>An unclassified stylesheet function that accepts atomic values</head>
                     <p>The <termref def="dt-streamability-category"/> is
                        <code>unclassified</code>.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:min" as="xs:integer"&gt;
  &lt;xsl:param name="arg0" as="xs:integer"/&gt;
  &lt;xsl:param name="arg1" as="xs:integer"/&gt;
  &lt;xsl:sequence select="min(($arg0, $arg1))"/&gt;
&lt;/xsl:function&gt;  
                        </eg>
                     <p>The effect of the rules is that a call to this function is streamable under
                        similar circumstances to those that apply to a binary operator such as
                           <code>+</code>. For example, a call is streamable if two atomic values
                        are supplied, or if two attribute nodes are supplied, whether from streamed
                        or unstreamed documents. The main constraint is that it is not permitted for
                        both arguments to be consuming; for example, if the context node is a node
                        in a streamed document, then the function call <code>f:min((price,
                           discount))</code> would not be guaranteed streamable.</p>
                  </example>
               </div4>

               <div4 id="category-absorbing">
                  <head>Streamability Category: absorbing</head>
                  <p><term>Informal description:</term> Functions in this category typically read
                     the subtrees rooted at the node or nodes supplied in the first argument. These
                     subtrees must not overlap each other. The function must not return any streamed
                     nodes.</p>
                  <p><term>Rules for the function signature:</term> there are no constraints.</p>
                  
                  <p><term>Rules for the function body:</term> 
                     For the function to be <termref def="dt-guaranteed-streamable"/>, the 
                     <termref def="dt-type-adjusted-posture-and-sweep">type-adjusted posture</termref> of
                     the function body with respect to the declared return type must be <termref def="dt-grounded"/>, and the 
                     <termref def="dt-type-adjusted-posture-and-sweep">type-adjusted sweep</termref> of the function body 
                     with respect to the declared return type must be <termref def="dt-motionless"/> or <termref def="dt-consuming"/>.</p>
                  
                  <p><term>Rules for references to the streaming
                        parameter:</term> If the declared type of the <termref def="dt-streaming-parameter"/> permits more than one node, then a variable
                     reference referring to the streaming parameter is <termref def="dt-striding"/>
                     and <termref def="dt-consuming"/>. Otherwise such a variable reference is
                        <termref def="dt-striding"/> and <termref def="dt-motionless"/>.</p>

                  <p><term>Rules for function calls:</term> If the first argument is <termref def="dt-crawling"/> then the function call is <termref def="dt-roaming"/>
                     and <termref def="dt-free-ranging"/>; otherwise the <termref def="dt-general-streamability-rules"/> apply. The operands are the
                     expressions appearing in the argument list of the function call. The <termref def="dt-operand-usage"/> of the first argument is <termref def="dt-absorption"/>; the operand usage of other arguments is the <termref def="dt-type-determined-usage"/> based on the declared type of the
                     corresponding <termref def="dt-parameter"/> in the function signature. </p>
                  <note>
                     <p>Absorbing functions perform an operation analogous to atomization on their
                        supplied arguments, in that they typically use information from the subtree
                        rooted at a node to compute atomic values. Atomization can be seen as a
                        special case of absorption. Calls on absorbing functions are therefore, from
                        a streamability point of view, equivalent to calls on functions that
                        implicitly atomize the supplied nodes.</p>
                     <p>An important difference, however, is that whereas atomization can be applied
                        to any argument of a function call, absorption applies only to the first
                        argument.</p>
                     <p>Another difference is that atomization is allowed on a sequence of nodes in
                           <termref def="dt-crawling"/> posture, whereas generalized absorption is
                        not. Within a sequence, there may be nodes whose subtrees overlap, and the
                        code for atomization is expected to handle this, but more general absorption
                        operations are not. To write a function that accepts streamed nodes and
                        atomizes them, it is better to use the streamability category
                           <code>unclassified</code>, and to declare the first argument with an
                        atomic type, rather than using the category <code>absorbing</code> which
                        allows more general processing, but restricts what can be supplied in the
                        argument to the function call.</p>
                  </note>
                  <example>
                     <head>An absorbing stylesheet function</head>
                     <p>The following function is declared as absorbing, and the function body meets
                        the rules for this category because it makes downward selections only, and
                        returns an atomic value.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:count-descendants" as="xs:integer" streamability="absorbing"&gt;
  &lt;xsl:param name="input" as="node()*"/&gt;
  &lt;xsl:sequence select="count($input//*)"/&gt;
&lt;/xsl:function&gt;  
                        </eg>
                     <p>The effect of the rules is that a call to this function is <termref def="dt-guaranteed-streamable"/> provided that the sequence supplied as
                        the value of the <code>$input</code> argument is <termref def="dt-motionless"/> or <termref def="dt-consuming"/>, and is either
                           <termref def="dt-grounded"/> or <termref def="dt-striding"/>.</p>
                  </example>
                  <example>
                     <head>An absorbing stylesheet function with two arguments</head>
                     <p>The following function is declared as absorbing, and the function body meets
                        the rules for this category because it makes downward selections only from
                        the node supplied as the first argument, and returns an atomic value.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:compare-size" as="xs:integer" streamability="absorbing"&gt;
  &lt;xsl:param name="input0" as="node()"/&gt;
  &lt;xsl:param name="input1" as="node()"/&gt;
  &lt;xsl:sequence select="count($input0//*) - count($input1//*)"/&gt;
&lt;/xsl:function&gt;</eg>
                     <p>This function takes two nodes as its arguments. Some examples of function
                        calls include: </p>
                     <ulist>
                        <item>
                           <p>Streamable: <code>f:compare-size(a, b)</code> where <code>a</code> is
                              an element in a streamed document and <code>b</code> is an element in
                              an unstreamed document</p>
                        </item>
                        <item>
                           <p>Streamable: <code>f:compare-size(a, b)</code> where <code>a</code> and
                                 <code>b</code> are both elements in unstreamed documents</p>
                        </item>
                        <item>
                           <p>Not streamable: <code>f:compare-size(a, b)</code> where <code>a</code>
                              is an element in an unstreamed document and <code>b</code> is an
                              element in a streamed document</p>
                        </item>
                     </ulist>
                     <p>The reason for the asymmetry is that for the first
                     argument the <termref def="dt-operand-usage"/> is <termref def="dt-absorption"/>,
                     while for the second argument it is <termref def="dt-navigation"/>. It is a consequence
                     of the <termref def="dt-general-streamability-rules"/> that when streamed nodes are
                     supplied to an operand with usage navigation, the resulting expression is
                     <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                  </example>
                  <example>
                     <head>A recursive absorbing stylesheet function</head>
                     <p>The following function is declared as absorbing, and the function body meets
                        the rules for this category. Analysis of the function body reveals that it
                        is grounded and consuming; to establish this, it is necessary to analyze the
                        recursive call <code>f:outline(*)</code>, and this is possible because it is
                        known to be a call on an absorbing stylesheet function.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:outline" as="xs:string" streamability="absorbing"&gt;
  &lt;xsl:param name="input" as="element()*"/&gt;
  &lt;xsl:value-of select="$input ! (name() || '(' || f:outline(*) || ')')" 
                separator=", "/&gt;
&lt;/xsl:function&gt;</eg>
                     <p>The effect of the rules is that a call to this function is guaranteed
                        streamable in the typical case where the sequence supplied as the value of
                        the <code>$input</code> argument is <termref def="dt-striding"/> and
                           <termref def="dt-consuming"/>.</p>

                  </example>
               </div4>

               <div4 id="category-inspection">
                  <head>Streamability Category: inspection</head>
                  <p><term>Informal description:</term> Functions in this category typically return
                     properties of the node supplied in the first argument, where these properties
                     can be determined without advancing the input stream. This allows access to
                     properties such as the name and type of each node, and also to its ancestors,
                     attributes, and namespaces. </p>
                  
                  <p><term>Rules for the function signature:</term> If
                     the declared type of the streaming parameter permits more than one node,
                     the function is not <termref def="dt-guaranteed-streamable"/>.</p>
                  
                  <p><term>Rules for the function body:</term>
                     For the function to be <termref def="dt-guaranteed-streamable"/>, 
                     the <termref def="dt-type-adjusted-posture-and-sweep">type-adjusted posture</termref> of
                     the function body with respect to the declared return type must be <termref def="dt-grounded"/>, and the 
                     <termref def="dt-type-adjusted-posture-and-sweep">type-adjusted sweep</termref> of the function body 
                     with respect to the declared return type must be <termref def="dt-motionless"/>.</p>

                     
                  <p><term>Rules for references to the streaming
                        parameter:</term> Such a variable reference is
                        <termref def="dt-striding"/> and <termref def="dt-motionless"/>.</p>
                  
                  <p><term>Rules for function calls:</term> the <termref def="dt-general-streamability-rules"/> apply. The operands are the
                     expressions appearing in the argument list of the function call. The <termref def="dt-operand-usage"/> of the first argument is <termref def="dt-inspection"/>; the operand usage of other arguments is the <termref def="dt-type-determined-usage"/> based on the declared type of the
                     corresponding argument in the function signature. </p>
                  <note>
                     <p>The <termref def="dt-streaming-parameter"/> is restricted to be a single
                        node because if <code>$input</code> were a sequence of nodes, then an
                        expression such as <code>($input/name(), $input/@id)</code> would not be
                        streamable.</p>
                  </note>
                  <example>
                     <head>Example of an inspection stylesheet function</head>
                     <p>The following function is declared with category <code>inspection</code>,
                        and the function body meets the rules for this category because all
                        references to the supplied node are motionless.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:depth" as="xs:integer" streamability="inspection"&gt;
  &lt;xsl:param name="input" as="node()"/&gt;
  &lt;xsl:sequence select="count($input/ancestor-or-self::*)"/&gt;
&lt;/xsl:function&gt;</eg>
                     <p>The effect of the rules is that a call to this function is guaranteed
                        streamable provided that the expression supplied as the value of the
                           <code>$input</code> argument is <termref def="dt-motionless"/> or
                           <termref def="dt-consuming"/>.</p>
                  </example>
                  <example>
                     <head>Example of an inspection stylesheet function with two arguments</head>
                     <p>The following function is declared with category <code>inspection</code>,
                        and the function body meets the rules for this category because the function
                        signature ensures that the second argument cannot be a node.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:get-attribute-value" as="xs:string"&gt;
  &lt;xsl:param name="element" as="node()"/&gt;
  &lt;xsl:param name="attribute-name" as="xs:string"/&gt;
  &lt;xsl:sequence select="string($element/@*[local-name() = $attribute-name])"/&gt;
&lt;/xsl:function&gt;</eg>
                     <p>Although the normal usage of this function might be to supply an element
                        from a streamed document as the first argument, and a literal string as the
                        second, it is also permissible (and guaranteed streamable) to supply an
                        unstreamed element as the first argument, and an element node from a
                        streamed document as the second. When applying the general streamability
                        rules in this case, the first operand is grounded and motionless, while the
                        second is grounded and consuming (by virtue of the rules for type-determined
                        usage), and this makes the function call grounded and consuming.</p>
                  </example>
               </div4>

               <div4 id="category-filter">
                  <head>Streamability Category: filter</head>
                  <p><term>Informal description:</term> Functions in this category typically return
                     either the node supplied in the first argument or nothing, depending on the
                     values of properties that can be determined without advancing the input stream.
                     This allows access to properties such as the name and type of each node, and
                     also to its ancestors, attributes, and namespaces. </p>
                  
                  <p><term>Rules for the function signature:</term> If
                     the declared type of the streaming parameter permits more than one node,
                     the function is not <termref def="dt-guaranteed-streamable"/>.</p>
                  
                  <p><term>Rules for the function body:</term> 
                     For the function to be <termref def="dt-guaranteed-streamable"/>, 
                     the <termref def="dt-type-adjusted-posture-and-sweep">type-adjusted posture</termref> of
                     the function body with respect to the declared return type must be <termref def="dt-striding"/>, and the 
                     <termref def="dt-type-adjusted-posture-and-sweep">type-adjusted sweep</termref> of the function body 
                     with respect to the declared return type must be <termref def="dt-motionless"/>.</p>
                  
                  <p><term>Rules for references to the streaming
                        parameter:</term> Such a variable reference is
                        <termref def="dt-striding"/> and <termref def="dt-motionless"/>.</p>
                  <p><term>Rules for function calls:</term> The <termref def="dt-posture"/> and
                        <termref def="dt-sweep"/> of a call to a function in this category are
                     determined by applying the <termref def="dt-general-streamability-rules"/>. The
                     operands are the expressions supplied as arguments to the function call. The
                     first argument has <termref def="dt-operand-usage"/>
                     <termref def="dt-transmission"/>; any further arguments have <termref def="dt-type-determined-usage"/> based on the declared type of the
                     corresponding parameter in the function signature.</p>

                  <example>
                     <head>Example of a filtering stylesheet function</head>
                     <p>The following function is declared as filtering, and the function body meets
                        the rules for this category because it selects nodes from the input based on
                        motionless properties (namely, the existence of attributes).</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:large-regions" as="element(region)" streamability="filter"&gt;
  &lt;xsl:param name="input" as="element(region)"/&gt;
  &lt;xsl:sequence select="$input[@size gt 1000]"/&gt;
&lt;/xsl:function&gt;</eg>
                     <p>The effect of the rules is that the posture and sweep of a function call 
                        <code>f:large-regions(EXPR)</code> are the same as the posture and sweep of <code>EXPR</code>.</p>
                     
                     <p>Although the name <code>filter</code> suggests that the result must always
                        be a subset of the input, this is not strictly required by the rules. The
                        function can also return atomic values, as well as attribute and namespace
                        nodes.</p>
                  </example>
               </div4>

               <div4 id="category-shallow-descent">
                  <head>Streamability Category: shallow-descent</head>
                  <p><term>Informal description:</term> Functions in this category typically return
                     children of the nodes supplied in the first argument. They may also select
                     deeper in the subtrees of these nodes, provided that no node in the result can
                     possibly be an ancestor of any other node in the result. </p>
                  
                  <p><term>Rules for the function signature:</term> If
                     the declared type of the streaming parameter permits more than one node,
                     the function is not <termref def="dt-guaranteed-streamable"/>.</p>
                  
                  <p><term>Rules for the function body:</term> 
                     For the function to be <termref def="dt-guaranteed-streamable"/>, 
                     the <termref def="dt-type-adjusted-posture-and-sweep">type-adjusted posture</termref> of
                     the function body with respect to the declared return type must be <termref def="dt-striding"/>, and the 
                     <termref def="dt-type-adjusted-posture-and-sweep">type-adjusted sweep</termref> of the function body 
                     with respect to the declared return type must be <termref def="dt-motionless"/> or <termref def="dt-consuming"/>.</p>

                  
                  <p><term>Rules for references to the streaming
                        parameter:</term> Such a variable reference is
                        <termref def="dt-striding"/> and <termref def="dt-motionless"/>.</p>
                  <p><term>Rules for function calls:</term> The rules are as follows, in order:</p>
                  <olist>
                     <item>
                        <p>Let <var>T0</var> be the <termref def="dt-utype"/> corresponding to the
                           declared type of the <termref def="dt-streaming-parameter"/> in the
                           function signature (defaulting to <var>U{*}</var>).</p>
                     </item>
                     <item>
                        <p>Let <var>P0</var> and <var>S0</var> be the <termref def="dt-type-adjusted-posture-and-sweep"/> of the first argument
                           expression, based on type <var>T0</var>.</p>
                     </item>

                     <item>
                        <p>If <var>P0</var> is not <termref def="dt-striding"/> or <termref def="dt-grounded"/>, the function call is <termref def="dt-roaming"/>
                           and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>Consider a construct <var>C</var> whose operands are the argument
                           expressions other than the first argument, with <termref def="dt-type-determined-usage">type-determined operand usage</termref>
                           based on the declared type of the corresponding parameter in the function
                           signature. Let <var>P1</var> and <var>S1</var> be the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of <var>C</var>,
                           assessed using the <termref def="dt-general-streamability-rules"/>.</p>
                        <note>
                           <p>If there is only one argument, then <var>P1</var> is <termref def="dt-grounded"/> and <var>S1</var> is <termref def="dt-motionless"/>.</p>
                        </note>
                     </item>
                     <item>
                        <p>If <var>P1</var> is not <termref def="dt-grounded"/>, the function call
                           is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If <var>S0</var> and <var>S1</var> are both <termref def="dt-consuming"/>, or if either is <termref def="dt-free-ranging"/>, then the function
                           call is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If <var>P0</var> is <termref def="dt-grounded"/>, then the <termref def="dt-posture"/> of the function call is <termref def="dt-grounded"/>, and the <termref def="dt-sweep"/> of the function call is the wider
                           of <var>S0</var> and <var>S1</var>.</p>
                     </item>
                     <item>
                        <p>Otherwise, the <termref def="dt-posture"/> of the function call is
                              <var>P0</var>, and the <termref def="dt-sweep"/> of the function call
                           is as follows:</p>
                        <olist>
                              <item>
                                 <p>If the intersection of <var>T0</var> with
                                       <var>U{document-node(), element()}</var> is empty (that is,
                                    the declared type of the first argument does not permit document
                                    or element nodes) then <var>S0</var>.</p>
                              </item>
                              <item>
                                 <p>Let <var>A</var> be the <termref def="dt-static-type"/> of the
                                    expression supplied as the first argument. If the intersection
                                    of <var>A</var> with <var>U{document-node(), element()}</var> is
                                    empty (that is, the inferred type of the expression supplied as
                                    the first argument does not permit document or element nodes)
                                    then <var>S0</var>.</p>
                              </item>
                              <item>
                                 <p>Otherwise, <termref def="dt-consuming"/>.</p>
                              </item>
                           </olist>
                        
                     </item>
                  </olist>
                  <example>
                     <head>A shallow-descent stylesheet function</head>
                     <p>The following function is declared as shallow-descent, and the function body
                        meets the rules for this category because it selects children of the
                        supplied input node.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:alternate-children" as="node()*" 
                                          streamability="shallow-descent"&gt;
  &lt;xsl:param name="input" as="element()"/&gt;
  &lt;xsl:sequence select="$input/node()[position() mod 2 = 1]"/&gt;
&lt;/xsl:function&gt;</eg>
                     <p>The effect of the rules is that a call to this function is guaranteed
                        streamable in the typical case where the node supplied as the value of
                        the <code>$input</code> argument is <termref def="dt-striding"/> and
                           <termref def="dt-consuming"/>.</p>

                  </example>

               </div4>

               <div4 id="category-deep-descent">
                  <head>Streamability Category: deep-descent</head>
                  <p><term>Informal description:</term> Functions in this category typically return
                     descendants of the nodes supplied in the first argument. </p>
                  
                 
                  <p><term>Rules for the function signature:</term> If
                     the declared type of the streaming parameter permits more than one node,
                     the function is not <termref def="dt-guaranteed-streamable"/>.</p>
                  
                  <p><term>Rules for the function body:</term> 
                     For the function to be <termref def="dt-guaranteed-streamable"/>, 
                     the <termref def="dt-type-adjusted-posture-and-sweep">type-adjusted posture</termref> of
                     the function body with respect to the declared return type must be <termref def="dt-crawling"/>, and the 
                     <termref def="dt-type-adjusted-posture-and-sweep">type-adjusted sweep</termref> of the function body 
                     with respect to the declared return type must be <termref def="dt-motionless"/> or <termref def="dt-consuming"/>.</p>
                  
                  <p><term>Rules for references to the streaming
                        parameter:</term> Such a variable reference is
                        <termref def="dt-striding"/> and <termref def="dt-motionless"/>.</p>
                  <p><term>Rules for function calls:</term> The rules are as follows, in order:</p>
                  <olist>
                     <item>
                        <p>Let <var>T0</var> be the <termref def="dt-utype"/> corresponding to the
                           declared type of the <termref def="dt-streaming-parameter"/> in the
                           function signature (defaulting to <var>U{*}</var>).</p>
                     </item>
                     <item>
                        <p>Let <var>P0</var> and <var>S0</var> be the <termref def="dt-type-adjusted-posture-and-sweep"/> of the first argument
                           expression, based on type <var>T0</var>.</p>
                     </item>
                     <item>
                        <p>If <var>P0</var> is not <termref def="dt-striding"/> or <termref def="dt-grounded"/>, the function call is <termref def="dt-roaming"/>
                           and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>Consider a construct <var>C</var> whose operands are the argument
                           expressions other than the first argument, with <termref def="dt-type-determined-usage">type-determined operand usage</termref>
                           based on the declared type of the corresponding parameter in the function
                           signature. Let <var>P1</var> and <var>S1</var> be the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of <var>C</var>,
                           assessed using the <termref def="dt-general-streamability-rules"/></p>
                        <note>
                           <p>If there is only one argument, then <var>P1</var> is <termref def="dt-grounded"/> and <var>S1</var> is <termref def="dt-motionless"/>.</p>
                        </note>
                     </item>
                     <item>
                        <p>If <var>P1</var> is not <termref def="dt-grounded"/>, the function call
                           is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If <var>S0</var> and <var>S1</var> are both <termref def="dt-consuming"/>, or if either is <termref def="dt-free-ranging"/>, the function call
                           is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If <var>P0</var> is <termref def="dt-grounded"/>, then the <termref def="dt-posture"/> of the function call is <termref def="dt-grounded"/>, and the <termref def="dt-sweep"/> of the function call is the wider
                           of <var>S0</var> and <var>S1</var>.</p>
                     </item>
                     <item>
                        <p>Otherwise, the <termref def="dt-posture"/> of the function call is
                              <termref def="dt-crawling"/>, and the <termref def="dt-sweep"/> of the
                           function call is as follows:</p> 
                        <olist>
                              <item>
                                 <p>If the intersection of <var>T0</var> with
                                       <var>U{document-node(), element()}</var> is empty (that is,
                                    the declared type of the first argument does not permit document
                                    or element nodes) then <var>S0</var>.</p>
                              </item>
                              <item>
                                 <p>Let <var>A</var> be the <termref def="dt-static-type"/> of the
                                    expression supplied as the first argument. If the intersection
                                    of <var>A</var> with <var>U{document-node(), element()}</var> is
                                    empty (that is, the inferred type of the expression supplied as
                                    the first argument does not permit document or element nodes)
                                    then <var>S0</var>.</p>
                              </item>
                              <item>
                                 <p>Otherwise, <termref def="dt-consuming"/>.</p>
                              </item>
                           </olist> 
                     </item>
                  </olist>
                  <example>
                     <head>A deep-descent stylesheet function</head>
                     <p>The following function is declared as deep-descent, and the function body
                        meets the rules for this category because it selects descendants of the
                        supplied input node.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:all-comments" as="comment()*" 
                                    streamability="deep-descent"&gt;
  &lt;xsl:param name="input" as="element()"/&gt;
  &lt;xsl:sequence select="$input//comment()"/&gt;
&lt;/xsl:function&gt;</eg>
                     <p>The effect of the rules is that a call to this function is guaranteed
                        streamable in the typical case where the node supplied as the value of
                        the <code>$input</code> argument is <termref def="dt-striding"/> and
                           <termref def="dt-consuming"/>.</p>

                  </example>

               </div4>

               <div4 id="category-ascent">
                  <head>Streamability Category: ascent</head>
                  <p><term>Informal description:</term> Functions in this category typically return
                     ancestors of the nodes supplied in the first argument. </p>
                  
                  <p><term>Rules for the function signature:</term> If
                     the declared type of the streaming parameter permits more than one node,
                     the function is not <termref def="dt-guaranteed-streamable"/>.</p>
                  
                  <p><term>Rules for the function body:</term> 
                     For the function to be <termref def="dt-guaranteed-streamable"/>, 
                     the <termref def="dt-type-adjusted-posture-and-sweep">type-adjusted posture</termref> of
                     the function body with respect to the declared return type must be either 
                     <termref def="dt-climbing"/> or <termref def="dt-grounded"/>, and the 
                     <termref def="dt-type-adjusted-posture-and-sweep">type-adjusted sweep</termref> of the function body 
                     with respect to the declared return type must be <termref def="dt-motionless"/>.</p>
                  
                  <p><term>Rules for references to the streaming
                        parameter:</term> Such a variable reference is
                        <termref def="dt-climbing"/> and <termref def="dt-motionless"/>.</p>
                  <p><term>Rules for function calls:</term> The <termref def="dt-posture"/> and
                        <termref def="dt-sweep"/> of a call to a function in this category are
                     determined as follows:</p>

                  <olist>
                     <item>
                        <p>Let <var>P0</var> and <var>S0</var> be the <termref def="dt-posture"/>
                           and <termref def="dt-sweep"/> obtained by assessing the function call
                           using the <termref def="dt-general-streamability-rules"/>, where the
                           operands are the arguments to the function call, with an <termref def="dt-operand-usage"/> 
                           for the first argument of <phrase diff="chg" at="A"><termref def="dt-transmission"/></phrase>, 
                           and an <termref def="dt-operand-usage"/> for
                           arguments after the first being the <termref def="dt-type-determined-usage"/> based on the declared type of the
                           corresponding <termref def="dt-function-parameter"/>. <phrase diff="add" at="A">[XSLT 3.0 Erratum E31, bug 30289]</phrase></p>
                     </item>
                     <item>
                        <p>If <var>P0</var> is <termref def="dt-roaming"/> or <var>S0</var> is
                              <termref def="dt-free-ranging"/>, then the function call is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If <var>S0</var> is not <termref def="dt-motionless"/>, then the function
                           call is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If <var>P0</var> is <termref def="dt-roaming"/>, then the function call
                           is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If <var>P0</var> is <termref def="dt-grounded"/>, then the function call
                           is <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                     </item>
                     <item diff="add" at="A">
                        <p>If the declared return type of the function does not permit nodes, then the function call
                           is <termref def="dt-grounded"/> and <termref def="dt-motionless"/>. [XSLT 3.0 Erratum E31, bug 30289].</p>
                     </item>
                     <item>
                        <p>Otherwise, the function call is <termref def="dt-climbing"/> and <termref def="dt-motionless"/>.</p>
                     </item>
                  </olist>

                  <example>
                     <head>An ascending stylesheet function</head>
                     <p>The following function is declared with category <code>ascent</code>, and
                        the function body meets the rules for this category because it selects
                        ancestors of the supplied node.</p>
                     <eg role="xslt-declaration xmlns:f='f'" xml:space="preserve">
&lt;xsl:function name="f:containing-section" as="element(section)" 
                                          streamability="ascent"&gt;
  &lt;xsl:param name="input" as="element(para)*"/&gt;
  &lt;xsl:sequence select="$input/ancestor::section[last()]"/&gt;
&lt;/xsl:function&gt;</eg>
                     <p>The effect of the rules is that a call to this function is guaranteed
                        streamable provided that the node supplied as the value of the
                           <code>input</code> argument is not <termref def="dt-roaming"/> or
                           <termref def="dt-free-ranging"/>. There are no other constraints on the
                        node supplied in the input sequence.</p>
                  </example>
               </div4>
            </div3>



            <div3 id="classifying-attribute-sets">
               <head>Classifying Attribute Sets</head>
               
               <p>The <termref def="dt-posture"/> of an <termref def="dt-attribute-set"/>
               is always <termref def="dt-grounded"/> (its result can never return streamed nodes).</p>
               
               <p>The <termref def="dt-sweep"/> of an <termref def="dt-attribute-set"/>
                  is <termref def="dt-motionless"/> if all the following conditions hold:</p>
               
               <olist>
                  <item><p>Every <elcode>xsl:attribute</elcode> instruction within the declarations comprising the attribute set
                     is <termref def="dt-motionless"/> when assessed as described in <specref ref="streamability-of-attribute-sets"/>,
                  using a <termref def="dt-context-posture"/> of <termref def="dt-striding"/>.</p></item>
                  <item><p>Every attribute set referenced in the <code>use-attribute-sets</code> attribute of an <elcode>xsl:attribute-set</elcode>
                  declaration of the attribute set has the attribute <code>streamable="yes"</code>.</p></item>
                  <item><p/></item>
               </olist>
               
               <p>If the <termref def="dt-sweep"/> of an <termref def="dt-attribute-set"/>
                  is not <termref def="dt-motionless"/> then it is <termref def="dt-free-ranging"/>.</p>
               

               <note>
                  <p>Attribute sets will always be <termref def="dt-grounded"/>,
                     because they return newly constructed attribute nodes.</p>
                  <p>Attribute sets will very often be <termref def="dt-motionless"/>, but if they
                     access the context item, they may be <termref def="dt-free-ranging"/>. Although some attribute sets could theoretically be
                  classified as <termref def="dt-consuming"/>, this option has been excluded because
                  it is unlikely to be useful; given the requirement to create attributes whose values
                  are obtained by reading a streamed input document, use of a streamable <termref def="dt-template-rule"/>
                  is a more versatile approach.</p>
                  <p>Because attribute sets can be overridden in another <termref def="dt-package"/>, the streamability of a construct such as an
                        <elcode>xsl:element</elcode> instruction containing a
                        <code>use-attribute-sets</code> attribute is based on the declared
                     streamability of the named attribute sets, as defined by the
                        <code>streamable</code> attribute of the <elcode>xsl:attribute-set</elcode>
                     element. If <code>streamable="yes"</code> is specified, then there is a
                     requirement that any overriding attribute set should also specify
                        <code>streamable="yes"</code>, and a streaming processor is required to
                     check that an attribute set containing such a declaration does in fact satisfy
                     the streamability rules.</p>
               </note>

            </div3>

            <div3 id="classifying-vts">
               <head>Classifying Value Templates</head>
               <p>A <termref def="dt-value-template">value template</termref> (that is, an <termref def="dt-attribute-value-template"/> or <termref def="dt-text-value-template"/>)
                  is a <termref def="dt-construct"/> whose operands are the expressions contained
                  within curly brackets. The required type for this operand role is
                     <code>xs:string</code> and the <termref def="dt-operand-usage">usage</termref>
                  is <termref def="dt-absorption"/>.</p>
               <p>The <termref def="dt-sweep"/> and <termref def="dt-posture"/> of a value template
                  are determined using the general rules in <specref ref="general-streamability-rules"/>.</p>
               <p>If there are no expressions contained within curly brackets, the value template is
                     <termref def="dt-motionless"/>.</p>
            </div3>

            <div3 id="classifying-expressions">
               <head>Classifying Expressions</head>




               <p>XPath expressions are classified using the rules in this section.</p>

               <p>In the analysis that follows, <termref def="dt-expression">expressions</termref>
                  are classified according to the most specific production rule that they match for
                  which there is an entry in this section. A production <var>P</var> is considered
                  more specific than a production <var>Q</var> (<var>Q</var> ≠ <var>P</var>)
                  if every expression that matches <var>P</var> also matches <var>Q</var>. For
                  example:</p>

               <ulist>
                  <item>
                     <p>The expression <code>3</code> satisfies the productions
                           <code>NumericLiteral</code>, <code>Literal</code>, and
                           <code>ArithmeticExpression</code>; the most specific of these for which
                        there is an entry in this section is <code>Literal</code>.</p>
                  </item>
                  <item>
                     <p>The expression <code>text()</code> (appearing as an expression) is a
                           <code>TextTest</code>, and therefore a <code>KindTest</code>, which is
                        itself a <code>NodeTest</code>, and therefore an <code>AxisStep</code> with
                        a defaulted <code>ForwardAxis</code>. The most specific of these for which
                        there is an entry in this section is <code>AxisStep</code>. Although the
                        expression is also a <code>RelativePathExpr</code>, that production is less
                        specific than <code>AxisStep</code> so its rules do not apply.</p>
                  </item>
                  <item>
                     <p>The expression <code>section/title</code> is a
                        <code>RelativePathExpr</code>, for which there is an entry in this section.
                        Although the expression is also a <code>PathExpr</code>, that production is
                        less specific than <code>RelativePathExpr</code> so its rules do not
                        apply.</p>
                  </item>
               </ulist>


               <p>The production rules for different kinds of expression are listed (with their
                  names and numbers) in the order in which they appear in Appendix A.1 of the XPath
                  3.0 specification; rules are also given for
                  new constructs introduced by XPath 3.1. Where two
                  numbers are given, they are the production rule numbers in XPath 3.0 and XPath 3.1 respectively;
                  where there is a single number, it is the production rule number in XPath 3.1.</p>

               <p>Many expressions can be analyzed using the <termref def="dt-general-streamability-rules"/>. These are indicated in the table below
                  by means of a simple proforma in which the <termref def="dt-operand-role">operand
                     roles</termref> are represented by a short code (A = <termref def="dt-absorption"/>, I = <termref def="dt-inspection"/>, T = <termref def="dt-transmission"/>, N = <termref def="dt-navigation"/>). For example the
                  proforma <code>A + A</code> indicates that for an arithmetic expression, both
                  operands have <termref def="dt-operand-usage"/>
                  <termref def="dt-absorption"/>, while <code>I or I</code> indicates that for an
                     <code>or</code> expression, both operands have <termref def="dt-operand-usage"/>
                  <termref def="dt-inspection"/>. For expressions where further explanation is
                  needed, the table contains a link to the relevant section.</p>


               <table class="data">
                  <caption>Operand Roles for XPath Expressions</caption>
                  <thead>
                     <tr>
                        <th rowspan="1" colspan="1">Construct</th>
                        <th rowspan="1" colspan="1">Proforma or Reference to Detailed Rules</th>
                        <th rowspan="1" colspan="1">Further Information</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td rowspan="1" colspan="1">Expr [6,6] </td>
                        <td rowspan="1" colspan="1"><code>T, T</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">ForExpr [8,8] </td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-for-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">LetExpr [11,11] </td>
                        <td rowspan="1" colspan="1"><code>let $var := N return T</code></td>
                        <td rowspan="1" colspan="1">Binding of variables to streamed nodes is not allowed.</td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">QuantifiedExpr [14,14]</td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-quantified-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">IfExpr [15,15] </td>
                        <td rowspan="1" colspan="1"><code>if (I) then T else
                           T</code></td>
                        <td rowspan="1" colspan="1">The then-clause and else-clause form a <termref def="dt-choice-operand-group"/> with usage <termref def="dt-transmission"/></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">OrExpr [16,16]</td>
                        <td rowspan="1" colspan="1"><code>I or I</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">AndExpr [17,17]</td>
                        <td rowspan="1" colspan="1"><code>I and I</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">StringConcatExpr [19,19]</td>
                        <td rowspan="1" colspan="1"><code>A || A</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">RangeExpr [20,20]</td>
                        <td rowspan="1" colspan="1"><code>A to A</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">AdditiveExpr [21,21]</td>
                        <td rowspan="1" colspan="1"><code>A + A</code>, <code>A - A</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">MultiplicativeExpr [22,22]</td>
                        <td rowspan="1" colspan="1"><code>A * A</code>, <code>A div A</code>, etc.</td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">UnionExpr [23,23] </td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-union-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">IntersectExceptExpr [24,24] </td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-union-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">InstanceOfExpr [25,25]</td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-instance-of-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">TreatExpr [26,26]</td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-treat-as-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">CastableExpr [27,27]</td>
                        <td rowspan="1" colspan="1"><code>A castable as TYPE</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">CastExpr [28,28] </td>
                        <td rowspan="1" colspan="1"><code>A cast as TYPE</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">UnaryExpr [29,30]</td>
                        <td rowspan="1" colspan="1"><code>+A</code>, <code>-A</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">GeneralComp [31,32]</td>
                        <td rowspan="1" colspan="1"><code>A = A</code>, <code>A &lt; A</code>, <code>A != A</code>,
                           etc.</td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">ValueComp [32,33]</td>
                        <td rowspan="1" colspan="1"><code>A eq A</code>, <code>A lt A</code>, <code>A ne A</code>, etc.</td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">NodeComp [33,34]</td>
                        <td rowspan="1" colspan="1"><code>I is I</code>, <code>I &lt;&lt;
                              I</code>, <code>I &gt;&gt; I</code></td>
                        <td rowspan="1" colspan="1">See Note 1 below</td>
                     </tr>

                     <tr>
                        <td rowspan="1" colspan="1">SimpleMapExpr [34,35] </td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-simple-mapping-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">PathExpr [35,36] </td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-path-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>

                     <tr>
                        <td rowspan="1" colspan="1">RelativePathExpr [36,37] </td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-path-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">AxisStep [38,39] </td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-axis-steps"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">ForwardStep [39,40], ReverseStep [42,43]</td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-axis-steps"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">PostfixExpr [48,49]: Filter Expression</td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-filter-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">PostfixExpr [48,49]: Dynamic Function Call</td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-dynamic-function-calls"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Literal [53,57]</td>
                        <td rowspan="1" colspan="1"/>
                        <td rowspan="1" colspan="1">There are no operands, so the construct is <termref def="dt-grounded"/>
                           and <termref def="dt-motionless"/></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">VarRef [55,59]</td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-variable-references"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="2" colspan="1">ParenthesizedExpr [57,61]</td>
                        <td rowspan="1" colspan="1"><code>(T)</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1"><code>()</code></td>
                        <td rowspan="1" colspan="1">There are no operands, so the construct is <termref def="dt-grounded"/>
                           and <termref def="dt-motionless"/></td>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">ContextItemExpr [58,62]</td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-context-item-expression"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">FunctionCall [59,63]</td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-function-calls"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">NamedFunctionRef [63,67]</td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-named-function-ref"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">InlineFunctionExpr [64,68] </td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-inline-functions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">MapConstructor [,69]</td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-map-constructors"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">Lookup (Postfix [,49] and Unary [,53])</td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-lookup-expressions"/></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">ArrowExpr [,29]</td>
                        <td rowspan="1" colspan="1">See <specref ref="streamability-of-function-calls"/>
                           and <specref ref="streamability-of-dynamic-function-calls"/>: 
                           the rules for <code>X =&gt; F(Y, Z)</code> are the same as the rules for <code>F(X, Y, Z)</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">SquareArrayConstructor [,74]</td>
                        <td rowspan="1" colspan="1"><code>[N, N, ...]</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                     <tr>
                        <td rowspan="1" colspan="1">CurlyArrayConstructor [,75]</td>
                        <td rowspan="1" colspan="1"><code>array{N, N, ...}</code></td>
                        <td rowspan="1" colspan="1"/>
                     </tr>
                  </tbody>
               </table>

               <note>
                  <olist>
                     <item>
                        <p> The operators <code>is</code>, <code>&lt;&lt;</code>, and
                              <code>&gt;&gt;</code> apply to streamed nodes just as to any other
                           nodes, though there are few practical situations where they will be
                           useful. A streamed document conforms to the rules of the XDM data model,
                           and its nodes are therefore distinct and ordered. They follow the usual
                           rules, for example that a parent node precedes its children in document
                           order. Expressions such as <code>.. is parent::X</code> or
                              <code>ancestor::x[1] &lt;&lt; ancestor::y[1]</code> are therefore
                           perfectly meaningful. The usefulness of the operators is limited by the
                           fact that variables cannot be bound to nodes in a streamed document. It
                           is permitted, though perhaps not useful, for one of the operands to be
                              <termref def="dt-consuming"/>: one can write <code>. &lt;&lt;
                              child::x</code>, and the resulting expression is (by applying the
                           general rules) <termref def="dt-consuming"/> and grounded.</p>
                        <p>The restriction that variables cannot be bound to streamed nodes prevents
                           writing of expressions such as <code>let $x := . return
                              descendant::x[ancestor::y[1] is $x]</code>. As a workaround, the
                           intended effect can be achieved by comparing node identity using the
                              <xfunction>generate-id</xfunction> function: <code>let $x :=
                              generate-id(.) return descendant::x[generate-id(ancestor::y[1]) =
                              $x]</code></p>
                     </item>


                  </olist>
               </note>

               <div4 id="streamability-of-for-expressions">
                  <head>Streamability of <code>for</code> Expressions</head>

                  <p>Writing the expression as <code>for $v in S return R</code>, the two operand
                     roles are <var>S</var> and <var>R</var>.</p>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> are determined by
                     the first of the following that applies:</p>

                  <olist>
                     <item>
                        <p>If <var>S</var> is not <termref def="dt-grounded"/>, then <termref def="dt-roaming"/>
                           and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     
                     <item>
                        <p>Otherwise, the <termref def="dt-general-streamability-rules"/> apply. The
                           operand roles are:</p>
                        <olist>
                           <item>
                              <p>The <code>in</code> expression (<code>S</code>). This has <termref def="dt-operand-usage">usage</termref>
                                 <termref def="dt-navigation"/>.</p>
                           </item>
                           <item>
                              <p>The <code>return</code> expression (<code>R</code>). This is a
                                    <termref def="dt-higher-order-operand"/> with <termref def="dt-operand-usage">usage</termref>
                                 <termref def="dt-transmission"/>.</p>
                           </item>
                        </olist>
                     </item>
                  </olist>

                  <note>
                     <p>Expressions of the form <code>for $i in 1 to 3 return $i*2</code>, where
                        there is no reference to a streamed node, are clearly streamable.</p>

                     <p>The <code>in</code> expression can also be <termref def="dt-consuming"/>,
                        for example <code>for $e in copy-of(emp) return $e/salary</code>.</p>

                     <p>The rule that <var>S</var> must be grounded
                        prevents the variable being bound to a node in a streamed document. This
                        disallows expressions of the form <code>for $x in child::section return
                           $x/para</code>, because this requires data flow analysis (tracing from
                        the binding of a variable to its usages), rather than purely syntactic
                        analysis. Some implementations may be able to stream such constructs.</p>

                     <p>The fact that the return clause is a higher-order operand prevents it from
                        being a <termref def="dt-consuming"/> expression, for example <code>for $i
                           in 1 to 3 return salary</code>. Use of a motionless expression that
                        accesses streamed nodes is however allowed, for example <code>for $i in 1 to
                           3 return name(ancestor::x[$i])</code>.</p>
                  </note>
               </div4>

               <div4 id="streamability-of-quantified-expressions">
                  <head>Streamability of Quantified Expressions</head>

                  <p>An expression with multiple in-clauses is first rewritten using nested
                     quantified expressions: for example <code>some $i in X, $j in Y satisfies $i eq
                        $j</code> can be rewritten as <code>some $i in X satisfies (some $j in Y
                        satisfies $i eq $j)</code>. The analysis therefore only needs to consider
                     expressions with a single in-clause.</p>

                  <p>Writing such an expression as <code>some|every $v in S satisfies C</code>, the
                     two operand roles are <var>S</var> and <var>C</var>.</p>

                  <p>The <termref def="dt-general-streamability-rules"/> apply. The <termref def="dt-operand-role">operand roles</termref> are:</p>
                  <olist>
                     <item>
                        <p>The <code>in</code> expression (<var>S</var>). This has usage <termref def="dt-navigation"/>.</p>
                     </item>
                     <item>
                        <p>The <code>satisfies</code> expression (<var>C</var>). This is a <termref def="dt-higher-order-operand"/> with usage <termref def="dt-inspection"/>.</p>
                     </item>
                  </olist>

                  <note>

                     <p>Expressions of the form some <code>$i in 1 to 3 satisfies $i lt 2</code>,
                        where there is no reference to a streamed node, are clearly streamable. </p>
                     <p>The expression <var>S</var> can be <termref def="dt-consuming"/>, so long as
                        it is grounded: for example <code>some $e in emp/salary/number(.) satisfies
                           $e gt 10000</code>. </p>
                     <p>The rule that <var>S</var> has usage <termref def="dt-navigation"/> prevents
                        the variable being bound to a node in a streamed document. This disallows
                        expressions of the form <code>some $x in child::section satisfies
                           has-children($x)</code>, because this requires data flow analysis
                        (tracing from the binding of a variable to its usages), rather than purely
                        syntactic analysis. Some implementations may be able to stream such
                        constructs. </p>
                     <p>The fact that <var>C</var> is a higher-order operand prevents it from being
                        a <termref def="dt-consuming"/> expression: for example <code>some $i in 1
                           to 3 satisfies author[$i] eq "Kay"</code> is not streamable. Use of a
                        motionless expression that accesses streamed nodes is however allowed, for
                        example <code>some $i in 1 to 3 satisfies @grade = $i</code>. </p>
                     <p>Quantified expressions that fail the streamability rules can often be
                        rewritten as filter expressions. For example, the expression <code>some $x in
                           child::section satisfies has-children($x)</code> can be rewritten as
                           <code>exists(child::section[has-children(.)])</code>, which is grounded
                        and <termref def="dt-consuming"/>. </p>
                  </note>

               </div4>
               <div4 id="streamability-of-if-expressions">
                  <head>Streamability of <code>if</code> expressions</head>
                  <p>Writing the expression as <code>if (C) then T else E</code>, there are three
                     operand roles: <var>C</var>, <var>T</var>, and <var>E</var>. The <termref def="dt-operand-usage">usage</termref> of <var>C</var> is <termref def="dt-inspection"/>, while the <termref def="dt-operand-usage">usage</termref> of <var>T</var> and <var>E</var> is <termref def="dt-transmission"/>. Operands <var>T</var> and <var>E</var> form a
                        <termref def="dt-choice-operand-group"/>, meaning that they can both consume
                     the input stream, provided they have consistent <termref def="dt-posture"/>.
                     The <termref def="dt-general-streamability-rules"/> apply.</p>
               </div4>
               <div4 id="streamability-of-union-expressions">
                  <head>Streamability of <code>union</code>, <code>intersect</code>, and
                        <code>except</code> Expressions</head>
                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> are the first of
                     the following that applies:</p>
                  <olist>
                     <item>
                        <p>If either of the two operands is <termref def="dt-free-ranging"/>, then
                              <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>
                           (Example: <code>. | following-sibling::*</code>).</p>
                     </item>
                     <item>
                        <p>If either of the two operands is <termref def="dt-grounded"/> and
                              <termref def="dt-motionless"/>, then the <termref def="dt-posture"/>
                           and <termref def="dt-sweep"/> of the other operand (Example: <code>. |
                              doc('abc.com')//x</code>)</p>
                     </item>
                     <item>
                        <p>If both operands are <termref def="dt-climbing"/>, then <termref def="dt-climbing"/> and the
                           wider of the sweeps of the two operands (Example: <code>parent::A | */ancestor::B</code>).</p>
                     </item>
                     <item>
                        <p>If the left-hand operand is <termref def="dt-striding"/> or <termref def="dt-crawling"/> and the right-hand operand is also
                                 <termref def="dt-striding"/> or <termref def="dt-crawling"/>, then <termref def="dt-crawling"/> and the wider of the
                           sweeps of the two operands (Example: <code>* | */*</code>).</p>
                     </item>
                     <item>
                        <p>Otherwise, <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/> (Example: <code>child::div |
                              parent::div</code>).</p>
                     </item>
                  </olist>
                  <note>
                     <p>Essentially the principle is that if both operands are streamable, then the
                        result is streamable (this assumes an evaluation strategy where both
                        operands are evaluated during the same pass of the streamed input document,
                        and the results merged). But there are caveats because of the need for
                        static streamability analysis of the result. This prevents constructs such
                        as <code>.. | *</code> that have heterogeneous <termref def="dt-posture"/>.</p>
                     <p>Where the two operands are both <termref def="dt-striding"/>, there are
                        cases where an implementation could determine that the result is also
                           <termref def="dt-striding"/>: for example <code>(author | editor)</code>.
                        In general, however, the combination of two striding operands may produce a
                        sequence of nodes that have nested subtrees (consider <code>author | author/name</code>),
                        so the result is classified as <termref def="dt-crawling"/>.</p>
                     <p>The expression <code>(author | editor)</code>, although it is not <termref def="dt-striding"/>, can be rewritten in the form <code>*[self::author or
                           self::editor]</code>, which is <termref def="dt-striding"/>.</p>
                  </note>
               </div4>
               <div4 id="streamability-of-instance-of-expressions">
                  <head>Streamability of <code>instance of</code> Expressions</head>

                  <p>For an expression of the form <var>X</var> instance of <var>ST</var> (where
                        <var>X</var> is an expression and <var>ST</var> is a
                     <termref def="dt-sequence-type"/>), 
                     the <termref def="dt-posture"/> and <termref def="dt-sweep"/> are determined by the <termref def="dt-general-streamability-rules"/>. There is a single operand
                        <var>X</var>, whose <termref def="dt-operand-usage"/> is as follows:</p>

                  <olist>
                     <item>
                        <p>If the <code>ItemType</code> of <var>ST</var> is a
                              <code>DocumentTest</code>, optionally parenthesized, that contains an
                              <code>ElementTest</code> or <code>SchemaElementTest</code> then
                           absorption</p>
                     </item>
                     <item>
                        <p>Otherwise, inspection.</p>
                     </item>
                  </olist>

                  <note>
                     <p>In general, it is possible to determine whether a node matches an
                           <code>ItemType</code> without consuming the node. For example it can be
                        established whether an element matches the test <code>element(para)</code>
                        when positioned at the start tag.</p>

                     <p>An <code>ItemType</code> of the form <code>document-node(element(X))</code>
                        is an exception to this rule because it matches a document node only if it
                        has exactly one element node child, and this cannot be determined without
                        consuming the document. </p>
                     <p>A processor may have knowledge that the document node cannot contain
                        multiple element nodes, for example because it knows that the source of the
                        streamed document is an XML parser that is not capable of generating such a
                        stream. In such cases the processor may make a different assessment of the
                        streamability of this construct. This comes under the general provision that
                        a processor is always at liberty to use streaming even when the stylesheet
                        is not guaranteed streamable. </p>
                  </note>
                  <note>
                     <p>As with other constructs that are evaluated with inspection usage, for
                        example the <xfunction>name</xfunction> function or access to an attribute
                        node, evaluation of a construct such as <code>$X instance of
                           schema-element(E)</code> as true or false may be invalidated if reading
                        of the input stream subsequently fails. Dynamic errors during streamed
                        processing of an input document invalidate all output generated prior to the
                        failure, and this case is no different. </p>
                  </note>

                  <note>
                     <p>Given an expression such as <code>child::* instance of element(E)*</code>,
                        the expression as a whole is <termref def="dt-consuming"/> and grounded. By
                        contrast, the expression <code>. instance of element(E)*</code> is
                        motionless and grounded. This can be verified by applying the general
                        streamability rules to these cases. </p>
                  </note>

               </div4>
               <div4 id="streamability-of-treat-as-expressions">
                  <head>Streamability of <code>treat as</code> Expressions</head>
                  
                  <p/>
                  
                  <p>For an expression of the form <var>X</var> treat as <var>ST</var> (where
                     <var>X</var> is an expression and <var>ST</var> is a
                     <termref def="dt-sequence-type"/>), 
                     the <termref def="dt-posture"/> and <termref def="dt-sweep"/> are determined as follows:  </p> 
                     
      
                  
                  <olist>
                     <item>
                        <p>If the <code>ItemType</code> of <var>ST</var> is a
                           <code>DocumentTest</code>, optionally parenthesized, that contains an
                           <code>ElementTest</code> or <code>SchemaElementTest</code> then
                           <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>Otherwise, the <termref def="dt-general-streamability-rules"/> apply. There is a single operand
                           <var>X</var>, whose <termref def="dt-operand-usage"/> is <termref def="dt-transmission"/>.</p>
                     </item>
                  </olist>
                  
                  <note><p>See the notes in <specref ref="streamability-of-instance-of-expressions"/> for
                  a discussion of the streamability difficulties associated with <code>document-node()</code> tests.</p></note>
                  
               </div4>
               <div4 id="streamability-of-simple-mapping-expressions">
                  <head>Streamability of Simple Mapping Expressions</head>
                  <p>The mapping operator <code>!</code> is treated as a left-associative binary
                     operator, so the expression <code>a!b!c</code> is processed as
                        <code>(a!b)!c</code>.</p>

                  <p>The <termref def="dt-posture"/> of the expression is
                     the <termref def="dt-posture"/> of the right-hand operand, assessed with a
                        <termref def="dt-context-posture"/> and
                     type set to the <termref def="dt-posture"/> and type of the left-hand operand.</p>

                  <p>The <termref def="dt-sweep"/> of the expression is
                     the wider of the <termref def="dt-sweep">sweeps</termref> of the two
                     operands.</p>



               </div4>
               <div4 id="streamability-of-path-expressions">
                  <head>Streamability of Path Expressions</head>

                  <p>The streamability analysis applies after the expansion of the <code>//</code>
                     pseudo-operator to <code>/descendant-or-self::node()/</code>, and after
                     expanding <code>..</code> to <code>parent::node()</code>, <code>@X</code> to
                        <code>attribute::X</code>, and an omitted axis to the default axis for the node kind.</p>


                  <p>Following the rules in XPath, a leading <code>"/"</code> is converted to
                        <code>(root(self::node()) treat as document-node())/</code> (with the final
                        <code>"/"</code> omitted for the expression <code>"/"</code> on its own).
                     This is followed by a rewrite of the call on <xfunction>root</xfunction>, as
                     described in <specref ref="streamability-fn-root"/>.</p>
                  <note>
                     <p>Taken together, these rewrites have the effect that a path expression such
                        as <code>//a</code> is streamable only if the statically-determined context
                        item type is <code>document-node()</code>, which will be the case for
                        example immediately within <elcode>xsl:source-document</elcode>, or in a template
                        rule with <code>match="/"</code>.</p>
                  </note>



                  <p>A <code>RelativePathExpr</code> with more than two operands (such as
                        <code>a/b/c</code>) is taken as a tree of binary expressions (that is,
                        <code>(a/b)/c</code>).</p>

                  <p>The <termref def="dt-sweep"/> of a relative path expression is the wider
                        <termref def="dt-sweep"/> of the two operands, where the ordering of
                     increasing width is <termref def="dt-motionless"/>, <termref def="dt-consuming"/>, <termref def="dt-free-ranging"/>.</p>

                  <note>
                     <p>Examples:</p>
                     <ulist>
                        <item>
                           <p>The <termref def="dt-sweep"/> of <code>a/@code</code> is <termref def="dt-consuming"/> (the wider of <termref def="dt-consuming"/>
                              and <termref def="dt-motionless"/>).</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-sweep"/> of <code>a/descendant::b</code> is
                                 <termref def="dt-consuming"/> (the wider of <termref def="dt-consuming"/> and <termref def="dt-consuming"/>).</p>
                        </item>

                        <item>
                           <p>The <termref def="dt-sweep"/> of <code>./@code</code> is <termref def="dt-motionless"/> (the wider of <termref def="dt-motionless"/>
                              and <termref def="dt-motionless"/>).</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-sweep"/> of <code>./a</code> is <termref def="dt-consuming"/> (the wider of <termref def="dt-motionless"/>
                              and <termref def="dt-consuming"/>).</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-sweep"/> of <code>a/following::b</code> is
                                 <termref def="dt-free-ranging"/> (the wider of <termref def="dt-consuming"/> and <termref def="dt-free-ranging"/>).</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-sweep"/> of <code>./.</code> is <termref def="dt-motionless"/> (the wider of <termref def="dt-motionless"/>
                              and <termref def="dt-motionless"/>).</p>
                        </item>
                     </ulist>
                  </note>

                  <p>The <termref def="dt-posture"/> of a relative path
                     expression is assessed in two phases, as follows:</p>

                  <olist>
                     <item>
                        <p>First, the provisional <termref def="dt-posture"/> is determined as
                           follows: The provisional <termref def="dt-posture"/> of the expression is
                           the <termref def="dt-posture"/> of the right-hand operand, assessed with
                           a <termref def="dt-context-posture"/>
                           and type set to the <termref def="dt-posture"/> and type of the left-hand operand; and the
                           provisional sweep is the wider of the sweeps of the two operands.</p>
                     </item>
                     <item>
                        <p>If the provisional <termref def="dt-posture"/> is <termref def="dt-roaming"/>, then it is
                           reassessed as follows:</p>
                        <olist>
                           <item>
                              <p><termdef id="dt-scanning-expression" term="scanning expression">A 
                                 <code>RelativePathExpr</code> is a <term>scanning expression</term>
                              if and only if it is syntactically equivalent to some <termref def="dt-motionless"/>
                              <termref def="dt-pattern"/>.</termdef></p>
                              
                              <note><p>This means that a <code>RelativePathExpr</code>
                              is a <term>scanning expression</term> if it conforms to the grammar for a <code>RelativePathExprP</code>
                              in the grammar for patterns (see <specref ref="pattern-syntax"/>),
                              and if, when considered as a pattern, the pattern is motionless according to the
                              rules in <specref ref="classifying-patterns"/>.</p>
                              
                              <p>In practice, the test as to whether the construct is equivalent to a pattern is likely
                              to be made by examining the structure of the expression tree, rather than by re-parsing the
                              lexical form of the expression against the grammar for patterns; but the outcome is the same.</p>
                              </note>
                              
                           </item>
                           <item>
                              <p>If the expression is a <term>scanning expression</term> then:</p>
                              <olist>
                                 <item>
                                    <p>If the static type of the expression contains
                                          <code>U{element}</code> then its <termref def="dt-posture"/> is <termref def="dt-crawling"/>.</p>
                                 </item>
                                 <item>
                                    <p>Otherwise, its <termref def="dt-posture"/> is <termref def="dt-striding"/></p>
                                 </item>
                              </olist>
                           </item>
                        </olist>
                     </item>


                     <item>
                        <p>Otherwise (if the provisional <termref def="dt-posture"/> is not <termref def="dt-roaming"/>, or
                           the expression is not a <term>scanning expression</term>), the <termref def="dt-posture"/> of the expression is the provisional <termref def="dt-posture"/>.</p>
                     </item>
                  </olist>


                  <note>
                     <p>The special rules for scanning expressions are designed to ensure
                     that expressions such as <code>//section/head</code> are streamable. The problem
                     with such an expression is that it is
                     possible to have two nested sections <var>A</var> and <var>B</var>, where <var>A</var>
                     is the parent of <var>B</var> and thus precedes <var>B</var> in document order,
                     but where there are children of <var>A</var> that come <emph>after</emph>
                     children of <var>B</var> in document order. This means that a nested-loop
                     strategy for the evaluation of <code>/descendant::section/child::head</code>
                     is not guaranteed to deliver nodes in document order without a sort, and is therefore not
                     a viable strategy for streaming.</p>
                     <p>However, there is a different strategy for evaluating such an expression,
                     which is in effect to rewrite the expression as <code>/descendant::head[parent::section]</code>;
                     specifically, it is possible to scan all descendants in document order, looking for a <code>head</code>
                     element that has a <code>section</code> parent. Hence the term <term>scanning expressions</term>.</p>
                     <p>The expressions that qualify as scanning expressions are paths that can be evaluated
                        by scanning all descendants and testing each one (independently) to see whether the elements
                        on its ancestor axis match the specified path. The subset of expressions that qualify 
                        as scanning expressions is therefore the same as the subset that qualify as motionless patterns.</p>
                     <p>Scanning expressions cannot use positional predicates: for example <code>//section/head[1]</code>
                        is not recognized as a scanning expression because this would require information
                        about a streamed node (specifically, about its preceding siblings) that is not retained during streaming.
                        </p>
                  </note>
                  
                  <note>
                     <p>Perhaps surprisingly, the expression <code>.//section/head</code> is not a scanning
                     expression and is therefore not guaranteed streamable. This is because it does not take
                     the syntactic form of a <termref def="dt-pattern"/>. To make it streamable, it can be rewritten as 
                     <code>descendant::section/head</code> or as <code>self::node()//section/head</code>.</p>
                     <p>Similarly, within a streamable stylesheet function whose <termref def="dt-streaming-parameter"/> is
                     <code>$node</code>, the expression <code>$node//section/head</code> is not a scanning 
                     expression. In this case the expression does have the syntactic form of a pattern, but the
                     pattern is not classified as motionless. (See <specref ref="classifying-patterns"/> — a
                     motionless pattern cannot contain a <code>RootedPath</code>.) A workaround in this case
                     is to rewrite the expression as <code>$node/(descendant::section/head)</code>. Assuming that the
                        function in question declares <code>streamability="absorbing"</code>, the analysis here is
                     that the left-hand operand (<code>$node</code>) is striding and consuming, while the right hand 
                     operand (<code>descendant::section/head</code>) is crawling and consuming (because it is a
                     scanning expression). The expression as a whole is therefore crawling and consuming.</p>
                     <p>These are cases where an implementation might reasonably choose to relax the rules,
                     insofar as this is permitted by <specref ref="streamability-guarantees"/>.</p>
                  </note>

                  <note>

                     <p>Examples:</p>
                     <p>In each of the following cases, assume that the <termref def="dt-context-posture"/> is striding.</p>
                     <ulist>
                        <item>
                           <p>The <termref def="dt-posture"/> of the expression <code>a/b/c</code>
                              is striding, because (under the rules for AxisStep [38]) a child axis
                              step evaluated with striding context <termref def="dt-posture"/>
                              creates a new striding posture.</p>
                        </item>
                        <item>
                           <p>The posture of the expression <code>a/descendant::c</code> is
                              crawling, because a descendant axis step evaluated with striding
                              context posture creates a new crawling posture.</p>
                        </item>
                        <item>
                           <p>The posture of the expression
                                 <code>../@status</code> is striding, because a parent axis step
                              evaluated with striding context posture creates a new climbing
                              posture, and an attribute axis step evaluated with climbing context
                              posture creates a new striding posture.</p>
                        </item>
                        <item>
                           <p>The posture of the expression
                                 <code>copy-of(.)//a/following-sibling::*</code> is grounded,
                              because the <function>copy-of</function> evaluated with striding
                              posture creates a grounded posture, and all subsequent axis steps
                              leave this posture unchanged.</p>
                        </item>
                        <item>
                           <p>The expression <code>section//head</code>
                              expands to
                                 <code>(section/descendant-or-self::node())/child::head</code>. The
                              posture of the left-hand operand
                                 <code>section/descendant-or-self::node()</code> is crawling,
                              because a descendant axis step evaluated with striding context posture
                              creates a new crawling posture. The provisional posture of the
                              expression as a whole is therefore <termref def="dt-roaming"/>, because a child axis step
                              evaluated with crawling context posture gives a resulting roaming posture. However, the expression
                              is a scanning expression (both <code>section//head</code> and its expansion are
                              motionless patterns), so the expression as a whole has
                              crawling posture. </p>
                        </item>
                        <item>
                           <p>The expression <code>section//head[1]</code> is
                              free-ranging: unlike the previous example, it contains a positional
                              predicate, which means that the operands do not satisfy the rules for
                              scanning expressions. </p>
                        </item>
                     </ulist>

                  </note>






               </div4>
               <div4 id="streamability-of-axis-steps">
                  <head>Streamability of Axis Steps</head>
                  <p>The <termref def="dt-sweep"/> and <termref def="dt-posture"/> of an AxisStep
                        <var>S</var> are determined by the first of the following rules that
                     applies:</p>
                  <olist>
                     <item>
                        <p>If the <termref def="dt-context-posture"/> is <termref def="dt-grounded"/>, then the sweep is
                              <termref def="dt-motionless"/> and the posture is <termref def="dt-grounded"/>;</p>
                     </item>
                     <item>
                        <p>If the <termref def="dt-context-posture"/> is <termref def="dt-roaming"/>, then the sweep is <termref def="dt-free-ranging"/> and the posture is <termref def="dt-roaming"/>;</p>
                     </item>
                     <item>
                        <p>If the statically-inferred <termref def="dt-context-item-type"/> is such
                           that the axis will always be empty (for example, applying the child axis
                           to a text node or the parent axis to a document node), or if the <code>NodeTest</code> is one that can never
                              select nodes on the chosen axis (for example, selecting attribute
                              nodes on the child axis), then the sweep is <termref def="dt-motionless"/> and the posture is <termref def="dt-grounded"/>
                           (because the expression is statically known to return an empty
                           sequence);</p>
                     </item>
                     <item>
                        <p>If all the following conditions are satisfied:</p>
                        <olist>
                           <item>
                              <p>The <termref def="dt-context-posture"/> is <termref def="dt-striding"/></p>
                           </item>
                           <item>
                              <p>The axis is <code>descendant</code> or
                                    <code>descendant-or-self</code></p>
                           </item>
                           <item>
                              <p>There is a predicate <var>P</var> in the <code>PredicateList</code>
                                 that satisfies all the following conditions:</p>
                              <olist>
                                 <item>
                                    <p>The static type of <var>P</var> is a subtype of
                                          <code>U{xs:decimal, xs:double, xs:float}</code></p>
                                 </item>
                                 <item>
                                    <p>Neither <var>P</var>, nor any operand of <var>P</var>, at any
                                       depth provided it has the AxisStep <var>S</var> as its
                                          <termref def="dt-focus-setting-container"/>, is a context
                                       item expression, an axis expression, or a call on a
                                       focus-dependent function;</p>
                                 </item>
                              </olist>
                           </item>

                        </olist>
                        <p>then <termref def="dt-striding"/> and <termref def="dt-consuming"/></p>
                        <note>
                           <p>Examples are <code>descendant::section[1]</code>,
                                 <code>descendant::section[$i+1]</code>,
                                 <code>descendant::section[count($x)]</code>. The significance of
                              this rule is that it detects cases where the descendant axis selects a
                              singleton, and where the posture of the result can therefore be
                                 <termref def="dt-striding"/> rather than <termref def="dt-crawling"/>.</p>
                        </note>

                     </item>
                     <item>
                        <p>If the <code>PredicateList</code> contains a <code>Predicate</code> that
                           is not <termref def="dt-motionless"/>, then the sweep is <termref def="dt-free-ranging"/> and the posture is <termref def="dt-roaming"/>;</p>
                     </item>

                     <item>
                        <p>Otherwise, the <termref def="dt-sweep"/> and <termref def="dt-posture"/>
                           of the expression are as determined by the table below, based on the
                              <termref def="dt-context-posture"/>, the choice of axis, and the node test. The condition
                           “Selects elements?” is true if the <termref def="dt-utype"/> of
                              <var>S</var> has a non-empty intersection with
                           <var>U{element()}</var>.</p>

                        <table class="data">
                           <caption>Streamability of Axis Steps Based on Context Posture</caption>
                           <thead>
                              <tr>
                                 <th rowspan="1" colspan="1">Context posture</th>
                                 <th rowspan="1" colspan="1">Axis</th>
                                 <th rowspan="1" colspan="1">Selects elements?</th>
                                 <th rowspan="1" colspan="1">Result posture</th>
                                 <th rowspan="1" colspan="1">Sweep</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr>
                                 <td rowspan="1" colspan="1">Grounded</td>
                                 <td rowspan="1" colspan="1">any</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td rowspan="1" colspan="1">Grounded</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Climbing</td>
                                 <td rowspan="1" colspan="1">self, parent, ancestor-or-self, ancestor</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td rowspan="1" colspan="1">Climbing</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Climbing</td>
                                 <td rowspan="1" colspan="1">attribute, namespace</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1">parent, ancestor-or-self,
                                    ancestor</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td rowspan="1" colspan="1">Climbing</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1">self, attribute, namespace</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1">child</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1">Consuming</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1">descendant, descendant-or-self</td>
                                 <td rowspan="1" colspan="1">Yes</td>
                                 <td rowspan="1" colspan="1">Crawling</td>
                                 <td rowspan="1" colspan="1">Consuming</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1">descendant, descendant-or-self</td>
                                 <td rowspan="1" colspan="1">No</td>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1">Consuming</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Crawling</td>
                                 <td rowspan="1" colspan="1">parent, ancestor-or-self,
                                    ancestor</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td rowspan="1" colspan="1">Climbing</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Crawling</td>
                                 <td rowspan="1" colspan="1">attribute, namespace</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Crawling</td>
                                 <td rowspan="1" colspan="1">self</td>
                                 <td rowspan="1" colspan="1">Yes</td>
                                 <td rowspan="1" colspan="1">Crawling</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td rowspan="1" colspan="1">Crawling</td>
                                 <td rowspan="1" colspan="1">self</td>
                                 <td rowspan="1" colspan="1">No</td>
                                 <td rowspan="1" colspan="1">Striding</td>
                                 <td rowspan="1" colspan="1">Motionless</td>
                              </tr>
                              <tr>
                                 <td colspan="2" rowspan="1">Any other combination</td>
                                 <td rowspan="1" colspan="1"/>
                                 <td rowspan="1" colspan="1">Roaming</td>
                                 <td rowspan="1" colspan="1">Free-ranging</td>
                              </tr>

                           </tbody>
                        </table>

                     </item>
                  </olist>
                  <note>
                     <p>This analysis does not attempt to classify <code>para[title]</code> as a
                           <termref def="dt-consuming"/> expression; an implementation might choose
                        to do so.</p>
                  </note>
               </div4>
               <div4 id="streamability-of-filter-expressions">
                  <head>Streamability of Filter Expressions</head>

                  <p>For a filter expression <var>F</var> of the form <code>B[P]</code> (where
                        <var>B</var> might itself be a filter expression), the <termref def="dt-posture"/> and <termref def="dt-sweep"/> are the first of the
                     following that applies:</p>
                  <olist>
                     <item>
                        <p>If all the following conditions are satisfied:</p>
                        <olist>

                           <item>
                              <p><var>B</var> is crawling;</p>
                           </item>

                           <item>
                              <p>The static type of <var>P</var> is a subtype of <code>U{xs:decimal,
                                    xs:double, xs:float}</code>, and</p>
                           </item>

                           <item>
                              <p>Neither <var>P</var>, nor any operand of <var>P</var>, at any depth
                                 provided it has <var>F</var> as its focus-setting container, is a
                                 context item expression, an axis expression, or a call on a
                                 focus-dependent function</p>
                           </item>
                        </olist>
                        <p>then the <termref def="dt-posture"/> is <termref def="dt-striding"/> and
                           the <termref def="dt-sweep"/> is the sweep of <var>B</var>. </p>

                        <note>
                           <p>This rule captures cases where it can be statically determined that
                              the predicate is numeric and is independent of the focus. In such
                              cases, the filter expression selects at most one node, and the posture
                              can therefore be changed from crawling to striding (if there is only
                              one node, there can be no overlapping trees). Examples of filter
                              expressions that satisfy this test are <code>(//x)[3]</code>,
                                 <code>(//x)[$i+1]</code>, <code>(//x)[index-of($a,
                                 $b)[last()]]</code>, and <code>(//x)[1 to 5]</code>. The last
                              example will actually raise a type error because <code>1 to 5</code>
                              has no effective boolean value; but if expressions are going to fail,
                              it does not matter what their streamability properties are.</p>
                        </note>
                     </item>



                     <item>
                        <p>If <var>P</var> is <termref def="dt-motionless"/>, then the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of <var>B</var>;</p>
                        <note>
                           <p>This includes the case where <var>B</var> is grounded. The predicate
                                 <var>P</var> is assessed with the posture of <var>B</var> as its
                              context posture, and if this is grounded, then <var>P</var> will
                              almost invariably be motionless, making the filter expression as a
                              whole grounded and motionless. For example if <code>$s</code> is
                              grounded, then <code>$s[child::*]</code> is also grounded. A
                              counter-example is the expression <code>$s[$n = 2]</code> where
                                 <code>$n</code> is a reference to the first argument of a stylesheet function
                              that is <termref def="dt-declared-streamable"/>: here the predicate is
                              not motionless, so the filter expression is roaming and
                              free-ranging.</p>
                        </note>
                     </item>
                     <item>
                        <p>Otherwise, <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                  </olist>
                  <note>
                     <p>The first rule allows a construct such as <code>&lt;xsl:apply-templates
                           select="(//title)[1]"/&gt;</code>, where a <termref def="dt-crawling"/>
                        operand would not be guaranteed streamable.</p>
                  </note>
                  <note>
                     <p>This section is not applicable to predicates forming part of an axis step,
                        such as <code>//title[1]</code>, as these are not technically filter
                        expressions. See <specref ref="streamability-of-axis-steps"/>.</p>
                  </note>
               </div4>
               <div4 id="streamability-of-dynamic-function-calls">
                  <head>Streamability of Dynamic Function Calls</head>
                  
                  <note>
                     <p>This section applies to dynamic function calls written using the traditional
                        syntax <code>$F(X, Y, Z)</code> and equally to those using the syntax <code>X =&gt; $F(Y, Z)</code></p>
                  </note>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of a dynamic
                     function call such as <code>$F(X, Y)</code> are determined by the <specref ref="general-streamability-rules"/>. The operands and their usages are as
                     follows:</p>

                  <olist>
                     <item>
                        <p>The base expression that computes the function value itself (here
                              <code>$F</code>). This has usage <termref def="dt-inspection"/>.</p>
                     </item>
                     <item>
                        <p>The argument expressions excluding any
                                 <code>?</code> placeholders (here <code>X</code> and
                              <code>Y</code>). These have <termref def="dt-type-determined-usage"/>
                           dependent on ancillary information
                              associated with the <termref def="dt-static-type"/> of the base
                              expression, where available (see <specref ref="determining-static-type"/>). If this information indicates
                              that the base expression is a function with signature
                           <code>function(A, B, ...) as R</code>, then the first argument
                              <code>X</code> has <termref def="dt-type-determined-usage"/> based on
                           the first argument type <code>A</code>, the second argument
                              <code>Y</code> has <termref def="dt-type-determined-usage"/> based on
                           the second argument type <code>B</code>, and so on. If no function signature is available, then the
                           usage of each of the argument expressions is <termref def="dt-navigation"/>.</p>
                     </item>
                  </olist>

                  <note>
                     <p>As explained in <specref ref="function-lookup"/>, use of a dynamic function
                        call where the function value is bound to a focus-dependent function such as
                           <code>name#0</code>, <code>lang#1</code>, or <code>last#0</code> is
                        likely to lead to a dynamic error if the context item is a node in a
                        streamed document, but this does not affect the static streamability
                        analysis.</p>
                  </note>
                  
                  <note>
                     <p>Maps and arrays are functions, and it is possible to look up a value in a map
                     or array using a dynamic function call of the form <code>$map($key)</code> or
                     <code>$array($index)</code>. If it is statically known that the function in question
                     is a map or array, then it is also known that the argument type is <code>xs:anyAtomicType</code>,
                     and that the operand usage is therefore <termref def="dt-absorption"/>. A call that
                     passes a streamed node will therefore be <termref def="dt-grounded"/> and <termref def="dt-consuming"/>.
                     However, if it is not known statically that the function is a map or array, then the expression
                     will generally be <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     
                     <p>This means it is desirable to declare the type of any variable holding a map or array. 
                     If streamable nodes are used to lookup a value in a map or array, then it may be advisable to use
                     the <code>map:get</code> or <code>array:get</code> functions explicitly; or<phrase diff="del" at="A">, if XPath 3.1 is available,</phrase>
                     the lookup operator (<code>?</code>).</p>
                     
                  </note>

               </div4>
               <div4 id="streamability-of-variable-references">
                  <head>Streamability of Variable References</head>

                  <p>For variable references that are bound to the
                        <termref def="dt-streaming-parameter"/> of a <termref def="dt-declared-streamable"/>
                     <termref def="dt-stylesheet-function"/>, see the rules for the <termref def="dt-streamability-category"/> of the containing function, under <specref ref="streamable-stylesheet-functions"/>.</p>

                  <p>In all other cases, variable references are <termref def="dt-grounded"/> and
                        <termref def="dt-motionless"/>.</p>



                  


               </div4>
               <div4 id="streamability-of-context-item-expression">
                  <head>Streamability of the Context Item Expression</head>

                  <p>The <termref def="dt-posture"/> of the expression is the <termref def="dt-context-posture"/>, and the <termref def="dt-sweep"/> is <termref def="dt-motionless"/>.</p>

                  <note>
                     <p>Although <code>.</code> is intrinsically motionless, when used in certain
                        contexts (such as <code>data(.)</code>) the containing expression will be
                           <termref def="dt-consuming"/>. This arises because of the <termref def="dt-operand-usage"/>: the argument to <xfunction>data</xfunction> has
                        usage <termref def="dt-absorption"/>, and the combination of a <termref def="dt-motionless"/> operand with usage <termref def="dt-absorption"/>
                        leads to the containing expression being <termref def="dt-consuming"/>.</p>
                     <p>Similarly, if <code>.</code> is used where the <termref def="dt-operand-usage"/> is <termref def="dt-navigation"/>, the
                        containing expression will be <termref def="dt-free-ranging"/>.</p>
                  </note>
               </div4>
               <div4 id="streamability-of-function-calls">
                  <head>Streamability of Static Function Calls</head>
                  
                  <note>
                     <p>This section applies to static function calls written using the traditional
                     syntax <code>F(X, Y, Z)</code> and equally to those using the syntax <code>X =&gt; F(Y, Z)</code></p>
                  </note>

                  <p>For calls to built-in functions, see <specref ref="classifying-built-in-functions"/>.</p>

                  <p>For calls to <termref def="dt-stylesheet-function">stylesheet functions</termref>, see <specref ref="streamable-stylesheet-functions"/>.</p>

                  <p>For partial function applications (where one or more of the arguments is
                     supplied as a <code>?</code> placeholder), see the rules at the end of this
                     section.</p>

                  <p>For a call to a constructor function, the <specref ref="general-streamability-rules"/> apply. There is a single operand role
                     (the argument to the function), with <termref def="dt-operand-usage"/>
                     <termref def="dt-absorption"/>.</p>




                  <p>For a call to an <termref def="dt-extension-function"/>, the <termref def="dt-posture"/> and <termref def="dt-sweep"/> are <termref def="dt-implementation-defined"/>.</p>



                  <p>If the function call is a partial function
                     application (that is, if one or more of the arguments is given as a
                        <code>?</code> placeholder), then:</p>
                  <olist>
                     <item>
                        <p>If the function is focus-dependent and
                              the <termref def="dt-context-posture"/> is not <termref def="dt-grounded"/>, then the function call is <termref def="dt-roaming"/> and
                           <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If the target of the function call is a
                              <termref def="dt-stylesheet-function"/>
                           that is <termref def="dt-declared-streamable"/>, and if the first argument is actually
                           supplied (that is, this argument is not supplied as a <code>?</code>
                           placeholder), and if the expression
                              that is supplied as the first argument is not <termref def="dt-grounded"/>, then the function call is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If the target is an <termref def="dt-extension-function"/>, the <termref def="dt-posture"/> and
                              <termref def="dt-sweep"/> are <termref def="dt-implementation-defined"/>.</p>
                     </item>
                     <item>
                        <p>Otherwise, the <termref def="dt-general-streamability-rules"/> apply.
                              The operands of a partial function
                              application are the expressions actually supplied as arguments to the
                              function, ignoring <code>?</code> place-holders; the corresponding
                                 <termref def="dt-operand-usage"/> is the <termref def="dt-type-determined-usage"/> based on the declared type of that
                              argument.</p>
                     </item>
                  </olist>




               </div4>
               <div4 id="streamability-of-named-function-ref">
                  <head>Streamability of Named Function References</head>
                  <p>Let <var>F</var> be the function to which the <code>NamedFunctionRef</code>
                     refers.</p>
                  <p>If <var>F</var> is focus-dependent and the
                           <termref def="dt-context-posture"/> is not <termref def="dt-grounded"/>, then the <code>NamedFunctionRef</code> is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                  <p>If <var>F</var> is an <termref def="dt-extension-function"/>, the <termref def="dt-posture"/> and <termref def="dt-sweep"/> are <termref def="dt-implementation-defined"/>.</p>
                  <p>Otherwise, the <code>NamedFunctionRef</code> is <termref def="dt-grounded"/> and
                     <termref def="dt-motionless"/>. </p>

                  <note>
                     <p>The main intent behind these rules is to ensure that the function item
                        returned by a named function reference does not encapsulate a reference to a
                        streamed node.</p>
                     <p>In the case of an expression such as <code>local-name#0</code>,
                        implementations might be able to do better by pre-evaluating the function at
                        the point where the named function reference occurs.</p>
                     <p>In the case of extension functions, implementations may be able to
                        distinguish whether the function is focus-dependent, and decide the
                        streamability of the named function reference accordingly.</p>
                  </note>
               </div4>
               <div4 id="streamability-of-inline-functions">
                  <head>Streamability of Inline Function Declarations</head>

                  <p>An inline function declaration that textually
                     contains a variable reference bound to a <termref def="dt-streaming-parameter"/> (of some containing stylesheet function) is <termref def="dt-roaming"/> and
                        <termref def="dt-free-ranging"/>.</p>


                  <p>All other inline function declarations are <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>

                  <note>
                     <p>It is not possible to pass a streamed node as an argument to a call to an
                        inline function unless the declared type of the corresponding function
                        parameter causes the node to be atomized: see <specref ref="streamability-of-dynamic-function-calls"/>. The only other way an
                        inline function could access a streamed node is by having the streamed node
                        in its closure, and this is prevented by the rule above.</p>
                  </note>
               </div4>
               <div4 id="streamability-of-map-constructors">
                  <head>Streamability of Map Constructors</head>

                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of a map
                     constructor (see <specref ref="map-constructors"/>) are the same as the
                        <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the equivalent
                        <elcode>xsl:map</elcode> instruction. The equivalent
                        <elcode>xsl:map</elcode> instruction is formed by creating a sequence of
                        <elcode>xsl:map-entry</elcode> instructions, one for each key/value pair in
                     the map expression, where the key expression becomes the value of
                        <code>xsl:map-entry/@key</code>, and the value expression becomes the value
                     of <code>xsl:map-entry/@select</code>; this sequence of
                        <elcode>xsl:map-entry</elcode> instructions is then wrapped in an
                        <elcode>xsl:map</elcode> parent instruction.</p>

                  <p>For example, the map constructor <code>map{'red':false(),
                        'green':true()}</code> translates to the instruction:</p>
                  <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:map&gt;
  &lt;xsl:map-entry key="'red'" select="false()"/&gt;
  &lt;xsl:map-entry key="'green'" select="true()"/&gt;
&lt;/xsl:map&gt;</eg>

                  <p>The rules for the streamability of <elcode>xsl:map</elcode> appear in <specref ref="streamability-xsl-map"/>.</p>

                  <p>See also <specref ref="maps-streaming"/>.</p>

               </div4>
               <div4 id="streamability-of-lookup-expressions">
                  <head>Streamability of Lookup Expressions</head>
                  
                  <p diff="del" at="A">Lookup expressions for maps are defined in XPath 3.1, and are available
                  in XSLT 3.0 whether or not XPath 3.1 is supported. Lookup expressions for arrays are defined in the
                  XPath 3.1 specification (see <xspecref spec="XP40" ref="id-lookup"/>), and are available only in XSLT 3.0
                  processors that provide the XPath 3.1 Feature (see ....).</p>
                  
                  <p>For the unary lookup operator, the <termref def="dt-posture"/> and <termref def="dt-sweep"/> 
                     of the expression <code>?X</code> are
                     defined to be the same as the <termref def="dt-posture"/> and <termref def="dt-sweep"/> 
                     of the postfix lookup expression <code>.?X</code>.</p>
                  
                  <p>For the postfix lookup expression <code>E?K</code>, the <termref def="dt-general-streamability-rules"/> apply as follows:</p>
                  
                  <olist>
                     <item><p>In the wildcard form of the expression, <code>E?*</code>, there is only one operand, <code>E</code>.
                     This has <termref def="dt-operand-usage"/> <termref def="dt-inspection"/>.</p></item>
                     <item><p>Where the construct <code>K</code> is an NCName, the expression <code>E?NAME</code> is treated as
                        equivalent to <code>E?("NAME")</code>.</p></item>
                     <item><p>Where the construct <code>K</code> is an integer, the expression <code>E?N</code> is treated as
                        equivalent to <code>E?(N)</code>.</p></item>
                     <item><p>In the general case where <code>K</code> is a parenthesized expression, the lookup expression
                        <code>E?(K)</code> has two operands. The first operand <code>E</code> has <termref def="dt-operand-usage"/> 
                        <termref def="dt-inspection"/>, while the second operand <code>K</code> has <termref def="dt-operand-usage"/>
                        <termref def="dt-absorption"/>.</p></item>
                  </olist>
               </div4>
            </div3>

            <div3 id="classifying-built-in-functions">
               <head>Classifying Calls to Built-In Functions</head>

               <p>This section describes the rules that determine the streamability of calls to
                  built-in functions. These differ from user-written functions because it is known
                  (defined in the specification) how nodes supplied as operands are used. Knowledge
                  of the usage of each operand, together with the <termref def="dt-posture"/> of the
                  actual operands, is in most cases enough to determine the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the function result.</p>

               <p>All the built-in functions are listed below. For most functions, a simple proforma
                  is shown that indicates the operand usage of each argument, using the code (A =
                     <termref def="dt-absorption"/>, I = <termref def="dt-inspection"/>, T =
                     <termref def="dt-transmission"/>, N = <termref def="dt-navigation"/>). So, for
                  example, the entry <code>fn:remove(T, A)</code> means that for the function
                     <code>fn:remove#2</code>, the <termref def="dt-operand-usage"/> of the first
                  argument is <termref def="dt-transmission"/>, and the <termref def="dt-operand-usage"/> of the second argument is <termref def="dt-absorption"/>. By reference to the general rules in <specref ref="general-streamability-rules"/>, this demonstrates that if the <termref def="dt-context-posture"/> is <termref def="dt-striding"/>, the posture and sweep of the expression
                     <code>sum(remove(*,1))</code> will be <code>grounded</code> and
                     <code>consuming</code> respectively. </p>

               <p>For functions that default one of their arguments (typically to the context item),
                  the relevant entry shows the equivalence, and the posture and sweep can in these
                  cases be computed by filling in the default value for the relevant argument.</p>

               <p>Some functions do not follow the general rules, and these are listed with a link
                  to the section where the particular rules for that function are described.</p>


               <?built-in-function-streamability?>

               <div4 id="streamability-fn-accumulator-after">
                  <head>Streamability of the <function>accumulator-after</function> Function</head>
                  <p>See also <specref ref="streamability-of-accumulators"/>.</p>

                  <p>The <termref def="dt-posture"/> of the function call is in all cases <termref def="dt-grounded"/>.</p>

                  <p>The <termref def="dt-sweep"/> is determined by applying the following rules, in
                     order:</p>

                  <olist>
                     <item>
                        <p>If the first argument (the accumulator name) is not <termref def="dt-motionless"/>, the function is <termref def="dt-free-ranging"/>. </p>
                     </item>
                     <item>
                        <p>If the <termref def="dt-context-posture"/> is <termref def="dt-grounded"/>, the function is <termref def="dt-motionless"/>. </p>
                     </item>
                     <item>
                        <p>If the <termref def="dt-context-item-type"/> has an empty intersection
                           with <var>U{document-node(), element()}</var> (that is, if the context
                           item cannot have children), the function is <termref def="dt-motionless"/>. </p>
                     </item>
                     <item>
                        <p>If the function call is contained in the <code>select</code> expression
                           or contained sequence constructor of an
                              <elcode>xsl:accumulator-rule</elcode> specifying
                              <code>phase="start"</code>, then it is <termref def="dt-free-ranging"/>.</p>
                     </item>
                     <item>
                        <p>If the function call is contained in the <code>select</code> expression
                           or contained sequence constructor of an
                              <elcode>xsl:accumulator-rule</elcode> specifying
                              <code>phase="end"</code>, then it is <termref def="dt-motionless"/>.</p>
                     </item>
                     <item>
                        <p>If no enclosing node of the function
                              call is part of a <termref def="dt-sequence-constructor"/>, then it is
                                 <termref def="dt-free-ranging"/>. For this purpose, the
                                 <term>enclosing nodes</term> of a function call are the attribute
                              or text node that immediately contains the XPath expression in which
                              the function call appears, and its ancestors.
                        </p>
                     </item>
                     <item>
                        <p>If the <termref def="dt-focus-setting-container"/> of the function call
                           is different from the <termref def="dt-focus-setting-container"/> of the
                           innermost containing <termref def="dt-instruction"/>, then the function
                           is <termref def="dt-free-ranging"/>. </p>
                     </item>
                     <item>
                        <p>If no enclosing node <var>N</var> of
                              the function call has a preceding sibling node <var>P</var> such that
                              (a) <var>N</var> and <var>P</var> are part of the same <termref def="dt-sequence-constructor"/>, and (b) the <termref def="dt-sweep"/> of <var>P</var> is <termref def="dt-consuming"/>,
                              then the function call is <termref def="dt-consuming"/>. (The term
                                 <term>enclosing node</term> is defined above.)</p>
                     </item>
                     <item>
                        <p>Otherwise, the function call is <termref def="dt-motionless"/>.</p>
                     </item>
                  </olist>

                  <note>
                     <p>The following notes apply to the above rules with matching numbers:</p>
                     <olist>
                        <item>
                           <p>This rule prevents the accumulator name being computed by reading the
                              streamed source document. This is disallowed primarily because there
                              is no conceivable use case for doing it.</p>
                        </item>
                        <item>
                           <p>If the context posture is grounded, then the target of the accumulator
                              is not a streamed node, so no streaming restrictions apply.</p>
                        </item>
                        <item>
                           <p>If the context item is a childless node (such as a text node), then
                              both the pre-descent and post-descent values of the accumulator can be
                              computed before evaluating any user-written constructs that access
                              this node; there are therefore no constraints on where a call to
                                 <function>accumulator-after</function> can appear.</p>
                        </item>
                        <item>
                           <p>This rule ensures that when computing the pre-descent value of an
                              accumulator for a particular streamed node, the post-descent values of
                              accumulators for that node are not available.</p>
                        </item>
                        <item>
                           <p>This rule states that the post-descent value of an accumulator is
                              allowed to depend on the post-descent values of other accumulators for
                              the same node. There is a rule preventing cycles <errorref spec="XT" class="DE" code="3400"/>.</p>
                        </item>
                        <item>
                           <p>This rule prevents the use of the function (when applied to a streamed
                              node) in contexts like the <code>use</code> attribute of
                                 <elcode>xsl:key</elcode>. It
                                 allows its use in the attributes of an <termref def="dt-instruction"/> or <termref def="dt-literal-result-element"/>, or in a <termref def="dt-text-value-template"/>. It does not allow use in an
                                    <elcode>xsl:sort</elcode> or <elcode>xsl:param</elcode> element,
                                 as these elements do not form part of a sequence constructor (see
                                    <specref ref="sequence-constructors"/>).</p>
                        </item>
                        <item>
                           <p>This rule prevents the use of the function (when applied to a streamed
                              node) in contexts such as predicates, or the right-hand side of the
                              <code>/</code> operator. The focus for evaluation of the function must be the
                              same as the focus for a containing sequence constructor. Sequence
                              constructors are treated differently from all other constructs for
                              this purpose in that their operands (the contained instructions) are
                              treated as ordered: in conjunction with the next rule, this rule is
                              assuming that instructions in a sequence constructor that follow a
                                 <termref def="dt-consuming"/> instruction are evaluated after the
                                 <termref def="dt-consuming"/> instruction and therefore have access
                              to the post-descent accumulator value.</p>
                        </item>
                        <item>
                           <p>This rule is subtle, and has a number of consequences. In these notes, the term
                                    <term>instruction</term> should be read as including all nodes
                                 making up a sequence constructor, including XSLT instructions,
                                 extension instructions, literal result elements, and text nodes
                                 containing text value templates.</p>
                           <ulist>
                              <item>
                                 <p>In a sequence constructor that contains a <termref def="dt-consuming"/> instruction such as
                                       <code>&lt;xsl:apply-templates/&gt;</code>, it allows any
                                    number of calls on <function>accumulator-after</function> to
                                    appear in instructions that follow the call on
                                       <code>&lt;xsl:apply-templates/&gt;</code>.</p>
                              </item>
                              <item>
                                 <p>In such a sequence constructor it prevents a call on
                                       <function>accumulator-after</function> from appearing in an
                                    instruction that precedes the
                                       <code>&lt;xsl:apply-templates/&gt;</code>, because there
                                    would then be two <termref def="dt-consuming"/>
                                    instructions.</p>
                              </item>
                              <item>
                                 <p>In a sequence constructor that contains calls on
                                       <function>accumulator-after</function>, and contains no other
                                       <termref def="dt-consuming"/> construct, the first
                                    instruction that contains a call on
                                       <function>accumulator-after</function> is consuming (unless
                                    it contains more than one such call, in which case it is
                                    free-ranging), and subsequent instructions containing such a
                                    call are motionless. So it is possible to have two or more calls
                                    on <function>accumulator-after</function> provided they appear
                                    in different instructions, which allows the analysis to assume
                                    an order of execution.</p>
                              </item>
                              <item>
                                 <p>It prevents a call on <function>accumulator-after</function>
                                    from appearing in the same instruction as another consuming
                                    construct: for example it disallows <code>concat(child::p,
                                       accumulator-after('a'))</code>. This rule preserves the
                                    ability to evaluate the arguments of the <code>concat</code>
                                    function in any order.</p>
                              </item>
                              <item>
                                 <p>It disallows a call on <function>accumulator-after</function>
                                    from appearing in a sequence constructor that is required to be
                                    motionless, for example within <elcode>xsl:sort</elcode>.</p>
                              </item>
                              <item>
                                 <p>The reference to a “preceding sibling node within the same
                                    sequence constructor” is carefully worded to ensure that
                                    preceding siblings among the children of
                                       <elcode>xsl:fork</elcode> are not taken into account; the
                                    children of <elcode>xsl:fork</elcode> are sibling instructions,
                                    but do not constitute a sequence constructor. The term also excludes elements such as
                                          <elcode>xsl:param</elcode> and <elcode>xsl:sort</elcode>
                                       that may precede a sequence constructor but are not part of
                                       it.</p>
                              </item>
                           </ulist>
                        </item>
                        <item>
                           <p>The final rule states that if none of the previous rules apply, the
                              function is considered motionless. This applies when the
                                 <function>accumulator-after</function> appears after a consuming
                              instruction within the same sequence constructor.</p>
                           <p>Note also that a call to <function>accumulator-after</function> can
                              safely appear within a construct such as a named template or
                              (non-streamable) stylesheet function; this is safe because the rules
                              ensure that in such situations, the context item cannot be a streamed
                              node.</p>
                        </item>
                     </olist>
                  </note>

                  <p>Dynamic invocation of <function>accumulator-after</function> is covered by the
                     rules in <specref ref="function-lookup"/>. These rules ensure that a function
                     item cannot include a streamed node in its closure; circumventing the
                     streamability rules for <function>accumulator-after</function> by making a
                     dynamic call is therefore not possible.</p>


               </div4>
               <div4 id="streamability-fn-accumulator-before">
                  <head>Streamability of the <function>accumulator-before</function> Function</head>
                  <p>See also <specref ref="streamability-of-accumulators"/>.</p>



                  <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the function call are assessed as follows:</p>

                  <olist>
                     <item>
                        <p>If the argument to <function>accumulator-before</function> is motionless,
                           the function call is <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                     </item>
                     <item>
                        <p>Otherwise, the function call is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                  </olist>
               </div4>
               <div4 id="streamability-fn-current">
                  <head>Streamability of the <function>current</function> Function</head>

                  <p>The <termref def="dt-sweep"/> and <termref def="dt-posture"/> of a call to the
                        <function>current</function> function are determined as follows:</p>
                 

                  <olist>
                     <item>
                        <p>If the call appears within a pattern, then climbing and motionless.</p>
                        <note><p>The call to <function>current</function> will always be within a predicate of the pattern.
                        The use of climbing posture here allows predicates such as <code>[@class = current()/@class]</code>,
                        while disallowing downwards navigation from the node returned by the function.</p></note>
                     </item>
                     <item>
                        <p>Otherwise, let <var>E</var> be the outermost containing XPath expression of the call
                           to the <function>current</function> function.</p>
                     </item>
                     <item>
                        <p>If the <termref def="dt-context-posture"/> of <var>E</var> is <termref def="dt-grounded"/>, then <termref def="dt-motionless"/> and <termref def="dt-grounded"/>.</p>
                     </item>
                     <item>
                        <p>If the path in the expression tree that connects the call on
                              <function>current</function> to <var>E</var> (excluding <var>E</var>
                           itself) contains an expression that is a <termref def="dt-higher-order-operand"/> of its parent expression, then
                              <termref def="dt-motionless"/> and <termref def="dt-climbing"/>. </p>
                        <note>

                           <p>Many common uses of the <function>current</function>, such as
                                 <code>//p[@class=current()/@class]</code>, fall into this category:
                              a predicate is a higher-order operand of its containing filter
                              expression.</p>
                           <p>The use of <termref def="dt-climbing"/> posture here might seem
                              unrelated to its usual connection with the ancestor axis. The
                              explanation (apart from the fact that it happens to produce the right
                              results) lies in the fact that at the point where the
                                 <function>current</function> call is evaluated, the node it returns
                              will always be an ancestor-or-self of the context node, as a
                              consequence of the fact that the containing XPath expression is
                              required to be either <termref def="dt-motionless"/> or <termref def="dt-consuming"/>.</p>
                           <p>The effect of the rule is to allow
                              expressions such as <code>//*[name() = name(current())]</code> or
                                 <code>//*[@ref = current()/@id]</code>.</p>
                        </note>
                     </item>
                     <item><p>Otherwise, the <termref def="dt-posture"/> is the 
                        <termref def="dt-context-posture"/>, and the <termref def="dt-sweep"/> is 
                        <termref def="dt-motionless"/>.</p></item>
                  </olist>

                  <!--<note><p>Although the <function>current</function> function is supported for streaming, it needs to be
                  used with care. Some common use cases such as <code>select="$lookup[@name = current()/name]</code> will fail,
                  because the streamability rules require a predicate to be motionless. A workaround is to extract the relevant value into a variable:
                     <code>select="let $n := string(name) return $lookup[@name = $n]</code>; in turn this removes the need for the <function>current</function>
                     function.</p>
                     <p>The use of the <function>current</function> function within a pattern is supported with similar restrictions. 
                        In this case the
                     <phrase diff="chg" at="Q"><termref def="dt-context-posture"/></phrase> is always <termref def="dt-striding"/>.</p></note>-->
               </div4>
               <div4 id="streamability-fn-current-group">
                  <head>Streamability of the <function>current-group</function> Function</head>

                  

                  

                  <p>The <termref def="dt-sweep"/> and <termref def="dt-posture"/> of a call <var>C</var> to the
                        <function>current-group</function> function are as follows:</p>

                  <olist>
                     <item>
                        <p>If all the following conditions are true:</p>
                        <olist>
                           <item>
                              <p><var>C</var> has a containing <elcode>xsl:for-each-group</elcode>
                                 instruction (call it <var>F</var>)</p>
                           </item>
                           <item>
                              <p>The path in the construct tree that connects <var>C</var> to the
                                 sequence constructor forming the body of <var>F</var> is such that
                                 no child construct is a <termref def="dt-higher-order-operand"/> of
                                 its parent</p>
                           </item>
                           <item>
                              <p>The <termref def="dt-focus-setting-container"/>
                                 of <var>C</var> is <var>F</var></p>
                           </item>
                        </olist>
                        <p>then the <termref def="dt-sweep"/> and <termref def="dt-posture"/> of
                              <var>C</var> are the <termref def="dt-sweep"/> and <termref def="dt-posture"/> of the <code>select</code> expression of
                              <var>F</var>.</p>

                     </item>
                     <item>
                        <p>Otherwise, <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>.</p>
                     </item>
                  </olist>

                  <note>
                     <p>Informally, for streamed evaluation to be possible, a call to
                           <function>current-group</function> must not appear in a construct that is
                        evaluated repeatedly. For example, the expression <code>for $i in 1 to 10
                           return current-group()</code> would not be streamable.</p>
                  </note>


               </div4>
               <div4 id="streamability-fn-current-grouping-key">
                  <head>Streamability of the <function>current-grouping-key</function>
                     Function</head>
                  <p>A call to the
                        <function>current-grouping-key</function> function is grounded and
                     motionless.</p>
               </div4>

               <div4 id="streamability-fn-current-merge-group">
                  <head>Streamability of the <function>current-merge-group</function>
                     Function</head>

                  <p>A call to the
                        <function>current-merge-group</function> function is <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                  <note>
                     <p>This is because the nodes to be merged are always snapshots, and therefore
                           <termref def="dt-grounded"/>: see <specref ref="streamable-merging"/>.</p>
                  </note>
               </div4>

               <div4 id="streamability-fn-current-merge-key">
                  <head>Streamability of the <function>current-merge-key</function> Function</head>
                  <p>A call to the <function>current-merge-key</function> function is <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
               </div4>



               <div4 id="streamability-fn-fold-left">
                  <head>Streamability of the <xfunction>fold-left</xfunction> Function</head>

                  <p>The function call <code>fold-left($seq, $zero, $f)</code>, follows the <termref def="dt-general-streamability-rules"/>, with the first argument
                        <code>$seq</code> having <termref def="dt-type-determined-usage"/> based on
                     the type of the second argument of the function supplied as
                     <code>$f</code>.</p>

                  <p>For example, given the call <code>fold-left(/*/transaction, 0, function($x as
                        xs:decimal, $y as xs:decimal) as xs:decimal {$x+$y})</code>, the <termref def="dt-operand-usage"/> of the argument <code>/*/transaction</code> is
                     determined by the declared type of <code>$y</code>, namely
                        <code>xs:decimal</code>. Since this is an atomic type, the <termref def="dt-type-determined-usage"/> is <termref def="dt-absorption"/>. Applying
                     this to the general streamability rules, the function call is <termref def="dt-grounded"/> and <termref def="dt-consuming"/>.</p>

               </div4>

               <div4 id="streamability-fn-fold-right">
                  <head>Streamability of the <xfunction>fold-right</xfunction> Function</head>

                  <p>The function follows the <termref def="dt-general-streamability-rules"/>, with
                     the first argument having <termref def="dt-operand-usage"/>
                     <termref def="dt-navigation"/> to reflect the fact that the supplied sequence
                     is processed in reverse order.</p>

                  <note>
                     <p>The same considerations apply as for the <xfunction>reverse</xfunction>
                        function: see <specref ref="streamability-fn-reverse"/>.</p>
                  </note>


               </div4>

               <div4 id="streamability-fn-for-each">
                  <head>Streamability of the <xfunction>for-each</xfunction> Function</head>

                  <p>The function call <code>for-each($seq, $f)</code>, follows the <termref def="dt-general-streamability-rules"/>, with the first argument
                        <code>$seq</code> having <termref def="dt-type-determined-usage"/> based on
                     the type of the (single) argument of the function supplied as
                     <code>$f</code>.</p>

                  <p>For example, given the call <code>for-each(/*/transaction, function($x as
                        xs:decimal) as xs:decimal {abs($x)})</code>, the <termref def="dt-operand-usage"/> of the argument <code>/*/transaction</code> is
                     determined by the declared type of <code>$x</code>, namely
                        <code>xs:decimal</code>. Since this is an atomic type, the <termref def="dt-type-determined-usage"/> is <termref def="dt-absorption"/>. Applying
                     this to the general streamability rules, the function call is <termref def="dt-grounded"/> and <termref def="dt-consuming"/>.</p>

                  <note>
                     <p>In practice, the <xfunction>filter</xfunction> function is streamable if
                        either (a) the supplied sequence is grounded, or (b) the supplied function
                        is statically known to atomize its argument.</p>
                  </note>

               </div4>

               <div4 id="streamability-fn-for-each-pair">
                  <head>Streamability of the <xfunction>for-each-pair</xfunction> Function</head>

                  <p>The function call <code>for-each($seq1, $seq2, $f)</code>, follows the <termref def="dt-general-streamability-rules"/>, where:</p>
                  <olist>
                        <item>
                           <p>The first argument <code>$seq1</code> has <termref def="dt-type-determined-usage"/> based on the type of the first
                              argument of the function supplied as <code>$f</code>.</p>
                        </item>
                        <item>
                           <p>The second argument <code>$seq2</code> has <termref def="dt-type-determined-usage"/> based on the type of the second
                              argument of the function supplied as <code>$f</code></p>
                        </item>
                     </olist>

                  <note>
                     <p>In practice, the <xfunction>for-each-pair</xfunction> function is streamable
                        provided (a) at most one of the input sequences is consuming, and (b) either
                        (i) that input sequence is grounded, or (ii) the supplied function is
                        statically known to atomize the relevant argument.</p>
                     <p>If it is necessary to combine two sequences that are both streamed, consider
                        using <elcode>xsl:merge</elcode>.</p>
                  </note>

               </div4>

               <div4 id="streamability-fn-function-lookup">
                  <head>Streamability of the <xfunction>function-lookup</xfunction> Function</head>

                  <p>See <specref ref="function-lookup"/> for special rules that relate to
                     streamability of calls to the <xfunction>function-lookup</xfunction>
                     function.</p>
                  <p>With the caveats given there, the function follows the <termref def="dt-general-streamability-rules"/>, for a function with two arguments
                     that both have <termref def="dt-operand-usage"/>
                     <termref def="dt-absorption"/>.</p>


               </div4>

               <div4 id="streamability-fn-innermost">
                  <head>Streamability of the <xfunction>innermost</xfunction> Function</head>

                  <p>The function follows the <termref def="dt-general-streamability-rules"/>, with
                     the first argument having <termref def="dt-operand-usage"/>
                     <termref def="dt-navigation"/>. This is to reflect the fact that the processing
                     is not strictly sequential: it cannot be determined that a node is part of the
                     result sequence of <xfunction>innermost</xfunction> until all its descendants
                     have been read.</p>



               </div4>


               <div4 id="streamability-fn-last">
                  <head>Streamability of the <xfunction>last</xfunction> Function</head>
                  <p>If the <termref def="dt-context-posture"/> for a call on the
                        <xfunction>last</xfunction> function is <termref def="dt-striding"/>,
                        <termref def="dt-crawling"/>, or <termref def="dt-roaming"/>, then the
                        <termref def="dt-posture"/> of the function is <termref def="dt-roaming"/>,
                     and the <termref def="dt-sweep"/> is <termref def="dt-free-ranging"/>.</p>
                  <p>In all other cases the function is <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                  <note>
                     <p>The cases where <xfunction>last</xfunction> can be used without affecting
                        streamability are where the context item is either <termref def="dt-grounded"/> or <termref def="dt-climbing"/>. The latter condition
                        makes expressions like <code>ancestor::*[@xml:space][last()]</code>
                        streamable.</p>
                     <p>There are special rules restricting the use of <xfunction>last</xfunction>
                        in the predicate of a pattern: see <specref ref="classifying-patterns"/>.</p>
                     <p>Note that there are no restrictions preventing the
                     use of <code>last()</code> when the context posture is grounded. The implications of
                     this are discussed in <specref ref="grounded-consuming-constructs"/>. In the case where
                     the sequence being processed is delivered by a consuming expression, using <code>last()</code>
                     may result in this sequence being buffered in memory.</p>
                  </note>
               </div4>
               <div4 id="streamability-fn-outermost">
                  <head>Streamability of the <xfunction>outermost</xfunction> Function</head>
                  <p>The single argument to this function has <termref def="dt-operand-usage"/>
                     <termref def="dt-transmission"/>.</p>
                  <p>The streamability of the function call follows the <termref def="dt-general-streamability-rules"/> with one exception: if the <termref def="dt-posture"/> of the argument is <termref def="dt-crawling"/>, then the
                     posture of the result is <termref def="dt-striding"/>.</p>
                  <note>
                     <p>There are cases where the streaming rules allow the construct
                           <code>outermost(//para)</code> but do not allow <code>//para</code>; the
                        function can therefore be useful in cases where it is known that
                           <code>para</code> elements will not be nested, as well as cases where the
                        application actually wishes to process all <code>para</code> elements except
                        those that are nested within another.</p>
                     <p>By contrast, the <xfunction>innermost</xfunction> function offers no
                        streaming benefits. Although it delivers a subset of the input nodes as its
                        result, in the correct order, it is classed as navigational because it needs
                        to look ahead in the input stream before deciding whether a node can be
                        included in the result.</p>
                  </note>
               </div4>
               <div4 id="streamability-fn-position">
                  <head>Streamability of the <xfunction>position</xfunction> Function</head>
                  <p>The <xfunction>position</xfunction> function follows the <termref def="dt-general-streamability-rules"/>. Since it has no operands, this means
                     it is <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                  <note>
                     <p>Within an expression, there are no special difficulties in evaluating the
                           <xfunction>position</xfunction> function.</p>
                     <p>It does have special treatment within a predicate of a <termref def="dt-pattern"/>, however: a pattern is not motionless if it contains a
                        call to <xfunction>position</xfunction>, as explained in <specref ref="classifying-patterns"/>. </p>
                  </note>
               </div4>
               <div4 id="streamability-fn-reverse">
                  <head>Streamability of the <xfunction>reverse</xfunction> Function</head>
                  <p>The <xfunction>reverse</xfunction> function follows the <termref def="dt-general-streamability-rules"/>, with its operand classified as
                     having <termref def="dt-operand-usage"/>
                     <termref def="dt-navigation"/>.</p>
                  <note>
                     <p>This means in effect that a call on <xfunction>reverse</xfunction> is not
                        streamable unless the operand is grounded. This may cause few surprises:</p>
                     <ulist>
                        <item>
                           <p>The expression <code>reverse(/*/emp/copy-of())</code> is considered
                              streamable, although all the <code>emp</code> elements will typically
                              need to be in memory at the same time. The explanation here is that
                              the streamability rules do not attempt to restrict the amount of
                              memory used for data that is explicitly copied by use of a function
                              such as <function>copy-of</function>.</p>
                        </item>
                        <item>
                           <p>The expression <code>reverse(ancestor::*)/name()</code> is considered
                              non-streamable, because the operand is not grounded. This problem can
                              be circumvented by rewriting the expression as
                                 <code>reverse(ancestor::*/name())</code></p>
                        </item>
                     </ulist>
                  </note>
               </div4>
               <div4 id="streamability-fn-root">
                  <head>Streamability of the <xfunction>root</xfunction> Function</head>

                  <p>The zero-argument function <code>root()</code> is equivalent to
                        <code>root(.)</code>.</p>
                  <p>Given the expression <code>root(X)</code>, if the <termref def="dt-static-type"/> of <code>X</code> is <var>U{document-node()}</var>, and if its <termref def="dt-posture"/> is <termref def="dt-striding"/>, then
                        <code>root(X)</code> is rewritten as <code>X</code>. Otherwise, it is
                     rewritten as <code>head((X)/ancestor-or-self::node())</code>. Streamability
                     analysis is then applied to the rewritten expression.</p>
                  <note>
                     <p>Because path expressions starting with <code>/</code> are rewritten to use
                        the <xfunction>root</xfunction> function, this ensures that a leading slash
                        is ignored if the context item is a document node, for example within a
                        template rule with <code>match="/"</code>. This improves streamability,
                        because upwards navigation followed by downward navigation is
                        disallowed.</p>
                  </note>
               </div4>
               <!--<div4 id="streamability-fn-unparsed-entity-public-id">
                  <head>Streamability of the <function>unparsed-entity-public-id</function> function</head>
                  <p>The function <function>unparsed-entity-public-id</function> has an implicit dependency on the context item.</p>
                  <p>If the context item type is anything other than a document node, the function works without difficulty in streaming mode: in the same way
                  as attributes of ancestor elements are retained and are available while processing descendant elements, the unparsed entities
                  declared in the DTD are retained while processing the body of the document.</p>
                  <p>While processing the document node itself, however, the contents of the DTD might not yet be available. An arbitrary number
                  of comments and processing instructions are allowed to precede the DTD. </p>
                  <p>So the rules are:</p>
                  <ulist>
                     <item><p>If the <phrase diff="chg" at="Q"><termref def="dt-context-posture"/></phrase> is grounded, the posture is grounded and the sweep is motionless</p></item>
                     <item><p>If the <phrase diff="chg" at="Q"><termref def="dt-context-posture"/></phrase> is roaming, the posture is roaming and the sweep is free-ranging</p></item>
                     <item><p>If the <phrase diff="chg" at="Q"><termref def="dt-context-posture"/></phrase> is climbing, striding, or crawling, the context item type permits a document node, then the posture is crawling
                     and the sweep is consuming</p></item>
                     <item><p>If the <phrase diff="chg" at="Q"><termref def="dt-context-posture"/></phrase> is climbing, striding, or crawling, the context item type does not permit a document node, then the posture is grounded
                        and the sweep is motionless</p></item>
                  </ulist>
               </div4>
               <div4 id="streamability-fn-unparsed-entity-uri">
                  <head>Streamability of the <function>unparsed-entity-uri</function> function</head>
                  <p>The streamability characteristics of this function are the same as <function>unparsed-entity-public-id</function>:
                     see <specref ref="streamability-fn-unparsed-entity-public-id"/>.</p>
               </div4>-->
            </div3>



            <div3 id="classifying-patterns">
               <head>Classifying Patterns</head>

               <note>
                  <p>Patterns differ from other kinds of construct in that they are not composable
                     in the same way. It is best to think of a pattern as specialized syntax for a
                     function that takes an item as its argument and returns a boolean: true if the
                     pattern matches the item, otherwise false. The <termref def="dt-static-type"/> of a pattern is therefore taken as
                           <var>U{xs:boolean}</var> (this is not to be confused with the type of the
                        items that the pattern is capable of matching).</p>
               </note>

               <p>The <termref def="dt-sweep"/> of a <termref def="dt-pattern"/>
                  is either <termref def="dt-motionless"/> or <termref def="dt-free-ranging"/>.
                  (Although there are patterns that could in principle be evaluated by consuming the
                  element node that they match, these are of no interest in the analysis, so they
                  are classified as free-ranging.)</p>

               <p>The <termref def="dt-posture"/> of a <termref def="dt-pattern"/>
                  is <termref def="dt-grounded"/> if the pattern is <termref def="dt-motionless"/>,
                  or <termref def="dt-roaming"/> otherwise. (This reflects the fact that a pattern
                  always returns a boolean result; it never returns a node in a streamed
                  document.)</p>


               

               <p>Informally, a <termref def="dt-motionless"/> pattern is one that
                  can be evaluated by a streaming processor when the input stream is positioned at
                  the start of the node being matched, without
                  advancing the input stream.</p>





               <p>A pattern is <termref def="dt-motionless"/> if and only if it satisfies all the following
                     conditions:</p>

               <olist>
                  <item>
                     <p>The pattern does not contain a <nt def="RootedPath">RootedPath</nt>.</p>
                  </item>

                  <item>
                     <p>If the pattern contains predicates, then every top-level
                           <code>Predicate</code> in the pattern satisfies all the following
                        conditions:</p>
                     <olist>
                        <item>
                           <p>The expression immediately contained in the predicate is <termref def="dt-motionless"/>, when assessed with
                                 a <termref def="dt-context-posture"/> of <termref def="dt-striding"/>, and a context item type set to the <termref def="dt-static-type"/> of the expression to which the predicate
                                 applies, determined using the rules in <specref ref="determining-static-type"/>.</p>
                        </item>
                        <item>
                           <p>The predicate is a <termref def="dt-non-positional-predicate"/>.</p>
                        </item>


                     </olist>

                     <p>The use of the term <term>top-level</term> in this rule means that
                        predicates that are nested within other predicates do not themselves have to
                        be non-positional, though they may play a role in the analysis of top-level
                        predicates.</p>
                  </item>

                  <item>
                     <p>The pattern does not contain (at any depth) a variable reference that is
                        bound to a <termref def="dt-streaming-parameter"/>. (See <specref ref="streamability-of-function-calls"/>).</p>
                  </item>

                  

               </olist>

               <p><termdef id="dt-non-positional-predicate" term="non-positional predicate" open="true">A predicate is a <term>non-positional
                        predicate</term> if it satisfies both of the following
                  conditions:</termdef></p>
               <olist>
                  <item>
                     <p>The predicate does not contain a function call or named function reference
                        to any of the following functions, unless that call or reference occurs
                        within a nested predicate:</p>
                     <olist>
                        <item>
                           <p><xfunction>position</xfunction></p>
                        </item>
                        <item>
                           <p><xfunction>last</xfunction></p>
                        </item>
                        <item>
                           <p><xfunction>function-lookup</xfunction>.</p>
                        </item>
                     </olist>
                     <note>
                        <p>The exception for nested predicates is there to ensure that patterns
                           such as <code>match="p[@code = $status[last()]]</code> are not disqualified.</p>
                     </note>
                  </item>

                  <item>
                     <p>The expression immediately contained in the
                        predicate is a non-numeric expression. An expression is non-numeric if
                           the intersection of its <termref def="dt-static-type"/> (see <specref ref="determining-static-type"/>)
                           with <var>U{xs:decimal, xs:double, xs:float}</var> is
                           <var>U{}</var>.</p>
                  </item>

               </olist>
               <p role="closetermdef"/>

               <note>
                  <p>A non-positional predicate can be evaluated by
                     considering each item in the filtered sequence independently; the result never
                     depends on the position of other items in the sequence or the length of the
                     sequence.</p>
               </note>







               <p>A pattern that is not <termref def="dt-motionless"/> is classified as <termref def="dt-free-ranging"/>.</p>

               <p>The following list shows examples of motionless
                  patterns:</p>

               <ulist>
                  <item>
                     <p><code>/</code></p>
                  </item>
                  <item>
                     <p><code>*</code></p>
                  </item>
                  <item>
                     <p><code>/*</code></p>
                  </item>
                  <item>
                     <p><code>p</code></p>
                  </item>
                  <item>
                     <p><code>p|q</code></p>
                  </item>
                  <item>
                     <p><code>p/q</code></p>
                  </item>
                  <item>
                     <p><code>p[@status='red']</code></p>
                  </item>
                  <item>
                     <p><code>p[base-uri()]</code></p>
                  </item>
                  <item>
                     <p><code>p[@class or @style]</code></p>
                  </item>
                  <item>
                     <p><code>p[@status]</code></p>
                  </item>
                  <item>
                     <p><code>p[@status = $status-codes[1]]</code></p>
                  </item>
                  <item>
                     <p><code>p[@class | @style]</code></p>
                  </item>
                  <item>
                     <p><code>p[contains(@class, ':')]</code></p>
                  </item>
                  <item>
                     <p><code>p[substring-after(@class, ':')]</code></p>
                  </item>
                  <item>
                     <p><code>p[ancestor::*[@xml:lang]]</code></p>
                  </item>
                  <item>
                     <p><code>text()[starts-with(., '$')]</code></p>
                  </item>
                  <item>
                     <p><code>@price</code></p>
                  </item>
                  <item>
                     <p><code>@price[starts-with(., '$')]</code></p>
                  </item>
                  <item>
                     <p><code>//p/text()[. = 'Introduction']</code></p>
                  </item>
                  <item>
                     <p><code>document-node(element(html))</code> (Note:
                        this is classified as motionless even though testing a document node against
                        the pattern might require a small amount of look-ahead.)</p>
                  </item>
               </ulist>

               <p>The following list shows examples of patterns that are
                  not motionless, explaining why not:</p>

               <ulist>
                  <item>
                     <p><code>id('abc')</code> (contains a <code>RootedPath</code>)</p>
                  </item>
                  <item>
                     <p><code>$doc//p</code> (contains a <code>RootedPath</code>)</p>
                  </item>
                  <item>
                     <p><code>p[b]</code> (the predicate is not motionless)</p>
                  </item>
                  <item>
                     <p><code>p[. = 'Introduction']</code> (the predicate is not motionless)</p>
                  </item>
                  <item>
                     <p><code>p[starts-with(., '$')]</code> (the predicate is not motionless)</p>
                  </item>
                  <item>
                     <p><code>p[preceding-sibling::p[1] = '']</code> (the predicate is not
                        motionless)</p>
                  </item>
                  <item>
                     <p><code>p[1]</code> (contains a positional predicate: return type is
                        numeric)</p>
                  </item>
                  <item>
                     <p><code>p[$pnum + 1]</code> (contains a positional predicate: return type is
                        numeric)</p>
                  </item>
                  <item>
                     <p><code>p[data(@status)]</code> (contains a positional predicate: return type
                        is potentially numeric)</p>
                  </item>
                  <item>
                     <p><code>p[position() gt 2]</code> (contains a positional predicate: calls
                           <code>position()</code>)</p>
                  </item>
                  <item>
                     <p><code>p[last()]</code> (contains a positional predicate: calls
                           <code>last()</code>)</p>
                  </item>
               </ulist>

            </div3>
         </div2>
         <div2 id="streamability-analysis-examples">
            <head>Examples of Streamability Analysis</head>
            <p>The examples in this section are intended to illustrate how the streamability rules
               are applied “top down” to establish whether template rules are guaranteed
               streamable.</p>
            <example>
               <head>A recursive-descent template rule</head>
               <p>Consider the following template rule, where mode <code>s</code> is defined with
                     <code>streamable="yes"</code>:</p>
               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:template match="para" mode="s"&gt;
  &lt;div class="para"&gt;
    &lt;xsl:apply-templates mode="s"/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;</eg>
               <p>The processor is required to establish that this template meets the streamability
                  rules. Specifically, as stated in <specref ref="streamable-templates"/>, it must
                  satisfy three conditions:</p>
               <olist>
                  <item>
                     <p>The match pattern must be <termref def="dt-motionless"/>.</p>
                  </item>
                  <item>
                     <p>The body of the template rule must be <termref def="dt-grounded"/>.</p>
                  </item>
                  <item>
                     <p>The initializers of any template parameters must be <termref def="dt-motionless"/>.</p>
                  </item>
               </olist>
               <p>The third condition is satisfied trivially because there are no parameters.</p>
               <p>The first rule depends on the rules for assessing patterns, which are given in
                     <specref ref="classifying-patterns"/>. This pattern is motionless because (a)
                  it does not contain a <code>RootedPath</code>, and (b) it contains no
                  predicates.</p>
               <p>So it remains to determine that the body of the template is <termref def="dt-grounded"/>. The proof of this is as follows:</p>
               <olist>
                  <item>
                     <p>The sequence constructor forming the body of the template is assessed
                        according to the rules in <specref ref="classifying-sequence-constructors"/>, which tell us that there is a single operand (the
                           <code>&lt;div&gt;</code>
                        <termref def="dt-literal-result-element"/>) which has <termref def="dt-operand-usage"/>
                        <var>U</var> = <termref def="dt-transmission"/>. </p>
                  </item>
                  <item>
                     <p>The assessment of the sequence constructor uses the <termref def="dt-general-streamability-rules"/>. These rules require us to
                        determine the type <var>T</var>, sweep <var>S</var>, posture <var>P</var>,
                        and usage <var>U</var> of each operand. We have already established that
                        there is a single operand, with <var>U</var> = <termref def="dt-transmission"/>. Section <specref ref="determining-static-type"/>
                        tells us that for all instructions, we can take <var>T</var> =
                           <var>U{*}</var>. The <termref def="dt-posture"/>
                        <var>P</var> and <termref def="dt-sweep"/>
                        <var>S</var> of the literal result element are established as follows:</p>

                     <olist>


                        <item>
                           <p>The rules for literal result elements (specifically the
                                 <code>&lt;div&gt;</code> element) are given in <specref ref="streamability-literal-result-elements"/>. This particular
                              literal result element has only one operand (its contained sequence
                              constructor), with <termref def="dt-operand-usage"/>
                              <var>U</var> = <termref def="dt-absorption"/>.</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-general-streamability-rules"/> again apply. Again
                              the <termref def="dt-static-type"/>
                              <var>T</var> of the operand is <code>U{*}</code>, and we need to
                              determine the <termref def="dt-posture"/>
                              <var>P</var> and <termref def="dt-sweep"/>
                              <var>S</var>.</p>
                        </item>
                        <item>
                           <p>To determine the posture and sweep of this sequence constructor (the
                              one that contains the <elcode>xsl:apply-templates</elcode>
                              instruction) we refer again to the <termref def="dt-general-streamability-rules"/>.</p>

                           <olist>
                              <item>
                                 <p>The sequence constructor has a single operand (the
                                       <elcode>xsl:apply-templates</elcode> instruction); again
                                       <var>U</var> = <termref def="dt-transmission"/>, <var>T</var>
                                    = <var>U{*}</var>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-posture"/>
                                    <var>P</var> and <termref def="dt-sweep"/>
                                    <var>S</var> of the <elcode>xsl:apply-templates</elcode>
                                    instruction are established as follows:</p>

                                 <olist>
                                    <item>
                                       <p>The rules that apply are in <specref ref="streamability-xsl-apply-templates"/>.</p>
                                    </item>
                                    <item>
                                       <p>Rule 1 does not apply because the <code>select</code>
                                          expression (which defaults to <code>child::node()</code>)
                                          is not <termref def="dt-grounded"/>. This is a consequence
                                          of the rules in <specref ref="streamability-of-axis-steps"/>, specifically:</p>
                                       <olist>
                                          <item>
                                             <p>The <termref def="dt-context-posture"/> of the axis
                                                step is established by the template rule as a whole,
                                                as <termref def="dt-striding"/>.</p>
                                          </item>
                                          <item>
                                             <p>Therefore rules 1 and 2 do not apply.</p>
                                          </item>
                                          <item>
                                             <p>The statically-inferred context item type is derived
                                                from the match pattern (<code>match="para"</code>).
                                                This gives a type of <var>U{element()}</var>. The
                                                child axis for element nodes is not necessarily
                                                empty, so rule 3 does not apply.</p>
                                          </item>
                                          <item>
                                             <p>Rule 4 does not apply because there are no
                                                predicates.</p>
                                          </item>
                                          <item>
                                             <p>So the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the axis step
                                                  <code>child::node()</code> are given by the table
                                                in rule 5. The entry for (context posture =
                                                striding, axis = child) gives a posture of <termref def="dt-striding"/> and a <termref def="dt-sweep"/> of <termref def="dt-consuming"/>.</p>
                                          </item>
                                          <item>
                                             <p>So the <code>select</code> expression is not
                                                  <termref def="dt-grounded"/>. (The same result can
                                                be reached intuitively: an expression that selects
                                                streamed nodes will never be <termref def="dt-grounded"/>.)</p>
                                          </item>
                                       </olist>

                                    </item>
                                    <item>
                                       <p>Rule 2 does not apply because there is no
                                             <elcode>xsl:sort</elcode> element.</p>
                                    </item>
                                    <item>
                                       <p>Rule 3 does not apply because the mode is declared with
                                             <code>streamable="yes"</code>.</p>
                                    </item>
                                    <item>
                                       <p>So the <termref def="dt-posture"/>
                                          <var>P</var> and <termref def="dt-sweep"/>
                                          <var>S</var> of the <elcode>xsl:apply-templates</elcode>
                                          instruction are established by the <termref def="dt-general-streamability-rules"/>, as follows:</p>
                                       <olist>
                                          <item>
                                             <p>There is a single operand, the implicit
                                                  <code>select="child::node()"</code> expression,
                                                with usage <var>U</var> = <termref def="dt-absorption"/>.</p>
                                          </item>
                                          <item>
                                             <p>We have already established that for this operand,
                                                the posture <var>P</var> = <termref def="dt-striding"/> and the <termref def="dt-sweep"/>
                                                <var>S</var> = <termref def="dt-consuming"/>.</p>
                                          </item>
                                          <item>
                                             <p>By the rules in <specref ref="determining-static-type"/>, the type
                                                  <var>T</var> of the <code>select</code> expression
                                                is <code>node()</code>.</p>
                                          </item>
                                          <item>
                                             <p>In the <termref def="dt-general-streamability-rules"/>, the adjusted sweep <var>S'</var> for an operand
                                                with (<var>P</var> = <termref def="dt-striding"/>,
                                                  <var>U</var> = <termref def="dt-absorption"/>) is
                                                  <termref def="dt-consuming"/>, </p>
                                          </item>
                                          <item>
                                             <p>Rule 2(d) then applies, so the
                                                  <elcode>xsl:apply-templates</elcode> instruction
                                                is <termref def="dt-consuming"/> and <termref def="dt-grounded"/>.</p>
                                          </item>
                                       </olist>

                                    </item>
                                 </olist>
                              </item>

                              <item>
                                 <p>So the sequence constructor that contains the
                                       <elcode>xsl:apply-templates</elcode> instruction has one
                                    operand with <var>U</var> = <termref def="dt-transmission"/>,
                                       <var>T</var> = <code>item()</code>, <var>P</var> = <termref def="dt-grounded"/>, <var>S</var> = <termref def="dt-consuming"/>. Rule 2(d) of the <termref def="dt-general-streamability-rules"/> applies, so the
                                    sequence constructor itself has <var>P</var> = <termref def="dt-grounded"/>, <var>S</var> = <termref def="dt-consuming"/>.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>So the literal result element has one operand with <var>U</var> =
                                 <termref def="dt-absorption"/>, <var>T</var> = <code>item()</code>,
                                 <var>P</var> = <termref def="dt-grounded"/>, <var>S</var> =
                                 <termref def="dt-consuming"/>. Rule 2(d) of the <termref def="dt-general-streamability-rules"/> applies, so the literal
                              result element has <var>P</var> = <termref def="dt-grounded"/>,
                                 <var>S</var> = <termref def="dt-consuming"/>.</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>So the sequence constructor containing the literal result element has one
                        operand with <var>U</var> = <termref def="dt-transmission"/>, <var>T</var> =
                           <code>item()</code>, <var>P</var> = <termref def="dt-grounded"/>,
                           <var>S</var> = <termref def="dt-consuming"/>. Rule 2(d) of the <termref def="dt-general-streamability-rules"/> applies, so this sequence
                        constructor itself has <var>P</var> = <termref def="dt-grounded"/>,
                           <var>S</var> = <termref def="dt-consuming"/>.</p>
                  </item>
                  <item>
                     <p>So we have established that the sequence constructor forming the body of the
                        template rule is <termref def="dt-grounded"/>.</p>
                  </item>


               </olist>
               <p>Therefore, since the other conditions are also satisfied, the template is <termref def="dt-guaranteed-streamable"/>.</p>
               <p>The analysis presented above could have been simplified by taking into account the
                  fact that the streamability properties of a sequence constructor containing a
                  single instruction are identical to the properties of that instruction. This
                  simplification will be exploited in the next example.</p>
            </example>
            <example>
               <head>An aggregating template rule</head>
               <p>Consider the following template rule, where mode <code>s</code> is defined with
                     <code>streamable="yes"</code>:</p>
               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:template match="transactions[@currency='USD']" mode="s"&gt;
  &lt;total&gt;&lt;xsl:value-of select="sum(transaction/@value)"/&gt;&lt;/total&gt;
&lt;/xsl:template&gt;</eg>
               <p>Again, as stated in <specref ref="streamable-templates"/>, it must satisfy three
                  conditions:</p>
               <olist>
                  <item>
                     <p>The match pattern must be <termref def="dt-motionless"/>.</p>
                  </item>
                  <item>
                     <p>The body of the template rule must be <termref def="dt-grounded"/>.</p>
                  </item>
                  <item>
                     <p>The initializers of any template parameters must be <termref def="dt-motionless"/>.</p>
                  </item>
               </olist>
               <p>The third condition is satisfied trivially because there are no parameters.</p>

               <p>The first rule depends on the rules for assessing patterns, which are given in
                     <specref ref="classifying-patterns"/>. This pattern is motionless because (a)
                  it is not a <code>RootedPath</code>, and (b) every predicate is <termref def="dt-motionless"/> and <termref def="dt-non-positional-predicate">non-positional</termref>. The analysis that proves the predicate is motionless
                  and non-positional proceeds as follows:</p>
               <olist>
                  <item>
                     <p>First establish that the expression <code>@currency='USD'</code> is
                           <termref def="dt-motionless"/>, as follows:</p>
                     <olist>
                        <item>
                           <p>The predicate is a general comparison (<code>GeneralComp</code>) which
                              follows the <termref def="dt-general-streamability-rules"/>.</p>
                        </item>
                        <item>
                           <p>There are two operands: an <code>AxisStep</code> with a defaulted
                                 <code>ForwardAxis</code>, and a <code>Literal</code>. Both operand
                              roles are <termref def="dt-absorption"/>.</p>
                        </item>
                        <item>
                           <p>The left-hand operand has
                              type <var>T</var> = <code>attribute()</code>. Its <termref def="dt-posture"/> and <termref def="dt-sweep"/> are determined by
                              the rules in <specref ref="streamability-of-axis-steps"/>. The
                                 <termref def="dt-context-posture"/> is <termref def="dt-striding"/>, so the <termref def="dt-posture"/> and <termref def="dt-sweep"/>
                              are determined by the entry in the table (rule 5) with context posture
                              = <termref def="dt-striding"/>, axis = <code>attribute</code>: that
                              is, the result posture is <termref def="dt-striding"/> and the <termref def="dt-sweep"/>
                              is <termref def="dt-motionless"/>.</p>
                        </item>
                        <item>
                           <p>The right-hand operand,
                              being a literal, is <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                        </item>
                        <item>
                           <p>In the <termref def="dt-general-streamability-rules"/>, rule 2(e)
                              applies, so the predicate is <termref def="dt-grounded"/> and <termref def="dt-motionless"/></p>
                        </item>
                     </olist>

                  </item>
                  <item>
                     <p>Now establish that the expression <code>@currency='USD'</code> is
                           <termref def="dt-non-positional-predicate">non-positional</termref>, as
                        follows:</p>
                     <olist>
                        <item>
                           <p>Rule 1 is satisfied: the predicate does not call
                                 <xfunction>position</xfunction>, <xfunction>last</xfunction>, or
                                 <xfunction>function-lookup</xfunction>.</p>
                        </item>
                        <item>
                           <p>Rule 2 is satisfied: the expression <code>@currency='USD'</code> is
                              non-numeric. The <termref def="dt-static-type"/> of the expression is
                              determined using the rules in <specref ref="determining-static-type"/>
                              as <var>U{xs:boolean}</var>, and this has no intersection with
                                 <var>U{xs:decimal, xs:double, xs:float}</var>.</p>
                        </item>
                     </olist>

                  </item>
               </olist>

               <p>So both conditions in <specref ref="classifying-patterns"/> are satisfied, and the
                  pattern is therefore <termref def="dt-motionless"/>.</p>


               <p>It remains to show that the body of the template rule is <termref def="dt-grounded"/>. The proof of this is as follows. Unlike the previous
                  example, the analysis is shown in simplified form; in particular the two sequence
                  constructors which each contain a single instruction are ignored, and replaced in
                  the construct tree by their contained instruction.</p>
               <olist>
                  <item>
                     <p>We need to show that the <code>&lt;total&gt;</code>
                        <termref def="dt-literal-result-element"/> is <termref def="dt-grounded"/>.</p>
                  </item>
                  <item>
                     <p>The rules that apply are in <specref ref="streamability-literal-result-elements"/>.</p>
                  </item>
                  <item>
                     <p>These rules refer to the <termref def="dt-general-streamability-rules"/>.
                        There is one operand, the <elcode>xsl:value-of</elcode> child element, which
                        has <termref def="dt-operand-usage"/>
                        <var>U</var> = <termref def="dt-absorption"/>, and type <var>T</var> =
                           <code>item()</code>.</p>
                  </item>
                  <item>
                     <p>So we need to determine the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the <elcode>xsl:value-of</elcode> instruction.</p>
                     <olist>
                        <item>
                           <p>The rules are given in <specref ref="streamability-xsl-value-of"/>.</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-general-streamability-rules"/> apply. There is
                              one operand, the expression <code>sum(transaction/@value)</code>,
                              which has <termref def="dt-operand-usage"/>
                              <var>U</var> = <termref def="dt-absorption"/>.</p>
                        </item>
                        <item>
                           <p>The type <var>T</var> of this operand is the return type defined in
                              the signature of the <xfunction>sum</xfunction> function, that is,
                                 <code>xs:anyAtomicType</code>.</p>
                        </item>
                        <item>
                           <p>The <termref def="dt-posture"/>
                              <var>P</var> and <termref def="dt-sweep"/>
                              <var>S</var> are established as follows:</p>
                           <olist>
                              <item>
                                 <p>The rules that apply to the call on <xfunction>sum</xfunction>
                                    are given in <specref ref="classifying-built-in-functions"/>.</p>
                              </item>
                              <item>
                                 <p>The relevant proforma is <code>fn:sum(A)</code>, indicating that
                                    the <termref def="dt-general-streamability-rules"/> apply, and
                                    that there is a single operand with usage <var>U</var> =
                                       <termref def="dt-absorption"/>.</p>
                              </item>
                              <item>
                                 <p>The type <var>T</var> of the operand
                                       <code>transaction/@value</code> is determined (by the rules
                                    in <specref ref="determining-static-type"/>) as
                                       <code>attribute()</code>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-posture"/>
                                    <var>P</var> and <termref def="dt-sweep"/>
                                    <var>S</var> of the operand <code>transaction/@value</code> are
                                    determined by the rules in <specref ref="streamability-of-path-expressions"/>, as follows:</p>
                                 <olist>
                                    <item>
                                       <p>The expression is expanded to
                                             <code>child::transaction/attribute::value</code>.</p>
                                    </item>
                                    <item>
                                       <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of the left-hand operand
                                             <code>child::transaction</code> are determined by the
                                          rules in <specref ref="streamability-of-axis-steps"/>, as
                                          follows:</p>
                                       <olist>
                                          <item>
                                             <p>The <termref def="dt-context-posture"/> is <termref def="dt-striding"/>, because the <termref def="dt-focus-setting-container"/> is the template
                                                rule itself.</p>
                                          </item>
                                          <item>
                                             <p>The <termref def="dt-context-item-type"/> is
                                                  <code>element()</code>, based on the <termref def="dt-match-type"/> of the pattern
                                                  <code>match="transactions[@currency='USD']"</code>.</p>
                                          </item>
                                          <item>
                                             <p>Rules 1 and 2 do not apply because the <termref def="dt-context-posture"/> is <termref def="dt-striding"/>.</p>
                                          </item>
                                          <item>
                                             <p>Rule 3 does not apply because the <code>child</code>
                                                axis applied to an element node is not necessarily
                                                empty.</p>
                                          </item>
                                          <item>
                                             <p>Rule 4 does not apply because there are no
                                                predicates.</p>
                                          </item>
                                          <item>
                                             <p>Rule 5 applies, and the table entry with context
                                                posture = <termref def="dt-striding"/>, axis =
                                                  <code>child</code> gives a result <termref def="dt-posture"/> of <termref def="dt-striding"/>
                                                and a <termref def="dt-sweep"/> of <termref def="dt-consuming"/>.</p>
                                          </item>
                                       </olist>
                                    </item>
                                    <item>
                                       <p>The <termref def="dt-posture"/> of the relative path
                                          expression
                                             <code>child::transaction/attribute::value</code> is
                                          therefore the <termref def="dt-posture"/> of its right-hand operand
                                             <code>attribute::value</code>, assessed with a <termref def="dt-context-posture"/> of <termref def="dt-striding"/>. This is determined by the rules in
                                             <specref ref="streamability-of-axis-steps"/>, as
                                          follows:</p>
                                       <olist>
                                          <item>
                                             <p>The <termref def="dt-context-posture"/>, as we have
                                                seen, is <termref def="dt-striding"/>.</p>
                                          </item>
                                          <item>
                                             <p>The <termref def="dt-context-item-type"/> is
                                                  <code>element()</code>, based on the type of the
                                                  left-hand operand
                                                  <code>child::transaction</code>.</p>
                                          </item>
                                          <item>
                                             <p>Rules 1 and 2 do not apply because the <termref def="dt-context-posture"/> is <termref def="dt-striding"/>.</p>
                                          </item>
                                          <item>
                                             <p>Rule 3 does not apply because the
                                                  <code>attribute</code> axis applied to an element
                                                node is not necessarily empty.</p>
                                          </item>
                                          <item>
                                             <p>Rule 4 does not apply because there are no
                                                predicates.</p>
                                          </item>
                                          <item>
                                             <p>Rule 5 applies, and the table entry with context
                                                posture = <termref def="dt-striding"/>, axis =
                                                  <code>attribute</code> gives a result <termref def="dt-posture"/> of <termref def="dt-striding"/> and a <termref def="dt-sweep"/> of
                                                  <termref def="dt-motionless"/>.</p>
                                          </item>
                                       </olist>
                                    </item>
                                    <item>
                                       <p>The <termref def="dt-posture"/> of the relative path
                                          expression
                                             <code>child::transaction/attribute::value</code> is
                                          therefore <termref def="dt-striding"/>.</p>
                                    </item>
                                    <item>
                                       <p>The <termref def="dt-sweep"/> of the relative path
                                          expression
                                             <code>child::transaction/attribute::value</code> is the
                                          wider of the sweeps of its two operands, namely <termref def="dt-consuming"/> and <termref def="dt-motionless"/>. That is, it is <termref def="dt-consuming"/>.</p>
                                    </item>
                                 </olist>
                              </item>
                              <item>
                                 <p>So the first and only operand to the call on <code>sum()</code>
                                    has <var>U</var> = <termref def="dt-absorption"/>, <var>T</var>
                                    = <code>attribute()</code>, <var>P</var> = <termref def="dt-climbing"/>, and <var>S</var> = <termref def="dt-consuming"/></p>
                              </item>
                              <item>
                                 <p>Rule 1(b) of the <termref def="dt-general-streamability-rules"/>
                                    computes the adjusted sweep <var>S'</var>. Rule 1(b)(iii)(A)
                                    applies, so the effective <termref def="dt-operand-usage"/>
                                    <var>U'</var> is <termref def="dt-inspection"/>. Rule
                                    1(b)(iii)(A) then computes the adjusted sweep from the table
                                    entry for <var>P</var> = <termref def="dt-climbing"/>,
                                       <var>U'</var> = <termref def="dt-inspection"/>; this shows
                                       <var>S'</var> = <var>S</var>, that is, <termref def="dt-consuming"/>.</p>
                              </item>
                              <item>
                                 <p>Rule 2(d) now applies, so the call on <code>sum()</code> is
                                       <termref def="dt-grounded"/> and <termref def="dt-consuming"/>.</p>
                              </item>
                           </olist>
                        </item>

                        <item>
                           <p>Since the <elcode>xsl:value-of</elcode> instruction has one operand
                              with <var>U</var> = <termref def="dt-absorption"/>, <var>T</var> =
                                 <code>xs:anyAtomicType</code>, <var>P</var> = <termref def="dt-grounded"/>, and <var>S</var> = <termref def="dt-consuming"/>, rule 2(d) again applies, and the <elcode>xsl:value-of</elcode>
                              instruction is <termref def="dt-grounded"/> and <termref def="dt-consuming"/>.</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>Since the literal result element has one operand with <var>U</var> =
                           <termref def="dt-absorption"/>, <var>T</var> = <code>item()</code>,
                           <var>P</var> = <termref def="dt-grounded"/>, and <var>S</var> = <termref def="dt-consuming"/>, rule 2(d) again applies, and the literal result
                        element is <termref def="dt-grounded"/> and <termref def="dt-consuming"/>.</p>
                  </item>
                  <item>
                     <p>Therefore the body of the template rule is <termref def="dt-grounded"/>, and
                        since the other conditions are also satisfied, it is <termref def="dt-guaranteed-streamable"/>.</p>
                  </item>
               </olist>

            </example>

            <example>
               <head>Streamed Grouping</head>
               <p>Consider the following code, which is designed to process a transaction file
                  containing transactions in chronological order, and output the total value of the
                  transactions for each day.</p>

               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:template name="go"&gt;
  &lt;out&gt;
    &lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
      &lt;xsl:for-each-group select="/account/transaction" 
                          group-adjacent="xs:date(@timestamp)"&gt;
         &lt;total date="{current-grouping-key()}" value="{sum(current-group()/@value)}"/&gt;
      &lt;/xsl:for-each-group&gt;
    &lt;/xsl:source-document&gt;
  &lt;/out&gt;
&lt;/xsl:template&gt;</eg>


               <p>The rules for <elcode>xsl:source-document</elcode> say that the instruction is <termref def="dt-guaranteed-streamable"/> if the contained <termref def="dt-sequence-constructor"/> is <termref def="dt-grounded"/>, and the task
                  of streamability analysis is to prove that this is the case. As in the previous
                  example, we will take a short-cut by making the assumption that a sequence
                  constructor containing a single instruction can be replaced by that instruction in
                  the construct tree.</p>

               <p>So the task is to show that the <elcode>xsl:for-each-group</elcode> instruction is
                     <termref def="dt-grounded"/>, which we can do as follows:</p>

               <olist>
                  <item>
                     <p>The relevant rules are to be found in <specref ref="streamability-xsl-for-each-group"/>.</p>
                     <note>
                        <p>Rule numbers may be different in a version of the specification with
                           change markings.</p>
                     </note>
                  </item>
                  <item>
                     <p>Rule 1 applies only if the <code>select</code> expression is <termref def="dt-grounded"/>. It is easy to see informally that this is not the
                        case (an expression that returns streamed nodes is never grounded). More
                        formally:</p>
                     <olist>
                        <item>
                           <p>The <code>select</code> expression is a path expression; the rules in
                                 <specref ref="streamability-of-path-expressions"/> apply.</p>
                        </item>
                        <item>
                           <p>The expression is rewritten as <code>((root(.) treat as
                                 document-node())/child::account)/child::transaction</code></p>
                        </item>
                        <item>
                           <p>The left-hand operand <code>(root(.) treat as
                                 document-node())/child::account</code> is also a path expression,
                              so the rules in <specref ref="streamability-of-path-expressions"/>
                              apply recursively:</p>
                           <olist>
                              <item>
                                 <p>The left-hand operand <code>root(.) treat as
                                       document-node()</code> follows the rules for a
                                       <code>TreatExpr</code> in <specref ref="classifying-expressions"/>; the proforma <code>T treat
                                       as TYPE</code> indicates that the <termref def="dt-general-streamability-rules"/> apply with a single
                                    operand having usage <termref def="dt-transmission"/>.</p>
                              </item>
                              <item>
                                 <p>This single operand <code>root(.)</code> follows the rules in
                                       <specref ref="streamability-fn-root"/>. The item type of the
                                    operand <code>.</code> is the <termref def="dt-context-item-type"/>, which is the type established
                                    by the <elcode>xsl:source-document</elcode> instruction, namely
                                       <code>document-node()</code>. Under these conditions
                                       <code>root(.)</code> is rewritten as <code>.</code>, so the
                                       <termref def="dt-posture"/> is the <termref def="dt-context-posture"/> established by the
                                       <elcode>xsl:source-document</elcode> instruction, namely <termref def="dt-striding"/>. The <termref def="dt-sweep"/> is
                                       <termref def="dt-motionless"/>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                                    the expression <code>root(.) treat as document-node()</code> are
                                    the same as the <termref def="dt-posture"/> and <termref def="dt-sweep"/> of <code>root(.)</code>, namely <termref def="dt-striding"/> and <termref def="dt-motionless"/></p>
                              </item>
                              <item>
                                 <p>The right-hand operand <code>child::account</code> is governed
                                    by the rules in <specref ref="streamability-of-axis-steps"/>.
                                    The <termref def="dt-context-posture"/> is <termref def="dt-striding"/>, and the axis is <code>child</code>, so
                                    the result posture is <termref def="dt-striding"/> and the sweep
                                    is <termref def="dt-consuming"/>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-posture"/> of the path expression is the
                                       <termref def="dt-posture"/> of the right-hand operand, that
                                    is <termref def="dt-striding"/>, and its sweep is the wider
                                    sweep of the two operands, that is <termref def="dt-consuming"/></p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>Returning to the outer path expression, the <termref def="dt-posture"/> of the right hand operand <code>child::transaction</code> is
                                 <termref def="dt-striding"/>, and its sweep is <termref def="dt-consuming"/>.</p>
                        </item>
                        <item>
                           <p>So the <termref def="dt-posture"/> of the <code>select</code>
                              expression as a whole is the posture of the right hand operand, that
                              is <termref def="dt-striding"/>; and its sweep is the wider of the
                              sweeps of the operands, which is <termref def="dt-consuming"/>.</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>Rule 2 does not apply: there is no <code>group-by</code> attribute.</p>
                  </item>
                  <item>
                     <p>Rule 3 does not apply: there is a <code>group-adjacent</code> attribute, but
                        it is <termref def="dt-motionless"/>. The reasoning is as follows:</p>
                     <olist>
                        <item>
                           <p>The value is a call to the constructor function <code>xs:date</code>.
                              The rules in <specref ref="streamability-of-function-calls"/> apply.
                              There is a single operand, whose required type is atomic, so the
                                 <termref def="dt-operand-usage"/> is <termref def="dt-absorption"/>.</p>
                        </item>
                        <item>
                           <p>These rules refer to the <termref def="dt-general-streamability-rules"/>, so we need to determine the <termref def="dt-context-item-type"/>,
                                 <termref def="dt-posture"/>, and <termref def="dt-sweep"/> of the
                              operand expression <code>@timestamp</code>. This is done as
                              follows:</p>
                           <olist>
                              <item>
                                 <p>The expression is an <code>AxisStep</code>, so the relevant
                                    rules are in <specref ref="streamability-of-axis-steps"/>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-context-posture"/> is the <termref def="dt-posture"/> of the <termref def="dt-controlling-operand"/> of the <termref def="dt-focus-setting-container"/>, that is, is the
                                       <code>select</code> expression of the containing
                                       <elcode>xsl:for-each-group</elcode> instruction, which as
                                    established above is <termref def="dt-striding"/>. The <termref def="dt-context-item-type"/> is similarly the inferred type
                                    of the <code>select</code> expression, and is
                                       <code>element()</code>.</p>
                              </item>
                              <item>
                                 <p>Rules 1 and 2 do not apply because the <termref def="dt-context-posture"/> is <termref def="dt-striding"/>.</p>
                              </item>
                              <item>
                                 <p>Rule 3 does not apply because the attribute axis for an element
                                    node is not necessarily empty.</p>
                              </item>
                              <item>
                                 <p>Rule 4 does not apply because there is no predicate.</p>
                              </item>
                              <item>
                                 <p>So the <termref def="dt-sweep"/> and <termref def="dt-posture"/>
                                    of the expression <code>@timestamp</code> are given by the table
                                    in Rule 5 as <termref def="dt-striding"/> and <termref def="dt-motionless"/>.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>Returning to the <termref def="dt-general-streamability-rules"/> for
                              the expression <code>xs:date(@timestamp)</code>, the operand <code>@timestamp</code>
                              has <var>U</var> = <termref def="dt-absorption"/>, <var>T</var> =
                                 <code>attribute()</code>, <var>P</var> = <termref def="dt-striding"/>, <var>S</var>
                              = <termref def="dt-motionless"/>. </p>
                        </item>
                        <item>
                           <p>Under Rule 1(b)(iii)(A), because <var>T</var> =
                                 <code>attribute()</code>, the <termref def="dt-operand-usage"/>
                              <var>U'</var> becomes <termref def="dt-inspection"/>.</p>
                        </item>
                        <item>
                           <p>Under Rule 1(b)(iii)(A), <var>S'</var> = <var>S</var> = <termref def="dt-motionless"/>.</p>
                        </item>
                        <item>
                           <p>Under Rule 2(e), the expression <code>xs:date(@timestamp)</code> is
                                 <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                        </item>
                     </olist>

                  </item>
                  <item>
                     <p>Rule 4 (under <elcode>xsl:for-each-group</elcode>) does not apply, because
                        there is no <elcode>xsl:sort</elcode> child.</p>
                  </item>
                  
                  
                  <item>
                     <p>So Rule 5 applies. This relies on knowing the <termref def="dt-posture"/> of
                        the sequence constructor contained in the
                           <elcode>xsl:for-each-group</elcode> instruction: that is, the <termref def="dt-posture"/> of the <code>total</code>
                        <termref def="dt-literal-result-element"/>. This is calculated as
                        follows:</p>
                     <olist>
                        <item>
                           <p>The rules that apply are in <specref ref="streamability-literal-result-elements"/>. The <termref def="dt-general-streamability-rules"/> apply; there are two
                              operands, the attribute value templates
                                 <code>{current-grouping-key()}</code> and
                                 <code>{sum(current-group()/@value)}</code>, and in each case the
                              usage is <termref def="dt-absorption"/>. We can simplify the analysis
                              by observing that the empty <termref def="dt-sequence-constructor"/>
                              contained in the literal result element can be ignored, since it is
                                 <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.
                           </p>
                        </item>
                        <item>
                           <p>Consider first the operand <code>{current-grouping-key()}</code>.</p>
                           <olist>
                              <item>
                                 <p>Section <specref ref="classifying-vts"/> applies. This refers to
                                    the <termref def="dt-general-streamability-rules"/>; there is a
                                    single operand, the expression
                                       <code>current-grouping-key()</code>, with usage <termref def="dt-absorption"/>.</p>
                              </item>

                              <item>
                                 <p>Section <specref ref="streamability-fn-current-grouping-key"/>
                                    applies. This establishes that the expression is <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                              </item>
                              <item>
                                 <p>It follows that the operand
                                       <code>{current-grouping-key()}</code> expression is also
                                       <termref def="dt-grounded"/> and <termref def="dt-motionless"/>.</p>
                              </item>
                           </olist>
                        </item>

                        <item>
                           <p>Now consider the operand
                              <code>{sum(current-group()/@value)}</code>.</p>
                        </item>
                        <item>
                           <p>Section <specref ref="classifying-vts"/> applies. This refers to the
                                 <termref def="dt-general-streamability-rules"/>; there is a single
                              operand, the expression <code>sum(current-group()/@value)</code>, with
                              usage <termref def="dt-absorption"/>.</p>
                        </item>
                        <item>
                           <p>The rules for the <code>sum</code> function appear in <specref ref="classifying-built-in-functions"/>. The proforma is given there
                              as <code>fn:sum(A)</code>, which means that the <termref def="dt-general-streamability-rules"/> apply, and that the single
                              operand <code>current-group()/@value</code> has usage <termref def="dt-absorption"/>. So we need to establish the <termref def="dt-posture"/>, <termref def="dt-sweep"/>, and type of this
                              expression, which we can do as follows:</p>
                           <olist>
                              <item>
                                 <p>The expression is a <code>RelativePathExpr</code>, so section
                                       <specref ref="streamability-of-path-expressions"/>
                                    applies.</p>
                              </item>
                              <item>
                                 <p>The expression is expanded to
                                       <code>current-group()/attribute::value</code>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                                    the left-hand operand <code>current-group()</code> are defined
                                    in <specref ref="streamability-fn-current-group"/>. Since all
                                    the required conditions are satisfied, the <termref def="dt-posture"/> of <code>current-group()</code> is the
                                       <termref def="dt-posture"/> of the <code>select</code>
                                    expression, that is <termref def="dt-striding"/>, and its
                                       <termref def="dt-sweep"/> is the <termref def="dt-sweep"/> of
                                    the <code>select</code> expression, that is <termref def="dt-consuming"/>.</p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-posture"/> and <termref def="dt-sweep"/> of
                                    the right hand operand <code>@value</code> are defined in
                                       <specref ref="streamability-of-axis-steps"/>. The <termref def="dt-context-posture"/> is the <termref def="dt-posture"/>
                                    of the left-hand operand <code>current-group()</code>, namely
                                       <termref def="dt-striding"/>; the table in Rule 5 applies,
                                    giving the result <termref def="dt-climbing"/> and <termref def="dt-motionless"/></p>
                              </item>
                              <item>
                                 <p>The <termref def="dt-posture"/> of the
                                       <code>RelativePathExpr</code> is the <termref def="dt-posture"/> of the right hand operand, namely <termref def="dt-striding"/>. The <termref def="dt-sweep"/> of the
                                       <code>RelativePathExpr</code> is the wider of the <termref def="dt-sweep">sweeps</termref> of its operands, which is
                                       <termref def="dt-consuming"/></p>
                              </item>
                              <item>
                                 <p>The type of the expression <code>current-group()/@value</code>
                                    is determined using the rules in <specref ref="determining-static-type"/> as
                                    <code>attribute()</code>.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>So the <code>sum</code> function has a single operand with
                                 <var>U</var> = <termref def="dt-absorption"/>, <var>P</var> =
                                 <termref def="dt-striding"/>, <var>S</var> = <termref def="dt-consuming"/>,
                                 <var>T</var> = <code>attribute()</code>.</p>
                        </item>
                        <item>
                           <p>In the <termref def="dt-general-streamability-rules"/>, Rule
                              1(b)(iii)(A) gives the adjusted usage as <var>U'</var> = <termref def="dt-inspection"/>, and Rule 1(b)(iii)(B) gives the adjusted
                              sweep as <var>S'</var> = <var>S</var> = <termref def="dt-consuming"/>.
                              Rule 2(d) gives the posture and sweep of the call to <code>sum</code>
                              as <termref def="dt-grounded"/> and <termref def="dt-consuming"/>.
                           </p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>So the literal result element has two operands, one of which is <termref def="dt-grounded"/> and <termref def="dt-motionless"/>, the other
                           <termref def="dt-grounded"/> and <termref def="dt-consuming"/>. Rule 2(d)
                        of the <termref def="dt-general-streamability-rules"/> determines that the
                        literal result element is <termref def="dt-grounded"/> and <termref def="dt-consuming"/>.</p>
                  </item>
                  <item>
                     <p>So the content of the <elcode>xsl:source-document</elcode> instruction is <termref def="dt-grounded"/>, which means that the instruction is <termref def="dt-guaranteed-streamable"/>.</p>
                  </item>
               </olist>
            </example>
         </div2>





         <div2 id="streamability-guarantees">
            <head>Streamability Guarantees</head>

            <p>Certain constructs allow a stylesheet author to declare that a construct is
               streamable. Specifically:</p>

            <ulist>
               <item>
                  <p>Specifying <code>streamable="yes"</code> on <elcode>xsl:mode</elcode> declares
                     that all template rules in that mode (and all
                        template rules that specify <code>mode="#all"</code>) are
                     streamable;</p>
               </item>
               <item>
                  <p>Specifying <code>streamable="yes"</code> on 
                     <elcode>xsl:source-document</elcode> declares that its
                     contained sequence constructor is streamable;</p>
               </item>
               <item>
                  <p>Specifying <code>streamable="yes"</code> on <elcode>xsl:function</elcode>
                     declares that the <termref def="dt-stylesheet-function"/> in question is
                     streamable;</p>
               </item>
               <item>
                  <p>Specifying <code>streamable="yes"</code> on <elcode>xsl:attribute-set</elcode>
                     declares that the attribute set in question is streamable;</p>
               </item>
               <item>
                  <p>Specifying <code>streamable="yes"</code> 
                     (explicitly or implicitly) on <elcode>xsl:merge-source</elcode> declares
                     that the merging process is streamable with respect to that particular input.</p>
               </item>
               <item>
                  <p>Specifying <code>streamable="yes"</code> on <elcode>xsl:accumulator</elcode>
                     declares that the accumulator can be evaluated on a streamed document.</p>
               </item>
               
            </ulist>

            <p><termdef id="dt-declared-streamable" term="declared-streamable">The above constructs (template rules belonging to a
                  mode declared with <code>streamable="yes"</code>; and <elcode>xsl:source-document</elcode>,
                     <elcode>xsl:attribute-set</elcode>, <elcode>xsl:function</elcode>,
               <elcode>xsl:merge-source</elcode>, and <elcode>xsl:accumulator</elcode>  elements specifying
                     <code>streamable="yes"</code>) are said to be
                  <term>declared-streamable</term>.</termdef></p>

            <p>In each case the construct in question is said to be
                  <term>guaranteed-streamable</term> if it satisfies two conditions:</p>

            <olist>
               <item>
                  <p>The construct is <termref def="dt-declared-streamable"/>.</p>
               </item>
               <item>
                  <p>Streamability analysis following the rules defined in this specification
                     determines that streamed processing is possible (the detailed conditions vary
                     from one construct to another).</p>
               </item>
            </olist>

            <p><termdef id="dt-guaranteed-streamable" term="guaranteed-streamable">A
                     <term>guaranteed-streamable</term> construct is a <termref def="dt-construct">construct</termref> that is declared to be streamable and that follows the
                  particular rules for that construct to make streaming possible, as defined by the
                  analysis in this specification.</termdef></p>


            <p>For a streaming processor, that is, a processor that claims conformance with the
                  <termref def="dt-streaming-feature"/>:</p>

            <olist>
               <item>
                  <p>If a construct is <termref def="dt-guaranteed-streamable"/> and
                  the input is provided in streamable form, then the input <rfc2119>must</rfc2119> be processed using streaming.</p>
                  <note><p>The requirement to process the input using streaming
                  does not apply if the processor is able to determine that this would convey no benefit:
                  for example, if the input is supplied as a tree in memory. However, this does not remove
                  the requirement to verify that the relevant stylesheet constructs are <termref def="dt-guaranteed-streamable"/>.</p></note>
               </item>
               <item>
                  <p>If a construct is declared as streamable but is not <termref def="dt-guaranteed-streamable"/> (that is, if it fails to satisfy the
                     conditions for streamability defined in this specification), then the processor
                        <rfc2119>must</rfc2119> be prepared to do any one of the following at user
                     option:</p>
                  <olist>
                     <item>
                        <p>Signal a static error <errorref spec="XT" class="SE" code="3430"/></p>
                     </item>
                     <item>
                        <p>Process the stylesheet as if it were a non-streaming processor (see
                           below)</p>
                     </item>
                     <item>
                        <p>Process the stylesheet with streaming if it is able to do so, or signal a
                           static error <errorref spec="XT" class="SE" code="3430"/> if it is not
                           able to do so.</p>
                     </item>
                  </olist>
               </item>
            </olist>

            <p><error spec="XT" type="static" class="SE" code="3430">
                  <p>It is a <termref def="dt-static-error"/> if a <termref def="dt-package">package</termref> contains a construct that is
                     declared to be streamable but which is not <termref def="dt-guaranteed-streamable"/>, unless the user has indicated that the
                     processor is to handle this situation by processing the stylesheet without
                     streaming or by making use of processor extensions to the streamability rules
                     where available.</p>
               </error></p>

            <p>For a non-streaming processor, the processor <rfc2119>must</rfc2119> evaluate the construct
               delivering the same results as if execution used streaming, but with no constraints
               on the evaluation strategy. (Processing <rfc2119>may</rfc2119>, of
               course, fail due to insufficient memory being available, or for other reasons.)
                  A non-streaming processor is <rfc2119>not
                     required</rfc2119> to assess whether constructs are <termref def="dt-guaranteed-streamable"/>, or to apply restrictions such as the rules
                  for where calls on the functions <function>accumulator-before</function> and
                     <function>accumulator-after</function> may appear. However, a non-streaming
                  processor <rfc2119>must</rfc2119> enforce the constraint implied by a
                     <code>use-accumulators</code> attribute restricting which accumulators can be
                  used with a particular document.</p>

            <note>
               <p>This specification does not attempt to legislate precisely what constitutes
                  evaluation “using streaming”. The most important test is that the amount of memory
                  needed should be for practical purposes independent of the size of the source
                  document, and in particular that the finite size of memory available should not
                  impose a limit on the size of source document that can be processed.</p>
               <p>The rules are designed to ensure that streaming processors can analyze
                  streamability using rules different from those in this specification, provided
                  that all constructs that are <termref def="dt-guaranteed-streamable"/> according
                  to this specification are actually streamable by the implementation. Furthermore,
                  non-streaming processors are not required to analyze streamability at all.</p>
               
            </note>


         </div2>

         

      </div1>



      <div1 id="add-func">
         <head>Additional Functions</head>
         <p>This section describes XSLT-specific additions to the XPath function library. Some of these 
            additional functions also make use of
            information specified by <termref def="dt-declaration">declarations</termref> in the
            stylesheet; this section also describes these declarations.</p>

         <div2 id="func-document">
            <head><?function fn:document?></head>
         </div2>


         <div2 id="key">
            <head>Keys</head>
            <p>Keys provide a way to work with documents that contain an implicit cross-reference
               structure. They make it easier to locate the nodes within a document that have a
               given value for a given attribute or child element, and they provide a hint to the
               implementation that certain access paths in the document need to be efficient.</p>
            <div3 id="xsl-key">
               <head>The <elcode>xsl:key</elcode> Declaration</head>
               <?element xsl:key?>
               <p>The <elcode>xsl:key</elcode>
                  <termref def="dt-declaration">declaration</termref> is used to declare <termref def="dt-key">keys</termref>. The <code>name</code> attribute specifies the name
                  of the key. The value of the <code>name</code> attribute is an <termref def="dt-eqname">EQName</termref>, which is expanded as
                  described in <specref ref="qname"/>. The <code>match</code> attribute is a <nt def="Pattern40">Pattern</nt>; an <elcode>xsl:key</elcode> element applies to
                  all nodes that match the pattern specified in the <code>match</code>
                  attribute.</p>
               <p>
                  <termdef id="dt-key" term="key">A <term>key</term> is defined as a set of
                        <elcode>xsl:key</elcode> declarations in the same
                           <termref def="dt-package">package</termref> that share the same
                     name.</termdef>
               </p>
               <p>The key name is scoped to the containing <termref def="dt-package">package</termref>, and is available for use in calls to the
                     <function>key</function> function within that package.</p>
               <p>The value of the key may be specified either using the <code>use</code> attribute
                  or by means of the contained <termref def="dt-sequence-constructor">sequence
                     constructor</termref>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1205">
                     <p>It is a <termref def="dt-static-error">static error</termref> if an
                           <elcode>xsl:key</elcode> declaration has a <code>use</code> attribute and
                        has non-empty content, or if it has empty content and no <code>use</code>
                        attribute.</p>
                  </error>
               </p>
               <p>If the <code>use</code> attribute is present, its value is an <termref def="dt-expression">expression</termref> specifying the values of the key. The
                  expression will be evaluated with a <termref def="dt-singleton-focus">singleton focus</termref> based on the node that
                     matches the pattern. The result of evaluating the expression is
                     <termref def="dt-atomization">atomized</termref>. </p>
               <p>Similarly, if a <termref def="dt-sequence-constructor">sequence
                     constructor</termref> is present, it is used to determine the values of the
                  key. The sequence constructor will be evaluated with the node that matches the
                  pattern as the context node. The result of evaluating the sequence constructor is
                     <termref def="dt-atomization">atomized</termref>.</p>
               <p>
                  <termdef id="dt-key-specifier" term="key specifier">The expression in the
                        <code>use</code> attribute and the <termref def="dt-sequence-constructor">sequence constructor</termref> within an <elcode>xsl:key</elcode>
                     declaration are referred to collectively as the <term>key specifier</term>. The
                     key specifier determines the values that may be used to find a node using this
                        <termref def="dt-key">key</termref>.</termdef>
               </p>
               <p>When evaluation of the <termref def="dt-key-specifier">key
                     specifier</termref> results in a sequence (after atomization) containing more
                  than one atomic value, the effect depends on the value of the
                     <code>composite</code> attribute:</p>
               <ulist>
                  <item>
                     <p>When the attribute is absent or has the value <code>no</code>, each atomic
                        value in the sequence acts as an individual key. For example, if
                           <code>match="book" use="author" composite="no"</code> is specified, then
                        a <code>book</code> element may be located using the value of any
                           <code>author</code> element.</p>
                  </item>
                  <item>
                     <p>When the attribute is present and has the value <code>yes</code>, the
                        sequence of atomic values is treated as a composite key that must be matched
                        in its entirety. For example, if <code>match="book" use="author"
                           composite="yes"</code> is specified, then a <code>book</code> element may
                        be located using the value of all its <code>author</code> elements, supplied
                        in the correct order.</p>
                  </item>
               </ulist>

               <p>If there are several <elcode>xsl:key</elcode> declarations in
                  the same package with the same key name, then
                  they must all have the same effective value for their <code>composite</code>
                  attribute. The effective value is the actual value of the attribute if present, or
                  <code>"no"</code> if the attribute is absent.</p>
               <note>
                  <p>There is no requirement that all the values of a key should have the same
                     type.</p>
               </note>
               <p>The presence of an <elcode>xsl:key</elcode> declaration makes it easy to find a
                  node that matches the <code>match</code> pattern if  the values of the <termref def="dt-key-specifier">key
                     specifier</termref> (when applied to that node) are known. It also provides a
                  hint to the implementation that access to the nodes by means of these values needs
                  to be efficient (many implementations are likely to construct an index or hash
                  table to achieve this). </p>
               <note>
                  <p>An <elcode>xsl:key</elcode> declaration is not bound to a specific source
                     document. The source document to which it applies is determined only when the
                        <function>key</function> function is used to locate nodes using the key.
                     Keys can be used to locate nodes within any source document (including
                     temporary trees), but each use of the <function>key</function> function
                     searches one document only.</p>
                  <p>Keys can only be used to search within a tree 
                     that is rooted at a document node.</p>
               </note>
               <p>The optional <code>collation</code> attribute is used only when deciding whether
                  two strings are equal for the purposes of key matching. Specifically, two key
                  values <code>$a</code> and <code>$b</code> are considered equal if the result of
                  the function call <code>deep-equal($a, $b,
                        $collation)</code> is true. The effective collation for an
                     <elcode>xsl:key</elcode> declaration is the collation specified in its
                     <code>collation</code> attribute if present, resolved against the base URI of
                  the <elcode>xsl:key</elcode> element, or the <termref def="dt-default-collation">default collation</termref> that is in scope for the <elcode>xsl:key</elcode>
                  declaration otherwise; the effective collation must be the same for all the
                     <elcode>xsl:key</elcode> declarations making up a <termref def="dt-key">key</termref>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1210">
                     <p>It is a <termref def="dt-static-error">static error</termref> if the
                           <elcode>xsl:key</elcode> declaration has a <code>collation</code>
                        attribute whose value (after resolving against the base URI) is not a URI
                        recognized by the implementation as referring to a collation.</p>
                  </error>
               </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1220">
                     <p>It is a <termref def="dt-static-error">static error</termref> if there are
                        several <elcode>xsl:key</elcode> declarations in the same <termref def="dt-package">package</termref> with the
                        same key name and different effective collations. Two collations are the
                        same if their URIs are equal under the rules for comparing
                           <code>xs:anyURI</code> values, or if the implementation can determine
                        that they are different URIs referring to the same collation.</p>
                  </error>
               </p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1222">
                     <p>It is a <termref def="dt-static-error">static error</termref> if there are
                        several <elcode>xsl:key</elcode> declarations in a <termref def="dt-package">package</termref> with the same key name and
                        different effective values for the <code>composite</code> attribute.</p>
                  </error>
               </p>
               <p>It is possible to have:</p>
               <ulist>
                  <item>
                     <p>multiple <elcode>xsl:key</elcode> declarations with the same name;</p>
                  </item>
                  <item>
                     <p>a node that matches the <code>match</code> patterns of several different
                           <elcode>xsl:key</elcode> declarations, whether these have the same key
                        name or different key names;</p>
                  </item>
                  <item>
                     <p>a node that returns more than one value from its <termref def="dt-key-specifier">key specifier</termref>
                        (which can be treated either as separate
                           individual key values, or as a single composite key value);</p>
                  </item>
                  <item>
                     <p>a key value that identifies more than one node (the key values for different
                        nodes do not need to be unique).</p>
                  </item>
               </ulist>
               <p>An <elcode>xsl:key</elcode> declaration with higher <termref def="dt-import-precedence">import precedence</termref> does not override
                  another of lower import precedence; all the <elcode>xsl:key</elcode> declarations
                  in the stylesheet are effective regardless of their import precedence.</p>
            </div3>
            <div3 id="func-key">
               <head><?function fn:key?></head>

            </div3>
         </div2>
         <div2 id="keys-and-streaming">
            <head>Keys and Streaming</head>
            <p>Keys are not applicable to streamed documents.</p>
            <p>This is ensured by the rules for the streamability of the <function>key</function> function 
               (see <specref ref="classifying-built-in-functions"/>). These rules make the <termref def="dt-operand-usage"/> of the
               third argument <termref def="dt-navigation"/>, which has the consequence that when the <function>key</function> function
            is applied to a streamed input document, the call is <termref def="dt-roaming"/> and <termref def="dt-free-ranging"/>, which effectively makes
            the containing construct non-streamable.</p>
         </div2>


         <div2 id="misc-func">
            <head>Miscellaneous Additional Functions</head>
            <div3 id="func-current">
               <head><?function fn:current?></head>
            </div3>
            <div3 id="func-unparsed-entity-uri">
               <head><?function fn:unparsed-entity-uri?></head>
            </div3>
            <div3 id="func-unparsed-entity-public-id">
               <head><?function fn:unparsed-entity-public-id?></head>
            </div3>

            <div3 id="func-system-property">
               <head><?function fn:system-property?></head>
            </div3>
            <div3 id="func-available-system-properties">
               <head><?function fn:available-system-properties?></head>
            </div3>

         </div2>

      </div1>



      <div1 id="map">
         <head>Maps</head>
         
         <p diff="chg" at="A">Maps are defined in the XDM Data Model.</p>
         <div2 id="map-type" diff="del" at="A">
            <head>The Type of a Map</head>


            <p>The syntax of <xnt ref="prod-xpath40-ItemType" spec="XP40">ItemType</xnt> as defined
               in XPath is extended as follows:</p>
            <scrap headstyle="show" id="MapType-scrap">
               <head>MapType</head>
               <prodgroup>
                  <prod num="69" id="NT-ItemType-2">
                     <lhs>ItemType</lhs>
                     <rhs>KindTest | ("item" "(" ")") | FunctionTest | AtomicOrUnionType |
                        ParenthesizedItemType<br/> | MapType</rhs>
                  </prod>
                  <prod num="201" id="NT-MapType">
                     <lhs>MapType</lhs>
                     <rhs>'map' '(' ( '*' | (<xnt ref="doc-xpath30-AtomicOrUnionType" spec="XP40">AtomicOrUnionType</xnt> ',' <xnt ref="prod-xpath40-SequenceType" spec="XP40">SequenceType</xnt>) ')'</rhs>
                  </prod>
               </prodgroup>
            </scrap>

            <p>The following rules express the matching rules for a map item type
               and a map, and extend the set of rules given in <xspecref spec="XP40" ref="id-matching-item"/>:</p>

            <ulist>
               <item>
                  <p>The <code>ItemType</code>
                     <code>map(K, V)</code> matches an item <var>M</var> if (a) <var>M</var> is a
                        map, and (b) every entry in <var>M</var> has
                     a key that matches <var>K</var> and an associated value that matches
                        <var>V</var>. For example, <code>map(xs:integer, element(employee))</code>
                     matches a map if all the keys in the map are integers, and all the associated
                     values are <code>employee</code> elements. Note that a map (like a sequence)
                     carries no intrinsic type information separate from the types of its entries,
                     and the type of existing entries in a map does not constrain the type of new
                     entries that can be added to the map.</p>
                  <note>
                     <p>In consequence, <code>map(K, V)</code> matches an empty
                        map, whatever the types <var>K</var> and <var>V</var> might be.</p>
                  </note>
               </item>
               <item>
                  <p>The <code>ItemType</code>
                     <code>map(*)</code> matches any map regardless of its contents. It is
                     equivalent to <code>map(xs:anyAtomicType, item()*)</code>.</p>
               </item>
            </ulist>

            <p>A map also acts as a function. This means that maps match certain
               function item types. Specifically, the following rule extends the list of rules in
                  <xspecref spec="XP40" ref="id-function-test"/>:</p>

            <ulist>
               <item>
                  <p><code>function(*)</code> matches any map.</p>
               </item>
               <item>
                  <p><code>function(xs:anyAtomicType) as item()*</code> matches any map.</p>
               </item>
            </ulist>

            <p>Because of the rules for subtyping of function types according to
               their signature, it follows that the item type <code>function(A) as item()*</code>,
               where A is an atomic type, also matches any map, regardless of the type of the keys
               actually found in the map. For example, a map whose keys are all strings can be
               supplied where the required type is <code>function(xs:integer) as item()*</code>; a
               call on the map that treats it as a function with an integer argument will always
               succeed, and will always return an empty sequence.</p>

            <p>The function signature of the map, treated as a function, is always
                  <code>function(xs:anyAtomicType) as item()*</code>, regardless of the actual types
               of the keys and values in the map. This means that a function item type with a more
               specific return type, such as <code>function(xs:anyAtomicType) as xs:integer</code>,
               does not match a map in the sense required to satisfy the <code>instance of</code>
               operator. However, the rules for function coercion mean that any map can be supplied
               as a value in a context where such a type is the required type, and a type error will
               only occur if an actual call on the map (treated as a function) returns a value that
               is not an instance of the required return type.</p>

            <note>
               <p>So, given a map <code>$M</code> whose keys are integers and whose results are
                  strings, such as <code>map{0:"no", 1:"yes"}</code>, the following relations hold,
                  among others:</p>
               <ulist>
                  <item>
                     <p><code>$M instance of map(*)</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of map(xs:integer, xs:string)</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of map(xs:decimal, xs:anyAtomicType)</code></p>
                  </item>
                  <item>
                     <p><code>not($M instance of map(xs:int, xs:string))</code></p>
                  </item>
                  <item>
                     <p><code>not($M instance of map(xs:integer, xs:token))</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of function(*)</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of function(xs:anyAtomicType) as item()*</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of function(xs:integer) as item()*</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of function(xs:int) as item()*</code></p>
                  </item>
                  <item>
                     <p><code>$M instance of function(xs:string) as item()*</code></p>
                  </item>
                  <item>
                     <p><code>not($M instance of function(xs:integer) as xs:string)</code></p>
                  </item>
               </ulist>
               <p>The last case might seem surprising; however, function coercion ensures that
                     <code>$M</code> can be used successfully anywhere that the required type is
                     <code>function(xs:integer) as xs:string</code>.</p>
            </note>

            <p>The rules for judging whether one item type is a subtype of
               another, given in <xspecref spec="XP40" ref="id-itemtype-subtype"/>, are extended
               with some additional rules. The judgement <code>subtype-itemtype(Ai, Bi)</code> is
               true if:</p>

            <ulist>
               <item>
                  <p><code>Ai</code> is <code>map(K, V)</code> and <code>Bi</code> is
                        <code>map(*)</code>, for any <code>K</code> and <code>V</code>.</p>
               </item>
               <item>
                  <p><code>Ai</code> is <code>map(Ka, Va)</code> and <code>Bi</code> is
                        <code>map(Kb, Vb)</code>, where <code>subtype-itemtype(Ka, Kb)</code> and
                        <code>subtype(Va, Vb)</code>.</p>
               </item>
               <item>
                  <p><code>Ai</code> is <code>map(*)</code> (or, because of the transitivity rules,
                     any other map type) and <code>Bi</code> is <code>function(*)</code>.</p>
               </item>
               <item>
                  <p><code>Ai</code> is <code>map(*)</code>, (or, because of the transitivity rules,
                     any other map type) and <code>Bi</code> is <code>function(xs:anyAtomicType) as
                        item()*</code>.</p>
               </item>
            </ulist>



         </div2>
         
         <div2 id="map-instructions">
            <head>Map Instructions</head>
            <p>Two instructions are added to XSLT to facilitate the construction of maps.</p>

            <?element xsl:map?>


            <p>The instruction <elcode>xsl:map</elcode> constructs and returns a new map.</p>

            

            <p>The contained sequence constructor <rfc2119>must</rfc2119> evaluate to a sequence of
               maps: call this <code>$maps</code>.</p>

            <p><phrase diff="chg" at="A">In the absense of duplicate keys,</phrase> the result of the instruction  
               is then given by the XPath 3.1 expression:</p>
            <eg role="non-xml" xml:space="preserve">map:merge($maps)</eg>

            <note>
               <p>Informally: <phrase diff="chg" at="A">in the absence of duplicate keys</phrase> the resulting map contains
                  the union of the map entries from the supplied sequence of maps.</p>
            </note>
            
            <p>The handling of duplicate keys is described in <specref ref="duplicate-keys"/> below.</p>

  


            <p>There is no requirement that the supplied input maps should have the same or
               compatible types. The type of a map (for example <code>map(xs:integer,
                  xs:string)</code>) is descriptive of the entries it currently contains, but is not
               a constraint on how the map may be combined with other maps.</p>

            <p><error spec="XT" class="TE" code="3375" type="type">
                  <p>A type error occurs if the result of evaluating the sequence constructor
                        <error.extra>within an <elcode>xsl:map</elcode> instruction</error.extra> is
                     not an instance of the required type <code>map(*)*</code>.</p>
               </error></p>



            <note>
               <p>In practice, the effect of this rule is that the sequence
                  constructor contained in the <elcode>xsl:map</elcode> instruction is severely
                  constrained: it doesn’t make sense, for example, for it to contain
                  instructions such as <elcode>xsl:element</elcode> that create new nodes. As with
                  other type errors, processors are free to signal the error statically if they are
                  able to determine that the sequence constructor would always fail when
                  evaluated.</p>
            </note>

            <?element xsl:map-entry?>

            <p>The instruction <elcode>xsl:map-entry</elcode> constructs and returns a singleton
               map: that is, a map which  contains one
               key and one value. Such a map is primarily used as a building block when constructing
               maps using the <elcode>xsl:map</elcode> instruction.</p>

            <p>The <code>select</code> attribute and the contained sequence constructor are mutually
               exclusive: if a <code>select</code> attribute is present, then the content
                  <rfc2119>must</rfc2119> be empty except optionally for
                  <elcode>xsl:fallback</elcode> instructions.</p>

            <p>
               <error spec="XT" type="static" class="SE" code="3280">
                  <p>It is a <termref def="dt-static-error">static error</termref> if the
                        <code>select</code> attribute of the <elcode>xsl:map-entry</elcode> element
                     is present unless the element has no children other than
                        <elcode>xsl:fallback</elcode> elements.</p>
               </error>
            </p>

            

            <p>The key of the entry in the new map is the value obtained by evaluating the
               expression in the <code>key</code> attribute, converted to the required type
                  <code>xs:anyAtomicType</code> by applying the <termref def="dt-coercion-rules"/>. If the supplied key (after conversion) is of
               type <code>xs:untypedAtomic</code>, it is cast to <code>xs:string</code>.</p>

            <p>The associated value is the value obtained by evaluating the expression in the
                  <code>select</code> attribute, or the contained sequence constructor, with no
               conversion. If there is no <code>select</code> attribute and the sequence constructor
               is empty, the associated value is the empty sequence.</p>

            

            <example>
               <head>Using XSLT instructions to create a fixed map</head>
               <p>The following example binds a variable to a map whose content is statically
                  known:</p>
               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:variable name="week" as="map(xs:string, xs:string)"&gt;
  &lt;xsl:map&gt;
    &lt;xsl:map-entry key="'Mo'" select="'Monday'"/&gt;
    &lt;xsl:map-entry key="'Tu'" select="'Tuesday'"/&gt;
    &lt;xsl:map-entry key="'We'" select="'Wednesday'"/&gt;
    &lt;xsl:map-entry key="'Th'" select="'Thursday'"/&gt;
    &lt;xsl:map-entry key="'Fr'" select="'Friday'"/&gt;
    &lt;xsl:map-entry key="'Sa'" select="'Saturday'"/&gt;
    &lt;xsl:map-entry key="'Su'" select="'Sunday'"/&gt;
  &lt;/xsl:map&gt;
&lt;/xsl:variable&gt;  
</eg>
            </example>
            <example>
               <head>Using XSLT instructions to create a computed map</head>
               <p>The following example binds a variable to a map acting as an index into a source
                  document:</p>
               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:variable name="index" as="map(xs:string, element(employee))"&gt;
  &lt;xsl:map&gt;
    &lt;xsl:for-each select="//employee"&gt;
      &lt;xsl:map-entry key="@empNr" select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:map&gt;
&lt;/xsl:variable&gt;  
</eg>
            </example>
            
            <div3 id="duplicate-keys" diff="add" at="A">
               <head>Handling of duplicate keys</head>
               
               <p>This section describes what happens when two or more maps returned by the sequence constructor
               within an <elcode>xsl:map</elcode> instruction contain duplicate keys: that is, when one of these
               maps contains an entry with key <var>K</var>, and another contains an entry with key <var>L</var>,
               and <code>op:same-key(K, L)</code> is true.</p>
               
               <p><error spec="XT" class="DE" code="3365" type="dynamic">
                  <p>In the absence of the <code>on-duplicates</code> attribute, 
                     a <termref def="dt-dynamic-error">dynamic error</termref> occurs if the set of
                     keys in the maps resulting from evaluating the sequence constructor
                     <error.extra>within an <elcode>xsl:map</elcode> instruction</error.extra>
                     contains duplicates.</p>
               </error></p>
               
               <p>The result of evaluating the <code>on-duplicates</code> attribute, if present, <rfc2119>must</rfc2119>
               be a function with arity 2. When the <elcode>xsl:map</elcode> instruction encounters two
               map entries having the same key, the two values associated with this key are passed as
               arguments to this function, and the function returns the value that should be associated
               with this key in the final map.</p>
               
               <p>The order of the arguments passed to the function reflects the order of the maps in which
               the duplicate entries appear: if map <var>M</var> and map <var>N</var> contain values <var>V/M</var>
               and <var>V/N</var> for the same key, and <var>M</var> precedes <var>N</var> in the sequence
                  of maps returned by the sequence constructor, then the callback function is called with arguments
                  <var>V/M</var> and <var>V/N</var> in that order.
               </p>
               
               <p>If more than two maps contain values for the same key, then the callback function is invoked repeatedly.
                  Let <var>F</var> be the callback function.
               Then if (for example) four maps supply the values <var>A</var>, <var>B</var>, <var>C</var>, and <var>D</var>
               for a given key <var>K</var>, in that order, the evaluation is as follows:</p>
               <olist>
                  <item><p><code>F(A, B)</code> is called; let its return value be <var>X</var>.</p></item>
                  <item><p><code>F(X, C)</code> is called; let its return value be <var>Y</var>.</p></item>
                  <item><p><code>F(Y, D)</code> is called; let its return value be <var>Z</var>.</p></item>
                  <item><p>The value that is associated with key <var>K</var> in the final map
                  will be <var>Z</var>.</p></item>
               </olist>
               
               <p>Thus, if the values are all singleton items (which is not necessarily the case), and if the sequence
               of values is <var>S</var>, then the final result is <code>fold-left(tail(S), head(S), F)</code>.</p>
               
               <p>For example, the following table shows some useful callback functions that might be supplied,
                  and explains their effect:</p>
               
               <table>
                  <thead>
                     <tr>
                        <th>Function</th>
                        <th>Effect</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td><code>function($a, $b){$a}</code></td>
                        <td>The first of the duplicate values is used.</td>
                     </tr>
                     <tr>
                        <td><code>function($a, $b){$b}</code></td>
                        <td>The last of the duplicate values is used.</td>
                     </tr>
                     <tr>
                        <td><code>function($a, $b){$a, $b}</code></td>
                        <td>The sequence-concatenation of the duplicate values is used.</td>
                     </tr>
                     <tr>
                        <td><code>function($a, $b){max(($a, $b))}</code></td>
                        <td>The highest of the duplicate values is used.</td>
                     </tr>
                     <tr>
                        <td><code>function($a, $b){min(($a, $b))}</code></td>
                        <td>The lowest of the duplicate values is used.</td>
                     </tr>
                     <tr>
                        <td><code>function($a, $b){string-join(($a, $b), ', ')}</code></td>
                        <td>The comma-separated string concatenation of the duplicate values is used.</td>
                     </tr>
                     <tr>
                        <td><code>function($a, $b){error()}</code></td>
                        <td>Duplicates are rejected as an error (this is the default in the absence of a
                           callback function).</td>
                     </tr>
                  </tbody>
               </table>
               
               <example id="map-with-duplicates-into-array">
                  <head>Combining Duplicates into an Array</head>
                  <p>This example takes as input an XML document such as:</p>
                  <eg><![CDATA[<data>
   <event id="A23" value="12"/>
   <event id="A24" value="5"/>
   <event id="A25" value="9"/>
   <event id="A23" value="2"/>
 </data>]]></eg>
                  <p>and constructs a map whose JSON representation is:</p>
                  <eg><![CDATA[{"A23": [12, 2], "A24": [5], "A23": [9]}]]></eg>
                  <p>The logic is:</p>
                  <eg><![CDATA[<xsl:template match="data">
   <xsl:map on-duplicates="function($a, $b){array:join(($a, $b))}">
     <xsl:for-each select="event">
        <xsl:map-entry key="@id" select="[xs:integer(@value)]"/>
     </xsl:for-each>
   </xsl:map>]]></eg>
               </example>
               
               
            </div3>
         </div2>

         <div2 id="map-constructors" diff="del" at="A">
            <head>Map Constructors</head>
            <p>A Map Constructor is a new kind of expression added to the syntax of XPath.</p>
            <note>
               <p>Map Constructors are defined in XPath 3.1. They are available in XSLT 3.0 whether
                  or not XPath 3.1 is supported. The specification given here is intended to be
                  identical to the specification in XPath 3.1.</p>
            </note>
            <p>The syntax of <xnt spec="XP40" ref="doc-xpath30-PrimaryExpr">PrimaryExpr</xnt> is
               extended to permit <code>MapConstructor</code> as an additional alternative.</p>

            <scrap headstyle="show" id="MapConstructor-scrap">
               <head>MapConstructor</head>
               <prodgroup>
                  <prod num="52" id="NT-PrimaryExpr">
                     <lhs>PrimaryExpr</lhs>
                     <rhs>Literal | VarRef | ParenthesizedExpr | ContextItemExpr | FunctionCall |
                        FunctionItemExpr<br/> | MapConstructor</rhs>
                  </prod>

                  <prod num="202" id="NT-MapConstructor">
                     <lhs>MapConstructor</lhs>
                     <rhs>"map" "{" (MapConstructorEntry ("," MapConstructorEntry )*)? "}" </rhs>
                  </prod>
                  <prod num="203" id="NT-MapConstructorEntry">
                     <lhs>MapConstructorEntry</lhs>
                     <rhs>MapKeyExpr ":" MapValueExpr </rhs>
                  </prod>
                  <prod num="204" id="NT-MapKeyExpr">
                     <lhs>MapKeyExpr</lhs>
                     <rhs><xnt ref="doc-xpath30-ExprSingle" spec="XP40">ExprSingle</xnt></rhs>
                  </prod>
                  <prod num="205" id="NT-MapValueExpr">
                     <lhs>MapValueExpr</lhs>
                     <rhs><xnt ref="doc-xpath30-ExprSingle" spec="XP40">ExprSingle</xnt></rhs>
                  </prod>
               </prodgroup>
            </scrap>



            <note>
               <p>In some circumstances, it is necessary to include whitespace
                  before or after the colon to ensure that this grammar is correctly parsed; this
                  arises for example when the <code>KeyExpr</code> ends with a name and the
                     <code>ValueExpr</code> starts with a name. </p>
            </note>

            <p>The value of the expression is a map whose entries correspond to the key-value pairs
               obtained by evaluating the successive <code>KeyExpr</code> and <code>ValueExpr</code>
               expressions.</p>
            <p>Each <code>KeyExpr</code> expression is evaluated and atomized; a type error <xerrorref spec="XP40" class="TY" code="0004"/> occurs if the result is not a single atomic value. If the key is of
               type <code>xs:untypedAtomic</code> it is converted to <code>xs:string</code>. The
               associated value is the result of evaluating the corresponding
                  <code>ValueExpr</code>. If two or more entries have the <term>same key</term> then 
               a dynamic error occurs <errorref spec="XT" class="DE" code="3365"/>.</p>
            <p>For example, the following expression constructs a map with seven entries:</p>
            <eg role="non-xml" xml:space="preserve">
map {
  "Su" : "Sunday",
  "Mo" : "Monday",
  "Tu" : "Tuesday",
  "We" : "Wednesday",
  "Th" : "Thursday",
  "Fr" : "Friday",
  "Sa" : "Saturday"
}</eg>
            <note>
               <p>Unlike the <function>map:merge</function> function, the number of entries in a map
                  that is constructed using a map expression is known statically.</p>
            </note>

         </div2>
         
         <div2 id="maps-streaming">
            <head>Maps and Streaming</head>

            <p>Maps have many uses, but their introduction to XSLT 3.0 was strongly motivated by
               streaming use cases. In essence, when a source document is processed in streaming
               mode, data that is encountered in the course of processing may need to be retained in
               variables for subsequent use, because the nodes cannot be revisited. This creates a
               need for a flexible data structure to accommodate such temporary data, and maps were
               designed to fulfil this need.</p>
            
            <p>The entries in a map are not allowed to contain references to 
               <termref def="dt-streamed-node">streamed nodes</termref>. This is achieved by ensuring that for all constructs
            that supply content to be included in a map (for example the third argument of <function>map:put</function>, and
               the <code>select</code> attribute of <elcode>xsl:map-entry</elcode>),
            the relevant operand is defined to have operand usage <termref def="dt-navigation"/>. Because maps cannot
               contain references to streamed nodes, they are effectively <termref def="dt-grounded"/>, and can therefore
               be used freely in contexts (such as parameters to functions or templates) where only grounded operands
               are permitted.</p>

            <p>The <elcode>xsl:map</elcode> instruction, and the XPath <code>MapConstructor</code>
               construct, are exceptions to the general rule that during streaming, only one
               downward selection (one consuming subexpression) is permitted. They share this
               characteristic with <elcode>xsl:fork</elcode>. As with <elcode>xsl:fork</elcode>, a
               streaming processor is expected to be able to construct the map during a single pass
               of the streamed input document, which may require multiple expressions to be
               evaluated in parallel.</p>

            <p>In the case of the <elcode>xsl:map</elcode> instruction, this exemption applies only in the
               case where the instruction consists exclusively of <elcode>xsl:map-entry</elcode>
               (and <elcode>xsl:fallback</elcode>) children, and not in more complex cases where the
               map entries are constructed dynamically (for example using a control flow implemented
               using <elcode>xsl:choose</elcode>, <elcode>xsl:for-each</elcode>, or
                  <elcode>xsl:call-template</elcode>). Such cases may, of course, be streamable
               if they only have a single consuming subexpression.</p>

            <p>For example, the following XPath expression is streamable, despite making two
               downward selections:</p>

            <eg role="non-xml" xml:space="preserve">
let $m := map{'price':xs:decimal(price), 'discount':xs:decimal(discount)} 
return ($m?price - $m?discount)</eg>

            <p>Analysis:</p>
            <olist>
               <item>
                  <p>Because the <code>return</code> clause is motionless, the <termref def="dt-sweep"/> of the <code>let</code> expression is the sweep of the map
                     expression (the expression in curly brackets).</p>
               </item>
               <item>
                  <p>The sweep of a map expression is the maximum sweep of its key/value pairs.</p>
               </item>
               <item>
                  <p>For both key/value pairs, the key is <termref def="dt-motionless"/> and the
                     value is <termref def="dt-consuming"/>.</p>
               </item>
               <item>
                  <p>The expression carefully atomizes both values, because
                     retaining references to streamed nodes in a map is not permitted.</p>
               </item>
               <item>
                  <p>Therefore the map expression, and hence the expression as a whole, is <termref def="dt-grounded"/> and <termref def="dt-consuming"/>.</p>
               </item>
            </olist>

            <p>See also: <specref ref="streamability-of-map-constructors"/>, <specref ref="streamability-xsl-map"/>, <specref ref="streamability-xsl-map-entry"/></p>

         </div2>
         <div2 id="map-examples">
            <head>Examples using Maps</head>
            <p>This section gives some examples of where maps can be useful.</p>

            <example id="maps-with-iterate">
               <head>Using Maps with xsl:iterate</head>
               <p>This example uses maps in conjunction with the <elcode>xsl:iterate</elcode>
                  instruction to find the highest-earning employee in each department, in a single
                  streaming pass of an input document containing employee records.</p>
               <eg role="xslt-instruction" xml:space="preserve">
&lt;xsl:source-document streamable="yes" href="employees.xml"&gt;
  &lt;xsl:iterate select="*/employee"&gt;
    &lt;xsl:param name="highest-earners" 
               as="map(xs:string, element(employee))" 
               select="map{}"/&gt;
    &lt;xsl:on-completion&gt;
      &lt;xsl:for-each select="map:keys($highest-earners)"&gt;
        &lt;department name="{.}"&gt;
          &lt;xsl:copy-of select="$highest-earners(.)"/&gt;
        &lt;/department&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:on-completion&gt;           
    &lt;xsl:variable name="this" select="copy-of(.)" as="element(employee)"/&gt; 
    &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="highest-earners"
          select="let $existing := $highest-earners($this/department)
                  return if ($existing/salary gt $this/salary)
                         then $highest-earners
                         else map:put($highest-earners, $this/department, $this)"/&gt;
    &lt;/xsl:next-iteration&gt;
  &lt;/xsl:iterate&gt;
&lt;/xsl:source-document&gt;
</eg>
            </example>
            <example id="example-complex-numbers">
               <head>Using Maps to Implement Complex Numbers</head>
               <p>A complex number might be represented as a map with two entries, the keys being
                  the <code>xs:boolean</code> value <code>true</code> for the real part, and the
                     <code>xs:boolean</code> value <code>false</code> for the imaginary part. A
                  library for manipulation of complex numbers might include functions such as the
                  following:</p>
               <eg role="xslt-declaration xmlns:i='i'" xml:space="preserve">

&lt;xsl:variable name="REAL" static="yes" as="xs:int" select="0"/&gt; 
&lt;xsl:variable name="IMAG" static="yes" as="xs:int" select="1"/&gt; 
                     
&lt;xsl:function name="i:complex" as="map(xs:int, xs:double)"&gt;
  &lt;xsl:param name="real" as="xs:double"/&gt;
  &lt;xsl:param name="imaginary" as="xs:double"/&gt;
  &lt;xsl:sequence select="map{ $REAL : $real, $IMAG : $imaginary }"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:real" as="xs:double"&gt;
  &lt;xsl:param name="complex" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="$complex($REAL)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:imaginary" as="xs:double"&gt;
  &lt;xsl:param name="complex" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="$complex($IMAG)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:add" as="map(xs:int, xs:double)"&gt;
  &lt;xsl:param name="arg1" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:param name="arg2" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="i:complex(i:real($arg1)+i:real($arg2), 
                                  i:imaginary($arg1)+i:imaginary($arg2)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:multiply" as="map(xs:boolean, xs:double)"&gt;
  &lt;xsl:param name="arg1" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:param name="arg2" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:sequence select="i:complex(
      i:real($arg1)*i:real($arg2) - i:imaginary($arg1)*i:imaginary($arg2),
      i:real($arg1)*i:imaginary($arg2) + i:imaginary($arg1)*i:real($arg2))"/&gt;
&lt;/xsl:function&gt;
</eg>
            </example>
            <example id="map-as-index">
               <head>Using a Map as an Index</head>
               <p>Given a set of <code>book</code> elements, it is possible to construct an index in
                  the form of a map allowing the books to be retrieved by ISBN number.</p>
               <p>Assume the book elements have the form:</p>
               <eg role="xml" xml:space="preserve">
&lt;book&gt;
  &lt;isbn&gt;0470192747&lt;/isbn&gt;
  &lt;author&gt;Michael H. Kay&lt;/author&gt;
  &lt;publisher&gt;Wiley&lt;/publisher&gt;
  &lt;title&gt;XSLT 2.0 and XPath 2.0 Programmer's Reference&lt;/title&gt;
&lt;/book&gt;</eg>
               <p>An index may be constructed as follows: </p>
               <eg role="xslt-declaration xmlns:map='http://www.w3.org/2005/xpath-functions/map" xml:space="preserve">
&lt;xsl:variable name="isbn-index" as="map(xs:string, element(book))"
    select="map:merge(for $b in //book return map{$b/isbn : $b})"/&gt;</eg>
               <p>This index may then be used to retrieve the book for a given ISBN using either of
                  the expressions <code>map:get($isbn-index, "0470192747")</code> or
                     <code>$isbn-index("0470192747")</code>.</p>
               <p>In this simple form, this replicates the functionality available using
                     <elcode>xsl:key</elcode> and the <function>key</function> function. However, it
                  also provides capabilities not directly available using the
                     <function>key</function> function: for example, the index can include
                     <code>book</code> elements in multiple source documents. It also allows
                  processing of all the books using a construct such as <code>&lt;xsl:for-each
                     select="map:keys($isbn-index)"&gt;</code></p>
            </example>
            <example id="map-as-class">
               <head>A Map containing Named Functions</head>
               <p>As in JavaScript, a map whose keys are strings and whose associated values are
                  function items can be used in a similar way to a class in object-oriented
                  programming languages.</p>
               <p>Suppose an application needs to handle customer order information that may arrive
                  in three different formats, with different hierarchic arrangements:</p>
               <olist>

                  <item>
                     <p>Flat structure:</p>
                     <eg role="xml" xml:space="preserve">
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;
&lt;order customer="c123" product="p789"&gt;...&lt;/order&gt;</eg>
                  </item>
                  <item>
                     <p>Orders within customer elements:</p>
                     <eg role="xml" xml:space="preserve">
&lt;customer id="c123"&gt;
   &lt;order product="p789"&gt;...&lt;/order&gt;
&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;</eg>
                  </item>
                  <item>
                     <p>Orders within product elements:</p>
                     <eg role="xml" xml:space="preserve">
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;
  &lt;order customer="c123"&gt;...&lt;/order&gt;
&lt;/product&gt;</eg>
                  </item>
               </olist>

               <p>An application can isolate itself from these differences by defining a set of
                  functions to navigate the relationships between customers, orders, and products:
                     <code>orders-for-customer</code>, <code>orders-for-product</code>,
                     <code>customer-for-order</code>, <code>product-for-order</code>. These
                  functions can be implemented in different ways for the three different input
                  formats. For example, with the first format the implementation might be:</p>
               <eg role="xslt-declaration" xml:space="preserve">
&lt;xsl:variable name="flat-input-functions" as="map(xs:string, function(*))*"
  select="map{
            'orders-for-customer' : 
                 function($c as element(customer)) as element(order)* 
                    {$c/../order[@customer=$c/@id]},
            'orders-for-product' : 
                 function($p as element(product)) as element(order)* 
                    {$p/../order[@product=$p/@id]},
            'customer-for-order' : 
                 function($o as element(order)) as element(customer) 
                    {$o/../customer[@id=$o/@customer]},
            'product-for-order' : 
                 function($o as element(order)) as element(product) 
                    {$o/../product[@id=$o/@product]} }                    
         "/&gt;</eg>
               <p>Having established which input format is in use, the application can bind the
                  appropriate implementation of these functions to a variable such as
                     <code>$input-navigator</code>, and can then process the input using XPath
                  expressions such as the following, which selects all products for which there is
                  no order: <code>//product[empty($input-navigator("orders-for-product")(.))]</code>
               </p>

            </example>
         </div2>
      </div1>
      
      <div1 id="arrays" diff="add" at="A">
         <head>Arrays</head>
         
         <p>Arrays are defined in the XDM Data Model.</p>
         <div2 id="array-construction">
            <head>Array Construction</head>
            <p>The instruction <elcode>xsl:array</elcode> constructs and returns a new array.</p>
            <?element xsl:array?>
            <p>If the <code>composite</code> attribute is omitted or set to <code>no</code>, the resulting
            array has one singleton member for each item returned by the <code>select</code> attribute or
            sequence constructor. For example <code>&lt;xsl:array select="1 to 5"/></code> returns
            an array with five members: <code>[1, 2, 3, 4, 5]</code>.</p>
            <p>If the <code>composite</code> attribute is present with the value <code>yes</code>, then
               each item returned by the <code>select</code> attribute or
               sequence constructor must be an zero-arity function, and the sequences that result from
            the evaluation of these zero-arity functions become the members of the array. For example, 
               <code>&lt;xsl:array select="function(){1 to 3}, function(){8 to 10}" composite="yes"/></code>
            returns an array with two members: <code>[(1,2,3), (8,9,10)]</code>.</p>
            <p>The <code>select</code> attribute and the contained sequence constructor are mutually
            exclusive: if the <code>select</code> attribute is present, then the only permitted child
            element is <elcode>xsl:fallback</elcode>.</p>
            <p>For convenience and readability, the instruction <elcode>xsl:array-member</elcode>
            can be used to construct a zero-arity function suitable for use with <elcode>xsl:array</elcode>.</p>
            <?element xsl:array-member?>
            <p>For example:</p>
            <eg><![CDATA[
<xsl:array composite="yes">
  <xsl:for-each select="'jane', 'mary', 'pete', 'andy'">
     <xsl:array-member select="lower-case(.), upper-case(.)"/>
  </xsl:for-each>
</xsl:array>]]></eg>
            <p>The result of this instruction is the array <code>[('jane', "JANE"), ('mary', 'MARY'), '('pete', 'PETE'), ('andy', 'ANDY')]</code>:
            that is, an array with four members, each of which is a sequence of two items.</p>
            <p>Although the syntax is designed to be intuitive, the underlying mechanism is non-obvious. The effect of the
            <elcode>xsl:array-member</elcode> instruction is to return a zero-arity anonymous function which, on evaluation,
            delivers the result of its <code>select</code> attribute or contained sequence constructor. That is, the 
               <elcode>xsl:array-member</elcode> instruction in this example is actually equivalent to:</p>
            <eg><![CDATA[
 <xsl:sequence select="let $member := (lower-case(.), upper-case(.)) 
                       return function(){$member}"/>              
               ]]></eg>
            <p>Specifically, the <elcode>xsl:array-member</elcode> instruction evaluates its <code>select</code>
               expression or contained <termref def="dt-sequence-constructor"/> (which are mutually exclusive),
               to obtain a value <var>V</var>, and returns a zero-arity anonymous function
               with signature <code>function() as item()*</code>, which when invoked returns <var>V</var>.</p>
            
            <note><p>The reason for this rather obscure formulation is to prevent the flattening of nested sequences that would
               normally occur when instructions within a sequence constructor deliver sequences rather than individual items.
               Wrapping the individual sequences within anonymous functions prevents this flattening.</p></note>
            
            <p>More formally, the semantics of the <elcode>xsl:array</elcode> instruction are as follows:</p>
            
            <olist>
               <item>
                  <p>When there is no <code>composite</code> attribute, or when <code>composite="no"</code>:</p>
                  <olist>
                     <item><p>The <code>select</code> expression or contained sequence constructor
                     is evaluated, in the same way as for the <elcode>xsl:sequence</elcode> instruction,
                     to yield a value <var>V</var>.</p></item>
                     <item><p>An array is constructed, containing one member for each item in <var>V</var>,
                     whose value is that item.</p></item>
                     <item><p>This array is returned as the result of the <code>xsl:array</code> instruction.</p></item>
                  </olist>
               </item>
               <item>
                  <p>When <code>composite="yes" is specified</code>:</p>
                  <olist>
                     <item><p>The <code>select</code> expression or contained sequence constructor
                        is evaluated, in the same way as for the <elcode>xsl:sequence</elcode> instruction,
                        to yield a value <var>V</var>.</p></item>
                     <item><p>A type error is raised if <var>V</var> is not an instance of 
                        <code>(function() as item()*)*</code>. [TODO: add error code]</p></item>
                     <item><p>An array is constructed, containing one member for each item <code>$v</code>
                        in <var>V</var>, the value of the array member being <code>$v()</code>.</p></item>
                     <item><p>This array is returned as the result of the <code>xsl:array</code> instruction.</p></item>
                  </olist>
               </item>
            </olist>
            
            <p>The semantics of the <elcode>xsl:array-member</elcode> instruction are as follows:</p>
            
            <olist>
               <item><p>The <code>select</code> expression or contained sequence constructor
                  is evaluated, in the same way as for the <elcode>xsl:sequence</elcode> instruction,
                  to yield a value <var>V</var>.</p></item>
               <item><p>The <elcode>xsl:array-member</elcode> instruction returns a zero-arity anonymous
                  function with signature <code>function() as item()*</code>, whose evaluation
                  returns <var>V</var>.</p></item>
            </olist>
            
            <p>The <code>select</code> attribute and the contained sequence constructor of <elcode>xsl:array</elcode>
               are mutually exclusive [Error condition TBA].</p>
 
            <p>The <code>select</code> attribute and the contained sequence constructor of <elcode>xsl:array-member</elcode>
            are mutually exclusive [Error condition TBA].</p>
            
            
            <note><p>XPath offers two constructs for creating arrays, the so called square and curly array constructors.
            The square array constructor (for example <code>[1, 3, 5, (7 to 10)]</code> can only construct an array where
            the number of members is statically known (in this case there are four members). The curly array constructor
            (for example <code>array{1, 3, 5, (7 to 10)}</code> can only construct an array whose members are singleton items 
            (in this case there are seven members, each being a single integer).</p>
               <p>The combination of 
            <elcode>xsl:array</elcode> and <elcode>xsl:array-member</elcode>, by contrast, can deliver an array
            whose size is determined dynamically and whose members can be arbitrary XDM values.</p>
               <p>An equivalent construct using array functions would be <code>['jane', 'mary', 'pete', 'andy'] =>
               array:for-each(function($s){lower-case($s), upper-case($s)})</code>.</p></note>
            
         </div2>
         
         <!--<div2 id="array-iteration">
            <head>Iterating over the Members of an Array</head>
            <p>The instruction <elcode>for-each-member</elcode> is available to iterate over the members of an
            array.</p>
            <?element xsl:for-each-member?>
         
            <p>The <code>select</code> attribute is <rfc2119>required</rfc2119>, and its value <rfc2119>must</rfc2119>
            be a single array item. The contained sequence constructor is evaluated once for each member in the array.</p>
            <p>If the <code>composite</code> attribute is absent or has the value <code>no</code>, then each member of the array
               must be a single item. In this case the sequence constructor is evaluated (once for each member) with 
               the context item being the single item comprising the array member, the context position being the
               position of the member within the array, and the context size being the number of members in the array.</p>
            
            <p>It is a <termref def="dt-type-error"/> [TBA] if the <elcode>xsl:for-each-member</elcode> instruction is evaluated
            for an array that has a member which is not a singleton item.</p>
            
            <p>If the <code>composite</code> attribute is present with the value <code>yes</code>, then the sequence
               constructor is evaluated (once for each member) with the context item being an anonymous zero-arity 
               function that wraps the actual
               value of the array member. The context position is again the
               position of the member within the array, and the context size is the number of members in the array.</p>
            
            <example>
               <head>Processing an array of singleton items</head>
               <p>Given an array <code>$in</code> containing <code>[1, 5, 6, 10]</code> the following example might output the sequence
               <code>('i', 'v', 'vi', 'x')</code>:</p>
               <eg><![CDATA[
<xsl:for-each-member select="$in">
  <xsl:sequence select="format-integer(., 'i')"/>
</xsl:for-each-member>  
]]></eg>
               <p>To obtain the output as an array, <code>('i', 'v', 'vi', 'x')</code>, the iteration can be combined with
               array construction:</p>
               <eg><![CDATA[
<xsl:array>
  <xsl:for-each-member select="$in">
    <xsl:array-item select="format-integer(., 'i')"/>
  </xsl:for-each-member>
</xsl:array>  
]]></eg>
               
            </example>
            <example>
               <head>Processing an array of sequence-valued items</head>
               <p>Given an array <code>$in</code> containing <code>[(1,2), (), (3,4,5)]</code>, the following example
               outputs the sum of the integers in each member, that is, <code>(3, 0, 12)</code>.</p>
               <eg><![CDATA[
<xsl:for-each-member select="$in" composite="yes">
  <xsl:sequence select="sum(.())"/>
</xsl:for-each-member>  
]]></eg>
               <p>The sequence constructor is evaluated three times, with the context item being set successively
               to a function that delivers <code>(1,2)</code>, a function that delivers the empty sequence 
                  <code>()</code>, and finally a function that delivers the sequence <code>(3,4,5)</code>.</p>
               <p>Because <elcode>xsl:for-each-member</elcode> represents array members in the same way that
               <elcode>xsl:array</elcode> expects them, array iteration and array construction can conveniently
               be combined. The following example copies selected items of an array into a new array:</p>
               <eg><![CDATA[
<xsl:variable name="items-to-copy" select="1, 5, 8"/>
<xsl:array>
  <xsl:for-each-member select="$in" composite="yes">
    <xsl:if test="position() = $items-to-copy" then="."/>
  </xsl:for-each-member>
</xsl:array>  
]]></eg>
            </example>
            
 
         </div2>-->
         
      </div1>

      <div1 id="json">
         <head>Processing JSON Data</head>
         <p>JSON is a popular format for exchange of structured data on the web: it is specified in
               <bibref ref="rfc7159"/>. This section
            describes facilities allowing JSON data to be processed using XSLT.</p>

         <note>
            <p>RFC7159 is taken as the definitive specification of JSON for the purposes of this
               document. The RFC explains its relationship with other JSON specifications such as
                  <bibref ref="ECMA-404"/>.</p>
         </note>

         <note>
            <p>XPath 3.1 incorporates the functions defined in this
               section. It also provides additional JSON capability, in the form of functions
                  <code>parse-json</code>, <code>json-doc</code>, and extensions to the
                  <xfunction>serialize</xfunction> function. These facilities are incorporated in XSLT
               3.0 only if the XPath 3.1 feature is supported. They depend on support for
               arrays.</p>
         </note>

         <div2 id="json-to-xml-mapping" diff="del" at="A">
            <head>XML Representation of JSON</head>


            <p>This specification defines a mapping from JSON data to XML (specifically, to XDM
               instances). A function <function>json-to-xml</function> is provided to take a JSON
               string as input and convert it to the XML representation. Two stylesheet modules are
               provided to perform the reverse transformation: one produces JSON in compact linear
               form, the other in indented form suitable for display, editing, or printing.</p>

            <p>The XML representation is designed to be capable of representing any valid JSON text
               other than one that uses characters which are not valid in XML. The transformation is
               lossless: that is, distinct JSON texts convert to distinct XML representations. When
               converting JSON to XML, options are provided to reject unsupported characters, to
               replace them with a substitute character, or to leave them in backslash-escaped
               form.</p>

            <p>The following example demonstrates the correspondence of a JSON text and the
               corresponding XML representation. </p>

            <example>
               <head>A JSON Text and its XML Representation</head>
               <p>Consider the following JSON text:</p>
               <eg role="json" xml:space="preserve">
{
  "desc"    : "Distances between several cities, in kilometers.",
  "updated" : "2014-02-04T18:50:45",
  "uptodate": true,
  "author"  : null,
  "cities"  : {
    "Brussels": [
      {"to": "London",    "distance": 322},
      {"to": "Paris",     "distance": 265},
      {"to": "Amsterdam", "distance": 173}
    ],
    "London": [
      {"to": "Brussels",  "distance": 322},
      {"to": "Paris",     "distance": 344},
      {"to": "Amsterdam", "distance": 358}
    ],
    "Paris": [
      {"to": "Brussels",  "distance": 265},
      {"to": "London",    "distance": 344},
      {"to": "Amsterdam", "distance": 431}
    ],
    "Amsterdam": [
      {"to": "Brussels",  "distance": 173},
      {"to": "London",    "distance": 358},
      {"to": "Paris",     "distance": 431}
    ]
  }
}
               </eg>
               <p>The XML representation of this text is as follows. Whitespace is included in the
                  XML representation for purposes of illustration, and is ignored by the stylesheets
                  that convert XML to JSON, but it will not be present in the output of the
                     <function>json-to-xml</function> function.</p>
               <eg role="xml" xml:space="preserve">
  &lt;map xmlns="http://www.w3.org/2005/xpath-functions"&gt;
    &lt;string key='desc'&gt;Distances between several cities, in kilometers.&lt;/string&gt;
    &lt;string key='updated'&gt;2014-02-04T18:50:45&lt;/string&gt;
    &lt;boolean key="uptodate"&gt;true&lt;/boolean&gt;
    &lt;null key="author"/&gt;
    &lt;map key='cities'&gt;
      &lt;array key="Brussels"&gt;
        &lt;map&gt;
            &lt;string key="to"&gt;London&lt;/string&gt;
            &lt;number key="distance"&gt;322&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Paris&lt;/string&gt;
            &lt;number key="distance"&gt;265&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Amsterdam&lt;/string&gt;
            &lt;number key="distance"&gt;173&lt;/number&gt;
        &lt;/map&gt; 
      &lt;/array&gt;
      &lt;array key="London"&gt;
        &lt;map&gt;
            &lt;string key="to"&gt;Brussels&lt;/string&gt;
            &lt;number key="distance"&gt;322&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Paris&lt;/string&gt;
            &lt;number key="distance"&gt;344&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Amsterdam&lt;/string&gt;
            &lt;number key="distance"&gt;358&lt;/number&gt;
        &lt;/map&gt; 
      &lt;/array&gt;
      &lt;array key="Paris"&gt;
        &lt;map&gt;
            &lt;string key="to"&gt;Brussels&lt;/string&gt;
            &lt;number key="distance"&gt;265&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;London&lt;/string&gt;
            &lt;number key="distance"&gt;344&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Amsterdam&lt;/string&gt;
            &lt;number key="distance"&gt;431&lt;/number&gt;
        &lt;/map&gt;  
      &lt;/array&gt;
      &lt;array key="Amsterdam"&gt;
        &lt;map&gt;
            &lt;string key="to"&gt;Brussels&lt;/string&gt;
            &lt;number key="distance"&gt;173&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;London&lt;/string&gt;
            &lt;number key="distance"&gt;358&lt;/number&gt;
        &lt;/map&gt; 
        &lt;map&gt;
            &lt;string key="to"&gt;Paris&lt;/string&gt;
            &lt;number key="distance"&gt;431&lt;/number&gt;
        &lt;/map&gt;
      &lt;/array&gt;
    &lt;/map&gt;  
  &lt;/map&gt;</eg>
            </example>

            <p>An XSD 1.0 schema for the XML representation is provided in <specref ref="schema-for-json"/>. It is not necessary to import this schema (using
                  <elcode>xsl:import-schema</elcode>) unless the stylesheet makes explicit reference
               to the components defined in the schema. If the stylesheet does import a schema for
               the namespace <code>http://www.w3.org/2005/xpath-functions</code>, then:</p>

            <olist>
               <item>
                  <p>The processor (if it is schema-aware) <rfc2119>must</rfc2119> recognize an
                        <elcode>xsl:import-schema</elcode> declaration for this namespace, whether
                     or not the <code>schema-location</code> is supplied.</p>
               </item>
               <item>
                  <p>If a <code>schema-location</code> is provided, then the schema document at that
                     location <rfc2119>must</rfc2119> be equivalent to the schema document at
                        <specref ref="schema-for-json"/>; the effect if it is not is <termref def="dt-implementation-dependent"/></p>
               </item>
            </olist>

            <p>The rules governing the mapping from JSON to XML are as follows. In these rules, the
               phrase “an element named N” is to be interpreted as meaning “an element node whose
               local name is N and whose namespace URI is
               <code>http://www.w3.org/2005/xpath-functions</code>”.</p>

            <olist>
               <item>
                  <p>The JSON value <code>null</code> is represented by an element named
                        <code>null</code>, with empty content.</p>
               </item>
               <item>
                  <p>The JSON values <code>true</code> and <code>false</code> are represented by an
                     element named <code>boolean</code>, with content conforming to the type
                        <code>xs:boolean</code>.</p>
               </item>
               <item>
                  <p>A JSON number is represented by an element named <code>number</code>, with
                     content conforming to the type <code>xs:double</code>, with the additional
                     restriction that the value must not be positive or negative infinity, nor
                        <code>NaN</code>.</p>
               </item>
               <item>
                  <p>A JSON string is represented by an element named <code>string</code>, with
                     content conforming to the type <code>xs:string</code>.</p>
               </item>
               <item>
                  <p>A JSON array is represented by an element named <code>array</code>. The content
                     is a sequence of child elements representing the members of the array in order,
                     each such element being the representation of the array member obtained by
                     applying these rules recursively.</p>
               </item>
               <item>
                  <p>A JSON object is represented by an element named <code>map</code>. The content
                     is a sequence of child elements each of which represents one of the name/value
                     pairs in the object. The representation of the name/value pair <var>N:V</var>
                     is obtained by taking the element that represents the value <var>V</var> (by
                     applying these rules recursively) and adding an attribute with name
                        <code>key</code> (in no namespace), whose value is <var>N</var> as an
                     instance of <code>xs:string</code>.</p>
               </item>

            </olist>

            <p>The attribute <code>escaped="true"</code> may be specified on a <code>string</code>
               element to indicate that the string value contains backslash-escaped characters that
               are to be interpreted according to the JSON rules. The attribute
                  <code>escaped-key="true"</code> may be specified on any element with a
                  <code>key</code> attribute to indicate that the key contains backslash-escaped
               characters that are to be interpreted according to the JSON rules. Both attributes
               have the default value <code>false</code>.</p>

            <p>The JSON grammar for <code>number</code> is a subset of
               the lexical space of the XSD type <code>xs:double</code>. The mapping from JSON
                  <code>number</code> values to <code>xs:double</code> values is defined by the
               XPath rules for casting from <code>xs:string</code> to <code>xs:double</code>. Note
               that these rules will never generate an error for out-of-range values; instead very
               large or very small values will be converted to <code>+INF</code> or
                  <code>-INF</code>. Since JSON does not impose limits on the range or precision of
               numbers, the conversion is not guaranteed to be lossless.</p>

            <p>Although the order of entries in a JSON object is generally considered to have no
               significance, the function <code>json-to-xml</code> and the stylesheets that perform
               the reverse transformation both retain order.</p>

            <p>The XDM representation of a JSON value may either be untyped (all elements annotated
               as <code>xs:untyped</code>, attributes as <code>xs:untypedAtomic</code>), or it may
               be typed. If it is typed, then it <rfc2119>must</rfc2119> have the type annotations
               obtained by validating the untyped representation against the schema given in
                  <specref ref="schema-for-json"/>. If it is untyped, then it
                  <rfc2119>must</rfc2119> be an XDM instance such that validation against this
               schema would succeed.</p>
         </div2>
         
         <div2 id="options"  diff="del" at="A">
            <head>Option Parameter Conventions</head>
            <p><emph>This section describes conventions which in principle can be adopted by the specification
            of any function. At the time of writing, the function which invoke these conventions are 
               <function>xml-to-json</function> and <function>json-to-xml</function>.</emph></p>
            <p>As a matter of convention, a number of functions defined in this document take
               a parameter whose value is a map, defining options controlling the detail of how
               the function is evaluated. Maps are a new data type introduced in XSLT 3.0.</p>
            <p>For example, the function <code>fn:xml-to-json</code> has an options parameter
               allowing specification of whether the output is to be indented. A call might be written:</p>
            <eg role="xpath" xml:space="preserve">fn:xml-to-json($input, map{'indent':true()})</eg>
            <p><termdef id="option-parameter-conventions" term="option parameter conventions">Functions
               that take an options parameter adopt common conventions on how the
               options are used. These are referred to as the <term>option parameter conventions</term>. These
               rules apply only to functions that explicitly refer to them.</termdef></p>
            <p>Where a function adopts the <termref def="option-parameter-conventions"/>, the following rules
               apply:</p>
            <olist>
               <item><p>The value of the relevant argument must be a map. The entries in the map are
                  referred to as options: the key of the entry is called the option name, and the
                  associated value is the option value. Option names defined in this specification
                  are always strings (single <code>xs:string</code> values). Option values may
                  be of any type.</p></item>
               <item><p>The type of the options parameter in the function signature is always
                  given as <code>map(*)</code>.</p></item>
               <item><p>Although option names are described above as strings, the actual key may be
                  any value that compares equal to the required string (using the <code>eq</code> operator
                  with Unicode codepoint collation). For example, instances of <code>xs:untypedAtomic</code>
                  or <code>xs:anyURI</code> are equally acceptable.</p>
                  <note><p>This means that the implementation of the function can check for the
                     presence and value of particular options using the functions <code>map:contains</code>
                     and/or <code>map:get</code>.</p></note></item>
               <item><p>It is not an error if the options map contains options with names other than those
                  described in this specification. Implementations <rfc2119>may</rfc2119> attach an 
                  <termref def="dt-implementation-defined">implementation-defined</termref> meaning to such entries,
                  and <rfc2119>may</rfc2119> define errors that arise if such entries are present with invalid values.
                  Implementations <rfc2119>must</rfc2119> ignore such entries unless they have a specific 
                  <termref def="dt-implementation-defined">implementation-defined</termref> meaning.
                  Implementations that define additional options in this way <rfc2119>should</rfc2119>
                  use values of type <code>xs:QName</code> as the option names, using an appropriate namespace.</p></item>
               <item><p>All entries in the options map are optional, and supplying an empty map has the same
                  effect as omitting the relevant argument in the function call, assuming this is permitted.</p></item>
               <item><p>For each named option, the function
                  specification defines a required type for the option value. The value that is actually
                  supplied in the map is converted to this required type using the 
                  <termref def="dt-coercion-rules"/>. 
                  A type error <xerrorref spec="XP40" class="TY" code="0004" type="type"/> occurs
                     if conversion of the supplied value to the required type is not possible, or if this conversion
                     delivers a coerced function whose invocation fails with a type error.
                  A dynamic error occurs if the supplied value 
                  after conversion is not one of the permitted values for the option in question: the error codes
                  for this error are defined in the specification of each function.</p>
                  <note><p>It is the responsibility of each function implementation to invoke this conversion; it
                     does not happen automatically as a consequence of the function calling rules.</p></note></item>
               <item><p>In cases where an option is list-valued, by convention the value may be supplied
                  either as a sequence or as an array. Accepting a sequence is convenient if the
                  value is generated programmatically using an XPath expression; while accepting an array 
                  allows the options to be held in an external file in JSON format, to be read using
                  a call on the <code>fn:json-doc</code> function.</p></item>
               <item><p>In cases where the value of an option is itself a map, the specification
                  of the particular function must indicate whether or not these rules apply recursively 
                  to the contents of that map.</p></item>
            </olist>
         </div2>


         <div2 id="xml-to-json-transformation">
            <head>Transforming XML to JSON</head>
            <p>Given an XML structure that does not use the XML representation of JSON defined in
                  <specref ref="json-to-xml-mapping"/>, there are two practical ways to convert it
               to JSON: either perform a transformation to the XML representation of JSON and then
               call the <function>xml-to-json</function> function; or transform it to JSON directly
               by using custom template rules.</p>

            <p>To assist with the second approach, a stylesheet is provided in <specref ref="xml-to-json-stylesheet"/>. This stylesheet includes a function
                  <code>j:xml-to-json</code> which, apart from being in a different namespace, is
               functionally very similar to the <function>xml-to-json</function> function described in
               the previous section. (It differs in doing less validation
                  of the input than the function specification requires, and in the details of how
                  special characters are escaped.)
               The implementation of the function is exposed, using template
               rules to perform a recursive descent of the supplied input, and the behavior of the
               function can therefore be customized (typically by importing the stylesheet and
               adding additional template rules) to handle arbitrary XML input.</p>

            <p>The stylesheet is provided under the W3C software license for the convenience of
               users. There is no requirement for any conformant XSLT processor to make this
               stylesheet available. Processors <rfc2119>may</rfc2119> implement the
               <function>xml-to-json</function> function by invoking this stylesheet (adapted
               to achieve full conformance), but there is no requirement to do so.</p>
         </div2>
      </div1>

     

      <div1 id="diagnostics">
         <head>Diagnostics</head>

         <div2 id="message">
            <head>Messages</head>
            <?element xsl:message?>
            <p>The <elcode>xsl:message</elcode> instruction sends a message in an <termref def="dt-implementation-defined">implementation-defined</termref> way. The
                  <elcode>xsl:message</elcode> instruction causes the creation of a new document,
               which is typically serialized and output to an <termref def="dt-implementation-defined">implementation-defined</termref> destination. The
               result of the <elcode>xsl:message</elcode> instruction is an empty sequence.</p>
            <p>The content of the message may be specified by using either or both of the optional
                  <code>select</code> attribute and the <termref def="dt-sequence-constructor">sequence constructor</termref> that forms the content of the
                  <elcode>xsl:message</elcode> instruction.</p>
            <p>If the <elcode>xsl:message</elcode> instruction contains a <termref def="dt-sequence-constructor">sequence constructor</termref>, then the sequence
               obtained by evaluating this sequence constructor is used to construct the content of
               the new document node, as described in <specref ref="constructing-complex-content"/>.</p>
            <p>If the <elcode>xsl:message</elcode> instruction has a <code>select</code> attribute,
               then the value of the attribute <rfc2119>must</rfc2119> be an XPath expression. The
               effect of the <elcode>xsl:message</elcode> instruction is then the same as if a
               single <elcode>xsl:copy-of</elcode> instruction with this <code>select</code>
               attribute were added to the start of the <termref def="dt-sequence-constructor">sequence constructor</termref>.</p>
            <p>If the <elcode>xsl:message</elcode> instruction has no content and no
                  <code>select</code> attribute, then an empty message is produced.</p>
            <imp-def-feature id="idf-err-messageformat">The destination and formatting of messages
               written using the <elcode>xsl:message</elcode> instruction are <termref def="dt-implementation-defined"/>.</imp-def-feature>
            <p>The tree produced by the <elcode>xsl:message</elcode> instruction is not technically
               a <termref def="dt-final-result-tree">final result tree</termref>. The tree has no
               URI and processors are not <rfc2119>required</rfc2119> to make the tree accessible to
               applications.</p>
            <note>
               <p>In many cases, the XML document produced using <elcode>xsl:message</elcode> will
                  consist of a document node owning a single text node. However, it may contain a
                  more complex structure.</p>
            </note>
            <note>
               <p>An implementation might implement <elcode>xsl:message</elcode> by popping up an
                  alert box or by writing to a log file. Because the order of execution of
                  instructions is implementation-defined, the order in which such messages appear is
                  not predictable.</p>
            </note>
            <p>The <code>terminate</code> attribute is interpreted as an <termref def="dt-attribute-value-template">attribute value template</termref>.</p>
            <p>If the <termref def="dt-effective-value">effective value</termref> of the
                  <code>terminate</code> attribute is <code>yes</code>, then the <termref def="dt-processor">processor</termref>
               <rfc2119>must</rfc2119>
               signal a <termref def="dt-dynamic-error"> dynamic error</termref> after
               sending the message. This error may be caught in the same
                  way as any other dynamic error using <elcode>xsl:catch</elcode>. The
               default value is <code>no</code>. Note that because the order of evaluation of
               instructions is <termref def="dt-implementation-dependent">implementation-dependent</termref>, this gives no guarantee that any particular
               instruction will or will not be evaluated before processing terminates.</p>
            <p>The optional <code>error-code</code> attribute 
               (also interpreted as an <termref def="dt-attribute-value-template"/>)
               may be used to indicate the error code
               associated with the message. This may be used irrespective of the value of
                  <code>terminate</code>. The 
               <termref def="dt-effective-value">effective value</termref> of the 
               error code attribute is expected to be an <termref def="dt-eqname">EQName</termref>. If no error code is specified, or if
               the effective value is not a valid EQName, the error code will have local part
                  <code>XTMM9000</code> and namespace URI
                  <code>http://www.w3.org/2005/xqt-errors</code>. User-defined error codes
                  <rfc2119>should</rfc2119> be in a namespace other than
                  <code>http://www.w3.org/2005/xqt-errors</code>. When the value of
                  <code>terminate</code> is <code>yes</code>, the error code may be matched in an
                  <elcode>xsl:catch</elcode> element to catch the error and cause processing to
               continue normally.</p>
            <p>
               <error spec="XT" type="dynamic" class="MM" code="9000">
                  <p>When a transformation is terminated by use of <code>&lt;xsl:message
                        terminate="yes"/&gt;</code>, the effect is the same as when a <termref def="dt-dynamic-error">
                        dynamic error</termref> occurs during the transformation. The default error code is <code>XTMM9000</code>; this may be
                        overridden using the <code>error-code</code> attribute of the
                           <elcode>xsl:message</elcode> instruction.</p>
               </error>
            </p>
            <example>
               <head>Localizing Messages</head>
               <p>One convenient way to do localization is to put the localized information (message
                  text, etc.) in an XML document, which becomes an additional input file to the
                     <termref def="dt-stylesheet">stylesheet</termref>. For example, suppose
                  messages for a language <code>
                     <var>L</var>
                  </code> are stored in an XML file <code>resources/<var>L</var>.xml</code> in the
                  form:</p>
               <eg role="xml" xml:space="preserve">&lt;messages&gt;
  &lt;message name="problem"&gt;A problem was detected.&lt;/message&gt;
  &lt;message name="error"&gt;An error was detected.&lt;/message&gt;
&lt;/messages&gt;
</eg>
               <p>Then a stylesheet could use the following approach to localize messages:</p>
               <eg role="xslt-declarations" xml:space="preserve">&lt;xsl:param name="lang" select="'en'"/&gt;
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message select="string($messages/message[@name=$name])"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</eg>
            </example>
            <!--Text inserted by erratum E20 change 1" Amended because we no longer have recoverable errors-->
            <p>Any <termref def="dt-dynamic-error">dynamic error</termref> that occurs while
               evaluating the <code>select</code> expression or the contained <termref def="dt-sequence-constructor">sequence constructor</termref>, and any <termref def="dt-serialization-error">serialization error</termref> that occurs while
               processing the result, does not cause the transformation to
                  fail; at worst, it means that no message is output, or that the only message that
                  is output is one that relates to the error that occurred.</p>
            <note>
               <p>An example of such an error is the serialization error that occurs when processing
                  the instruction <code>&lt;xsl:message select="@code"/&gt;</code> (on the grounds
                  that free-standing attributes cannot be serialized). Making such errors
                  recoverable means that it is implementation-defined whether or not they are
                  signaled to the user and whether they cause termination of the transformation. If
                  the processor chooses to recover from the error, the content of any resulting
                  message is implementation-dependent.</p>
               <p>One possible recovery action is to include a description of the error in the
                  generated message text.</p>
            </note>
            <!--End of text inserted by erratum E20-->
         </div2>
         <div2 id="assertions">
            <head>Assertions</head>

            <p>The <elcode>xsl:assert</elcode> instruction is used to assert that the value of a
               particular expression is true; if the value of the expression is false, and
               assertions are enabled, then a dynamic error occurs.</p>

            <?element xsl:assert?>

            <p>By default, assertions are disabled.</p>

            <p>An implementation <rfc2119>must</rfc2119> provide an external mechanism to enable or
               disable assertion checking. This may work either statically or dynamically, and may
               be at the level of the stylesheet as a whole, or at the level of an individual
               package, or otherwise. The detail of such mechanisms is <termref def="dt-implementation-defined"/>.</p>

            <!--<olist>          
            <item><p>As with any other instruction, assertions may be disabled by use of the <code>use-when</code>
            attribute: see <specref ref="conditional-inclusion"/>.</p></item>
            <item></item>
       
            <item><p diff="del" at="M">The optional <code>enabled</code> attribute contains an expression which is evaluated
               to determine whether assertion checking is enabled. Checking is disabled if the attribute is present
               and the effective boolean value
               of the expression is false. This mechanism can be used, for example, to enable or disable a group of assertions
               by the setting of a <termref def="dt-stylesheet-parameter"/>.</p></item>
         </olist>-->

            <imp-def-feature id="idf-api-enablingassertions">The detail of any external mechanism
               allowing a processor to enable or disable checking of assertions is <termref def="dt-implementation-defined"/>.</imp-def-feature>

            <p>If assertion checking is enabled, the instruction is evaluated as follows:</p>

            <olist>
               <item>
                  <p>The expression in the <code>test</code> attribute is evaluated. If the
                     effective boolean value of the result is <code>true</code>, the assertion
                     succeeds, and no further action is taken. If the effective boolean value is
                     false, or if a dynamic error occurs during evaluation of the expression, then
                     the assertion fails.</p>
               </item>

               <item>
                  <p>If the assertion fails, then the effect of the instruction is governed by the
                     rules for evaluation of an <elcode>xsl:message</elcode> instruction with the
                     same <code>select</code> attribute, <code>error-code</code> attribute, and
                     contained <termref def="dt-sequence-constructor"/>, and with the value
                        <code>terminate="yes"</code>. However, the default error code if the
                        <code>error-code</code> attribute is omitted is <code>XTMM9001</code> rather
                     than <code>XTMM9000</code>.</p>

                  <note>
                     <p>To the extent that the behavior of <elcode>xsl:message</elcode> is <termref def="dt-implementation-defined"/>, this rule does not prevent an
                        implementation treating <elcode>xsl:assert</elcode> and
                           <elcode>xsl:message</elcode> differently.</p>
                  </note>

                  <note>
                     <p>If evaluation of the <code>test</code> expression
                        fails with a dynamic error, the effect is exactly the same as if the
                        evaluation returns <code>false</code>, including the fact that the
                        instruction fails with error code <code>XTMM9001</code>.</p>
                  </note>
               </item>

               <item>
                  <p>If an assertion fails, then the following sibling
                     instructions of the <elcode>xsl:assert</elcode> instruction are not
                     evaluated.</p>

                  <note>
                     <p>This means that <elcode>xsl:assert</elcode> can
                        be used (rather like <elcode>xsl:if</elcode> and
                        <elcode>xsl:choose</elcode>) to prevent subsequent instructions from
                        executing if a particular precondition is not true, which might be useful if
                        the subsequent instructions have side-effects (for example, by calling
                        extension functions) or if they can fail in uncatchable ways (for example,
                        non-terminating recursion). It is worth noting that there are limits to this
                        guarantee. It does not ensure, for example, that when an assertion within a
                        template fails, the following siblings of the
                           <elcode>xsl:call-template</elcode> instruction that invokes that template
                        will not be evaluated; nor does it ensure that if an assertion fails while
                        processing the first item of a sequence using <elcode>xsl:for-each</elcode>,
                        then subsequent items in the sequence will not be processed. </p>
                  </note>
               </item>
            </olist>

            <p>
               <error spec="XT" type="dynamic" class="MM" code="9001">
                  <p>When a transformation is terminated by use of <elcode>xsl:assert</elcode>, the
                     effect is the same as when a <termref def="dt-dynamic-error"> dynamic error</termref> occurs during the
                     transformation. The default error code is <code>XTMM9001</code>; this may be
                     overridden using the <code>error-code</code> attribute of the
                        <elcode>xsl:assert</elcode> instruction.</p>
               </error>
            </p>

            <p>As with any other dynamic error, an error caused by an assertion failing may be
               trapped using <elcode>xsl:try</elcode>: see <specref ref="try-catch"/>.</p>

            <p>The result of the <elcode>xsl:assert</elcode> instruction is an empty sequence.</p>

            <example>
               <head>Using Assertions with Static Parameters</head>
               <p>The following example shows a stylesheet function that checks that the value of
                  its supplied argument is in range. The check is performed only if the <termref def="dt-static-parameter"/>
                  <code>$DEBUG</code> is set to true.</p>
               <eg role="xslt-declarations" xml:space="preserve">
&lt;xsl:param name="DEBUG" as="xs:boolean" select="false()" 
           static="yes" required="no"/&gt;
&lt;xsl:function name="f:days-elapsed" as="xs:integer"&gt;
  &lt;xsl:param name="date" as="xs:date"/&gt;
  &lt;xsl:assert use-when="$DEBUG" test="$date lt current-date()"/&gt;
  &lt;xsl:sequence select="(current-date() - $since) 
                            div xs:dayTimeDuration('PT1D')"/&gt;
&lt;/xsl:function&gt;</eg>
            </example>

            <note>
               <p>Implementations should avoid optimizing <elcode>xsl:assert</elcode> instructions
                  away. As a guideline, if the result of a sequence constructor is required by the
                  transformation, the implementation should ensure that all
                     <elcode>xsl:assert</elcode> instructions in that sequence constructor are
                  evaluated. Conversely, if the result of a sequence constructor is not required by
                  the transformation, its <elcode>xsl:assert</elcode> instructions should not be
                  evaluated.</p>

               <p>This guidance is not intended to prevent optimizations such as lazy
                  evaluation, where evaluation of a sequence constructor may finish early, as soon
                  as enough information is available to evaluate the containing instruction.</p>
            </note>

            <p>An implementation <rfc2119>may</rfc2119> provide a user option allowing a processor
               to treat assertions as being true without explicit checking. This option
                  <rfc2119>must not</rfc2119> be enabled by default. If such an option is in force,
               the effect of any assertion not being true is <termref def="dt-implementation-dependent"/>.</p>

            <note>
               <p>For example, given the assertion <code>&lt;xsl:assert
                     test="count(//title)=1"/&gt;</code>, a processor might generate code for the
                  expression <code>&lt;xsl:value-of select="//title"/&gt;</code> that stops searching
                  for <code>title</code> elements after finding the first one. In the event that the
                  source document contains more than one <code>title</code>, execution of the
                  stylesheet may fail in arbitrary ways, or it may produce incorrect output.</p>
            </note>


         </div2>
      </div1>
      <div1 id="extension">
         <head>Extensibility and Fallback</head>
         <p>XSLT allows two kinds of extension, extension instructions and extension functions.</p>
         <p>
            <termdef id="dt-extension-instruction" term="extension instruction">An <term>extension
                  instruction</term> is an element within a <termref def="dt-sequence-constructor">sequence constructor</termref> that is in a namespace (not the <termref def="dt-xslt-namespace">XSLT namespace</termref>) designated as an extension
               namespace.</termdef>
         </p>
         <p>
            <termdef id="dt-extension-function" term="extension function">An <term>extension
               function</term> is a named function introduced to the static or dynamic context 
               by mechanisms outside the scope of this specification.</termdef></p>
         
    
         <p>This specification does not define any mechanism for creating or binding implementations
            of <termref def="dt-extension-instruction">extension instructions</termref> or <termref def="dt-extension-function">extension functions</termref>, and it is not
               <rfc2119>required</rfc2119> that implementations support any such mechanism. Such
            mechanisms, if they exist, are <termref def="dt-implementation-defined">implementation-defined</termref>. Therefore, an XSLT stylesheet that must be
            portable between XSLT implementations cannot rely on particular extensions being
            available. XSLT provides mechanisms that allow an XSLT stylesheet to determine whether
            the implementation makes particular extensions available, and to specify what happens if
            those extensions are not available. If an XSLT stylesheet is careful to make use of
            these mechanisms, it is possible for it to take advantage of extensions and still retain
            portability.</p>
         
         <p>
            <error spec="XT" type="static" class="SE" code="0085">
               <p>It is a <termref def="dt-static-error"/> to use a <termref def="dt-reserved-namespace"/>
                  in the name of any <termref def="dt-extension-function"/> or <termref def="dt-extension-instruction"/>,
                  other than a function or instruction defined in this specification or in a normatively 
                  referenced specification. It is a <termref def="dt-static-error"/> to use a prefix bound 
                  to a reserved namespace in the <code>[xsl:]extension-element-prefixes</code> attribute.
               </p>
            </error>
         </p>

         <div2 id="extension-functions">
            <head>Extension Functions</head>
            <p>The set of functions that can be called from a <xnt spec="XP40" ref="prod-xpath40-FunctionCall">FunctionCall</xnt> within an XPath <termref def="dt-expression">expression</termref> may include one or more <termref def="dt-extension-function">extension functions</termref>. The <termref def="dt-expanded-qname">expanded QName</termref> of an extension function always
               has a non-null namespace URI, which <rfc2119>must not</rfc2119> be the 
                  URI of a <termref def="dt-reserved-namespace"/>.</p>
            
            <note><p>The definition of the term <termref def="dt-extension-function"/> is written to exclude
            user-written <termref def="dt-stylesheet-function">stylesheet functions</termref>,
            constructor functions for built-in and user-defined types, functions in the <code>fn</code>, <code>math</code>,
               <code>map</code>, and <code>array</code> namespaces,
            anonymous XPath inline functions, maps and arrays,
            and partial function applications (including partial applications of extension functions). It also excludes
            functions obtained by invoking XPath-defined functions such as
               <xfunction spec="FO40">load-xquery-module</xfunction>.
            The definition allows extension functions to be discovered at evaluation time (typically using
            <xfunction>function-lookup</xfunction>) rather than necessarily being known statically.
            </p>
            <p>Technically, the definition of extension functions excludes anonymous functions
            obtained by calling or partially applying other extension functions. Since such functions are
            by their nature implementation-defined, they may however share some of the characteristics of
            extension functions.</p></note>
            
  
            <div3 id="func-function-available">
               <head><?function fn:function-available?></head>
            </div3>
            <div3 id="calling-extension-functions">
               <head>Calling Extension Functions</head>
               <p>If the function name used in a <xnt spec="XP40" ref="prod-xpath40-FunctionCall">FunctionCall</xnt> within an XPath <termref def="dt-expression">expression</termref> identifies an extension function, then to evaluate the
                     <xnt spec="XP40" ref="prod-xpath40-FunctionCall">FunctionCall</xnt>, the
                  processor will first evaluate each of the arguments in the <xnt spec="XP40" ref="prod-xpath40-FunctionCall">FunctionCall</xnt>. If the processor has
                  information about the datatypes expected by the extension function, then it
                     <rfc2119>may</rfc2119> perform any necessary type conversions between the XPath
                  datatypes and those defined by the implementation language. If multiple extension
                  functions are available with the same name, the processor <rfc2119>may</rfc2119>
                  decide which one to invoke based on the number of arguments, the types of the
                  arguments, or any other criteria. The result returned by the implementation is
                  returned as the result of the function call, again after any necessary conversions
                  between the datatypes of the implementation language and those of XPath. The
                  details of such type conversions are outside the scope of this specification.</p>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1420">
                     <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the arguments
                        supplied to a call on an extension function do not satisfy the rules defined
                        for that particular extension function, or if the extension function reports
                        an error, or if the result of the extension function cannot be converted to
                        an XPath value.</p>
                  </error>
               </p>
               <note>
                  <p>Implementations may also provide mechanisms allowing extension functions to
                     report recoverable dynamic errors, or to execute within an environment that
                     treats some or all of the errors listed above as recoverable.</p>
               </note>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1425">
                     <p>When the containing element is processed with
                              <termref def="dt-xslt-10-behavior">XSLT 1.0
                           behavior</termref>, it is a <termref def="dt-dynamic-error"> dynamic
                           error</termref> to evaluate an extension function call if no
                        implementation of the extension function is available.</p>
                  </error>
               </p>
               <note>
                  <p>When XSLT 1.0 behavior is not enabled, this
                     is a static error <xerrorref spec="XP40" class="ST" code="0017"/>.</p>
               </note>
               <note>
                  <p>There is no prohibition on calling extension functions that have side-effects
                     (for example, an extension function that writes data to a file). However, the
                     order of execution of XSLT instructions is not defined in this specification,
                     so the effects of such functions are unpredictable.</p>
               </note>
               <p>Implementations are not <rfc2119>required</rfc2119> to perform full validation of
                  values returned by extension functions. It is an error for an extension function
                  to return a string containing characters that are not permitted in XML, but the
                  consequences of this error are <termref def="dt-implementation-defined">implementation-defined</termref>. The implementation <rfc2119>may</rfc2119>
                  raise an error, <rfc2119>may</rfc2119> convert the string to a string containing
                  valid characters only, or <rfc2119>may</rfc2119> treat the invalid characters as
                  if they were permitted characters.</p>
               <imp-def-feature id="idf-ext-nonxmlstring">The effect of an extension function
                  returning a string containing characters that are not permitted in XML is
                  implementation-defined.</imp-def-feature>
               <note>
                  <p>The ability to execute extension functions represents a potential security
                     weakness, since untrusted stylesheets may invoke code that has privileged
                     access to resources on the machine where the <termref def="dt-processor">processor</termref> executes. Implementations may therefore provide
                     mechanisms that restrict the use of extension functions by untrusted
                     stylesheets.</p>
               </note>
               <p>All observations in this section regarding the errors that can occur when invoking
                  extension functions apply equally when invoking <termref def="dt-extension-instruction">extension instructions</termref>.</p>
            </div3>
            <div3 id="external-objects">
               <head>External Objects</head>
               <p>An implementation <rfc2119>may</rfc2119> allow an extension function to return an
                  object that does not have any natural representation in the XDM data model,
                  whether as an atomic value, a node, or a function
                     item. For example, an extension function <code>sql:connect</code>
                  might return an object that represents a connection to a relational database; the
                  resulting connection object might be passed as an argument to calls on other
                  extension functions such as <code>sql:insert</code> and
                  <code>sql:select</code>.</p>
               <p>The way in which such objects are represented in the type system is <termref def="dt-implementation-defined">implementation-defined</termref>. They might be
                  represented by a completely new datatype, or they might be mapped to existing
                  datatypes such as <code>integer</code>, <code>string</code>, or
                     <code>anyURI</code>.</p>
               <imp-def-feature id="idf-ext-externalobjects">The way in which external objects are
                  represented in the type system is implementation-defined.</imp-def-feature>
            </div3>
            <div3 id="func-type-available">
               <head><?function fn:type-available?></head>
            </div3>
         </div2>
         <div2 id="extension-instruction">
            <head>Extension Instructions</head>
            <p>
               <termdef id="dt-extension-namespace" term="extension namespace">The <termref def="dt-extension-instruction">extension instruction</termref> mechanism allows
                  namespaces to be designated as <term>extension namespaces</term>. When a namespace
                  is designated as an extension namespace and an element with a name from that
                  namespace occurs in a <termref def="dt-sequence-constructor">sequence
                     constructor</termref>, then the element is treated as an <termref def="dt-instruction">instruction</termref> rather than as a <termref def="dt-literal-result-element">literal result element</termref>.</termdef> The
               namespace determines the semantics of the instruction.</p>
            <note>
               <p>Since an element that is a child of an <elcode>xsl:stylesheet</elcode> element is
                  not occurring <emph>in a <termref def="dt-sequence-constructor">sequence
                        constructor</termref>
                  </emph>, <termref def="dt-data-element">user-defined data elements</termref> (see
                     <specref ref="user-defined-top-level"/>) are not extension elements as defined
                  here, and nothing in this section applies to them.</p>
            </note>
            <div3 id="designating-extension-namespace">
               <head>Designating an Extension Namespace</head>
               <p>A namespace is designated as an extension namespace by using an
                     <code>[xsl:]extension-element-prefixes</code> attribute on an element in the
                  stylesheet (see <specref ref="standard-attributes"/>). The attribute
                     <rfc2119>must</rfc2119> be in the XSLT namespace only if its parent element is
                     <emph>not</emph> in the XSLT namespace. The value of the attribute is a
                  whitespace-separated list of namespace prefixes. The namespace bound to each of
                  the prefixes is designated as an extension namespace.</p>
               <p>The default namespace (as declared by <code>xmlns</code>) may be designated as an
                  extension namespace by including <code>#default</code> in the list of namespace
                  prefixes.</p>
               <p>A <termref def="dt-reserved-namespace"/> 
                  cannot be designated as an extension namespace: see <errorref spec="XT" class="SE" code="0085"/>.</p>
               <p>
                  <error spec="XT" type="static" class="SE" code="1430">
                     <p>It is a <termref def="dt-static-error">static error</termref> if there is no
                        namespace bound to the prefix on the element bearing the
                           <code>[xsl:]extension-element-prefixes</code> attribute or, when
                           <code>#default</code> is specified, if there is no default namespace.</p>
                  </error>
               </p>
               <p>The designation of a namespace as an extension namespace is effective for the
                  element bearing the <code>[xsl:]extension-element-prefixes</code> attribute and
                  for all descendants of that element within the same stylesheet module.</p>
            </div3>
            <div3 id="func-element-available">
               <head><?function fn:element-available?></head>

            </div3>
            <div3 id="fallback">
               <head>Fallback</head>
               <?element xsl:fallback?>
               <p>The content of an <elcode>xsl:fallback</elcode> element is a <termref def="dt-sequence-constructor">sequence constructor</termref>, and when
                  performing fallback, the value returned by the <elcode>xsl:fallback</elcode>
                  element is the result of evaluating this sequence constructor.</p>
               <p>When not performing fallback, evaluating an <elcode>xsl:fallback</elcode> element
                  returns an empty sequence: the content of the <elcode>xsl:fallback</elcode>
                  element is not evaluated.</p>
               <p>There are two situations where a <termref def="dt-processor">processor</termref>
                  performs fallback: when an extension instruction that is not available is
                  evaluated, and when an instruction in the XSLT namespace, that is not defined in
                  XSLT 3.0, is evaluated within a region of the
                  stylesheet for which <termref def="dt-forwards-compatible-behavior"/> is
                  enabled.</p>
               <note>
                  <p>Fallback processing is not invoked in other situations, for example it is not
                     invoked when an XPath expression uses unrecognized syntax or contains a call to
                     an unknown function. To handle such situations dynamically, the stylesheet
                     should call functions such as <function>system-property</function> and
                        <function>function-available</function> to decide what capabilities are
                     available.</p>
               </note>
               <p>
                  <error spec="XT" type="dynamic" class="DE" code="1450">
                     <p>When a <termref def="dt-processor">processor</termref> performs fallback for
                        an <termref def="dt-extension-instruction">extension instruction</termref>
                        that is not recognized, if the instruction element has one or more
                           <elcode>xsl:fallback</elcode> children, then the content of each of the
                           <elcode>xsl:fallback</elcode> children <rfc2119>must</rfc2119> be
                        evaluated; it is a <termref def="dt-dynamic-error"> dynamic error</termref> if it has no
                           <elcode>xsl:fallback</elcode> children.</p>
                  </error>
               </p>
               <note>
                  <p>This is different from the situation with unrecognized <termref def="dt-xslt-element">XSLT elements</termref>. As explained in <specref ref="forwards"/>, an unrecognized XSLT element appearing within a <termref def="dt-sequence-constructor">sequence constructor</termref> is a static
                     error unless (a) <termref def="dt-forwards-compatible-behavior"/> is enabled,
                     and (b) the instruction has an <elcode>xsl:fallback</elcode> child.</p>
               </note>
            </div3>
         </div2>
      </div1>
      <div1 id="result-trees">
         <head>Transformation Results</head>
         <p>The output of a transformation includes a <termref def="dt-principal-result"/> and zero or more <termref def="dt-secondary-result">secondary results</termref>.</p>
         
         
         <p>The way in which these results are
             delivered to an application is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
         <imp-def-feature id="idf-api-results">The way in which the results of the transformation
            are delivered to an application is implementation-defined.</imp-def-feature>
         <p>Serialization of results
             is described further in <specref ref="serialization"/>
         </p>
         <div2 id="creating-result-trees">
            <head>Creating Secondary Results</head>
            <?element xsl:result-document?>
            <p>The <elcode>xsl:result-document</elcode> instruction is
               used to create a <termref def="dt-secondary-result"/>. The content of the
                  <elcode>xsl:result-document</elcode> element is a <termref def="dt-sequence-constructor">sequence constructor</termref>, 
               and the value of the
                  <termref def="dt-secondary-result"/> (known as the <termref def="dt-raw-result"/>)
               is the <termref def="dt-immediate-result"/> of this
               sequence constructor. </p>
            
            <p>As with the <termref def="dt-principal-result"/> of the
            transformation, a <termref def="dt-secondary-result"/> may be delivered to the calling
            application in three ways (see <specref ref="post-processing"/>):</p>
            
            <olist>
               <item><p>The <termref def="dt-raw-result"/> may be delivered <emph>as is</emph>.</p></item>
               <item><p>The <termref def="dt-raw-result"/> may be used to construct a <termref def="dt-final-result-tree"/>
               by invoking the process of <xtermref spec="SER30" ref="sequence-normalization"/>.</p></item>
               <item><p>The <termref def="dt-raw-result"/> may be serialized to a sequence of octets (which
               may then, optionally, be saved to a persistent storage location).</p></item>
            </olist>
            
            <p>The decision whether or not to serialize the raw result depends on the 
               <termref def="dt-processor">processor</termref> and on the way it is invoked. This
               is <termref def="dt-implementation-defined"/>, and it is not controlled by anything
               in the stylesheet.</p>
            
            <p>If the result is not serialized, then the decision whether to
               return the <termref def="dt-raw-result"/> or to construct a tree depends on the effective
               value of the <code>build-tree</code> attribute. If the effective value of
               the <code>build-tree</code> attribute is <code>yes</code>, then 
                  a <termref def="dt-final-result-tree"/> is created
               by invoking the process of <xtermref spec="SER30" ref="sequence-normalization"/>. <phrase diff="del" at="A">The default for the
                  <code>build-tree</code> attribute depends on the serialization method. For the
                  <code>xml</code>, <code>html</code>, <code>xhtml</code>, and <code>text</code>
               methods the default value is <code>yes</code>. For
                  the <code>json</code> and <code>adaptive</code> methods the default value is <code>no</code>.</phrase>
               <phrase diff="add" at="A">Conversely, if the result <emph>is</emph> serialized, then 
                  the decision whether or not to construct a tree depends on the choice of 
                  serialization method, and the <code>build-tree</code> attribute is then ignored. 
                  For example, with <code>method="xml"</code> a tree is always constructed, whereas 
                  with <code>method="json"</code> a tree is never constructed. [XSLT 3.0 Erratum E14, bug 30208].
               </phrase></p>

            
            <p>The <elcode>xsl:result-document</elcode> instruction
               defines a URI that may be used to identify the <termref def="dt-secondary-result"/>.
               The instruction may optionally specify the output format to be used for serializing the result.</p>
            
            <p>Technically, the result of evaluating the <elcode>xsl:result-document</elcode>
               instruction is an empty sequence. This means it does not contribute anything to the
               result of the sequence constructor it is part of.</p>
            <p>The <termref def="dt-effective-value">effective value</termref> of the
                  <code>format</code> attribute, if specified, <rfc2119>must</rfc2119> be an <termref def="dt-eqname">EQName</termref>. The value is
               expanded using the namespace declarations in scope for the
                  <elcode>xsl:result-document</elcode> element. The resulting <termref def="dt-expanded-qname">expanded QName</termref>
               <rfc2119>must</rfc2119> match the expanded QName of a named <termref def="dt-output-definition">output definition</termref> in the <termref def="dt-stylesheet">stylesheet</termref>. This identifies the
                  <elcode>xsl:output</elcode> declaration that will control the serialization of the
                  <termref def="dt-final-result-tree">final result tree</termref> (see <specref ref="serialization"/>), if the result tree is serialized. If the
                  <code>format</code> attribute is omitted, the unnamed <termref def="dt-output-definition">output definition</termref> is used to control
               serialization of the result tree.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1460">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the <termref def="dt-effective-value">effective value</termref> of the
                        <code>format</code> attribute <error.extra>of an
                           <elcode>xsl:result-document</elcode> element</error.extra> is not a valid
                        <termref def="dt-eqname">EQName</termref>, or if it does not match the
                        <termref def="dt-expanded-qname">expanded QName</termref> of an <termref def="dt-output-definition">output definition</termref> in the containing <termref def="dt-package">package</termref>. If the processor is able to detect
                     the error statically (for example, when the <code>format</code> attribute
                     contains no curly brackets), then the processor <rfc2119>may</rfc2119>
                     optionally signal this as a <termref def="dt-static-error">static
                        error</termref>.</p>
               </error>
            </p>
            <note>
               <p>The only way to select the unnamed <termref def="dt-output-definition">output
                     definition</termref> is to omit the <code>format</code> attribute.</p>
            </note>
            <p>The <code>parameter-document</code> attribute allows serialization
               parameters to be supplied in an external document. The external document must contain
               an <code>output:serialization-parameters</code> element with the format described in
                  <xspecref spec="SER30" ref="serparams-in-xdm-instance"/>, and the parameters are
               interpreted as described in that specification.</p>
            <p>If present, the <termref def="dt-effective-value"/> of the URI supplied in the
                  <code>parameter-document</code> attribute is dereferenced, after resolution
               against the base URI of the <elcode>xsl:result-document</elcode> element if it is a
               relative reference. 
               The parameter document <rfc2119>should</rfc2119> be read during run-time evaluation of the stylesheet. 
               If the location of the stylesheet at development time is
               different from the deployed location, any relative reference should be resolved
               against the deployed location. A serialization error occurs if the result of
               dereferencing the URI is ill-formed or invalid; but if no document can be found at
               the specified location, the attribute <code>should</code> be ignored.</p>
            <p>A serialization parameter specified in the
                  <code>parameter-document</code> takes precedence over a value supplied directly as
               an attribute of <elcode>xsl:result-document</elcode>, which in turn takes precedence
               over a value supplied in the selected output definition, except that the values of
               the <code>cdata-section-elements</code> and <code>suppress-indentation</code>
               attributes are merged in the same way as when multiple <elcode>xsl:output</elcode>
               declarations are merged.</p>
            <p>The attributes <code>method</code>, <code>allow-duplicate-names</code>, <code>build-tree</code>, <code>byte-order-mark</code>
               <code>cdata-section-elements</code>, <code>doctype-public</code>,
                  <code>doctype-system</code>, <code>encoding</code>,
                  <code>escape-uri-attributes</code>, <code>html-version</code>, <code>indent</code>, <code>item-separator</code>,
               <code>json-node-output-method</code>,
                  <code>media-type</code>, <code>normalization-form</code>,
                  <code>omit-xml-declaration</code>, <code>standalone</code>, <code>suppress-indentation</code>,
               <!-- see bug 6535 -->
               <code>undeclare-prefixes</code>, <code>use-character-maps</code>, and
                  <code>output-version</code> may be used to override attributes defined in the
               selected <termref def="dt-output-definition">output definition</termref>.</p>
            <p>With the exception of <code>use-character-maps</code>, these attributes are all
               defined as <termref def="dt-attribute-value-template">attribute value
                  templates</termref>, so their values may be set dynamically. For any of these
               attributes that is present on the <elcode>xsl:result-document</elcode> instruction,
               the <termref def="dt-effective-value">effective value</termref> of the attribute
               overrides or supplements the corresponding value from the output definition. This
               works in the same way as when one <elcode>xsl:output</elcode> declaration overrides
               another. Some of the attributes have more specific
                  rules:</p>
            <ulist>
               <item>
                  <p>In the case of <code>cdata-section-elements</code>
                     and <code>suppress-indentation</code>, the
                     value of the serialization parameter is the union of the expanded names of the
                     elements named in this instruction and the elements named in the selected
                     output definition.</p>
               </item>
               <item>
                  <p>In the case of <code>use-character-maps</code>, the character maps referenced
                     in this instruction supplement and take precedence over those defined in the
                     selected output definition.</p>
               </item>
               <item>
                  <p>In the case of <code>doctype-public</code> and <code>doctype-system</code>,
                     setting the effective value of the attribute to a zero-length string has the
                     effect of overriding any value for these attributes obtained from the output
                     definition. The corresponding serialization parameter is not set (is
                     “absent”).</p>
               </item>
               <item>
                  <p>In the case of <code>item-separator</code>, setting the effective value of the
                     attribute to the special value <code>"#absent"</code> has the effect of
                     overriding any value for this attribute obtained from the output definition.
                     The corresponding serialization parameter is not set (is “absent”). It is not
                     possible to set the value of the serialization parameter to the literal
                     7-character string <code>"#absent"</code>. </p>
               </item>
               <item>
                  <p>In all other cases, the effective value of an attribute actually present on
                     this instruction takes precedence over the value defined in the selected output
                     definition.</p>
               </item>
            </ulist>
            <note>
               <p>In the case of the attributes <code>method</code>,
                     <code>cdata-section-elements</code>, <code>suppress-indentation</code>, and
                     <code>use-character-maps</code>, the <termref def="dt-effective-value">effective value</termref> of the attribute contains a space-separated list of
                     <termref def="dt-eqname">EQNames</termref>. If any of these is a <termref def="dt-lexical-qname">lexical QName</termref> with a prefix, the prefix is
                  expanded using the in-scope namespaces for the
                     <elcode>xsl:result-document</elcode> element. In the case of
                     <code>cdata-section-elements</code>
                  and <code>suppress-indentation</code>, an
                  unprefixed element name is expanded using the default namespace. In the case of
                  the <code>method</code> attribute, if the method is not one of the system-defined
                  methods (xml, html, xhtml, text) then the expanded name must have a non-absent
                  namespace.</p>
            </note>
            <p diff="del" at="A">Unless the processor implements the XPath 3.1 feature, the 
               <code>method</code> values <code>json</code> and
                  <code>adaptive</code>
               <rfc2119>must</rfc2119> be rejected as invalid, and the attributes
                  <code>allow-duplicate-names</code> and <code>json-node-output-method</code>
               <rfc2119>must</rfc2119> be ignored. The meaning of these output methods and
               serialization parameters is defined in <bibref ref="xslt-xquery-serialization-31"/>.</p>
            <p>The <code>output-version</code> attribute on the <elcode>xsl:result-document</elcode>
               instruction overrides the <code>version</code> attribute on
                  <elcode>xsl:output</elcode> (it has been renamed because <code>version</code> is
               available with a different meaning as a standard attribute: see <specref ref="standard-attributes"/>). In all other cases, attributes correspond if they
               have the same name.</p>
            <p>There are some serialization parameters that apply to some output methods but not to
               others. For example, the <code>indent</code> attribute has no effect on the
                  <code>text</code> output method. If a value is supplied for an attribute that is
               inapplicable to the output method, its value is not passed to the serializer. The
               processor <rfc2119>may</rfc2119> validate the value of such an attribute, but is not
                  <rfc2119>required</rfc2119> to do so.</p>
            
            <p>The <code>item-separator</code> serialization parameter
               is used when the <termref def="dt-raw-result"/> is used to construct a result tree
               by applying sequence normalization, and it is also used when the result tree is
               serialized. For example, if the sequence constructor delivers a sequence of
               integers, and the <code>text</code> serialization method is used, then the result of serialization
               will be a string obtained by converting each integer to a string, and separating the
               strings using the defined <code>item-separator</code>.</p>
            
            
            <p>The <code>href</code> attribute is optional. The default value is the zero-length
               string. The <termref def="dt-effective-value">effective value</termref> of the
               attribute <rfc2119>must</rfc2119> be a <termref def="dt-uri-reference">URI
                  Reference</termref>, which may be absolute or relative. If it is relative, then it is resolved against the <termref def="dt-base-output-uri"/>. There <rfc2119>may</rfc2119> be <termref def="dt-implementation-defined">implementation-defined</termref> restrictions on
               the form of absolute URI that may be used, but the implementation is not
                  <rfc2119>required</rfc2119> to enforce any restrictions. Any valid relative URI
                  reference
               <rfc2119>must</rfc2119> be accepted. Note that the zero-length string is a valid
               relative URI reference.</p>
            <imp-def-feature id="idf-api-resultdocumenthref"> It is <termref def="dt-implementation-defined"/> how the URI appearing in the <code>href</code>
               attribute of <elcode>xsl:result-document</elcode> affects the way in which the result
               tree is delivered to the application. There <rfc2119>may</rfc2119> be restrictions on
               the form of this URI. </imp-def-feature>
            <p>If the implementation provides an API to access <termref def="dt-secondary-result">secondary results</termref>, then it
                  <rfc2119>must</rfc2119> allow a secondary result to be identified by means of the
               absolutized value of the <code>href</code> attribute. In addition, if a <termref def="dt-final-result-tree"/> is constructed (that is, if the effective value of
                  <code>build-tree</code> is <code>yes</code>), then this value is used as the base
               URI of the document node at the root of the <termref def="dt-final-result-tree">final
                  result tree</termref>. </p>



            <note>
               <p>The base URI of the <termref def="dt-final-result-tree">final result
                     tree</termref> is not necessarily the same thing as the URI of its serialized
                  representation on disk, if any. For example, a server (or browser client) might
                  store final result trees only in memory, or in an internal disk cache. As long as
                  the processor satisfies requests for those URIs, it is irrelevant where they are
                  actually written on disk, if at all.</p>
            </note>
            <note>
               <p>It will often be the case that one <termref def="dt-final-result-tree">final
                     result tree</termref> contains links to another final result tree produced
                  during the same transformation, in the form of a relative URI reference. The mechanism of associating a URI with a final
                  result tree has been chosen to allow the integrity of such links to be preserved
                  when the trees are serialized.</p>
               <p>As well as being potentially significant in any API that provides access to final
                  result trees, the base URI of the new document node is relevant if the final
                  result tree, rather than being serialized, is supplied as input to a further
                  transformation.</p>
            </note>
            <p>The optional attributes <code>type</code> and <code>validation</code> may be used on
               the <elcode>xsl:result-document</elcode> instruction to validate the contents of
                  a <termref def="dt-final-result-tree"/>, and to determine the <termref def="dt-type-annotation">type
                  annotation</termref> that elements and attributes within the <termref def="dt-final-result-tree">final result tree</termref> will carry. The permitted
               values and their semantics are described in <specref ref="validating-document-nodes"/>. Any such validation is applied to the
               document node produced as the result of <xtermref spec="SER30" ref="sequence-normalization"/>.
               If sequence normalization does not take place (typically because the <termref def="dt-raw-result"/>
               is delivered to the application directly, or because the selected serialization method
               does not involve sequence normalization) then the <code>validation</code> and
               <code>type</code> attributes are ignored.</p>
            
            <note><p>Validation applies after inserting item separators as determined by the
            <code>item-separator</code> serialization parameter, and an inappropriate choice
            of <code>item-separator</code> may cause the result to become invalid.</p></note>
            
            <p>A <termref def="dt-processor">processor</termref>
               <rfc2119>may</rfc2119> allow a <termref def="dt-final-result-tree">final result
                  tree</termref> to be serialized. Serialization is described in <specref ref="serialization"/>. However, an implementation (for example, a <termref def="dt-processor">processor</termref> running in an environment with no access to
               writable filestore) is not <rfc2119>required</rfc2119> to support the serialization
               of <termref def="dt-final-result-tree">final result trees</termref>. An
               implementation that does not support the serialization of final result trees
                  <rfc2119>may</rfc2119> ignore the <code>format</code> attribute and the
               serialization attributes. Such an implementation <rfc2119>must</rfc2119> provide the
               application with some means of access to the (un-serialized) result tree, using its
               URI to identify it.</p>
            <p>Implementations may provide additional mechanisms, outside the scope of this
               specification, for defining the way in which <termref def="dt-final-result-tree">final result trees</termref> are processed. Such mechanisms
                  <rfc2119>may</rfc2119> make use of the XSLT-defined attributes on the
                  <elcode>xsl:result-document</elcode> and/or <elcode>xsl:output</elcode> elements,
               or they <rfc2119>may</rfc2119> use additional elements or attributes in an <termref def="dt-implementation-defined">implementation-defined</termref> namespace.</p>

            <example>
               <head>Multiple Result Documents</head>
               <p> The following example takes an XHTML document as input, and breaks it up so that
                  the text following each &lt;h1&gt; element is included in a separate document. A
                  new document <code>toc.html</code> is constructed to act as an index:</p>
               <eg role="xslt-document" xml:space="preserve">&lt;xsl:stylesheet
	version="3.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
	
&lt;xsl:output name="toc-format" method="xhtml" indent="yes"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"/&gt;
            
&lt;xsl:output name="section-format" method="xhtml" indent="no"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"/&gt;	
	 
&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document href="toc.html" 
                       format="toc-format" 
                       validation="strict"&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;head&gt;&lt;title&gt;Table of Contents&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Table of Contents&lt;/h1&gt;
        &lt;xsl:for-each select="/*/xhtml:body/(*[1] | xhtml:h1)"&gt;
          &lt;p&gt;
            &lt;a href="section{position()}.html"&gt;
              &lt;xsl:value-of select="."/&gt;
            &lt;/a&gt;
          &lt;/p&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:for-each-group select="/*/xhtml:body/*" group-starting-with="xhtml:h1"&gt;
    &lt;xsl:result-document href="section{position()}.html" 
                         format="section-format" validation="strip"&gt;  	
      &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
        &lt;head&gt;&lt;title&gt;&lt;xsl:value-of select="."/&gt;&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;xsl:copy-of select="current-group()"/&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:result-document&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</eg>
            </example>
         </div2>
         <div2 id="result-document-restrictions">
            <head>Restrictions on the use of <elcode>xsl:result-document</elcode></head>
            <p>There are restrictions on the use of the <elcode>xsl:result-document</elcode>
               instruction, designed to ensure that the results are fully interoperable even when
               processors optimize the sequence in which instructions are evaluated. Informally, the
               restriction is that the <elcode>xsl:result-document</elcode> instruction can only be
               used while writing a final result tree, not while writing to a temporary tree or a
               sequence. This restriction is defined formally as follows.</p>
            <p>
               <termdef id="dt-output-state" term="output state">Each instruction in the <termref def="dt-stylesheet">stylesheet</termref> is evaluated in one of two possible
                     <term>output states</term>: <termref def="dt-final-output-state">final output
                     state</termref> or <termref def="dt-temporary-output-state">temporary output
                     state</termref>.</termdef></p>
            <p>
               <termdef id="dt-final-output-state" term="final output state">The first of the two
                     <termref def="dt-output-state">output states</termref> is called <term>final
                     output</term> state. This state applies when instructions are writing to a
                     <termref def="dt-final-result-tree">final result tree</termref>.</termdef>
            </p>
            <p>
               <termdef id="dt-temporary-output-state" term="temporary output state">The second of
                  the two <termref def="dt-output-state">output states</termref> is called
                     <term>temporary output</term> state. This state applies when instructions are
                  writing to a <termref def="dt-temporary-tree">temporary tree</termref> or any
                  other non-final destination.</termdef>
            </p>
            <p>The instructions in the <termref def="dt-initial-named-template"/> are evaluated in
                  <termref def="dt-final-output-state">final output state</termref>. An instruction
               is evaluated in the same <termref def="dt-output-state">output state</termref> as its
               calling instruction, except that <elcode>xsl:variable</elcode>,
                  <elcode>xsl:param</elcode>, <elcode>xsl:with-param</elcode>, 
               <elcode>xsl:function</elcode>, <elcode>xsl:key</elcode>, <elcode>xsl:sort</elcode>,
                  <elcode>xsl:accumulator-rule</elcode>, and
                     <elcode>xsl:merge-key</elcode>
                always evaluate the instructions in their
               contained <termref def="dt-sequence-constructor">sequence constructor</termref> in
                  <termref def="dt-temporary-output-state">temporary output state</termref>.</p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1480">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> to evaluate the
                        <elcode>xsl:result-document</elcode> instruction in <termref def="dt-temporary-output-state">temporary output state</termref>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1490">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> for a transformation to
                     generate two or more <termref def="dt-final-result-tree">final result
                        trees</termref> with the same URI.</p>
               </error>
            </p>
            <note>
               <p>Note, this means that it is an error to evaluate more than one
                     <elcode>xsl:result-document</elcode> instruction that omits the
                     <code>href</code> attribute, or to evaluate any
                     <elcode>xsl:result-document</elcode> instruction that omits the
                     <code>href</code> attribute if an initial <termref def="dt-final-result-tree">final result tree</termref> is created implicitly.</p>
            </note>
            <p>In addition, an implementation <rfc2119>may</rfc2119> report this
               error if it is able to detect that two or more final result trees are generated with
               different URIs that refer to the same physical resource.</p>


            
            <p>
               <error spec="XT" type="dynamic" class="DE" code="1500">
                  <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> for a <termref def="dt-stylesheet">stylesheet</termref> to write to an external resource
                     and read from the same resource during a single transformation, if the same absolute URI is used to access the resource in
                        both cases. </p>
               </error>
            </p>
            <p>In addition, an implementation <rfc2119>may</rfc2119> report this
               error if it is able to detect that a transformation writes to a resource and reads
               from the same resource using different URIs that refer to the same physical resource.
               Note that if the error is not detected, it is <termref def="dt-implementation-dependent"/> whether the document that is read from the
               resource reflects its state before or after the result tree is written.</p>
         </div2>
         <div2 id="current-output-uri">
            <head>The Current Output URI</head>
            <p><termdef id="dt-current-output-uri" term="current output URI">The <term>current output URI</term> is the URI
                  associated with the <termref def="dt-principal-result"/> or <termref def="dt-secondary-result"/> that is currently being written.</termdef></p>
            <div3 id="func-current-output-uri">
               <head><?function fn:current-output-uri?></head>

            </div3>
         </div2>


         <div2 id="validation">
            <head>Validation</head>
            <p>It is possible to control the <termref def="dt-type-annotation"/> applied to
               individual element and attribute nodes as they are constructed. This is done using
               the <code>type</code> and <code>validation</code> attributes of the
                  <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                  <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                  <elcode>xsl:document</elcode>, and <elcode>xsl:result-document</elcode>
               instructions, or the <code>xsl:type</code> and <code>xsl:validation</code> attributes
               of a <termref def="dt-literal-result-element">literal result element</termref>.
                  The same attributes are used on
                     <elcode>xsl:source-document</elcode> and <elcode>xsl:merge-source</elcode> to control
                  validation of input documents.</p>
            <p>The <code>[xsl:]type</code> attribute is used to request validation of an element or
               attribute against a specific simple or complex type defined in a schema. The
                  <code>[xsl:]validation</code> attribute is used to request validation against the
               global element or attribute declaration whose name matches the name of the element or
               attribute being validated.</p>
            <p>The <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are mutually
               exclusive. Both are optional, but if one is present then the other
                  <rfc2119>must</rfc2119> be omitted. If both attributes are omitted, the effect is
               the same as specifying the <code>validation</code> attribute with the value specified
               in the <code>[xsl:]default-validation</code> attribute of
                  the innermost containing element having such an attribute; if this is not
               specified, the effect is the same as specifying <code>validation="strip"</code>.</p>

            <p>The <code>[xsl:]default-validation</code> attribute defines the
               default value of the <code>validation</code> attribute of all
                  <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                  <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                  <elcode>xsl:document</elcode>, and <elcode>xsl:result-document</elcode>
               instructions, and of the <code>xsl:validation</code> attribute of all
               <termref def="dt-literal-result-element">literal result elements</termref>,
               appearing <phrase diff="chg" at="A">appearing as descendants of the element 
                  on which the attribute appears, unless there is an inner element that defines 
                  a different default</phrase>. <phrase diff="del" at="A">It also determines
               the validation applied to the implicit <termref def="dt-final-result-tree">final
                  result tree</termref> created in the absence of an
                  <elcode>xsl:result-document</elcode> instruction.</phrase> This default <phrase diff="del" at="A">applies within the
               containing <termref def="dt-stylesheet-module">stylesheet module</termref> or
                  <termref def="dt-package"/>: it</phrase> does not extend to included or imported stylesheet
               modules or used packages. If the attribute is omitted, the default is
                  <code>strip</code>. The permitted values are <code>preserve</code> and
                  <code>strip</code>.</p>
            
            <p diff="add" at="A">
               The <code>default-validation</code> attribute on the outermost element of the principal
               stylesheet module of the <termref def="dt-top-level-package"/> also determines the validation 
               applied to the implicit final result tree created in the absence of an 
               <elcode>xsl:result-document</elcode> instruction. [XSLT 3.0 Erratum E15, bug 30211].
            </p>

            <p>The <code>[xsl:]default-validation</code> attribute has no
               effect on the <elcode>xsl:source-document</elcode> and <elcode>xsl:merge-source</elcode>
               elements, which perform no validation unless explicitly requested.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1505">
                  <p>It is a <termref def="dt-static-error">static error</termref> if both the
                        <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are
                     present on the <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                        <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                        <elcode>xsl:document</elcode>, <elcode>xsl:result-document</elcode>, <elcode>xsl:source-document</elcode>, or
                           <elcode>xsl:merge-source</elcode> elements, or on a <termref def="dt-literal-result-element">literal result element</termref>.</p>
               </error>
            </p>
            <p>The detailed rules for validation vary depending on the kind of node being validated.
               The rules for element and attribute nodes are given in <specref ref="validating-constructed-nodes"/>, while those for document nodes are given in
                  <specref ref="validating-document-nodes"/>.</p>
            <div3 id="validating-constructed-nodes">
               <head>Validating Constructed Elements and Attributes</head>
               <div4 id="validating-using-validation-attribute">
                  <head>Validation using the <code>[xsl:]validation</code> Attribute</head>
                  <p>The <code>[xsl:]validation</code> attribute defines the validation action to be
                     taken. It determines not only the <termref def="dt-type-annotation">type
                        annotation</termref> of the node that is constructed by the relevant
                     instruction itself, but also the type annotations of all element and attribute
                     nodes that have the constructed node as an ancestor. Conceptually, the
                     validation requested for a child element or attribute node is applied before
                     the validation requested for its parent element. For example, if the
                     instruction that constructs a child element specifies
                        <code>validation="strict"</code>, this will cause the child element to be
                     checked against an element declaration, but if the instruction that constructs
                     its parent element specifies <code>validation="strip"</code>, then the final
                     effect will be that the child node is annotated as <code>xs:untyped</code>.</p>
                  <p>In the paragraphs below, the term <emph>contained nodes</emph> means the
                     elements and attributes that have the newly constructed node as an
                     ancestor.</p>
                  <olist>
                     <item>
                        <p>The value <code>strip</code> indicates that the new node and each of the
                           contained nodes will have the <termref def="dt-type-annotation">type
                              annotation</termref>
                           <code>xs:untyped</code> if it is an element, or
                              <code>xs:untypedAtomic</code> if it is an attribute. Any previous type
                           annotation present on a contained element or attribute node (for example,
                           a type annotation that is present on an element copied from a source
                           document) is also replaced by <code>xs:untyped</code> or
                              <code>xs:untypedAtomic</code> as appropriate. The typed value of the
                           node is changed to be the same as its string value, as an instance of
                              <code>xs:untypedAtomic</code>. In the case of elements the
                              <code>nilled</code> property is set to <code>false</code>. The values
                           of the <code>is-id</code> and <code>is-idrefs</code> properties are
                           unchanged. Schema validation is not invoked.</p>
                     </item>
                     <item>
                        <p>The value <code>preserve</code> indicates that nodes that are copied will
                           retain their <termref def="dt-type-annotation">type
                           annotations</termref>, but nodes whose content is newly constructed will
                           be annotated as <code>xs:anyType</code> in the case of elements, or
                              <code>xs:untypedAtomic</code> in the case of attributes. Schema
                           validation is not invoked. The detailed effect depends on the
                           instruction:</p>
                        <olist>
                           <item>
                              <p>In the case of <elcode>xsl:element</elcode> and literal result
                                 elements, the new element has a <termref def="dt-type-annotation">type annotation</termref> of <code>xs:anyType</code>, and the
                                 type annotations of contained nodes are retained unchanged.</p>
                              <p>The <code>nilled</code>,
                                    <code>is-id</code> and <code>is-idrefs</code> properties on the
                                 new element are set to <code>false</code>.</p>
                           </item>
                           <item>
                              <p>In the case of <elcode>xsl:attribute</elcode>, the effect is
                                 exactly the same as specifying <code>validation="strip"</code>:
                                 that is, the new attribute will have the type annotation
                                    <code>xs:untypedAtomic</code>.</p>
                              <p>The <code>is-id</code> and
                                    <code>is-idrefs</code> properties on the new attribute are set
                                 to <code>false</code>.</p>
                           </item>
                           <item>
                              <p>In the case of <elcode>xsl:copy-of</elcode>, all the nodes that are
                                 copied will retain their type annotations unchanged. The values of their
                                       <code>nilled</code>, <code>is-id</code> and
                                       <code>is-idrefs</code> properties are also
                                 unchanged.</p>
                           </item>
                           <item>
                              <p>In the case of <elcode>xsl:copy</elcode>, the effect depends on the
                                 kind of node being copied.</p>
                              <olist>
                                 <item>
                                    <p>Where the node being copied is an attribute, the copied
                                       attribute will retain its <termref def="dt-type-annotation">type annotation</termref>
                                       and the values of its
                                             <code>is-id</code> and <code>is-idrefs</code>
                                          properties.</p>
                                 </item>
                                 <item>
                                    <p>Where the node being copied is an element, the copied element
                                       will have a <termref def="dt-type-annotation">type
                                          annotation</termref> of <code>xs:anyType</code> (because
                                       this instruction does not copy the content of the element, it
                                       would be wrong to assume that the type is unchanged); but any
                                       contained nodes will have their type annotations retained in
                                       the same way as with <elcode>xsl:element</elcode>. The values of the
                                             <code>nilled</code>, <code>is-id</code>, and
                                             <code>is-idrefs</code> properties are handled in the
                                          same way as <elcode>xsl:element</elcode>.
                                    </p>
                                 </item>
                              </olist>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>The value <code>strict</code> indicates that <termref def="dt-type-annotation">type annotations</termref> are established by
                           performing strict schema validity assessment on the element or attribute
                           node created by this instruction as follows:</p>
                        <olist>
                           <item>
                              <p>In the case of an element, a top-level element declaration is
                                 identified whose local name and namespace (if any) match the name
                                 of the element, and schema-validity assessment is carried out
                                 according to the rules defined in <bibref ref="xmlschema-1"/>
                                 (section 3.3.4 <quote>Element Declaration Validation Rules</quote>,
                                 validation rule <quote>Schema-Validity Assessment
                                 (Element)</quote>, clauses 1.1 and 2, using the top-level element
                                 declaration as the “declaration stipulated by the processor”, which
                                 is mentioned in clause 1.1.1.1). The element is considered valid if
                                 the result of the schema validity assessment is a PSVI in which the
                                 relevant element node has a <code>validity</code> property whose
                                 value is <code>valid</code>. If there is no matching element
                                 declaration, or if the element is not considered valid, the
                                 transformation fails <errorref class="TE" code="1510"/>, <errorref class="TE" code="1512"/>. In effect this means that the element
                                 being validated <rfc2119>must</rfc2119> be declared using a
                                 top-level declaration in the schema, and <rfc2119>must</rfc2119>
                                 conform to its declaration. The process of validation applies
                                 recursively to contained elements and attributes to the extent
                                 required by the schema definition.</p>
                              <note>
                                 <p>It is not an error if the identified type definition is a simple
                                    type, although <bibref ref="xmlschema-1"/> does not define
                                    explicitly that this case is permitted.</p>
                              </note>
                           </item>
                           <item>
                              <p>In the case of an attribute, a top-level attribute declaration is
                                 identified whose local name and namespace (if any) match the name
                                 of the attribute, and schema-validity assessment is carried out
                                 according to the rules defined in <bibref ref="xmlschema-1"/>
                                 (section 3.2.4 <quote>Attribute Declaration Validation
                                    Rules</quote>, validation rule <quote>Schema-Validity Assessment
                                    (Attribute)</quote>). The attribute is considered valid if the
                                 result of the schema validity assessment is a PSVI in which the
                                 relevant attribute node has a <code>validity</code> property whose
                                 value is <code>valid</code>. If the attribute is not considered
                                 valid, the transformation fails <errorref class="TE" code="1510"/>.
                                 In effect this means that the attribute being validated
                                    <rfc2119>must</rfc2119> be declared using a top-level
                                 declaration in the schema, and <rfc2119>must</rfc2119> conform to
                                 its declaration.</p>
                           </item>
                           <item>
                              <p>The schema components used to validate an element or attribute may
                                 be located in any way described by <bibref ref="xmlschema-1"/> (see
                                 section 4.3.2, <emph>How schema documents are located on the
                                    Web</emph>). The components in the schema constructed from the
                                 synthetic schema document (see <specref ref="import-schema"/>) will
                                 always be available for validating constructed nodes; if additional
                                 schema components are needed, they <rfc2119>may</rfc2119> be
                                 located in other ways, for example implicitly from knowledge of the
                                 namespace in which the elements and attributes appear, or using the
                                    <code>xsi:schemaLocation</code> attribute of elements within the
                                 tree being validated.</p>
                           </item>
                           <item>
                              <p>The type annotations on the resulting
                                 nodes, as well as the values of their <code>is-id</code>,
                                    <code>is-idrefs</code>, and <code>nilled</code> properties, are
                                 defined by the rules in <xspecref ref="const-psvi" spec="DM31"/>.</p>
                           </item>
                           <item>
                              <p>If no validation is performed for a node, which can happen when the
                                 schema specifies <code>lax</code> or <code>skip</code> validation
                                 for that node or for a subtree, then the node is annotated as
                                    <code>xs:anyType</code> in the case of an element, and
                                    <code>xs:untypedAtomic</code> in the case of an attribute.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>The value <code>lax</code> has the same effect as the value
                              <code>strict</code>, except that whereas <code>strict</code>
                           validation fails if there is no matching top-level element declaration or
                           if the outcome of validity assessment is a <code>validity</code> property
                           of <code>invalid</code> or <code>notKnown</code>, <code>lax</code>
                           validation fails only if the outcome of validity assessment is a
                              <code>validity</code> property of <code>invalid</code>. That is,
                              <code>lax</code> validation does not cause a <termref def="dt-type-error">type error</termref> when the outcome is
                              <code>notKnown</code>.</p>
                        <p>In practice this means that the element or attribute being validated
                              <rfc2119>must</rfc2119> conform to its declaration if a top-level
                           declaration is available. If no such declaration is available, then the
                           element or attribute is not validated, but its attributes and children
                           are validated, again with lax validation. Any nodes whose validation
                           outcome is a <code>validity</code> property of <code>notKnown</code> are
                           annotated as <code>xs:anyType</code> in the case of an element, and
                              <code>xs:untypedAtomic</code> in the case of an attribute.</p>

                        <p>The type annotations on the resulting nodes,
                           as well as the values of their <code>is-id</code>,
                           <code>is-idrefs</code>, and <code>nilled</code> properties, are defined
                           by the rules in <xspecref ref="const-psvi" spec="DM31"/>.</p>

                        <note>
                           <p>When the parent element lacks a declaration, the XML Schema
                              specification defines the recursive checking of children and
                              attributes as optional. For this specification, this recursive
                              checking is required.</p>
                        </note>
                        <note>
                           <p>If an element that is being validated has an <code>xsi:type</code>
                              attribute, then the value of the <code>xsi:type</code> attribute will
                              be taken into account when performing the validation. However, the
                              presence of an <code>xsi:type</code> attribute will not of itself
                              cause an element to be validated: if validation against a named type
                              is required, as distinct from validation against a top-level element
                              declaration, then it must be requested using the XSLT
                                 <code>[xsl:]type</code> attribute on the instruction that invokes
                              the validation, as described in section <specref ref="validation-xsl-type"/>
                           </p>
                        </note>
                        
                     </item>
                  </olist>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1510">
                        <p>If the <code>validation</code> attribute of an
                              <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                              <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, or
                              <elcode>xsl:result-document</elcode> instruction, or the
                              <code>xsl:validation</code> attribute of a literal result element, has
                           the effective value <code>strict</code>, and schema validity assessment
                           concludes that the validity of the element or attribute is invalid or
                           unknown, a <termref def="dt-type-error">type error</termref> occurs. As
                           with other type errors, the error <rfc2119>may</rfc2119> be signaled
                           statically if it can be detected statically. </p>
                     </error>
                  </p>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1512">
                        <p>If the <code>validation</code> attribute of an
                              <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                              <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, or
                              <elcode>xsl:result-document</elcode> instruction, or the
                              <code>xsl:validation</code> attribute of a literal result element, has
                           the effective value <code>strict</code>, and there is no matching
                           top-level declaration in the schema, then a <termref def="dt-type-error">type error</termref> occurs. As with other type errors, the error
                              <rfc2119>may</rfc2119> be signaled statically if it can be detected
                           statically. </p>
                     </error>
                  </p>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1515">
                        <p>If the <code>validation</code> attribute of an
                              <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                              <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>, or
                              <elcode>xsl:result-document</elcode> instruction, or the
                              <code>xsl:validation</code> attribute of a literal result element, has
                           the effective value <code>lax</code>, and schema validity assessment
                           concludes that the element or attribute is invalid, a <termref def="dt-type-error">type error</termref> occurs. As with other type
                           errors, the error <rfc2119>may</rfc2119> be signaled statically if it can
                           be detected statically. </p>
                     </error>
                  </p>
                  <note>
                     <p>No mechanism is provided to validate an element or attribute against a local
                        declaration in a schema. Such validation can usually be achieved by applying
                        validation to a containing element for which a top-level element declaration
                        exists.</p>
                  </note>
               </div4>
               <div4 id="validation-xsl-type">
                  <head>Validation using the <code>[xsl:]type</code> Attribute</head>
                  <p>The <code>[xsl:]type</code> attribute takes as its value an 
                     <phrase diff="chg" at="A"><xnt spec="XP40" ref="dt-EQName"/></phrase>.
                     If it is a lexical QName with no prefix, it is
                     expanded using the <phrase diff="chg" at="A">default namespace for types</phrase>.
                     This <rfc2119>must</rfc2119> be the name of a type definition included in the
                        <termref def="dt-in-scope-schema-component">in-scope schema
                        components</termref> for the stylesheet. </p>
                  <p>If the <code>[xsl:]type</code> attribute is present, then the newly constructed
                     element or attribute is validated against the type definition identified by
                     this attribute.</p>
                  <ulist>
                     <item>
                        <p>In the case of an element, schema-validity assessment is carried out
                           according to the rules defined in <bibref ref="xmlschema-1"/> (section
                           3.3.4 <quote>Element Declaration Validation Rules</quote>, validation
                           rule <quote>Schema-Validity Assessment (Element)</quote>, clauses 1.2 and
                           2), using this type definition as the <quote>processor-stipulated type
                              definition</quote>. The element is considered valid if the result of
                           the schema validity assessment is a PSVI in which the relevant element
                           node has a <code>validity</code> property whose value is
                              <code>valid</code>. </p>
                     </item>
                     <item>
                        <p>In the case of an attribute, the attribute is considered valid if (in the
                           terminology of XML Schema) the attribute’s normalized value is
                           locally valid with respect to that type definition according to the rules
                           for <quote>String Valid</quote> (<bibref ref="xmlschema-1"/>, section
                           3.14.4). (Normalization here refers to the process of normalizing
                           whitespace according to the rules of the <code>whiteSpace</code> facet
                           for the datatype).</p>
                     </item>
                     <item>
                        <p>If the element or attribute is not considered valid, as defined above,
                           the transformation fails <errorref class="TE" code="1540"/>.</p>
                     </item>
                  </ulist>

                  <p>If an element node is validated against the type
                        <code>xs:untyped</code>, the effect is the same as specifying
                        <code>validation="strip"</code>: that is, the elements and attributes in the
                     subtree rooted at the target element are copied with a type annotation of
                        <code>xs:untyped</code> or <code>xs:untypedAtomic</code> respectively.</p>

                  <p>If an element or attribute node is validated against the type
                        <code>xs:untypedAtomic</code>, the effect is the same as specifying
                        <code>[xsl:]type="xs:string"</code> except that when validation succeeds,
                     the returned element or attribute has a type annotation of
                        <code>xs:untypedAtomic</code>. Validation fails in the case of an element
                     with element children.</p>
                  <p>
                     <error spec="XT" type="static" class="SE" code="1520">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                           value of the <code>type</code> attribute of an
                              <elcode>xsl:element</elcode>, <elcode>xsl:attribute</elcode>,
                              <elcode>xsl:copy</elcode>, <elcode>xsl:copy-of</elcode>,
                              <elcode>xsl:document</elcode>, <elcode>xsl:result-document</elcode>,
                           <phrase diff="add" at="E"><elcode>xsl:source-document</elcode>, or 
                              <elcode>xsl:merge-source</elcode></phrase>
                           instruction, or the <code>xsl:type</code> attribute of a literal result
                           element, is not a valid <code>QName</code>, or if it uses a prefix that
                           is not defined in an in-scope namespace declaration, or if the QName is
                           not the name of a type definition included in the <termref def="dt-in-scope-schema-component">in-scope schema
                              components</termref> for the <termref def="dt-package">package</termref>.
                        <phrase diff="add" at="A">[XSLT 3.0 Erratum E20, bug 30234]</phrase></p>
                     </error>
                  </p>
                  <p>
                     <error spec="XT" type="static" class="SE" code="1530">
                        <p>It is a <termref def="dt-static-error">static error</termref> if the
                           value of the <code>type</code> attribute of an
                              <elcode>xsl:attribute</elcode> instruction refers to a complex type
                           definition</p>
                     </error>.</p>
                  <p>
                     <!-- see spec bug 13001 -->
                     <error spec="XT" type="type" class="TE" code="1535">
                        <p>It is a <termref def="dt-type-error">type error</termref> if the value of
                           the <code>type</code> attribute of an <elcode>xsl:copy</elcode> or
                              <elcode>xsl:copy-of</elcode> instruction refers to a complex type
                           definition and one or more of the items being copied is an attribute
                           node.</p>
                     </error></p>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1540">
                        <p>It is a <termref def="dt-type-error">type error</termref> if an
                              <code>[xsl:]type</code> attribute is defined for a constructed element
                           or attribute, and the outcome of schema validity assessment against that
                           type is that the <code>validity</code> property of that element or
                           attribute information item is other than <code>valid</code>.</p>
                     </error>
                  </p>
                  <note>
                     <p>Like other type errors, this error may be signaled statically if it can be
                        detected statically. For example, the instruction <code>&lt;xsl:attribute
                           name="dob" type="xs:date"&gt;1999-02-29&lt;/xsl:attribute&gt;</code> may
                        result in a static error being signaled. If the error is not signaled
                        statically, it will be signaled when the instruction is evaluated.</p>
                  </note>
               </div4>
               <div4 id="validation-process">
                  <head>The Validation Process</head>
                  <p>As well as checking for validity against the schema, the validity assessment
                     process causes <termref def="dt-type-annotation">type annotations</termref> to
                     be associated with element and attribute nodes. If default values for elements
                     or attributes are defined in the schema, the validation process will where
                     necessary create new nodes containing these default values.</p>
                  <p>Validation of an element or attribute node only takes into account constraints
                     on the content of the element or attribute. Validation rules affecting the
                     document as a whole are not applied. Specifically, this means:</p>
                  <ulist>
                     <item>
                        <p>The validation rule <quote>Validation Root Valid (ID/IDREF)</quote> is
                           not applied. This means that validation will not fail if there are
                           non-unique ID values or dangling IDREF values in the subtree being
                           validated.</p>
                     </item>
                     <item>
                        <!--Text replaced by erratum E12 change 1"-->
                        <p>The validation rule <quote>Validation Rule: Identity-constraint
                              Satisfied</quote>
                           <rfc2119>should</rfc2119> be applied.</p>
                        <!--End of text replaced by erratum E12-->
                     </item>
                     <item>
                        <p>There is no check that the document contains unparsed entities whose
                           names match the values of nodes of type <code>xs:ENTITY</code> or
                              <code>xs:ENTITIES</code>. (XSLT 3.0
                           provides no facility to construct unparsed entities within a tree.)</p>
                     </item>
                     
                  </ulist>
                  <p>With these caveats, validating a newly constructed element, using strict or lax
                     validation, is equivalent to the following steps:</p>
                  <olist>
                     <item>
                        <p>The element is serialized to textual XML form, according to the rules
                           defined in <bibref ref="xslt-xquery-serialization-30"/> using the XML
                           output method, with all parameters defaulted. Note that this process
                           discards any existing <termref def="dt-type-annotation">type
                              annotations</termref>.</p>
                     </item>
                     <item>
                        <p>The resulting XML document is parsed to create an XML Information Set
                           (see <bibref ref="xml-infoset"/>.)</p>
                     </item>
                     <item>
                        <p>The Information Set produced in the previous step is validated according
                           to the rules in <bibref ref="xmlschema-1"/>. The result of this step is a
                           Post-Schema Validation Infoset (PSVI). If the validation process is not
                           successful (as defined above), a <termref def="dt-type-error">type
                              error</termref> is raised.</p>
                     </item>
                     <item>
                        <p>The PSVI produced in the previous step is converted back into the XDM
                           data model by the mapping described in <bibref ref="xpath-datamodel-30"/>
                              (<xspecref spec="DM30" ref="PSVI2Types"/>). This process creates nodes
                           with simple or complex <termref def="dt-type-annotation">type
                              annotations</termref> based on the types established during schema
                           validation.</p>
                     </item>
                  </olist>

                  <p> The above process must be done in such a way that
                     the base URI property of every node in the resulting XDM tree is the same as
                     the base URI property of the corresponding node in the input tree. </p>
                  <note>
                     <p> As an alternative to steps 1 and 2, the XDM tree may be converted to an
                        Infoset directly, using the mapping rules given for each kind of node in
                           <bibref ref="xpath-datamodel-30"/> (Section 6). </p>
                  </note>
                  <p>Validating an attribute using strict or lax validation requires a modified
                     version of this procedure. A copy of the attribute is first added to an element
                     node that is created for the purpose, and namespace fixup (see <specref ref="namespace-fixup"/>) is performed on this element node. The name of this
                     element is of no consequence, but it must be the same as the name of a
                     synthesized element declaration of the form:</p>
                  <eg role="xslt-instruction" xml:space="preserve">&lt;xs:element name="E"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute ref="A"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;</eg>
                  <p>where A is the name of the attribute being validated.</p>
                  <p>This synthetic element is then validated using the procedure given above for
                     validating elements, and if it is found to be valid, a copy of the validated
                     attribute is made, retaining its <termref def="dt-type-annotation">type
                        annotation</termref>, but detaching it from the containing element (and
                     thus, from any namespace nodes).</p>
                  <p>The XDM data model does not permit an attribute node with no parent to have a
                     typed value that includes a namespace-qualified name, that is, a value whose
                     type is derived from <code>xs:QName</code> or <code>xs:NOTATION</code>. This
                     restriction is imposed because these types rely on the namespace nodes of a
                     containing element to resolve namespace prefixes. Therefore, it is an error to
                     validate a parentless attribute against such a type. This affects the
                     instructions <elcode>xsl:attribute</elcode>, <elcode>xsl:copy</elcode>, and
                        <elcode>xsl:copy-of</elcode>.</p>
                  <p>
                     <error spec="XT" type="type" class="TE" code="1545">
                        <p>A <termref def="dt-type-error">type error</termref> occurs if a
                              <code>type</code> or <code>validation</code> attribute is defined
                           (explicitly or implicitly) for an instruction that constructs a new
                           attribute node, if the effect of this is to cause the attribute value to
                           be validated against a type that is derived from, or constructed by list
                           or union from, the primitive types <code>xs:QName</code> or
                              <code>xs:NOTATION</code>.</p>
                     </error>
                  </p>
               </div4>
            </div3>
            <div3 id="validating-document-nodes">
               <head>Validating Document Nodes</head>
               <p>It is possible to apply validation to a document node. This happens when a new
                  document node is constructed by one of the XSLT elements <elcode>xsl:source-document</elcode>, <elcode>xsl:merge-source</elcode>, <elcode>xsl:document</elcode>,
                     <elcode>xsl:result-document</elcode>, <elcode>xsl:copy</elcode>, or
                     <elcode>xsl:copy-of</elcode>, and this element has a <code>type</code>
                  attribute, or a <code>validation</code> attribute with the value
                     <code>strict</code> or <code>lax</code>.</p>
               <p>Document-level validation is not applied to the document node that is created
                  implicitly when a variable-binding element has no <code>select</code> attribute
                  and no <code>as</code> attribute (see <specref ref="temporary-trees"/>). This is
                  equivalent to using <code>validation="preserve"</code> on
                     <elcode>xsl:document</elcode>: nodes within such trees retain their <termref def="dt-type-annotation">type annotation</termref>. Similarly, validation is
                  not applied to document nodes created using <elcode>xsl:message</elcode>
                  or <elcode>xsl:assert</elcode>. </p>
               <p>The values <code>validation="preserve"</code> and <code>validation="strip"</code>
                  do not request validation. In the first case, all element and attribute nodes
                  within the tree rooted at the new document node retain their <termref def="dt-type-annotation">type annotations</termref>. In the second case,
                  elements within the tree have their type annotation set to
                  <code>xs:untyped</code>, while attributes have their type annotation set to
                     <code>xs:untypedAtomic</code>.</p>
               <p>When validation is requested for a document node (that is, when
                     <code>validation</code> is set to <code>strict</code> or <code>lax</code>, or
                  when a <code>type</code> attribute is present), the following processing takes
                  place:</p>
               <ulist>
                  <item>
                     <p>
                        <error spec="XT" type="type" class="TE" code="1550">
                           <p>A <termref def="dt-type-error">type error</termref> occurs
                                 <error.extra>when a document node is validated</error.extra> unless
                              the children of the document node comprise exactly one element node,
                              no text nodes, and zero or more comment and processing instruction
                              nodes, in any order.</p>
                        </error>
                     </p>
                  </item>
                  <item>
                     <p>The single element node child is validated, using the supplied values of the
                           <code>validation</code> and <code>type</code> attributes, as described in
                           <specref ref="validating-constructed-nodes"/>.</p>
                     <note>
                        <p>The <code>type</code> attribute on <elcode>xsl:source-document</elcode>,
                              <elcode>xsl:document</elcode> and
                           <elcode>xsl:result-document</elcode>, and on <elcode>xsl:copy</elcode>
                           and <elcode>xsl:copy-of</elcode> when copying a document node, thus
                           refers to the required type of the element node that is the only element
                           child of the document node. It does not refer to the type of the document
                           node itself.</p>
                     </note>
                  </item>
                  <item>
                     <p>The validation rule <quote>Validation Root Valid (ID/IDREF)</quote> is
                        applied to the single element node child of the document node. This means
                        that validation will fail if there are non-unique ID values or dangling
                        IDREF values in the document tree.</p>
                  </item>
                  <item>
                     <p>Identity constraints, as defined in section 3.11 of <bibref ref="xmlschema-1"/>, are checked. (This refers to constraints defined
                        using <code>xs:unique</code>, <code>xs:key</code>, and
                           <code>xs:keyref</code>.)</p>
                  </item>
                  <item>
                     <p>There is no check that the tree contains unparsed entities whose names match
                        the values of nodes of type <code>xs:ENTITY</code> or
                           <code>xs:ENTITIES</code>. This is because there is no facility in XSLT
                           3.0 to create unparsed entities in a
                           <termref def="dt-result-tree">result tree</termref>. It is possible to
                        add unparsed entity declarations to the result document by referencing a
                        suitable DOCTYPE during serialization.</p>
                  </item>
                  
                  <item>
                     <p>All other children of the document node (comments and processing
                        instructions) are copied unchanged.</p>
                  </item>
               </ulist>
               <p>
                  <error spec="XT" type="type" class="TE" code="1555">
                     <p>It is a <termref def="dt-type-error">type error</termref> if, when
                        validating a document node, document-level constraints (such as ID/IDREF
                        constraints) are not satisfied. <!-- see test bug 935 -->
                        </p>
                  </error>
               </p>
            </div3>
            <div3 id="validating-xml-id">
               <head>Validating <code>xml:id</code> attributes</head>
               <p>This section provides a non-normative summary of the effect of validation on
               attributes named <code>xml:id</code>. The normative rules can be inferred from rules
               given elsewhere in this section.</p>
               <olist>
                  <item><p>When an attribute named <code>xml:id</code> is encountered
                  in the course of validation:</p>
                  <olist>
                     <item><p>A validation error occurs if it the attribute is not lexically valid against type <code>xs:ID</code>.</p></item>
                     <item><p>The typed value of the attribute is whitespace-normalized.</p></item>
                     <item><p>The attribute is labeled with type annotation <code>xs:ID</code>.</p></item>
                     <item><p>The attribute acquires the <code>is-id</code> property.</p></item>
                  </olist></item>
                  <item><p>The previous rule applies whether validation is strict, lax, or by type; 
                     validation will never fail (or be skipped) on the grounds
                  that no global attribute declaration named <code>xsl:id</code> is available.</p></item>
                  <item><p>Checking <code>xml:id</code> attributes for uniqueness happens if and only if
                  validation is applied at the level of a document node.</p></item>
               </olist>
            </div3>
         </div2>
      </div1>
      <div1 id="serialization">
         <head>Serialization</head>
         <p>A <termref def="dt-processor">processor</termref>
            <rfc2119>may</rfc2119> output a <termref def="dt-final-result-tree">final result
               tree</termref> as a sequence of octets, although it is not
               <rfc2119>required</rfc2119> to be able to do so (see <specref ref="conformance"/>).
            Stylesheet authors can use <elcode>xsl:output</elcode> declarations to specify how they
            wish result trees to be serialized. If a processor serializes a final result tree, it
               <rfc2119>must</rfc2119> do so as specified by these declarations.</p>
         <p>The rules governing the output of the serializer are defined in <bibref ref="xslt-xquery-serialization-30"/>. The serialization is controlled using a number
            of serialization parameters. The values of these serialization parameters may be set
            within the <termref def="dt-stylesheet">stylesheet</termref>, using the
               <elcode>xsl:output</elcode>, <elcode>xsl:result-document</elcode>, and
               <elcode>xsl:character-map</elcode> declarations.</p>
         <?element xsl:output?>
         <p>The <elcode>xsl:output</elcode> declaration is optional; if used, it
               <rfc2119>must</rfc2119> always appear as a <termref def="dt-top-level">top-level</termref> element within a stylesheet module.</p>
         <p>A <termref def="dt-stylesheet">stylesheet</termref> may contain multiple
               <elcode>xsl:output</elcode> declarations and may include or import stylesheet modules
            that also contain <elcode>xsl:output</elcode> declarations. The name of an
               <elcode>xsl:output</elcode> declaration is the value of its <code>name</code>
            attribute, if any.</p>
         <p>
            <termdef id="dt-output-definition" term="output definition">All the
                  <elcode>xsl:output</elcode> declarations within a
                     <termref def="dt-package">package</termref> that share the same name
               are grouped into a named <term>output definition</term>; those that have no name are
               grouped into a single unnamed output definition.</termdef>
         </p>
         <p>An output definition is scoped to a package. If this is a <termref def="dt-library-package">library package</termref> the output definition applies only
            to <elcode>xsl:result-document</elcode> instructions within the same package. If it is
            the <termref def="dt-top-level-package">top-level package</termref>, the output
            definition applies to <elcode>xsl:result-document</elcode> instructions within the same
            package and also to the implicit <termref def="dt-final-result-tree">final result
               tree</termref>.</p>
         <p>A stylesheet always includes an unnamed <termref def="dt-output-definition">output
               definition</termref>; in the absence of an unnamed <elcode>xsl:output</elcode>
            declaration, the unnamed output definition is equivalent to the one that would be used
            if the stylesheet contained an <elcode>xsl:output</elcode> declaration having no
            attributes.</p>
         <p>A named <termref def="dt-output-definition">output definition</termref> is used when its
            name matches the <code>format</code> attribute used in an
               <elcode>xsl:result-document</elcode> element. The unnamed output definition is used
            when an <elcode>xsl:result-document</elcode> element omits the <code>format</code>
            attribute. It is also used when serializing the <termref def="dt-principal-result"/>.
            .</p>
         <p>All the <elcode>xsl:output</elcode> elements making up an <termref def="dt-output-definition">output definition</termref> are effectively merged. For
            those attributes whose values are namespace-sensitive, the merging is done after
               <termref def="dt-lexical-qname">lexical QNames</termref> have been converted into
               <termref def="dt-expanded-qname">expanded QNames</termref>. For the
               <code>cdata-section-elements</code>
            and <code>suppress-indentation</code> attributes, the
            output definition uses the union of the values from all the constituent
               <elcode>xsl:output</elcode> declarations. For the <code>use-character-maps</code>
            attribute, the output definition uses the concatenation of the sequences of <termref def="dt-expanded-qname">expanded QNames</termref> values from all the constituent
               <elcode>xsl:output</elcode> declarations, taking them in order of increasing <termref def="dt-import-precedence">import precedence</termref>, or where several have the
            same import precedence, in <termref def="dt-declaration-order">declaration
               order</termref>. For other attributes, the <termref def="dt-output-definition">output
               definition</termref> uses the value of that attribute from the
               <elcode>xsl:output</elcode> declaration with the highest <termref def="dt-import-precedence">import precedence</termref>.</p>
         <p>The <code>parameter-document</code> attribute allows serialization
            parameters to be supplied in an external document. The external document must contain an
               <code>output:serialization-parameters</code> element with the format described in
               <xspecref spec="SER30" ref="serparams-in-xdm-instance"/>, and the parameters are
            interpreted as described in that specification.</p>
         <p>If present, the URI supplied in the <code>parameter-document</code>
            attribute is dereferenced, after resolution against the base URI of the
               <elcode>xsl:output</elcode> element if it is a relative reference. 
            The parameter document <rfc2119>should</rfc2119> be read during static analysis of the stylesheet. 
            A serialization error occurs
            if the result of dereferencing the URI is ill-formed or invalid; but if no document can
            be found at the specified location, the attribute <rfc2119>should</rfc2119> be ignored.</p>
         <p>A serialization parameter specified in the
               <code>parameter-document</code> takes precedence over a value supplied directly in
            the output declaration, except that the values of the
               <code>cdata-section-elements</code> and <code>suppress-indentation</code> attributes
            are merged in the same way as when multiple <elcode>xsl:output</elcode> declarations are
            merged.</p>


         <p>
            <error spec="XT" type="static" class="SE" code="1560">
               <p>It is a <termref def="dt-static-error">static error</termref> if two
                     <elcode>xsl:output</elcode> declarations within an <termref def="dt-output-definition">output definition</termref> specify explicit values
                  for the same attribute (other than <code>cdata-section-elements</code>, <code>suppress-indentation</code>, and
                     <code>use-character-maps</code>), with the values of the attributes being not
                  equal, unless there is another <elcode>xsl:output</elcode> declaration within the
                  same <termref def="dt-output-definition">output definition</termref> that has
                  higher import precedence and that specifies an explicit value for the same
                  attribute. </p>
            </error>
         </p>
         <p diff="del" at="A">The <code>build-tree</code> attribute controls whether the
            raw <termref def="dt-principal-result"/> or <termref def="dt-secondary-result"/> is
            converted to a <termref def="dt-final-result-tree"/>. The default depends on the value
            of the <code>method</code> attribute: the default is <code>yes</code> if the
               <code>method</code> attribute specifies <code>xml</code>, <code>html</code>,
               <code>xhtml</code>, or <code>text</code>, or if it is omitted; the default is <code>no</code> if the <code>method</code> attribute
               specifies <code>json</code> or <code>adaptive</code>. A <termref def="dt-final-result-tree"/> may be constructed whether or not it is subsequently
            serialized.</p>
         <p diff="add" at="A">
            If the result is not serialized, then the decision whether to return the raw result 
            or to construct a tree depends on the effective value of the <code>build-tree</code> attribute. 
            If the effective value of the <code>build-tree</code> attribute is <code>yes</code>, then a 
            final result tree is created by invoking the process of sequence normalization. Conversely, 
            if the result is serialized, then the decision whether or not to construct a tree depends 
            on the choice of serialization method, and the <code>build-tree</code> attribute is 
            then ignored. For example, with <code>method="xml"</code> a tree is always constructed, 
            whereas with <code>method="json"</code> a tree is never constructed. [XSLT 3.0 Erratum E14, bug 30208].
         </p>
         <note>
            <p>The default for <code>build-tree</code> may differ for user-defined serialization
               methods or for serialization methods introduced in future versions of this
               specification.</p>
         </note>
         <p diff="del" at="A">Unless the processor implements the XPath 3.1 feature, the 
            <code>method</code> values <code>json</code> and
               <code>adaptive</code>
            <rfc2119>must</rfc2119> be rejected as invalid, and the attributes
               <code>allow-duplicate-names</code> and <code>json-node-output-method</code>
            <rfc2119>must</rfc2119> be ignored. The meaning of these output methods and
            serialization parameters is defined in <bibref ref="xslt-xquery-serialization-31"/>.</p>
         <p>If none of the <elcode>xsl:output</elcode> declarations within an <termref def="dt-output-definition">output definition</termref> specifies a value for a
            particular attribute, then the corresponding serialization parameter takes a default
            value. The default value depends on the chosen output method.</p>
         <p>There are some serialization parameters that apply to some output methods but not to
            others. For example, the <code>indent</code> attribute has no effect on the
               <code>text</code> output method. If a value is supplied for an attribute that is
            inapplicable to the output method, its value is not passed to the serializer. The
            processor <rfc2119>may</rfc2119> validate the value of such an attribute, but is not
               <rfc2119>required</rfc2119> to do so.</p>
         <p>An implementation <rfc2119>may</rfc2119> allow the attributes of the
               <elcode>xsl:output</elcode> declaration to be overridden, or the default values to be
            changed, using the API that controls the transformation.</p>
         <p>The location to which <termref def="dt-final-result-tree">final result trees</termref>
            are serialized (whether in filestore or elsewhere) is <termref def="dt-implementation-defined">implementation-defined</termref> (which in practice
               <rfc2119>may</rfc2119> mean that it is controlled using an implementation-defined
            API). However, these locations <rfc2119>must</rfc2119> satisfy the constraint that when
            two <termref def="dt-final-result-tree">final result trees</termref> are both created
            (implicitly or explicitly) using relative URI references in the <code>href</code> attribute of the
               <elcode>xsl:result-document</elcode> instruction, then these relative URI references may be used to construct references from one
            tree to the other, and such references <rfc2119>must</rfc2119> remain valid when both
            result trees are serialized. </p>
         <imp-def-feature id="idf-api-serializationlocation">If serialization is supported, then the
            location to which a <termref def="dt-final-result-tree">final result tree</termref> is
            serialized is implementation-defined, subject to the constraint that relative URI
               references used to reference one tree from another
            remain valid.</imp-def-feature>
         <p>The <code>method</code> attribute on the <elcode>xsl:output</elcode> element identifies
            the overall method that is to be used for outputting the <termref def="dt-final-result-tree">final result tree</termref>.</p>
         <p>
            <error spec="XT" type="static" class="SE" code="1570">
               <p>The value <error.extra>of the <code>method</code> attribute on
                        <elcode>xsl:output</elcode>
                  </error.extra>
                  <rfc2119>must</rfc2119> (if present) be a valid <termref def="dt-eqname">EQName</termref>. If it is a <termref def="dt-lexical-qname">lexical
                     QName</termref> with no a prefix, then it identifies a method specified in
                     <bibref ref="xslt-xquery-serialization-30"/> and <rfc2119>must</rfc2119> be one
                  of <code>xml</code>, <code>html</code>, <code>xhtml</code>, or
                  <code>text</code>.</p>
            </error> If it is a <termref def="dt-lexical-qname">lexical QName</termref> with a
            prefix, then the <termref def="dt-lexical-qname">lexical QName</termref> is expanded
            into an <termref def="dt-expanded-qname">expanded QName</termref> as described in
               <specref ref="qname"/>; the <termref def="dt-expanded-qname">expanded QName</termref>
            identifies the output method; the behavior in this case is not specified by this
            document.</p>
         <p>The default for the <code>method</code> attribute depends on the contents of the tree
            being serialized, and is chosen as follows. If the document node of the <termref def="dt-final-result-tree">final result tree</termref> has an element child, and any
            text nodes preceding the first element child of the document node of the result tree
            contain only whitespace characters, then:</p>
         <ulist>
            <item>
               <p>If the <termref def="dt-expanded-qname">expanded QName</termref> of this first
                  element child has local part <code>html</code> (in lower case), and namespace URI
                     <code>http://www.w3.org/1999/xhtml</code>, then the default output method is
                  normally <code>xhtml</code>. However, if the
                        <termref def="dt-effective-version"/> of the outermost element of the
                        <termref def="dt-principal-stylesheet-module">principal stylesheet
                        module</termref> in the <termref def="dt-top-level-package"/> has the value
                        <code>1.0</code>, and if the result tree is generated implicitly
                  (rather than by an explicit <elcode>xsl:result-document</elcode> instruction),
                  then the default output method in this situation is <code>xml</code>.</p>
            </item>
            <item>
               <p>If the <termref def="dt-expanded-qname">expanded QName</termref> of this first
                  element child has local part <code>html</code> (in any combination of upper and
                  lower case) and a null namespace URI, then the default output method is
                     <code>html</code>.</p>
            </item>
         </ulist>
         <p>In all other cases, the default output method is <code>xml</code>.</p>
         <p>The default output method is used if the selected <termref def="dt-output-definition">output definition</termref> does not include a <code>method</code> attribute.</p>
         <p>The other attributes on <elcode>xsl:output</elcode> provide parameters for the output
            method. The following attributes are allowed:</p>
         <ulist>
            <item>
               <p> The value of the <code>encoding</code> attribute provides the value of the
                     <code>encoding</code> parameter to the serialization method. The default value
                  is <termref def="dt-implementation-defined"/>, but in the case of the
                     <code>xml</code> and <code>xhtml</code> methods it <rfc2119>must</rfc2119> be
                  either <code>UTF-8</code> or <code>UTF-16</code>. </p>
               <imp-def-feature id="idf-defaults-serialization">The default value of the
                     <code>encoding</code> attribute of the <elcode>xsl:output</elcode> element is
                  implementation-defined. Where the encoding is UTF-8, the default for the
                     <code>byte-order-mark</code> attribute is
                  implementation-defined.</imp-def-feature>
            </item>
            <item>
               <p>The <code>byte-order-mark</code> attribute defines whether a byte order mark is
                  written at the start of the file. If the value <code>yes</code> is specified, a
                  byte order mark is written; if <code>no</code> is specified, no byte order mark is
                  written. The default value depends on the encoding used. If the encoding is
                     <code>UTF-16</code>, the default is <code>yes</code>; for <code>UTF-8</code> it
                  is <termref def="dt-implementation-defined"/>, and for all other encodings it is
                     <code>no</code>. The value of the byte order mark indicates whether high order
                  bytes are written before or after low order bytes; the actual byte order used is
                     <termref def="dt-implementation-dependent">implementation-dependent</termref>,
                  unless it is defined by the selected encoding. </p>
            </item>
            <item>
               <p> The <code>cdata-section-elements</code> attribute is a whitespace-separated list
                  of QNames. The default value is an empty list. After expansion of these names
                  using the in-scope namespace declarations for the <elcode>xsl:output</elcode>
                  declaration in which they appear, this list of names provides the value of the
                     <code>cdata-section-elements</code> parameter to the serialization method. In
                  the case of an unprefixed name, the default namespace (that is, the namespace
                  declared using <code>xmlns="uri"</code>) is used. </p>
               <note>
                  <p>This differs from the rule for most other QNames used in a stylesheet. The
                     reason is that these names refer to elements in the result document, and
                     therefore follow the same convention as the name of a literal result element or
                     the <code>name</code> attribute of <elcode>xsl:element</elcode>.</p>
               </note>
            </item>
            <item>
               <p> The value of the <code>doctype-system</code> attribute provides the value of the
                     <code>doctype-system</code> parameter to the serialization method. If the attribute is absent or has a zero-length
                     string as its value, then the serialization parameter is not set (is
                     “absent”).
               </p>

            </item>
            <item>
               <p> The value of the <code>doctype-public</code> attribute provides the value of the
                     <code>doctype-public</code> parameter to the serialization method. If the attribute is absent or has a zero-length
                     string as its value, then the serialization parameter is not set (is
                     “absent”).
               </p>
               <!--Text inserted by erratum E3 change 1"-->
               <p>The value of <code>doctype-public</code> must conform to the rules for a <xnt spec="XML" ref="PubidLiteral">PubidLiteral</xnt> (see <bibref ref="REC-xml"/>).</p>
               <!--End of text inserted by erratum E3-->
            </item>
            <item>
               <p> The value of the <code>escape-uri-attributes</code> attribute provides the value
                  of the <code>escape-uri-attributes</code> parameter to the serialization method.
                  The default value is <code>yes</code>. </p>
            </item>
            <item>
               <p> The value of the <code>html-version</code> attribute provides
                  the value of the <code>html-version</code> parameter to the serialization method.
                  The set of permitted values, and the default value, are <termref def="dt-implementation-defined">implementation-defined</termref>. A <termref def="dt-serialization-error">serialization error</termref> will be reported if
                  the requested version is not supported by the implementation. </p>
               <note>
                  <p>This serialization parameter is new in version 3.0. If it is
                     absent, the html output method uses the value of the <code>version</code>
                     parameter in its place. For XHTML serialization, the <code>html-version</code>
                     parameter indicates the version of XHTML to be used, while the
                        <code>version</code> parameter indicates the version of XML.</p>
               </note>
            </item>
            <item>
               <p> The value of the <code>include-content-type</code> attribute provides the value
                  of the <code>include-content-type</code> parameter to the serialization method.
                  The default value is <code>yes</code>. </p>
            </item>
            <item>
               <p> The value of the <code>indent</code> attribute provides the value of the
                     <code>indent</code> parameter to the serialization method. The default value is
                     <code>yes</code> in the case of the <code>html</code> and <code>xhtml</code>
                  output methods, <code>no</code> in the case of the <code>xml</code> output method.
               </p>
            </item>
            <item>
               <p> The value of the <code>item-separator</code> attribute provides the value of the
                     <code>item-separator</code> parameter to the serialization method. The value of
                  the serialization parameter can be any string (including a zero-length string), or
                  absent. To set the parameter to absent, the <code>item-separator</code> attribute
                  can either be omitted, or set to the special value
                     <code>item-separator="#absent"</code>; it is not possible to set the value of
                  the serialization parameter to the literal 7-character string <code>"#absent"</code>. </p>
               <note>
                  <p>The <code>item-separator</code> attribute has no
                     effect if the sequence being serialized contains only one item<phrase diff="del" at="A">, which will
                     always be the case if the effective value of <code>build-tree</code> is
                        <code>yes</code></phrase>. <phrase diff="add" at="A">[XSLT 3.0 Erratum E14, bug 30208].</phrase></p>
               </note>
            </item>
            <item>
               <p> The value of the <code>media-type</code> attribute provides the value of the
                     <code>media-type</code> parameter to the serialization method. The default
                  value is <code>text/xml</code> in the case of the <code>xml</code> output method,
                     <code>text/html</code> in the case of the <code>html</code> and
                     <code>xhtml</code> output methods, and <code>text/plain</code> in the case of
                  the <code>text</code> output method. <phrase diff="add" at="A">The default for 
                     the <code>json</code> output method is <code>application/json</code>; the default 
                     for the adaptive output method is <termref def="dt-implementation-defined"/>.
                  [XSLT 3.0 Erratum E26, bug 30245].</phrase></p>
            </item>
            <item>
               <p> The value of the <code>normalization-form</code> attribute provides the value of
                  the <code>normalization-form</code> parameter to the serialization method. A value
                  that is an <code>NMTOKEN</code> other than one of those enumerated for the
                     <code>normalization-form</code> attribute specifies an implementation-defined
                  normalization form; the behavior in this case is not specified by this document.
                  The default value is <code>none</code>. </p>
            </item>
            <item>
               <p> The value of the <code>omit-xml-declaration</code> attribute provides the value
                  of the <code>omit-xml-declaration</code> parameter to the serialization method.
                  The default value is <code>no</code>. </p>
            </item>
            <item>
               <p> The value of the <code>standalone</code> attribute provides the value of the
                     <code>standalone</code> parameter to the serialization method. The default
                  value is <code>omit</code>; this means that no <code>standalone</code> attribute
                  is to be included in the XML declaration. </p>
            </item>
            <item>
               <p> The <code>suppress-indentation</code> attribute is a whitespace-separated list of
                  QNames. The default value is an empty list. After expansion of these names using
                  the in-scope namespace declarations for the <elcode>xsl:output</elcode>
                  declaration in which they appear, this list of names provides the value of the
                     <code>suppress-indentation</code> parameter to the serialization method. In the
                  case of an unprefixed name, the default namespace (that is, the namespace declared
                  using <code>xmlns="uri"</code>) is used. </p>
               <note>
                  <p>This differs from the rule for most other QNames used in a stylesheet. The
                     reason is that these names refer to elements in the result document, and
                     therefore follow the same convention as the name of a literal result element or
                     the <code>name</code> attribute of <elcode>xsl:element</elcode>.</p>
               </note>
            </item>
            <item>
               <p> The value of the <code>undeclare-prefixes</code> attribute provides the value of the
                  <code>undeclare-prefixes</code> parameter to the serialization method. The default
                  value is <code>no</code>.</p>
            </item>
            <item>
               <p>The <code>use-character-maps</code> attribute provides a list of named character
                  maps that are used in conjunction with this <termref def="dt-output-definition">output definition</termref>. The way this attribute is used is described in
                     <specref ref="character-maps"/>. The default value is an empty list.</p>
            </item>
            <item>
               <p> The value of the <code>version</code> attribute provides the value of the
                     <code>version</code> parameter to the serialization method. The set of
                  permitted values, and the default value, are <termref def="dt-implementation-defined">implementation-defined</termref>. A <termref def="dt-serialization-error">serialization error</termref> will be reported if
                  the requested version is not supported by the implementation.
                  <!--The default value depends on the output method: it is <code>1.0</code> for <code>xml</code>,
						<code>4.01</code> for <code>html</code>, and <code>1.0</code> for <code>xhtml</code>. The 
						parameter is not used by the text output method.-->
               </p>
            </item>
         </ulist>
         
         <imp-def-feature id="idf-spec-serversions">It is implementation-defined which versions of
            XML, HTML, and XHTML are supported in the <code>version</code> attribute of the
               <elcode>xsl:output</elcode> declaration.</imp-def-feature>

         <p>If the processor performs serialization, then it must signal any  serialization errors that occur. These have the same
            effect as <termref def="dt-dynamic-error"> dynamic errors</termref>: that is, the processor must
            signal the error and must not finish as if the transformation had been successful.</p>
         <div2 id="character-maps">
            <head>Character Maps</head>
            <p>
               <termdef id="dt-character-map" term="character map">A <term>character map</term>
                  allows a specific character appearing in a text or attribute node in the <termref def="dt-final-result-tree">final result tree</termref> to be substituted by a
                  specified string of characters during serialization.</termdef> The effect of
               character maps is defined in <bibref ref="xslt-xquery-serialization-30"/>.</p>
            <p>The character map that is supplied as a parameter to the serializer is determined
               from the <elcode>xsl:character-map</elcode> elements referenced from the
                  <elcode>xsl:output</elcode> declaration for the selected <termref def="dt-output-definition">output definition</termref>.</p>
            <p>The <elcode>xsl:character-map</elcode> element is a declaration that may appear as a
               child of the <elcode>xsl:stylesheet</elcode> element.</p>
            <?element xsl:character-map?>
            <p>The <elcode>xsl:character-map</elcode> declaration declares a character map with a
               name and a set of character mappings. The character mappings are specified by means
               of <elcode>xsl:output-character</elcode> elements contained either directly within
               the <elcode>xsl:character-map</elcode> element, or in further character maps
               referenced in the <code>use-character-maps</code> attribute.</p>
            <p>The <rfc2119>required</rfc2119>
               <code>name</code> attribute provides a name for the character map. When a character
               map is used by an <termref def="dt-output-definition">output definition</termref> or
               another character map, the character map with the highest <termref def="dt-import-precedence">import precedence</termref> is used.</p>
            <p>The name of a character map is local to the <termref def="dt-package">package</termref> in which its declaration appears; it may be
               referenced only from within the same package.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1580">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a <termref def="dt-package">package</termref> contains two
                     or more character maps with the same name and the same <termref def="dt-import-precedence">import precedence</termref>, unless it also
                     contains another character map with the same name and higher import
                     precedence.</p>
               </error>
            </p>
            <p>The optional <code>use-character-maps</code> attribute lists the names of further
               character maps that are included into this character map.</p>
            <p>
               <error spec="XT" type="static" class="SE" code="1590">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a name in the
                        <code>use-character-maps</code> attribute of the <elcode>xsl:output</elcode>
                     or <elcode>xsl:character-map</elcode> elements does not match the
                        <code>name</code> attribute of any <elcode>xsl:character-map</elcode> in the
                        containing <termref def="dt-package">package</termref>.</p>
               </error>
            </p>
            <p>
               <error spec="XT" type="static" class="SE" code="1600">
                  <p>It is a <termref def="dt-static-error">static error</termref> if a character
                     map references itself, directly or indirectly, via a name in the
                        <code>use-character-maps</code> attribute.</p>
               </error>
            </p>
            <p>It is not an error if the same character map is referenced more than once, directly
               or indirectly.</p>
            <p>An <termref def="dt-output-definition">output definition</termref>, after recursive
               expansion of character maps referenced via its <code>use-character-maps</code>
               attribute, may contain several mappings for the same character. In this situation,
               the last character mapping takes precedence. To establish the ordering, the following
               rules are used:</p>
            <ulist>
               <item>
                  <p>Within a single <elcode>xsl:character-map</elcode> element, the characters
                     defined in character maps referenced in the <code>use-character-maps</code>
                     attribute are considered before the characters defined in the child
                        <elcode>xsl:output-character</elcode> elements.</p>
               </item>
               <item>
                  <p>The character maps referenced in a single <code>use-character-maps</code>
                     attribute are considered in the order in which they are listed in that
                     attribute. The expansion is depth-first: each referenced character map is fully
                     expanded before the next one is considered.</p>
               </item>
               <item>
                  <p>Two <elcode>xsl:output-character</elcode> elements appearing as children of the
                     same <elcode>xsl:character-map</elcode> element are considered in document
                     order.</p>
               </item>
            </ulist>
            <p>The <elcode>xsl:output-character</elcode> element is defined as follows:</p>
            <?element xsl:output-character?>
            <p>The character map that is passed as a parameter to the serializer contains a mapping
               for the character specified in the <code>character</code> attribute to the string
               specified in the <code>string</code> attribute. </p>
            <p>Character mapping is not applied to characters for which output escaping has been
               disabled as described in <specref ref="disable-output-escaping"/>.</p>
            <p>If a character is mapped, then it is not subjected to XML or HTML escaping.</p>
            <example>
               <head>Using Character Maps to Generate Non-XML Output</head>
               <p>Character maps can be useful when producing serialized output in a format that
                  resembles, but is not strictly conformant to, HTML or XML. For example, when the
                  output is a JSP page, there might be a need to generate the output:</p>
               <eg role="non-xml" xml:space="preserve">&lt;jsp:setProperty name="user" property="id" value='&lt;%= "id" + idValue %&gt;'/&gt;</eg>
               <p>Although this output is not well-formed XML or HTML, it is valid in Java Server
                  Pages. This can be achieved by allocating three Unicode characters (which are not
                  needed for any other purpose) to represent the strings <code>&lt;%</code>,
                     <code>%&gt;</code>, and <code>"</code>, for example:</p>
               <eg role="xslt-declaration" xml:space="preserve">&lt;xsl:character-map name="jsp"&gt;
  &lt;xsl:output-character character="«" string="&amp;lt;%"/&gt;   
  &lt;xsl:output-character character="»" string="%&amp;gt;"/&gt;
  &lt;xsl:output-character character="§" string='"'/&gt;
&lt;/xsl:character-map&gt;</eg>
               <p>When this character map is referenced in the <elcode>xsl:output</elcode>
                  declaration, the required output can be produced by writing the following in the
                  stylesheet:</p>
               <eg role="non-xml" xml:space="preserve">&lt;jsp:setProperty name="user" property="id" value='«= §id§ + idValue »'/&gt;</eg>
               <p>This works on the assumption that when an apostrophe or quotation mark is
                  generated as part of an attribute value by the use of character maps, the
                  serializer will (where possible) use the other choice of delimiter around the
                  attribute value.</p>
            </example>
            <example>
               <head>Constructing a Composite Character Map</head>
               <p>The following example illustrates a composite character map constructed in a
                  modular fashion:</p>
               <eg role="xslt-declarations" xml:space="preserve">
&lt;xsl:output name="htmlDoc" use-character-maps="htmlDoc" /&gt;

&lt;xsl:character-map name="htmlDoc"
  use-character-maps="html-chars doc-entities windows-format" /&gt;
  
&lt;xsl:character-map name="html-chars"
  use-character-maps="latin1 ..." /&gt;

&lt;xsl:character-map name="latin1"&gt;
  &lt;xsl:output-character character="&amp;#160;" string="&amp;amp;nbsp;" /&gt;
  &lt;xsl:output-character character="&amp;#161;" string="&amp;amp;iexcl;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="doc-entities"&gt;
  &lt;xsl:output-character character="&amp;#xE400;" string="&amp;amp;t-and-c;" /&gt;
  &lt;xsl:output-character character="&amp;#xE401;" string="&amp;amp;chap1;" /&gt;
  &lt;xsl:output-character character="&amp;#xE402;" string="&amp;amp;chap2;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="windows-format"&gt;
  &lt;!-- newlines as CRLF --&gt;
  &lt;xsl:output-character character="&amp;#xA;" string="&amp;#xD;&amp;#xA;" /&gt;

  &lt;!-- tabs as three spaces --&gt;
  &lt;xsl:output-character character="&amp;#x9;" string="   " /&gt;

  &lt;!-- images for special characters --&gt;
  &lt;xsl:output-character character="&amp;#xF001;"
    string="&amp;lt;img src='special1.gif' /&amp;gt;" /&gt;
  &lt;xsl:output-character character="&amp;#xF002;"
    string="&amp;lt;img src='special2.gif' /&amp;gt;" /&gt;
  ...
&lt;/xsl:character-map&gt;</eg>
            </example>
            <note>
               <p>When character maps are used, there is no guarantee that the serialized output
                  will be well-formed XML (or HTML). Furthermore, the fact that the result tree was
                  validated against a schema gives no guarantee that the serialized output will
                  still be valid against the same schema. Conversely, it is possible to use
                  character maps to produce schema-valid output from a result tree that would fail
                  validation.</p>
            </note>
         </div2>
         <div2 id="disable-output-escaping">
            <head>Disabling Output Escaping</head>
            <p>Normally, when using the XML, HTML, or XHTML output method, the serializer will
               escape special characters such as <code>&amp;</code> and <code>&lt;</code> when
               outputting text nodes. This ensures that the output is well-formed. However, it is
               sometimes convenient to be able to produce output that is almost, but not quite
               well-formed XML; for example, the output may include ill-formed sections which are
               intended to be transformed into well-formed XML by a subsequent non-XML-aware
               process. For this reason, XSLT defines a mechanism for disabling output escaping.</p>
            <p>This feature is <termref def="dt-deprecated">deprecated</termref>.</p>
            <p>This is an optional feature: it is not <rfc2119>required</rfc2119> that an XSLT
               processor that implements the serialization option <rfc2119>should</rfc2119> offer
               the ability to disable output escaping, and there is no conformance level that
               requires this feature.</p>
            <p>This feature requires the serializer (described in <bibref ref="xslt-xquery-serialization-30"/>) 
               to be extended as follows. Conceptually, the <termref def="dt-final-result-tree">final result tree</termref> provides an additional
               boolean property <code>disable-escaping</code> associated with every character in a
               text node. When this property is set, the normal action of the serializer to escape
               special characters such as <code>&amp;</code> and <code>&lt;</code> is
               suppressed.</p>
            <p>An <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> element may have a
                  <code>disable-output-escaping</code> attribute; the allowed values are
                  <code>yes</code> or <code>no</code>. The default is <code>no</code>; if the value
               is <code>yes</code>, then every character in the text node generated by evaluating
               the <elcode>xsl:value-of</elcode> or <elcode>xsl:text</elcode> element
                  <rfc2119>should</rfc2119> have the <code>disable-escaping</code> property set.</p>
            <example>
               <head>Disable Output Escaping</head>
               <p>For example,</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;</eg>
               <p>should generate the single character <code>&lt;</code>.</p>
            </example>
            <p>If output escaping is disabled for an <elcode>xsl:value-of</elcode> or
                  <elcode>xsl:text</elcode> instruction evaluated when <termref def="dt-temporary-output-state">temporary output state</termref> is in effect, the
               request to disable output escaping is ignored.</p>
            <p>Similarly, if an <elcode>xsl:value-of</elcode> or
                  <elcode>xsl:text</elcode> instruction specifies that output escaping is to be
               disabled when writing to a <termref def="dt-final-result-tree">final result
                  tree</termref> that is not being serialized, the request to disable output
               escaping is ignored.</p>
            <note>
               <p>Furthermore, a request to disable output escaping has no effect when the newly
               constructed text node is used to form the value of an attribute, comment, processing instruction,
               or namespace node. This is because the rules for constructing such nodes (see <specref ref="constructing-simple-content"/>)
               cause the text node to be atomized, and the process of atomizing a text node takes no
               account of the disable-escaping property.</p>
            </note>
            <p>If output escaping is disabled for text within an element that would normally be
               output using a CDATA section, because the element is listed in the
                  <code>cdata-section-elements</code>, then the relevant text will not be included
               in a CDATA section. In effect, CDATA is treated as an alternative escaping mechanism,
               which is disabled by the <code>disable-output-escaping</code> option.</p>
            <example>
               <head>Interaction of Output Escaping and CDATA</head>
               <p>For example, if <code>&lt;xsl:output cdata-section-elements="title"/&gt;</code> is
                  specified, then the following instructions:</p>
               <eg role="xslt-instruction" xml:space="preserve">&lt;title&gt;
  &lt;xsl:text disable-output-escaping="yes"&gt;This is not &amp;lt;hr/&amp;gt; 
                                          good coding practice&lt;/xsl:text&gt;
&lt;/title&gt;</eg>
               <p>should generate the output:</p>
               <eg role="xml" xml:space="preserve">&lt;title&gt;&lt;![CDATA[This is not ]]&gt;&lt;hr/&gt;&lt;![CDATA[ good coding practice]]&gt;&lt;/title&gt;</eg>
            </example>
            <p>The <code>disable-output-escaping</code> attribute may be used with the
                  <code>html</code> output method as well as with the <code>xml</code> output
               method. The <code>text</code> output method ignores the
                  <code>disable-output-escaping</code> attribute, since this method does not perform
               any output escaping.</p>
            <p>A <termref def="dt-processor">processor</termref> will only be able to disable output
               escaping if it controls how the <termref def="dt-final-result-tree">final result
                  tree</termref> is output. This might not always be the case. For example, the
               result tree might be used as a <termref def="dt-source-tree">source tree</termref>
               for another XSLT transformation instead of being output. It is <termref def="dt-implementation-defined">implementation-defined</termref> whether (and
               under what circumstances) disabling output escaping is supported. If disabling output escaping is not supported, any request to disable
                  output escaping is ignored.</p>
            

            
            <imp-def-feature id="idf-feature-doe">It is implementation-defined whether, and under
               what circumstances, disabling output escaping is supported.</imp-def-feature>
            <p>If output escaping is disabled for a character that is not representable in the
               encoding that the <termref def="dt-processor">processor</termref> is using for
               output, the request to disable output escaping is ignored in respect of that
               character.</p>
            <p>Since disabling output escaping might not work with all implementations and can
               result in XML that is not well-formed, it <rfc2119>should</rfc2119> be used only when
               there is no alternative.</p>
            <note>
               <p>When disable-output-escaping is used, there is no guarantee that the serialized
                  output will be well-formed XML (or HTML). Furthermore, the fact that the result
                  tree was validated against a schema gives no guarantee that the serialized output
                  will still be valid against the same schema. Conversely, it is possible to use
                  disable-output-escaping to produce schema-valid output from a result tree that
                  would fail validation.</p>
            </note>
            <note>
               <p>The facility to define character maps for use during serialization, as described
                  in <specref ref="character-maps"/>, has been produced as an alternative mechanism
                  that can be used in many situations where disabling of output escaping was
                  previously necessary, without the same difficulties.</p>
            </note>
         </div2>
      </div1>
      <div1 id="conformance">
         <head>Conformance</head>
         <p>A <termref def="dt-processor">processor</termref> that claims
            conformance with this specification <rfc2119>must</rfc2119> satisfy the conformance
            requirements for a <termref def="dt-basic-xslt-processor">basic XSLT processor</termref>
            and for each of the optional features with which it claims conformance.</p>
         <p>The following optional features are defined:</p>
         <olist>
            <item>
               <p>The schema-awareness feature, defined in <specref ref="schema-aware-conformance"/></p>
            </item>
            <item>
               <p>The serialization feature, defined in <specref ref="serialization-feature"/></p>
            </item>
            <item>
               <p>The backwards compatibility feature, defined in <specref ref="backwards-compatibility-feature"/></p>
            </item>
            <item>
               <p>The streaming feature, defined in <specref ref="streaming-feature"/>.</p>
            </item>
            <item>
               <p>The dynamic evaluation feature, defined in <specref ref="dynamic-evaluation-feature"/>.</p>
            </item>
            <item>
               <p>The higher-order functions feature, defined in
               <specref ref="hof-feature"/>.</p>
            </item>
            <item diff="del" at="A">
               <p>The XPath 3.1 feature, defined in ... .</p>
            </item>
            
         </olist>

         <p>A processor that does not claim conformance with an optional feature
               <rfc2119>must</rfc2119> satisfy the requirements for processors that do not implement
            that feature.</p>

         <note>
            <p>There is no conformance level or feature defined in this specification that requires
               implementation of the static typing features described in <bibref ref="xpath-30"/>.
               An XSLT processor may provide a user option to invoke static typing, but to be
               conformant with this specification it must allow a stylesheet to be processed with
               static typing disabled. The interaction of XSLT stylesheets with the static typing
               feature of XPath 3.0 has not been specified, so
               the results of using static typing, if available, are implementation-defined.</p>
         </note>
         <p>An XSLT processor takes as its inputs a stylesheet and zero or more XDM trees conforming to the data model defined in <bibref ref="xpath-datamodel-30"/>. It is not <rfc2119>required</rfc2119> that the processor
            supports any particular method of constructing XDM trees, but conformance can only be
            tested if it provides a mechanism that enables XDM trees representing the stylesheet and
            primary source document to be constructed and supplied as input to the processor.</p>
         <p>The output of the XSLT processor consists of zero or more <termref def="dt-final-result-tree">final result trees</termref>. It is not
               <rfc2119>required</rfc2119> that the processor supports any particular method of
            accessing a final result tree, but if it does not support the serialization feature, conformance can only be tested if it provides
            some alternative mechanism that enables access to the results of the transformation.</p>
         <p>Certain facilities in this specification are described as producing <termref def="dt-implementation-defined">implementation-defined</termref> results. A claim
            that asserts conformance with this specification <rfc2119>must</rfc2119> be accompanied
            by documentation stating the effect of each implementation-defined feature. For
            convenience, a non-normative checklist of implementation-defined features is provided at
               <specref ref="implementation-defined-features"/>.</p>
         <p>A conforming <termref def="dt-processor">processor</termref>
            <rfc2119>must</rfc2119> signal any <termref def="dt-static-error">static error</termref>
            occurring in the stylesheet, or in any XPath <termref def="dt-expression">expression</termref>, except where specified otherwise either for individual error
            conditions or under the general provisions for <termref def="dt-forwards-compatible-behavior"/> (see <specref ref="forwards"/>). After
            signaling such an error, the processor <rfc2119>may</rfc2119> continue for the purpose
            of signaling additional errors, but <rfc2119>must</rfc2119> terminate abnormally without
            performing any transformation.</p>
         <p>When a <termref def="dt-dynamic-error">dynamic error</termref> occurs during the course
            of a transformation, and is not caught using
                  <elcode>xsl:catch</elcode>,
             the processor
               <rfc2119>must</rfc2119> signal it and <rfc2119>must</rfc2119> eventually terminate
            abnormally. </p>
         <p>Some errors, notably <termref def="dt-type-error">type errors</termref>,
               <rfc2119>may</rfc2119> be treated as <termref def="dt-static-error">static
               errors</termref> or <termref def="dt-dynamic-error">dynamic errors</termref> at the
            discretion of the processor.</p>
         <p>A conforming processor <rfc2119>may</rfc2119> impose limits on the processing resources
            consumed by the processing of a stylesheet.</p>

         <p>The mandatory requirements of this specification are taken to
            include the mandatory requirements of <bibref ref="xpath-30"/>, <bibref ref="xpath-datamodel-30"/>, and <bibref ref="xpath-functions-40"/>. An XSLT 3.0
            processor <rfc2119>must</rfc2119> provide a mode of operation which conforms to the 3.0
            versions of those specifications as extended by <specref ref="map"/> and <specref ref="json"/>.</p>

         <p diff="del" at="A">A processor <rfc2119>may</rfc2119> also provide a mode of
            operation which conforms to the 3.1 versions of those specifications; in this case it
            must do so as described in XPath 3.1 feature.</p>

         <p>A processor <rfc2119>may</rfc2119> also provide a mode of
            operation which conforms to versions of those specifications later than the 3.1
            versions; in such cases the detail of how XSLT 3.0 interacts with new features
            introduced by such later versions (for example, extensions to the data model) is
               <termref def="dt-implementation-defined"/>.</p>

         <imp-def-feature id="idf-spec-xpath">It is <termref def="dt-implementation-defined"/>
            whether (and if so how) an XSLT 3.0 processor is able to work with versions of XPath
            later than XPath 3.1.</imp-def-feature>



         <p>A requirement is mandatory unless the specification includes wording (such as the use of
            the words <rfc2119>should</rfc2119> or <rfc2119>may</rfc2119>) that clearly indicates
            that it is optional.</p>
         
         <p>Some of the optional features are defined in such a way that
         if the feature is not provided, the data model is constrained to exclude certain kinds of
         item. For example:</p>
         
         <ulist>
            <item><p>A processor that does not provide the <termref def="dt-schema-aware-xslt-processor">schema-awareness</termref>
            feature restricts the data model so that it does not contain atomic values of types other than the built-in types,
            or nodes with non-trivial type annotations.</p></item>
            <item><p>A processor that does not provide the <termref def="dt-hof-feature"/> constrains the data model so that
            it does not contain function items other than maps or arrays.</p></item>
            <item diff="del" at="A"><p>A processor that does not provide the XPath 3.1 feature constrains the data model so that
               it does not contain arrays.</p></item>
         </ulist>
         
         <p><error spec="XT" type="dynamic" class="DE" code="1665">
            <p>A <termref def="dt-dynamic-error"/> <rfc2119>may</rfc2119> be raised if the
               input to the processor includes an item that requires availability
               of an optional feature that the processor does not provide.</p></error></p>
         
         <note><p>It is not necessarily possible to trigger this error. A processor that does
         not provide an optional feature might not define or recognize any representation of the items
         that are disallowed. The error code is provided for use in cases where a processor is able
         to interoperate with other software that does not have the same constraints — for example,
         where a package compiled with a non-schema-aware processor is able to invoke functions in a package
         that was compiled with a schema-aware processor. Even in that case,
         processors have the option of filtering or converting the input so that it meets the relevant
         constraints: for example, a non-schema-aware processor when presented with a schema-validated
         document in the form of a PSVI might simply ignore the properties it does not understand.</p>
            
            <p>The dynamic error is optional: for example a processor might report no error
            if the offending item is not actually used.</p>
         
            <p>The phrase <emph>input to the processor</emph> is deliberately wide: it includes (inter alia)
               the <termref def="dt-global-context-item"/>, items present in the <termref def="dt-initial-match-selection"/>, items passed as <termref def="dt-stylesheet-parameter">stylesheet parameters</termref>, items returned by functions such as 
                <function>document</function>, <xfunction>doc</xfunction>, and
               <xfunction>collection</xfunction>, items returned by <termref def="dt-extension-function">extension functions</termref> and <termref def="dt-extension-instruction">extension instructions</termref>,
            items supplied in function or template parameters or results across package boundaries, and nodes
            reachable from any of the above by axis navigation.</p></note>


         <div2 id="basic-conformance">
            <head>Basic XSLT Processor</head>
            <p>
               <termdef id="dt-basic-xslt-processor" term="basic XSLT processor">A <term>basic XSLT
                     processor</term> is an XSLT processor that implements all the mandatory
                  requirements of this specification with the exception of constructs explicitly
                  associated with an optional feature.</termdef> These constructs are listed
               below.</p>

            <!--<p>A <termref def="dt-basic-xslt-processor">basic XSLT processor</termref> 
               <rfc2119>must</rfc2119> enforce the following restrictions. It
                  <rfc2119>must</rfc2119> signal a static or dynamic error when the restriction is
               violated, as described below.</p>-->

         </div2>
         <div2 id="schema-aware-conformance">
            <head>Schema-Awareness Conformance Feature</head>

            <p>A conformant processor <rfc2119>must</rfc2119> either be a conformant <termref def="dt-schema-aware-xslt-processor"/> or a conformant <termref def="dt-non-schema-aware-processor"/>.</p>
            <p>
               <termdef id="dt-schema-aware-xslt-processor" term="schema-aware XSLT processor">A
                     <term>schema-aware XSLT processor</term> is an XSLT processor that implements
                  the mandatory requirements of this specification connected with the
                     <elcode>xsl:import-schema</elcode> declaration, the
                     <code>[xsl:]validation</code> and <code>[xsl:]type attributes</code>, and the
                  ability to handle input documents whose nodes have type annotations other than
                     <code>xs:untyped</code> and <code>xs:untypedAtomic</code>. The mandatory
                  requirements of this specification are taken to include the mandatory requirements
                  of XPath 3.0, as described in <bibref ref="xpath-30"/>. A requirement is mandatory unless the specification includes
                  wording (such as the use of the words <rfc2119>should</rfc2119> or
                     <rfc2119>may</rfc2119>) that clearly indicates that it is optional.</termdef>
            </p>

            <p><termdef id="dt-non-schema-aware-processor" term="non-schema-aware processor">A <term>non-schema-aware processor</term> is a
                  processor that does not claim conformance with the schema-aware conformance
                  feature. Such a processor <rfc2119>must</rfc2119> handle constructs associated
                  with schema-aware processing as described in this section.</termdef></p>


            <p>
               <error spec="XT" type="static" class="SE" code="1650">
                  <p>A <termref def="dt-non-schema-aware-processor">non-schema-aware
                        processor</termref>
                     <rfc2119>must</rfc2119> signal a <termref def="dt-static-error">static
                        error</termref> if a <termref def="dt-package">package</termref> includes an
                        <elcode>xsl:import-schema</elcode> declaration.</p>
               </error>
            </p>
            <note>
               <p>A processor that rejects an <elcode>xsl:import-schema</elcode> declaration will
                  also reject any reference to a user-defined type defined in a schema, or to a
                  user-defined element or attribute declaration; it will not, however, reject
                  references to the built-in types listed in <specref ref="built-in-types"/>.</p>
            </note>
            <p>A <termref def="dt-non-schema-aware-processor">non-schema-aware
                  processor</termref> is not able to validate input documents, and is not able to
               handle input documents containing type annotations other than <code>xs:untyped</code>
               or <code>xs:untypedAtomic</code>. Therefore, such a processor <rfc2119>must</rfc2119>
               treat any <code>[xsl:]validation</code> attribute
                  with a value of <code>preserve</code> or <code>lax</code>, or a
                     <code>[xsl:]default-validation</code> attribute with a value of
                     <code>preserve</code> as if the value were <code>strip</code>.</p>

            <note>
               <p>The values <code>lax</code> and <code>preserve</code> indicate that the validation
                  to be applied depends on the calling application, so it is appropriate for the
                  request to be treated differently by different kinds of processor. By contrast,
                  requesting <code>strict</code> validation, either through the
                     <code>[xsl:]validation</code> attribute or the <code>type</code> attribute,
                  indicates that the stylesheet is expecting to deal with typed data, and therefore
                  cannot be processed without performing the validation.</p>
            </note>
            <p>
               <error spec="XT" type="static" class="SE" code="1660">
                  <p>A <termref def="dt-non-schema-aware-processor">non-schema-aware
                        processor</termref>
                     <rfc2119>must</rfc2119> signal a <termref def="dt-static-error">static
                        error</termref> if a <termref def="dt-package">package</termref> includes an
                        <code>[xsl:]type</code> attribute; or an <code>[xsl:]validation</code> or
                        <code>[xsl:]default-validation</code> attribute with a value other than
                        <code>strip</code>, <code>preserve</code>, or
                           <code>lax</code>; or an
                           <elcode>xsl:mode</elcode> element whose <code>typed</code> attribute is
                        equal to <code>yes</code> or <code>strict</code>; or an <code>as</code>
                              attribute whose value is a 
                              <termref def="dt-sequence-type"/> that can only match
                        nodes with a type annotation other than <code>xs:untyped</code> or
                           <code>xs:untypedAtomic</code> (for example, <code>as="element(*,
                           xs:integer)"</code>).</p>
               </error>
            </p>
            <p>A <termref def="dt-non-schema-aware-processor">non-schema-aware processor</termref>
               constrains the data model as follows, and raises a <termref def="dt-dynamic-error"/> (<errorref spec="XT" class="DE" code="1665"/>) if the
                  constraints are not satisfied:</p>
            <ulist>
               <item>
                  <p>Atomic values <rfc2119>must</rfc2119> belong to one of the atomic types listed
                     in <specref ref="built-in-types"/> (except as noted below).</p>
                  <p>An atomic value may also belong to an implementation-defined type that has been
                     added to the context for use with <termref def="dt-extension-function">extension functions</termref> or <termref def="dt-extension-instruction">extension instructions</termref>.</p>
                  <p>The set of constructor functions available are limited to those that construct
                     values of the above atomic types.</p>
                  <p>The static context, which defines the full set of type names recognized by an
                     XSLT processor and also by the XPath processor, includes these atomic types,
                     plus <code>xs:anyType</code>, <code>xs:anySimpleType</code>,
                        <code>xs:untyped</code>, and <code>xs:anyAtomicType</code>.</p>
               </item>
               <item>
                  <p>Element nodes <rfc2119>must</rfc2119> be annotated with the <termref def="dt-type-annotation">type annotation</termref>
                     <code>xs:untyped</code>, and attribute nodes with the type annotation
                        <code>xs:untypedAtomic</code>.</p>
               </item>
            </ulist>
            

         </div2>
         <div2 id="serialization-feature">
            <head>Serialization Feature</head>
            <p>
               <termdef id="dt-serialization-feature" term="serialization feature">A processor that
                  claims conformance with the <term>serialization feature</term>
                  <rfc2119>must</rfc2119> support the conversion of a <termref def="dt-final-result-tree">final result tree</termref> to a sequence of octets
                  following the rules defined in <specref ref="serialization"/>.</termdef> It
                  <rfc2119>must</rfc2119> respect all the attributes of the
                  <elcode>xsl:output</elcode> and <elcode>xsl:character-map</elcode> declarations,
               and <rfc2119>must</rfc2119> provide all four output methods, <code>xml</code>,
                  <code>xhtml</code>, <code>html</code>, and <code>text</code>. Where the
               specification uses words such as <rfc2119>must</rfc2119> and
                  <rfc2119>required</rfc2119>, then it <rfc2119>must</rfc2119> serialize the result
               tree in precisely the way described; in other cases it <rfc2119>may</rfc2119> use an
               alternative, equivalent representation.</p>
            <p>A processor may claim conformance with the serialization feature whether or not it
               supports the setting <code>disable-output-escaping="yes"</code> on
                  <elcode>xsl:text</elcode>, or <elcode>xsl:value-of</elcode>. </p>
            <p>A processor that does not claim conformance with the serialization feature
                  <rfc2119>must not</rfc2119> signal an error merely because the <termref def="dt-stylesheet">stylesheet</termref> contains <elcode>xsl:output</elcode> or
                  <elcode>xsl:character-map</elcode> declarations, or serialization attributes on
               the <elcode>xsl:result-document</elcode> instruction. Such a processor
                  <rfc2119>may</rfc2119> check that these declarations and attributes have valid
               values, but is not <rfc2119>required</rfc2119> to do so. Apart from optional
               validation, these declarations <rfc2119>should</rfc2119> be ignored.</p>
            
            <note>
               <p>A processor that does not claim conformance with the serialization feature
               <rfc2119>may</rfc2119> offer alternative serialization capabilities, and these
               <rfc2119>may</rfc2119> make use of the serialization parameters defined on
               <elcode>xsl:output</elcode> and/or <elcode>xsl:result-document</elcode>.
                  <phrase diff="add" at="A">Such a processor <rfc2119>may</rfc2119> implement 
                     selected parts of the serialization capabilities defined in this specification. 
                     For example, it may implement selected output methods, or selected serialization 
                     properties. It may implement sequence normalization using the <code>item-separator</code> 
                     property even if it has no other serialization capabilities. [XSLT 3.0 Erratum E14, bug 30208].</phrase></p>
            </note>
            
            <p>If the processor claims conformance with 
               the serialization feature then it <rfc2119>must</rfc2119> fully implement the 
               <xfunction>serialize</xfunction> function defined in <phrase diff="chg" at="A"><bibref ref="xpath-functions-40"/></phrase>,
               and <rfc2119>must not</rfc2119>
               raise error <xerrorref spec="FO40" code="0010" class="DC"/> as the result of such a call.</p>
            
            <p>If the processor does not claim conformance with
               the serialization feature, then it <rfc2119>may</rfc2119> raise 
               error <xerrorref spec="FO40" code="0010" class="DC"/> in respect of some or
               all calls on the <xfunction>serialize</xfunction> function; it <rfc2119>must not</rfc2119>
               return a result from a call on this function unless the result is conformant with
               the specification, given the parameters actually supplied. 
            </p>

            <p>A processor that claims conformance with the Serialization
               Feature must satisfy the mandatory requirements of <bibref ref="xslt-xquery-serialization-30"/>. It <rfc2119>must</rfc2119> provide a mode of
               operation which conforms to the 3.0 version of that specification. It
                  <rfc2119>may</rfc2119> also provide a mode of operation which conforms to a later
               version of that specification; in such cases the detail of how XSLT 3.0 interacts
               with new features introduced by such a version (for example, support for new
               serialization properties) is <termref def="dt-implementation-defined"/>.</p>

            <imp-def-feature id="idf-spec-serialization">It is <termref def="dt-implementation-defined"/> whether (and if so how) an XSLT 3.0 processor is
               able to work with versions of <bibref ref="xslt-xquery-serialization-30"/> later than
               3.1.</imp-def-feature>
         </div2>
         <div2 id="backwards-compatibility-feature">
            <head>Compatibility Features</head>
            <p>
               <termdef id="dt-1.0-compatibility-feature" term="XSLT 1.0 compatibility feature">A
                  processor that claims conformance with the <term>XSLT 1.0 compatibility
                     feature</term>
                  <rfc2119>must</rfc2119> support the processing of stylesheet instructions and
                  XPath expressions with <termref def="dt-xslt-10-behavior">XSLT
                     1.0 behavior</termref>, as defined in <specref ref="backwards"/>.</termdef>
            </p>
            
            <p>Note that a processor that does not claim conformance with the <termref def="dt-1.0-compatibility-feature"/>
               <rfc2119>must</rfc2119> raise a <termref def="dt-dynamic-error"> dynamic error</termref> if an instruction is
               evaluated whose <termref def="dt-effective-version"/> is 1.0. <errorref spec="XT" class="DE" code="0160"/>.</p>
            <note>
               <p>The reason this is a dynamic error rather than a static error is to allow
                  stylesheets to contain conditional logic, following different paths depending on
                  whether the XSLT processor implements XSLT 1.0, 2.0, or
                     3.0. The selection of which path to use can be controlled by using the
                     <function>system-property</function> function to test the
                     <code>xsl:version</code> system property.</p>
            </note>
            <p>A processor that claims conformance with the <termref def="dt-1.0-compatibility-feature"/>
               <rfc2119>must</rfc2119> permit the use of the namespace axis in XPath expressions
               when backwards compatible behavior is enabled. In all other circumstances, support
               for the namespace axis is optional.</p>
            <note>
               <p>There are no incompatibilities between 3.0 and 2.0 that would
                  justify a 2.0-compatibility mode. When a 3.0 processor encounters a stylesheet
                  that specifies <code>version="2.0"</code>, evaluation therefore proceeds exactly
                  as if it specified <code>version="3.0"</code>. However, a software product may
                  invoke an XSLT 2.0 processor in preference to an XSLT 3.0 processor when the
                  stylesheet specifies <code>version="2.0"</code>, in which case any use of new 3.0
                  constructs will be rejected.</p>
            </note>
         </div2>
         <div2 id="streaming-feature">
            <head>Streaming Feature</head>
            <p>
               <termdef id="dt-streaming-feature" term="streaming feature">A processor that claims
                  conformance with the <term>streaming feature</term>
                  <rfc2119>must</rfc2119> use streamed processing in cases where (a) streaming is
                  requested (for example by using the attribute <code>streamable="yes"</code> on
                  <elcode>xsl:mode</elcode>, or on
                  the <elcode>xsl:source-document</elcode> instruction) and
                  (b) the constructs in question are <termref def="dt-guaranteed-streamable"/>
                  according to this specification.</termdef>
            </p>
            <p>A processor that does not claim conformance with the streaming feature is not
               required to use streamed processing and is not required to determine whether any
               construct is guaranteed streamable. Such a processor must, however, implement the
               semantics of all constructs in the language provided that enough memory is available
               to perform the processing without streaming.</p>
            <p>A processor that conforms with the feature <rfc2119>must</rfc2119>
               return the value <code>"yes"</code> in response to the function call
                  <code>system-property('xsl:supports-streaming')</code>; a processor that does not
               conform with the feature <rfc2119>must</rfc2119> return the value
               <code>"no"</code>.</p>
            <note>
               <p>The term <emph>streamed processing</emph> as used here means the ability to
                  process arbitrarily large input documents without ever-increasing memory
                  requirements.</p>
            </note>


         </div2>
         <div2 id="dynamic-evaluation-feature">
            <head>Dynamic Evaluation Feature</head>
            <p>
               <termdef id="dt-dynamic-evaluation-feature" term="dynamic evaluation feature">A
                  processor that claims conformance with the <term>dynamic evaluation feature</term>
                  <rfc2119>must</rfc2119> evaluate the <elcode>xsl:evaluate</elcode> function as
                  described in this specification.</termdef>
            </p>
            <p>A processor that does not claim conformance with the dynamic evaluation feature
                  <rfc2119>must</rfc2119> report a dynamic error if an <elcode>xsl:evaluate</elcode>
               instruction is evaluated. It <rfc2119>must not</rfc2119> report a static error merely
               because of the presence of an <elcode>xsl:evaluate</elcode> instruction in the
               stylesheet, unless a processor that conforms with the feature would report the same
               static error.</p>

            <p>A processor that conforms with the feature <rfc2119>must</rfc2119> return the value
                  <code>"yes"</code> in response to the function call
                  <code>system-property('xsl:supports-dynamic-evaluation')</code>; a processor that
               does not conform with the feature <rfc2119>must</rfc2119> return the value
                  <code>"no"</code>.</p>

            <p>A processor that conforms with the feature <rfc2119>must</rfc2119> return the value
                  <code>true</code> in response to the function call
                  <code>element-available('xsl:evaluate')</code>; a processor that does not conform
               with the feature <rfc2119>must</rfc2119> return the value <code>false</code>.</p>

            <note>
               <p>A processor may allow dynamic evaluation to be enabled and disabled by means of
                  configuration settings, perhaps for security reasons. In consequence, it may be
                  impossible to tell during static analysis of the stylesheet whether or not the
                  feature will be available during execution. A stylesheet author wanting to check
                  whether the feature is available should therefore make the test using a run-time
                  call on <code>system-property</code>, rather than relying on tests in an
                     <code>[xsl:]use-when</code> attribute.</p>
            </note>
         </div2>
         
 
         <div2 id="hof-feature">
            <head>Higher-Order Functions Feature</head>
            <p><termdef id="dt-hof-feature" term="higher-order functions feature">The <term>higher-order functions feature</term>
            contains functionality connected with the use of functions as items in the data model, that can be stored in variables
            and passed to other functions.</termdef></p>
            
            <p><error type="static" spec="XT" class="SE" code="3540"><p>A processor that does not provide the 
               <termref def="dt-hof-feature"/> raises a <termref def="dt-static-error"/> if any of the following
               XPath constructs are found in an <termref def="dt-expression"/>, <termref def="dt-pattern"/>, 
               <termref def="dt-sequence-type"/>, or <code>ItemType</code>: a 
               <xnt spec="XP40" ref="prod-xpath40-TypedFunctionTest">TypedFunctionTest</xnt>, a
               <xnt spec="XP40" ref="prod-xpath40-NamedFunctionRef">NamedFunctionRef</xnt>, an
               <xnt spec="XP40" ref="prod-xpath40-InlineFunctionExpr">InlineFunctionExpr</xnt>, or an
               <xnt spec="XP40" ref="prod-xpath40-ArgumentPlaceholder">ArgumentPlaceholder</xnt></p></error>.</p>
            
            <note><p>The effect is to disallow the three constructs used to create function-valued items: named function references
            such as <code>round#1</code>, inline function expressions such as <code>function($x){$x+1}</code>, and
            partial function application such as <code>starts-with(?, '#')</code>, along with sequence types
            such as <code>function(xs:integer) as xs:string</code> that serve no useful purpose in the absence of such items.</p> 
            
            <p>The item type <code>function(*)</code> is allowed by these rules, and serves as a generic type for maps and arrays.</p></note>
            
            <p>Where a processor does not provide the <termref def="dt-hof-feature"/>, functions whose
            specification in <bibref ref="xpath-functions-31"/> labels them with the <term>higher-order</term>
            property are excluded from the static context of expressions and patterns. An attempt to reference such
            a function therefore fails in the same way as an attempt to call a non-existent function.</p>
            
            <note><p>Examples of functions labeled with this property are <xfunction>filter</xfunction>, <xfunction>for-each</xfunction>,
            <xfunction>fold-left</xfunction>, and <xfunction>fold-right</xfunction>.</p></note>
            
            <p>A processor that does not provide the higher-order functions feature constrains the data model
               by disallowing function items other than maps and arrays, and may raise a <termref def="dt-dynamic-error"/> (<errorref spec="XT" class="DE" code="1665"/>) if this
               constraint is not satisfied.</p>
            
            <p>The same rules apply to a dynamic XPath expression processed using <elcode>xsl:evaluate</elcode>.</p>
            
         </div2>
         
      </div1>
   </body>
   <back>
      <div1 id="references">
         <head>References</head>
         <div2 id="normative-references">
            <head>Normative References</head>

            <blist>
               <bibl id="xpath-datamodel-30" key="XDM 3.0"/>
               <bibl id="xpath-datamodel-31" key="XDM 3.1"/>
               <bibl id="xpath-functions-30" key="Functions and Operators 3.0"/>
               <bibl id="xpath-functions-31" key="Functions and Operators 3.1"/>
               <bibl id="xpath-functions-40" key="Functions and Operators 4.0"/>
               <!--World Wide Web Consortium. 
<emph>XQuery 1.0 and XPath 2.0 Functions and Operators.</emph>
W3C Working Draft. 
See <loc href="http://www.w3.org/TR/xpath-functions/"/>
					</bibl>-->
               <bibl id="xml-infoset" key="XML Information Set"/>
               <!--World Wide Web Consortium. 
					<emph>XML Information Set.</emph> W3C Recommendation. 
					See <loc href="http://www.w3.org/TR/xml-infoset/"/>
                    </bibl>-->
               <!--<bibl id="ISO3166" key="ISO 3166-1">ISO (International Organization for
                  Standardization) <emph>Codes for the representation of names of countries and
                  their subdivisions - Part 1: Country codes</emph> ISO 3166-1:1997. 
                  Second edition, 2006-11-20. </bibl>-->
               <!--<bibl id="ISO8601" key="ISO 8601">ISO (International Organization for
                  Standardization) <emph>Data elements and interchange formats - Information
                     interchange - Representation of dates and times.</emph> ISO 8601:2004,
                     Third edition, 2004-12-03. </bibl>-->
               <bibl id="ISO15924" key="ISO 15924">ISO (International Organization for
                  Standardization) <emph>Information and documentation — Codes for the
                     representation of names of scripts</emph> ISO 15924:2004, January 2004. See <loc href="https://www.iso.org/obp/ui/#!iso:std:iso:15924:ed-1:v1:en"/>.</bibl>
               <bibl id="ISO15924_register" key="ISO 15924 Register">Unicode Consortium. <emph>Codes
                     for the representation of names of scripts — Alphabetical list of
                     four-letter script codes.</emph> See <loc href="http://www.unicode.org/iso15924/iso15924-codes.html"/>. Retrieved
                  February 2013; continually updated.</bibl>
               <bibl id="xslt-xquery-serialization-30" key="XSLT and XQuery Serialization"/>
               <bibl id="xslt-xquery-serialization-31" key="XSLT and XQuery Serialization 3.1"/>
               <!--<bibl id="UNICODE-NORMALIZATION" key="Unicode Normalization">Unicode Consortium.
					<emph>Unicode Normalization Forms</emph>. Unicode Standard Annex #15.
					See <loc href="http://www.unicode.org/unicode/reports/tr15/"/>
					</bibl>-->
               <!--					<bibl id="XHTML10" key="XHTML 1.0">World Wide Web Consortium. <emph>XHTML
1.0: The Extensible HyperText Markup Language.</emph> W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xhtml1/"/>. Note: a second edition of this
specification is in preparation.</bibl>-->
               <!--					<bibl id="XHTML11" key="XHTML 1.1">World Wide Web Consortium. <emph>XHTML
1.1: Module-Based XHTML.</emph> W3C Recommendation. 
See <loc href="http://www.w3.org/TR/xhtml11/"/>
</bibl>-->
               <bibl id="rfc7159" key="RFC 7159">IETF. <emph>The JavaScript Object Notation (JSON)
                     Data Interchange Format.</emph>
                  March 2014. See <loc href="http://www.ietf.org/rfc/rfc7159.txt">http://www.ietf.org/rfc/rfc7159.txt</loc>
               </bibl>

               <bibl id="UNICODE" key="UNICODE">Unicode Consortium. <emph>The Unicode
                     Standard</emph> as updated from time to time by the publication of new
                  versions. See <loc href="http://www.unicode.org/standard/versions/"/> for the
                  latest version and additional information on versions of the standard and of the
                  Unicode Character Database. The version of Unicode to be used is <termref def="dt-implementation-defined">implementation-defined</termref>, but
                  implementations are recommended to use the latest Unicode version.</bibl>
               <bibl id="UNICODE-TR10" key="UNICODE TR10">Unicode Consortium. <emph>Unicode
                     Technical Standard #10. Unicode Collation Algorithm</emph>. Unicode Technical
                  Report. See <loc href="http://www.unicode.org/reports/tr10/"/>.</bibl>
               <bibl id="UNICODE-TR35" key="UNICODE TR35">Unicode Consortium. <emph>Unicode
                     Technical Standard #35. Unicode Locale Data Markup Language</emph>. Unicode
                  Technical Report. See <loc href="http://www.unicode.org/reports/tr35/"/>.</bibl>
               <bibl id="REC-xml" key="XML 1.0"> World Wide Web Consortium. <emph>Extensible Markup
                     Language (XML) 1.0. W3C Recommendation.</emph> See <loc href="https://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml/</loc>. The
                  edition of XML 1.0 must be no earlier than the Third Edition; the edition used is
                     <termref def="dt-implementation-defined"/>, but we recommend that
                  implementations use the latest version. </bibl>
               <bibl id="xml11" key="XML 1.1"/>
               <bibl id="xmlbase" key="XML Base"/>
               <bibl id="xml-id" key="xml:id"/>
               <bibl id="xml-names" key="Namespaces in XML"/>
               <bibl id="xml-names11" key="Namespaces in XML 1.1"/>
               <bibl id="xmlschema-1" key="XML Schema Part 1"/>
               <bibl id="xmlschema-2" key="XML Schema Part 2"/>
               <bibl id="xmlschema11-1" key="XML Schema 1.1 Part 1"/>
               <bibl id="xmlschema11-2" key="XML Schema 1.1 Part 2"/>
               <bibl id="xpath-30" key="XPath 3.0"/>
               <bibl id="xpath-31" key="XPath 3.1"/>
               <bibl id="xpath-40" key="XPath 3.14.0"/>
               <bibl id="XSLT-Mime-Type" key="XSLT Media Type">World Wide Web Consortium.
                     <emph>Registration of MIME Media Type application/xslt+xml</emph>. In <loc href="https://www.w3.org/TR/2007/REC-xslt20-20070123/#media-type-registration">Appendix B.1 of the XSLT 2.0 specification.</loc></bibl>
            </blist>
         </div2>
         <div2 id="other-references">
            <head>Other References</head>
            <blist>
               <bibl id="CLDR" key="Unicode CLDR">CLDR - Unicode Common Locale Data Repository.
                  Available at: <loc href="http://cldr.unicode.org">http://cldr.unicode.org</loc></bibl>

               <bibl id="DOM-Level-2-Core" key="DOM Level 2"/>
               <bibl id="ECMA-404" key="ECMA-404"> ECMA International. <emph>The JSON Data
                     Interchange Format</emph> October 2013. See <loc href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf">http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf</loc>. </bibl>
               <bibl id="ICU" key="ICU">ICU - International Components for Unicode. Available at
                     <loc href="http://site.icu-project.org">http://site.icu-project.org</loc>
               </bibl>
               <bibl id="rfc2119" key="RFC2119">S. Bradner. <emph>Key words for use in RFCs to
                     Indicate Requirement Levels</emph>. IETF RFC 2119. See <loc href="http://www.ietf.org/rfc/rfc2119.txt"/>.</bibl>
               <!--<bibl id="RFC2376" key="RFC2376">E. Whitehead, M. Murata. <emph>XML Media
                     Types</emph>. IETF RFC 2376. See <loc
                     href="http://www.ietf.org/rfc/rfc2376.txt"/>.</bibl>-->

               <bibl id="RFC3986" key="RFC3986"> T. Berners-Lee, R. Fielding, and L. Masinter.
                     <emph>Uniform Resource Identifiers (URI): Generic Syntax</emph>. IETF RFC 3986.
                  See <loc href="http://www.ietf.org/rfc/rfc3986.txt"/>.</bibl>
               <bibl id="RFC3987" key="RFC3987">M. Duerst, M. Suignard. <emph>Internationalized
                     Resource Identifiers (IRIs)</emph>. IETF RFC 3987. See <loc href="http://www.ietf.org/rfc/rfc3987.txt"/>.</bibl>
               
               <bibl id="RFC4647" key="RFC4647">A. Phillips and M. Davis. <emph>Matching of Language Tags</emph>. IETF RFC 4647. See <loc href="http://www.ietf.org/rfc/rfc4647.txt"/>.</bibl>
               

               <bibl id="rfc7303" key="RFC7303">H. Thompson and C. Lilley. <emph>XML Media
                     Types</emph>. IETF RFC 7303. See <loc href="http://www.ietf.org/rfc/rfc7303.txt"/></bibl>

               <bibl id="SemVer" key="SemVer">Tom Preston-Werner, <emph>Semantic Versioning
                     2.0.0</emph>. See <loc href="http://semver.org/"/>. Undated (retrieved 1 August
                  2014).</bibl>
               <bibl id="STX" key="STX">Petr Cimprich <emph>et al</emph>, <emph>Streaming
                     Transformations for XML (STX) Version 1.0</emph>. Working Draft 27 April 2007.
                  See <loc href="http://stx.sourceforge.net/documents/spec-stx-20070427.html"/>
               </bibl>

               <!--<bibl id="xinclude" key="XInclude"/>-->
               <bibl id="xlink" key="XLink"/>
               <bibl id="SCHEMA-AND-XML-1.1" key="XML Schema 1.0 and XML 1.1">World Wide Web
                  Consortium. <emph>Processing XML 1.1 documents with XML Schema 1.0
                     processors</emph>. W3C Working Group Note 11 May 2005. See <loc href="https://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/"/>
               </bibl>
               <bibl id="xml-stylesheet" key="XML Stylesheet"/>
               <bibl id="xptr-framework" key="XPointer Framework"/>
               <bibl id="xsl11" key="XSL-FO"/>
               <bibl id="xslt" key="XSLT 1.0"/>
               <bibl id="xslt20" key="XSLT 2.0"/>
               <bibl id="xslt30" key="XSLT 3.0"/>
            </blist>
         </div2>
      </div1>
      <div1 id="json-in-xml">
         <head>XML Representation of JSON</head>
         <p>This appendix contains the schema for the XML representation of JSON described in
               <specref ref="json-to-xml-mapping"/>, together with the stylesheets used for
            converting from this XML representation to strings matching the JSON grammar.</p>
         <p>These schema documents and stylesheets are also available as separate resources (links
            are listed at the top of this document).</p>
         <div2 id="schema-for-json">
            <head>Schema for the XML Representation of JSON</head>
            <p>The schema is reproduced below:</p>
            <?doc schema-for-json.xsd?>
         </div2>
         <div2 id="xml-to-json-stylesheet">
            <head>Stylesheet for converting XML to JSON</head>
            <p>This stylesheet contains the implementation of a function very similar to
                  <function>xml-to-json</function>, but implemented in XSLT so that it can be
               customized and extended. This stylesheet is provided for the benefit of users and
               there are no conformance requirements associated with it; there is no requirement
               that processors should make this stylesheet available. The stylesheet is reproduced
               below:</p>
            <?doc xml-to-json.xsl?>
         </div2>
      </div1>
      <inform-div1 id="glossary">
         <head>Glossary</head>
         <?glossary?>
      </inform-div1>
      <inform-div1 id="element-syntax-summary">
         <head>Element Syntax Summary</head>
         <?element-syntax-summary?>
      </inform-div1>
       <inform-div1 id="error-summary">
         <head>Summary of Error Conditions</head>
         <p>This appendix provides a summary of error conditions that a processor
            may signal. This list includes all error codes defined in this specification, but this
            is not an exhaustive list of all errors that can occur. Implementations
               <rfc2119>must</rfc2119> signal errors using these error codes, and applications can
            test for these codes; however, when more than one rule in the specification is violated,
            different processors will not necessarily signal the same error code. Implementations
            are not <rfc2119>required</rfc2119> to signal errors using the descriptive text used
            here.</p>
         <note>
            <p>The appendix is non-normative because the same information is given normatively
               elsewhere.</p>
         </note>
         <?error-summary?>
      </inform-div1>
      <inform-div1 id="implementation-defined-features">
         <head>Checklist of Implementation-Defined Features</head>
         <p>This appendix provides a summary of XSLT language features whose effect is explicitly
               <termref def="dt-implementation-defined"/>. The conformance rules (see <specref ref="conformance"/>) require vendors to provide documentation that explains how these
            choices have been exercised.</p>

         <p>The implementation-defined features are grouped into categories for convenience.</p>

         <div2 id="imp-def-api">
            <head>Application Programming Interfaces</head>

            <p>This category covers interfaces for initiating a transformation, setting its
               parameters, initializing the static and dynamic context, and collecting the results.
               In general terms, it is implementation defined how input is passed to the processor
               and how it returns its output. This includes the interpretation of URIs used to refer
               to stylesheet packages and modules, source documents and collections, collations, and
               result documents.</p>

            <p>More specifically:</p>

            <?implementation-defined-features api?>
         </div2>

         <div2 id="imp-def-ext">
            <head>Vendor and User Extensions</head>

            <p>This category covers extensions and extensibility: mechanisms for providing vendor or
               user extensions to the language without sacrificing interoperability.</p>

            <p>In general terms, it is implementation-defined:</p>

            <ulist>
               <item>
                  <p>whether and under what circumstances the implementation recognizes any
                     extension functions, extension instructions, extension attributes, user-defined
                     data elements, additional types, additional serialization methods or
                     serialization parameters, or additional collations, and if so, what effect they
                     have. </p>
               </item>
               <item>
                  <p>whether, how, and under what circumstances the implementation allows users to
                     define extension functions, extension instructions, extension attributes,
                     user-defined data elements, additional types, additional serialization methods
                     or serialization parameters, or additional collations. If it does allow users
                     to do so, it must follow the rules given elsewhere in this specification. </p>
               </item>
               <item>
                  <p>what information is available to such extensions (for example, whether they
                     have access to the static and dynamic context.) </p>
               </item>
               <item>
                  <p>where such extensions are allowed, the extent to which the processor enforces
                     their correct behavior (for example, checking that strings returned by
                     extension functions contain only valid XML characters) </p>
               </item>
            </ulist>

            <p>More specifically:</p>

            <?implementation-defined-features ext?>
         </div2>

         <div2 id="imp-def-feature">
            <head>Localization</head>
            <p>This specification, and the specifications that it refers to, include facilities for
               adapting the output of a transformation to meet local expectations: examples include
               the formatting of numbers and dates, and the choice of collations for sorted output.
               The general principles are:</p>

            <ulist>
               <item>
                  <p>The specification does not mandate any particular localizations that processors
                     must offer: for example, a conformant processor might choose to provide output
                     in Japanese only.</p>
               </item>
               <item>
                  <p>The specification provides fallback mechanisms so that if a particular
                     localization is requested and is not available, processing does not fail.</p>
               </item>
            </ulist>

            <p>More specifically:</p>

            <?implementation-defined-features local?>
         </div2>

         <div2 id="imp-def-optional-feature">
            <head>Optional Features</head>
            <p>As well as the optional conformance features identified in <specref ref="conformance"/>, some specific features of the specification are defined to be optional.</p>

            <?implementation-defined-features feature?>
         </div2>

         <div2 id="imp-def-dependencies">
            <head>Dependencies</head>
            <p>When this specification refers normatively to other specifications, it generally
               gives implementations freedom to decide (within constraints) which version of the
               referenced specification should be used. Specifically:</p>

            <?implementation-defined-features spec?>
         </div2>

         <div2 id="imp-def-defaults-and-limits">
            <head>Defaults and Limits</head>
            <p>To accommodate variations in the way that the XSLT language is deployed, and the
               constraints of different processing environments, defaults for some options are
               implementation-defined. In addition, limits on the sizes of ranges of values
               permitted are in general implementation-defined:</p>

            <?implementation-defined-features defaults?>
         </div2>
         <div2 id="imp-def-errors">
            <head>Detection and Reporting of Errors</head>
            <p>Some aspects of error handling are implementation-defined:</p>

            <?implementation-defined-features err?>
         </div2>


      </inform-div1>
      <inform-div1 id="summary-list-of-functions">
         <head>Summary of Available Functions</head>
         <div2 id="function-categories">
            <head>Function Classification</head>
            <p>The functions available for use within an XSLT stylesheet can be classified based firstly,
            on where the function is defined, and secondly, on where it can be used. Specifically, the set
            of functions available is slightly different for :</p>
            <ulist>
               <item><p>Regular XPath expressions within the stylesheet, for example those appearing in
                  <code>select</code> or <code>test</code> attributes, or between braces in a <termref def="dt-text-value-template"/> (<var>R</var>)</p></item>
               <item><p><termref def="dt-static-expression">Static expressions</termref> (<var>S</var>)</p></item>
               <item><p>XPath expressions evaluated dynamically using <elcode>xsl:evaluate</elcode> (<var>D</var>)</p></item>
            </ulist>
            
            <p>The categories are listed in the following table:</p>

            <table class="data">
               <caption>Categories of Function, and their Availability</caption>
               <thead>
                  <tr>
                     <th rowspan="1" colspan="1">Category</th>
                     <th rowspan="1" colspan="1">Defined where?</th>
                     <th rowspan="1" colspan="1">Available where?</th>
                     <th rowspan="1" colspan="1">Notes</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td rowspan="1" colspan="1">User-defined functions</td>
                     <td rowspan="1" colspan="1">Defined using <elcode>xsl:function</elcode> declarations in the stylesheet</td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>D</var></td>
                     <td rowspan="1" colspan="1">Functions are private by default; private functions can be referenced only
                     within the package where they are declared (and not in <elcode>xsl:evaluate</elcode>
                     expressions).</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Constructor functions for built-in types</td>
                     <td rowspan="1" colspan="1"><xspecref spec="FO40" ref="constructor-functions"/></td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>S</var>, <var>D</var></td>
                     <td rowspan="1" colspan="1">These functions are all in the namespace conventionally associated with the
                     prefix <code>xs</code>. The semantics of a constructor function are identical
                     to the semantics of a <code>cast</code> expression.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Constructor functions for user-defined types</td>
                     <td rowspan="1" colspan="1"><xspecref spec="FO40" ref="constructor-functions"/></td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>D</var> (if <code>schema-aware="yes"</code>)</td>
                     <td rowspan="1" colspan="1">This category includes a function for every named user-defined simple
                     type in an imported schema; the function allows the conversion of strings
                     and certain other values to instances of the user-defined type.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Functions defined in XPath 3.0</td>
                     <td rowspan="1" colspan="1"><bibref ref="xpath-functions-30"/></td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>S</var>, <var>D</var></td>
                     <td rowspan="1" colspan="1">Includes functions in the namespaces conventionally
                     referred to be the prefixes <code>fn</code> and <code>math</code>.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Additional functions defined in XPath 3.1 (where supported)</td>
                     <td rowspan="1" colspan="1"><bibref ref="xpath-functions-31"/></td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>S</var>, <var>D</var>.</td>
                     <td rowspan="1" colspan="1">This category has an overlap with the set of XSLT-defined-functions. Where a function
                     is defined both in this document and in XPath 3.1, the function is available in an XSLT 3.0
                     stylesheet whether or not the processor supports XPath 3.1. This category includes functions
                     in namespaces conventionally referred to by the prefixes <code>fn</code>, <code>map</code>, 
                     and <code>array</code>.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Functions defined in XSLT 3.0</td>
                     <td rowspan="1" colspan="1">This specification</td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>S</var> (see note), <var>D</var></td>
                     <td rowspan="1" colspan="1">See <specref ref="XSLT-defined-functions"/>. There is an overlap with
                     the set of functions defined in XPath 3.1. The functions available in static expressions are:
                     <function>element-available</function>, <function>function-available</function>,
                     <function>type-available</function>, <function>available-system-properties</function>,
                     and <function>system-property</function>.</td>
                  </tr>
                  <tr>
                     <td rowspan="1" colspan="1">Extension functions</td>
                     <td rowspan="1" colspan="1">Implementation-defined: see <specref ref="extension-functions"/>.</td>
                     <td rowspan="1" colspan="1"><var>R</var>, <var>S</var>, <var>D</var></td>
                     <td rowspan="1" colspan="1">Availability is <termref def="dt-implementation-defined"/></td>
                  </tr>
               </tbody>
            </table>
            
            

         </div2>
      <div2 id="XSLT-defined-functions">
         <head>List of XSLT-defined functions</head>
         <p>This appendix acts as an index of functions defined in this specification, to augment
            the set of functions defined in <bibref ref="xpath-functions-40"/>.</p>
         <?xslt-defined-functions?>
      </div2>
      </inform-div1>
      <inform-div1 id="schema-for-xslt">
         <head>Schemas for XSLT 4.0 Stylesheets</head>
         
         <p diff="add" at="A">TODO: the two schemas need to be updated for XSLT 4.0</p>
         
         <p>For convenience, schemas are provided for validation of XSLT 3.0 stylesheets
         using the XSD 1.1 and Relax NG schema languages. These are non-normative. Neither will detect
         every static error that might arise in an XSLT 3.0 stylesheet (for example, there is no attempt
         to check the syntax of XPath expressions); in addition, these schemas may reject some stylesheets
         that are valid, for example because they rely on <code>xsl:use-when</code> to eliminate sections of code
         that would otherwise be invalid.</p>
         <div2 id="xsd11-schema-for-xslt">
            <head>XSD 1.1 Schema for XSLT Stylesheets</head>

         <p>The following XSD 1.1 schema describes the structure of an XSLT stylesheet module. It
            does not define all the constraints that apply to a stylesheet (for example, it does not
            attempt to define a datatype that precisely represents attributes containing XPath
               <termref def="dt-expression">expressions</termref>). However, every valid stylesheet
            module conforms to this schema, unless it contains elements that invoke <termref def="dt-forwards-compatible-behavior"/>.</p>
         <p>A copy of this schema is available at <loc href="schema-for-xslt30.xsd">schema-for-xslt30.xsd</loc>
         </p>

         <note>
            <p>The schema as written uses a lax wildcard to permit literal result elements to appear
               in a sequence constructor. This assumes that the schema used for validation will not
               contain any global element declaration that matches the element name of a literal
               result element. The content model for an element such as <code>invoice</code>
               appearing within a stylesheet is not the same as the content model for the same
               element appearing within a source document (it is likely to contain XSLT instructions
               rather than other elements from the target vocabulary): therefore, including such
               declarations in the schema used for validating a stylesheet is inappropriate.</p>
            <p>The reason that lax validation rather than skip validation is used is so that XSLT
               instructions appearing as children of the literal result element will themselves be
               validated, using the appropriate global element declaration.</p>
         </note>

         <note>
            <p>The schema uses XSD 1.1 assertions to represent some of the non-grammatical
               constraints appearing in the specification, for example the rule that some elements
               can have either a <code>select</code> attribute or a contained sequence constructor,
               but not both. At this stage, no attempt has been made to represent every such
               constraint, even where it is not difficult to express the rule. There will always be
               some constraints that cannot be expressed at all, for example those that require
               access to multiple stylesheet modules, those that require access to the in-scope
               schema components, and those that involve parsing a non-regular grammar, such as the
               grammar for patterns.</p>
            <p>Apart from assertions, the only other significant use of XSD 1.1 features is that the
               elements <elcode>xsl:param</elcode> and <elcode>xsl:variable</elcode> are in two
               substitution groups: one containing all instructions, and one containing all
               declarations. If the schema needs to be converted to an XSD 1.0 schema, removing all
               assertions is straightforward; the other change needed is to remove
                  <elcode>xsl:param</elcode> and <elcode>xsl:variable</elcode> from the substitution
               group for declarations, and instead permit them explicitly as children of
                  <elcode>xsl:transform</elcode>.</p>
         </note>
         <?schema-for-xslt?>
         </div2>
         <div2 id="relax-ng-schema-for-xslt">
            <head>Relax-NG Schema for XSLT Stylesheets</head>
            <p>The following Relax-NG schema may be used to validate XSLT 3.0 stylesheet modules. Similar
            caveats apply as for the XSD 1.1 version.</p>
            <p>A copy of this schema is available at <loc href="schema-for-xslt30.rnc">schema-for-xslt30.rnc</loc>
            </p>
            <?rng-schema-for-xslt?>
         </div2>
      </inform-div1>


      <inform-div1 id="acknowledgements">
         <head>Acknowledgements</head>
         <p>This specification was developed and approved for publication by the W3C XSLT Working
            Group (WG).</p>
         <p>The chair of the XSLT WG is Sharon Adler. The active membership of the XSLT WG during the
            final stages of the preparation of this specification included:</p>

         <slist>
            <sitem>Sharon Adler (Chair)</sitem>
            <sitem>Anders Berglund</sitem>
            <sitem>Carine Bournez (W3C team)</sitem>
            <sitem>Abel Braaksma</sitem>
            <sitem>Charles Foster</sitem>
            <sitem>Florent Georges</sitem>
            <sitem>Michael Kay (Editor)</sitem>
            <sitem>Jirka Kosek</sitem>
            <sitem>Luis Ibhiabor</sitem>
            <sitem>Michael Sperberg-McQueen</sitem>
            <sitem>Norm Walsh</sitem>
            <sitem>Mohamed Zergaoui</sitem>
         </slist>

         <p>The Working Group wishes to acknowledge the contribution of those who have participated
            in the work at earlier stages, as well as the pioneering work of the developers of STX
            (see <bibref ref="STX"/>) which formed an important intellectual input to the design
            of XSLT 3.0 and demonstrated the feasibility of creating a streaming transformation
            language based on the core XSLT concept of recursive descent of the source tree using
            rule-based templates.</p>
         
         <p>The Working Group also wishes to thank external reviewers who have provided feedback
         during the development of the specification.</p>

      </inform-div1>

      <inform-div1 id="changes-since-3.0" diff="add" at="A">
         <head>Changes since XSLT 3.0</head>
         <div2 id="xslt-changes-since-3.0">
            <head>Changes in successive Drafts</head>
            <p>The following sections list changes in successive drafts of this specification.</p>
            <div3 id="changes-in-draft-A">
            <head>Changes in this Specification: draft A (12 April 2021)</head>
            <olist>
               <item><p>Errata agreed against XSLT 3.0 have been applied.</p></item>
               <item><p>Support for XPath 4.0 and Functions and Operators 4.0 is required. This notably
               means that support for XDM arrays is now required.</p></item>
               <item><p>The <elcode>xsl:if</elcode> instruction acquires attributes <code>then</code> and <code>else</code>.</p></item>
               <item><p>The <elcode>xsl:when</elcode> and <elcode>xsl:otherwise</elcode> elements can be evaluated using a
               <code>select</code> expression rather than a contained sequence constructor.</p></item>
               <item><p>A new <elcode>xsl:switch</elcode> instruction is introduced.</p></item>
               <item><p>The <elcode>xsl:item-type</elcode> declaration allows names to be given to item types,
               which can then be referenced by name. This is particularly useful with record types, introduced
               in XPath 4.0.</p></item>
               <item><p>A new <elcode>xsl:function-library</elcode> declaration is introduced, allowing
               functions from multiple different namespaces to be called without using a namespace prefix.</p></item>
               <item><p>The default namespace for element names and the default namespace for types can now be
               different, allowing built-in types to be referenced in unprefixed form (<code>as="integer"</code>).</p></item>
               <item><p>New instructions <elcode>xsl:array</elcode> and <elcode>xsl:array-member</elcode> allow
               the construction of arrays.</p></item>
               <item><p>The instructions <elcode>xsl:for-each</elcode>, <elcode>xsl:iterate</elcode>, and 
                  <elcode>xsl:for-each-group</elcode> have attributes <code>array</code> and <code>map</code>
                  which can be used in place of the <code>select</code> attribute to allow iteration over arrays or maps
                  rather than sequences.</p></item>
               <item><p>The new instruction <elcode>xsl:match</elcode> allows items to be matched against
               and XSLT pattern to deliver a boolean result.</p></item>
               <item><p>New pattern syntax ( <code>type(T)</code>, <code>record(N, M, N)</code>) 
                  allows matching of items by item type.</p></item>
               <!--<item><p>A new attribute <code>xsl:template/@test</code> allows tunnel parameters to be taken
               into account when deciding which template rules to apply.</p></item>-->
               <item><p>The <elcode>xsl:mode</elcode> declaration acquires an attribute <code>as="sequence-type"</code> which
               declares the return type of all template rules in that mode.</p></item>
               <item><p>The <elcode>xsl:for-each</elcode> and <elcode>xsl:apply-templates</elcode> instructions
               acquire a <code>separator</code> attribute to allow separators to be inserted into the output.</p></item>
               <item><p>The <elcode>xsl:map</elcode> instruction acquires a new attribute <code>on-duplicates</code>.</p></item>
               <item><p>The <elcode>xsl:function</elcode> declaration allows parameters to be declared as optional,
                  so a single <elcode>xsl:function</elcode> declaration can declare functions with multiple arities.</p></item>
               <item><p>Enclosed modes: The <elcode>xsl:mode</elcode> declaration allows contained
                  <elcode>xsl:template</elcode> declarations.</p></item>
               <item><p>Functions that accept a lexical QName as an argument, such as <xfunction>key</xfunction>,
                  <xfunction>function-available</xfunction>, <xfunction>element-available</xfunction>,
                  <xfunction>type-available</xfunction>, <xfunction>system-property</xfunction>,
                  <xfunction>accumulator-before</xfunction>, and <xfunction>accumulator-after</xfunction>,
               now have the option of supplying an <code>xs:QName</code> value instead.</p></item>
            </olist>
            </div3>
            <div3 id="changes-in-draft-B">
               <head>Changes in this Specification: draft B (date TBA)</head>
               <olist>
                  <item><p>The proposed <code>array</code> and <code>map</code> attributes of
                     <elcode>xsl:for-each</elcode>, <elcode>xsl:iterate</elcode>, and <elcode>xsl:for-each-group</elcode>
                     have been dropped. Instead, to iterate over the contents of an array or map, use functions
                  such as <code>array:members</code> and <code>map:key-value-pairs</code>.</p></item>
                  <item><p>The descriptions of basic data types for attributes now avoid using the term
                  <emph>lexical space</emph>, since in XSD the lexical space contains values after whitespace
                  normalization whereas these descriptions relate to the values as written.</p></item>
                  <item><p>The rules for <termref def="dt-enclosed-mode">enclosed modes</termref> are corrected:
                  the restriction on referring to the enclosed mode from outside applies to the package, not
                  just to the stylesheet module. In addition, an <elcode>xsl:apply-templates</elcode> instruction
                  within an enclosed mode defaults its <code>mode</code> attribute to the enclosing mode.</p></item>
               </olist>
            </div3>
         </div2>
         <div2 id="xpath-changes-since-3.1">
            <head>Changes in Other Related Specifications</head>

            <p>A number of changes affecting XSLT 4.0 have been made in other related
               specifications. Some of the more significant changes are as follows:</p>
            <olist>
               <item>
                  <p>A number of new kinds of ItemType are introduced, for example union types,
                  record types, and enumeration types.</p>
               </item>

               <item>
                  <p>The coercion rules (previously "function conversion rules") allow atomic values
                  of primitive types to be supplied where a restricted type is required: for example
                  if the required type is <code>xs:positiveInteger</code>, it is now acceptable to supply the
                  value <code>42</code>.</p>
               </item>
               
               <item>
                  <p>XPath 4.0 introduces abbreviated syntax for conditional expressions
                  (<code>condition ?? action1 !! action2</code>) and for inline functions
                  (<code>-> $x, $y {$x + $y}</code>).</p>
               </item>

 

               
            </olist>
         </div2>
      </inform-div1>
   
      <inform-div1 id="todo-list" diff="add" at="A">
         <head>Changes Pending</head>
         <p>Further work is needed in the following areas:</p>
            <olist>
               <item><p>Streamability implications of new constructs</p></item>
               <item><p>Details of error codes</p></item>
               <item><p>Default priorites for new kinds of pattern</p></item>
               <item><p>Add built-in template rules suitable for JSON processing</p></item>
               <item><p>Default namespace for elements: allow matching on local-name only,
               or on "XHTML or nothing".</p></item>
            </olist>
      </inform-div1>

      <inform-div1 id="incompatibilities" diff="add" at="A">
         <head>Incompatibilities with XSLT 3.0</head>
         <p>This section lists all known incompatibilities with XSLT 3.0, that is, situations
               where a stylesheet that is error-free
            according to the XSLT 3.0 specification and where all elements have an effective version
            of <code>3.0</code> or less, will produce different results depending on whether it is
            run under an XSLT 3.0 processor or an XSLT 4.0 processor.</p>
         <olist>
            <item>
               <p>The rules for comparing values in <elcode>xsl:for-each-group</elcode> now reference
               the rules for <function>distinct-values</function>, which have themselves changed
               to reference <function>op:same-key</function>. This change eliminates the intransitivity
               in the previous specification, which meant that in edge cases involving rounding of numeric values
               of different types, two items in different groups could compare equal. Any change in behavior
               is confined to this edge case.</p>
            </item>

            
         </olist>
         
         <p>This specification also corrects a number of errors and omissions in XSLT 3.0, in a way that
         might create incompatibilities for some processors, depending on how they interpreted the XSLT 3.0
         specification:</p>
         <olist>
            <item><p>XSLT 3.0 (and earlier releases) did not fully define the evaluation context for the
            default values of template parameters. For example, if the default value of a parameter of a 
            template rule invoked <elcode>xsl:next-match</elcode>, it was not specified whether the
            current template rule should be the calling template or the called template. This omission has
            been corrected.</p></item>
         </olist>


      </inform-div1>
   </back>
</spec>
