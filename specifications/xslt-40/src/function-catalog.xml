<?xml version="1.0" encoding="utf-8"?>
<!-- Current changes labelled at="S" -->
<fos:functions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xmlns:fos="http://www.w3.org/xpath-functions/spec/namespace"
               xsi:schemaLocation="http://www.w3.org/xpath-functions/spec/namespace ../../xpath-functions-30/src/fos.xsd">
   <fos:global-variables>
      <fos:variable name="po" as="element()">&lt;PurchaseOrder&gt; &lt;line-item&gt;
         &lt;description&gt;Large widget&lt;/description&gt; &lt;price&gt;8.95&lt;/price&gt;
         &lt;quantity&gt;5.0&lt;/quantity&gt; &lt;/line-item&gt; &lt;line-item&gt;
         &lt;description&gt;Small widget&lt;/description&gt; &lt;price&gt;3.99&lt;/price&gt;
         &lt;quantity&gt;2.0&lt;/quantity&gt; &lt;/line-item&gt; &lt;line-item&gt;
         &lt;description&gt;Tiny widget&lt;/description&gt; &lt;price&gt;1.49&lt;/price&gt;
         &lt;quantity&gt;805&lt;/quantity&gt; &lt;/line-item&gt;
         &lt;/PurchaseOrder&gt;</fos:variable>
      <fos:variable name="item1" select="$po/line-item[1]"/>
      <fos:variable name="item2" select="$po/line-item[2]"/>
      <fos:variable name="item3" select="$po/line-item[3]"/>
   </fos:global-variables>

   <fos:function name="current">
      <fos:signatures>
         <fos:proto name="current" return-type="item()"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
         <fos:property>special-streaming-rules</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the item that is the context item for the evaluation of the containing XPath
            expression</p>
      </fos:summary>
      <fos:rules>

         <p>The <function>current</function> function, used within an XPath <termref def="dt-expression">expression</termref>, returns the item that was the <termref def="dt-context-item">context item</termref> at the point where the expression was
            invoked from the XSLT <termref def="dt-stylesheet">stylesheet</termref>. This is
            referred to as the current item. For an outermost expression (an expression not
            occurring within another expression), the current item is always the same as the context
            item. Thus,</p>
         <eg xml:space="preserve"><![CDATA[<xsl:value-of select="current()"/>]]></eg>
         <p>means the same as</p>
         <eg xml:space="preserve"><![CDATA[<xsl:value-of select="."/>]]></eg>
         <p>However, within square brackets, or on the right-hand side of the <code>/</code>
            operator, the current item is generally different from the context item.</p>
         <p>If the <function>current</function> function is used within a <termref def="dt-pattern">pattern</termref>, its value is the item that is
            being matched against the pattern.</p>

      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1360">
               <p>If the <function>current</function> function is evaluated within an expression
                  that is evaluated when the context item is absent, a <termref def="dt-dynamic-error">
                     dynamic error</termref> occurs.</p>
            </error>
         </p>
         <p>When the <function>current</function> is called by means of a
            dynamic function call (for example, <code>current#0()</code>), it is evaluated as if the
            context item is absent (<errorref spec="XT" type="dynamic" class="DE" code="1360"/>).</p>

      </fos:errors>
      <fos:examples>

         <fos:example>
            <p>The instruction:</p>
            <eg xml:space="preserve"><![CDATA[<xsl:apply-templates select="//glossary/entry[@name=current()/@ref]"/>]]></eg>
            <p>will process all <code>entry</code> elements that have a <code>glossary</code> parent
               element and that have a <code>name</code> attribute with value equal to the value of
               the current itemâ€™s <code>ref</code> attribute. This is different from</p>
            <eg xml:space="preserve"><![CDATA[<xsl:apply-templates select="//glossary/entry[@name=./@ref]"/>]]></eg>
            <p>which means the same as</p>
            <eg xml:space="preserve"><![CDATA[<xsl:apply-templates select="//glossary/entry[@name=@ref]"/>]]></eg>
            <p>and so would process all <code>entry</code> elements that have a
                  <code>glossary</code> parent element and that have a <code>name</code> attribute
               and a <code>ref</code> attribute with the same value.</p>
         </fos:example>

      </fos:examples>


   </fos:function>


   <fos:function name="current-group">
      <fos:signatures>
         <fos:proto name="current-group" return-type="item()*"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>special-streaming-rules</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the group currently being processed by an <elcode>xsl:for-each-group</elcode>
             instruction.</p>
      </fos:summary>
      <fos:rules>
         <p> The evaluation context for XPath <termref def="dt-expression">expressions</termref>
            includes a component called the <termref def="dt-current-group">current group</termref>,
            which is a sequence. </p>

         <p>The function <function>current-group</function> returns the sequence
            of items making up the current group.</p>

         <p>The current group is bound during evaluation of the
               <elcode>xsl:for-each-group</elcode> instruction. If no
               <elcode>xsl:for-each-group</elcode> instruction is being evaluated, the current group
            will be <termref def="dt-absent"/>: that is, any reference to it will cause a dynamic
            error.</p>

         <p>The effect of <termref def="dt-invocation-construct">invocation constructs</termref> on the <termref def="dt-current-group"/> is as
            follows:</p>

         <ulist>
            <item>
               <p>If the <termref def="dt-invocation-construct"/> is contained within a <termref def="dt-declared-streamable"/>
                  <termref def="dt-construct"/> (for example, if it is within an
                     <elcode>xsl:source-document</elcode> instruction with the attribute <code>streamable="yes"</code>, 
                  or within a streamable template), then the
                  invocation construct sets the current group to <termref def="dt-absent"/>. In this
                  situation the scope of the current group is effectively static; it can only be
                  referenced within the body of the <elcode>xsl:for-each-group</elcode> instruction
                  to which it applies.</p>
            </item>

            <item>
               <p>If the <termref def="dt-invocation-construct"/> is a (static or dynamic) function
                  call, then the invocation construct sets the current group to <termref def="dt-absent"/>.</p>
            </item>

            <item>
               <p>Otherwise the <termref def="dt-invocation-construct"/> leaves the current group
                  unchanged. In this situation the scope of the current group is effectively
                  dynamic: it can be referenced within called templates and attribute sets.</p>
            </item>
         </ulist>

         <p>The current group is initially <termref def="dt-absent"/>
            during the evaluation of global variables and stylesheet parameters, during the
         evaluation of the <code>use</code> attribute or contained sequence constructor of <elcode>xsl:key</elcode>,
         and during the evaluation of the <code>initial-value</code> attribute of <elcode>xsl:accumulator</elcode>
         and the <code>select</code> attribute of contained sequence constructor of <elcode>xsl:accumulator-rule</elcode>.</p>




      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="static" class="SE" code="1060">
               <p>It is a <termref def="dt-static-error">static error</termref> if the
                     <function>current-group</function> function is used within a <termref def="dt-pattern">pattern</termref>.</p>
            </error>
         </p>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1061">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the
                     <function>current-group</function> function is used when the current group is
                     <termref def="dt-absent">absent</termref>
                  , or when it is invoked in the course of evaluating a
                     pattern. The error <rfc2119>may</rfc2119> be reported statically if it
                  can be detected statically.</p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p>Like other XSLT extensions to the dynamic evaluation context,
            the <termref def="dt-current-group"/> is not retained as part of the closure of a
            function value. This means that the expression <code>current-group#0</code> is valid and
            returns a function value, but any invocation of this function will fail with a dynamic
            error <errorref spec="XT" class="DE" code="1061"/>. </p>

      </fos:notes>
   </fos:function>

   <fos:function name="current-grouping-key">
      <fos:signatures>
         <fos:proto name="current-grouping-key" return-type="xs:anyAtomicType*"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>special-streaming-rules</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the grouping key of the group currently being processed using the
               <elcode>xsl:for-each-group</elcode>
             instruction.</p>
      </fos:summary>
      <fos:rules>
         <p> The evaluation context for XPath <termref def="dt-expression">expressions</termref>
            includes a component called the <termref def="dt-current-grouping-key">current grouping
               key</termref>, which is a sequence of atomic
               values. The current grouping key is the <termref def="dt-grouping-key">grouping key</termref> shared in common by all the items within the <termref def="dt-current-group">current group</termref>. </p>

         <p>The function <function>current-grouping-key</function> returns the <termref def="dt-current-grouping-key">current grouping key</termref>.</p>

         <p>The current grouping key is bound during evaluation of an
               <elcode>xsl:for-each-group</elcode> instruction that has a <code>group-by</code> or
               <code>group-adjacent</code> attribute. If <phrase>no
                  <elcode>xsl:for-each-group</elcode> instruction is being evaluated, the current
               grouping key will be <termref def="dt-absent"/>, which means that any reference to it
               causes a dynamic error. The current grouping key is also set to <termref def="dt-absent"/> during the evaluation of an <elcode>xsl:for-each-group</elcode>
               instruction with a <code>group-starting-with</code> or <code>group-ending-with</code>
               attribute</phrase>.</p>

         <p>The effect of <termref def="dt-invocation-construct">invocation constructs</termref> on the <termref def="dt-current-grouping-key"/> is
            as follows:</p>

         <ulist>
            <item>
               <p>If the <termref def="dt-invocation-construct"/> is contained within a <termref def="dt-declared-streamable"/>
                  <termref def="dt-construct"/> (for example, if it is within an
                     <elcode>xsl:source-document</elcode> instruction with the attribute <code>streamable="yes"</code>, 
                  or within a streamable template), then the
                  invocation construct sets the current grouping key to <termref def="dt-absent"/>.
                  In this situation the scope of the current group is effectively static; it can
                  only be referenced within the body of the <elcode>xsl:for-each-group</elcode>
                  instruction to which it applies.</p>
            </item>

            <item>
               <p>If the <termref def="dt-invocation-construct"/> is a (static or dynamic) function
                  call, then the invocation construct sets the current grouping key to <termref def="dt-absent"/>.</p>
            </item>

            <item>
               <p>Otherwise the <termref def="dt-invocation-construct"/> leaves the current grouping
                  key unchanged. In this situation the scope of the current group is effectively
                  dynamic: it can be referenced within called templates and attribute sets.</p>
            </item>
         </ulist>

         
         <p>The current grouping key is initially <termref def="dt-absent"/>
            during the evaluation of global variables and stylesheet parameters, during the
            evaluation of the <code>use</code> attribute or contained sequence constructor of <elcode>xsl:key</elcode>,
            and during the evaluation of the <code>initial-value</code> attribute of <elcode>xsl:accumulator</elcode>
            and the <code>select</code> attribute of contained sequence constructor of <elcode>xsl:accumulator-rule</elcode>.</p>


         <p>While an <elcode>xsl:for-each-group</elcode> instruction with a <code>group-by</code> or
               <code>group-adjacent</code> attribute is being evaluated, the <termref def="dt-current-grouping-key">current grouping key</termref> will be a single atomic
            value if <code>composite="no"</code> is specified (explicitly
               or implicitly), or a sequence of atomic values if <code>composite="yes"</code> is
               specified.
         </p>

         

         <p>At other times, the current grouping key will be <termref def="dt-absent">absent</termref>.</p>



         <p>The <termref def="dt-grouping-key">grouping keys</termref> of
               all items in a group are not necessarily identical. For example, one might be an
                  <code>xs:float</code> while another is a numerically equal
               <code>xs:decimal</code>. The <function>current-grouping-key</function>
            function returns the grouping key of the <termref def="dt-initial-item">initial item</termref> in the group, after atomization and
            casting of <code>xs:untypedAtomic</code> values to <code>xs:string</code>.</p>

         <p>The function takes no arguments.</p>


      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="static" class="SE" code="1070">
               <p>It is a <termref def="dt-static-error">static error</termref> if the
                     <function>current-grouping-key</function> function is used within a <termref def="dt-pattern">pattern</termref>.</p>
            </error>
         </p>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1071">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the
                     <function>current-grouping-key</function> function is used when the current
                  grouping key is <termref def="dt-absent">absent</termref>, or when it is invoked in the course of evaluating a pattern.
                  The error <rfc2119>may</rfc2119> be reported statically if it can be detected
                  statically.</p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p>Like other XSLT extensions to the dynamic evaluation context,
            the <termref def="dt-current-grouping-key"/> is not retained as part of the closure of a
            function value. This means that the expression <code>current-grouping-key#0</code> is
            valid and returns a function value, but any invocation of this function will fail with a
            dynamic error <errorref spec="XT" class="DE" code="1071"/>. </p>
      </fos:notes>
   </fos:function>

   <fos:function name="current-merge-group">
      <fos:signatures>
         <fos:proto name="current-merge-group" return-type="item()*">
            <fos:arg name="source" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>special-streaming-rules</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the group of items currently being processed by an <elcode>xsl:merge</elcode>
            instruction.</p>
      </fos:summary>
      <fos:rules>
         <p>The <termref def="dt-current-merge-group"/> is bound during evaluation of the
               <elcode>xsl:merge-action</elcode> child of an <elcode>xsl:merge</elcode> instruction. 
            If no <elcode>xsl:merge-action</elcode> is being
            evaluated, then the current merge group is <termref def="dt-absent"/>, in which case the
            function raises a dynamic error (see below).</p>

         <p>The <termref def="dt-current-merge-group"/> (if not absent) is a map. 
            It contains the set of items, from all merge inputs, that share a common value for
            the merge key. This is structured as a map so that the items from each merge source can
            be identified. The key in the map is the value of the <code>name</code> attribute of the
            corresponding <elcode>xsl:merge-source</elcode> element (or an invented name, in its
            absence), and the associated value is the set of items contributed by that merge
            group.</p>

         <p>The map itself is not made visible, but this function returns values derived from the
            map. Specifically, if the map is denoted by <var>$G</var>:</p>

         <ulist>
            <item>
               <p><phrase diff="add" at="2023-02-16">If <code>$source</code> is supplied
               and is non-empty, the</phrase> function returns the value of the expression
                     <code>if (map:contains($source)) then $G($source) else error()</code>.
                  Informally, if there is an <elcode>xsl:merge-source</elcode> element whose
                     <code>name</code> attribute matches <code>$source</code>, the function returns
                  the items in the current merge group that are contributed by this merge source;
                  otherwise it raises a dynamic error (see below).</p>
            </item>
            <item>
               <p><phrase diff="add" at="2023-02-16">Otherwise (when <code>$source</code> is absent or empty)</phrase>
                  the function returns the value of the expression
                     <code>sort(map:keys($G))!$G(.)</code>, where the <code>sort()</code> function
                  sorts the names of <elcode>xsl:merge-source</elcode> elements into the document
                  order of the <elcode>xsl:merge-source</elcode> elements in the stylesheet.
                  Informally, it returns all the items in the current merge group regardless of
                  which merge source they derive from.</p>
            </item>
         </ulist>

         <p>Within the <termref def="dt-current-merge-group"/>, the ordering of items from the input
            sequences is as follows, in major-to-minor order:</p>

         <ulist>
            <item>
               <p>Items are first ordered by the <elcode>xsl:merge-source</elcode> element that
                  defined the input sequence from which the item was taken; items from
                     <elcode>xsl:merge-source</elcode>
                  <var>A</var> precede items from <elcode>xsl:merge-source</elcode>
                  <var>B</var> if <var>A</var> precedes <var>B</var> in document order within the
                  stylesheet.</p>
            </item>
            <item>
               <p>Items from different input sequences selected by the same
                     <elcode>xsl:merge-source</elcode> element are then ordered based on the order
                  of the anchor items in the sequence selected by evaluating the <code>select</code>
                  attribute of the <elcode>xsl:merge-source</elcode> element.</p>
            </item>
            <item>
               <p>Finally, duplicate items from the same input sequence retain their order from the
                  input sequence.</p>
            </item>
         </ulist>

         <p>Duplicates are not eliminated: for example, if the same node is
            selected in more than one input sequence, it may appear twice in the current 
            merge group.</p>

         



      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="static" class="SE" code="3470">
               <p>It is a <termref def="dt-static-error">static error</termref> if the
                     <function>current-merge-group</function> function is used within a <termref def="dt-pattern">pattern</termref>.</p>
            </error>
         </p>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="3480">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the
                     <function>current-merge-group</function> function is used when the current
                  merge group is <termref def="dt-absent">absent</termref>. The error
                     <rfc2119>may</rfc2119> be reported statically if it can be detected
                  statically.</p>
            </error>
         </p>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="3490">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the
                     <code>$source</code> argument of the <function>current-merge-group</function>
                  function <phrase diff="add" at="2023-02-16">(when supplied)</phrase>
                  does not match the <code>name</code> attribute of any
                     <elcode>xsl:merge-source</elcode> element for the current merge operation. The
                  error <rfc2119>may</rfc2119> be reported statically if it can be detected
                  statically.</p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p>Because the <termref def="dt-current-merge-group"/> is cleared by function calls and
            template calls, the <function>current-merge-group</function> function only has useful
            effect when the call appears as a descendant of an <elcode>xsl:merge-action</elcode>
            element.</p>
         <p>If an <elcode>xsl:merge-source</elcode> element has no <code>name</code> attribute, then
            it is not possible to discover the items in the current merge group that derive
            specifically from that source, but these items will still be present in the current
            merge group, and will be included in the result when the function is called with no
            arguments.</p>
         <p>Like other XSLT extensions to the dynamic evaluation context, the <termref def="dt-current-merge-group"/> is not retained as part of the closure of a function
            value. This means that the expression <code>current-merge-group#0</code> is valid and
            returns a function value, but any invocation of this function will fail with a dynamic
            error <errorref spec="XT" class="DE" code="3480"/>. </p>

      </fos:notes>
   </fos:function>

   <fos:function name="current-merge-key">
      <fos:signatures>
         <fos:proto name="current-merge-key" return-type="xs:anyAtomicType*"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>special-streaming-rules</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the merge key of the 
            merge group currently being processed using the
               <elcode>xsl:merge</elcode> instruction.</p>
      </fos:summary>
      <fos:rules>
         <p>The evaluation context for XPath <termref def="dt-expression">expressions</termref>
            includes a component called the <termref def="dt-current-merge-key"/>, which is a
            sequence of atomic values. The current merge key is the <termref def="dt-composite-merge-key-value">composite merge key value</termref> shared in common by all
            the items within the <termref def="dt-current-merge-group">current merge
            group</termref>. </p>

         <p>The function <function>current-merge-key</function> returns the <termref def="dt-current-merge-key">current merge key</termref>.</p>


      
         <p>While the <elcode>xsl:merge-action</elcode> child of an 
            <elcode>xsl:merge</elcode> instruction is being evaluated, the <termref def="dt-current-merge-key"/> will be a single atomic
            value if there is a single merge key, or a sequence of atomic values if there are
            multiple merge keys.</p>



         <p>At other times, the current merge key will be <termref def="dt-absent">absent</termref>.</p>

         
         <p>The <termref def="dt-composite-merge-key-value">merge keys</termref> of
               all items in a group are not necessarily identical. For example, one might be an
                  <code>xs:float</code> while another is a numerically equal
            <code>xs:decimal</code>. The <function>current-merge-key</function>
            function returns the merge key of the 
            first item in the group, after atomization and
            casting of <code>xs:untypedAtomic</code> values to <code>xs:string</code>.</p>




      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="static" class="SE" code="3500">
               <p>It is a <termref def="dt-static-error">static error</termref> if the
                     <function>current-merge-key</function> function is used within a <termref def="dt-pattern">pattern</termref>.</p>
            </error>
         </p>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="3510">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> if the
                     <function>current-merge-key</function> function is used when the current
                  merge key is <termref def="dt-absent">absent</termref>, or when it is invoked
                  in the course of evaluating a pattern. The error <rfc2119>may</rfc2119> be
                  reported statically if it can be detected statically.</p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p>Like other XSLT extensions to the dynamic evaluation context, the <termref def="dt-current-merge-key"/> is not retained as part of the closure of a function
            value. This means that the expression <code>current-merge-key#0</code> is valid and
            returns a function value, but any invocation of this function will fail with a dynamic
            error <errorref spec="XT" class="DE" code="3510"/>. </p>
      </fos:notes>
   </fos:function>
   
   <fos:function name="current-output-uri">
      <fos:signatures>
         <fos:proto name="current-output-uri" return-type="xs:anyURI?"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>context-dependent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value of the <termref def="dt-current-output-uri"/>.</p>
      </fos:summary>
      <fos:rules>
         <p>On initial invocation of a stylesheet component, the current output uri is set to the
         <termref def="dt-base-output-uri"/>.</p>
         <p>During execution of an <elcode>xsl:result-document</elcode> instruction with an <code>href</code>
         attribute, the current output URI changes to the absolute URI obtained by resolving the <termref def="dt-effective-value"/>
         of the <code>href</code> attribute against the base output URI.</p>
         
         <p>The current output URI is cleared (set to <termref def="dt-absent"/>) while evaluating stylesheet functions, 
            dynamic function calls, evaluation of global variables, stylesheet parameters, and patterns. 
            If the function is called when the current output URI is absent, the function returns the empty sequence.
         </p>
         
         <p>The current output URI may also be <termref def="dt-absent"/> in the event that a stylesheet is invoked without supplying a
         <termref def="dt-base-output-uri"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>The current output URI is not cleared when evaluating a local variable, even though <elcode>xsl:result-document</elcode>
            cannot be used while evaluating a local variable. 
            The reason for this is to allow the value of <code>current-output-uri</code> to be set as the value of a 
            tunnel parameter, so that the original
            base output URI is accessible even when writing nested result documents.</p>
      </fos:notes>
   </fos:function>
   
   <fos:function name="current-mode">
      <fos:signatures>
         <fos:proto name="current-mode" return-type="xs:QName?"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>context-dependent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value of the <termref def="dt-current-mode"/>.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the name of the <termref def="dt-current-mode"/>. If the current mode
            is <termref def="dt-absent"/>, or if it is the
            <termref def="dt-unnamed-mode"/>, the function returns an empty sequence.</p>
         
         <p>If the function is called while evaluating the <code>match</code> pattern of a template
         rule, the function returns the name of the mode used in the calling <elcode>xsl:apply-templates</elcode>
         instruction (or, if the pattern is evaluated in the course of an <elcode></elcode></p>
         <p>During execution of an <elcode>xsl:result-document</elcode> instruction with an <code>href</code>
            attribute, the current output URI changes to the absolute URI obtained by resolving the <termref def="dt-effective-value"/>
            of the <code>href</code> attribute against the base output URI.</p>
         
         <p>The current output URI is cleared (set to <termref def="dt-absent"/>) while evaluating stylesheet functions, 
            dynamic function calls, evaluation of global variables, stylesheet parameters, and patterns. 
            If the function is called when the current output URI is absent, the function returns the empty sequence.
         </p>
         
         <p>The current output URI may also be <termref def="dt-absent"/> in the event that a stylesheet is invoked without supplying a
            <termref def="dt-base-output-uri"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>The current output URI is not cleared when evaluating a local variable, even though <elcode>xsl:result-document</elcode>
            cannot be used while evaluating a local variable. 
            The reason for this is to allow the value of <code>current-output-uri</code> to be set as the value of a 
            tunnel parameter, so that the original
            base output URI is accessible even when writing nested result documents.</p>
      </fos:notes>
   </fos:function>
   
   <fos:function name="regex-group">
      <fos:signatures>
         <fos:proto name="regex-group" return-type="xs:string">
            <fos:arg name="number" type="xs:integer"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the string captured by a parenthesized subexpression of the regular expression
            used during evaluation of the <elcode>xsl:analyze-string</elcode> instruction.</p>
      </fos:summary>
      <fos:rules>
         <p>
            <termdef id="dt-current-captured-substrings" term="current captured substrings">While
               the <elcode>xsl:matching-substring</elcode> instruction is active, a set of
                  <term>current captured substrings</term> is available, corresponding to the
               parenthesized subexpressions of the regular expression.</termdef> These captured
            substrings are accessible using the function <function>regex-group</function>. This
            function takes an integer argument to identify the group, and returns a string
            representing the captured substring.</p>
         <p>The <var>N</var>th captured substring (where <var>N</var> &gt; 0) is the string matched
            by the subexpression contained by the <var>N</var>th left parenthesis in the regex,
               excluding any non-capturing groups, which are written as
                  <code>(?:xxx)</code>. The zeroth captured substring is the string that
            matches the entire regex. This means that the value of <code>regex-group(0)</code> is
            initially the same as the value of <code>.</code> (dot).</p>
         <p>The function returns the zero-length string if there is no captured substring with the
            relevant number. This can occur for a number of reasons:</p>
         <olist>
            <item>
               <p>The number is negative.</p>
            </item>
            <item>
               <p>The regular expression does not contain a parenthesized subexpression with the
                  given number.</p>
            </item>
            <item>
               <p>The parenthesized subexpression exists, and did not match any part of the input
                  string.</p>
            </item>
            <item>
               <p>The parenthesized subexpression exists, and matched a zero-length substring of
                  the input string.</p>
            </item>
         </olist>
         <p>The set of captured substrings is a context variable with dynamic scope. It is initially
            an empty sequence. During the evaluation of an <elcode>xsl:matching-substring</elcode>
            instruction it is set to the sequence of matched substrings for that regex match. During
            the evaluation of an <elcode>xsl:non-matching-substring</elcode> instruction or a
               <termref def="dt-pattern">pattern</termref> or a <termref def="dt-stylesheet-function">stylesheet function</termref> it is set to an empty
            sequence. On completion of an instruction that changes the value, the variable reverts
            to its previous value.</p>
         <p>The value of the <termref def="dt-current-captured-substrings">current captured
               substrings</termref> is unaffected through calls of
               <elcode>xsl:apply-templates</elcode>, <elcode>xsl:call-template</elcode>,
               <elcode>xsl:apply-imports</elcode> or <elcode>xsl:next-match</elcode>, or by
            expansion of named <termref def="dt-attribute-set">attribute sets</termref>.</p>

      </fos:rules>
   </fos:function>

   <fos:function name="copy-of">
      <fos:signatures>
         <fos:proto name="copy-of" return-type="item()*">
            <fos:arg name="input" type="item()*" default="." usage="absorption"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>nondeterministic</fos:property>
         <fos:property>focus-dependent</fos:property>
         <fos:property>context-independent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>nondeterministic</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>context-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a deep copy of the sequence supplied as the <code>$input</code> argument, or of the
            context item if the argument is absent.</p>
      </fos:summary>
      <fos:rules>
         
         <p>The zero-argument form of this function is defined so that <code>copy-of()</code>
         returns the value of <code>internal:copy-item(.)</code>, where <code>internal:copy-item</code> (which
            exists only for the purpose of this exposition) is defined below. Informally, <code>copy-of()</code>
         copies the context item.</p>

         <p>The single argument form of this function is defined in terms of the
         <code>internal:copy-item</code> as follows: <code>copy-of($input)</code> is equivalent
            to <code>$input ! internal:copy-item(.)</code>. Informally, <code>copy-of($input)</code> copies each item in the
         input sequence in turn.</p>
            
            <p>The <code>internal:copy-item</code> function is defined as follows:</p>
         <eg><![CDATA[
<xsl:function name="internal:copy-item" as="item()" 
              new-each-time="maybe">
  <xsl:param name="input" as="item()"/>
  <xsl:copy-of select="$input" 
               copy-namespaces="yes"
               copy-accumulators="yes"
               validation="preserve"/>
</xsl:function>]]></eg>

         <p>The streamability analysis, however, is different: see <specref ref="classifying-built-in-functions"/>.</p>

         <p>The use of <code>new-each-time="maybe"</code> in the above definition means that 
            if the <code>internal:copy-item</code> function is called more than once with the same node as argument 
            (whether or not these calls are part of the same call on <code>copy-of</code>), then it is <termref def="dt-implementation-dependent">implementation-dependent</termref> whether each
            call returns the same node, or whether multiple calls return different nodes.
           Returning the original node, however, is not allowed, except as an optimization when the processor
         can determine that this is equivalent.</p>
         
         <note>
            <p>One case where such optimization might be possible is when the copy is immediately atomized.</p>
         </note>
            
      </fos:rules>
      <fos:notes>
         <p>The <function>copy-of</function> function is available for use (and is primarily
            intended for use) when a source document is processed using streaming. It can also be
            used when not streaming. The effect, 
            when applied to element and document nodes,
            is to take a copy of the subtree rooted at the
            current node, and to make this available as a normal tree: one that can be processed without
            any of the restrictions that apply while streaming, for example only being able to
            process children once. The copy, of course, does not include siblings or ancestors of
            the context node, so any attempt to navigate to siblings or ancestors will result in an
            empty sequence being returned.</p>
         <p>All nodes in the result sequence will be parentless.</p>
         <p>If atomic values or functions (including maps and arrays) are present in the input sequence,
         they will be included unchanged at the corresponding position of the result sequence.</p>
         <p>Accumulator values are taken from the copied
            document as described in <specref ref="copying-accumulators"/>.</p>
      </fos:notes>

      <fos:examples>
         <fos:example>
            <p>Using <code>copy-of()</code> while streaming:</p>
            <p>This example copies from the source document all employees who work in marketing and
               are based in Dubai. Because there are two accesses using the child axis, it is not
               possible to do this without buffering each employee in memory, which can be achieved
               using the <function>copy-of</function> function.</p>
            <eg xml:space="preserve"><![CDATA[<xsl:source-document streamable="yes" href="employees.xml">
  <xsl:sequence select="copy-of(employees/employee)
                          [department='Marketing' and location='Dubai']"/>
</xsl:source-document>]]></eg>
         </fos:example>
      </fos:examples>

   </fos:function>

   <fos:function name="snapshot">
      <fos:signatures>
         <fos:proto name="snapshot" return-type="item()*">
            <fos:arg name="input" type="item()*" default="." usage="absorption"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>nondeterministic</fos:property>
         <fos:property>focus-dependent</fos:property>
         <fos:property>context-independent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>nondeterministic</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>context-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a copy of a sequence, retaining copies of the ancestors and descendants of any node in the input sequence, together with their
            attributes and namespaces.</p>
      </fos:summary>
      <fos:rules>

         <p>The zero-argument form of this function is defined so that <code>snapshot()</code>
            returns the value of <code>internal:snaphot-item(.)</code>, where <code>internal:snapshot-item</code> (which
            exists only for the purpose of this exposition) is defined below. Informally, <code>snapshot()</code>
            takes a snapshot of the context item.</p>
         
         <p>The single argument form of this function is defined in terms of the
            <code>internal:snapshot-item</code> as follows: <code>snapshot($input)</code> is equivalent
            to <code>$input ! internal:snapshot-item(.)</code>. Informally, <code>snapshot($input)</code> takes a snapshot of each item in the
            input sequence in turn.</p>

         
         <p>The <code>internal:snapshot-item</code> function behaves as follows:</p>
         
         <ulist>
            <item>
               <p>If the supplied item is an atomic value or a function item (including maps
            and arrays), then it returns that item unchanged.</p>
            </item>
            <item>
               <p>If the supplied item is a node, then it returns a <termref def="dt-snapshot"/>
            of that node, as defined below.</p>
            </item>
         </ulist>
         
         <p>
            <termdef id="dt-snapshot" term="snapshot">A <term>snapshot</term> of a node <var>N</var>
               is a deep copy of <var>N</var>, as produced by the <elcode>xsl:copy-of</elcode>
               instruction with <code>copy-namespaces</code> set to <code>yes</code>,
               <code>copy-accumulators</code> set to <code>yes</code>, and
                  <code>validation</code> set to <code>preserve</code>, with the additional property
               that for every ancestor of <var>N</var>, the copy also has a corresponding ancestor
               whose name, node-kind, and base URI are the same as the corresponding ancestor of
               <var>N</var>, and that has copies of the attributes, namespaces and accumulator values of the
               corresponding ancestor of <var>N</var>. But the ancestor has a type annotation of
                  <code>xs:anyType</code>, has the properties <code>nilled</code>,
                  <code>is-id</code>, and <code>is-idref</code> set to <code>false</code>, and has no children
               other than the child that is a copy of <var>N</var> or one of its
               ancestors.</termdef>
         </p>
         
         
         <p>If the function is called more than once with the same argument, it is <termref def="dt-implementation-dependent">implementation-dependent</termref> whether each
            call returns the same node, or whether multiple calls return different nodes. That is,
            the result of the expression <code>snapshot($X) is snapshot($X)</code> is <termref def="dt-implementation-dependent">implementation-dependent</termref>.</p>
         
         <p>Except for the effect on accumulators, the <code>internal:snapshot-item</code> function can be expressed
            as follows:</p>
         <eg xml:space="preserve"><![CDATA[
    <xsl:function name="internal:snapshot-item" as="item()">
        <xsl:param name="input" as="item()"/>
        <xsl:apply-templates select="$input" mode="internal:snapshot"/>
    </xsl:function>
    
    <!-- for atomic values and function items, return the item unchanged -->
    
    <xsl:template match="." mode="internal:snapshot" priority="1">
        <xsl:sequence select="."/>
    </xsl:template>
    
    <!-- for a document node, or any other root node, return a deep copy -->
    
    <xsl:template match="root()" mode="internal:snapshot" priority="5">
        <xsl:copy-of select="."/>
    </xsl:template>
    
    <!-- for an element, comment, text node, or processing instruction: -->
    
    <xsl:template match="node()" mode="internal:snapshot" 
                                 as="node()" priority="3">
        <xsl:sequence select="internal:graft-to-parent(
                                ., .., function($n){$n/node()})"/>
    </xsl:template>
    
    <!-- for an attribute: -->
    
    <xsl:template match="@*" mode="internal:snapshot" 
                             as="attribute()" priority="3">
        <xsl:variable name="name" select="node-name(.)"/>
        <xsl:sequence select="internal:graft-to-parent(., .., 
                                function($n){$n/@*[node-name(.) = $name]})"/>
    </xsl:template>
    
    <!-- for a namespace node: -->
    
    <xsl:template match="namespace-node()" mode="internal:snapshot" 
                  as="namespace-node()" priority="3">
        <xsl:variable name="name" select="local-name(.)"/>
        <xsl:sequence select="internal:graft-to-parent(., .., 
                  function($n){$n/namespace-node()[local-name(.) = $name]})"/>
    </xsl:template>
    
    <!-- make a copy C of a supplied node N, grafting it to a shallow copy of 
         C's original parent, and returning the copy C -->
    
    <xsl:function name="internal:graft-to-parent" as="node()">
        <xsl:param name="n" as="node()"/>
        <xsl:param name="original-parent" as="node()?"/>
        <xsl:param name="down-function" as="function(node()) as node()"/>
        <xsl:choose>
            <xsl:when test="exists($original-parent)">
                <xsl:variable name="p" as="node()">
                    <xsl:copy select="$original-parent">
                        <xsl:copy-of select="@*"/>
                        <xsl:copy-of select="$n"/>
                    </xsl:copy>
                </xsl:variable>
                <xsl:variable name="copied-parent" 
                     select="internal:graft-to-parent(
                        $p, $original-parent/.., function($n){$n/node()}))"/>
                <xsl:sequence select="$down-function($copied-parent)"/>              
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="$n"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    
]]></eg>
      </fos:rules>
      <fos:notes>
         <p>The <function>snapshot</function> function is available for use (and is primarily
            intended for use) when a source document is processed using streaming. It can also be
            used when not streaming. The effect is to take a copy of the subtree rooted at the
            current node, along with copies of the ancestors and their attributes, and to make this
            available as a normal tree, that can be processed without any of the restrictions that
            apply while streaming, for example only being able to process children once. The copy,
            of course, does not include siblings of the context node or of its ancestors, so any
            attempt to navigate to these siblings will result in an empty sequence being
            returned.</p>
         <p>For parentless nodes, the effect of <code>snapshot($x)</code> is identical to the effect
         of <code>copy-of($x)</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p>Using <code>snapshot()</code> while streaming:</p>
            <p>This example copies from the source document all employees who work in marketing and
               are based in Dubai. It assumes that employees are grouped by location. Because there
               are two accesses using the child axis (referencing <code>department</code> and
                  <code>salary</code>), it is not possible to do this without buffering each
               employee in memory. The <function>snapshot</function> function is used in preference
               to the simpler <function>copy-of</function> so that access to attributes of the
               parent <code>location</code> element remains possible.</p>
            <eg xml:space="preserve"><![CDATA[<xsl:source-document streamable="yes" href="employees.xml">
  <xsl:for-each select="snapshot(locations/location[@name='Dubai']
                          /employee)[department='Marketing']">
    <employee>
      <location code="{../@code}"/>
      <salary value="{salary}"/>
    </employee>
  </xsl:for-each>
</xsl:source-document>]]></eg>
         </fos:example>
      </fos:examples>
   </fos:function>






   <fos:function name="document">
      <fos:signatures>
         <fos:proto name="document" return-type="node()*">
            <fos:arg name="uri-sequence" type="item()*" usage="absorption"/>
            <fos:arg name="base-node" type="node()?" default="()" usage="inspection"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property dependency="static-base-uri">context-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>context-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Provides access to XML documents identified by a URI.</p>
      </fos:summary>
      <fos:rules>
         <p>The <function>document</function> function allows access to XML documents identified by
            a URI.</p>
         <p>The first argument contains a sequence of URI references. The second argument, if
            present, is a node whose base URI is used to resolve any relative URI references
            contained in the first argument.</p>
         <p>A sequence of absolute URI references is obtained as follows.</p>
         <ulist>
            <item>
               <p>For an item in <code>$uri-sequence</code> that is an instance of
                     <code>xs:string</code>, <code>xs:anyURI</code>, or
                     <code>xs:untypedAtomic</code>, the value is cast to <code>xs:anyURI</code>. If
                  the resulting URI reference is an absolute URI reference then it is used <emph>as
                     is</emph>. If it is a relative URI reference, then it is resolved as follows:</p>
               <olist>
                  <item>
                     <p>If <code>$base-node</code> is supplied 
                        <phrase diff="add" at="2023-02-16">(that is, if the argument is present and non-empty)</phrase>, 
                        then it is resolved against the base URI of <code>$base-node</code>.</p>
                  </item>
                  <item>
                     <p>Otherwise it is resolved against the static base URI from the static context of the
                  expression containing the call to the <function>document</function> function. In cases where the source
                  code of the stylesheet is available at execution time, this will typically be the location of the
                  relevant stylesheet module.</p>
                  </item>
               </olist>
     
            </item>
            <item>
               <p>For an item in <code>$uri-sequence</code> that is a node, the node is <termref def="dt-atomization">atomized</termref>. The result <rfc2119>must</rfc2119> be
                  a sequence whose items are all instances of <code>xs:string</code>,
                     <code>xs:anyURI</code>, or <code>xs:untypedAtomic</code>. Each of these values
                  is cast to <code>xs:anyURI</code>, and if the resulting URI reference is an
                  absolute URI reference then it is used <emph>as is</emph>. If it is a relative URI
                  reference, then it is resolved against the base URI of <code>$base-node</code> if
                  supplied, or against the base URI of the node that contained it otherwise.</p>
            </item>
            <item>
               <p>A relative URI is resolved against a base URI using the rules of the <xfunction>resolve-uri</xfunction>
                  function. A dynamic error occurs (see below) if no base URI is available.</p>
               
            </item>
            <item>
               <p> If <code>$uri-sequence</code> (after atomizing any nodes) contains an 
                  item other than an atomic value of type <code>xs:string</code>, <code>xs:anyURI</code>, or
                     <code>xs:untypedAtomic</code> then a type error is raised <xerrorref spec="XP40" class="TY" code="0004"/>. </p>
            </item>
         </ulist>

         <p>Each of these absolute URI references is then processed as follows. Any fragment
            identifier that is present in the URI reference is removed, and the resulting absolute
            URI is cast to a string and then passed to the <xfunction>doc</xfunction> function
            defined in <bibref ref="xpath-functions-30"/>. This returns a document node. If an error
            occurs during evaluation of the <xfunction>doc</xfunction> function, the processor
               <rfc2119>may</rfc2119> either raise this error in the normal way, or
               <rfc2119>may</rfc2119> recover by ignoring the failure, in which case the failing URI
            will not contribute any nodes to the result of the <function>document</function>
            function.</p>
         <p>If the URI reference contained no fragment identifier, then this document node is
            included in the sequence of nodes returned by the <function>document</function>
            function.</p>
         <p>If the URI reference contained a fragment identifier, then the fragment identifier is
            interpreted according to the rules for the media type of the resource representation
            identified by the URI, and is used to select zero or more nodes that are
            descendant-or-self nodes of the returned document node. As described in <specref ref="initiating"/>, the media type is available as part of the evaluation context for
            a transformation.</p>


         <p>The sequence of nodes returned by the function is in document order, with no duplicates.
            This order has no necessary relationship to the order in which URIs were supplied in the
               <code>$uri-sequence</code> argument.</p>

      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1160">
               <p>When a URI reference <error.extra>supplied to the <function>document</function>
                     function</error.extra> contains a fragment identifier, it is a <termref def="dt-dynamic-error"/> if the media type is not one that is recognized by the
                  processor, or if the fragment identifier does not conform to the rules for
                  fragment identifiers for that media type, or if the fragment identifier selects
                  something other than a sequence of nodes (for example, if it selects a range of
                  characters within a text node). </p>
            </error>
         </p>
         <p>A processor <rfc2119>may</rfc2119> provide an option which, if
            selected, causes the processor instead of raising this error, to ignore the fragment
            identifier and return the document node.</p>
         <p>The set of media types recognized by a processor is <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
         <imp-def-feature>The set of media types recognized by the processor, for the purpose of
            interpreting fragment identifiers in URI references passed to the
               <function>document</function> function, is implementation-defined.</imp-def-feature>
         <p>
            <!-- bug 10109 -->
            <error spec="XT" type="dynamic" class="DE" code="1162">
               <p>When a URI reference <error.extra>supplied to the <function>document</function>
                     function</error.extra> is a relative reference, it is a <termref def="dt-dynamic-error">dynamic error</termref> if no base URI is available to
                  resolve the relative reference. This can arise for example when the URI is
                  contained in a node that has no base URI (for example a parentless text node), or
                  when the second argument to the function is a node that has no base URI, or when
                  the base URI from the static context is undefined. </p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         
         <p>One effect of these rules is that in an interpreted environment 
            where the source code of the stylesheet is available and its base URI is known, then unless
            XML entities or <code>xml:base</code> are used, the expression <code>document("")</code> refers 
            to the document node of the containing stylesheet module (the definitive rules are in <bibref ref="RFC3986"/>). 
            The XML resource containing the stylesheet module is then processed exactly as if it were any 
            other XML document, for example there is no special recognition of <elcode>xsl:text</elcode> elements, 
            and no special treatment of comments and processing instructions.</p>

         <p>The XPath rules for function calling ensure that it is a type error if the supplied
            value of the second argument is anything other than a single node. If <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is enabled, then a
            sequence of nodes may be supplied, and the first node in the sequence will be used.</p>

      </fos:notes>
   </fos:function>

   <fos:function name="unparsed-entity-uri">
      <fos:signatures>
         <fos:proto name="unparsed-entity-uri" return-type="xs:anyURI">
            <fos:arg name="entity-name" type="xs:string" usage="absorption"/>
            <fos:arg name="doc" type="node()" usage="inspection" default="."/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>focus-dependent</fos:property>
         <fos:property>context-dependent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the URI (system identifier) of an unparsed entity</p>
      </fos:summary>
      <fos:rules>
         <p>Calling the single-argument form of this function has the same effect as calling the
         two-argument form with the context item as the second argument.</p>
         <p>The two-argument <function>unparsed-entity-uri</function> 
            function returns the URI of the unparsed
            entity whose name is given by the value of the <code>$entity-name</code> argument, in
            the document containing the node supplied as the 
               value of the <code>$doc</code> argument. It
            returns the zero-length <code>xs:anyURI</code> if there is no such entity. This function
            maps to the <code>dm:unparsed-entity-system-id</code> accessor defined in <bibref ref="xpath-datamodel-30"/>.</p>

      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1370">
               <p>It is a <termref def="dt-dynamic-error"/> if <code>$node</code>,
                  or the context item if the second argument is omitted,
                  is a node in a tree whose root is not a document node.</p>
            </error>
         </p>  
            <p>The following errors may be raised when <code>$node</code> is omitted:</p>
            
            <ulist>
               <item>
               <p>If the context item is absent, <termref def="dt-dynamic-error"/> 
                  <xerrorref spec="XP40" class="DY" code="0002"/>.</p>
            </item>
               <item>
               <p>If the context item is not a node, <termref def="dt-type-error"/> 
                  <xerrorref spec="XP40" class="TY" code="0004"/>.</p>
            </item>
            </ulist>
            
         
 
      </fos:errors>
      <fos:notes>
         <p>The XDM accessor <code>dm:unparsed-entity-system-id</code> is defined to return an absolute URI,
            obtained by resolving the system identifier as written against the base URI of the document. If no
            base URI is available for the document, the <function>unparsed-entity-uri</function> function
            <rfc2119>should</rfc2119> return the system identifier as written, without any attempt to make
            it absolute.</p>
         <p>XML permits more than one unparsed entity declaration with the same name to appear,
         and says that the first declaration is the one that should be used. This rule <rfc2119>should</rfc2119> be 
         respected during construction of the data model; the data model instance should not contain more than one
         unparsed entity with the same name.</p>
      </fos:notes>
   </fos:function>

   <fos:function name="unparsed-entity-public-id">
      <fos:signatures>
         <fos:proto name="unparsed-entity-public-id" return-type="xs:string">
            <fos:arg name="entity-name" type="xs:string" usage="absorption"/>
            <fos:arg name="doc" type="node()" usage="inspection" default="."/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>focus-dependent</fos:property>
         <fos:property>context-dependent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the public identifier of an unparsed entity</p>
      </fos:summary>
      <fos:rules>
         <p>Calling the single-argument form of this function has the same effect as calling the
            two-argument form with the context item as the second argument.</p>
         
         <p>The two-argument <function>unparsed-entity-public-id</function> 
            function returns the public
            identifier of the unparsed entity whose name is given by the value of the
            <code>$entity-name</code> argument, in the document containing the node supplied as the 
               value of the <code>$doc</code> argument. It returns the zero-length string if
            there is no such entity, or if the entity has no public identifier. This function maps
            to the <code>dm:unparsed-entity-public-id</code> accessor defined in <bibref ref="xpath-datamodel-30"/>.</p>

      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1380">
               <p>It is a <termref def="dt-dynamic-error"/> if <code>$node</code>,
                  or the context item if the second argument is omitted,
                  is a node in a tree whose root is not a document node.</p>
            </error>
         </p>
           
            <p>The following errors may be raised when <code>$node</code> is omitted:</p>
            
            <ulist>
               <item>
               <p>If the context item is absent, <termref def="dt-dynamic-error"/> 
                  <xerrorref spec="XP40" class="DY" code="0002"/>.</p>
            </item>
               <item>
               <p>If the context item is not a node, <termref def="dt-type-error"/> 
                  <xerrorref spec="XP40" class="TY" code="0004"/>.</p>
            </item>
            </ulist>
            
         
      </fos:errors>
      <fos:notes>
         
         <p>XML permits more than one unparsed entity declaration with the same name to appear,
            and says that the first declaration is the one that should be used. This rule <rfc2119>should</rfc2119> be 
            respected during construction of the data model; the data model instance should not contain more than one
            unparsed entity with the same name.</p>
      </fos:notes>
   </fos:function>


   <fos:function name="key">
      <fos:signatures>
         <fos:proto name="key" return-type="node()*">
            <fos:arg name="key-name" type="(xs:string | xs:QName)"/>
            <fos:arg name="key-value" type="xs:anyAtomicType*"/>
            <fos:arg name="top" type="node()" default="/" usage="navigation"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property>focus-dependent</fos:property>
         <fos:property>context-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="3">
         <fos:property>deterministic</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property>context-dependent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the nodes that match a supplied key value.</p>
      </fos:summary>
      <fos:rules>
         <p>The <function>key</function> function does for keys what the <xfunction>element-with-id</xfunction> function does for IDs.</p>
         <p>The <code>$key-name</code> argument specifies the name of the <termref def="dt-key">key</termref>. 
            The value of the argument <rfc2119>must</rfc2119> be <phrase diff="add" at="2022-01-01">either an <code>xs:QName</code>, or </phrase>
            a string containing an <termref def="dt-eqname"/>. If it is
            a <termref def="dt-lexical-qname">lexical QName</termref>, then it is expanded as
            described in <specref ref="qname"/> (no prefix means no namespace).</p>

         <p>The <code>$key-value</code> argument to the <function>key</function> function is
            considered as a sequence. The effect depends on the value of
               the <code>composite</code> attribute of the corresponding <code>xsl:key</code>
               declaration.</p>

         <ulist>
            <item>
               <p>If <code>composite</code> is <code>no</code> or
                     absent, the set of requested key values is formed by atomizing the
                  supplied value of the argument, using the standard <termref def="dt-coercion-rules">coercion rules</termref>. Each of
                  the resulting atomic values is considered as a requested key value. The result of
                  the function is a sequence of nodes, in document order and with duplicates
                  removed, comprising those nodes in the selected subtree (see below) that are
                  matched by an <elcode>xsl:key</elcode> declaration whose name is the same as the
                  supplied key name, where the result of evaluating the <termref def="dt-key-specifier">key specifier</termref> contains a value that is equal
                  to one of these requested key values, under the rules appropriate to the XPath
                     <code>eq</code> operator for the two values in question, using the
                     <code>collation</code> attributes of the <elcode>xsl:key</elcode> declaration
                  when comparing strings. No error is reported if two values are encountered that
                  are not comparable; they are regarded for the purposes of this function as being
                  not equal. </p>
               <p>If the second argument is an empty sequence, the result of the function will be an
                  empty sequence.</p>
            </item>
            <item>
               <p>If <code>composite</code> is <code>yes</code>, the requested key
                  value is the sequence formed by atomizing the supplied value of the argument,
                  using the standard <termref def="dt-coercion-rules">coercion rules</termref>. 
                  The result of the function is a sequence of nodes, in document
                  order and with duplicates removed, comprising those nodes in the selected subtree
                  (see below) that are matched by an <elcode>xsl:key</elcode> declaration whose name
                  is the same as the supplied key name, where the result of evaluating the <termref def="dt-key-specifier">key specifier</termref> is deep-equal to the requested
                  key value, under the rules appropriate to the <xfunction>deep-equal</xfunction>
                  function applied to the two values in question, using the <code>collation</code>
                  attributes of the <elcode>xsl:key</elcode> declaration when comparing strings.
                  Note that the <xfunction>deep-equal</xfunction> function reports no error if two
                  values are encountered that are not comparable; they are regarded for the purposes
                  of this function as being not equal.</p>
               <p>If the second argument is an empty sequence, the result of the
                  function will be the set of nodes having an empty sequence as the value of the key
                  specifier.</p>
            </item>
         </ulist>


         <p>Different rules apply when <termref def="dt-xslt-10-behavior">XSLT 1.0 compatible behavior</termref> is enabled.</p>

         <p>A key (that is, a set of <elcode>xsl:key</elcode>
            declarations sharing the same key name) is processed in backwards compatible mode if (a)
            at least one of the xsl:key elements in the definition of the key enables backwards
            compatible behavior, and (b) the effective value of the <code>composite</code> attribute
            is <code>no</code>.</p>

         <p>When a key is processed in backwards compatible mode,
            then:</p>

         <ulist>

            <item>
               <p>The result of evaluating the key specifier in any <elcode>xsl:key</elcode>
               declaration having this key name is converted after atomization to a sequence of
               strings, by applying a cast to each item in the sequence.</p>
            </item>

            <item>
               <p>When the first argument to the <function>key</function> function specifies this key
               name, then the value of the second argument is converted after atomization to a
               sequence of strings, by applying a cast to each item in the sequence. The values are
               then compared as strings.</p>
            </item>
         </ulist>


         <p>The third argument is used to identify the selected subtree. If the argument is present,
            the selected subtree is the set of nodes that have <var>$top</var> as an
            ancestor-or-self node. If the argument is omitted, the selected subtree is the document
            containing the context node. This means that the third argument effectively defaults to
               <code>/</code>.</p>

         <p>The result of the <function>key</function> function can be described more specifically
            as follows. The result is a sequence containing every node <var>$N</var> that satisfies
            the following conditions:</p>
         <ulist>
            <item>
               <p>
                  <code>$N/ancestor-or-self::node() intersect $top</code> is non-empty. (If the
                  third argument is omitted, <code>$top</code> defaults to <code>/</code>)</p>
            </item>
            <item>
               <p>
                  <var>$N</var> matches the pattern specified in the <code>match</code> attribute of
                  an <elcode>xsl:key</elcode> declaration whose <code>name</code> attribute matches
                  the name specified in the <code>$key-name</code> argument.</p>
            </item>
            <item>
               <p>When <code>composite="no"</code>,  and the
                     <termref def="dt-key-specifier">key specifier</termref> of that
                     <elcode>xsl:key</elcode> declaration is evaluated with a <termref def="dt-singleton-focus">singleton focus</termref> based on <var>$N</var>, the
                     <termref def="dt-atomization">atomized</termref> value of the resulting
                  sequence includes a value that compares equal to at least one item in the atomized
                  value of the sequence supplied as <code>$key-value</code>, under the rules of the
                     <code>eq</code> operator with the collation selected as described above.</p>
               <p>When <code>composite="yes"</code>,  and the
                     <termref def="dt-key-specifier">key specifier</termref> of that
                     <elcode>xsl:key</elcode> declaration is evaluated with a <termref def="dt-singleton-focus">singleton focus</termref> based on <var>$N</var>, the
                     <termref def="dt-atomization">atomized</termref> value of the resulting
                  sequence compares equal to the atomized value of the sequence supplied as
                     <code>$key-value</code>, under the rules of the
                     <xfunction>deep-equal</xfunction> function with the collation selected as
                  described above.</p>
            </item>
         </ulist>
         <p>The sequence returned by the <function>key</function> function will be in document
            order, with duplicates (that is, nodes having the same identity) removed. </p>
      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1260">
               <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the value
                     <error.extra>of the first argument to the <function>key</function>
                     function</error.extra> is not a valid QName, or if there is no namespace
                  declaration in scope for the prefix of the QName, or if the name obtained by
                  expanding the QName is not the same as the expanded name of any
                     <elcode>xsl:key</elcode> declaration in the containing <termref def="dt-package">package</termref>. If the
                  processor is able to detect the error statically (for example, when the argument
                  is supplied as a string literal), then the processor <rfc2119>may</rfc2119>
                  optionally raise this as a <termref def="dt-static-error">static
                  error</termref>.</p>
            </error>
         </p>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1270">
               <p>It is a <termref def="dt-dynamic-error">dynamic
                        error</termref> to call the <function>key</function> function with
                  two arguments if there is no <termref def="dt-context-node">context
                  node</termref>, or if the root of the tree containing the context node is not a
                  document node; or to call the function with three arguments if the root of the
                  tree containing the node supplied in the third argument is not a document
                  node.</p>
            </error>
         </p>

      </fos:errors>
      <fos:notes>

         <p>Untyped atomic values are converted to strings, not to the type of the other operand.
            This means, for example, that if the expression in the <code>use</code> attribute
            returns a date, supplying an untyped atomic value in the call to the
               <function>key</function> function will return an empty sequence.</p>

      </fos:notes>
      <fos:examples>
         <fos:example>
            <example>
               <head>Using a Key to Follow Cross-References</head>
               <p>Given a declaration</p>
               <eg xml:space="preserve"><![CDATA[<xsl:key name="idkey" match="div" use="@id"/>]]></eg>
               <p>an expression <code>key("idkey",@ref)</code> will return the same nodes as
                     <code>id(@ref)</code>, assuming that the only ID attribute declared in the XML
                  source document is:</p>
               <eg xml:space="preserve"><![CDATA[<!ATTLIST div id ID #IMPLIED>]]></eg>
               <p>and that the <code>ref</code> attribute of the context node contains no
                  whitespace.</p>
            </example>
         </fos:example>
         <fos:example>
            <example>
               <head>Using a Key to Generate Hyperlinks</head>

               <p>Suppose a document describing a function library uses a <code>prototype</code>
                  element to define functions</p>
               <eg xml:space="preserve"><![CDATA[<prototype name="sqrt" return-type="xs:double">
  <arg type="xs:double"/>
</prototype>]]></eg>
               <p>and a <code>function</code> element to refer to function names</p>
               <eg xml:space="preserve"><![CDATA[<function>sqrt</function>]]></eg>
               <p>Then the stylesheet could generate hyperlinks between the references and
                  definitions as follows:</p>
               <eg xml:space="preserve"><![CDATA[<xsl:key name="func" match="prototype" use="@name"/>

<xsl:template match="function">
<b>
  <a href="#{generate-id(key('func',.))}">
    <xsl:apply-templates/>
  </a>
</b>
</xsl:template>

<xsl:template match="prototype">
  <p>
    <a name="{generate-id()}">
      <b>Function: </b>
      ...
    </a>
  </p>
  </xsl:template>]]></eg>
            </example>
         </fos:example>
         <fos:example>
            <p>When called with two arguments, the <function>key</function> function always returns
               nodes that are in the same document as the context node. To retrieve a node from any
               other document, it is necessary either to change the context node, or to supply a
               third argument.</p>
            <example>
               <head>Using Keys to Reference other Documents</head>
               <p>For example, suppose a document contains bibliographic references in the form
                     <code>&lt;bibref&gt;XSLT&lt;/bibref&gt;</code>, and there is a separate XML
                  document <code>bib.xml</code> containing a bibliographic database with entries in
                  the form:</p>
               <eg xml:space="preserve"><![CDATA[<entry name="XSLT">...</entry>]]></eg>
               <p>Then the stylesheet could use the following to transform the <code>bibref</code>
                  elements:</p>
               <eg xml:space="preserve"><![CDATA[<xsl:key name="bib" match="entry" use="@name"/>

<xsl:template match="bibref">
  <xsl:variable name="name" select="."/>
  <xsl:apply-templates select="document('bib.xml')/key('bib', $name)"/>
</xsl:template>]]></eg>
               <note>
                  <p>This relies on the ability in XPath 2.0 to have a function call on the
                     right-hand side of the <code>/</code> operator in a path expression.</p>
               </note>
               <p>The following code would also work:</p>
               <eg xml:space="preserve"><![CDATA[<xsl:key name="bib" match="entry" use="@name"/>

<xsl:template match="bibref">
  <xsl:apply-templates select="key('bib', ., document('bib.xml'))"/>
</xsl:template>]]></eg>
            </example>
         </fos:example>
         <fos:example>
            <example>
               <head>Using a Composite Key</head>
               <p>This example uses a composite key consisting of first name and last name to locate
                  employees in an employee file.</p>
               <p>The key can be defined like this:</p>
               <eg><![CDATA[
<xsl:key name="emp-name-key" 
         match="employee" 
         use="name/first, name/last" 
         composite="yes"/>                     
         ]]></eg>
               <p>A particular employee can then be located using the function call:</p>
               <eg><![CDATA[key('emp-name-key', ('Tim', 'Berners-Lee'), doc('employees.xml'))]]></eg>
            </example>
         </fos:example>

      </fos:examples>
   </fos:function>

   <fos:function name="system-property">
      <fos:signatures>
         <fos:proto name="system-property" return-type="xs:string">
            <fos:arg name="name" type="(xs:string | xs:QName)"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>focus-independent</fos:property>
         <fos:property dependency="namespaces">context-dependent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value of a system property</p>
      </fos:summary>
      <fos:rules>

         
         <p>The value of the <code>$name</code> argument 
            <rfc2119>must</rfc2119> be <phrase diff="add" at="2022-01-01">either an <code>xs:QName</code>, or </phrase>
            a string containing an <termref def="dt-eqname">EQName</termref>. If it is a 
            <termref def="dt-lexical-qname">lexical QName</termref>
            with a prefix, then it is expanded into an <termref def="dt-expanded-qname">expanded
               QName</termref> using the namespace declarations in the static context of the
            <termref def="dt-expression">expression</termref>. If there is no prefix, the name is
            taken as being in no namespace.</p>
            
 

         <p>The <function>system-property</function> function returns a string representing the
            value of the system property identified by the name. If there is no such system
            property, the zero-length string is returned.</p>
         <p>Implementations <rfc2119>must</rfc2119> provide the following system properties, which
            are all in the <termref def="dt-xslt-namespace">XSLT namespace</termref>:</p>
         <ulist>
            <item>
               <p>
                  <code>xsl:version</code>, a number giving the version of XSLT implemented by the
                     <termref def="dt-processor">processor</termref>; for implementations conforming
                  to the version of XSLT specified by this document, this is the string <code>"3.0"</code>. The value will always be a
                  string in the lexical space of the decimal datatype defined in XML Schema (see
                     <bibref ref="xmlschema-2"/>). This allows the value to be converted to a number
                  for the purpose of magnitude comparisons.</p>
            </item>
            <item>
               <p>
                  <code>xsl:vendor</code>, a string identifying the implementer of the <termref def="dt-processor">processor</termref>
               </p>
            </item>
            <item>
               <p>
                  <code>xsl:vendor-url</code>, a string containing a URL identifying the implementer
                  of the <termref def="dt-processor">processor</termref>; typically this is the host
                  page (home page) of the implementerâ€™s Web site.</p>
            </item>
            <item>
               <p>
                  <code>xsl:product-name</code>, a string containing the name of the implementation,
                  as defined by the implementer. This <rfc2119>should</rfc2119> normally remain
                  constant from one release of the product to the next. It <rfc2119>should</rfc2119>
                  also be constant across platforms in cases where the same source code is used to
                  produce compatible products for multiple execution platforms.</p>
            </item>
            <item>
               <p>
                  <code>xsl:product-version</code>, a string identifying the version of the
                  implementation, as defined by the implementer. This <rfc2119>should</rfc2119>
                  normally vary from one release of the product to the next, and at the discretion
                  of the implementer it <rfc2119>may</rfc2119> also vary across different execution
                  platforms.</p>
            </item>
            <item>
               <p>
                  <code>xsl:is-schema-aware</code>, returns the string <code>"yes"</code> in the
                  case of a processor that claims conformance as a <termref def="dt-schema-aware-xslt-processor">schema-aware XSLT processor</termref>, or
                     <code>"no"</code> in the case of a <termref def="dt-basic-xslt-processor">basic
                     XSLT processor</termref>.</p>
            </item>
            <item>
               <p>
                  <code>xsl:supports-serialization</code>, returns the string <code>"yes"</code> in
                  the case of a processor that offers the <termref def="dt-serialization-feature">serialization feature</termref>, or <code>"no"</code> otherwise.</p>
            </item>
            <item>
               <p>
                  <code>xsl:supports-backwards-compatibility</code>, returns the string
                     <code>"yes"</code> in the case of a processor that offers the <termref def="dt-1.0-compatibility-feature"/>, or
                     <code>"no"</code> otherwise.</p>
            </item>
            <item>
               <p>
                  <code>xsl:supports-namespace-axis</code>, returns the string <code>"yes"</code> in
                  the case of a processor that offers the XPath namespace axis even when not in
                  backwards compatible mode, or <code>"no"</code> otherwise. Note that a processor
                  that supports backwards compatible mode must support the namespace axis when in
                  that mode, so this property is not relevant to that case.</p>
            </item>
            <item>
               <p>
                  <code>xsl:supports-streaming</code>, returns the string <code>"yes"</code> in the
                  case of a processor that offers the streaming feature (see <specref ref="streaming-feature"/>), or <code>"no"</code> otherwise.</p>

            </item>
            <item>
               <p>
                  <code>xsl:supports-dynamic-evaluation</code>, returns the string
                     <code>"yes"</code> in the case of a processor that offers the dynamic
                  evaluation feature (see <specref ref="dynamic-evaluation-feature"/>), or
                     <code>"no"</code> otherwise.</p>

            </item>
            <item>
               <p diff="chg" at="2023-01-29">
                  <code>xsl:supports-higher-order-functions</code>, always returns the string
                  <code>"yes"</code>.</p>
               <note diff="chg" at="2023-01-29">In XSLT 4.0, support for higher-order functions is no
               longer an optional feature.</note>
               
            </item>
            <item>
               <p>
                  <code>xsl:xpath-version</code>, a number giving the version of XPath implemented by the
                  <termref def="dt-processor">processor</termref>. The value will always be a
                  string in the lexical space of the decimal datatype defined in XML Schema (see
                  <bibref ref="xmlschema-2"/>). This allows the value to be converted to a number
                  for the purpose of magnitude comparisons. Typical values are <code>"3.0"</code> or <code>"3.1"</code>.
                  The value <code>"3.0"</code> indicates that the processor implements XPath 3.0 plus the extensions
                  defined in <specref ref="map"/> and <specref ref="json"/>.
               </p>
            </item>
            <item>
               <p>
                  <code>xsl:xsd-version</code>, a number giving the version of XSD (XML Schema) implemented by the
                  <termref def="dt-processor">processor</termref>. The value will always be a
                  string in the lexical space of the decimal datatype defined in XML Schema (see
                  <bibref ref="xmlschema-2"/>). This allows the value to be converted to a number
                  for the purpose of magnitude comparisons. Typical values are <code>"1.0"</code> or <code>"1.1"</code>.
                  This property is relevant even when the processor is not schema-aware, since the built-in datatypes
                  for XSD 1.1 differ from those in XSD 1.0.
               </p>
            </item>
         </ulist>
         <p>Some of these properties relate to the conformance levels and features offered by the
               <termref def="dt-processor">processor</termref>: these options are described in
               <specref ref="conformance"/>.</p>
         <p>The actual values returned for the above properties are <termref def="dt-implementation-defined">implementation-defined</termref>.</p>
         <p>The set of system properties that are supported, in addition to those listed above, is
            also <termref def="dt-implementation-defined">implementation-defined</termref>.
            Implementations <rfc2119>must not</rfc2119> define additional system properties in the
            XSLT namespace.</p>
         <imp-def-feature>The values returned by the <function>system-property</function> function,
            and the names of the additional properties that are recognized, are
            implementation-defined.</imp-def-feature>

      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1390">
               <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the value supplied as
                  the <code>$property-name</code> argument <error.extra>to the
                        <function>system-property</function> function</error.extra> is not a valid
                  QName, or if there is no namespace declaration in scope for the prefix of the
                  QName. If the processor is able to detect the error statically (for example, when
                  the argument is supplied as a string literal), then the processor
                     <rfc2119>may</rfc2119> optionally raise this as a <termref def="dt-static-error">static error</termref>. </p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p>An implementation must not return the value <code>
               3.0
            </code> as the value of the <code>xsl:version</code> system property unless it is
            conformant to XSLT 3.0.</p>
         <p>It is recognized that vendors who are enhancing XSLT 1.0 or
               2.0 processors may wish to release interim implementations before all the
            mandatory features of this specification are implemented. Since such products are not
            conformant to XSLT 3.0, this specification cannot define their behavior. However,
            implementers of such products are encouraged to return a value for the
               <code>xsl:version</code> system property that is intermediate between 1.0 and 3.0,
            and to provide the <function>element-available</function> and
               <function>function-available</function> functions to allow users to test which
            features have been fully implemented.</p>
      </fos:notes>
   </fos:function>
   
   <fos:function name="available-system-properties">
      <fos:signatures>
         <fos:proto name="available-system-properties" return-type="xs:QName*"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a list of system property names that are suitable for passing to
            the <function>system-property</function> function, as a sequence of QNames.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence of QNames, being the names of the system properties
            recognized by the processor, in some <termref def="dt-implementation-dependent">implementation-dependent</termref> order.</p>
         <p>The prefix part of a returned QName is <termref def="dt-implementation-dependent"/>.</p>
         
         <p>The function is <xtermref spec="FO30" ref="dt-deterministic">deterministic</xtermref>: that is, the
            set of available system properties does not vary during the course of a transformation.</p>
      </fos:rules>
      <fos:notes>
         <p>The function returns a list of QNames, containing no duplicates.</p>
         <p>The QNames in this list are suitable for passing to the
            <function>system-property</function> function.<phrase diff="del" at="2022-01-01"> However, they must first be converted to
            the form expected by the <function>system-property</function> function, which is either
            a lexical QName or to an EQName in the form <code>Q{uri}local</code>. Because the prefix 
            of the returned QName is unpredictable, the <code>Q{uri}local</code> is likely
            to be more convenient. Conversion of an <code>xs:QName</code> value to an EQName in 
            <code>Q{uri}local</code> format can be achieved using the function:</phrase></p>
         
      </fos:notes>
   </fos:function>

   <fos:function name="function-available" prefix="fn">
      <fos:signatures>
         <fos:proto name="function-available" return-type="xs:boolean">
            <fos:arg name="name" type="(xs:string | xs:QName)"/>
            <fos:arg name="arity" type="xs:integer?" default="()"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="namespaces known-function-signatures">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Determines whether a particular function is or is not available for use. The function is
            particularly useful for calling within an <code>[xsl:]use-when</code> attribute (see
               <specref ref="conditional-inclusion"/>) to test whether a particular <termref def="dt-extension-function"/> is available.</p>
      </fos:summary>
      <fos:rules>

         <p>A function is said to be available within an XPath expression if it is present in the
               <xtermref spec="XP40" ref="dt-statically-known-function-definitions">statically known function
               definitions</xtermref> for that expression (see <specref ref="static-context"/>).
            <phrase diff="chg" at="2022-11-27">Function definitions</phrase> in the static context are uniquely identified 
            by the name of the function (a QName) in combination with its
            <termref diff="chg" at="2022-11-27" def="dt-arity-range">arity range</termref>.</p>
         <p>The value of <code>$name</code> <rfc2119>must</rfc2119> be 
            <phrase diff="add" at="2022-01-01">either an <code>xs:QName</code>, or </phrase>a
            string containing an <termref def="dt-eqname">EQName</termref>. A lexical QName is
            expanded into an <termref def="dt-expanded-qname">expanded QName</termref> using the
            namespace declarations in scope for the <termref def="dt-expression">expression</termref>. 
            If the value is an unprefixed lexical QName, then the <termref def="dt-standard-function-namespace">standard function namespace</termref> is used in
            the expanded QName.</p>
         <p><phrase diff="chg" at="2023-02-16">When the <code>$arity</code> argument is present and non-empty,</phrase>
            the <function>function-available</function> function returns
            <code>true</code> if and only if there is an available function whose name matches the value of the
               <code>$function-name</code> argument and whose <termref def="dt-arity-range">arity range</termref> 
            includes the value of the <code>$arity</code> argument. </p>
         <p><phrase diff="chg" at="2023-02-16">When the <code>$arity</code> argument is omitted or empty,</phrase>
            the <function>function-available</function> function
            returns <code>true</code> if and only if there is at least one available function (with some arity)
            whose name matches the value of the <code>$name</code> argument. </p>



         <p>When the containing expression is evaluated with <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> set to
               <code>true</code>, the <function>function-available</function> function returns <code>false</code> in
            respect of a function name and arity for which no implementation is available (other
            than the fallback error function that raises a dynamic error whenever it is called).
            This means that it is possible (as in XSLT 1.0) to use logic such as the following to
            test whether a function is available before calling it:</p>
         <example>
            <head>Calling an extension function with backwards compatibility enabled</head>
            <eg xml:space="preserve"><![CDATA[
<summary xsl:version="1.0">
  <xsl:choose>
    <xsl:when test="function-available('my:summary')">
      <xsl:value-of select="my:summary()"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:text>Summary not available</xsl:text>
    </xsl:otherwise>
  </xsl:choose>
</summary>]]></eg>
         </example>




      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1400">
               <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the 
                  <code>$name</code> argument
                     <error.extra>passed to the <function>function-available</function>
                     function</error.extra> <phrase diff="chg" at="2022-01-01">evaluates to a string that is not</phrase> a valid
                  <termref def="dt-eqname">EQName</termref>, or if the value is a
                  <termref def="dt-lexical-qname">lexical QName</termref> with a prefix for which no
                  namespace declaration is present in the static context. If the processor is able
                  to detect the error statically (for example, when the argument is supplied as a
                  string literal), then the processor <rfc2119>may</rfc2119> optionally raise this
                  as a <termref def="dt-static-error">static error</termref>.</p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p>The fact that a function with a given name is available gives no guarantee that any
            particular call on the function will be successful. For example, it is not possible to
            determine the types of the arguments expected.</p>
         <p>The introduction of the <xfunction>function-lookup</xfunction>
            function in XPath 3.0 reduces the need for <function>function-available</function>,
            since <xfunction>function-lookup</xfunction> not only tests whether a function is
            available, but also returns a function item that enables it to be dynamically
            called.</p>
         <p>If a function is present in the static context but with no useful
            functionality (for example, if the system has been configured for security reasons so
            that <xfunction>available-environment-variables</xfunction> returns no information),
            then <function>function-available</function> when applied to that function should return
            <code>false</code>.</p>
         <p>It is not necessary that there be a direct equivalence between the
            results of <function>function-available</function> and
               <xfunction>function-lookup</xfunction> in all cases. For example, there may be
               <termref def="dt-extension-function">extension functions</termref> whose side-effects
            are such that for security reasons, dynamic calls to the function are disallowed;
               <xfunction>function-lookup</xfunction> might then not provide access to the function.
            The main use-case for <function>function-available</function>, by contrast, is for use
            in <code>[xsl:]use-when</code> conditions to test whether static calls on the function
            are possible.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <example>
               <head>Stylesheet portable between XSLT 1.0, XSLT 2.0, and XSLT 3.0</head>
               <p>A stylesheet that is designed to use XSLT 2.0 facilities when running under an
                     XSLT 2.0 or XSLT 3.0 processor, but to fall
                  back to XSLT 1.0 capabilities when not, might be written using the code:</p>
               <eg xml:space="preserve"><![CDATA[
<out xsl:version="2.0">
  <xsl:choose>
    <xsl:when test="function-available('matches')">
      <xsl:value-of select="matches(/doc/title, '[a-z]*')"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="string-length(
	        translate(/doc/title, 'abcdefghijklmnopqrstuvwxyz', '')) = 0"/>
    </xsl:otherwise>
  </xsl:choose>
</out>]]></eg>
               <p>Here an XSLT 2.0 or XSLT 3.0 processor will
                  always take the <elcode>xsl:when</elcode> branch, while a 1.0 processor will
                  follow the <elcode>xsl:otherwise</elcode> branch. The single-argument version of
                  the <function>function-available</function> function is used here, because that is
                  the only version available in XSLT 1.0. Under the rules of XSLT 1.0, the call on
                  the <code>matches</code> function is not an error, because it is never
                  evaluated.</p>
            </example>
         </fos:example>
         <fos:example>
            <example>
               <head>Stylesheet portable between XSLT 3.0 and a future version of XSLT</head>
               <p>A stylesheet that is designed to use facilities in some future XSLT version when
                  they are available, but to fall back to XSLT 2.0 or XSLT
                     3.0 capabilities when not, might be written using code such as the
                  following. This hypothesizes the availability in some future version of a function
                     <code>pad</code> which pads a string to a fixed length with spaces:</p>
               <eg xml:space="preserve"><![CDATA[
 <xsl:value-of select="pad(/doc/title, 10)" 
               use-when="function-available('pad', 2)"/>
 <xsl:value-of select="concat(/doc/title, string-join(
                          for $i in 1 to 10 - string-length(/doc/title) 
						  return ' ', ''))"
               use-when="not(function-available('pad', 2))"/>
 ]]></eg>
               <p>In this case the two-argument version of <function>function-available</function>
                  is used, because there is no requirement for this code to run under XSLT 1.0.</p>
            </example>
         </fos:example>
      </fos:examples>

   </fos:function>

   <fos:function name="element-available" prefix="fn">
      <fos:signatures>
         <fos:proto name="element-available" return-type="xs:boolean">
            <fos:arg name="name" type="(xs:string | xs:QName)"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="namespaces">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Determines whether a particular instruction is or is not available for use. The function
            is particularly useful for calling within an <code>[xsl:]use-when</code> attribute (see
               <specref ref="conditional-inclusion"/>) to test whether a particular
            <termref def="dt-extension-instruction"/> is available.</p>
      </fos:summary>
      <fos:rules>




         <p>The value of the <code>$name</code> argument
               <rfc2119>must</rfc2119> be <phrase diff="add" at="2022-01-01">either an <code>xs:QName</code>,
               or</phrase> a string containing an <termref def="dt-eqname">EQName</termref>. 
            If it is a <termref def="dt-lexical-qname">lexical QName</termref>
            with a prefix, then it is expanded into an <termref def="dt-expanded-qname">expanded
               QName</termref> using the namespace declarations in the static context of the
               <termref def="dt-expression">expression</termref>. If there is a default namespace in
            scope, then it is used to expand an unprefixed <termref def="dt-lexical-qname">lexical
               QName</termref>.</p>

         <p> If the resulting <termref def="dt-expanded-qname">expanded
               QName</termref> is in the <termref def="dt-xslt-namespace"/>, the function returns
            <code>true</code> if and only if the local name matches the name of an XSLT element that is defined
            in this specification and implemented by the XSLT processor.</p>

         <p>If the <termref def="dt-expanded-qname">expanded QName</termref> has a null namespace
            URI, the <function>element-available</function> function will return <code>false</code>. </p>

         <p>If the <termref def="dt-expanded-qname">expanded QName</termref> is not in the <termref def="dt-xslt-namespace">XSLT namespace</termref>, the function returns <code>true</code> if and
            only if the processor has an <phrase diff="add" at="2022-01-01">external</phrase> implementation 
            available of an <termref def="dt-extension-instruction">extension instruction</termref> with the given
            expanded QName. This applies whether or not the namespace has been designated as an
               <termref def="dt-extension-namespace">extension namespace</termref>.</p>
         <p diff="add" at="2022-01-01">The term <term>external implementation</term> excludes the use of a 
            <termref def="dt-named-template"/> as the instructionâ€™s implementation. The function does not return
         <code>true</code> simply because the name matches the name of a <termref def="dt-named-template"/>.</p>
         <p>If the processor does not have an implementation of a particular extension instruction
            available, and such an extension instruction is evaluated, then the processor
               <rfc2119>must</rfc2119> perform fallback for the element as specified in <specref ref="fallback"/>. An implementation <rfc2119>must not</rfc2119> raise an error
            merely because the stylesheet contains an extension instruction for which no
            implementation is available.</p>

      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1440">
               <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the argument
                     <error.extra>passed to the <function>element-available</function>
                     function</error.extra> <phrase diff="chg" at="2022-01-01">evaluates to a string that is 
                        not</phrase> a valid <termref def="dt-eqname">EQName</termref>, or if the value 
                  is a <termref def="dt-lexical-qname">lexical QName</termref> with a prefix for which no
                  namespace declaration is present in the static context. If the processor is able
                  to detect the error statically (for example, when the argument is supplied as a
                  string literal), then the processor <rfc2119>may</rfc2119> optionally raise this
                  as a <termref def="dt-static-error">static error</termref>.</p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p>For element names in the XSLT namespace:</p>

         <ulist>
            <item>
               <p>This function can be useful to
                  distinguish processors that implement XSLT 3.0 from processors that implement
                  other (older or newer) versions of the specification, and to distinguish full
                  implementations from incomplete implementations. (Incomplete implementations,
                  of course, cannot be assumed to behave as described in this specification.)</p>
            </item>
            <item>
               <p>In earlier versions of this specification,
                     <function>element-available</function> was defined to return <code>true</code> only for
                  elements classified as instructions. The distinction between instructions and
                  other elements, however, is sometimes rather technical, and in XSLT 3.0 the effect
                  of the function has therefore been aligned to do what its name might suggest.</p>
            </item>
            <item>
               <p>If an instruction is recognized but offers no useful
                  functionality (for example, if the system has been configured for security reasons
                  so that <elcode>xsl:evaluate</elcode> always raises an error), then
                     <function>element-available</function> when applied to that instruction
                     <rfc2119>should</rfc2119> return <code>false</code>.</p>
            </item>

         </ulist>

         <p>For element names in other namespaces:</p>

         <ulist>
            <item>
               <p>The result of the <function>element-available</function> does not depend on
                  whether or not the namespace of the supplied instruction name has been designated
                  as an extension element namespace; it tests whether the instruction would be
                  available if the namespace were designated as such.</p>
            </item>
         </ulist>





      </fos:notes>
   </fos:function>

   <fos:function name="type-available" prefix="fn">
      <fos:signatures>
         <fos:proto name="type-available" return-type="xs:boolean">
            <fos:arg name="name" type="(xs:string | xs:QName)"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="namespaces schema-definitions">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <!--Text replaced by erratum E15 change 1"-->
         <p>Used to control how a stylesheet behaves if a particular schema type is or is not
            available in the static context.</p>
         <!--End of text replaced by erratum E15-->
      </fos:summary>
      <fos:rules>

         <p>A schema type (that is, a simple type or a complex type) is said to be available within
            an XPath expression if it is a type definition that is present in the 
            <xtermref spec="XP40" ref="dt-is-types">in-scope schema types</xtermref> for that expression
            (see <specref ref="static-context"/>). This includes built-in types, types imported
            using <elcode>xsl:import-schema</elcode>, and extension types defined by the
            implementation.</p>
         <p>The value of the <code>$name</code> argument <rfc2119>must</rfc2119> be 
            <phrase diff="add" at="2022-01-01">either an <code>xs:QName</code>, or</phrase> a string
            containing an <termref def="dt-eqname">EQName</termref>. The EQName is expanded into 
            an <termref def="dt-expanded-qname">expanded QName</termref> using the namespace declarations in
            scope for the <termref def="dt-expression">expression</termref>. If the value is an
            unprefixed lexical QName, then the default namespace is used in the expanded QName.</p>
         <p>The function returns <code>true</code> if and only if there is an available type whose name matches
            the value of the <code>$name</code> argument. </p>


      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="1428">
               <p>It is a <termref def="dt-dynamic-error"> dynamic error</termref> if the argument
                     <error.extra>passed to the <function>type-available</function>
                     function</error.extra> <phrase diff="chg" at="2022-01-01">evaluates to a string that is 
                        not</phrase> a valid <termref def="dt-eqname">EQName</termref>, or if the 
                  value is a <termref def="dt-lexical-qname">lexical QName</termref> with a prefix for which no
                  namespace declaration is present in the static context. If the processor is able
                  to detect the error statically (for example, when the argument is supplied as a
                  string literal), then the processor <rfc2119>may</rfc2119> optionally raise this
                  as a <termref def="dt-static-error">static error</termref>.</p>
            </error>
         </p>
      </fos:errors>
      <fos:notes>
         <p>The <function>type-available</function> function is of limited use within an
               <code>[xsl:]use-when</code> expression, because the static context for the expression
            does not include any user-defined types.</p>
      </fos:notes>
   </fos:function>
   
   <fos:function name="stream-available" prefix="fn">
      <fos:signatures>
         <fos:proto name="stream-available" return-type="xs:boolean">
            <fos:arg name="uri" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>nondeterministic</fos:property>
         <fos:property dependency="available-documents">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Determines, as far as possible, whether a document is available for streamed processing using <elcode>xsl:source-document</elcode>.</p>
      </fos:summary>
      <fos:rules>
         
         <p>The intent of the <function>stream-available</function> function is to allow a stylesheet author to determine,
            before calling <elcode>xsl:source-document</elcode> with <code>streamable="yes"</code> and 
            with a particular URI as the value of its <code>href</code>
         attribute, whether a document is available at that location for streamed processing.</p>
         
         <p>If the <code>$uri</code> argument is an empty sequence then the function returns <code>false</code>.</p>
         
         <p>If the function returns <code>true</code> then the caller can conclude that the following conditions are true:</p>
         
         <olist>
            <item>
               <p>The supplied URI is valid;</p>
            </item>
            <item>
               <p>A resource can be retrieved at that URI;</p>
            </item>
            <item>
               <p>An XML representation of the resource can be delivered, which is well-formed at least to the extent
            that some initial sequence of octets can be decoded into characters and matched against the production:</p>
               <p>
                  <code>prolog (EmptyElemTag | STag )</code>
               </p>
               <p>as defined in the XML 1.0 or XML 1.1 Recommendation.</p>
               <note>That is, the XML is well-formed at least as far as the end of the first element start tag; to establish this,
               a parser will typically retrieve any external entities referenced in the Doctype declaration or DTD.</note>
            </item>
         </olist>
         
         <p>If the function returns <code>false</code>, the caller can conclude that either one of the above conditions is not satisfied, or
         the processor detected some other condition that would prevent a call on <elcode>xsl:source-document</elcode> with
            <code>streamable="yes"</code> executing successfully.</p>
         
         <p>Like <elcode>xsl:source-document</elcode> itself, the function is not deterministic, which means that multiple calls during the execution
         of a stylesheet will not necessarily return the same result. The caller cannot make any inferences about the point in time at which
         the input conditions for <function>stream-available</function> are present, and in particular there is no guarantee that because
         <function>stream-available</function> returns <code>true</code>, <elcode>xsl:source-document</elcode> will necessarily succeed.</p>
         
         <p>The value of the <code>$uri</code> argument <rfc2119>must</rfc2119> be a URI in the form of a string. If it is a relative URI,
            it is resolved relative to the static base URI of the function call.</p>
 
         
         
      </fos:rules>
      <fos:errors>
         <p>If the URI is invalid, such that a call on <xfunction>doc-available</xfunction> would raise an error, then 
            <function>stream-available</function> raises the same error: <xerrorref spec="FO30" class="DC" code="0005"/>.</p>
      </fos:errors>
 
   </fos:function>
   <fos:function name="accumulator-before">
      <fos:signatures>
         <fos:proto name="accumulator-before" return-type="item()*">
            <fos:arg name="name" type="(xs:string | xs:QName)"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
         <fos:property>special-streaming-rules</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the pre-descent value of the selected accumulator at the context node.</p>
      </fos:summary>
      <fos:rules>
         <p>The <code>$name</code> argument specifies the name of the <termref def="dt-accumulator"/>. 
            The value of the argument <rfc2119>must</rfc2119> be 
            <phrase diff="add" at="2022-01-01">either an <code>xs:QName</code>, or</phrase>
            a string containing an <termref def="dt-eqname"/>. If it is a 
            <termref def="dt-lexical-qname">lexical QName</termref>, then it is expanded as described in
               <specref ref="qname"/> (no prefix means no namespace).</p>
         <p>The function returns the pre-descent value <var>B(N)</var>of the selected accumulator
            where <var>N</var> is the context node, as defined in <specref ref="accumulator-formal-rules"/>.</p>
         <p>If the context item is a node in a streamed document, then the accumulator 
            must be declared with <code>streamable="yes"</code>.</p>
         <note>
            <p>The converse is not true: an accumulator declared to be streamable is available on both
         streamed and unstreamed nodes.</p>
         </note>
 
      </fos:rules>
      <fos:errors>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="3340">
               <p>It is a <termref def="dt-dynamic-error"/> if the value of the first
                     argument to the <function>accumulator-before</function> or
                        <function>accumulator-after</function> function is 
                  <phrase diff="add" at="2022-01-01">a string that is</phrase> not a valid
                     <termref def="dt-eqname"/>, or if there is no namespace declaration in scope
                  for the prefix of the QName, or if the name obtained by expanding the QName is not
                  the same as the expanded name of any <elcode>xsl:accumulator</elcode> declaration
                  appearing in the <termref def="dt-package">package</termref> in which the function
                  call appears. If the processor is able to detect the error statically (for
                  example, when the argument is supplied as a string literal), then the processor
                     <rfc2119>may</rfc2119> optionally raise this as a <termref def="dt-static-error">static error</termref>.</p>
            </error>
         </p>
         <p>
            <error spec="XT" type="dynamic" class="DE" code="3350">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> to call the
                     <function>accumulator-before</function> or
                     <function>accumulator-after</function> function when there is no <termref def="dt-context-item"/>.</p>
            </error>
         </p>        
         <p>
            <error spec="XT" type="dynamic" class="TE" code="3360">
               <p>It is a <termref def="dt-type-error">type error</termref> to call the
                     <function>accumulator-before</function> or
                     <function>accumulator-after</function> function when the <termref def="dt-context-item"/> is 
                  not a node, or when it is an attribute or namespace node.</p>
            </error>
         </p>

         <p>
            <error spec="XT" type="dynamic" class="DE" code="3362">
               <p>It is a <termref def="dt-dynamic-error">dynamic error</termref> to call the
                     <function>accumulator-before</function> or
                     <function>accumulator-after</function> function when the context
                  item is a node in a tree to which the selected accumulator is not
                  applicable (including the case where it is not applicable
                     because the document is streamed and the accumulator is not 
                  declared with <code>streamable="yes"</code>). Implementations
                  <rfc2119>may</rfc2119> raise this error but are <rfc2119>not required</rfc2119> to do so,
                  if they are capable of streaming documents without imposing this restriction.</p>
            </error>
         </p>
         
         <p>
            <error spec="XT" type="dynamic" class="DE" code="3400">
               <p>It is an error if there is a cyclic set of dependencies among accumulators such
                  that the (pre- or post-descent) value of an accumulator depends directly or indirectly on itself.
                  A processor <rfc2119>may</rfc2119> report this as a <termref def="dt-static-error"/> if it
                  can be detected statically. Alternatively a processor <rfc2119>may</rfc2119> report this as a 
                  <termref def="dt-dynamic-error"/>. As a further option, a processor may fail catastrophically when
                  this error occurs.</p>
            </error>
         </p>
         <note>
            <p>The term <term>catastrophic failure</term> here means a failure similar to infinite function or template
         recursion, which might result in stack overflow or even in non-termination of the transformation, rather than in 
         a dynamic error of the kind that can be processed using <elcode>xsl:try</elcode> and <elcode>xsl:catch</elcode>.</p>
         </note>
                  
     
         

      </fos:errors>
      <fos:notes>
         <p>The <function>accumulator-before</function> function can be applied to a node whether or not the accumulator
            has a <code>phase="start"</code> rule for that node. In effect, there is a <code>phase="start"</code> rule
            for every node, where the default rule is to leave the accumulator value unchanged; the 
            <function>accumulator-before</function> function delivers the value of the accumulator after processing
            the explicit or implicit <code>phase="start"</code> rule.</p>
      </fos:notes>
      <fos:examples>

         <fos:example>
            <p>Given the accumulator:</p>
            <eg><![CDATA[
<xsl:accumulator name="a" initial-value="0">
   <xsl:accumulator-rule match="section" select="$value + 1"/>
</xsl:accumulator>]]></eg>
            <p>and the template rule:</p>
            <eg><![CDATA[
<xsl:template match="section">
   <xsl:value-of select="accumulator-before('a')"/>
   <xsl:apply-templates/>
</xsl:template>]]></eg>
            <p>The stylesheet will precede the output from processing each section with a section
               number that runs sequentially 1, 2, 3... irrespective of the nesting of sections.</p>
         </fos:example>

      </fos:examples>


   </fos:function>

   <fos:function name="accumulator-after">
      <fos:signatures>
         <fos:proto name="accumulator-after" return-type="item()*">
            <fos:arg name="name" type="(xs:string | xs:QName)"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
         <fos:property>special-streaming-rules</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the post-descent value of the selected accumulator at the context node.</p>
      </fos:summary>
      <fos:rules>

         <p>The <code>$name</code> argument specifies the name of the <termref def="dt-accumulator"/>. 
            The value of the argument <rfc2119>must</rfc2119> be 
            <phrase diff="add" at="2022-01-01">either an <code>xs:QName</code>, or</phrase>
            a string containing an <termref def="dt-eqname">EQName</termref>. If it is a
               <termref def="dt-lexical-qname">lexical QName</termref>, then it is expanded as
            described in <specref ref="qname"/> (no prefix means no namespace).</p>
         <p>The function returns the post-descent value <var>A(N)</var> of the selected accumulator
            where <var>N</var> is the context node, as defined in <specref ref="accumulator-formal-rules"/>.</p>
         
         <p>If the context item is a node in a streamed document, then the accumulator 
            must be declared with <code>streamable="yes"</code>.</p>
         <note>
            <p>The converse is not true: an accumulator declared to be streamable is available on both
            streamed and unstreamed nodes.</p>
         </note>
         
         
      </fos:rules>
      <fos:errors>
         <p>The following errors apply: <errorref spec="XT" type="dynamic" class="DE" code="3340"/>,
               <errorref spec="XT" type="dynamic" class="DE" code="3350"/>, <errorref spec="XT" type="type" class="TE" code="3360"/>, <errorref spec="XT" type="dynamic" class="DE" code="3362"/>, <errorref spec="XT" type="dynamic" class="DE" code="3400"/>. </p>
         <p>For constraints on the use of <function>accumulator-after</function> when streaming, see
         <specref ref="streamability-fn-accumulator-after"/>.</p>
      </fos:errors>
      
      <fos:notes>
         <p>The <function>accumulator-after</function> function can be applied to a node whether or not the accumulator
            has a <code>phase="end"</code> rule for that node. In effect, there is a <code>phase="end"</code> rule
            for every node, where the default rule is to leave the accumulator value unchanged; the 
            <function>accumulator-after</function> function delivers the value of the accumulator after processing
            the explicit or implicit <code>phase="end"</code> rule.</p>
      </fos:notes>

      <fos:examples>

         <fos:example>
            <p>Given the accumulator:</p>
            <eg><![CDATA[
<xsl:accumulator name="w" initial-value="0" streamable="true" as="xs:integer">
   <xsl:accumulator-rule match="text()" 
                         select="$value + count(tokenize(.))"/>
</xsl:accumulator>]]></eg>
            <p>and the template rule:</p>
            <eg><![CDATA[
<xsl:template match="section">
   <xsl:apply-templates/>
   (words: <xsl:value-of select="accumulator-after('w') - accumulator-before('w')"/>)
</xsl:template>]]></eg>
            <p>The stylesheet will output at the end of each section a (crude) count of the number of words
               in that section.</p>
            <p>
               <emph>Note: the call on <code>tokenize(.)</code> relies on XPath 3.1</emph>
            </p>
         </fos:example>

      </fos:examples>


   </fos:function>
   
   
 
   
   
   <!--<fos:function name="new-attribute">
      <fos:signatures>
         <fos:proto name="new-attribute" return-type="comment()">
            <fos:arg name="name" type="xs:QName"/>
            <fos:arg name="content" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      
      <fos:summary>
         <p>Constructs a new attribute node with given name and content.</p>
      </fos:summary>
      <fos:rules>
         
         <p>The result of the function is typically a new attribute node. However, the function
            is <term>elidable</term>: it is implementation-dependent whether two calls with the
            same arguments will return the same node or distinct nodes.</p>
         
         <p>The name of the returned attribute node is given by <code>$name</code>.</p>
         
         <p>The string value of the returned attribute node is the value of <code>$content</code>.</p>
         
         <p>The type annotation of the returned attribute is <code>xs:untypedAtomic</code>.</p>
         
      </fos:rules>
   </fos:function>
   
   <fos:function name="new-comment">
      <fos:signatures>
         <fos:proto name="new-comment" return-type="comment()">
            <fos:arg name="content" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      
      <fos:summary>
         <p>Constructs a new comment node with given content.</p>
      </fos:summary>
      <fos:rules>
         
         <p>The result of the function is typically a new comment node. However, the function
            is <term>elidable</term>: it is implementation-dependent whether two calls with the
            same arguments will return the same node or distinct nodes.</p>
         
         <p>The string value of the returned text node is the value of <code>$content</code>.</p>
         
      </fos:rules>
   </fos:function>
   
   <fos:function name="new-document">
      <fos:signatures>
         <fos:proto name="new-document" return-type="document-node()">
            <fos:arg name="content" type="node()*"/>
         </fos:proto>
      </fos:signatures>
      
      <fos:summary>
         <p>Constructs a new document node with given content.</p>
      </fos:summary>
      <fos:rules>
         
         <p>The result of the function is typically a new document node. However, the function
         is <term>elidable</term>: it is implementation-dependent whether two calls with the
         same arguments will return the same node or distinct nodes.</p>
         
         <p>The sequence of nodes supplied as <code>$content</code> are copied to form the content of the
         document node, as follows:</p>
         
         <olist>
            <item>
               <p>Any document nodes in the sequence are replaced by their content.</p>
            </item>
            <item><p>Adjacent text nodes are merged.</p></item>
            <item><p>Zero-length text nodes are discarded.</p></item>
            <item><p>Attribute and namespace nodes are rejected, causing a dynamic error</p></item>
         </olist>
         
         <p>The base URI of the document node is taken from the static base URI in the static context of the function call.</p>
         
      </fos:rules>
      
      <fos:errors>
         <p>It is an error if the value of <code>$content</code> includes any attribute or namespace nodes.</p>
      </fos:errors>
      
      <fos:notes>
         <p>Unfortunately XSLT and XQuery have different rules for constructing the content
         of document nodes, and this function ideally needs to harmonize them. </p>
         <p>The specification deliberately requires the content to be supplied as a sequence
         of nodes, to minimize complications.</p>
      </fos:notes>
      

      
   </fos:function>
   
   <fos:function name="new-attribute">
      <fos:signatures>
         <fos:proto name="new-attribute" return-type="comment()">
            <fos:arg name="name" type="xs:QName"/>
            <fos:arg name="content" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      
      <fos:summary>
         <p>Constructs a new attribute node with given name and content.</p>
      </fos:summary>
      <fos:rules>
         
         <p>The result of the function is typically a new attribute node. However, the function
            is <term>elidable</term>: it is implementation-dependent whether two calls with the
            same arguments will return the same node or distinct nodes.</p>
         
         <p>The name of the returned attribute node is given by <code>$name</code>.</p>
         
         <p>The string value of the returned attribute node is the value of <code>$content</code>.</p>
         
         <p>The type annotation of the returned attribute is <code>xs:untypedAtomic</code>.</p>
         
      </fos:rules>
   </fos:function>
   
   <fos:function name="new-element">
      <fos:signatures>
         <fos:proto name="new-element" return-type="comment()">
            <fos:arg name="namespaces" type="namespace-node()*"/>
            <fos:arg name="attributes" type="attribute()*"/>
            <fos:arg name="content" type="node()*"/>
         </fos:proto>
      </fos:signatures>
      
      <fos:summary>
         <p>Constructs a new element node with given name and content.</p>
      </fos:summary>
      <fos:rules>
         
         <p>The result of the function is typically a new parentless element node. However, the function
            is <term>elidable</term>: it is implementation-dependent whether two calls with the
            same arguments will return the same node or distinct nodes.</p>
         
         <p>The name of the returned element node is given by <code>$name</code>.</p>
         
         <p>[TBA] more detail needed.</p>
         
      </fos:rules>
   </fos:function>
   
   <fos:function name="new-namespace">
      <fos:signatures>
         <fos:proto name="new-namespace" return-type="namespace-node()">
            <fos:arg name="name" type="xs:string"/>
            <fos:arg name="content" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      
      <fos:summary>
         <p>Constructs a new namespace node with given name and content.</p>
      </fos:summary>
      <fos:rules>
         
         <p>The result of the function is typically a new namespace node. However, the function
            is <term>elidable</term>: it is implementation-dependent whether two calls with the
            same arguments will return the same node or distinct nodes.</p>
         
         <p>The name of the returned namespace node (that is, the namespace prefix) 
            is given by <code>$name</code>. </p>
         
         <p>The string value of the returned namespace node is the value of <code>$content</code>.</p>
         
         
      </fos:rules>
      <fos:errors>
         <p>It is an error if the <code>$name</code> attribute is not one of (a) a zero-length string,
         or (b) a string that is castable to <code>xs:NCName</code>.</p>
      </fos:errors>
   </fos:function>
   
   <fos:function name="new-text">
      <fos:signatures>
         <fos:proto name="new-text" return-type="text()">
            <fos:arg name="content" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      
      <fos:summary>
         <p>Constructs a new text node with given content.</p>
      </fos:summary>
      <fos:rules>
         
         <p>The result of the function is typically a new text node. However, the function
            is <term>elidable</term>: it is implementation-dependent whether two calls with the
            same arguments will return the same node or distinct nodes.</p>
         
         <p>The string value of the returned text node is the value of <code>$content</code>.</p>
         
 
      </fos:rules>
      
 
      
      
   </fos:function>-->
   
   
   
   


   
 


</fos:functions>
