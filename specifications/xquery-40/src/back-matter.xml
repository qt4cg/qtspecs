<?xml version="1.0" encoding="utf-8"?>
<div1 id="id-type-promotion-and-operator-mapping">
<head>Type Promotion and Operator Mapping</head>

<div2 id="promotion">
<head>Type Promotion</head>

<p><termdef term="type promotion" id="dt-type-promotion">Under certain circumstances, an atomic value can be promoted from
one type to another. <term>Type promotion</term> is used in evaluating function calls (see <specref ref="id-function-calls"/>)<phrase role="xquery">, <code>order by</code> clauses (see <specref ref="id-order-by-clause"/>),</phrase>  and operators that accept numeric or string operands (see <specref ref="mapping"/>).</termdef> The following type promotions are permitted:</p>

<olist>
<item><p>Numeric type promotion:</p><olist>
<item><p>A value of type <code>xs:float</code> (or any type
derived by restriction from <code>xs:float</code>) can be promoted to
the type <code>xs:double</code>. The result is the
<code>xs:double</code> value that is the same as the original
value.</p></item>


<item><p>A value of type <code>xs:decimal</code> (or any type derived
by restriction from <code>xs:decimal</code>) can be promoted to either
of the types <code>xs:float</code> or <code>xs:double</code>.  The
result of this promotion is created by casting the original value to
the required type. This kind of promotion may cause loss of
precision.</p></item></olist></item>
<item><p>URI type promotion: A value of type <code>xs:anyURI</code> (or any type derived by restriction from <code>xs:anyURI</code>) can be promoted to the type <code>xs:string</code>. The result of this promotion is created by casting the original value to the type <code>xs:string</code>.</p><note><p>Since <code>xs:anyURI</code> values can be promoted to <code>xs:string</code>, functions and operators that compare strings using the <termref def="dt-def-collation">default collation</termref> also compare <code>xs:anyURI</code> values using the <termref def="dt-def-collation">default collation</termref>. This ensures that orderings that include strings, <code>xs:anyURI</code> values, or any combination of the two types are consistent and well-defined.</p></note></item>


</olist>
<p>Note that <termref def="dt-type-promotion">type promotion</termref> is different from <termref def="dt-subtype-substitution">subtype substitution</termref>. For example:</p><ulist>
<item><p>A function that expects a parameter <code>$p</code> of type <code>xs:float</code> can be invoked with a value of type <code>xs:decimal</code>. This is an example of <termref def="dt-type-promotion">type promotion</termref>. The value is actually converted to the expected type. Within the body of the function, <code>$p instance of xs:decimal</code> returns <code>false</code>.</p></item>
<item><p>A function that expects a parameter <code>$p</code> of type <code>xs:decimal</code> can be invoked with a value of type <code>xs:integer</code>. This is an example of <termref def="dt-subtype-substitution">subtype substitution</termref>. The value retains its original type. Within the body of the function, <code>$p instance of xs:integer</code> returns <code>true</code>.</p></item></ulist></div2>

<div2 id="mapping">
<head>Operator Mapping</head> <p>The operator mapping tables in this section list the
combinations of types for which the various operators of &language;
are defined. <termdef term="operator function" id="dt-operator-function">For each operator and valid combination of operand types, the operator mapping tables specify a result type and an <term>operator function</term> that implements the semantics of the operator for the given types.</termdef> The definitions of the operator functions are given in  <bibref ref="xpath-functions-40"/>. The result of an operator may be the raising of an error by its operator function, as defined in <bibref ref="xpath-functions-40"/>. The operator function fully defines the semantics of a given operator for the case where the operands are single atomic values of the types given in the table. For the definition of each operator (including its
behavior for empty sequences or sequences of length greater than one),
see the descriptive material in the main part of this
document.</p>
  
  <p>The <code>and</code> and
<code>or</code> operators are defined directly in the main body of
this document, and do not occur in the operator mapping table.</p>
  
  <p diff="chg" at="A">The operators <code>ne</code>, <code>le</code>, <code>gt</code>, and <code>ge</code> do not
  occur in the operator mapping table, but are instead defined by the following equivalences:</p>
  
  <ulist diff="chg" at="A">
    <item><p><code>A ne B</code> is equivalent to <code>not(A eq B)</code></p></item>
    <item><p><code>A le B</code> is equivalent to <code>A lt B or A eq B</code></p></item>
    <item><p><code>A gt B</code> is equivalent to <code>B lt A</code></p></item>
    <item><p><code>A ge B</code> is equivalent to <code>B lt A or B eq A</code></p></item>
  </ulist>
  
  <p>If an operator in the operator mapping tables expects an operand of type
<emph>ET</emph>, that operator can be applied to an operand of type <emph>AT</emph> if type <emph>AT</emph> can
be converted to type <emph>ET</emph> by a combination of <termref def="dt-type-promotion">type promotion</termref> and <termref def="dt-subtype-substitution">subtype substitution</termref>. For example, a table entry indicates that the <code>gt</code> operator may
be applied to two <code>xs:date</code> operands, returning
<code>xs:boolean</code>. Therefore, the <code>gt</code> operator may
also be applied to two (possibly different) subtypes of
<code>xs:date</code>, also returning <code>xs:boolean</code>.</p>

<p><termdef id="dt-numeric" term="numeric">When referring to a type, the term <term>numeric</term> denotes the types
<code>xs:integer</code>, <code>xs:decimal</code>,
<code>xs:float</code>, and <code>xs:double</code> which are all member types of the built-in union type <code>xs:numeric</code>.</termdef> An operator whose
operands and result are designated as <termref def="dt-numeric">numeric</termref> might be
thought of as representing four operators, one for each of the numeric
types. For example, the numeric <code>+</code> operator might be
thought of as representing the following four operators:</p>


<table width="80%" role="medium"><tbody>
<tr><th align="center">Operator</th><th align="center">First operand type</th><th align="center">Second operand type</th><th align="center">Result type</th></tr>
<tr><td align="center"><code>+</code></td><td align="center"><code>xs:integer</code></td><td align="center"><code>xs:integer</code></td><td align="center"><code>xs:integer</code></td></tr>
<tr><td align="center"><code>+</code></td><td align="center"><code>xs:decimal</code></td><td align="center"><code>xs:decimal</code></td><td align="center"><code>xs:decimal</code></td></tr>
<tr><td align="center"><code>+</code></td><td align="center"><code>xs:float</code></td><td align="center"><code>xs:float</code></td><td align="center"><code>xs:float</code></td></tr>
<tr><td align="center"><code>+</code></td><td align="center"><code>xs:double</code></td><td align="center"><code>xs:double</code></td><td align="center"><code>xs:double</code></td></tr></tbody></table><p>A numeric operator may be validly applied to an operand of type <emph>AT</emph> if type
<emph>AT</emph> can be converted to any of the four numeric types by a combination of
<termref def="dt-type-promotion">type promotion</termref> and <termref def="dt-subtype-substitution">subtype substitution</termref>. If the result type of an
operator is listed as numeric, it means "the first type in the ordered list <code>(xs:integer, xs:decimal, xs:float, xs:double)</code> into which all operands can be converted by <termref def="dt-subtype-substitution">subtype substitution</termref> and <termref def="dt-type-promotion">type promotion</termref>." As an example, suppose that the type <code>hatsize</code> is derived from <code>xs:integer</code> and the type <code>shoesize</code> is derived from <code>xs:float</code>.   Then if the <code>+</code> operator is invoked with operands of type <code>hatsize</code> and <code>shoesize</code>, it returns a result of type <code>xs:float</code>.  Similarly, if <code>+</code> is invoked with two operands of type <code>hatsize</code> it returns a result of type <code>xs:integer</code>.</p><p><termdef id="dt-gregorian" term="Gregorian">In the operator mapping tables,
the term <term>Gregorian</term> refers to the types
<code>xs:gYearMonth</code>, <code>xs:gYear</code>,
<code>xs:gMonthDay</code>, <code>xs:gDay</code>, and
<code>xs:gMonth</code>.</termdef>  For binary operators that accept two
Gregorian-type operands, both operands must have the same type (for
example, if one operand is of type <code>xs:gDay</code>, the other
operand must be of type <code>xs:gDay</code>.)</p>

<table border="1" role="small">
<caption>Binary Operators</caption>
<tbody>

<tr>
<th>Operator</th>
<th>Type(A)</th>
<th>Type(B)</th>
<th>Function</th>
<th>Result type</th>
</tr>

<tr><td>A + B</td><td>numeric</td><td>numeric</td><td>op:numeric-add(A, B)</td><td>numeric</td></tr>

<tr><td>A + B</td><td>xs:date</td><td>xs:yearMonthDuration</td><td>op:add-yearMonthDuration-to-date(A, B)</td><td>xs:date</td></tr>

<tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:date</td><td>op:add-yearMonthDuration-to-date(B, A)</td><td>xs:date</td></tr>
<tr><td>A + B</td><td>xs:date</td><td>xs:dayTimeDuration</td><td>op:add-dayTimeDuration-to-date(A, B)</td><td>xs:date</td></tr>
<tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:date</td><td>op:add-dayTimeDuration-to-date(B, A)</td><td>xs:date</td></tr>

<tr><td>A + B</td><td>xs:time</td><td>xs:dayTimeDuration</td><td>op:add-dayTimeDuration-to-time(A, B)</td><td>xs:time</td></tr>
<tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:time</td><td>op:add-dayTimeDuration-to-time(B, A)</td><td>xs:time</td></tr>


<tr><td>A + B</td><td>xs:dateTime</td><td>xs:yearMonthDuration</td><td>op:add-yearMonthDuration-to-dateTime(A, B)</td><td>xs:dateTime</td></tr>
<tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:dateTime</td><td>op:add-yearMonthDuration-to-dateTime(B, A)</td><td>xs:dateTime</td></tr>

<tr><td>A + B</td><td>xs:dateTime</td><td>xs:dayTimeDuration</td><td>op:add-dayTimeDuration-to-dateTime(A, B)</td><td>xs:dateTime</td></tr>
<tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:dateTime</td><td>op:add-dayTimeDuration-to-dateTime(B, A)</td><td>xs:dateTime</td></tr>

<tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td>op:add-yearMonthDurations(A, B)</td><td>xs:yearMonthDuration</td></tr>
<tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td>op:add-dayTimeDurations(A, B)</td><td>xs:dayTimeDuration</td></tr>


<tr><td>A - B</td><td>numeric</td><td>numeric</td><td>op:numeric-subtract(A, B)</td><td>numeric</td></tr>


<tr><td>A - B</td><td>xs:date</td><td>xs:date</td><td>op:subtract-dates(A, B)</td><td>xs:dayTimeDuration</td></tr>
<tr><td>A - B</td><td>xs:date</td><td>xs:yearMonthDuration</td><td>op:subtract-yearMonthDuration-from-date(A, B)</td><td>xs:date</td></tr>
<tr><td>A - B</td><td>xs:date</td><td>xs:dayTimeDuration</td><td>op:subtract-dayTimeDuration-from-date(A, B)</td><td>xs:date</td></tr>

<tr><td>A - B</td><td>xs:time</td><td>xs:time</td><td>op:subtract-times(A, B)</td><td>xs:dayTimeDuration</td></tr>

<tr><td>A - B</td><td>xs:time</td><td>xs:dayTimeDuration</td><td>op:subtract-dayTimeDuration-from-time(A, B)</td><td>xs:time</td></tr>


<tr><td>A - B</td><td>xs:dateTime</td><td>xs:dateTime</td><td>op:subtract-dateTimes(A, B)</td><td>xs:dayTimeDuration</td></tr>
<tr><td>A - B</td><td>xs:dateTime</td><td>xs:yearMonthDuration</td><td>op:subtract-yearMonthDuration-from-dateTime(A, B)</td><td>xs:dateTime</td></tr>
<tr><td>A - B</td><td>xs:dateTime</td><td>xs:dayTimeDuration</td><td>op:subtract-dayTimeDuration-from-dateTime(A, B)</td><td>xs:dateTime</td></tr>

<tr><td>A - B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td>op:subtract-yearMonthDurations(A, B)</td><td>xs:yearMonthDuration</td></tr>
<tr><td>A - B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td>op:subtract-dayTimeDurations(A, B)</td><td>xs:dayTimeDuration</td></tr>


<tr><td>A * B</td><td>numeric</td><td>numeric</td><td>op:numeric-multiply(A, B)</td><td>numeric</td></tr>
<tr><td>A * B</td><td>xs:yearMonthDuration</td><td>numeric</td><td>op:multiply-yearMonthDuration(A, B)</td><td>xs:yearMonthDuration</td></tr>
<tr><td>A * B</td><td>numeric</td><td>xs:yearMonthDuration</td><td>op:multiply-yearMonthDuration(B, A)</td><td>xs:yearMonthDuration</td></tr>
<tr><td>A * B</td><td>xs:dayTimeDuration</td><td>numeric</td><td>op:multiply-dayTimeDuration(A, B)</td><td>xs:dayTimeDuration</td></tr>
<tr><td>A * B</td><td>numeric</td><td>xs:dayTimeDuration</td><td>op:multiply-dayTimeDuration(B, A)</td><td>xs:dayTimeDuration</td></tr>

  <tr><td>A × B</td><td>numeric</td><td>numeric</td><td>op:numeric-multiply(A, B)</td><td>numeric</td></tr>
  <tr><td>A × B</td><td>xs:yearMonthDuration</td><td>numeric</td><td>op:multiply-yearMonthDuration(A, B)</td><td>xs:yearMonthDuration</td></tr>
  <tr><td>A × B</td><td>numeric</td><td>xs:yearMonthDuration</td><td>op:multiply-yearMonthDuration(B, A)</td><td>xs:yearMonthDuration</td></tr>
  <tr><td>A × B</td><td>xs:dayTimeDuration</td><td>numeric</td><td>op:multiply-dayTimeDuration(A, B)</td><td>xs:dayTimeDuration</td></tr>
  <tr><td>A × B</td><td>numeric</td><td>xs:dayTimeDuration</td><td>op:multiply-dayTimeDuration(B, A)</td><td>xs:dayTimeDuration</td></tr>
  

<tr><td>A idiv B</td><td>numeric</td><td>numeric</td><td>op:numeric-integer-divide(A, B)</td><td>xs:integer</td></tr>

  <tr><td>A div B</td><td>numeric</td><td>numeric</td><td>op:numeric-divide(A, B)</td><td>numeric; but xs:decimal if both operands are xs:integer</td></tr>
<tr><td>A div B</td><td>xs:yearMonthDuration</td><td>numeric</td><td>op:divide-yearMonthDuration(A, B)</td><td>xs:yearMonthDuration</td></tr>
<tr><td>A div B</td><td>xs:dayTimeDuration</td><td>numeric</td><td>op:divide-dayTimeDuration(A, B)</td><td>xs:dayTimeDuration</td></tr>
<tr><td>A div B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td>op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td><td>xs:decimal</td></tr>
<tr><td>A div B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td>op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td><td>xs:decimal</td></tr>

  <tr><td>A ÷ B</td><td>numeric</td><td>numeric</td><td>op:numeric-divide(A, B)</td><td>numeric; but xs:decimal if both operands are xs:integer</td></tr>
  <tr><td>A ÷ B</td><td>xs:yearMonthDuration</td><td>numeric</td><td>op:divide-yearMonthDuration(A, B)</td><td>xs:yearMonthDuration</td></tr>
  <tr><td>A ÷ B</td><td>xs:dayTimeDuration</td><td>numeric</td><td>op:divide-dayTimeDuration(A, B)</td><td>xs:dayTimeDuration</td></tr>
  <tr><td>A ÷ B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td>op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td><td>xs:decimal</td></tr>
  <tr><td>A ÷ B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td>op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td><td>xs:decimal</td></tr>
  
<tr><td>A mod B</td><td>numeric</td><td>numeric</td><td>op:numeric-mod(A, B)</td><td>numeric</td></tr>


<tr><td>A eq B</td><td>numeric</td><td>numeric</td><td>op:numeric-equal(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:boolean</td><td>xs:boolean</td><td>op:boolean-equal(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:string</td><td>xs:string</td><td>op:numeric-equal(fn:compare(A, B), 0)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:date</td><td>xs:date</td><td>op:date-equal(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:time</td><td>xs:time</td><td>op:time-equal(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:dateTime</td><td>xs:dateTime</td><td>op:dateTime-equal(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:duration</td><td>xs:duration</td><td>op:duration-equal(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>Gregorian</td><td>Gregorian</td><td>op:gYear-equal(A, B) etc.</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:hexBinary</td><td>xs:hexBinary</td><td>op:hexBinary-equal(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:base64Binary</td><td>xs:base64Binary</td><td>op:base64Binary-equal(A, B)</td><td>xs:boolean</td></tr>


<tr><td>A eq B</td><td>xs:QName</td><td>xs:QName</td><td>op:QName-equal(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:NOTATION</td><td>xs:NOTATION</td><td>op:NOTATION-equal(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:hexBinary</td><td>xs:hexBinary</td><td>op:hexBinary-equal(A, B)</td><td>xs:boolean</td></tr>
<tr><td>A eq B</td><td>xs:base64Binary</td><td>xs:base64Binary</td><td>op:hexBinary-equal(A, B)</td><td>xs:boolean</td></tr>



<tr><td>A lt B</td><td>numeric</td><td>numeric</td><td>op:numeric-less-than(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:boolean</td><td>xs:boolean</td><td>op:boolean-less-than(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:string</td><td>xs:string</td><td>op:numeric-less-than(fn:compare(A, B), 0)</td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:date</td><td>xs:date</td><td>op:date-less-than(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:time</td><td>xs:time</td><td>op:time-less-than(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:dateTime</td><td>xs:dateTime</td><td>op:dateTime-less-than(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td>op:yearMonthDuration-less-than(A, B)</td><td>xs:boolean</td></tr>
<tr><td>A lt B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td>op:dayTimeDuration-less-than(A, B)</td><td>xs:boolean</td></tr>
<tr><td>A lt B</td><td>xs:hexBinary</td><td>xs:hexBinary</td><td>op:hexBinary-less-than(A, B)</td><td>xs:boolean</td></tr>
<tr><td>A lt B</td><td>xs:base64Binary</td><td>xs:base64Binary</td><td>op:base64Binary-less-than(A, B)</td><td>xs:boolean</td></tr>




</tbody>
</table>

<table border="1" role="small">
<caption>Unary Operators</caption>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Operand type</th>
      <th>Function</th>
      <th>Result type</th>
    </tr>
  </thead>
<tbody>



<tr><td>+ A</td><td>numeric</td><td>op:numeric-unary-plus(A)</td><td>numeric</td></tr>

<tr><td>- A</td><td>numeric</td><td>op:numeric-unary-minus(A)</td><td>numeric</td></tr>
</tbody>
</table>


</div2>
  
  <!--<div2 id="id-math-symbols" diff="add" at="A">
    <head>Mathematical Operator Symbols</head>
    <p>Various operators written in the grammar using alphabetic keywords (such as <code>and</code>, <code>or</code>,
    <code>le</code>, <code>ge</code>) can instead be written using mathematical symbols. The equivalents are given
    in the table below:</p>
    
    <table border="1">
      <caption>Mathematical Operator Symbols</caption>
      <thead>
        <tr>
          <th>Operator</th>
          <th>Symbol</th>
          <th>Codepoint</th>
        </tr>
      </thead>
      <tbody>
        
        <tr>
          <td>and</td>
          <td>∧</td>
          <td>x2227</td>
        </tr>
        <tr>
          <td>or</td>
          <td>∨</td>
          <td>x2228</td>
        </tr>
        <tr>
          <td>eq</td>
          <td>≐</td>
          <td>x2250</td>
        </tr>
        <tr>
          <td>ne</td>
          <td>≠</td>
          <td>x2260</td>
        </tr>
        <tr>
          <td>lt</td>
          <td>⋖</td>
          <td>x22D6</td>
        </tr>
        <tr>
          <td>gt</td>
          <td>⋗</td>
          <td>x22D7</td>
        </tr>
        <tr>
          <td>le</td>
          <td>≤</td>
          <td>x2264</td>
        </tr>
        <tr>
          <td>ge</td>
          <td>≥</td>
          <td>x2265</td>
        </tr>
        <tr>
          <td>div</td>
          <td>÷</td>
          <td>xF7</td>
        </tr>
        <tr>
          <td>mod</td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>idiv</td>
          <td>⨸</td>
          <td>x2A38</td>
        </tr>
        <tr>
          <td>union (|)</td>
          <td>∪</td>
          <td>x222A</td>
        </tr>
        <tr>
          <td>intersect</td>
          <td>∩</td>
          <td>x2229</td>
        </tr>
        <tr>
          <td>except</td>
          <td>∖</td>
          <td>x2216</td>
        </tr>
        <tr>
          <td>is</td>
          <td>≡</td>
          <td>x2261</td>
        </tr>        
        <tr>
          <td>&lt;&lt; (precedes)</td>
          <td>≪</td>
          <td>x226A</td>
        </tr>
        <tr>
          <td>>> (follows)</td>
          <td>≫</td>
          <td>x226B</td>
        </tr>
        <tr>
          <td>otherwise</td>
          <td>⊩</td>
          <td>x22A9</td>
        </tr>
        <tr>
          <td>some</td>
          <td>∃</td>
          <td>x2203</td>
        </tr>
        <tr>
          <td>every</td>
          <td>∀</td>
          <td>x2200</td>
        </tr>
        <tr>
          <td>satisfies</td>
          <td>⧴</td>
          <td>x29F4</td>
        </tr>
      </tbody>
    </table>
    <p>For example, the expression <code>some $x in $X satisfies $x le 17</code> can equivalently be written
      <code>∃ $x in $X ⧴ $x ≤ 17</code></p>
  </div2>-->
</div1>

<div1 role="xquery" id="id-xq-context-components">
  <head>Context Components</head>

  <p>The tables in this section describe how values are assigned to
  the various components of the static context and dynamic context,
  and to the parameters that control the serialization process.</p>


<div2 id="id-xq-static-context-components">
<head>Static Context Components</head>

<p>The following table describes the components of the <term>static context</term>. The following aspects of each component are described:</p>

<ulist>
<item><p><emph>Default initial value:</emph> This is the
initial value of the component if it is not overridden or augmented by
the implementation or by a query.</p> </item>
<item><p><emph>Can be
overwritten or augmented by implementation:</emph> Indicates whether
an XQuery implementation is allowed to replace the default initial
value of the component by a different, <termref
def="dt-implementation-defined">implementation-defined</termref> value
and/or to augment the default initial value by additional <termref
def="dt-implementation-defined">implementation-defined</termref>
values.</p></item>
<item><p>
<emph>Can be overwritten or augmented by prolog:</emph>
Indicates whether there are prolog declarations that can replace and/or augment
the initial value provided by default or by the implementation.
</p></item>
<item><p>
<emph>Can be overwritten or augmented by expressions:</emph>
Indicates whether there are expressions that can replace and/or augment
the value of the component for their subexpressions.
</p></item>
<item><p><emph>Consistency
Rules:</emph> Indicates rules that must be observed in assigning
values to the component. Additional consistency rules may be found in
<specref ref="id-consistency-constraints"/>.</p></item></ulist>

<table width="100%" border="1" role="small">
<caption>Static Context Components</caption>
<tbody>
<!-- First group: can be overwritten/augmented by expressions -->
<tr>
<th>Component</th>
<th>Default initial value</th>
<th>Can be overwritten or augmented by implementation?</th>
<th>Can be overwritten or augmented by prolog?</th>
<th>Can be overwritten or augmented by expressions?</th>
<th>Consistency rules</th>
</tr>
<tr>
<td>Statically known namespaces</td>
<td><code>fn</code>, <code>xml</code>, <code>xs</code>, <code>xsi</code>,  <code>local</code></td>
<td>overwriteable and augmentable (except for <code>xml</code>)</td>
<td>overwriteable and augmentable by <specref ref="id-namespace-declaration"/></td>
<td>overwriteable and augmentable by element constructor</td>
<td>Only one namespace can be assigned to a given prefix
per lexical scope.</td>
</tr>
<tr><td>Default element/type namespace</td>
  <td>no namespace</td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-default-namespace"/></td>
  <td>overwriteable by element constructor</td>
  <td>Only one default namespace per lexical scope.</td></tr>

<tr>
  <td>In-scope variables</td>
  <td>none</td>
  <td>augmentable</td>
  <td>overwriteable and augmentable by <specref ref="id-variable-declarations"/> and  <specref ref="id-inline-func"/>, augmentable by <specref ref="id-module-import"/></td>
  <td>overwriteable and augmentable by variable-binding expressions</td>
  <td>Only one definition per variable per lexical scope.</td></tr>

<tr>
  <td>Context value static type</td>
  <td>item()</td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-context-value-declarations"/></td>
  <td>overwriteable by expresssions that set the context value</td>
  <td>None.</td></tr>
<tr>
  <td>Ordering mode</td>
  <td><code>ordered</code></td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-default-ordering-decl"/></td>
  <td>overwriteable by expression</td>
  <td>Value must be <code>ordered</code> or <code>unordered</code>.</td></tr>

<!-- Second group: can be overwritten/augmented by (decls in) prologs,
     but not by expressions -->

<tr>
  <td>Default function namespace</td>
  <td><code>fn</code></td>
  <td>overwriteable (not recommended)</td>
  <td>overwriteable by <specref ref="id-default-namespace"/></td>
  <td>no</td>
  <td>None.</td></tr>
<tr>
  <td>In-scope schema types</td>
  <td>built-in types in <code>xs</code></td>
  <td>augmentable</td>
  <td>augmentable by <specref ref="id-schema-import"/></td>
  <td>no</td>
  <td>Only one definition per global or local type.</td></tr>
<tr>
  <td>In-scope element declarations</td>
  <td>none</td>
  <td>augmentable</td>
  <td>augmentable by  <specref ref="id-schema-import"/></td>
  <td>no</td>
  <td>Only one definition per global or local element name.</td></tr>
<tr>
  <td>In-scope attribute declarations</td>
  <td>none</td>
  <td>augmentable</td>
  <td>augmentable by  <specref ref="id-schema-import"/></td>
  <td>no</td>
  <td>Only one definition per global or local attribute name.</td></tr>
<tr>
  <td>Statically known function signatures</td>
  <td>the signatures of the <termref def="dt-system-function">system functions</termref></td>
  <td>augmentable</td>
  <td>augmentable by  <specref ref="id-module-import"/> and by  <specref ref="FunctionDeclns"/>; augmentable by  <specref ref="id-schema-import"/> (which adds constructor functions for user-defined types)</td>
  <td>no</td>
  <td>Each function must have a unique <termref def="dt-expanded-qname">expanded QName</termref> and number of arguments.</td></tr>
<tr>
  <td>Default collation</td>
  <td>Unicode codepoint collation</td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-default-collation-declaration"/></td>
  <td>no</td>
  <td>None.</td></tr>
<tr>
  <td>Construction mode</td>
  <td><code>preserve</code></td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-construction-declaration"/></td>
  <td>no</td>
  <td>Value must be <code>preserve</code> or <code>strip</code>. </td></tr>
<tr>
  <td>Default order for empty sequences</td>
  <td>implementation-defined</td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-empty-order-decl"/></td>
  <td>no</td>
  <td>Value must be <code>greatest</code> or <code>least</code>.</td></tr>
<tr>
  <td>Boundary-space policy</td>
  <td><code>strip</code></td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-boundary-space-decls"/></td>
  <td>no</td>
  <td>Value must be <code>preserve</code> or <code>strip</code>. </td></tr>
<tr>
  <td>Copy-namespaces mode</td>
  <td><code>inherit, preserve</code></td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-copy-namespaces-decl"/></td>
  <td>no</td>
  <td>Value consists of <code>inherit</code> or <code>no-inherit</code>, and <code>preserve</code> or <code>no-preserve</code>.</td></tr>
<tr>
  <td>Static Base URI</td>
  <td>See rules in <specref ref="id-base-uri-decl"/></td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-base-uri-decl"/></td>
  <td>no</td>
  <td>Value must be a valid lexical representation of the type xs:anyURI.</td></tr>

  <tr>
    <td>Statically known decimal formats</td>
    <td>the default (unnamed) decimal format, which has an implementation-dependent value</td>
    <td>augmentable</td>
    <td>augmentable, using <termref def="dt-decimal-format-decl">decimal format declarations</termref></td>
    <td>no</td>
    <td>each QName uniquely identifies a decimal format</td></tr>


<!-- Third group: cannot be overwritten/augmented by expressions or
     declarations in prologs -->

<tr>
  <td>Statically known documents</td>
  <td>none</td>
  <td>augmentable</td>
  <td>no</td>
  <td>no</td>
  <td>None.</td></tr>
<tr>
  <td>Statically known collections</td>
  <td>none</td>
  <td>augmentable</td>
  <td>no</td>
  <td>no</td>
  <td>None.</td></tr>
<tr>
  <td>Statically known default collection type</td>
  <td><code>item()*</code></td>
  <td>overwriteable</td>
  <td>no</td>
  <td>no</td>
  <td>None.</td></tr>
<tr>
  <td>Statically known collations</td>
  <td>only the default collation</td>
  <td>augmentable</td>
  <td>no</td>
  <td>no</td>
  <td>Each URI uniquely identifies a collation.</td></tr>
<tr>
  <td>XPath 1.0 Compatibility Mode</td>
  <td><code>false</code></td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>Must be <code>false</code>.</td>
</tr>

 <!-- Serialization parameters -->
<tr>
<th colspan="6">Serialization Parameters</th>
</tr>

<tr>
  <td>allow-duplicate-names</td>
  <td>no</td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>

<tr>
  <td>byte-order-mark</td>
  <td>implementation-defined</td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>
<tr>
  <td>cdata-section-elements</td>
  <td>empty</td>
  <td>overwriteable and augmentable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>
<tr>
  <td>doctype-public</td>
  <td>none</td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>
<tr>
  <td>doctype-system</td>
  <td>none</td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>
<tr>
  <td>encoding</td>
  <td>implementation-defined choice between <code>"utf-8"</code> and <code>"utf-16"</code></td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>
  <tr>
    <td>escape-solidus</td>
    <td>yes</td>
    <td>overwriteable and augmentable</td>
    <td>overwriteable by prolog</td>
    <td>yes</td>
    <td><xspecref spec="SER31" ref="serparam"/></td></tr>  
<tr>
  <td>escape-uri-attributes</td>
  <td>yes</td>
  <td>overwriteable and augmentable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>

<tr>
  <td>html-version</td>
  <td>implementation-defined</td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>


<tr>
  <td>include-content-type</td>
  <td>yes</td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>
<tr>
  <td>indent</td>
  <td>no</td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>

<tr>
  <td>item-separator</td>
  <td>implementation-defined</td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>


<tr>
  <td>json-node-output-method</td>
  <td>xml</td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>

<tr>
  <td>media-type</td>
  <td>implementation-defined</td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>
<tr>
  <td>method</td>
  <td>xml</td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>
<tr>
  <td>normalization-form</td>
  <td>implementation-defined</td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>
<tr>
  <td>omit-xml-declaration</td>
  <td>implementation-defined</td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>
<tr>
  <td>standalone</td>
  <td>implementation-defined</td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>
<tr>
  <td>suppress-indentation</td>
  <td>empty</td>
  <td>overwriteable and augmentable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>
<tr>
  <td>undeclare-prefixes</td>
  <td>no</td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>
<tr>
  <td>use-character-maps</td>
  <td>empty</td>
  <td>overwriteable and augmentable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>
<tr>
  <td>version</td>
  <td>implementation-defined</td>
  <td>overwriteable</td>
  <td>overwriteable by prolog</td>
  <td>no</td>
  <td><xspecref spec="SER31" ref="serparam"/></td></tr>
</tbody>
</table></div2>
<div2 id="id-xq-evaluation-context-components">
  <head>Dynamic Context Components</head>

  <p>The following table describes the components of the <term>dynamic context</term>. The following aspects of each component are described:</p><ulist>
<item><p><emph>Default initial value:</emph> This is the initial value of the component if it is not overridden or augmented by the implementation or by a query.</p> </item>
<item><p><emph>Can be overwritten or augmented by implementation:</emph> Indicates whether an XQuery implementation is allowed to replace the default initial value of the component by a different <termref def="dt-implementation-defined">implementation-defined</termref> value and/or to augment the default initial value by additional <termref def="dt-implementation-defined">implementation-defined</termref> values.</p></item>
<item><p><emph>Can be overwritten or augmented by prolog:</emph>
Indicates whether there are prolog declarations that can replace and/or augment
the initial value provided by default or by the implementation.</p></item>
<item><p><emph>Can be overwritten or augmented by expressions:</emph>
Indicates whether there are expressions that can replace and/or augment
the value of the component for their subexpressions.</p></item>
<item><p><emph>Consistency Rules:</emph> Indicates rules that must be observed in assigning values to the component. Additional consistency rules may be found in <specref ref="id-consistency-constraints"/>.</p></item></ulist><table width="100%" border="1" role="small">
<caption>Dynamic Context Components</caption>
<tbody>

<tr>
<th>Component</th>

<th>Default initial value</th>

<th>Can be overwritten or augmented by implementation?</th>

<th>Can be overwritten or augmented by prolog?</th>

<th>Can be overwritten or augmented by expressions?</th>

<th>Consistency rules</th>
</tr>

<tr>
  <td>Context value</td>
  <td>none</td>
  <td>overwriteable</td>
  <td>overwriteable by a  <specref ref="id-context-value-declarations"/> in the main module
  </td>
  <td>overwritten during evaluation of path expressions and predicates</td>
  <td>Must be the same in the dynamic context of every module in a query.
  </td>
</tr>
<tr>
  <td>Context position</td>
  <td>none</td>
  <td>overwriteable</td>
  <td>overwriteable by a  <specref ref="id-context-value-declarations"/> in the main module
  </td>
  <td>overwritten during evaluation of path expressions and predicates</td>
  <td>If context value is defined, context position must be &gt;0 and &lt;= context size; else  context position is <xtermref spec="DM31" ref="dt-absent"/>. </td>
</tr>
<tr>
  <td>Context size</td>
  <td>none
  </td>
  <td>overwriteable</td>
  <td>overwriteable by a  <specref ref="id-context-value-declarations"/> in the main module
      
  </td>
  <td>overwritten during evaluation of path expressions and predicates</td>
  <td>If context value is defined, context size must be &gt;0; else context size is <xtermref spec="DM31" ref="dt-absent"/>.</td></tr>


<tr>
  <td>Variable values</td>
  <td>none</td>
  <td>augmentable</td>
  <td>overwriteable and augmentable by  <specref ref="id-variable-declarations"/>  and  <specref ref="id-inline-func"/>, augmentable by <specref ref="id-module-import"/></td>
  <td>overwriteable and augmentable by variable-binding expressions</td>
  <td>Names and values must be consistent with in-scope variables.</td>
</tr>
<tr>
  <td>Named functions</td>
  <td>the <termref def="dt-system-function">system functions</termref></td>
  <td>augmentable</td>
  <td>augmentable by 
 <specref ref="FunctionDeclns"/>, 
<specref ref="id-module-import"/>,
and
<specref ref="id-schema-import"/> ( (which adds constructor functions for user-defined types)</td>
  <td>no</td>
  <td>Must be consistent with statically known function signatures</td>
</tr>
<tr>
  <td>Current dateTime</td>
  <td>none</td>
  <td>must be initialized <phrase role="xquery">by implementation</phrase></td>
  <td>no</td>
  <td>no</td>
  <td>Must include a timezone. Remains constant during evaluation of a query.</td></tr>
<tr>
  <td>Implicit timezone</td>
  <td>none</td>
  <td>must be initialized <phrase role="xquery">by implementation</phrase></td>
  <td>no</td>
  <td>no</td>
  <td>Remains constant during evaluation of a query.</td></tr>
<tr>
  <td>Available documents</td>
  <td>none</td>
  <td>must be initialized <phrase role="xquery">by implementation</phrase></td>
  <td>no</td>
  <td>no</td>
  <td>None</td></tr>
<tr>
  <td>Available text resources</td>
  <td>none</td>
  <td>must be initialized <phrase role="xquery">by implementation</phrase></td>
  <td>no</td>
  <td>no</td>
  <td>None</td></tr>
<tr>
  <td>Available collections</td>
  <td>none</td>
  <td>must be initialized <phrase role="xquery">by implementation</phrase></td>
  <td>no</td>
  <td>no</td>
  <td>None</td></tr>
<tr>
  <td>Default collection</td>
  <td>none</td>
  <td>overwriteable</td>
  <td>no</td>
  <td>no</td>
  <td>None</td></tr>
  <tr>
    <td>Available URI collections</td>
    <td>none</td>
    <td>must be initialized <phrase role="xquery">by implementation</phrase></td>
    <td>no</td>
    <td>no</td>
    <td>None</td></tr>
  <tr>
    <td>Default URI collection</td>
    <td>none</td>
    <td>overwriteable</td>
    <td>no</td>
    <td>no</td>
    <td>None</td></tr>  
</tbody>
</table></div2>
</div1>
<div1 id="id-xp-context-components" role="xpath"><head>Context Components</head><p>The tables in this
section describe the scope (range of applicability) of the various
components in a module's static context and dynamic context.</p>

<div2 id="id-xp-static-context-components"><head>Static Context
Components</head><p>The following table describes the components of
the <term>static context</term>. For each component, “global”
indicates that the value of the component applies throughout an XPath
expression, whereas “lexical” indicates that the value of the
component applies only within the subexpression in which it is
defined.</p>

<table width="60%" border="1" role="small">

<caption>Static Context Components</caption>
<tbody>

<tr>
<th>Component</th>
<th>Scope</th>
</tr>

<tr>
  <td>XPath 1.0 Compatibility Mode</td>
  <td>global</td>
</tr>
<tr>
  <td>Statically known namespaces</td>
  <td>global</td>
</tr>
<tr>
  <td>Default element/type namespace</td>
  <td>global</td></tr>
<tr>
  <td>Default function namespace</td>
  <td>global</td></tr>
<tr>
  <td>In-scope schema types</td>
  <td>global</td></tr>
<tr>
  <td>In-scope element declarations</td>
  <td>global</td></tr>
<tr>
  <td>In-scope attribute declarations</td>
  <td>global</td></tr>
<tr>
  <td>In-scope variables</td>
  <td>lexical; for-expressions, let-expressions, and quantified expressions can bind new variables</td></tr>
<tr>
  <td>Context value static type</td>
  <td>lexical</td></tr>
<tr>
  <td>Statically known function signatures</td>
  <td>global</td></tr>
<tr>
  <td>Statically known collations</td>
  <td>global</td></tr>
<tr>
  <td>Default collation</td>
  <td>global</td></tr>
<tr>
  <td>Base URI</td>
  <td>global</td></tr>
<tr>
  <td>Statically known documents</td>
  <td>global</td></tr>
<tr>
  <td>Statically known collections</td>
  <td>global  </td></tr>
<tr>
  <td>Statically known default collection type</td>
  <td>global</td></tr>
</tbody>
</table></div2>

<div2 id="id-xp-evaluation-context-components">
  <head>Dynamic Context Components</head>
  <p>The following table describes how values are assigned to the various components of the
    <term>dynamic context</term>. All these components are initialized by mechanisms
    defined by the host language. For each component, “global” indicates that the value
    of the component remains constant throughout evaluation of the XPath expression,
    whereas “dynamic” indicates that the value of the component can be modified by the
    evaluation of subexpressions.</p>
<table width="60%" border="1" role="small">
<caption>Dynamic Context Components</caption>
<tbody>

<tr>
<th>Component</th>



<th>Scope</th>
</tr>

<tr>
  <td>Context value</td>
  <td>dynamic; changes during evaluation of path expressions and predicates</td>
</tr>
<tr>
  <td>Context position</td>
  <td>dynamic; changes during evaluation of path expressions and predicates</td>
</tr>
<tr>
  <td>Context size</td>
  <td>dynamic; changes during evaluation of path expressions and predicates</td></tr>
<tr>
  <td>Variable values</td>
  <td>dynamic; for-expressions, let-expressions, and quantified expressions can bind new variables</td></tr>
<tr>
  <td>Current date and time</td>
  <td>global; must be initialized <phrase role="xquery">by implementation</phrase></td></tr>
<tr>
  <td>Implicit timezone</td>
  <td>global; must be initialized <phrase role="xquery">by implementation</phrase></td></tr>
<tr>
  <td>Available documents</td>
  <td>global; must be initialized <phrase role="xquery">by implementation</phrase></td></tr>
<tr>
  <td>Available node collections</td>
  <td>global; must be initialized <phrase role="xquery">by implementation</phrase></td></tr>
<tr>
  <td>Default collection</td>
  <td>global; overwriteable by implementation</td></tr>
  <tr>
    <td>Available URI collections</td>
    <td>global; must be initialized <phrase role="xquery">by implementation</phrase></td></tr>
  <tr>
    <td>Default URI collection</td>
    <td>global; overwriteable by implementation</td></tr>  
</tbody>
</table></div2></div1>
<div1 id="id-impl-defined-items"><head>Implementation-Defined Items</head><p>The following items in this specification are <termref def="dt-implementation-defined">implementation-defined</termref>:</p><olist>
<item><p>The version of Unicode that is used to construct expressions.</p></item>
<item><p>The <termref def="dt-static-collations">statically-known collations</termref>.</p></item>
<item><p>The <termref def="dt-timezone">implicit timezone</termref>.</p></item>
<item><p>The circumstances in which <termref def="dt-warning">warnings</termref> are raised, and the ways in which warnings are handled.</p></item>
<item><p>The method by which errors are reported to the external processing environment.</p></item>

<item><p>Which version of XML and XML Names (e.g. <bibref ref="XML"/> and <bibref ref="XMLNAMES"/> or <bibref ref="XML1.1"/> and <bibref ref="XMLNAMES11"/>) and which version of XML Schema (e.g. <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/>) is used for the definitions of primitives such as characters and names, and for the definitions  of operations such as normalization of line endings and normalization of whitespace in attribute values. It is recommended that the latest applicable version be used (even if it is published later than this specification).</p></item>

<item><p>How XDM instances are created from sources other than an Infoset or PSVI.</p></item>
<item role="xquery"><p>Any components of the <termref def="dt-static-context">static context</termref> or <termref def="dt-dynamic-context">dynamic context</termref> that are overwritten or augmented by the implementation.</p></item><item role="xpath"><p>Whether the implementation supports the namespace axis.</p></item>
<item role="xquery"><p>The default handling of empty sequences returned by an ordering key (orderspec) in an <code>order by</code> clause (<code>empty least</code> or <code>empty greatest</code>).</p></item><item role="xquery"><p>The names and semantics of any <termref def="dt-extension-expression">extension expressions</termref> (<termref def="dt-pragma">pragmas</termref>) recognized by the implementation.</p></item><item role="xquery"><p>The names and semantics of any <termref def="dt-option-declaration">option declarations</termref>  recognized by the implementation.</p></item><item role="xquery"><p>Protocols (if any) by which parameters can be passed to an external function, and the result of the function can returned to the invoking query.</p></item><item role="xquery"><p>The process by which the specific modules to be imported by a
<termref def="dt-module-import">module import</termref> are identified, if the <termref def="dt-module-feature">Module Feature</termref> is supported (includes processing of location hints, if any.)</p></item>

<item role="xquery"><p>The means by which serialization is invoked, if the <termref def="dt-serialization-feature">Serialization Feature</termref> is supported.</p></item><item role="xquery"><p>The default values for the <code>byte-order-mark</code>, <code>encoding</code>, <code>html-version</code>, <code>item-separator</code>, <code>media-type</code>, <code>normalization-form</code>, <code>omit-xml-declaration</code>, <code>standalone</code>, and <code>version</code> parameters, if the <termref def="dt-serialization-feature">Serialization Feature</termref> is supported.</p></item><item role="xquery"><p>The result of an unsuccessful call to an external function (for example,
if the function implementation cannot be found or does not return a value
of the declared type).</p></item><item role="xquery"><p>Limits on ranges of values for various data types, as enumerated in <specref ref="id-data-model-conformance"/>.</p></item>

<item role="xquery"><p>Syntactic extensions to XQuery, including both their syntax and semantics, as discussed in <specref ref="id-syntax-extensions"/>.</p></item>

<item><p>Whether the type system is based on <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/>. An implementation that has based its type system on XML Schema 1.0 is not required to support the use of the <code>xs:dateTimeStamp</code> constructor or the use of <code>xs:dateTimeStamp</code> or <code>xs:error</code> as <nt def="TypeName">TypeName</nt> in any expression.</p></item>

<item><p>The signatures of functions provided by the implementation or via an implementation-defined API (see <specref ref="static_context"/>).</p></item>

<item><p>Any <termref def="dt-environment-variables">environment variables</termref> provided by the implementation.</p></item>

<item><p>Any rules used for static typing (see <specref ref="id-static-analysis"/>).</p></item>

<item><p>Any serialization parameters provided by the implementation<phrase role="xquery"> (see  <specref ref="id-serialization"/>).</phrase></p></item>

<item role="xquery"><p>The means by which the location hint for a serialization parameter document identifies the corresponding XDM instance (see  <specref ref="id-serialization"/>).</p></item>

<item><p>What error, if any, is returned if an external function's implementation does not return the declared result type (see <specref ref="id-consistency-constraints"/>).</p></item>

<item role="xquery"><p>Any annotations defined by the implementation, and their associated behavior (see <specref ref="id-annotations"/>).</p></item>

<item role="xquery"><p>Any <termref def="dt-function-assertion">function assertions</termref> defined by the implementation.</p></item>

<item role="xquery"><p>The effect of function assertions understood by the implementation on <specref ref="id-assertions-subtype"/>.</p></item>

<item role="xquery"><p>Any implementation-defined variables defined by the implementation. (see <specref ref="id-variables"/>).</p></item>

<item role="xquery"><p>The ordering associated with <code>fn:unordered</code> in the implementation (see <specref ref="id-unordered-expressions"/>).</p></item>

<item role="xquery"><p>Any additional information provided for try/catch via the <code>err:additional</code> variable (see <specref ref="id-try-catch"/>).</p></item>

<item role="xquery"><p>The default boundary-space policy (see <specref ref="id-boundary-space-decls"/>).</p></item>

<item role="xquery"><p>The default collation (see <specref ref="id-default-collation-declaration"/>).</p></item>

<item role="xquery"><p>The default base URI (see <specref ref="id-base-uri-decl"/>).</p></item>

</olist>

<note><p>Additional <termref def="dt-implementation-defined">implementation-defined</termref> items are listed in <bibref ref="xpath-datamodel-31"/> and <bibref ref="xpath-functions-40"/>.</p></note></div1>
<div1 id="id-references">
<head>References</head>
<div2 id="id-normative-references">
<head>Normative References</head>

<blist>

<bibl id="RFC2119" key="RFC2119">S. Bradner.
      <emph>Key Words for use in RFCs to Indicate Requirement Levels.</emph> IETF RFC 2119.
      See <loc href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</loc>.</bibl>

<bibl id="RFC3986" key="RFC3986">T. Berners-Lee, R. Fielding, and
      L. Masinter.  <emph>Uniform Resource Identifiers (URI): Generic
      Syntax</emph>. IETF RFC 3986.
      See <loc href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</loc>.</bibl>

<bibl id="RFC3987" key="RFC3987">M. Duerst and M. Suignard.
      <emph>Internationalized Resource Identifiers (IRIs)</emph>.
      IETF RFC 3987. See <loc href="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</loc>.</bibl>

<bibl id="ISO10646" key="ISO/IEC 10646">ISO (International Organization for Standardization).
      <emph>ISO/IEC 10646:2003. Information technology&mdash;Universal Multiple-Octet Coded Character Set (UCS)</emph>,
      as, from time to time, amended, replaced by a new edition, or expanded by the addition of new parts.
      [Geneva]: International Organization for Standardization.
      (See <loc href="http://www.iso.org">http://www.iso.org</loc> for the latest version.)</bibl>

<bibl id="Unicode" key="Unicode">The Unicode Consortium. <emph>The Unicode Standard.</emph>
      Reading, Mass.: Addison-Wesley, 2003, as updated from time to time by the publication of new versions.
      See <loc href="http://www.unicode.org/standard/versions/">http://www.unicode.org/standard/versions/</loc>
      for the latest version and additional information on versions of the standard and of the Unicode Character Database.
      The version of Unicode to be used is <termref def="dt-implementation-defined">implementation-defined</termref>,
      but implementations are recommended to use the latest Unicode version.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XML" key="XML 1.0"
      xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
      <emph>Extensible Markup Language (XML) 1.0.</emph>
      W3C Recommendation.
      See <loc href="http://www.w3.org/TR/REC-xml/" xlink:type="simple" xlink:show="replace"
      xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml/</loc>.
      The edition of XML 1.0 must be no earlier than the Third Edition;
      the edition used is <termref def="dt-implementation-defined">implementation-defined</termref>,
      but we recommend that implementations use the latest version.
</bibl>

<bibl id="XML1.1" key="XML 1.1">World Wide Web Consortium.
      <emph>Extensible Markup Language (XML) 1.1.</emph>
      W3C Recommendation.
      See <loc href="http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</loc>
</bibl>

<bibl id="XMLBASE" key="XML Base">World Wide Web Consortium.
      <emph>XML Base.</emph> W3C Recommendation. See
      <loc href="http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</loc>
</bibl>

<bibl id="XMLNAMES" key="XML Names">World Wide Web Consortium.
      <emph>Namespaces in XML.</emph> W3C Recommendation. See
      <loc href="http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</loc>
</bibl>

<bibl id="XMLNAMES11" key="XML Names 1.1">World Wide Web Consortium.
      <emph>Namespaces in XML 1.1.</emph> W3C Recommendation. See
      <loc href="http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</loc>
</bibl>

<bibl id="XMLID" key="XML ID">World Wide Web Consortium. <emph>xml:id Version 1.0.</emph>
      W3C Recommendation. See <loc href="http://www.w3.org/TR/xml-id/">http://www.w3.org/TR/xml-id/</loc></bibl>

<bibl id="XMLSchema10" key="XML Schema 1.0">World Wide Web Consortium.
      <emph>XML Schema, Parts 0, 1, and 2 (Second Edition)</emph>. W3C Recommendation, 28 October 2004.
      See <loc href="http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</loc>,
      <loc href="http://www.w3.org/TR/xmlschema-1/" id="schema1">http://www.w3.org/TR/xmlschema-1/</loc>,
      and <loc href="http://www.w3.org/TR/xmlschema-2/" id="schema2">http://www.w3.org/TR/xmlschema-2/</loc>.</bibl>

<bibl id="XMLSchema11" key="XML Schema 1.1">World Wide Web Consortium.
      <emph>XML Schema, Parts 1, and 2</emph>. W3C Recommendation 5 April 2012.
      See <loc href="http://www.w3.org/TR/xmlschema11-1/" id="schema1-11">http://www.w3.org/TR/xmlschema11-1/</loc>,
      and <loc href="http://www.w3.org/TR/xmlschema11-2/" id="schema2-11">http://www.w3.org/TR/xmlschema11-2/</loc>.</bibl>

<bibl id="xpath-datamodel-31" key="XQuery and XPath Data Model (XDM) 3.1"/>

<bibl id="xpath-functions-40" key="XQuery and XPath Functions and Operators 4.0"/>

<bibl id="xslt-xquery-serialization-31" key="XSLT and XQuery Serialization 3.1"/>

<bibl id="xquery-update-30" key="XQuery Update Facility 3.0" role="xquery"/>


</blist>
</div2>
<div2 id="id-non-normative-references">
<head>Non-normative References</head>

<blist>

<bibl id="xquery-30-requirements" key="XQuery 3.0 Requirements" role="xquery"/>
<bibl id="xquery-31-requirements" key="XQuery 3.1 Requirements" role="xquery"/>

<bibl id="xquery-30" key="XQuery 3.0: An XML Query Language" role="xquery"/>
<bibl id="xquery-31" key="XQuery 3.1: An XML Query Language" role="xpath"/>

<bibl id="xquery-semantics" key="XQuery 1.0 and XPath 2.0 Formal Semantics"/>

<bibl id="xqueryx-31" key="XQueryX 3.1" role="xquery"/>

<bibl id="xslt-30" key="XSL Transformations (XSLT) Version 3.0"/>

<bibl id="DOM" key="Document Object Model" role="xquery">World Wide Web Consortium. <emph>Document Object Model (DOM) Level 3 Core Specification.</emph> W3C Recommendation, April 7, 2004. See <loc href="http://www.w3.org/TR/DOM-Level-3-Core/">http://www.w3.org/TR/DOM-Level-3-Core/</loc>.</bibl>

<bibl id="XINFO" key="XML Infoset">World Wide Web
Consortium. <emph>XML Information Set (Second Edition).</emph> W3C Recommendation 4 February 2004. See
<loc href="http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</loc>
</bibl>

<bibl key="XML Path Language (XPath) Version 1.0" id="xpath"/>

<bibl key="XML Path Language (XPath) Version 2.0" id="xpath20"/>

<bibl key="XML Path Language (XPath) Version 3.0" id="xpath-30"/>
<bibl key="XML Path Language (XPath) Version 3.1" id="xpath-31" role="xquery"/>

<bibl id="XPTR" key="XPointer">World Wide Web Consortium. <emph>XML
Pointer Language (XPointer).</emph> W3C Last Call Working Draft 8 January 2001.
See <loc href="http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</loc></bibl>

<bibl id="UseCases" key="XML Query Use Cases" role="xquery">World Wide
Web Consortium. <emph>XML Query Use Cases</emph>. W3C Working Draft, 8 June 2006.
See <loc href="http://www.w3.org/TR/xquery-use-cases/">http://www.w3.org/TR/xquery-use-cases/</loc>.</bibl>

<bibl id="xml11schema10" key="XML 1.1 and Schema 1.0" role="xquery">World Wide
Web Consortium. <emph>Processing XML 1.1 Documents with XML Schema 1.0 Processors</emph>.
W3C Working Group Note, 11 May 2005.
See <loc href="http://www.w3.org/TR/xml11schema10/">http://www.w3.org/TR/xml11schema10/</loc>.</bibl>

<bibl id="RFC1738" key="Uniform Resource Locators (URL)" role="xquery">Internet Engineering Task Force (IETF).
<emph>Uniform Resource Locators (URL)</emph>. Request For Comment No. 1738, Dec. 1994.
See <loc href="http://www.ietf.org/rfc/rfc1738.txt">http://www.ietf.org/rfc/rfc1738.txt</loc>.</bibl>

<bibl key="ODMG" id="ODMG" role="xquery">Rick Cattell et al. <emph>The
Object Database Standard: ODMG-93, Release 1.2</emph>. Morgan Kaufmann
Publishers, San Francisco, 1996.</bibl>

<bibl key="Quilt" id="Quilt" role="xquery">Don Chamberlin,
Jonathan Robie, and Daniela Florescu. <emph>Quilt: an XML Query Language for
Heterogeneous Data Sources</emph>.  In <emph>Lecture Notes in Computer
Science</emph>, Springer-Verlag, Dec. 2000.  
<!--
Also available at <loc href="http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf">http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf</loc>.
See also <loc href="http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html">http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html</loc>.
-->
</bibl>

<bibl key="XML-QL" id="XML-QL" role="xquery">Alin Deutsch, Mary Fernandez,
Daniela Florescu, Alon Levy, and Dan Suciu.
<emph>A Query Language for XML</emph>.
</bibl>

<bibl key="SQL" id="SQL" role="xquery">International Organization for
Standardization (ISO).  <emph>Information Technology &mdash; Database Language
SQL</emph>. Standard No. ISO/IEC 9075:2011.  (Available from American
National Standards Institute, New York, NY 10036, (212)
642-4900.)</bibl>

<bibl key="XQL" id="XQL" role="xquery">J. Robie, J. Lapp, D. Schach. <emph>XML
Query Language (XQL)</emph>. See <loc href="http://www.w3.org/TandS/QL/QL98/pp/xql.html">http://www.w3.org/TandS/QL/QL98/pp/xql.html</loc>.</bibl>

</blist>
</div2>

<div2 id="id-background-material"><head>Background Material</head>
<blist>

<bibl id="CHARMOD" key="Character Model">World Wide Web Consortium.
<emph>Character Model for the World Wide Web.</emph> W3C Working
Draft. See <loc href="http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</loc>.</bibl>

<bibl id="xslt" key="XSL Transformations (XSLT) Version 1.0"/>

<bibl id="UseCaseQueries" key="Use Case Sample Queries" role="xquery">Queries
from the XQuery 1.0 Use Cases, presented in a single file.
See
<loc href="http://www.w3.org/2010/12/xquery-30-use-cases/xquery-30-use-case-queries.txt">http://www.w3.org/2010/12/xquery-30-use-cases/xquery-30-use-case-queries.txt</loc>.
</bibl>

<bibl id="XQueryQueries" key="XQuery Sample Queries" role="xquery">Queries
from this document, presented in a single file.
See
<loc href="http://www.w3.org/2013/01/xquery-30-use-cases/xquery-30-example-queries.txt">http://www.w3.org/2013/01/xquery-30-use-cases/xquery-30-example-queries.txt</loc>.
</bibl>

<bibl id="Moustache" key="Moustache" role="xquery">
<emph>mustache</emph> - Logic-less templates. See
<loc href="http://mustache.github.io/mustache.5.html">http://mustache.github.io/mustache.5.html</loc>.
</bibl>

</blist>
</div2>
</div1>


&errors;&mime-type;<inform-div1 id="id-glossary"><head>Glossary</head>
<!-- This processing instruction automatically generates the glossary. -->
<?glossary?>
</inform-div1>


&examples;

<inform-div1 id="id-incompatibilities">

<head>Backwards Compatibility</head>
  
  <div2 id="id-incompatibilities-31" diff="add" at="2022-11-16">
    <head>Incompatibilities relative to &language-tech; 3.1</head>
    
    <p>In <code>fn:format-integer</code>, certain formatting pictures using a circumflex as a grouping separator might
    be interpreted differently in 4.0: for example <code>format-integer(1234, "9^999")</code> would output <code>"1^234"</code>
      in 3.1, but will output <code>"1621"</code> (1234 in base 9) with 4.0. As a workaround, this can be rewritten as 
      <code>format-integer(1234, "0^000")</code>.</p>
    
    <p>In &language;, certain expressions are classified as <termref def="dt-implausible"/>: an example
    is <code>@code/text()</code>, which will always return an empty sequence. A processor may report
    a static error when such expressions are encountered; however, processors are <rfc2119>required</rfc2119>
    to provide a mode of operation in which such expressions are accepted, thus retaining backwards
    compatibility.</p>
  </div2>

<div2 id="id-incompatibilities-30">
<head>Incompatibilities relative to &language-tech; 3.0</head>
<p>The following names are now reserved, and cannot appear as function names (see <specref ref="id-reserved-fn-names"/>):</p>

<ulist>
  <item>
    <p>
      <code>map</code>
    </p>
  </item>
  <item>
    <p>
      <code>array</code>
    </p>
  </item>
</ulist>
</div2>

<div2 id="id-incompatibilities-10">
<head>Incompatibilities relative to &language-tech; <phrase role="xpath">2.0</phrase><phrase role="xquery">1.0</phrase></head>

<p>The following names are now reserved, and cannot appear as function names (see <specref ref="id-reserved-fn-names"/>):</p>

<ulist>
  <item>
    <p>
      <code>function</code>
    </p>
  </item>
  <item>
    <p>
      <code>namespace-node</code>
    </p>
  </item>
  <item>
    <p>
      <code>switch</code>
    </p>
  </item>
</ulist>


<p>If <code>U</code> is a union type with <code>T</code> as one of its members,
  and if <code>E</code> is an element with <code>T</code> as its type annotation,
  the expression <code role="parse-test">E instance of element(*, U)</code>
  returns <code>true</code> in both &language-tech; 3.0 and 3.1.
  In <phrase role="xpath">XPath 2.0</phrase><phrase role="xquery">XQuery 1.0</phrase>,
  it returns <code>false</code>.</p>

 <note><p>This is not an incompatibility with &language-tech; 3.0.
 It should be included in &language-tech; 3.0 as an incompatibility with
 <phrase role="xpath">XPath 2.0</phrase><phrase role="xquery">XQuery 1.0</phrase>,
 but it was discovered after publication.</p></note>
</div2>

&xpath-backwards-compat;

</inform-div1>

<inform-div1 id="id-revision-log" diff="chg" at="2022-11-16">
<head>Change Log</head>

<p role="xquery">This appendix lists the changes that have been made to this
specification since the publication of the XQuery 3.1 Recommendation.</p>

<p role="xpath">This appendix lists the changes that have been made to this
specification since the publication of XPath 3.1 Recommendation.</p>

<div2 id="id-changes-since-3.1">
  <head>Changes since version 3.1</head>
  <div3 id="id-substantive-changes-since-3.1">
    <head>Substantive Changes</head>
  
  <p>The following changes have been agreed by the working group:</p>
    <olist>
      <item><p>The concept of the context item has been generalized, so it is now a context value. That is,
      it is no longer constrained to be a single item.</p></item>
      <item><p>Function definitions in the static context may now have optional parameters,
      provided this does not cause ambiguity across multiple function definitions with the same name.
      Optional parameters are given a default value, which can be any expression, including one that
      depends on the context of the caller (so an argument can default to the context value).</p></item>
      <item><p>In a static function call, arguments can be specified either positionally or by keyword,
      or a combination of both.</p></item>
      <item><p>An <code>otherwise</code> operator is introduced: <code>A otherwise B</code> returns the
        value of <code>A</code>, unless it is an empty sequence, in which case it returns the value of <code>B</code>.</p></item>
      <item><p>Alternative syntax for conditional expressions is available: <code>if (condition) {X} else {Y}</code>,
      with the <code>else</code> part being optional.</p></item>
      <item><p>The syntax <code>for $x in X for $y in Y return Z</code> is now accepted in XPath as well as in XQuery.</p></item>
      <item><p>The <code>NodeTest</code> in an <code>AxisStep</code> now allows alternatives: 
        <code>ancestor::(section|appendix)</code>.</p></item>
      <item><p>Element and attribute tests can include alternative names: <code>element(chapter|section)</code>,
      <code>attribute(role|class)</code>.</p></item>
      <item><p>String templates provide a new way of constructing strings: for example <code>`{$greeting}, {$planet}!`</code>
      is equivalent to <code>$greeting || ', ' || $planet || '!'</code></p></item>
      <item><p>In inline function expressions, the keyword <code>function</code> may be abbreviated
      as <code>fn</code>.</p></item>
      <item><p>New abbreviated syntax is introduced (<termref def="dt-focus-function"/>) 
        for simple inline functions taking a single argument. 
        An example is <code>fn{../@code}</code></p></item>
      <item><p>The arrow operator <code>=></code> is now complemented by a “mapping arrow” operator <code>=!></code>
        which applies a the supplied function to each item in the input sequence independently.</p></item>
      <item><p>The “function conversion rules” are now renamed “coercion rules”.</p></item>
      <item><p>The coercion rules allow “relabeling” of a supplied atomic value where
        the required type is a derived atomic type: for example, it is now permitted to supply
        the value 3 when calling a function that expects an instance of <code>xs:positiveInteger</code>.</p></item>
      <item><p>In XQuery, the coercion rules are now used when binding values to variables (both
        global variable declarations and local variable bindings). This aligns XQuery with XSLT,
        and means that the rules for binding to variables are the same as the rules for binding
        to function parameters.</p></item>
      <item><p>Function coercion allows a function with arity <var>N</var> to be supplied where a function of arity 
        greater than <var>N</var> is expected. For example this allows the function <code>true#0</code> 
        to be supplied where a predicate function is required.</p></item>
      <item><p>The rules for “errors and optimization” have been tightened up to disallow
        many cases of optimizations that alter error behavior. In particular
        there are restrictions on reordering the operands of <code>and</code> and <code>or</code>,
        and of predicates in filter expressions, in a way that might allow the processor to raise dynamic
        errors that the author intended to prevent.
      </p></item>
      <item><p>Support for higher-order functions is now a mandatory feature (in 3.1 it was optional).</p></item>
      <item role="xquery"><p>Switch expressions now allow a <code>case</code> clause to match multiple atomic values.</p></item>
      <item><p>Numeric literals can now be written in hexadecimal or binary notation; and underscores can be included
      for readability.</p></item>
      <item role="xquery"><p>Switch and typeswitch expressions can now be written with curly braces,
        to improve readability.</p></item>
      <item role="xquery"><p>The comparand expression in a switch expression can be omitted, allowing
        the switch cases to be provided as arbitrary boolean expressions.</p></item>
      <item><p>The symbols <code>×</code> and <code>÷</code> can be used for multiplication and division,
        and operators such as <code>&lt;</code> and <code>&gt;</code> can use the full-width forms
        <code>&#xFF1C;</code> and <code>&#xFF1E;</code> to avoid the need for XML escaping.</p></item>
      <item role="xquery"><p>The <code>start</code> clause in window expressions has become optional, as well as
      the <code>when</code> keyword and its associated expression.</p></item>
      <item role="xquery"><p>The values <code>true()</code> and <code>false()</code> are allowed
      in function annotations, and negated numeric literals are also allowed.</p></item>
      <item role="xquery"><p>All implementations must now predeclare the namespace prefixes
      <code>math</code>, <code>map</code>, <code>array</code>, and <code>err</code>. In XQuery 3.1 it was permitted
        but not required to predeclare these namespaces.</p></item>
      <item role="xquery"><p>In previous versions the interpretation of location hints in 
        <code>import schema</code> declarations was entirely at the discretion of the processor. To
        improve interoperability, XQuery 4.0 recommends (but does not mandate)
        a specific strategy for interpreting these hints.</p></item>
    </olist>
    
    <p>The following changes are present in this draft, but are awaiting review and agreement:</p>
  <olist>
    <item><p>The static context now allows the default namespace for elements and
    the default namespace for types to be different. XSLT 4.0 takes advantage of this,
    XQuery 4.0 currently does not.</p></item>
    <item><p>A new <code>with</code> expression allows namespace bindings to be defined
    within an expression (and to be redefined in nested expressions).</p></item>
    <item><p>The static context now allows the unprefixed function names to be resolved
    using an arbitrary algorithm, rather than requiring the resolution to use a
    default namespace.</p></item>
    <item><p>The rules for reporting type errors during static analysis have been changed
    so that a processor has more freedom to report errors in respect of constructs that
    are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation
    is defined to return an empty sequence rather than an error.</p></item>
    <item><p>Record types are added as a new kind of <code>ItemType</code>, constraining
      the value space of maps.</p></item>
    <item><p>Local union types are added as a new kind of <code>ItemType</code>, constraining
      the value space of atomic values.</p></item>
    <item><p>Enumeration types are added as a new kind of <code>ItemType</code>, constraining
      the value space of strings.</p></item>
    
    <item><p>Element and attribute tests of the form <code>element(N)</code>
    and <code>attribute(N)</code> now allow <code>N</code> to be any <code>NameTest</code>,
    including a wildcard.</p></item>
    
    
    <item><p>The lookup operator <code>?</code> can now be followed by a string literal, for cases where
    map keys are strings other than NCNames.</p></item>
    
    
    <item><p>The rules for value comparisons when comparing values of different types (for example, decimal and double)
    have changed to be transitive. A decimal value is no longer converted to double, instead the double is converted
    to a decimal without loss of precision. This may affect compatibility in edge cases involving comparison of
    values that are numerically very close.</p></item>
    <item><p>A <code>for member</code> clause is added to FLWOR expressions to allow iteration over
    an array.</p></item>
    
 
  </olist>
  </div3>
  <div3 id="id-editorial-changes-since-3.1">
    <head>Editorial Changes</head>
    
    <olist>
      <item><p>The presentation of the rules for the subtype relationship between sequence types and item types has been substantially
        rewritten to improve clarity; no change to the semantics is intended.</p></item>
      <item><p>The operator mapping table has been simplified by removing entries for the operators <code>ne</code>,
      <code>le</code>, <code>gt</code>, and <code>ge</code>; these are now defined by reference to the
      rules for the operators <code>eq</code> and <code>lt</code>.</p></item>
      <item><p>Recommended rules for processing an <code>import schema</code> declaration with multiple
      location hints are now provided, though they are not binding on implementors.</p></item>

    </olist>
  </div3>
</div2>
</inform-div1>
