<?xml version="1.0" encoding="utf-8"?>
<!--<div1 id="id-type-promotion-and-operator-mapping">
<head>Type Promotion and Operator Mapping</head>

<div2 id="promotion">
<head>Type Promotion</head>

<p><termdef term="type promotion" id="dt-type-promotion">Under certain circumstances, an atomic item can be promoted from
  one type to another.</termdef> <term>Type promotion</term> is used in a number of contexts:</p>
  
  <ulist>
    <item><p>It forms part of the process described by the <termref def="dt-coercion-rules"/>, invoked
    for example when a value of one type is supplied as an argument of a function call where
    the required type of the corresponding function parameter is declared with a different type.</p></item>
    <item><p>It forms part of the process described in <specref ref="mapping"/>, which selects the implementation
      of a binary operator based on the types of the supplied operands.</p></item>
    <item><p>It is invoked (by explicit reference) in a number of other situations,
    for example when computing an average of a sequence of numeric values (in the
      <function>fn:avg</function> function)<phrase role="xquery">, and in <code>order by</code> clauses
      (see <specref ref="id-order-by-clause"/>)</phrase>.</p></item>
  </ulist>
  
  <p>In general, type promotion takes a set of one or more atomic items as input, potentially
    having different types, and selects a single common type to which all the input values can
    be converted by casting.</p>
  
  <p>There are three families of atomic types that can be mixed in this way:</p>

  <olist>
    <item><p>Numeric types. This applies when the input contains values of types
      <code>xs:decimal</code>, <code>xs:float</code>, and <code>xs:double</code> (including
      types derived from these, such as <code>xs:integer</code>).</p>
      <p>The rules are:</p>
      <olist>
        <item><p>If any of the items is of type <code>xs:double</code>, then 
        all the values are cast to type <code>xs:double</code>.</p></item>
        <item><p>Otherwise, if any of the items is of type <code>xs:float</code>, then 
          all the values are cast to type <code>xs:float</code>.</p></item>
        <item><p>Otherwise, no casting takes place: the values remain as <code>xs:decimal</code>.</p></item>
      </olist>
    </item>
    <item><p>String types. This applies when the input contains values of types
      <code>xs:string</code> and <code>xs:anyURI</code> (including
      types derived from these, such as <code>xs:NCName</code>).</p>
      <p>The rule is that if any of the items is of type <code>xs:string</code>,
      then all the values are cast to type <code>xs:string</code>.</p>
    </item>
    <item><p>Binary types. This applies when the input contains values of types
      <code>xs:hexBinary</code> and <code>xs:base64Binary</code> (including
      types derived from these).</p>
      <p>The rule is that if any of the items is of type <code>xs:hexBinary</code>,
        then all the values are cast to type <code>xs:hexBinary</code>.</p>
    </item>
  </olist>
  
</div2>
<div2 id="mapping">
<head>Operator Mapping</head> 
  
  <changes>
    <change>The operator mapping table has been simplified by removing entries for the operators <code>ne</code>,
      <code>le</code>, <code>gt</code>, and <code>ge</code>; these are now defined by reference to the
      rules for the operators <code>eq</code> and <code>lt</code>.</change>
  </changes>
  
  <p>The operator mapping tables in this section list the
combinations of types for which various operators of &language;
are defined. The operators covered by this appendix are the value comparison
operators <code>eq</code> and <code>lt</code>, and the arithmetic operators
  <code>+</code>, <code>-</code>, <code>*</code>, <code>div</code>, 
  <code>idiv</code>, and <code>mod</code>.</p>
  
  <p>Other operators (such as <code>and</code>,
    <code>or</code>, <code>intersect</code>, <code>union</code>,
    <code>=</code>, <code>||</code>, and <code>is</code>)
    are defined directly in the main body of
    this document, and do not occur in the operator mapping table.</p>
  

    
    <p diff="chg" at="A">The operators <code>ne</code>, <code>le</code>, <code>gt</code>, and <code>ge</code> do not
      occur in the operator mapping table, but are instead defined by the following equivalences:</p>
    
    <ulist diff="chg" at="A">
      <item><p><code>A ne B</code> is equivalent to <code>not(A eq B)</code></p></item>
      <item><p><code>A le B</code> is equivalent to <code>A lt B or A eq B</code></p></item>
      <item><p><code>A gt B</code> is equivalent to <code>B lt A</code></p></item>
      <item><p><code>A ge B</code> is equivalent to <code>B lt A or B eq A</code></p></item>
    </ulist>
    
  
  
  <p><termdef term="operator function" id="dt-operator-function">For each 
  operator and valid combination of operand types, the operator mapping tables 
  specify a result type and an expression that invokes an <term>operator function</term>; 
    the operator function implements 
  the semantics of the operator for the given types.</termdef> The definitions 
  of the operator functions are given in  <bibref ref="xpath-functions-40"/>. 
  The result of an operator may be the raising of an error by its operator 
  function, as defined in <bibref ref="xpath-functions-40"/>. The operator 
  function fully defines the semantics of a given operator for the case 
  where the operands are single atomic items of the types given in the table. 
  For the definition of each operator (including its
behavior for empty sequences or sequences of length greater than one),
see the descriptive material in the main part of this
document.</p>
  

  
  <p>If an operator in the operator mapping tables expects an operand of type
<emph>ET</emph>, that operator can be applied to an operand of type <emph>AT</emph> if type <emph>AT</emph> can
be converted to type <emph>ET</emph> by a combination of <termref def="dt-type-promotion">type promotion</termref> and <termref def="dt-subtype-substitution">subtype substitution</termref>. For example, a table entry indicates that the <code>gt</code> operator may
be applied to two <code>xs:date</code> operands, returning
<code>xs:boolean</code>. Therefore, the <code>gt</code> operator may
also be applied to two (possibly different) subtypes of
<code>xs:date</code>, also returning <code>xs:boolean</code>.</p>

<p><termdef id="dt-numeric" term="numeric">When referring to a type, the term <term>numeric</term> denotes the types
<code>xs:integer</code>, <code>xs:decimal</code>,
<code>xs:float</code>, and <code>xs:double</code> which are all member types of the built-in union type <code>xs:numeric</code>.</termdef> An operator whose
operands and result are designated as <termref def="dt-numeric">numeric</termref> might be
thought of as representing four operators, one for each of the numeric
types. For example, the numeric <code>+</code> operator might be
thought of as representing the following four operators:</p>


<table width="80%" role="medium"><tbody>
<tr><th align="center">Operator</th><th align="center">First operand type</th><th align="center">Second operand type</th><th align="center">Result type</th></tr>
<tr><td align="center"><code>+</code></td><td align="center"><code>xs:integer</code></td><td align="center"><code>xs:integer</code></td><td align="center"><code>xs:integer</code></td></tr>
<tr><td align="center"><code>+</code></td><td align="center"><code>xs:decimal</code></td><td align="center"><code>xs:decimal</code></td><td align="center"><code>xs:decimal</code></td></tr>
<tr><td align="center"><code>+</code></td><td align="center"><code>xs:float</code></td><td align="center"><code>xs:float</code></td><td align="center"><code>xs:float</code></td></tr>
<tr><td align="center"><code>+</code></td><td align="center"><code>xs:double</code></td><td align="center"><code>xs:double</code></td><td align="center"><code>xs:double</code></td></tr></tbody></table><p>A numeric operator may be validly applied to an operand of type <emph>AT</emph> if type
<emph>AT</emph> can be converted to any of the four numeric types by a combination of
<termref def="dt-type-promotion">type promotion</termref> and <termref def="dt-subtype-substitution">subtype substitution</termref>. 
  If the result type of an
operator is listed as numeric, it means "the first type in the ordered list 
  <code>(xs:integer, xs:decimal, xs:float, xs:double)</code> into which all 
  operands can be converted by <termref def="dt-subtype-substitution">subtype substitution</termref> 
  and <termref def="dt-type-promotion">type promotion</termref>." As an example, suppose that 
  the type <code>hatsize</code> is derived from <code>xs:integer</code> and the type 
  <code>shoesize</code> is derived from <code>xs:float</code>.   Then if the <code>+</code> 
  operator is invoked with operands of type <code>hatsize</code> and <code>shoesize</code>, 
  it returns a result of type <code>xs:float</code>.  Similarly, if <code>+</code> is invoked 
  with two operands of type <code>hatsize</code> it returns a result of type <code>xs:integer</code>.</p>
  
  <p><termdef id="dt-gregorian" term="Gregorian">In the operator mapping tables,
the term <term>Gregorian</term> refers to the types
<code>xs:gYearMonth</code>, <code>xs:gYear</code>,
<code>xs:gMonthDay</code>, <code>xs:gDay</code>, and
<code>xs:gMonth</code>.</termdef>  For binary operators that accept two
Gregorian-type operands, both operands must have the same type (for
example, if one operand is of type <code>xs:gDay</code>, the other
operand must be of type <code>xs:gDay</code>.)</p>
  
  <p diff="add" at="2023-11-03"><termdef id="dt-binary" term="binary">In the operator mapping tables,
    the term <term>binary</term> refers to the types
    <code>xs:hexBinary</code> and <code>xs:base64Binary</code>.</termdef>
    For operators that accept two
    binary operands, both operands are promoted to type 
    <code>xs:hexBinary</code>.</p>

<table border="1" role="small">
<caption>Binary Operators</caption>
<tbody>

<tr>
<th>Operator</th>
<th>Type(A)</th>
<th>Type(B)</th>
<th>Function</th>
<th>Result type</th>
</tr>

<tr><td>A + B</td><td>numeric</td><td>numeric</td><td>op:numeric-add(A, B)</td><td>numeric</td></tr>

<tr><td>A + B</td><td>xs:date</td><td>xs:yearMonthDuration</td><td>op:add-yearMonthDuration-to-date(A, B)</td><td>xs:date</td></tr>

<tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:date</td><td>op:add-yearMonthDuration-to-date(B, A)</td><td>xs:date</td></tr>
<tr><td>A + B</td><td>xs:date</td><td>xs:dayTimeDuration</td><td>op:add-dayTimeDuration-to-date(A, B)</td><td>xs:date</td></tr>
<tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:date</td><td>op:add-dayTimeDuration-to-date(B, A)</td><td>xs:date</td></tr>

<tr><td>A + B</td><td>xs:time</td><td>xs:dayTimeDuration</td><td>op:add-dayTimeDuration-to-time(A, B)</td><td>xs:time</td></tr>
<tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:time</td><td>op:add-dayTimeDuration-to-time(B, A)</td><td>xs:time</td></tr>


<tr><td>A + B</td><td>xs:dateTime</td><td>xs:yearMonthDuration</td><td>op:add-yearMonthDuration-to-dateTime(A, B)</td><td>xs:dateTime</td></tr>
<tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:dateTime</td><td>op:add-yearMonthDuration-to-dateTime(B, A)</td><td>xs:dateTime</td></tr>

<tr><td>A + B</td><td>xs:dateTime</td><td>xs:dayTimeDuration</td><td>op:add-dayTimeDuration-to-dateTime(A, B)</td><td>xs:dateTime</td></tr>
<tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:dateTime</td><td>op:add-dayTimeDuration-to-dateTime(B, A)</td><td>xs:dateTime</td></tr>

<tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td>op:add-yearMonthDurations(A, B)</td><td>xs:yearMonthDuration</td></tr>
<tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td>op:add-dayTimeDurations(A, B)</td><td>xs:dayTimeDuration</td></tr>


<tr><td>A - B</td><td>numeric</td><td>numeric</td><td>op:numeric-subtract(A, B)</td><td>numeric</td></tr>


<tr><td>A - B</td><td>xs:date</td><td>xs:date</td><td>op:subtract-dates(A, B)</td><td>xs:dayTimeDuration</td></tr>
<tr><td>A - B</td><td>xs:date</td><td>xs:yearMonthDuration</td><td>op:subtract-yearMonthDuration-from-date(A, B)</td><td>xs:date</td></tr>
<tr><td>A - B</td><td>xs:date</td><td>xs:dayTimeDuration</td><td>op:subtract-dayTimeDuration-from-date(A, B)</td><td>xs:date</td></tr>

<tr><td>A - B</td><td>xs:time</td><td>xs:time</td><td>op:subtract-times(A, B)</td><td>xs:dayTimeDuration</td></tr>

<tr><td>A - B</td><td>xs:time</td><td>xs:dayTimeDuration</td><td>op:subtract-dayTimeDuration-from-time(A, B)</td><td>xs:time</td></tr>


<tr><td>A - B</td><td>xs:dateTime</td><td>xs:dateTime</td><td>op:subtract-dateTimes(A, B)</td><td>xs:dayTimeDuration</td></tr>
<tr><td>A - B</td><td>xs:dateTime</td><td>xs:yearMonthDuration</td><td>op:subtract-yearMonthDuration-from-dateTime(A, B)</td><td>xs:dateTime</td></tr>
<tr><td>A - B</td><td>xs:dateTime</td><td>xs:dayTimeDuration</td><td>op:subtract-dayTimeDuration-from-dateTime(A, B)</td><td>xs:dateTime</td></tr>

<tr><td>A - B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td>op:subtract-yearMonthDurations(A, B)</td><td>xs:yearMonthDuration</td></tr>
<tr><td>A - B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td>op:subtract-dayTimeDurations(A, B)</td><td>xs:dayTimeDuration</td></tr>


<tr><td>A * B</td><td>numeric</td><td>numeric</td><td>op:numeric-multiply(A, B)</td><td>numeric</td></tr>
<tr><td>A * B</td><td>xs:yearMonthDuration</td><td>numeric</td><td>op:multiply-yearMonthDuration(A, B)</td><td>xs:yearMonthDuration</td></tr>
<tr><td>A * B</td><td>numeric</td><td>xs:yearMonthDuration</td><td>op:multiply-yearMonthDuration(B, A)</td><td>xs:yearMonthDuration</td></tr>
<tr><td>A * B</td><td>xs:dayTimeDuration</td><td>numeric</td><td>op:multiply-dayTimeDuration(A, B)</td><td>xs:dayTimeDuration</td></tr>
<tr><td>A * B</td><td>numeric</td><td>xs:dayTimeDuration</td><td>op:multiply-dayTimeDuration(B, A)</td><td>xs:dayTimeDuration</td></tr>

  <tr><td>A × B</td><td>numeric</td><td>numeric</td><td>op:numeric-multiply(A, B)</td><td>numeric</td></tr>
  <tr><td>A × B</td><td>xs:yearMonthDuration</td><td>numeric</td><td>op:multiply-yearMonthDuration(A, B)</td><td>xs:yearMonthDuration</td></tr>
  <tr><td>A × B</td><td>numeric</td><td>xs:yearMonthDuration</td><td>op:multiply-yearMonthDuration(B, A)</td><td>xs:yearMonthDuration</td></tr>
  <tr><td>A × B</td><td>xs:dayTimeDuration</td><td>numeric</td><td>op:multiply-dayTimeDuration(A, B)</td><td>xs:dayTimeDuration</td></tr>
  <tr><td>A × B</td><td>numeric</td><td>xs:dayTimeDuration</td><td>op:multiply-dayTimeDuration(B, A)</td><td>xs:dayTimeDuration</td></tr>
  

<tr><td>A idiv B</td><td>numeric</td><td>numeric</td><td>op:numeric-integer-divide(A, B)</td><td>xs:integer</td></tr>

  <tr><td>A div B</td><td>numeric</td><td>numeric</td><td>op:numeric-divide(A, B)</td><td>numeric; but xs:decimal if both operands are xs:integer</td></tr>
<tr><td>A div B</td><td>xs:yearMonthDuration</td><td>numeric</td><td>op:divide-yearMonthDuration(A, B)</td><td>xs:yearMonthDuration</td></tr>
<tr><td>A div B</td><td>xs:dayTimeDuration</td><td>numeric</td><td>op:divide-dayTimeDuration(A, B)</td><td>xs:dayTimeDuration</td></tr>
<tr><td>A div B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td>op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td><td>xs:decimal</td></tr>
<tr><td>A div B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td>op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td><td>xs:decimal</td></tr>

  <tr><td>A ÷ B</td><td>numeric</td><td>numeric</td><td>op:numeric-divide(A, B)</td><td>numeric; but xs:decimal if both operands are xs:integer</td></tr>
  <tr><td>A ÷ B</td><td>xs:yearMonthDuration</td><td>numeric</td><td>op:divide-yearMonthDuration(A, B)</td><td>xs:yearMonthDuration</td></tr>
  <tr><td>A ÷ B</td><td>xs:dayTimeDuration</td><td>numeric</td><td>op:divide-dayTimeDuration(A, B)</td><td>xs:dayTimeDuration</td></tr>
  <tr><td>A ÷ B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td>op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</td><td>xs:decimal</td></tr>
  <tr><td>A ÷ B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td>op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</td><td>xs:decimal</td></tr>
  
<tr><td>A mod B</td><td>numeric</td><td>numeric</td><td>op:numeric-mod(A, B)</td><td>numeric</td></tr>


<tr><td>A eq B</td><td>numeric</td><td>numeric</td><td>op:numeric-equal(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:boolean</td><td>xs:boolean</td><td>op:boolean-equal(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:string</td><td>xs:string</td><td>op:numeric-equal(fn:compare(A, B), 0)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:date</td><td>xs:date</td><td>op:date-equal(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:time</td><td>xs:time</td><td>op:time-equal(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:dateTime</td><td>xs:dateTime</td><td>op:dateTime-equal(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:duration</td><td>xs:duration</td><td>op:duration-equal(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>Gregorian</td><td>Gregorian</td><td>op:gYear-equal(A, B) etc.</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>binary</td><td>binary</td><td>op:binary-equal(A, B)</td><td>xs:boolean</td></tr>


<tr><td>A eq B</td><td>xs:QName</td><td>xs:QName</td><td>op:QName-equal(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:NOTATION</td><td>xs:NOTATION</td><td>op:NOTATION-equal(A, B)</td><td>xs:boolean</td></tr>




<tr><td>A lt B</td><td>numeric</td><td>numeric</td><td>op:numeric-less-than(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:boolean</td><td>xs:boolean</td><td>op:boolean-less-than(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:string</td><td>xs:string</td><td>op:numeric-less-than(fn:compare(A, B), 0)</td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:date</td><td>xs:date</td><td>op:date-less-than(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:time</td><td>xs:time</td><td>op:time-less-than(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:dateTime</td><td>xs:dateTime</td><td>op:dateTime-less-than(A, B)</td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td>op:yearMonthDuration-less-than(A, B)</td><td>xs:boolean</td></tr>
<tr><td>A lt B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td>op:dayTimeDuration-less-than(A, B)</td><td>xs:boolean</td></tr>
<tr><td>A lt B</td><td>binary</td><td>binary</td><td>op:binary-less-than(A, B)</td><td>xs:boolean</td></tr>




</tbody>
</table>

<table border="1" role="small">
<caption>Unary Operators</caption>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Operand type</th>
      <th>Function</th>
      <th>Result type</th>
    </tr>
  </thead>
<tbody>



<tr><td>+ A</td><td>numeric</td><td>op:numeric-unary-plus(A)</td><td>numeric</td></tr>

<tr><td>- A</td><td>numeric</td><td>op:numeric-unary-minus(A)</td><td>numeric</td></tr>
</tbody>
</table>


</div2>
  

</div1>-->


<div1 role="xquery" id="id-xq-context-components">
  <head>Context Components</head>

  <p>The tables in this section describe how values are assigned to
  the various components of the <termref def="dt-static-context"/> and <termref def="dt-dynamic-context"/>.</p>


<div2 id="id-xq-static-context-components">
<head>Static Context Components</head>
 
<changes>
  <change issue="1343">
    Parts of the static context that were there purely to assist in static typing, such as the statically
    known documents, were no longer referenced and have therefore been dropped.
  </change>
</changes> 

<p>The following table describes the components of the <term>static context</term>. The following aspects of each component are described:</p>

<ulist>
<item><p><emph>Default initial value:</emph> This is the
initial value of the component if it is not overridden or augmented by
the implementation or by a query.</p> </item>
<item><p><emph>Can be
overwritten or augmented by implementation:</emph> Indicates whether
an XQuery implementation is allowed to replace the default initial
value of the component by a different, <termref
def="dt-implementation-defined">implementation-defined</termref> value
and/or to augment the default initial value by additional <termref
def="dt-implementation-defined">implementation-defined</termref>
values.</p></item>
<item><p>
<emph>Can be overwritten or augmented by prolog:</emph>
Indicates whether there are prolog declarations that can replace and/or augment
the initial value provided by default or by the implementation.
</p></item>
<item><p>
<emph>Can be overwritten or augmented by expressions:</emph>
Indicates whether there are expressions that can replace and/or augment
the value of the component for their subexpressions.
</p></item>
<item><p><emph>Consistency
Rules:</emph> Indicates rules that must be observed in assigning
values to the component. Additional consistency rules may be found in
<specref ref="id-consistency-constraints"/>.</p></item></ulist>

<table width="100%" border="1" role="small">
<caption>Static Context Components</caption>
<tbody>
<!-- First group: can be overwritten/augmented by expressions -->
<tr>
<th>Component</th>
<th>Default initial value</th>
<th>Can be overwritten or augmented by implementation?</th>
<th>Can be overwritten or augmented by prolog?</th>
<th>Can be overwritten or augmented by expressions?</th>
<th>Consistency rules</th>
</tr>
<tr>
<td>Statically known namespaces</td>
<td><code>fn</code>, <code>xml</code>, <code>xs</code>, <code>xsi</code>,  <code>local</code></td>
<td>overwriteable and augmentable (except for <code>xml</code>)</td>
<td>overwriteable and augmentable by <specref ref="id-namespace-declaration"/></td>
<td>overwriteable and augmentable by element constructor</td>
<td>Only one namespace can be assigned to a given prefix
per lexical scope.</td>
</tr>
<tr><td>Default element/type namespace</td>
  <td>no namespace</td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-default-namespace"/></td>
  <td>overwriteable by element constructor</td>
  <td>Only one default namespace per lexical scope.</td></tr>

<tr>
  <td>In-scope variables</td>
  <td>none</td>
  <td>augmentable</td>
  <td>overwriteable and augmentable by <specref ref="id-variable-declarations"/> and  <specref ref="id-inline-func"/>, augmentable by <specref ref="id-module-import"/></td>
  <td>overwriteable and augmentable by variable-binding expressions</td>
  <td>Only one definition per variable per lexical scope.</td></tr>

<tr>
  <td>Context value static type</td>
  <td>item()</td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-context-value-declarations"/></td>
  <td>overwriteable by expressions that set the context value</td>
  <td>None.</td></tr>
<tr>
  <td>Ordering mode</td>
  <td><code>ordered</code></td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-default-ordering-decl"/></td>
  <td>overwriteable by expression</td>
  <td>Value must be <code>ordered</code> or <code>unordered</code>.</td></tr>

<!-- Second group: can be overwritten/augmented by (decls in) prologs,
     but not by expressions -->

<tr>
  <td>Default function namespace</td>
  <td><code>fn</code></td>
  <td>overwriteable (not recommended)</td>
  <td>overwriteable by <specref ref="id-default-namespace"/></td>
  <td>no</td>
  <td>None.</td></tr>
<tr>
  <td>In-scope schema types</td>
  <td>built-in types in <code>xs</code></td>
  <td>augmentable</td>
  <td>augmentable by <specref ref="id-schema-import"/></td>
  <td>no</td>
  <td>Only one definition per global or local type.</td></tr>
<tr>
  <td>In-scope element declarations</td>
  <td>none</td>
  <td>augmentable</td>
  <td>augmentable by  <specref ref="id-schema-import"/></td>
  <td>no</td>
  <td>Only one definition per global or local element name.</td></tr>
<tr>
  <td>In-scope attribute declarations</td>
  <td>none</td>
  <td>augmentable</td>
  <td>augmentable by  <specref ref="id-schema-import"/></td>
  <td>no</td>
  <td>Only one definition per global or local attribute name.</td></tr>
<tr>
  <td>Statically known function signatures</td>
  <td>the signatures of the <termref def="dt-system-function">system functions</termref></td>
  <td>augmentable</td>
  <td>augmentable by  <specref ref="id-module-import"/> and by  <specref ref="FunctionDeclns"/>; augmentable by  <specref ref="id-schema-import"/> (which adds constructor functions for user-defined types)</td>
  <td>no</td>
  <td>Each function must have a unique <termref def="dt-expanded-qname">expanded QName</termref> and number of arguments.</td></tr>
<tr>
  <td>Default collation</td>
  <td>Unicode codepoint collation</td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-default-collation-declaration"/></td>
  <td>no</td>
  <td>None.</td></tr>
<tr>
  <td>Construction mode</td>
  <td><code>preserve</code></td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-construction-declaration"/></td>
  <td>no</td>
  <td>Value must be <code>preserve</code> or <code>strip</code>. </td></tr>
<tr>
  <td>Default order for empty sequences</td>
  <td>implementation-defined</td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-empty-order-decl"/></td>
  <td>no</td>
  <td>Value must be <code>greatest</code> or <code>least</code>.</td></tr>
<tr>
  <td>Boundary-space policy</td>
  <td><code>strip</code></td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-boundary-space-decls"/></td>
  <td>no</td>
  <td>Value must be <code>preserve</code> or <code>strip</code>. </td></tr>
<tr>
  <td>Copy-namespaces mode</td>
  <td><code>inherit, preserve</code></td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-copy-namespaces-decl"/></td>
  <td>no</td>
  <td>Value consists of <code>inherit</code> or <code>no-inherit</code>, and <code>preserve</code> or <code>no-preserve</code>.</td></tr>
<tr>
  <td>Static Base URI</td>
  <td>See rules in <specref ref="id-base-uri-decl"/></td>
  <td>overwriteable</td>
  <td>overwriteable by <specref ref="id-base-uri-decl"/></td>
  <td>no</td>
  <td>Value must be a valid lexical representation of the type xs:anyURI.</td></tr>

  <tr>
    <td>Statically known decimal formats</td>
    <td>the default (unnamed) decimal format, which has an implementation-dependent value</td>
    <td>augmentable</td>
    <td>augmentable, using <termref def="dt-decimal-format-decl">decimal format declarations</termref></td>
    <td>no</td>
    <td>each QName uniquely identifies a decimal format</td></tr>


<!-- Third group: cannot be overwritten/augmented by expressions or
     declarations in prologs -->


<tr>
  <td>Statically known collations</td>
  <td>only the default collation</td>
  <td>augmentable</td>
  <td>no</td>
  <td>no</td>
  <td>Each URI uniquely identifies a collation.</td></tr>
<tr>
  <td>XPath 1.0 Compatibility Mode</td>
  <td><code>false</code></td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>Must be <code>false</code>.</td>
</tr>


</tbody>
</table></div2>
<div2 id="id-xq-evaluation-context-components">
  <head>Dynamic Context Components</head>

  <p>The following table describes the components of the <term>dynamic context</term>. The following aspects of each component are described:</p><ulist>
<item><p><emph>Default initial value:</emph> This is the initial value of the component if it is not overridden or augmented by the implementation or by a query.</p> </item>
<item><p><emph>Can be overwritten or augmented by implementation:</emph> Indicates whether an XQuery implementation is allowed to replace the default initial value of the component by a different <termref def="dt-implementation-defined">implementation-defined</termref> value and/or to augment the default initial value by additional <termref def="dt-implementation-defined">implementation-defined</termref> values.</p></item>
<item><p><emph>Can be overwritten or augmented by prolog:</emph>
Indicates whether there are prolog declarations that can replace and/or augment
the initial value provided by default or by the implementation.</p></item>
<item><p><emph>Can be overwritten or augmented by expressions:</emph>
Indicates whether there are expressions that can replace and/or augment
the value of the component for their subexpressions.</p></item>
<item><p><emph>Consistency Rules:</emph> Indicates rules that must be observed in assigning values to the component. Additional consistency rules may be found in <specref ref="id-consistency-constraints"/>.</p></item></ulist><table width="100%" border="1" role="small">
<caption>Dynamic Context Components</caption>
<tbody>

<tr>
<th>Component</th>

<th>Default initial value</th>

<th>Can be overwritten or augmented by implementation?</th>

<th>Can be overwritten or augmented by prolog?</th>

<th>Can be overwritten or augmented by expressions?</th>

<th>Consistency rules</th>
</tr>

<tr>
  <td>Context value</td>
  <td>none</td>
  <td>overwriteable</td>
  <td>overwriteable by a  <specref ref="id-context-value-declarations"/> in the main module
  </td>
  <td>overwritten during evaluation of path expressions and predicates</td>
  <td>Must be the same in the dynamic context of every module in a query.
  </td>
</tr>
<tr>
  <td>Context position</td>
  <td>none</td>
  <td>overwriteable</td>
  <td>overwriteable by a  <specref ref="id-context-value-declarations"/> in the main module
  </td>
  <td>overwritten during evaluation of path expressions and predicates</td>
  <td>If context value is defined, context position must be &gt;0 and &lt;= context size; else  context position is <xtermref spec="DM31" ref="dt-absent"/>. </td>
</tr>
<tr>
  <td>Context size</td>
  <td>none
  </td>
  <td>overwriteable</td>
  <td>overwriteable by a  <specref ref="id-context-value-declarations"/> in the main module
      
  </td>
  <td>overwritten during evaluation of path expressions and predicates</td>
  <td>If context value is defined, context size must be &gt;0; else context size is <xtermref spec="DM31" ref="dt-absent"/>.</td></tr>


<tr>
  <td>Variable values</td>
  <td>none</td>
  <td>augmentable</td>
  <td>overwriteable and augmentable by  <specref ref="id-variable-declarations"/>  and  <specref ref="id-inline-func"/>, augmentable by <specref ref="id-module-import"/></td>
  <td>overwriteable and augmentable by variable-binding expressions</td>
  <td>Names and values must be consistent with in-scope variables.</td>
</tr>
<tr>
  <td>Named functions</td>
  <td>the <termref def="dt-system-function">system functions</termref></td>
  <td>augmentable</td>
  <td>augmentable by 
 <specref ref="FunctionDeclns"/>, 
<specref ref="id-module-import"/>,
and
<specref ref="id-schema-import"/> ( (which adds constructor functions for user-defined types)</td>
  <td>no</td>
  <td>Must be consistent with statically known function signatures</td>
</tr>
<tr>
  <td>Current dateTime</td>
  <td>none</td>
  <td>must be initialized <phrase role="xquery">by implementation</phrase></td>
  <td>no</td>
  <td>no</td>
  <td>Must include a timezone. Remains constant during evaluation of a query.</td></tr>
<tr>
  <td>Implicit timezone</td>
  <td>none</td>
  <td>must be initialized <phrase role="xquery">by implementation</phrase></td>
  <td>no</td>
  <td>no</td>
  <td>Remains constant during evaluation of a query.</td></tr>
<tr>
  <td>Available documents</td>
  <td>none</td>
  <td>must be initialized <phrase role="xquery">by implementation</phrase></td>
  <td>no</td>
  <td>no</td>
  <td>None</td></tr>
<tr>
  <td>Available text resources</td>
  <td>none</td>
  <td>must be initialized <phrase role="xquery">by implementation</phrase></td>
  <td>no</td>
  <td>no</td>
  <td>None</td></tr>
<tr>
  <td>Available collections</td>
  <td>none</td>
  <td>must be initialized <phrase role="xquery">by implementation</phrase></td>
  <td>no</td>
  <td>no</td>
  <td>None</td></tr>
<tr>
  <td>Default collection</td>
  <td>none</td>
  <td>overwriteable</td>
  <td>no</td>
  <td>no</td>
  <td>None</td></tr>
  <tr>
    <td>Available URI collections</td>
    <td>none</td>
    <td>must be initialized <phrase role="xquery">by implementation</phrase></td>
    <td>no</td>
    <td>no</td>
    <td>None</td></tr>
  <tr>
    <td>Default URI collection</td>
    <td>none</td>
    <td>overwriteable</td>
    <td>no</td>
    <td>no</td>
    <td>None</td></tr>  
</tbody>
</table></div2>
</div1>
<div1 id="id-xp-context-components" role="xpath"><head>Context Components</head><p>The tables in this
section describe the scope (range of applicability) of the various
components in a module's static context and dynamic context.</p>

<div2 id="id-xp-static-context-components"><head>Static Context
Components</head><p>The following table describes the components of
the <term>static context</term>. For each component, “global”
indicates that the value of the component applies throughout an XPath
expression, whereas “lexical” indicates that the value of the
component applies only within the subexpression in which it is
defined.</p>

<table width="60%" border="1" role="small">

<caption>Static Context Components</caption>
<tbody>

<tr>
<th>Component</th>
<th>Scope</th>
</tr>

<tr>
  <td>XPath 1.0 Compatibility Mode</td>
  <td>global</td>
</tr>
<tr>
  <td>Statically known namespaces</td>
  <td>global</td>
</tr>
<tr>
  <td>Default element/type namespace</td>
  <td>global</td></tr>
<tr>
  <td>Default function namespace</td>
  <td>global</td></tr>
<tr>
  <td>In-scope schema types</td>
  <td>global</td></tr>
<tr>
  <td>In-scope element declarations</td>
  <td>global</td></tr>
<tr>
  <td>In-scope attribute declarations</td>
  <td>global</td></tr>
<tr>
  <td>In-scope variables</td>
  <td>lexical; for-expressions, let-expressions, and quantified expressions can bind new variables</td></tr>
<tr>
  <td>Context value static type</td>
  <td>lexical</td></tr>
<tr>
  <td>Statically known function signatures</td>
  <td>global</td></tr>
<tr>
  <td>Statically known collations</td>
  <td>global</td></tr>
<tr>
  <td>Default collation</td>
  <td>global</td></tr>
<tr>
  <td>Base URI</td>
  <td>global</td></tr>
<tr>
  <td>Statically known documents</td>
  <td>global</td></tr>
<tr>
  <td>Statically known collections</td>
  <td>global  </td></tr>
<tr>
  <td>Statically known default collection type</td>
  <td>global</td></tr>
</tbody>
</table></div2>

<div2 id="id-xp-evaluation-context-components">
  <head>Dynamic Context Components</head>
  <p>The following table describes how values are assigned to the various components of the
    <term>dynamic context</term>. All these components are initialized by mechanisms
    defined by the host language. For each component, “global” indicates that the value
    of the component remains constant throughout evaluation of the XPath expression,
    whereas “dynamic” indicates that the value of the component can be modified by the
    evaluation of subexpressions.</p>
<table width="60%" border="1" role="small">
<caption>Dynamic Context Components</caption>
<tbody>

<tr>
<th>Component</th>



<th>Scope</th>
</tr>

<tr>
  <td>Context value</td>
  <td>dynamic; changes during evaluation of path expressions and predicates</td>
</tr>
<tr>
  <td>Context position</td>
  <td>dynamic; changes during evaluation of path expressions and predicates</td>
</tr>
<tr>
  <td>Context size</td>
  <td>dynamic; changes during evaluation of path expressions and predicates</td></tr>
<tr>
  <td>Variable values</td>
  <td>dynamic; for-expressions, let-expressions, and quantified expressions can bind new variables</td></tr>
<tr>
  <td>Current date and time</td>
  <td>global; must be initialized <phrase role="xquery">by implementation</phrase></td></tr>
<tr>
  <td>Implicit timezone</td>
  <td>global; must be initialized <phrase role="xquery">by implementation</phrase></td></tr>
<tr>
  <td>Available documents</td>
  <td>global; must be initialized <phrase role="xquery">by implementation</phrase></td></tr>
<tr>
  <td>Available node collections</td>
  <td>global; must be initialized <phrase role="xquery">by implementation</phrase></td></tr>
<tr>
  <td>Default collection</td>
  <td>global; overwriteable by implementation</td></tr>
  <tr>
    <td>Available URI collections</td>
    <td>global; must be initialized <phrase role="xquery">by implementation</phrase></td></tr>
  <tr>
    <td>Default URI collection</td>
    <td>global; overwriteable by implementation</td></tr>  
</tbody>
</table></div2></div1>
<div1 id="id-impl-defined-items"><head>Implementation-Defined Items</head><p>The following items in this specification 
  are <termref def="dt-implementation-defined">implementation-defined</termref>:</p><olist>
<item><p>The version of Unicode that is used to construct expressions.</p></item>
<item><p>The <termref def="dt-static-collations">statically-known collations</termref>.</p></item>
<item><p>The <termref def="dt-timezone">implicit timezone</termref>.</p></item>
<item><p>The circumstances in which <termref def="dt-warning">warnings</termref> are raised, and the ways in which warnings are handled.</p></item>
<item><p>The method by which errors are reported to the external processing environment.</p></item>

<item><p>Which version of XML and XML Names (e.g. <bibref ref="XML"/> and <bibref ref="XMLNAMES"/> or <bibref ref="XML1.1"/> and <bibref ref="XMLNAMES11"/>) and which version of XML Schema (e.g. <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/>) is used for the definitions of primitives such as characters and names, and for the definitions  of operations such as normalization of line endings and normalization of whitespace in attribute values. It is recommended that the latest applicable version be used (even if it is published later than this specification).</p></item>

<item><p>How XDM instances are created from sources other than an Infoset or PSVI.</p></item>
<item role="xquery"><p>Any components of the <termref def="dt-static-context">static context</termref> or <termref def="dt-dynamic-context">dynamic context</termref> that are overwritten or augmented by the implementation.</p></item><item role="xpath"><p>Whether the implementation supports the namespace axis.</p></item>
<item role="xquery"><p>The default handling of empty sequences returned by an ordering key (orderspec) in an <code>order by</code> clause (<code>empty least</code> or <code>empty greatest</code>).</p></item><item role="xquery"><p>The names and semantics of any <termref def="dt-extension-expression">extension expressions</termref> (<termref def="dt-pragma">pragmas</termref>) recognized by the implementation.</p></item><item role="xquery"><p>The names and semantics of any <termref def="dt-option-declaration">option declarations</termref>  recognized by the implementation.</p></item><item role="xquery"><p>Protocols (if any) by which parameters can be passed to an external function, and the result of the function can returned to the invoking query.</p></item><item role="xquery"><p>The process by which the specific modules to be imported by a
<termref def="dt-module-import">module import</termref> are identified, if the <termref def="dt-module-feature">Module Feature</termref> is supported (includes processing of location hints, if any.)</p></item>

<item role="xquery"><p>The means by which serialization is invoked, if the <termref def="dt-serialization-feature">Serialization Feature</termref> is supported.</p></item><item role="xquery"><p>The default values for the <code>byte-order-mark</code>, <code>encoding</code>, <code>html-version</code>, <code>item-separator</code>, <code>media-type</code>, <code>normalization-form</code>, <code>omit-xml-declaration</code>, <code>standalone</code>, and <code>version</code> parameters, if the <termref def="dt-serialization-feature">Serialization Feature</termref> is supported.</p></item><item role="xquery"><p>The result of an unsuccessful call to an external function (for example,
if the function implementation cannot be found or does not return a value
of the declared type).</p></item><item role="xquery"><p>Limits on ranges of values for various data types, as enumerated in <specref ref="id-data-model-conformance"/>.</p></item>

<item role="xquery"><p>Syntactic extensions to XQuery, including both their syntax and semantics, as discussed in <specref ref="id-syntax-extensions"/>.</p></item>

<item><p>Whether the type system is based on <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/>. An implementation that has based its type system on XML Schema 1.0 is not required to support the use of the <code>xs:dateTimeStamp</code> constructor or the use of <code>xs:dateTimeStamp</code> or <code>xs:error</code> as <nt def="TypeName">TypeName</nt> in any expression.</p></item>

<item><p>The signatures of functions provided by the implementation or via an implementation-defined API (see <specref ref="static_context"/>).</p></item>

<item><p>Any <termref def="dt-environment-variables">environment variables</termref> provided by the implementation.</p></item>

<item><p>Any rules used for static typing (see <specref ref="id-static-analysis"/>).</p></item>

<item><p>Any serialization parameters provided by the implementation<phrase role="xquery"> (see  <specref ref="id-serialization"/>).</phrase></p></item>

<item role="xquery"><p>The means by which the location hint for a serialization parameter document identifies the corresponding XDM instance (see  <specref ref="id-serialization"/>).</p></item>

<item><p>What error, if any, is returned if an external function's implementation does not return the declared result type (see <specref ref="id-consistency-constraints"/>).</p></item>

<item role="xquery"><p>Any annotations defined by the implementation, and their associated behavior (see <specref ref="id-annotations"/>).</p></item>

<item role="xquery"><p>Any <termref def="dt-function-assertion">function assertions</termref> defined by the implementation.</p></item>

<item role="xquery"><p>The effect of function assertions understood by the implementation on <specref ref="id-assertions-subtype"/>.</p></item>

<item role="xquery"><p>Any implementation-defined variables defined by the implementation. (see <specref ref="id-variables"/>).</p></item>

<item role="xquery"><p>The ordering associated with <code>fn:unordered</code> in the implementation (see <specref ref="id-unordered-expressions"/>).</p></item>

<item role="xquery"><p>Any additional information provided for try/catch via the <code>err:additional</code> variable (see <specref ref="id-try-catch"/>).</p></item>

<item role="xquery"><p>The default boundary-space policy (see <specref ref="id-boundary-space-decls"/>).</p></item>

<item role="xquery"><p>The default collation (see <specref ref="id-default-collation-declaration"/>).</p></item>

<item role="xquery"><p>The default base URI (see <specref ref="id-base-uri-decl"/>).</p></item>

</olist>

<note><p>Additional <termref def="dt-implementation-defined">implementation-defined</termref> 
  items are listed in <bibref ref="xpath-datamodel-40"/> and <bibref ref="xpath-functions-40"/>.</p></note></div1>
<div1 id="id-references">
<head>References</head>
<div2 id="id-normative-references">
<head>Normative References</head>

<blist>

<bibl id="RFC2119" key="RFC2119">S. Bradner.
      <emph>Key Words for use in RFCs to Indicate Requirement Levels.</emph> IETF RFC 2119.
      See <loc href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</loc>.</bibl>

<bibl id="RFC3986" key="RFC3986">T. Berners-Lee, R. Fielding, and
      L. Masinter.  <emph>Uniform Resource Identifiers (URI): Generic
      Syntax</emph>. IETF RFC 3986.
      See <loc href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</loc>.</bibl>

<bibl id="RFC3987" key="RFC3987">M. Duerst and M. Suignard.
      <emph>Internationalized Resource Identifiers (IRIs)</emph>.
      IETF RFC 3987. See <loc href="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</loc>.</bibl>

<bibl id="ISO10646" key="ISO/IEC 10646">ISO (International Organization for Standardization).
      <emph>ISO/IEC 10646:2003. Information technology&mdash;Universal Multiple-Octet Coded Character Set (UCS)</emph>,
      as, from time to time, amended, replaced by a new edition, or expanded by the addition of new parts.
      [Geneva]: International Organization for Standardization.
      (See <loc href="http://www.iso.org">http://www.iso.org</loc> for the latest version.)</bibl>

<bibl id="Unicode" key="Unicode">The Unicode Consortium. <emph>The Unicode Standard.</emph>
      Reading, Mass.: Addison-Wesley, 2003, as updated from time to time by the publication of new versions.
      See <loc href="http://www.unicode.org/standard/versions/">http://www.unicode.org/standard/versions/</loc>
      for the latest version and additional information on versions of the standard and of the Unicode Character Database.
      The version of Unicode to be used is <termref def="dt-implementation-defined">implementation-defined</termref>,
      but implementations are recommended to use the latest Unicode version.</bibl>

<bibl xmlns:xlink="http://www.w3.org/1999/xlink" id="XML" key="XML 1.0"
      xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">World Wide Web Consortium.
      <emph>Extensible Markup Language (XML) 1.0.</emph>
      W3C Recommendation.
      See <loc href="http://www.w3.org/TR/REC-xml/" xlink:type="simple" xlink:show="replace"
      xlink:actuate="onRequest">http://www.w3.org/TR/REC-xml/</loc>.
      The edition of XML 1.0 must be no earlier than the Third Edition;
      the edition used is <termref def="dt-implementation-defined">implementation-defined</termref>,
      but we recommend that implementations use the latest version.
</bibl>

<bibl id="XML1.1" key="XML 1.1">World Wide Web Consortium.
      <emph>Extensible Markup Language (XML) 1.1.</emph>
      W3C Recommendation.
      See <loc href="http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</loc>
</bibl>

<bibl id="XMLBASE" key="XML Base">World Wide Web Consortium.
      <emph>XML Base.</emph> W3C Recommendation. See
      <loc href="http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</loc>
</bibl>

<bibl id="XMLNAMES" key="XML Names">World Wide Web Consortium.
      <emph>Namespaces in XML.</emph> W3C Recommendation. See
      <loc href="http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</loc>
</bibl>

<bibl id="XMLNAMES11" key="XML Names 1.1">World Wide Web Consortium.
      <emph>Namespaces in XML 1.1.</emph> W3C Recommendation. See
      <loc href="http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</loc>
</bibl>

<bibl id="XMLID" key="XML ID">World Wide Web Consortium. <emph>xml:id Version 1.0.</emph>
      W3C Recommendation. See <loc href="http://www.w3.org/TR/xml-id/">http://www.w3.org/TR/xml-id/</loc></bibl>

<bibl id="XMLSchema10" key="XML Schema 1.0">World Wide Web Consortium.
      <emph>XML Schema, Parts 0, 1, and 2 (Second Edition)</emph>. W3C Recommendation, 28 October 2004.
      See <loc href="http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</loc>,
      <loc href="http://www.w3.org/TR/xmlschema-1/" id="schema1">http://www.w3.org/TR/xmlschema-1/</loc>,
      and <loc href="http://www.w3.org/TR/xmlschema-2/" id="schema2">http://www.w3.org/TR/xmlschema-2/</loc>.</bibl>

<bibl id="XMLSchema11" key="XML Schema 1.1">World Wide Web Consortium.
      <emph>XML Schema, Parts 1, and 2</emph>. W3C Recommendation 5 April 2012.
      See <loc href="http://www.w3.org/TR/xmlschema11-1/" id="schema1-11">http://www.w3.org/TR/xmlschema11-1/</loc>,
      and <loc href="http://www.w3.org/TR/xmlschema11-2/" id="schema2-11">http://www.w3.org/TR/xmlschema11-2/</loc>.</bibl>

<bibl id="xpath-datamodel-40" key="XQuery and XPath Data Model (XDM) 4.0"/>

<bibl id="xpath-functions-40" key="XQuery and XPath Functions and Operators 4.0"/>
  
  <bibl id="xpath-40" key="XPath 4.0"/>
  

<bibl id="xslt-xquery-serialization-40" key="XSLT and XQuery Serialization 4.0"/>

<!--<bibl id="xquery-update-30" key="XQuery Update Facility 3.0" role="xquery"/>-->


</blist>
</div2>
<div2 id="id-non-normative-references">
<head>Non-normative References</head>

<blist>

<bibl id="xquery-30-requirements" key="XQuery 3.0 Requirements" role="xquery"/>
<bibl id="xquery-31-requirements" key="XQuery 3.1 Requirements" role="xquery"/>

<bibl id="xquery-30" key="XQuery 3.0: An XML Query Language" role="xquery"/>
<bibl id="xquery-31" key="XQuery 3.1: An XML Query Language" role="xpath"/>

<bibl id="xquery-semantics" key="XQuery 1.0 and XPath 2.0 Formal Semantics"/>

<!--<bibl id="xqueryx-31" key="XQueryX 3.1" role="xquery"/>-->

<bibl id="xslt-40" key="XSL Transformations (XSLT) Version 4.0"/>

<bibl id="DOM" key="Document Object Model" role="xquery">World Wide Web Consortium. <emph>Document Object Model (DOM) Level 3 Core Specification.</emph> W3C Recommendation, April 7, 2004. See <loc href="http://www.w3.org/TR/DOM-Level-3-Core/">http://www.w3.org/TR/DOM-Level-3-Core/</loc>.</bibl>

<bibl id="XINFO" key="XML Infoset">World Wide Web
Consortium. <emph>XML Information Set (Second Edition).</emph> W3C Recommendation 4 February 2004. See
<loc href="http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</loc>
</bibl>

<bibl key="XML Path Language (XPath) Version 1.0" id="xpath"/>

<bibl key="XML Path Language (XPath) Version 2.0" id="xpath20"/>

<bibl key="XML Path Language (XPath) Version 3.0" id="xpath-30"/>
<bibl key="XML Path Language (XPath) Version 3.1" id="xpath-31" role="xquery"/>

<bibl id="XPTR" key="XPointer">World Wide Web Consortium. <emph>XML
Pointer Language (XPointer).</emph> W3C Last Call Working Draft 8 January 2001.
See <loc href="http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</loc></bibl>

<bibl id="UseCases" key="XML Query Use Cases" role="xquery">World Wide
Web Consortium. <emph>XML Query Use Cases</emph>. W3C Working Draft, 8 June 2006.
See <loc href="http://www.w3.org/TR/xquery-use-cases/">http://www.w3.org/TR/xquery-use-cases/</loc>.</bibl>

<bibl id="xml11schema10" key="XML 1.1 and Schema 1.0" role="xquery">World Wide
Web Consortium. <emph>Processing XML 1.1 Documents with XML Schema 1.0 Processors</emph>.
W3C Working Group Note, 11 May 2005.
See <loc href="http://www.w3.org/TR/xml11schema10/">http://www.w3.org/TR/xml11schema10/</loc>.</bibl>

<bibl id="RFC1738" key="Uniform Resource Locators (URL)" role="xquery">Internet Engineering Task Force (IETF).
<emph>Uniform Resource Locators (URL)</emph>. Request For Comment No. 1738, Dec. 1994.
See <loc href="http://www.ietf.org/rfc/rfc1738.txt">http://www.ietf.org/rfc/rfc1738.txt</loc>.</bibl>

<bibl key="ODMG" id="ODMG" role="xquery">Rick Cattell et al. <emph>The
Object Database Standard: ODMG-93, Release 1.2</emph>. Morgan Kaufmann
Publishers, San Francisco, 1996.</bibl>

<bibl key="Quilt" id="Quilt" role="xquery">Don Chamberlin,
Jonathan Robie, and Daniela Florescu. <emph>Quilt: an XML Query Language for
Heterogeneous Data Sources</emph>.  In <emph>Lecture Notes in Computer
Science</emph>, Springer-Verlag, Dec. 2000.  
<!--
Also available at <loc href="http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf">http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf</loc>.
See also <loc href="http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html">http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html</loc>.
-->
</bibl>

<bibl key="XML-QL" id="XML-QL" role="xquery">Alin Deutsch, Mary Fernandez,
Daniela Florescu, Alon Levy, and Dan Suciu.
<emph>A Query Language for XML</emph>.
</bibl>

<bibl key="SQL" id="SQL" role="xquery">International Organization for
Standardization (ISO).  <emph>Information Technology &mdash; Database Language
SQL</emph>. Standard No. ISO/IEC 9075:2011.  (Available from American
National Standards Institute, New York, NY 10036, (212)
642-4900.)</bibl>

<bibl key="XQL" id="XQL" role="xquery">J. Robie, J. Lapp, D. Schach. <emph>XML
Query Language (XQL)</emph>. See <loc href="http://www.w3.org/TandS/QL/QL98/pp/xql.html">http://www.w3.org/TandS/QL/QL98/pp/xql.html</loc>.</bibl>

</blist>
</div2>

<div2 id="id-background-material"><head>Background Material</head>
<blist>

<bibl id="CHARMOD" key="Character Model">World Wide Web Consortium.
<emph>Character Model for the World Wide Web.</emph> W3C Working
Draft. See <loc href="http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</loc>.</bibl>

<bibl id="xslt" key="XSL Transformations (XSLT) Version 1.0"/>

<bibl id="UseCaseQueries" key="Use Case Sample Queries" role="xquery">Queries
from the XQuery 1.0 Use Cases, presented in a single file.
See
<loc href="http://www.w3.org/2010/12/xquery-30-use-cases/xquery-30-use-case-queries.txt">http://www.w3.org/2010/12/xquery-30-use-cases/xquery-30-use-case-queries.txt</loc>.
</bibl>

<bibl id="XQueryQueries" key="XQuery Sample Queries" role="xquery">Queries
from this document, presented in a single file.
See
<loc href="http://www.w3.org/2013/01/xquery-30-use-cases/xquery-30-example-queries.txt">http://www.w3.org/2013/01/xquery-30-use-cases/xquery-30-example-queries.txt</loc>.
</bibl>

<bibl id="Moustache" key="Moustache" role="xquery">
<emph>mustache</emph> - Logic-less templates. See
<loc href="http://mustache.github.io/mustache.5.html">http://mustache.github.io/mustache.5.html</loc>.
</bibl>

</blist>
</div2>
</div1>


&errors;&mime-type;<inform-div1 id="id-glossary"><head>Glossary</head>
<!-- This processing instruction automatically generates the glossary. -->
<?glossary?>
</inform-div1>

<inform-div1 id="id-atomic-comparisons">
  <head>Atomic Comparisons: An Overview</head>
  <p>This appendix provides a non-normative summary of the various functions and operators used for comparison
    of atomic items, with some background on the history and rationale.</p>
  
  
  <div2 id="id-equality-comparison">
    <head>Equality Comparisons</head>
    <p>In &language; there are essentially four ways of comparing two atomic items for equality:</p>
    
    <ulist>
      <item><p><code>$A = $B</code></p>
        <p>This operator was introduced in XPath 1.0. The semantics were changed slightly in XPath 2.0, but the
          original semantics remain available when XPath 1.0 compatibility mode is enabled.</p>
        <p>With a general comparison in XPath 2.0 or later (and in XQuery), the following rules are observed:</p>
        <ulist>
          <item><p>Either operand may be a sequence; the result is true if any pair of items from the
            two sequences compares equal.</p>
            <p>In consequence, if either operand is an empty sequence, the result is false.</p></item>
          <item><p>If nodes are supplied, they are atomized.</p></item>
          <item><p>Untyped atomic items appearing in one operand are converted to the type of the
            other operand (if both operands are untyped atomic, they are compared as strings).</p></item>
          <item><p>As a result, the operator is not transitive: the untyped atomic items <code>"4.0"</code>
            and <code>"4"</code> are not equal to each other, but both compare equal to the integer value 
            <code>4</code>.</p></item>
          <item><p>Comparison of certain values is context-sensitive. In particular, comparison of strings
            uses the default collation from the static context, while comparison of date/time values lacking
            an explicit timezone takes the timezone from the dynamic context.</p></item>
          <item><p>NaN is not equal to NaN; negative zero is equal to positive zero.</p></item>
          <item><p><code>xs:hexBinary</code> and <code>xs:base64Binary</code> values are mutually comparable:
          they are equal if they represent the same sequence of octets.</p></item>
          <item><p>Comparing incompatible values (for example <code>xs:integer</code> and <code>xs:date</code>)
            raises an error.</p></item>
        </ulist>
      </item>
      <item><p><code>$A eq $B</code></p>
        <p>Value comparisons were introduced in XPath 2.0 and XQuery 1.0. One of the aims was to make
          the comparison transitive (a precondition for a wide variety of optimizations), however in edge
          cases involving comparisons across different numeric types this was not entirely achieved.</p>
        <p>With a value comparison, the rules are:</p>
        <ulist>
          <item><p>Each operand must either be a single atomic item, or an empty sequence.</p></item>
          <item><p>If either operand is an empty sequence, the result is an empty sequence; in most
            contexts this has the same effect as returning false.</p></item>
          <item><p>If nodes are supplied, they are atomized.</p></item>
          <item><p>Untyped atomic items are converted to strings (regardless of the type of the other operand).</p></item>
          <item><p>Numeric values of types <code>xs:integer</code>, <code>xs:decimal</code>, or <code>xs:float</code>
            are converted to <code>xs:double</code>.</p>
            <p>This can lead to problems with implementations of <code>xs:decimal</code> that support more precision 
              than can be held in an <code>xs:double</code>.</p></item>
          <item><p>As with general comparisons, the default collation and implicit timezone are taken from the
            context.</p></item>
          <item><p>NaN is not equal to NaN; negative zero is equal to positive zero.</p></item>
          <item><p><code>xs:hexBinary</code> and <code>xs:base64Binary</code> values are mutually comparable:
            they are equal if they represent the same sequence of octets.</p></item>
          <item><p>Comparing incompatible values (for example <code>xs:integer</code> and <code>xs:date</code>)
            raises an error.</p></item>
        </ulist>
      </item>
      <item><p><code>deep-equal($A, $B)</code></p>
        <p>As the name implies, the <code>deep-equal</code> function was introduced primarily for comparing nodes,
          or sequences of nodes; however in its simplest form it can also be used to compare two atomic items. The semantics
          of the comparison used by <code>deep-equal($A, $B)</code> are also invoked by a wide variety of other functions
          including <code>distinct-values</code>, <code>all-equal</code>, and <code>all-different</code>; it is also
          used to underpin grouping constructs in both XQuery 4.0 and XSLT 4.0.</p>
        <p>Some of the relevant rules are:</p>
        <ulist>
          <item><p>Because <code>deep-equal</code> is used to compare sequences, if one of the operands is an empty
            sequence the result is false; but if both operands are empty sequences, the result is true.</p></item>
          <item><p>If nodes are supplied, they are not atomized; they are compared as nodes.</p></item>
          <item><p>Strings can be compared using the default collation or using an explicitly specified collation;
            there are also options to compare after normalizing whitespace or unicode.</p></item>
          <item><p>Comparisons of dates and times lacking a timezone uses the implicit timezone from the dynamic
            context.</p></item>
          <item><p>Numeric values are converted to <code>xs:decimal</code> prior to comparison, not to <code>xs:double</code>.
            This represents a departure in 4.0 from previous versions of the specification. The conversion must use
            an implementation of <code>xs:decimal</code> that does not cause loss of precision. As a result, the comparison
            is now truly transitive, which makes it suitable to underpin grouping operations.</p></item>
          <item><p>To ensure that every value is equal to itself, comparing NaN to NaN returns true.</p></item>
          <item><p><code>xs:hexBinary</code> and <code>xs:base64Binary</code> values are mutually comparable:
            they are equal if they represent the same sequence of octets.</p></item>
          <item><p>Comparing incompatible values (for example <code>xs:integer</code> and <code>xs:date</code>)
            returns false; it does not raise an error.</p></item>
        </ulist></item>
      <item><p><code>atomic-equal($A, $B)</code></p>
        <p>This comparison operation was introduced in XPath 3.0 (and XQuery 3.0) for comparing keys in maps;
          the 4.0 specifications expose it directly as a function that can be called from user applications.
          The dominant requirements for keys in maps were that the comparison should be transitive, error-free, 
          and context-independent. The relevant rules are:</p>
        <ulist>
          <item><p>The type signature of the function ensures that it can only be used to compare
            single items; empty sequences do not arise.</p></item>
          <item><p>If nodes are supplied, they are atomized.</p></item>
          <item><p>Strings are compared codepoint-by-codepoint, without reference to any collation or
            normalization.</p></item>
          <item><p>Dates and times lacking a timezone are never equal to dates and times that have a timezone.
            However, when comparing two dates or times that both have a timezone, the timezone is normalized.</p></item>
          <item><p>As with <code>deep-equal</code>, numeric values are converted to <code>xs:decimal</code> 
            prior to comparison, not to <code>xs:double</code>.</p></item>
          <item><p>Comparing NaN to NaN returns true.</p></item>
          <item><p><code>xs:hexBinary</code> and <code>xs:base64Binary</code> values are distinct:
            both can co-exist as distinct keys in a map even if the underlying sequence of octets is the same.</p></item>
          <item><p>Comparing incompatible values (for example <code>xs:integer</code> and <code>xs:date</code>)
            returns false; it does not raise an error.</p></item>
        </ulist>
        
      </item>
    </ulist>
      
      <p>The following table summarizes these differences. For all these examples it is assumed that
      (a) the default collation is the HTML case-blind collation, (b) the implicit timezone is
      +01:00, and (c) nodes are untyped.</p>
      
      <table border="1" role="small">
        <thead>
          <tr>
            <th><code>$A</code></th>
            <th><code>$B</code></th>
            <th><code>$A = $B</code></th>
            <th><code>$A eq $B</code></th>
            <th><code>deep-equal(&#x200B;$A, $B)</code></th>
            <th><code>atomic-equal(&#x200B;$A, $B)</code></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><p><code>()</code></p></td>
            <td><p><code>()</code></p></td>
            <td><p><code>false</code></p></td>
            <td><p><code>()</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>error</code></p></td>
          </tr>
          <tr>
            <td><p><code>12</code></p></td>
            <td><p><code>()</code></p></td>
            <td><p><code>false</code></p></td>
            <td><p><code>()</code></p></td>
            <td><p><code>false</code></p></td>
            <td><p><code>error</code></p></td>
          </tr>
          <tr>
            <td><p><code>(1,2)</code></p></td>
            <td><p><code>(2,3)</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>error</code></p></td>
            <td><p><code>false</code></p></td>
            <td><p><code>error</code></p></td>
          </tr>
          <tr>
            <td><p><code>12</code></p></td>
            <td><p><code>12e0</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
          </tr>
          <tr>
            <td><p><code>0.2</code></p></td>
            <td><p><code>0.2e0</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>false</code></p></td>
            <td><p><code>false</code></p></td>
          </tr>
          <tr>
            <td><p><code>NaN</code></p></td>
            <td><p><code>NaN</code></p></td>
            <td><p><code>false</code></p></td>
            <td><p><code>false</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
          </tr>
          <tr>
            <td><p><code>+0e0</code></p></td>
            <td><p><code>-0e0</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
          </tr>
          <tr>
            <td><p><code>"A"</code></p></td>
            <td><p><code>"a"</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>false</code></p></td>
          </tr>
          <tr>
            <td><p><code>"A"</code></p></td>
            <td><p><code>12</code></p></td>
            <td><p><code>error</code></p></td>
            <td><p><code>error</code></p></td>
            <td><p><code>false</code></p></td>
            <td><p><code>false</code></p></td>
          </tr>
          <tr>
            <td><p><code><![CDATA[<a>A</a>]]></code></p></td>
            <td><p><code>"A"</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>false</code></p></td>
            <td><p><code>true</code></p></td>
          </tr>
          <tr>
            <td><p><code><![CDATA[<a>12</a>]]></code></p></td>
            <td><p><code>12</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>error</code></p></td>
            <td><p><code>false</code></p></td>
            <td><p><code>false</code></p></td>
          </tr>
          <tr>
            <td><p><code>xs:time(&#x200B;'12:00:00Z')</code></p></td>
            <td><p><code>xs:time(&#x200B;'13:00:00+01:00')</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
          </tr>
          <tr>
            <td><p><code>xs:time(&#x200B;'12:00:00Z')</code></p></td>
            <td><p><code>xs:time(&#x200B;'13:00:00')</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>false</code></p></td>
          </tr>
          <tr>
            <td><p><code>xs:hexBinary(&#x200B;"0000")</code></p></td>
            <td><p><code>xs:base64Binary(&#x200B;"AAA=")</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>true</code></p></td>
            <td><p><code>false</code></p></td>
          </tr>
        </tbody>
      </table>

  </div2>
  <div2 id="id-ordering-comparison">
    <head>Ordering Comparisons</head>
    <p>In &language; there are essentially three ways of comparing two atomic items for their relative ordering:</p>
    
    <ulist>
      <item><p><code>$A &lt; $B</code></p></item>
      <item><p><code>$A lt $B</code></p></item>
      <item><p><code>Sorting</code></p></item>
    </ulist>
    
    <p>TODO: to be expanded.</p>
  </div2>
  
</inform-div1>


<inform-div1 id="id-incompatibilities">

<head>Backwards Compatibility</head>
  
  <div2 id="id-incompatibilities-31" diff="add" at="2022-11-16">
    <head>Incompatibilities relative to &language-tech; 3.1</head>
    
    <p>In <code>fn:format-integer</code>, certain formatting pictures using a circumflex as a grouping separator might
    be interpreted differently in 4.0: for example <code>format-integer(1234, "9^999")</code> would output <code>"1^234"</code>
      in 3.1, but will output <code>"1621"</code> (1234 in base 9) with 4.0. As a workaround, this can be rewritten as 
      <code>format-integer(1234, "0^000")</code>.</p>
    
    <p role="xquery">In computed node constructors, the node name must now be written in quotation marks
    if it matches certain language keywords. For example <code>element div {}</code> must now be
    written <code>element "div" {}</code>. (Alternatively, <code>element { "div" } {}</code>
    and <code>element Q{}div {}</code> are permitted by both XQuery 3.1 and XQuery 4.0.)
    This change is made because <code>{}</code> is now a valid expression representing an
    empty map, so expressions such as <code>element otherwise {}</code> could (without this rule) be 
    parsed in two different ways.</p>
    
    <p>In &language;, certain expressions are classified as <termref def="dt-implausible"/>: an example
    is <code>@code/text()</code>, which will always return an empty sequence. A processor may report
    a static error when such expressions are encountered; however, processors are <rfc2119>required</rfc2119>
    to provide a mode of operation in which such expressions are accepted, thus retaining backwards
    compatibility.</p>
    
    <p>In expressions that deliver a function item, notably partial function applications, named function references,
    and the <code>fn:function-lookup</code> function, errors may now be detected at the point where the function item
    is created when they were previously detected at the point where the function item was called. This was underspecified
    in previous versions. For example, the partial function application <code>contains(?, 42)</code> is now required to
    raise a type error (because the second argument should be a string, not an integer) at the point where the partial
    function application occurs, not at the point where the resulting function is called.</p>
    
    <p>As explained in <specref ref="id-function-coercion"/>, the fact that coercion rules are now applied
    to global variables and local variable bindings introduces an incompatibility in the case of variables
    whose value is a function item. Previously it was possible to supply a function item that accepted a wider
    range of argument values than those declared in the variable's type declaration; this is no longer the case.</p>
  </div2>

<div2 id="id-incompatibilities-30">
<head>Incompatibilities relative to &language-tech; 3.0</head>
<p>The following names are now reserved, and cannot appear as function names (see <specref ref="id-reserved-fn-names"/>):</p>

<ulist>
  <item>
    <p>
      <code>map</code>
    </p>
  </item>
  <item>
    <p>
      <code>array</code>
    </p>
  </item>
</ulist>
</div2>

<div2 id="id-incompatibilities-10">
<head>Incompatibilities relative to &language-tech; <phrase role="xpath">2.0</phrase><phrase role="xquery">1.0</phrase></head>

<p>The following names are now reserved, and cannot appear as function names (see <specref ref="id-reserved-fn-names"/>):</p>

<ulist>
  <item>
    <p>
      <code>function</code>
    </p>
  </item>
  <item>
    <p>
      <code>namespace-node</code>
    </p>
  </item>
  <item>
    <p>
      <code>switch</code>
    </p>
  </item>
</ulist>


<p>If <code>U</code> is a union type with <code>T</code> as one of its members,
  and if <code>E</code> is an element with <code>T</code> as its type annotation,
  the expression <code role="parse-test">E instance of element(*, U)</code>
  returns <code>true</code> in both &language-tech; 3.0 and 3.1.
  In <phrase role="xpath">XPath 2.0</phrase><phrase role="xquery">XQuery 1.0</phrase>,
  it returns <code>false</code>.</p>

 <note><p>This is not an incompatibility with &language-tech; 3.0.
 It should be included in &language-tech; 3.0 as an incompatibility with
 <phrase role="xpath">XPath 2.0</phrase><phrase role="xquery">XQuery 1.0</phrase>,
 but it was discovered after publication.</p></note>
</div2>

&xpath-backwards-compat;

</inform-div1>

<inform-div1 id="id-revision-log" diff="chg" at="2022-11-16">
<head>Change Log</head>
  

  <?change-log?>

</inform-div1>
