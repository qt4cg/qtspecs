<?xml version="1.0" encoding="UTF-8"?>
<div1 role="xquery" id="id-query-prolog">
  <head role="xquery">Modules and Prologs</head>
  <scrap>
    <prodrecap ref="Module"/>
  </scrap>
  <p>A query can be assembled from one or more fragments called <term>modules</term>. <termdef
      term="module" id="dt-module">A <term>module</term> is a fragment of XQuery code that conforms
      to the <nt def="Module">Module</nt> grammar and can independently undergo the <termref
        def="dt-static-analysis">static analysis phase</termref> described in <specref
        ref="id-expression-processing"/>. Each module is either a <termref def="dt-main-module">main
        module</termref> or a <termref def="dt-library-module">library
    module</termref>.</termdef></p>
  <p>
    <termdef id="dt-main-module" term="main module">A <term>main module</term> consists of a
        <termref def="dt-prolog">Prolog</termref> followed by a <termref def="dt-queryBody">Query
        Body</termref>.</termdef> A query has exactly one main module. In a main module, the
      <termref def="dt-queryBody">Query Body</termref> is evaluated with respect to the static and
    dynamic contexts of the main module in which it is found, and its value is the result of the
    query.</p>
  <p><termdef id="dt-library-module" term="library module">A module that does not contain a <termref
        def="dt-queryBody">Query Body</termref> is called a <term>library module</term>. A library
      module consists of a <termref def="dt-module-declaration">module declaration</termref>
      followed by a <termref def="dt-prolog">Prolog</termref>.</termdef> A library module cannot be
    evaluated directly; instead, it provides function and variable declarations that can be imported
    into other modules.</p>
  <p>The XQuery syntax does not allow a <termref def="dt-module">module</termref> to contain both a
      <termref def="dt-module-declaration">module declaration</termref> and a <termref
      def="dt-queryBody">Query Body</termref>.</p>
  <p><termdef id="dt-prolog" term="Prolog">A <term>Prolog</term> is a series of declarations and
      imports that define the processing environment for the <termref def="dt-module"
        >module</termref> that contains the Prolog.</termdef> Each declaration or import is followed
    by a semicolon. A Prolog is organized into two parts. </p>
  <p>The first part of the Prolog consists of setters, imports, namespace declarations, and default
    namespace declarations. <termdef term="setter" id="dt-setter"><term>Setters</term> are
      declarations that set the value of some property that affects query processing, such as
      construction mode or default collation.</termdef> Namespace declarations and
    default namespace declarations affect the interpretation of <termref def="dt-qname">lexical
      QNames</termref> within the query. Imports are used to import definitions from schemas and
    modules. <termdef term="target namespace" id="dt-target-namespace"> The <term>target
        namespace</term> of a module is the namespace of the objects (such as elements or functions)
      that it defines. </termdef></p>
  <p>The second part of the Prolog consists of declarations of variables, functions, and options.
    These declarations appear at the end of the Prolog because they may be affected by declarations
    and imports in the first part of the Prolog.</p>
  <p><termdef id="dt-queryBody" term="query body">The <term>Query Body</term>, if present, consists
      of an expression that defines the result of the query.</termdef> Evaluation of expressions is
    described in <specref ref="id-expressions"/>. A module can be evaluated only if it has a Query
    Body.</p>


  <div2 id="id-version-declaration">
    <head>Version Declaration</head>

    <scrap>
      <prodrecap ref="VersionDecl"/>
    </scrap>

    <p>
      <termdef term="version declaration" id="dt-version-declaration">
      A <term>version declaration</term> can identify the applicable
      XQuery syntax and semantics for a <termref
      def="dt-module">module</termref>, as well as its
      encoding.</termdef></p>

      
      
      <p><termdef id="dt-version-number" term="XQuery version number">An <term>XQuery version number</term> 
        consists of two integers, referred to as the 
        <term>major version number</term> and the  <term>minor version number</term>.</termdef></p>
    
      <p>The version number is written as a <code>StringLiteral</code> following the <code>version</code>
      keyword, and in a conformant &language; query it <rfc2119>must</rfc2119> match the regular expression 
      <code>[1-9][0-9]*\.[0-9]</code>: for example <code>"4.0"</code>. The major version is the integer 
        preceding the dot (which must be written without any leading zero); the minor version is the
      integer after the dot (which must be a single digit).</p>
    
      <note>
        <p>XQuery 1.0 and 3.0 allowed the version number to be any string; XQuery 3.1 constrained it
        to consist of two integers separated by a dot. This left it unclear, for example,
        whether "3.01" was the same version number as "3.1", or whether "3.10" represented a higher version
        than "3.2". In 4.0 the rules have therefore been made stricter, to avoid any ambiguity.</p>
      </note>
    
      <p>If the version declaration is not
      present or the version is not included in the declaration, an
      XQuery 4.0 processor assumes a version of "4.0", unless configured otherwise using
      some external mechanism.</p>
    
      <p>The version number "4.0" indicates the intent that the module
      be processed by an <termref def="dt-xquery-40-processor">XQuery
        4.0 processor</termref>.</p>
    
      <p>An &language; processor must accept a module in which the version number is given as
      "1.0", "3.0", or "3.1". It is then <termref def="dt-implementation-defined"/> whether
      the module is processed using the syntax and semantics of the &language; specification, or the rules
      of the relevant earlier version. For example, if a query module specifies version <code>"3.0"</code>
      but contains a call to the <code>parse-html</code> function, the processor at its option can
      either raise an error, or process the function call according to the &language; specification.</p>
    
      <p>The &language; specification does not attempt to define the semantics of a query in which
      different modules use different version numbers. One approach is to process all modules as if
      they specified version "4.0". Another approach (which may be appropriate if modules
      are separately compiled) is to process each module using its own version number; but it is then
      <termref def="dt-implementation-defined"/> what happens if (say) a 3.1 module imports a 
      4.0 library module that declares a function with a signature that 3.1 does not recognize.</p>
    
      <p>A conformant &language; processor <rfc2119>may</rfc2119> raise an error if the version number is anything
      other than "1.0", "3.0", "3.1", or "4.0". If the processor does not raise an error, the effect of such
      a query is <termref def="dt-implementation-defined"/>.</p>
    
      <note>
        <p>The effect of this rule is to permit the use of non-standard version numbers to
        label non-standard extensions of the XQuery language. It also leaves flexibility as
        to how an &language; processor should handle future version numbers such as "4.1",
        or version numbers such as "1" or "3.00" that were permitted by earlier XQuery
        specifications.</p>
      </note>
  
      <p>If a query is rejected because of a version mismatch with the processor, a static error  
      <errorref code="0031" class="ST"/> must be raised.</p>
      
      
    
    
    
      


    <p><termdef term="encoding declaration" id="dt-encoding-declaration">If present, a version
        declaration may optionally include an <term>encoding declaration</term>. The value of the
        string literal following the keyword <code>encoding</code> is an encoding name, and must
        conform to the definition of <code>EncName</code> specified in <bibref ref="XML"/><errorref
          code="0087" class="ST"/>. The purpose of an encoding declaration is to allow the writer of
        a query to provide a string that indicates how the query is encoded, such as
          <code>"UTF-8"</code>, <code>"UTF-16"</code>, or <code>"US-ASCII"</code>.</termdef> Since
      the encoding of a query may change as the query moves from one environment to another, there
      can be no guarantee that the encoding declaration is correct.</p>
    <p>The handling of an encoding declaration is <termref def="dt-implementation-dependent"
        >implementation-dependent</termref>. If an implementation has <emph>a priori</emph>
      knowledge of the encoding of a query, it may use this knowledge and disregard the encoding
      declaration. The semantics of a query are not affected by the presence or absence of an
      encoding declaration.</p>
    <p>If a version declaration is present, no <nt def="Comment">Comment</nt> may occur before the
      end of the version declaration. If such a <nt def="Comment">Comment</nt> is present, the
      result is <termref def="dt-implementation-dependent">implementation-dependent</termref>; an
      implementation may raise an implementation-dependent static error, or ignore the comment. <note>
        <p>The effect of a <code>Comment</code> before the end of a version declaration is
          implementation-dependent because it may suppress query processing by interfering with
          detection of the encoding declaration.</p></note></p>

    <p>The following examples illustrate version declarations:</p>

    <eg role="frag-prolog-parse-test">xquery version "3.1";</eg>
    <eg role="frag-prolog-parse-test">xquery version "4.0" encoding "utf-8";</eg>
  </div2>

  <div2 id="id-module-declaration">
    <head>Module Declaration</head>
    <scrap>
      <prodrecap ref="ModuleDecl"/>
    </scrap>
    <p>
      <termdef id="dt-module-declaration" term="module declaration">A <term>module
          declaration</term> serves to identify a <termref def="dt-module">module</termref> as a
          <termref def="dt-library-module">library module</termref>. A module declaration begins
        with the keyword <code>module</code> and contains a namespace prefix and a <nt
          def="URILiteral">URILiteral</nt>.</termdef> The URILiteral must be of nonzero length
        <errorref class="ST" code="0088"/>. The URILiteral identifies the <termref
        def="dt-target-namespace">target namespace</termref> of the library module, which is the
      namespace for all variables and functions exported by the library module. The name of every
      variable and function declared in a library module must have a namespace URI that is the same
      as the target namespace of the module; otherwise a <termref def="dt-static-error">static
        error</termref> is raised <errorref class="ST" code="0048"/>. The (prefix,URI) pair is added
      to the set of <termref def="dt-static-namespaces">statically known namespaces</termref>. </p>
    <p>The namespace prefix specified in a module declaration must not be <code>xml</code> or
        <code>xmlns</code>
      <errorref class="ST" code="0070"/>, and must not be the same as any namespace prefix bound in
      the same module by a <termref def="dt-schema-import">schema import</termref>, by a <termref
        def="dt-namespace-declaration">namespace declaration</termref>, or by a <termref
        def="dt-module-import">module import</termref> with a different target namespace <errorref
        class="ST" code="0033"/>.</p>
    <p>Any <termref def="dt-module">module</termref> may import one or more library modules by means
      of a <termref def="dt-module-import">module import</termref> that specifies the target
      namespace of the library modules to be imported. When a module imports one or more library
      modules, the variables and functions declared in the imported modules are added to the
        <termref def="dt-static-context">static context</termref> and (where applicable) to the
        <termref def="dt-dynamic-context">dynamic context</termref> of the importing module.</p>
    <p>The following is an example of a module declaration:</p>
    <eg role="frag-prolog-parse-test">module namespace gis = "http://example.org/gis-functions";</eg>

  </div2>

  <div2 id="id-boundary-space-decls">
    <head>Boundary-space Declaration</head>
    <scrap>
      <prodrecap ref="BoundarySpaceDecl"/>
    </scrap>
    <p>
      <termdef id="dt-boundary-space-decl" term="boundary-space declaration">A <term>boundary-space
          declaration</term> sets the <termref def="dt-boundary-space-policy">boundary-space
          policy</termref> in the <termref def="dt-static-context">static context</termref>,
        overriding any implementation-defined default. Boundary-space policy controls whether
          <termref def="dt-boundary-whitespace">boundary whitespace</termref> is preserved by
        element constructors during processing of the query.</termdef> If boundary-space policy is
        <code>preserve</code>, boundary whitespace is preserved. If boundary-space policy is
        <code>strip</code>, boundary whitespace is stripped (deleted). A further discussion of
      whitespace in constructed elements can be found in <specref ref="id-whitespace"/>.</p>
    <p>The following example illustrates a boundary-space declaration:</p>
    <eg role="frag-prolog-parse-test">declare boundary-space preserve;</eg>
    <p>If a Prolog contains more than one boundary-space declaration, a <termref
        def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0068"
      />.</p>
  </div2>
  <div2 id="id-default-collation-declaration">
    <head>Default Collation Declaration</head>
    <scrap>
      <prodrecap ref="DefaultCollationDecl"/>
    </scrap>
    <p>
      <termdef term="default collation declaration" id="dt-default-collation-decl">A <term>default
          collation declaration</term> sets the value of the <termref def="dt-def-collation">default
          collation</termref> in the <termref def="dt-static-context">static context</termref>,
        overriding any implementation-defined default.</termdef> The default collation is the
      collation that is used by functions and operators that require a collation if no other
      collation is specified. For example, the <code>gt</code> operator on strings is defined by a
      call to the <function>fn:compare</function> function, which takes an optional collation parameter.
      Since the <code>gt</code> operator does not specify a collation, the <function>fn:compare</function>
      function implements <code>gt</code> by using the default collation.</p>
    <p>If neither the implementation nor the Prolog specifies a default collation, the Unicode
      codepoint collation (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>)
      is used. </p>
    <p>The following example illustrates a default collation declaration:</p>
    <eg role="frag-prolog-parse-test">declare default collation "http://example.org/languages/Icelandic";</eg>
    <p>If a default collation declaration specifies a collation by a relative URI, that relative URI
      is <termref def="dt-resolve-relative-uri">resolved to an absolute URI</termref> using the
        <termref def="dt-static-base-uri">Static Base URI</termref>. If a Prolog contains more than
      one default collation declaration, or the value specified by a default collation declaration
      (after resolution of a relative URI, if necessary) is not present in <termref
        def="dt-static-collations">statically known collations</termref>, a <termref
        def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0038"
      />.</p>
  </div2>
  <div2 id="id-base-uri-decl">
    <head>Base URI Declaration</head>
    <scrap>
      <prodrecap ref="BaseURIDecl"/>
    </scrap>

    <p>
      <termdef id="dt-base-uri-decl" term="base URI declaration">A <term>base URI declaration</term>
        specifies the <termref def="dt-static-base-uri">Static Base URI</termref> property. The
          <termref def="dt-static-base-uri">Static Base URI</termref> property is used when
        resolving relative URI references.</termdef> For example, the <termref
        def="dt-static-base-uri">Static Base URI</termref> property is used when resolving relative
      references for <termref def="dt-module-import">module import</termref> and for the
        <function>fn:doc</function> function.</p>

    <note>
      <p>As discussed in the definition of <termref def="dt-static-base-uri">Static Base
          URI</termref>, if there is no base URI declaration, or if the value of the declaration is
        a relative URI reference, then the value of the Static Base URI may depend on the location
        of the query, and it is permissible for this to vary between the static analysis phase and
        the dynamic evaluation phase.</p>
    </note>

    <p>The following is an example of a base URI declaration:</p>
    <eg role="frag-prolog-parse-test">declare base-uri "http://example.org";</eg>
    <p>If a Prolog contains more than one base URI declaration, a <termref def="dt-static-error"
        >static error</termref> is raised <errorref class="ST" code="0032"/>.</p>
    <p>In the terminology of <bibref ref="RFC3986"/> Section 5.1, the URILiteral of the base URI
      declaration is considered to be a “base URI embedded in content”. If no base URI declaration
      is present, <termref def="dt-static-base-uri">Static Base URI</termref> property is
      established according to the principles outlined in <bibref ref="RFC3986"/> Section
      5.1—that is, it defaults first to the base URI of the encapsulating entity, then to the
      URI used to retrieve the entity, and finally to an implementation-defined default. If the
      URILiteral in the base URI declaration is a relative URI, then it is made absolute by
      resolving it with respect to this same hierarchy. For example, if the URILiteral in the base
      URI declaration is <code>../data/</code>, and the query is contained in a file whose URI is
        <code>file:///C:/temp/queries/query.xq</code>, then the <termref def="dt-static-base-uri"
        >Static Base URI</termref> property is <code>file:///C:/temp/data/</code>.</p>

    <p>It is not intrinsically an error if this process fails to establish an absolute base URI;
      however, the <termref def="dt-static-base-uri">Static Base URI</termref> property is then
        <xtermref spec="DM40" ref="dt-absent"/>
      <errorref class="ST" code="0001"/>. When the <termref def="dt-static-base-uri">Static Base
        URI</termref> property is <xtermref spec="DM40" ref="dt-absent"/>, any attempt to use its
      value to <termref def="dt-resolve-relative-uri">resolve a relative URI reference</termref>
      will result in an error <errorref class="ST" code="0001"/>. </p>
  </div2>

  <div2 id="id-construction-declaration">
    <head>Construction Declaration</head>
    <scrap>
      <prodrecap ref="ConstructionDecl"/>
    </scrap>
    <p>
      <termdef term="construction declaration" id="dt-construction-decl">A <term>construction
          declaration</term> sets the <termref def="dt-construction-mode">construction
          mode</termref> in the <termref def="dt-static-context">static context</termref>,
        overriding any implementation-defined default.</termdef> The construction mode governs the
      behavior of element and document node constructors. If construction mode is
        <code>preserve</code>, the type of a constructed element node is <code>xs:anyType</code>,
      and all attribute and element nodes copied during node construction retain their original
      types. If construction mode is <code>strip</code>, the type of a constructed element node is
        <code>xs:untyped</code>; all element nodes copied during node construction receive the type
        <code>xs:untyped</code>, and all attribute nodes copied during node construction receive the
      type <code>xs:untypedAtomic</code>.</p>
    <p>The following example illustrates a construction declaration:</p>
    <eg role="frag-prolog-parse-test">declare construction strip;</eg>
    <p>If a Prolog specifies more than one construction declaration, a <termref
        def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0067"
      />.</p>
  </div2>
  <div2 id="id-default-ordering-decl">
    <head>Ordering Mode Declaration</head>
    <changes>
       <change issue="1339" PR="1342" date="2024-09-03">
               The ordering mode declaration is retained for
               backwards compatibility reasons, but in XQuery 4.0 it is deprecated and has no useful effect.
       </change>
    </changes>
    <scrap>
      <prodrecap ref="OrderingModeDecl"/>
    </scrap>
    <p>
      The ordering mode declaration is retained from earlier XQuery versions,
      but in XQuery 4.0 it is deprecated and has no effect.</p>
    
    <note><p>That is to say, XQuery 4.0 always operates as if ordering mode were set to <code>ordered</code>
    in earlier versions.</p></note>
    
    <p>If a Prolog contains more than one ordering mode declaration, a <termref
        def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0065"
      />.</p>
  </div2>
  <div2 id="id-empty-order-decl">
    <head>Empty Order Declaration</head>
    <scrap>
      <prodrecap ref="EmptyOrderDecl"/>
    </scrap>
    <p>
      <termdef term="empty order declaration" id="dt-empty-order-decl">An <term>empty order
          declaration</term> sets the <termref def="dt-default-empty-order">default order for empty
          sequences</termref> in the <termref def="dt-static-context">static context,</termref>
        overriding any implementation-defined default. This declaration controls the processing of
        empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code>
        clause in a FLWOR expression.</termdef> An individual <code>order by</code> clause may
      override the default order for empty sequences by specifying <code>empty greatest</code> or
        <code>empty least</code>.</p>
    <p>The following example illustrates an empty order declaration:</p>
    <eg role="frag-prolog-parse-test">declare default order empty least;</eg>
    <p>If a Prolog contains more than one empty order declaration, a <termref def="dt-static-error"
        >static error</termref> is raised <errorref class="ST" code="0069"/>.</p>
    
  </div2>


  <div2 id="id-copy-namespaces-decl">
    <head>Copy-Namespaces Declaration</head>
    <scrap>
      <prodrecap ref="CopyNamespacesDecl"/>
    </scrap>

    <p>
      <termdef id="dt-copy-namespaces-decl" term="copy-namespaces
declaration">A
          <term>copy-namespaces declaration</term> sets the value of <termref
          def="dt-copy-namespaces-mode">copy-namespaces mode</termref> in the <termref
          def="dt-static-context">static context</termref>, overriding any implementation-defined
        default. Copy-namespaces mode controls the namespace bindings that are assigned when an
        existing element node is copied by an element constructor or document constructor.</termdef>
      Handling of namespace bindings by element constructors is described in <specref
        ref="id-element-constructor"/>.</p>

    <p>The following example illustrates a copy-namespaces declaration:</p>

    <eg role="frag-prolog-parse-test">declare copy-namespaces preserve, no-inherit;</eg>

    <p>If a Prolog contains more than one copy-namespaces declaration, a <termref
        def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0055"
      />.</p>
  </div2>


  <div2 id="id-decimal-format-decl">
    <head>Decimal Format Declaration</head>
    <changes>
      <change issue="1048" PR="1250" date="2024-06-03">
         Several decimal format properties, including minus sign, exponent separator, percent, and per-mille,
         can now be rendered as arbitrary strings rather than being confined to a single
         character.
      </change>
    </changes>
    <scrap>
      <prodrecap ref="DecimalFormatDecl"/>
    </scrap>
    
    <p>
      <termdef id="dt-decimal-format-decl" term="decimal-format
        declaration">A <term>decimal format
          declaration</term> adds a decimal format to the <termref def="dt-static-decimal-formats"
            >statically known decimal formats</termref>, which define the properties used to format
        numbers using the <code>fn:format-number()</code> function</termdef>, as described in
      <bibref ref="xpath-functions-40"/>. 
      
      If the form <code>decimal-format EQName</code> is used, then the declaration 
        defines the properties of the decimal format whose name is <code>EQName</code>, while the form <code>default decimal-format</code> 
        defines the properties of the unnamed decimal format. The declaration contains a set of 
        (<code>DFPropertyName</code>, <code>StringLiteral</code>) pairs, where the <code>DFPropertyName</code> is the name 
        of the property and the <code>StringLiteral</code> is its value. The valid values and default values for each 
        property are defined in <termref def="dt-static-decimal-formats">statically known decimal formats</termref>.
      </p>
      
      <p>If a format declares no properties, default values are
      used for all properties.</p>
    
    <p>Error conditions are defined as follows:</p>
    <ulist>
      <item><p>It is a <termref def="dt-static-error">static error</termref> for a query prolog to contain
        two decimal format declarations with the same name, or to contain two default decimal format
        declarations <errorref class="ST" code="0111"/>.</p></item>
      <item><p>It is a <termref def="dt-static-error">static
        error</termref> for a decimal format declaration to define the same property more than once
        <errorref class="ST" code="0114"/>.</p></item>
      <item><p>It is a <termref def="dt-static-error">static
        error</termref> for a decimal format declaration to specify a value that is not valid for a
        given property, as described in <termref def="dt-static-decimal-formats">statically known
          decimal formats</termref>
        <errorref class="ST" code="0097"/>.</p></item>
      <item><p>It is a <termref def="dt-static-error">static
        error</termref> if, for any named or unnamed decimal format, the properties identifying
        <term>marker</term> characters to be used in a picture string do identify distinct values <errorref class="ST"
          code="0098"/>.</p> 
        <p>The following properties identify <term>marker</term> characters used in a picture string:
        <termref def="id-static-decimal-format-decimal-separator">decimal-separator</termref>, 
        <termref def="id-static-decimal-format-exponent-separator">exponent-separator</termref>,
        <termref def="id-static-decimal-format-grouping-separator">grouping-separator</termref>, 
        <termref def="id-static-decimal-format-percent">percent</termref>, 
        <termref def="id-static-decimal-format-per-mille">per-mille</termref>, 
        the family of ten decimal digits starting with <termref def="id-static-decimal-format-zero-digit">zero-digit</termref>, 
        <termref def="id-static-decimal-format-digit">digit</termref>, 
        and <termref def="id-static-decimal-format-pattern-separator">pattern-separator</termref>.</p>
      </item>
      
    </ulist>

    
    <example>
      
      <p>The following query formats numbers using two different decimal format declarations:</p>
      
      <eg role="parse-test">
declare decimal-format local:de decimal-separator = "," grouping-separator = "."; 
declare decimal-format local:en decimal-separator = "." grouping-separator = ","; 
       
let $numbers := (1234.567, 789, 1234567.765) 
for $i in $numbers
return ( 
  format-number($i, "#.###,##", "local:de"), 
  format-number($i, "#,###.##", "local:en") 
)</eg>
      <p>The output of this query is:</p>
      <eg>1.234,57 1,234.57 789 789 1.234.567,76 1,234,567.76</eg>
    </example>
    
  </div2>

  <div2 id="id-schema-import">
    <head>Schema Import</head>
    
    <changes>
 
      <change issue="647" PR="659" date="2023-10-24">In previous versions the interpretation of location hints in 
        <code>import schema</code> declarations was entirely at the discretion of the processor. To
        improve interoperability, XQuery 4.0 recommends (but does not mandate)
        a specific strategy for interpreting these hints.</change>
      <change issue="451" PR="635">The rules for the consistency of schemas imported by different query modules,
        and for consistency between imported schemas and those used for validating input documents, have
        been defined with greater precision. It is now recognized that these schemas will not always be
        identical, and that validation with respect to different schemas may produce different outcomes,
        even if the components of one are a subset of the components of the other.</change>
    </changes>
    
    <scrap>
      <prodrecap ref="SchemaImport"/>
    </scrap>


    <p>
      <termdef id="dt-schema-import" term="schema import">A <term>schema import</term> imports the
        element declarations, attribute declarations, and type definitions from a schema into the
          <termref def="dt-issd">in-scope schema definitions</termref>. For each named user-defined
        simple type in the schema, schema import also adds a corresponding <termref
          def="dt-constructor-function">constructor function</termref>. </termdef> The schema to be
      imported is identified by its <termref def="dt-target-namespace">target namespace</termref>.
      The schema import may bind a namespace prefix to the target namespace of the imported schema,
      adding the (prefix, URI) pair to the <termref def="dt-static-namespaces">statically known
        namespaces</termref>, or it may declare that target namespace to be the <termref
        def="dt-default-namespace-elements-and-types"/>. The schema import may
      also provide optional hints for locating the schema.</p>
    <p>The namespace prefix specified in a schema import must not be <code>xml</code> or
        <code>xmlns</code>
      <errorref class="ST" code="0070"/>, and must not be the same as any namespace prefix bound in
      the same module by another schema import, a <termref def="dt-module-import">module
        import</termref>, a <termref def="dt-namespace-declaration">namespace declaration</termref>,
      or a <termref def="dt-module-import">module declaration</termref>
      <errorref class="ST" code="0033"/>. </p>
    
    <note diff="add" at="issue647"><p>If schema definitions from the <code>xml</code> namespace
    are to be used (for example, <code>schema-attribute(xml:space)</code>, then the prolog should
      include a declaration in the form <code>import schema "http://www.w3.org/XML/1998/namespace"</code>.
    No prefix should be supplied (the <code>xml</code> prefix is predeclared), and no location hint
    should be provided (the schema definitions for the namespace are built in, and cannot be varied).</p></note>
    
    <p diff="add" at="A">If the schema import declaration specifies <code>default element namespace</code>
      then the prolog must not contain a <termref def="dt-namespace-declaration">namespace declaration</termref>
      that specifies <code>default element namespace</code> or <code>default type namespace</code>.</p>
    
    <p diff="add" at="2023-10-16">If the keyword <code>"fixed"</code>, is present, the 
      <termref def="dt-default-namespace-elements-and-types"/> is fixed throughout the module,
      and is not affected by default namespace declarations (<code>xmlns=""</code>) appearing
      on direct element constructors.</p>


    <p> The first <nt def="URILiteral">URILiteral</nt> in a schema import specifies the target
      namespace of the schema to be imported.
    </p>
    <p>
      If the target
      namespace is <code>http://www.w3.org/2005/xpath-functions</code> then the schema described in 
      <xspecref spec="FO40" ref="schemata"/> is imported; any location hints are ignored.
    </p>

    <p>A schema import that specifies a zero-length string as target namespace is considered to
      import a schema that has no target namespace. Such a schema import must not bind a namespace
      prefix <errorref class="ST" code="0057"/>, but it may set the default element and/or type namespace
      to a zero-length string (representing “no namespace”), thus enabling the definitions in the
      imported namespace to be referenced. If the <termref def="dt-default-namespace-elements-and-types"/> is not set to "no
      namespace", <phrase diff="chg" at="A">the only way to reference the definitions in an imported schema that has no
        target namespace is using the EQName syntax <code>Q{}local-name</code></phrase>.</p>
    
    <p diff="chg" at="issue647">The <nt def="URILiteral">URILiterals</nt> 
      that follow the <code>at</code> keyword are 
      optional location hints, intended to allow a processor to locate schema documents containing 
      definitions of the required schema components in the target namespace. Processors <rfc2119>may</rfc2119> 
      interpret or disregard these hints in an <termref def="dt-implementation-defined"
        >implementation-defined</termref> way. The preferred strategy,
      which <rfc2119>should</rfc2119> be used by default unless the user indicates otherwise, 
      is as follows:</p>
    
    <olist diff="add" at="issue647">
      <item><p>If the target namespace is one for which the processor has built-in knowledge,
      for example the schema for a <termref def="dt-reserved-namespaces">reserved namespace</termref>, the location hints
      <rfc2119>should</rfc2119> be ignored, and the built-in schema used in preference.</p></item>
      <item><p>In other cases, the location hints are taken in order, treating them as URI references relative
        to the static base URI of the query module.</p></item>
      <item><p>If the first location hint cannot be successfully dereferenced, then that location hint is disregarded 
        (optionally with a warning), and the process continues with the next location hint, until
        one is found that can be successfully dereferenced; if none of the location hints can be dereferenced, 
        then a static error is reported.</p></item>
      <item><p>The dereferencing of a location hint <rfc2119>may</rfc2119> make use of <termref def="dt-implementation-defined"
        >implementation-defined</termref>
        indirection mechanisms such as resolver callbacks and catalog files.</p></item>
      <item><p>If a location hint is successfully dereferenced, but yields a resource that cannot be parsed as a valid
        XSD schema document with the correct target namespace, then a static error is reported.</p></item>
      <item><p>If a valid schema document is located, then it is combined with the schema documents obtained
        from other import schema declarations, in the same way as a schema is assembled from multiple
        schema documents referenced using <code>xs:import</code> declarations. This implies that the 
        several schema documents must together comprise a valid schema, for example there cannot be two 
        different type definitions with the same name.</p></item>
      <item><p>Once one location hint has been successfully processed, subsequent location hints are
      ignored.</p></item>
    </olist>
    
    <note diff="add" at="issue647"><p>Processors that adopted a different strategy in earlier releases <rfc2119>may</rfc2119>
      continue to use that strategy by default, in order to retain compatibility; however such
      processors <rfc2119>should</rfc2119> offer the above strategy as an option. </p>
    <p>The process described above is not intended to be totally prescriptive, or to guarantee complete 
      interoperability. Processors are likely to exhibit variations, depending both on design decisions made
      by the product vendor, and on decisions made when configuring the platform
      and network infrastructure on which it runs. For example, when retrieving HTTP resources,
      the details of the HTTP request are likely to vary, and the criteria used to decide whether
      a request was successful may also vary. In addition, the XSD specification itself describes
      some aspects of the process incompletely, including for example the criteria used to decide 
      whether two components (such as type definitions) should be considered identical.</p>
    
    </note>
    
    <p>Different query modules may import different schemas, but there is a requirement that all the schemas
      used by a query <rfc2119>must</rfc2119> be compatible. The rules for compatibility are defined
      in <xspecref spec="DM40" ref="schema-consistency"/>. This means, for example:</p>
    
    <ulist>
      <item><p>If any schema component (such as an element declaration or complex type definition)
      is imported into more than one query module, the definitions of these components must effectively 
      be the same.</p></item>
      <item><p>This leaves room, however, for some differences between modules. For example, 
      the substitution group membership of an element declaration may vary between one module
      and another, depending on what other element declarations are present in the schema. This
      means that an element can be validated in one module and passed as a function parameter
      to another module in which the element would be considered invalid. Any static type inferencing
      that is performed must take such possibilities into account; this is particularly important
      if query modules are compiled independently from one another.</p></item>
    </ulist>
    
    
    <p>
      If the target
      namespace is <code>http://www.w3.org/2005/xpath-functions</code> then the schema described in 
      <xspecref spec="FO31" ref="schemata"/> is imported; any location hints are ignored.
    </p>
    
    <p>It is a <termref def="dt-static-error">static error</termref>
      <errorref class="ST" code="0058"/> if more than one schema import in the same <termref
        def="dt-prolog">Prolog</termref> specifies the same target namespace. It is a <termref
        def="dt-static-error">static error</termref>
      <errorref class="ST" code="0059"/> if the implementation is not able to process a schema
      import by finding a valid schema with the specified target namespace. 
      <phrase diff="del" at="issue647">It is a <termref
        def="dt-static-error">static error</termref>
      <errorref class="ST" code="0035"/> if multiple imported schemas, or multiple physical
      resources within one schema, contain definitions for the same name in the same symbol space
      (for example, two definitions for the same element name, even if the definitions are
      consistent). However, it is not an error to import the schema with target namespace
        <code>http://www.w3.org/2001/XMLSchema </code>(predeclared prefix <code>xs</code>), even
      though the built-in types defined in this schema are implicitly included in the <termref
        def="dt-is-types">in-scope schema types.</termref></phrase>
    </p>



    <p> It is a <termref def="dt-static-error">static error</termref>
      <errorref code="0012" class="ST"/> if the set of definitions contained in all schemas imported
      by a Prolog do not satisfy the conditions for schema validity specified in Sections 3 and 5 of
        <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/> Part 1: in particular, each definition
      must be valid, complete, and unique.</p>
    
    <p> It is a <termref def="dt-static-error">static error</termref>
      <errorref code="0149" class="ST"/> if the schemas imported by different modules of a query
      are not compatible as defined in <xspecref spec="DM40" ref="schema-consistency"/>.</p>
    

    <p>The following example imports a schema, specifying both its target namespace and its
      location, and binding the prefix <code>soap</code> to the target namespace:</p>

    <eg role="frag-prolog-parse-test">import schema namespace soap="http://www.w3.org/2003/05/soap-envelope" 
  at "http://www.w3.org/2003/05/soap-envelope/";</eg>
    <p>The following example imports a schema by specifying only its target namespace, and makes it
      the <termref def="dt-default-namespace-elements-and-types"/>:</p>
    <eg role="frag-prolog-parse-test">import schema default element namespace "http://example.org/abc";</eg>
    <p>The following example imports a schema that has no target namespace, providing a location
      hint, and sets the <termref def="dt-default-namespace-elements-and-types"/> to “no namespace” so that the definitions in
      the imported schema can be referenced:</p>
    <eg role="frag-prolog-parse-test">import schema default element namespace "" at "http://example.org/xyz.xsd";</eg>
    <p>The following example imports a schema that has no target namespace and sets the 
      <termref def="dt-default-namespace-elements-and-types"/> to “no namespace”. 
      Since no location hint is provided, it is up to the
      implementation to find the schema to be imported.</p>
    <eg role="frag-prolog-parse-test">import schema default element namespace "";</eg>
  </div2>
  <div2 id="id-module-import">
    <head>Module Import</head>
    <scrap>
      <prodrecap ref="ModuleImport"/>
    </scrap>
    <p>
      <termdef term="module import" id="dt-module-import">A <term>module import</term> imports the
        public variable declarations, public function declarations<phrase diff="add" at="A">, 
          and public item type declarations</phrase> from one or more <termref
          def="dt-library-module">library modules</termref> into the <termref
          def="dt-statically-known-function-definitions"/>, <termref
          def="dt-in-scope-variables">in-scope variables</termref><phrase diff="add" at="A">,
          or <termref def="dt-in-scope-named-item-types"/></phrase> of the importing <termref
          def="dt-module">module</termref>.</termdef> Each module import names a <termref
        def="dt-target-namespace">target namespace</termref> and imports an <termref
        def="dt-implementation-defined">implementation-defined</termref> set of modules that share
      this target namespace. The module import may bind a namespace prefix to the target namespace,
      adding the (prefix, URI) pair to the <termref def="dt-static-namespaces">statically known
        namespaces</termref>, and it may provide optional hints for locating the modules to be
      imported.</p>

    <p>If a module <var>A</var> imports module <var>B</var>, the static context of module
      <var>A</var> will contain the <termref
        def="dt-statically-known-function-definitions"/>, <termref
          def="dt-in-scope-variables">in-scope variables</termref><phrase diff="add" at="A">,
            or <termref def="dt-in-scope-named-item-types"/></phrase> of
      module <var>B</var>, and the dynamic context of module <var>A</var> will contain the
        public <termref def="dt-variable-values">variable values</termref> and <termref
        def="dt-dynamically-known-function-definitions"/> of module <var>B</var>. It will
      not contain:</p>
    
    <ulist>
      <item><p>Private functions, variables, and item types declared in <var>B</var>.</p></item>
      <item><p>Functions, variables, and item types not
      declared directly in <var>B</var>, but imported from some other library module.</p></item>
      <item><p>Other components such as <termref def="dt-issd">in-scope schema definitions</termref> or <termref
        def="dt-static-namespaces">statically known namespaces</termref> declared in <var>B</var>.</p></item>
    </ulist>

    <p>The following example illustrates a module import:</p>

    <eg role="frag-prolog-parse-test">import module namespace gis="http://example.org/gis-functions";</eg>

    <p>If a query imports the same module via multiple paths, only one instance of the module is
      imported. Because only one instance of a module is imported, there is only one instance of
      each variable declared in a module's prolog.</p>

    <p>A module may import its own target namespace (this is interpreted as importing an <termref
        def="dt-implementation-defined">implementation-defined</termref> set of other modules that
      share its target namespace.)</p>

    <p>The namespace prefix specified in a module import must not be <code>xml</code> or
        <code>xmlns</code>
      <errorref class="ST" code="0070"/>, and must not be the same as any namespace prefix bound in
      the same module by another module import, a <termref def="dt-schema-import">schema
        import</termref>, a <termref def="dt-namespace-declaration">namespace declaration</termref>,
      or a <termref def="dt-module-declaration">module declaration</termref> with a different target
      namespace <errorref class="ST" code="0033"/>.</p>
    <p>The first <nt def="URILiteral">URILiteral</nt> in a module import must be of nonzero length
        <errorref class="ST" code="0088"/>, and specifies the target namespace of the modules to be
      imported. The <nt def="URILiteral">URILiterals</nt> that follow the <code>at</code> keyword are 
      optional location hints, and can be interpreted or disregarded in
      an <termref def="dt-implementation-defined"
        >implementation-defined</termref> way.</p>
    
    
    <p>It is a <termref def="dt-static-error">static error</termref>
      <errorref class="ST" code="0047"/> if more than one module import in a <termref
        def="dt-prolog">Prolog</termref> specifies the same target namespace. It is a <termref
        def="dt-static-error">static error</termref>
      <errorref class="ST" code="0059"/> if the implementation is not able to process a module
      import by finding a valid module definition with the specified target namespace. It is a
        <termref def="dt-static-error">static error</termref> if two or more variables declared or
      imported by a <termref def="dt-module">module</termref> have equal <termref
        def="dt-expanded-qname">expanded QNames</termref> (as defined by the <code>eq</code>
      operator) <errorref class="ST" code="0049"/>.</p>
    
    <p>Module imports are not transitive. Importing a module provides access only to 
      declarations contained directly in the imported module. For example, if 
      module <var>A</var> imports
      module <var>B</var>, and module <var>B</var> imports module <var>C</var>, 
      module <var>A</var> does not have access to the functions and
      variables declared in module <var>C</var>. </p>
    
 

    <example>
      <head>Schema Information and Module Import</head>

      <p>A module import does not import schema definitions from the imported module. In the
        following query, the type <code>geometry:triangle</code> is not defined, even if it is known in the
        imported module, so the variable declaration raises an error <errorref class="ST"
          code="0051"/>:</p>

      <eg role="parse-test">(: Error - geometry:triangle is not defined :) 
import module namespace geo = "http://example.org/geo-functions"; 
declare variable $triangle as geometry:triangle := geo:make-triangle(); 
$triangle</eg>

      <p>Without the type declaration for the variable, the variable declaration succeeds:</p>

      <eg role="parse-test">import module namespace geo = "http://example.org/geo-functions";
declare variable $triangle := geo:make-triangle();
$triangle</eg>

      <p>Importing the schema that defines the type of the variable,
      the variable declaration succeeds:</p>

      <eg role="parse-test">import schema namespace geometry = "http://example.org/geo-schema-declarations"; 
import module namespace geo = "http://example.org/geo-functions"; 
declare variable $triangle as geometry:triangle := geo:make-triangle();
$triangle</eg>
    </example>

    <div3 id="id-module-handling-module-uris">
      <head>The Target Namespace of a Module</head>

      <p>The target namespace of a module should be treated in the same way as other namespace
        URIs.</p>

      <p>To maximize interoperability, query authors should use a string that is a valid absolute
        IRI.</p>

      <p>Implementions must accept any string of Unicode characters. Target namespace URIs are
        compared using the Unicode codepoint collation rather than any concept of semantic
        equivalence.</p>

      <p>Implementations may provide mechanisms allowing the target namespace URI to be used as
        input to a process that delivers the module as a resource, for example a catalog, module
        repository, or URI resolver. For interoperability, such mechanisms should not prevent the
        user from choosing an arbitrary URI for naming a module.</p>

      <p>Similarly, implementations may perform syntactic transformations on the target namespace
        URI to obtain the names of related resources, for example to implement a convention relating
        the name or location of compiled code to the target namespace URI; but again, such
        mechanisms should not prevent the user from choosing an arbitrary target namespace URI.</p>

      <p>As with other namespace URIs, it is common practice to use target namespace URIs whose
        scheme is <code>http</code> and whose authority part uses a DNS domain name under the control of the
        user.</p>

      <p>The specifications allow, and some users might consider it good practice, for the target
        namespace URI of a function library to be the same as the namespace URI of the XML
        vocabulary manipulated by the functions in that library.</p>
    </div3>

    <div3 id="id-module-handling-multiple-same">
      <head>Multiple Modules with the same Namespace</head>

      <p>Several different modules with the same target namespace can be used in the same query. The
        names of public variables and public functions must be unique within the <termref
          def="dt-static-context"/> of a query: this means that if two modules with
        the same target namespace URI are used in the same query, the names of the public variables
        and functions in their module contexts must not overlap.</p>

      <p>If one module contains an <code>import module</code> declaration with the target namespace
          <code>M</code>, then all public variables and public functions in the contexts of modules
        whose target namespace is <code>M</code> must be accessible in the importing module,
        regardless whether the participation of the imported module was directly due to this "import
        module" declaration.</p>

    </div3>


    <div3 id="id-module-handling-location-uris">
      <head>Location URIs</head>

      <p>The term “location URIs” refers to the URIs in the <code>at</code> clause of an
        <code>import module</code> declaration.</p>

      <p>Products should (by default or at user option) take account of all the location URIs in an
        <code>import module</code> declaration, treating each location URI as a reference to a module with the
        specified target namespace URI. Location URIs should be made absolute with respect to the
        static base URI of the module containing the <code>import module</code> declaration where they appear.
        The mapping from location URIs to module source code or compiled code MAY be done in any way
        convenient to the implementation. If possible given the product’s architecture, security
        requirements, etc, the product should allow this to fetch the source code of the module to
        use the standard web mechanisms for dereferencing URIs in standard schemes such as the
        <code>http</code> URI scheme.</p>

      <p>When the same absolutized location URI is used more than once, either in the same
        <code>import module</code> declaration or in different
        <code>import module</code> declarations within the same query, a
        single copy of the resource containing the module is loaded. When different absolutized
        location URIs are used, each results in a single module being loaded, unless the
        implementation is able to determine that the different URIs are references to the same
        resource. No error due to duplicate variable or functions names should arise from the same
        module being imported more than once, so long as the absolute location URI is the same in
        each case.</p>

      <p>Implementations must report a static error if a location URI cannot be resolved after all
        available recovery strategies have been exhausted.</p>

    </div3>
    <div3 id="id-module-handling-cycles">
      <head>Cycles</head>

      <p>Implementations must resolve cycles in the import graph, either at the level of target
        namespace URIs or at the level of location URIs, and ensure that each module is imported
        only once. </p>
    </div3>

  </div2>
  <div2 id="id-namespace-declaration">

    <head>Namespace Declaration</head>
    
    <changes>
      <change>
        All implementations must now predeclare the namespace prefixes
        <code>math</code>, <code>map</code>, <code>array</code>, and <code>err</code>. In XQuery 3.1 it was permitted
        but not required to predeclare these namespaces.
      </change>
    </changes>
    <scrap>
      <prodrecap ref="NamespaceDecl"/>
    </scrap>

    <p>
      <termdef id="dt-namespace-declaration" term="namespace declaration">A <term>namespace
          declaration</term> declares a namespace prefix and associates it with a namespace URI,
        adding the (prefix, URI) pair to the set of <termref def="dt-static-namespaces">statically
          known namespaces</termref>.</termdef> The namespace declaration is in scope throughout the
      query in which it is declared, unless it is overridden by a <termref
        def="dt-namespace-decl-attr">namespace declaration attribute</termref> in a <termref
        def="dt-direct-elem-const">direct element constructor</termref>.</p>
    <p>If the URILiteral part of a namespace declaration is a zero-length string, any existing
      namespace binding for the given prefix is removed from the <termref def="dt-static-namespaces"
        >statically known namespaces</termref>. This feature provides a way to remove predeclared
      namespace prefixes such as <code>local</code>.</p>
    <p>The following query illustrates a namespace declaration:</p>
    <eg role="parse-test">
<![CDATA[declare namespace foo = "http://example.org";
<foo:bar> Lentils </foo:bar>]]>
    </eg>
    <p>In the query result, the newly created node is in the namespace associated with the namespace
      URI <code>http://example.org</code>.</p>




    <p>The namespace prefix specified in a namespace declaration must not be <code>xml</code> or
        <code>xmlns</code>
      <errorref class="ST" code="0070"/>. The namespace URI specified in a namespace declaration
      must not be <code>http://www.w3.org/XML/1998/namespace</code> or
        <code>http://www.w3.org/2000/xmlns/</code>
      <errorref class="ST" code="0070"/>. The namespace prefix specified in a namespace declaration
      must not be the same as any namespace prefix bound in the same module by a <termref
        def="dt-module-import">module import</termref>, <termref def="dt-schema-import">schema
        import</termref>, <termref def="dt-module-import">module declaration</termref>, or another
      namespace declaration <errorref class="ST" code="0033"/>. </p>

    <p>It is a <termref def="dt-static-error">static error</termref>
      <errorref class="ST" code="0081"/> if an expression contains a <termref def="dt-qname">lexical
        QName</termref> with a namespace prefix that is not in the <termref
        def="dt-static-namespaces">statically known namespaces</termref>.</p>

    <p>XQuery has several predeclared namespace prefixes, which are listed in
      <specref ref="id-namespaces-and-qnames"/>.
        These prefixes may be used without an explicit declaration; they are present in the
        <termref def="dt-static-namespaces">statically known namespaces</termref>
        before each query is processed. They may be overridden by
        <termref def="dt-namespace-declaration">namespace declarations</termref> in a <termref
        def="dt-prolog">Prolog</termref> or by <termref def="dt-namespace-decl-attr">namespace
        declaration attributes</termref> on constructed elements (however, the prefix
        <code>xml</code> must not be redeclared, and no other prefix may be bound to the namespace
      URI associated with the prefix <code>xml</code> <errorref class="ST" code="0070"/>).
    </p>

    <p>Additional predeclared namespace prefixes may be added to the <termref
        def="dt-static-namespaces">statically known namespaces</termref> by an implementation.</p>

    <p>When element or attribute names are compared, they are considered identical if the local
      parts and namespace URIs match on a codepoint basis. Namespace prefixes need not be identical
      for two names to match, as illustrated by the following example:</p>
    <eg role="parse-test">
<![CDATA[declare namespace xx = "http://example.org";

let $node := <foo:bar xmlns:foo = "http://example.org">
  <foo:bing> Lentils </foo:bing>
</foo:bar>
return $node/xx:bing]]>
    </eg>
    <p>Although the namespace prefixes <code>xx</code> and <code>foo</code> differ, both are bound
      to the namespace URI <code>http://example.org</code>. Since <code>xx:bing</code> and
        <code>foo:bing</code> have the same local name and the same namespace URI, they match. The
      output of the above query is as follows.</p>
    <eg role="parse-test">
<![CDATA[<foo:bing xmlns:foo="http://example.org"> Lentils </foo:bing>]]>
    </eg>
  </div2>
  <div2 id="id-default-namespace">
    <head>Default Namespace Declaration</head>
    
    <changes>
      <change issue="65" PR="753" date="2023-10-31">
        The <termref def="dt-default-namespace-elements-and-types"/> can now be declared to be fixed
        for a query module, meaning it is unaffected by a namespace declaration appearing on a direct
        element constructor.
      </change>
      <change issue="296" PR="1181" date="2023-04-30">
        The <termref def="dt-default-namespace-elements-and-types"/> can be set to the value <code>##any</code>,
        allowing unprefixed names in axis steps to match elements with a given local name in any namespace.
      </change>
    </changes>
    <scrap>
      <prodrecap ref="DefaultNamespaceDecl"/>
    </scrap>
    <p>
      <term>Default namespace declarations</term> can be used in a <termref def="dt-prolog"
        >Prolog</termref> to facilitate the use of unprefixed QNames.</p>

    <p>The namespace URI specified in a default namespace declaration must not be
        <code>http://www.w3.org/XML/1998/namespace</code> or
        <code>http://www.w3.org/2000/xmlns/</code>
      <errorref class="ST" code="0070"/>.</p>

    <p>The following kinds of default namespace declarations are supported:</p>
    <ulist>
      
      <item>
        <p>A <term>default element namespace declaration</term> declares how unprefixed element and type
          names are to be interpreted. The relevant value 
          is recorded as the <termref def="dt-default-namespace-elements-and-types"/> in the
          <termref def="dt-static-context">static context</termref> for the query module. A <termref def="dt-prolog"
            >Prolog</termref> may contain at most one default element namespace declaration
          <phrase diff="add" at="A">and it must not contain
          both a default element namespace declaration and an <code>import schema</code> declaration
            that specifies a default element namespace</phrase> <errorref class="ST" code="0066"/>.</p>
          <p>The <code>URILiteral</code> may take one of the following forms:</p>
          <ulist>
            <item><p>A namespace URI. This namespace will typically be used for unprefixed names appearing
            where an element or type name is expected.</p></item>
            <item><p>The empty string <code>""</code>. In this case unprefixed names appearing where
              an element or type name is expected are treated as being in no namespace: the
              <termref def="dt-default-namespace-elements-and-types"/> is set to <xtermref spec="DM40" ref="dt-absent"/>.</p></item>
            <item><p>The string <code>"##any"</code>. In this case an unprefixed name appearing
              as a <nt def="NameTest">NameTest</nt> in an axis step whose principal node kind is element
              is interpreted as a wildcard (the unprefixed name <code>N</code> is treated as equivalent
              to the wildcard <code>*:N</code>); an unprefixed name used appearing where an item type name
              is expected is interpreted as a local name in namespace <code>http://www.w3.org/2001/XMLSchema</code>,
              while an unprefixed name appearing in any other context
              where an element or type name is expected is treated as being in no namespace.</p>
              <note><p>To take an example, older versions of the internet index of RFCs (requests for comments)
              use the namespace URI <code>http://www.rfc-editor.org/rfc-index</code>, while newer
              versions use <code>https://www.rfc-editor.org/rfc-index</code> (note the change of URI scheme).
              XPath code that needs to work with either version can be simplified by setting the
              default namespace to <code>##any</code>: but be aware that this might lead to spurious matching
              of names in an unrelated namespace.</p></note>
            </item>
          </ulist>
          <p>The following example illustrates the declaration of a
          default namespace for elements and types:</p>
        <eg role="frag-prolog-parse-test">declare default element namespace "http://example.org/names";</eg>
        
        <p>If no default element namespace declaration is present, unprefixed element and type
          names are in no namespace (however, an implementation may define a different default as
          specified in <specref ref="id-xq-static-context-components"/>.)</p>
        <p diff="add" at="2023-10-16">If the keyword <code>"fixed"</code>, is present, the 
          <termref def="dt-default-namespace-elements-and-types"/> is fixed throughout the module,
          and is not affected by default namespace declarations (<code>xmlns=""</code>) appearing
          on direct element constructors.</p>
        
      </item>


      <item>
        <p>A <term>default function namespace declaration</term> declares a namespace URI that is
          associated with unprefixed function names in static function calls and function
          declarations.</p>
 
         <p>A <termref def="dt-prolog">Prolog</termref> may contain at most one
          default function namespace declaration <errorref class="ST" code="0066"/>. If the
          <code>StringLiteral</code> in a default function namespace declaration is a zero-length string, the
          default function namespace is undeclared (set to <xtermref spec="DM40" ref="dt-absent"/>).
          In that case, any functions that are associated with a namespace can be called only by
          using an explicit namespace prefix.</p>
        <p>If no default function namespace declaration is present, the default function namespace
          is the namespace of XPath/XQuery functions,
            <code>http://www.w3.org/2005/xpath-functions</code> (however, an implementation may
          define a different default as specified in <specref ref="id-xq-static-context-components"
          />.)</p>
        <p>The following example illustrates the declaration of a default function namespace:</p>
        <eg role="frag-prolog-parse-test">declare default function namespace "http://www.w3.org/2005/xpath-functions/math";</eg>
        <p>The effect of declaring a default function namespace is that all functions in the default
          function namespace, including implicitly declared <termref def="dt-constructor-function"
            >constructor functions</termref>, can be invoked without specifying a namespace prefix.
          When a static function call uses a function name with no prefix, the local name of the
          function must match a function (including implicitly declared <termref
            def="dt-constructor-function">constructor functions</termref>) in the default function
          namespace <errorref class="ST" code="0017"/>.</p>
        <note>
          <p>Only <termref def="dt-constructor-function">constructor functions</termref> can be in
            no namespace.</p>
        </note>
        <p diff="add" at="2023-10-16">The keyword <code>"fixed"</code> has no effect when declaring
          a default function namespace, since there is no mechanism to change the default function
          namespace within a query module.</p>
      </item>
    </ulist>
    <p> Unprefixed attribute names and variable names are in no namespace.</p>
  </div2>
  
  <div2 id="id-annotations">
    <head>Annotations</head>

    <scrap>
      <prodrecap ref="Annotation"/>
    </scrap>

    <p>XQuery uses annotations to declare properties associated with functions (inline or declared
      in the prolog), variables, and named types. For instance, a function may be declared <code>%public</code> or
        <code>%private</code>. The semantics associated with these properties are described in
        <specref ref="FunctionDeclns"/>.</p>
    
    <note>
      <p>For ease of exposition, the EBNF grammar includes several productions that all start
      with <code>"declare" Annotation*</code>, followed by the type of declaration (one of
      <code>"variable"</code>, <code>"function"</code>, <code>"type"</code>, <code>"record"</code>).
      A parser generated automatically from the grammar in this form would require unbounded
      lookahead. For implementation purposes, the grammar can be refactored as
      <code>"declare" Annotation* ( "variable"... | "function"... | "type"... | "record"... )</code>.</p>
    </note>
    
    <p>Annotations are <code>(QName, value)</code> pairs. If the EQName of the annotation is a
        <termref def="dt-qname">lexical QName</termref> then it is expanded using the 
      <termref def="dt-default-annotation-namespace-rule"/>.</p>
    
    <note><p>The default namespace is a <termref def="dt-reserved-namespaces">reserved namespace</termref>, which means
    that unprefixed names cannot be used for implementation-defined or user-defined
    annotations. It is permitted to use a no-namespace name, which
    might be written, for example, as <code>%Q{}inline</code>; however, this
    is discouraged because it is likely to reduce portability across implementations.</p></note>
    
    <p>In general there is no rule preventing two annotations on the same declaration having
    the same name, although this is disallowed for some specific annotations such as
    <code>%public</code> and <code>%private</code>. The order of annotations may be significant.</p>
    
    <p>If there is no value associated with an annotation, the effective value is the empty sequence.
    This is the case, for example, with the annotations <code>%public</code> and <code>%private</code>.</p>

    
    <p role="xquery"> A few annotations, such as <code>%public</code> and <code>%private</code>,
      have rules defined by this specification. Implementations may define further annotations, whose behavior is
        implementation-defined. For instance, if the <code>eg</code> prefix is bound to a namespace
        recognized by a particular implementation, then it could be used to define an annotation like
          <code>eg:sequential</code>. 
        If the namespace URI of an annotation is not recognized by the 
        implementation, then the annotation has no effect, other than being available for inspection
        using the <function>fn:function-annotations</function> function.</p> 
     <p>Implementations may also provide 
      a way for users to define their own annotations.
        Implementations must not define annotations, or allow users to define annotations, in 
         <termref def="dt-reserved-namespaces">reserved namespaces</termref>; it 
        is a <termref def="dt-static-error">static error</termref> <errorref class="ST" code="0045"/> 
        for the name of an annotation to be in a <termref def="dt-reserved-namespaces">reserved namespace</termref>.
     </p>


    <p diff="chg" at="issue637"> An annotation can provide values explicitly using a parenthesized list of 
      constant values. These values may take any of the following forms:</p>
    
    <ulist diff="chg" at="issue637">
      <item><p>A string literal, for example <code>"Paris"</code> or <code>'London'</code>, denoting
      a value of type <code>xs:string</code>.</p></item>
      <item><p>A numeric literal, for example <code>0</code>, <code>0.1</code>, <code>0x7FFF</code>,
        or <code>1e-6</code>,
        denoting a value of type <code>xs:decimal</code>, <code>xs:integer</code>, 
        or <code>xs:double</code>. The literal may be preceded by a minus sign to represent a negative
        number.</p></item>
      <item><p>One of the constructs <code>true()</code> or <code>false()</code>, denoting
      the <code>xs:boolean</code> values <code>true</code> and <code>false</code> respectively.</p></item>
      <item><p>A QName literal, for example <code>#div</code> or <code>#xml:space</code>, denoting
      a value of type <code>xs:QName</code>.</p></item>
    </ulist>
 
    <p>For example, the annotation
        <code>%java:method("java.lang.Math.sin")</code> sets the value of the
        <code>java:method</code> annotation to the string value <code>java.lang.Math.sin</code>. An implementation
      might define such annotations to facilitate calling external functions.
    </p>

    <note diff="add" at="issue637"><p>The constructs <code>true()</code> and <code>false()</code> must be written as
    prescribed by the grammar. No namespace prefix is allowed. Although the values resemble calls to
    functions in the default function namespace, they are unaffected by the namespace
    context.</p></note>
  </div2>


  <div2 id="id-variable-declarations">
    <head>Variable Declaration</head>
    
    <changes>
      <change issue="189" PR="254" date="2022-11-29">
        The coercion rules are now used when binding values to variables (both
        global variable declarations and local variable bindings). This aligns XQuery with XSLT,
        and means that the rules for binding to variables are the same as the rules for binding
        to function parameters.
      </change>
      <change issue="1379" PR="1432" date="2024-09-12">
         In earlier versions, the static context for the <termref def="dt-initializing-expression"/>
         excluded the variable being declared. This restriction has been lifted.
      </change>
      <change issue="1954" PR="1956" date="2025-04-24">
        Private variables declared in a library module are no longer required to be in the module namespace.
      </change>
    </changes>

    <scrap>
      <prodrecap ref="VarDecl"/>
    </scrap>



    <p><termdef id="dt-variable-declaration" term="variable declaration">A <term>variable declaration</term> 
      in the XQuery prolog defines the name and <termref def="dt-static-type">static
        type</termref> of a variable, and optionally a value for the variable. It adds to the 
        <termref def="dt-in-scope-variables">in-scope
        variables</termref> in the <termref def="dt-static-context"/>, and may also add to the <termref
        def="dt-variable-values">variable values</termref> in the <termref def="dt-dynamic-context"/>.</termdef> </p>

    <note>
      <p>The term <term>variable declaration</term> always refers to a declaration of a variable in a
        Prolog. The binding of a variable to a value in a query expression, such as a FLWOR
        expression, is known as a <term>variable binding</term>, and does not make the variable
        visible to an importing module.</p>
    </note>
    
    <p>The variable name, if written as a <termref def="dt-qname"/>, is expanded
      using the <termref def="dt-no-namespace-rule"/>.</p>


    <p>During static analysis, a variable declaration causes a pair <code>(expanded QName N, type
        T)</code> to be added to the <termref def="dt-in-scope-variables">in-scope
        variables</termref>. The <termref def="dt-expanded-qname"/> N is the <code>VarName</code>. If N is equal (as
      defined by the eq operator) to the expanded QName of another variable in in-scope variables, a
        <termref def="dt-static-error">static error</termref> is raised <errorref class="ST"
        code="0049"/>.
        
      The type T of the declared variable is as follows:
    </p>
    <ulist>
      <item>
          <p>If <code>TypeDeclaration</code> is present, then the <code>SequenceType</code> in the
          <code>TypeDeclaration</code>; otherwise</p>
      </item>

      <!--<item>
        <p>If the Static Typing Feature is in effect and <code>VarValue</code> is present, then the
           static type inferred from static analysis of the expression <code>VarValue</code>;</p>

        <note>
          <p>Type inference might not be computable until after the check for circular dependencies,
             described below, is complete.</p>
        </note>
      </item>-->

      <item>
        <p> Otherwise, <code>item()*</code>.</p>
      </item>
    </ulist>

    <p>A variable declaration may
      use annotations to specify that the variable is <code>%private</code> or <code>%public</code>
      (which is the default). <termdef id="dt-private-variable" term="private
  variable">A
          <term>private variable</term> is a variable with a <code>%private</code> annotation. A
        private variable is hidden from <termref def="dt-module-import">module import</termref>,
        which can not import it into the <termref def="dt-in-scope-variables">in-scope
          variables</termref> of another module.</termdef>
      <termdef id="dt-public-variable" term="public variable">A <term>public variable</term> is a
        variable without a <code>%private</code> annotation. A public variable is accessible to
          <termref def="dt-module-import">module import</termref>, which can import it into the
          <termref def="dt-in-scope-variables">in-scope variables</termref> of another module. Using
          <code>%public</code> and <code>%private</code> annotations in a main module is not an
        error, but it does not affect module imports, since a main module cannot be imported. It is
        a <termref def="dt-static-error">static error</termref>
        <errorref class="ST" code="0116"/> if a variable declaration contains both a
          <code>%private</code> and a <code>%public</code> annotation, more than one
          <code>%private</code> annotation, or more than one <code>%public</code>
        annotation.</termdef></p>
    
    <p>All <termref def="dt-public-variable"/> names declared in a library module must (when expanded) be in the target
      namespace of the library module <errorref class="ST" code="0048"/>.</p>


    

    <p>Here are some examples of variable declarations:</p>

    <ulist>
      <item>
        <p>The following declaration specifies both the type and the value of a variable. This
          declaration causes the type <code>xs:integer</code> to be associated with variable
            <code>$x</code> in the <termref def="dt-static-context">static context</termref>, and
          the value <code>7</code> to be associated with variable <code>$x</code> in the <termref
            def="dt-dynamic-context">dynamic context</termref>.</p>

        <eg role="frag-prolog-parse-test">declare variable $x as xs:integer := 7;</eg>

      </item>
      <item>
        <p>The following declaration specifies a value but not a type. The <termref
            def="dt-static-type">static type</termref> of the variable is inferred from the static
          type of its value. In this case, the variable <code>$x</code> has a static type of
            <code>xs:decimal</code>, inferred from its value which is 7.5.</p>

        <eg role="frag-prolog-parse-test">declare variable $x := 7.5;</eg>

      </item>
      <item>
        <p>The following declaration specifies a type but not a value. The keyword
            <code>external</code> indicates that the value of the variable will be provided by the
          external environment. At evaluation time, if the variable <code>$x</code> in the <termref
            def="dt-dynamic-context">dynamic context</termref> does not have a value of type
            <code>xs:integer</code>, a <termref def="dt-type-error">type error</termref> is
          raised.</p>
        <eg role="frag-prolog-parse-test">declare variable $x as xs:integer external;</eg>
      </item>
      <item>
        <p>The following declaration specifies neither a type nor a value. It simply declares that
          the query depends on the existence of a variable named <code>$x</code>, whose type and
          value will be provided by the external environment. During query analysis, the type of
            <code>$x</code> is considered to be <code>item()*</code>. During query evaluation, the
            <termref def="dt-dynamic-context">dynamic context</termref> must include a type and a
          value for <code>$x</code>, and its value must be compatible with its type.</p>
        <eg role="frag-prolog-parse-test">declare variable $x external;</eg>
      </item>
      <item>
        <p>The following declaration, which might appear in a library module, declares a variable
          whose name includes a namespace prefix:</p>
        <eg role="frag-prolog-parse-test">declare variable $sasl:username as xs:string := "jonathan@example.com";</eg>
      </item>

      <item>
        <p>This is an example of an external variable declaration that provides a
            <code>VarDefaultValue</code>:</p>
        <eg role="frag-prolog-parse-test">declare variable $x as xs:integer external := 47;</eg>
      </item>
    </ulist>

    <p>
      An implementation can provide annotations it needs. For instance,
      an implementation that supports volatile external variables
      might allow them to be declared using an annotation:</p>

    <eg role="frag-prolog-parse-test">declare %eg:volatile variable $time as xs:time external;</eg>

    
   

    <p>
      <termdef term="initializing expression" id="dt-initializing-expression">If a variable
        declaration includes an expression (<code>VarValue</code> or <code>VarDefaultValue</code>),
        the expression is called an <term>initializing expression.</term> The static context for an
        initializing expression includes all functions, variables, and namespaces that are declared
        or imported anywhere in the Prolog.</termdef>
    </p>
    
    <p diff="add" at="2022-11-17">If a required type is defined, then the value obtained by 
      evaluating the initializing expression is converted to the required type by applying
    the <termref def="dt-coercion-rules"/>. A type error occurs if this is not possible.
      In invoking the <termref def="dt-coercion-rules"/>, <termref def="dt-xpath-compat-mode"/> does not apply.</p>


    <p>In a module's dynamic context, a variable value (or the context value) may <termref
        def="dt-depends-on">depend on</termref> another variable value (or the context value).
        <termdef id="dt-depends-on" term="depends on">A variable value (or the context value)
          <term>depends on</term> another variable value (or the context value) if, during the
        evaluation of the initializing expression of the former, the latter is accessed through the
        module context.</termdef></p>

    <p>In the following example, the value of variable <code>$a</code>
      <termref def="dt-depends-on">depends on</termref> the value of variable <code>$b</code>
      because the evaluation of $a's initializing expression accesses the value of $b during the
      evaluation of <code>local:f()</code>.</p>

    <eg role="frag-prolog-parse-test">declare variable $a := local:f(); 
declare variable $b := 1;
declare function local:f() { $b }; </eg>

    <p>A directed graph can be built with all variable values and the context value as nodes, and
      with the <termref def="dt-depends-on">depend on</termref> relation as edges. This graph must
      not contain cycles, as it makes the population of the dynamic context impossible. If it is
      discovered, during static analysis or during dynamic evaluation, that such a cycle exists,
      error <errorref class="DY" code="0054"/> must be raised.</p>


    <!-- ================================================= -->

    <p>During query evaluation, each variable declaration causes a pair <code>(expanded QName <var>N</var>,
        value <var>V</var>)</code> to be added to the <termref def="dt-variable-values">variable
        values</termref>. The <termref def="dt-expanded-qname"/> <var>N</var> is the expanded name of the variable. The value <var>V</var> is as
      follows:</p>

    <ulist>
      <item>
        <p>If <code>VarValue</code> is specified, then <var>V</var> is the result of evaluating
            <code>VarValue</code>.</p>
      </item>

      <item>
        <p> If <code>external</code> is specified, then:</p>

        <ulist>
          <item>
            <p> if a value is provided for the variable by the external environment, then <var>V</var> is that
              value. The means by which typed values of external variables are provided by the
              external environment is implementation-defined.</p>
          </item>

          <item>
            <p> if no value is provided for the variable by the external environment, and
                <code>VarDefaultValue</code> is specified, then <var>V</var> is the result of evaluating
                <code>VarDefaultValue</code>.</p>
          </item>

          <item>
            <p>If no value is provided for the variable by the external environment, and
                <code>VarDefaultValue</code> is not specified, then a <termref
                def="dt-dynamic-error">dynamic error</termref> is raised <errorref class="DY"
                code="0002"/>. </p>
            <p>It is implementation-dependent whether this error is raised if the evaluation of the
              query does not reference the value of the variable.</p>
          </item>
        </ulist>
      </item>
    </ulist>

    <p>In all cases the value <var>V</var> must match the type <var>T</var> according to the rules for SequenceType
      matching; otherwise a <termref def="dt-type-error">type error</termref> is raised <errorref
        class="TY" code="0004"/>.</p>

    

  </div2>

  <div2 id="id-context-value-declarations">
    <head>Context Value Declaration</head>
    
    <changes>
      <change issue="129" PR="368" date="2023-07-21">
        The concept of the context item has been generalized, so it is now a context value. That is,
        it is no longer constrained to be a single item.
      </change>
    </changes>

    <scrap>
      <prodrecap ref="ContextValueDecl"/>
    </scrap>

    <!-- ================================================================== -->

    <p>A context value declaration allows a query to specify the <termref def="dt-static-type">static
        type</termref>, value, or default value for the <termref def="dt-initial-context-value"
        >initial context value</termref>.</p>

    <p>Only the main module can set the <termref def="dt-initial-context-value">initial
        context value</termref>. In a library module, a context value declaration must be external,
      and specifies only the static type. Specifying a <nt def="VarValue"/> or <nt
        def="VarDefaultValue"/> for a context value declaration in a library
      module is a static error <errorref class="ST" code="0113"/>.</p>
    
    <p>The form <code>declare context value</code> allows the <termref def="dt-initial-context-value"/>
    to set to any value, with any sequence type. The alternative form <code>declare context item</code>
    is retained for compatibility with earlier versions of XQuery, and requires the value to be a single
    item, and the type (if specified) to be an item type.</p>

    <p>In every module that does not contain a context value declaration, the effect is as if the
      declaration</p>

    <eg>declare context value as item()* external;</eg>

    <p>appeared in that module.</p>

    <p>The context value declaration has the effect of setting the context
      value static type <code>T</code> in the static context.
      When the form <code>declare context value</code> is used, the default type is <code>item()*</code>.
      When the alternative form <code>declare context item</code> is used, the default type is
      <code>item()</code>.</p>

    <p>If a module contains more than one context value declaration, a static error is raised
        <errorref class="ST" code="0099"/>.</p>

    <p>The static context for an initializing expression includes all functions, variables, and
      namespaces that are declared or imported anywhere in the Prolog.</p>

    <p>During query evaluation, a <termref def="dt-fixed-focus">fixed focus</termref> is
      created in the dynamic context for the evaluation of the <code>QueryBody</code> in the main
      module, and for the initializing expression of every variable declaration in every module.
      
      
      The context value of this fixed focus is called
      the <termref def="dt-initial-context-value">initial context value</termref>,
      which is selected as follows:
      
      </p>

    <ulist>
      <item>
        <p>If <code>VarValue</code> is specified, then
          the initial context value is
          the result of evaluating <code>VarValue</code>.</p>
        <note>
          <p>
            In such a case,
            the initial context value does not obtain its value from the external environment.
            If the external environment attempts to provide a value for the initial context value,
            it is outside the scope of this specification
            whether that is ignored, or results in an error.
          </p>
        </note>
      </item>
      <item>
        <p>If <code>external</code> is specified, then:</p>
        <ulist>
          <item>
            <p>If the declaration occurs in a main module and a value is provided for the context value by the external environment, then
              the initial context value is
              that value. <note><p>If the declaration occurs in a library module, then it does not set the value of the initial context value, the value is set by the main module.</p></note></p>
            <p>The means by which an external value is provided by the external environment is
              implementation-defined.</p>
          </item>

          <item>
            <p>If no value is provided for the context value by the external environment, and
                <code>VarDefaultValue</code> is specified, then
                the initial context value is
                the result of evaluating
                <code>VarDefaultValue</code> as described below. </p>
          </item>

        </ulist>
      </item>
    </ulist>

    <p>In all cases where the context value has a value, that value must match the type
        <code>T</code> according to the rules for SequenceType matching; otherwise a type error is
      raised <errorref class="TY" code="0004"/>. If more than one module contains a context value
      declaration, the context value must match the type declared in each one.</p>

    <p>If <code>VarValue</code> or <code>VarDefaultValue</code> is evaluated, the static and dynamic
      contexts for the evaluation are the current module's static and dynamic context.</p>
    
    <p diff="add" at="2022-11-17">If a required type is defined, then the value obtained by 
      evaluating <code>VarValue</code> or <code>VarDefaultValue</code> is converted to the required type by applying
      the <termref def="dt-coercion-rules"/>. A type error occurs if this is not possible.
      In invoking the <termref def="dt-coercion-rules"/>, <termref def="dt-xpath-compat-mode"/> does not apply.</p>
    

    <p>Here are some examples of context value declarations.</p>

    <ulist>
      <item>
        <p>Declare the type of the context value as a single element item with a required element name:</p>
        <eg role="frag-prolog-parse-test">declare namespace env = "http://www.w3.org/2003/05/soap-envelope"; 
declare context item as element(env:Envelope) external;</eg>

      </item>
      <item>
        <p>Declare a default context value, which is a system log in a default location. If the
          system log is in a different location, it can be specified in the external
          environment:</p>
        <eg role="frag-prolog-parse-test">declare context value as element(sys:log) external :=
  doc("/var/xlogs/sysevent.xml")/sys:log; </eg>
      </item>
      
      <item>
        <p>Declare a context value, which is collection whose collection URI is supplied as an external
          parameter to the query. If the
          system log is in a different location, it can be specified in the external
          environment:</p>
        <eg role="frag-prolog-parse-test">declare variable $uri as xs:string external;
declare context value as document-node()* := collection($uri); </eg>
        <p>With this declaration, a query body such as <code>//person[name="Mandela"]</code> returns all matching
        <code>person</code> elements appearing in any document in the collection.</p>
      </item>
    </ulist>
  </div2>


  <div2 id="FunctionDeclns">
    <head>Function Declarations</head>
    
    <changes>
      <change>
        Function definitions in the static context may now have optional parameters,
        provided this does not cause ambiguity across multiple function definitions with the same name.
        Optional parameters are given a default value, which can be any expression, including one that
        depends on the context of the caller (so an argument can default to the context value).
      </change>
    </changes>
    <p diff="chg" at="variadicity">In addition to the <termref def="dt-system-function">system functions</termref>, XQuery
      allows users to declare functions of their own. A function declaration declares a family of functions
      having the same name and similar parameters. The declaration specifies the name of
      the function, the names and datatypes of the parameters, and the datatype of the result. All
      datatypes are specified using the syntax described in <specref ref="id-types"/>.</p>
    
      <p>Including a function declaration in the query causes a corresponding <termref def="dt-function-definition"/> to be
        added to the <termref def="dt-statically-known-function-definitions"/> of the <termref def="dt-static-context"/>.
        The associated functions also become available in the
        <termref def="dt-dynamically-known-function-definitions">dynamically known function definitions</termref> 
        of the <termref def="dt-dynamic-context"/>.</p>
    
 
 

    <scrap>
      <prodrecap ref="FunctionDecl"/>
    </scrap>

    <p> A function declaration specifies whether the implementation of the function 
      is <termref def="dt-udf">user-defined</termref> or <termref def="dt-external-function">external</termref>.</p>
    
    <p>In addition to <termref def="dt-udf">user-defined functions</termref>
      and <termref def="dt-external-function">external functions</termref>, &language; allows anonymous
      functions to be declared in the body of a query using <termref def="dt-inline-func">inline function expressions</termref>.</p>
    
    
    
    <p>The following example illustrates the declaration and use of a local function that accepts a
      sequence of <code>employee</code> elements, summarizes them by department, and returns a
      sequence of <code>dept</code> elements.</p>
    <example>
      <head>Using a function, prepare a summary of employees that are located in Denver.</head>
        <eg role="parse-test">declare function local:summary($emps as element(employee)*) as element(dept)* { 
  for $no in distinct-values($emps/deptno) 
  let $emp := $emps[deptno = $no]
  return &lt;dept&gt; 
    &lt;deptno&gt;{ $no }&lt;/deptno&gt; 
    &lt;headcount&gt;{ count($emp) }&lt;/headcount&gt; 
    &lt;payroll&gt;{ sum($emp/salary) }&lt;/payroll&gt; 
  &lt;/dept&gt; 
};
local:summary(doc("acme_corp.xml")//employee[location = "Denver"])</eg>
    </example>
    
    <div3 id="id-user-defined-functions">
      <head>User-Defined Functions</head>
    

      <p>
        <termdef id="dt-udf" term="user-defined function">
          <term>User defined functions</term> are functions that contain a <term>function body</term>,
          which provides the implementation of the function as a <termref def="dt-content-expression">content expression</termref>.</termdef> The
          <termref def="dt-static-context">static context</termref> for a function body includes all
        functions, variables, and namespaces that are declared or imported anywhere in the <termref
          def="dt-prolog">Prolog</termref>, including the function being declared. Its <termref
          def="dt-in-scope-variables">in-scope variables</termref> component also includes the
        parameters of the function being declared. </p>
  
        <p>An implementation <rfc2119>should</rfc2119> raise a static error <errorref class="ST" code="0008"/> if the function body depends on 
        the context value.
      </p>
      
      <p>The properties of the <termref def="dt-function-definition"/> <var>F</var> are derived from the syntax of the
        function declaration as follows:</p>
      
      <ulist>
        <item><p>The name of <var>F</var> is the <termref def="dt-expanded-qname"/> obtained by expanding the <code>EQName</code>
          that follows the keyword <code>function</code> using the <termref def="dt-default-function-namespace-rule"/>.</p></item>
        <item><p>The parameters of <var>F</var> are derived from the <code>ParamWithDefault</code> entries in the
          <code>ParamListWithDefaults</code>:</p>
          <ulist>
            <item><p>The parameter name is the <termref def="dt-expanded-qname"/> obtained by expanding the <code>EQName</code>
              that follows the <code>$</code> symbol using the <termref def="dt-no-namespace-rule"/>.</p></item>
            <item><p>The required type of the parameter is given by the <code>TypeDeclaration</code>, defaulting to <code>item()*</code>.</p></item>
            <item><p>The default value of the parameter is given by the expression that follows the <code>:=</code> symbol; if there
              is no default value, then the parameter is a required parameter.</p></item>
          </ulist>
        </item>
        <item><p>The return type of the function is given by the final <code>TypeDeclaration</code> that follows the <code>ParamListWithDefaults</code>
          if present, defaulting to <code>item()*</code>.</p></item>
        <item><p>The function annotations are derived from the annotations that follow the <code>%</code> symbol, if present.</p></item>
        <item><p>The implementation of the function is given by the enclosed expression.</p></item>
      </ulist>
      
      <p>The static context may include more than one declared function with the same expanded name, but their arity ranges must 
        not overlap <errorref class="ST" code="0034"/>.</p>
      
      <note diff="add" at="2023-03-24">
        <p>A consequence of this rule is that a function declaration must not declare a function that has arity 1 (one)
          if its name is the same as the name of an imported atomic type, since the name would then clash with the
          constructor function for that type.</p>
      </note>
      
      
    </div3>
    
    
    <div3 id="id-function-names">
      <head>Function Names</head>
      
      <changes>
        <change issue="1954" PR="1956" date="2025-04-24">
          Private functions declared in a library module are no longer required to be in the module namespace.
        </change>
      </changes>
      
      
      <p>Every declared function must be in a namespace; that is, every declared function name must
        (when expanded) have a non-null namespace URI <errorref class="ST" code="0060"/>.</p>
      
      
        
        <p>A <termref def="dt-public-function"/> 
        declared in a <termref def="dt-library-module">library module</termref> must be in
        the <termref def="dt-target-namespace">target namespace</termref> of the library module
        <errorref class="ST" code="0048"/>. </p>
      
      <p><termdef term="reserved namespaces" id="dt-reserved-namespaces">A <term>reserved namespace</term> is a namespace
        that must not be used in the name of a function declaration.</termdef>  
        It is a <termref def="dt-static-error">static error</termref> <errorref class="ST" code="0045"/> 
        if the function name in a function declaration (when expanded) is 
        in a <termref def="dt-reserved-namespaces">reserved namespace</termref>. 
        The following namespaces are reserved namespaces:
        <ulist>
          <item>
            <p>
              <code>http://www.w3.org/XML/1998/namespace</code>
            </p>
          </item>
          <item>
            <p>
              <code>http://www.w3.org/2001/XMLSchema</code>
            </p>
          </item>
          <item>
            <p>
              <code>http://www.w3.org/2001/XMLSchema-instance</code>
            </p>
          </item>
          <item>
            <p>
              <code>http://www.w3.org/2005/xpath-functions</code>
            </p>
          </item>
          <item>
            <p>
              <code>http://www.w3.org/2005/xpath-functions/array</code>
            </p>
          </item>
          <item>
            <p>
              <code>http://www.w3.org/2005/xpath-functions/map</code>
            </p>
          </item>
          <item>
            <p>
              <code>http://www.w3.org/2005/xpath-functions/math</code>
            </p>
          </item>
          <item>
            <p>
              <code>http://www.w3.org/2012/xquery</code>
            </p>
          </item>
        </ulist>
      </p>
      
      <p>If the function name in a function declaration has no namespace prefix, it is considered to be in the
        <termref def="dt-default-function-namespace"/>. This will result in a static error if the default function
        namespace is a <termref def="dt-reserved-namespaces">reserved namespace</termref>.</p>
               
      
      <p>In order to allow modules to declare functions for local use within the module without
        defining a new namespace, XQuery predefines the namespace prefix <code>local</code> to the
        namespace <code>http://www.w3.org/2005/xquery-local-functions</code>. It is suggested (but not
        required) that this namespace be used for defining local functions, including 
        <termref def="dt-private-function">private functions</termref> declared in 
        <termref def="dt-library-module">library modules</termref>.</p>
      
    </div3>
    
    <div3 id="id-function-parameters">
      <head>Function Parameters</head>
    
    
    <p>A function declaration includes a list of zero or more function parameters.</p>
      
      <p>The parameters of a function declaration are considered to be variables whose scope is the
        function body. It is an <termref def="dt-static-error">static error</termref>
        <errorref class="ST" code="0039"/> for a function declaration to have more than one parameter
        with the same name. The type of a function parameter can be any type that can be expressed as
        a <termref def="dt-sequence-type">sequence type</termref>.</p>
      
      <p>If a function parameter is declared using a name but no type, its default type is
        <code>item()*</code>. If the result type is omitted from a function declaration, its default
        result type is <code>item()*</code>.</p>
      
      <p diff="add" at="variadicity">The function body defines the implementation of the <termref def="dt-function-definition"/>. 
        The rules for static function calls (see <specref ref="id-eval-static-function-call"/>)
        ensure that a value is available for each parameter, whether required or optional, and that the value
        will always be an instance of the declared type.
      </p>
      
      
      <p>A parameter is
    optional if a default value is supplied using the construct <code>:= ExprSingle</code>; otherwise it is required. If a parameter
    is optional, then all subsequent parameters in the list must also be optional; otherwise, a
    <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0148"/>.
    In other words, the parameter list includes
    zero or more required parameters followed by zero or more optional parameters.</p>
    
    <p>The number of arguments that may be supplied in a call to this family of functions is thus in the range <var>M</var> to <var>N</var>,
    where <var>M</var> is the number of required parameters, and <var>N</var> is the total number of parameters (whether required or optional).
    This is refered to as the <termref def="dt-arity-range"/> of the <termref def="dt-function-definition"/>.</p>
      
     <p diff="add" at="2023-05-19">The default value for an optional parameter will often be supplied using a 
       simple literal or constant expression, for example
     <code>$married as xs:boolean := false()</code> or <code>$options as map(*) := { }</code>. However, to allow greater flexibility,
     the initial value can also be context-dependent. For example, <code>$node as node() := .</code> declares a parameter whose
     default value is the context value from the dynamic context of the caller, while <code>$collation as xs:string := default-collation()</code>
     declares a parameter whose default value is the default collation from the dynamic context of the caller.
     The detailed rules are as follows. In these rules, the term <term>caller</term> means the function call or function reference
     that invokes the function being defined.</p>
      
      <p diff="add" at="2023-05-19">The <termref def="dt-static-context"/> for the initializing expression of an optional parameter is the same as the static
      context for the <termref def="dt-initializing-expression"/> of a variable declaration (see <specref ref="id-variable-declarations"/>),
      with the following exceptions:</p>
      
      <ulist diff="add" at="2023-05-19">
        <item><p>The <termref def="dt-in-scope-variables"/> component is empty. This means that the 
          initializing expression cannot refer to any variables, other than local variables declared within the expression itself. 
          Note in particular that it cannot refer to other parameters of the function.</p></item>
        
        <item><p>The <termref def="dt-statically-known-function-definitions"/> excludes all user-defined functions.</p></item>
      </ulist>
      
      <p diff="add" at="2023-05-19">The <termref def="dt-dynamic-context"/> for the initializing expression of an optional parameter 
        is the same as the dynamic context of the <term>caller</term>, with the following exceptions:</p>
      
      <ulist diff="add" at="2023-05-19">
        <item><p>The <termref def="dt-variable-values"/> component is empty.</p></item>
        <item><p>The <termref def="dt-dynamically-known-function-definitions"/> excludes all user-defined functions.</p></item>
      </ulist>
      
      
    
    
    </div3> 
    
    <div3 id="id-function-annotations">
      <head>Function Annotations</head>
      
      <changes>
        <!--<change PR="1137" issue="161" date="2024-04-23">
          Functions may be declared to be variadic.
        </change>
-->
        <change issue="637 2058" PR="682 TODO" date="2025-06-24">
          The values <code>true()</code> and <code>false()</code> are allowed
          in function annotations, as well as negated numeric literals and
          QName literals.
        </change>
      </changes>
  
    <p>A function declaration may use the <code>%private</code> or <code>%public</code> annotations
      to specify that a function is public or private; if neither of these annotations is used, the
      function is public. <termdef id="dt-private-function" term="private function">A <term>private
          function</term> is a function with a <code>%private</code> annotation. A private function
        is hidden from <termref def="dt-module-import">module import</termref>, which can not import
        it into the <termref def="dt-statically-known-function-definitions"/> of another module. </termdef>
      <termdef id="dt-public-function" term="public function">A <term>public function</term> is a
        function without a <code>%private</code> annotation. A public function is accessible to
          <termref def="dt-module-import">module import</termref>, which can import it into the
        <termref def="dt-statically-known-function-definitions"/> of
        another module. </termdef> Using <code>%public</code> and <code>%private</code> annotations
      in a main module is not an error, but it does not affect module imports, since a main module
      cannot be imported. It is a <termref def="dt-static-error">static error</termref>
      <errorref class="ST" code="0106"/> if a function declaration contains both a
        <code>%private</code> and a <code>%public</code> annotation, more than one
        <code>%private</code> annotation, or more than one <code>%public</code> annotation. </p>
      
      <!--<p>The function annotation <code>%variadic</code> declares the corresponding
      <termref def="dt-function-definition"/> to be <termref def="dt-variadic"/>. If a function
        is annotated as <code>%variadic</code> then there must be at least one parameter,
      and all parameters including the final parameter must be required parameters
      <errorref spec="XQ" class="ST" code="0150"/>.
      For an overview of the behavior of variadic functions, see <specref ref="id-variadic-functions-overview"/>. </p>-->
      
      <p>The annotation <code>%method</code> is reserved for use with inline function declarations: see
      <specref ref="id-methods"/> <errorref spec="XP" class="ST" code="0107"/>.</p>
      
      <p>An implementation can define annotations, in its own namespace, to support functionality
        beyond the scope of this specification. For instance, an implementation that supports external
        Java functions might use an annotation to associate a Java function with an XQuery external
        function:</p>
      
      <eg role="frag-prolog-parse-test">declare 
  %java:method("java.lang.StrictMath.copySign") 
function smath:copySign($magnitude, $sign) external;</eg>
      
      
    </div3>
    
    <div3 id="id-external-functions">
      <head>External Functions</head>

      <p>
        In function declarations, <termref def="dt-external-function">external functions</termref> are identified by the keyword
        <code>external</code>. The purpose of a function declaration for an external function is to
        declare the datatypes of the function parameters and result, for use in type checking of the
        query that contains or imports the function declaration.</p>
      
      

    <p>An XQuery implementation may provide a facility whereby external functions can be implemented, 
      but it is not required to do so. If such a facility is
      provided, the protocols by which parameters are passed to an external function, and the result
      of the function is returned to the invoking query, are <termref
        def="dt-implementation-defined">implementation-defined</termref>. An XQuery implementation
      may augment the type system of <bibref ref="xpath-datamodel-40"/> with additional types that
      are designed to facilitate exchange of data, or it may provide
      mechanism for the user to define such types. For example, a type might be provided that
      encapsulates an object returned by an external function, such as an SQL database connection.
      These additional types, if defined, are considered to be derived by restriction from
        <code>xs:anyAtomicType</code>.</p>
    </div3>

 
 
    
    <div3 id="id-recursion">
      <head>Recursion</head>



    <p>A function declaration may be recursive&mdash;that is, it may reference itself. Mutually
      recursive functions, whose bodies reference each other, are also allowed.</p>
      
      <example>
        <head>A recursive function to compute the maximum depth of a document</head>
      
      <p>The following
      example declares a recursive function that computes the maximum depth of a node hierarchy, and
      calls the function to find the maximum depth of a particular document. The function
        <code>local:depth</code> calls the built-in functions <code>empty</code> and
        <code>max</code>, which are in the default function namespace.</p>
 
        <eg role="parse-test">
declare function local:depth($e as node()) as xs:integer {
  (: A node with no children has depth 1 :)
  (: Otherwise, add 1 to max depth of children :)
  if (empty($e/*)) 
  then 1
  else max(for $c in $e/* return local:depth($c)) + 1
};

local:depth(doc("partlist.xml"))
        </eg>

    <!-- ============================================================ -->

<p diff="add" at="variadicity">[TODO: add an example of a function with an optional parameter.]</p>

    <!-- ============================================================ -->
      </example>
    </div3>
  </div2>
  
  <div2 id="id-item-type-declaration" diff="add" at="A">
    <head>Item Type Declarations</head>
    
    <p>An item type declaration defines a name for an <termref def="dt-item-type"/>. Defining a name for an item type
    allows it to be referenced by name rather than repeating
    the <termref def="dt-item-type-designator"/> in full.</p>
    
    <scrap>
      <prodrecap ref="ItemTypeDecl"/>
    </scrap>
    
    <p>An item type declaration adds a <termref def="dt-named-item-type"/> to the <termref def="dt-in-scope-named-item-types"/>
    of the containing module. This enables the item type to be referred to using a simple name.</p>
    
    <example>
    <p>For example, given the declaration:</p>
    
    <eg>declare type app:invoice as map("xs:string", element(inv:paid-invoice));</eg>
    
    <p>It becomes possible to declare a variable containing a sequence of such items as:</p>
      
    <eg>declare variable $invoices as app:invoice*;</eg>
      
    <p>The definition can also be used within another item type declaration:</p>
      
    <eg>declare type app:overdue-invoices as map("xs:date", app:invoice*);</eg>  
      
    </example>
    
    <p>If the name of the item type being declared is written as an (unprefixed) NCName, then 
      it is interpreted as being in the <termref def="dt-default-namespace-elements-and-types"/>.</p>
    
    
    
    <p>An item type declaration may use the <code>%private</code> or <code>%public</code> annotations
      to specify that an item type name is public or private; if neither of these annotations is used, the
      declaration is public.</p>
    
    <ulist>
      <item><p><termdef id="dt-private-item-type" term="private item type">A <term>private
        item type</term> is a named item type with a <code>%private</code> annotation. A private item type
        is hidden from <termref def="dt-module-import">module import</termref>, which can not import
        it into the <termref def="dt-in-scope-named-item-types"/> of another module. </termdef></p></item>
      <item><p><termdef id="dt-public-item-type" term="public item type">A <term>public item type</term> is an
         item type declaration without a <code>%private</code> annotation. A public item type is accessible to
        <termref def="dt-module-import">module import</termref>, which can import it into the
        <termref def="dt-in-scope-named-item-types"/> of
        another module. </termdef></p></item>
      <item><p>Using <code>%public</code> and <code>%private</code> annotations
      in a main module is not an error, but it does not affect module imports, since a main module
      cannot be imported. </p></item>
      <item><p>It is a <termref def="dt-static-error">static error</termref>
      <errorref class="ST" code="0106"/> if an item type declaration contains both a
      <code>%private</code> and a <code>%public</code> annotation, more than one
      <code>%private</code> annotation, or more than one <code>%public</code> annotation. </p></item>
      <item><p>The name of a <termref def="dt-public-item-type"/> declared in a <termref def="dt-library-module"/>
        must (when expanded) be in the <termref def="dt-target-namespace"/> of the 
      <termref def="dt-library-module"/> <errorref class="ST" code="0048"/>.
      </p></item>
      <item><p>The name of a <termref def="dt-private-item-type"/>, or of a <termref def="dt-public-item-type"/> declared
      in a <termref def="dt-main-module"/>, must be in a namespace, which may be any namespace
        that is not a <termref def="dt-reserved-namespaces">reserved namespace</termref>.</p>
      <note><p>Writing the name as an unprefixed NCName is generally possible, except when the
      <termref def="dt-default-namespace-elements-and-types"/> is a reserved namespace.</p></note></item>
    </ulist>
    
    <p>The declaration of an item type is available throughout the containing module; if it is
      public then it is also available throughout any importing modules. Forwards references are
      permitted, but cyclic and self-referential definitions are not allowed <errorref class="ST" code="0140"/>. This means that a reference to
      a named item type can always be replaced by the definition of the item type, but this can only happen after the item
      type declaration has been processed.</p>

    <p diff="add" at="issue275">The name of an item type must be unique among the names of all
      declared item types and <termref def="dt-generalized-atomic-type">generalized atomic types</termref>
      in the <termref def="dt-static-context"/> of the query module. <errorref class="ST" code="0146"/></p>
    
    
    <note><p>Named item types have been designed so that a reference to an item type name can be expanded
      (that is, replaced by its definition) as soon as the declaration is encountered during query parsing.
      There is never any need to retain item type names at execution time except optionally for diagnostics.</p></note>
      
    <note><p>The specification allows forwards references to named item type declarations. 
      While disallowing this would appear to make life easier for implementers, it is not practical because it
    would make cyclic module imports impossible.</p></note>
    
    <note><p>It is possible to import a public variable or function into a different module
    even if its declaration refers to named item types that are not themselves imported (because they
    are declared as <code>%private</code>). This is because the type name can always be replaced by 
    its definition. However, it is generally more convenient if any named item types used
    in public function and variable declarations are themselves public.</p></note>
    
    
  </div2>
  
  <div2 id="id-named-record-types">
    <head>Named Record Types</head>
    <p>Although item type declarations, as described in <specref ref="id-item-type-declaration"/>, can be
    used to give names to record types as well as any other item type, named record types as described
    in this section provide a more concise syntax, plus additional functionality. In particular:</p>
    
    <ulist>
      <item><p>Named record types can be recursive.</p></item>
      <item><p>Named record types implicitly create a constructor function that can be
        used to create instances of the record type.</p></item>
      <item><p>A field in a named record type can be a function that has implicit access to
      the record on which it is defined, rather like methods in object-oriented languages.</p></item>
    </ulist>
    
    <p>The syntax is as follows:</p>
    
    <scrap>
      <prodrecap ref="NamedRecordTypeDecl"/>
    </scrap>
    
    <p>A named record declaration serves as both a <termref def="dt-named-item-type"/> and as a 
      <termref def="dt-function-definition"/>, and
      it therefore inherits rules from both these roles. In particular:</p>
            
    <olist>
       <item><p>Its name must not be the same as the name of any other named item type, or any
         generalized atomic type, that is present in the same static context <errorref class="ST" code="0048"/>.</p></item>
       <item><p>If the declaration is public and is within a <termref def="dt-library-module"/>, then its name
       must be in the <termref def="dt-target-namespace"/> of the library module <errorref class="ST" code="0048"/>.
       </p></item>
       <item><p>As a function, it must not have an arity range that overlaps the arity range of any
       other function declaration having the same name in the same static context.</p></item>
       <item><p>The order of field declarations is significant, because it determines the order of
       arguments in a call to the constructor function.</p></item>
       <item><p>The fields must have distinct names. <errorref class="ST" code="0021"/></p></item>
       <item><p>In order to work as both a record type and a function declaration, the names of the
       fields must be simple NCNames in no namespace; the names must not be written as string literals
         <errorref class="ST" code="0003"/>.</p>
       <note><p>This is described here as a semantic constraint, but an implementation might choose
       to impose it at the level of the grammar.</p></note></item>
       <item><p>If an initializing expression is present in an <nt def="ExtendedFieldDeclaration">ExtendedFieldDeclaration</nt>, it must
       follow the rules for the initializing expression of a parameter in a function declaration,
       given in <specref ref="id-function-parameters"/>. In particular, if any field has an initializing
       expression then all following fields must have an initializing expression.</p></item>
      <item><p>Any annotations that are present, such as <code>%public</code> or <code>%private</code>,
       apply both to the item type declaration and to the function declaration.</p></item>
    </olist>
    
    <div3 id="named-records-as-item-types">
      <head>Named Records as Item Types</head>
    
      
      <p>As a named item type declaration, the construct:</p>
        
        <eg>declare record cx:complex(r as xs:double, i as xs:double := 0);</eg>
      
        <p>is equivalent to:</p>
        
        <eg>declare type cx:complex as record(r as xs:double, i as xs:double);</eg>
        
        <p>Any initializing expressions for fields are ignored for this purpose.</p>
      
        <note><p>The initializing expression only provides a default for values constructed using the 
          constructor function. It has no effect on the rules for determining whether a particular value is a valid instance
        of the type, and it does not affect the result of retrieval operations such as the lookup operator.</p></note>
      
        
        <p>The name of a named record declaration is available throughout the static
          context of the module in which it is declared, including within the record declaration itself. This means that
          named record declarations can be self-recursive or mutually recursive.</p>
      
        <note><p>Unlike a named item type declared using <code>declare type</code>, a reference to a named record type
        cannot (in general) be directly replaced by the corresponding record definition during parsing, because
        in the case of a recursive definition, simple textual replacement would not terminate.</p></note>
      
        <p>A recursive record type will only be instantiable if every field whose value may contain instances of the record type
        (directly or indirectly) is optional or emptiable. Specifically, it must either be an optional field, or its type
        declaration must be such that it can hold an empty sequence or a value of a different type. 
        A recursive record type that is not instantiable is considered to be <termref def="dt-implausible"/>, 
        which means that a processor may treat it as an error but is not obliged to do so <errorref class="ST" code="0023"/>.</p>
        
    </div3>
    <div3 id="named-records-as-functions">
      <head>Constructor Functions for Named Record Types</head>
   
       <p>The construct:</p>
        
        <eg>declare record cx:complex(r as xs:double, i as xs:double := 0);</eg>
      
      <p>implicitly defines the function:</p>
       
       <eg>declare function cx:complex($r as xs:double, $i as xs:double := 0) as cx:complex {
  map:merge(({ "r": $r }, { "i": $i }))
};
       </eg>
      
      <p>So the call <code>cx:complex(3, 2)</code> produces the value <code>{ "r": 3e0, "i": 2e0 }</code>,
      while the call <code>cx:complex(3)</code> produces the value <code>{ "r": 3e0, "i": 0e0 }</code></p>
      
      <p>The order of entries in the map corresponds
      to the order of field declarations in the record type. This means, for example, that when
      the map is serialized using the JSON output method, the order of entries in the output will
      correspond to the order of field declarations.</p>
      
      <p>If a field is declared as optional, by including a question mark after the name, and if it has no initializer,
      then the initializer <code>:= ()</code> is added implicitly. If the declared type of an optional field does
        not permit an empty sequence, then the declared type of the function parameter is adjusted by changing the
        occurrence indicator (from absent to <code>?</code> or from <code>+</code> to <code>*</code>) in order
      to make the empty sequence an acceptable value.</p>
      
      <p>Furthermore, if a field is optional and has no explicit initializer, the relevant entry in the constructed 
        map will be absent when the value supplied (implicitly or explicitly) to the function argument is an empty sequence. 
        This is achieved by modifying the function body. Given the declaration:</p>
      
      <eg>declare record cx:complex(r as xs:double, i? as xs:double);</eg>
      
      <p>the equivalent function declaration is:</p>
       
       <eg>declare function cx:complex($r as xs:double, $i as xs:double? := ()) as cx:complex {
  map:merge((
    { "r": $r },
    if (exists($i)) { { "i": $i } }
  ), { "retain-order" : true() })
};
       </eg>
      
      
      <p>If any field is either declared optional, or has an explicit initializer, 
        then all subsequent fields must also either be declared optional, or have an explicit initializer
        <errorref class="ST" code="0148"/>.</p>
      
      <p>If the record type is declared as extensible (by the presence of a final <code>,*</code>), then
      an additional paremeter is added to the function declaration. The name of the parameter is <code>options</code>
      (provided this name is available for use), its declared type is <code>map(*)</code>, and its default
      value is <code>{}</code> (an empty map). The function body is then modified as shown in the following example.
      Given the declaration:</p>
      
      <eg>declare record p:person($first as xs:string, $last as xs:string, *);</eg>
      
      <p>the equivalent function declaration is:</p>
      
      <eg>declare function p:person(
  $first   as xs:string, 
  $last    as xs:string, 
  $options as map(*) := {}
) as p:person {
  map:merge((
    { "first": $first },
    { "last": $last },
    $options
  ),
  { "duplicates": "use-first" }
 };
      </eg>
      
      <p>The effect of the <code>duplicates</code> option here is that when two values are supplied for the same field,
      one as a direct argument in the function call and the other in the <code>options</code> map, the value supplied
      as a direct argument is used in preference. The resulting
      map has an <xtermref spec="DM40" ref="dt-entry-order"/> in which the named fields appear first, in order of
      declaration, followed by the extension entries supplied in <code>$options</code>, retaining the 
        <xtermref spec="DM40" ref="dt-entry-order"/> of the <code>$options</code> map.</p>
      
      <p>If the name <code>options</code> is already in use for one of the fields, then the first available name from the
      sequence <code>("options1", "options2", ...)</code> is used instead for the additional function parameter.</p>
     
       <p>More formally, the equivalent function declaration is derived as follows:</p>
     
     <ulist>
       <item><p>The function annotations are the annotations on the named record declaration.</p></item>
       <item><p>The function name is the QName of the named record declaration, expanded using
         the <termref def="dt-default-type-namespace-rule"/>. The resulting QName must be the same as the
       module namespace if the declaration appears in a library module, and in any event, it must be in some
       namespace.</p></item>
       <item><p>The parameters of the function declaration are derived from the fields of the named record
       declaration, in order.</p>
       <ulist>
         <item><p>The name of the parameter is the name of the field (always an NCName).</p></item>
         <item><p>The declared type of the parameter is the declared type of the field, if present; but
         if the field is optional, indicated by a question mark (<code>?</code>) after its name, and has no initializer,
           then the occurrence indicator is adjusted to permit an empty sequence, as described earlier.</p></item>
         <item><p>The default value for the parameter is given by the initializing expression in
         the <nt def="ExtendedFieldDeclaration"/>, if present. If the field is optional and has no initializer, then
         it is given a default value of <code>()</code>, the empty sequence.</p></item>
       </ulist></item>
       
       <item><p>If the record type is extensible, then a further parameter is added at the end:</p>
        <ulist>
          <item><p>The name of the parameter is the first available name from the sequence
          <code>("options", "options1", "options2", ...)</code>.</p></item>
          <item><p>The declared type of the parameter is <code>map(*)</code>.</p></item>
          <item><p>The default value of the parameter is <code>{}</code>, the empty map.</p></item>
        </ulist>
       </item>
       
       <item><p>The return type of the function is the name of the record declaration, with no occurrence
       indicator.</p></item>
       <item><p>The body of the function is a call of the function <code>map:merge</code> with two arguments:</p>
         <ulist>
           <item><p>The first argument is a parenthesized expression containing a 
             comma-separated sequence of subexpressions, containing one
           subexpression for each field, in order, and optionally a further subexpression for the
           <code>options</code> parameter if present.</p></item>
           <item><p>By default, the relevant subexpression is the map constructor <code>{ "N": $N }</code>
           where <var>N</var> is the field name.</p></item>
           <item><p>If the field is optional and is declared without an explicit initializer, then the
           relevant subexpression takes the form <code>if (exists($N)) { { "N": $N } }</code>
           where <var>N</var> is the field name.</p></item>
           <item><p>The optional final subexpression, if present, takes the form <code>$options</code>,
           where <code>$options</code> is the name allocated to the final parameter.</p></item>
           <item><p>The second argument in the call of the function <code>map:merge</code>
           is the map <code>{ "duplicates": "use-first" }</code>.</p></item>
         </ulist>
       </item>  
 
 
     </ulist>
      
       
      
       <p>Note that a question mark <code>?</code> after the field name indicates that the field is optional from the point of
       view of conformance of an item to the record type. The presence of an initializer indicates that it is optional
       from the point of view of a call on the constructor function. The two things are independent of each other. For example:</p>
     
       <ulist>
         <item>
           <p><code>record(longitude, latitude, altitude?)</code></p>
           <p>Defines a record type in which <code>altitude</code> entry may be absent, and a constructor
           function with three arguments, of which the last is optional; if the function is called
           with two arguments (or with the third argument set to an empty sequence), then there will be no
           <code>altitude</code> entry in the resulting map.</p>
           <p><code>record(longitude, latitude, altitude := 0)</code></p>
           <p>Defines a record type in which all three fields will always be present, and a constructor
           function in which the third argument can be omitted, defaulting to zero.</p>
           <p><code>record(longitude, latitude, altitude? := ())</code></p>
           <p>Defines a record type in which the <code>altitude</code> entry may be absent both from the
             record and in the function call: but because a default value has been supplied explicitly,
             the constructed map will always have an entry for <code>altitude</code>.</p>
         </item>
       </ulist>
      
      <note>
        <p>Although the constructor function for a named record type produces a map in which the
        order of entries corresponds to the order of field declarations in the record type, the order
        of entries in a map is immaterial when testing whether a map matches the record type: the entries
        can be in any order.</p>
      </note>
      
    </div3>
    <div3 id="id-functions-as-fields">
      <head>Using Methods in Records</head>
       
       <p>Named record declarations are useful in conjunction with <termref def="dt-method">methods</termref>, 
         described in <specref ref="id-methods"/>. For example, given the declaration:</p>
       
       <eg>declare record geom:rectangle(
  width as xs:double,
  height as xs:double,
  area as fn() as xs:double := %method fn() { 
    ?width × ?height
  },
  perimeter as fn() as xs:double := %method fn() {
    2 × (?width + ?height)
  },
  expand as fn($factor as xs:double) as geom:rectangle := %method fn() {
    geom:rectangle(?width × $factor, ?height × $factor)
  }   
);</eg>
       
       <p>The following expression constructs a rectangle and calculates its area:</p>
       
       <eg>let $box := geom:rectangle(3, 2)
return $box?area()</eg>
      
      <p>The following expands the dimensions of the rectangle and 
        calculates the perimeter of the result:</p>
      <eg>let $box := geom:rectangle(3, 2)
return $box?expand(2)?perimeter()</eg>
     <note><p>There is nothing to stop a user constructing an instance of <code>geom:rectangle</code>
     in which the <code>area</code> field holds some different function: while the syntax imitates
     that of object-oriented languages, there is no encapsulation.</p></note>
    </div3>
  </div2>
  
  
  <div2 id="id-option-declaration">
    <head>Option Declarations</head>
    <p>
      <termdef term="option declaration" id="dt-option-declaration">An <term>option
          declaration</term> declares an option that affects the behavior of a particular
        implementation. Each option consists of an identifying EQName and a StringLiteral.</termdef>
    </p>
    <scrap>
      <prodrecap ref="OptionDecl"/>
    </scrap>
    
    <p>Typically, a particular option will be recognized by some implementations and not by others.
      The syntax is designed so that option declarations can be successfully parsed by all
      implementations.</p>
    <p>If the EQName of an option is a <termref def="dt-qname">lexical QName</termref> then it is expanded
    using the <termref def="dt-default-annotation-namespace-rule"/>.</p>

    <note><p>If the name is unprefixed, the <termref def="dt-expanded-qname"
        >expanded QName</termref> will be in the <code>http://www.w3.org/2012/xquery</code> namespace,
      which is reserved for option declarations defined by the XQuery family of specifications.
      XQuery does not currently define declaration options in this namespace.</p>
</note>
    <p>Each implementation recognizes the <code>http://www.w3.org/2012/xquery</code> namespace URI
      and and all options defined in this namespace in this specification. In addition, each
      implementation recognizes an <termref def="dt-implementation-defined"
        >implementation-defined</termref> set of namespace URIs and an implementation-defined set of
      option names defined in those namespaces. If the namespace part of an option declaration's
      name is not recognized, the option declaration is ignored.</p>
    <p>Otherwise, the effect of the option declaration, including its error behavior, is <termref
        def="dt-implementation-defined">implementation-defined</termref>. For example, if the local
      part of the QName is not recognized, or if the StringLiteral does not conform to the rules
      defined by the implementation for the particular option declaration, the implementation may
      choose whether to raise an error, ignore the option declaration, or take some other
      action.</p>
    <p>Implementations may impose rules on where particular option declarations may appear relative
      to variable declarations and function declarations, and the interpretation of an option
      declaration may depend on its position.</p>
    <p>An option declaration must not be used to change the syntax accepted by the processor, or to
      suppress the detection of <termref def="dt-static-error">static errors</termref>. However, it
      may be used without restriction to modify the semantics of the query. The scope of the option
      declaration is <termref def="dt-implementation-defined"
      >implementation-defined</termref>&mdash;for example, an option declaration might apply to the
      whole query, to the current module, or to the immediately following function declaration.</p>
    <p>The following examples illustrate several possible uses for option declarations:</p>
    <ulist>
      <item>
        <p>This option declaration might be used to specify how comments in source documents
          returned by the <code>fn:doc()</code> function should be handled:</p>
        <eg role="frag-prolog-parse-test">declare option exq:strip-comments "true"; </eg>
      </item>
      <item>
        <p>This option declaration might be used to associate a namespace used in function names
          with a Java class: </p>
        <eg role="frag-prolog-parse-test">declare namespace smath = "http://example.org/MathLibrary";
declare option exq:java-class "smath = java.lang.StrictMath"; </eg>
      </item>
    </ulist>
  </div2>
  <div2 id="id-output-declarations">
    <head>Output Declarations</head>
    
               <p role="xquery">
               <bibref ref="xslt-xquery-serialization-40"
                  /> defines a set
of <term>serialization parameters</term> that govern the serialization
process. If an XQuery implementation provides a serialization
interface, it may support (and may expose to users) any of the
serialization parameters listed (with default values) in
in this section.
If an implementation does not support one of these parameters, it must ignore it without raising an error.</p>

            <p role="xquery">
               <termdef id="dt-output-declaration" term="output declaration"
                     >An <term>output declaration</term>
is an option declaration in the namespace <code>http://www.w3.org/2010/xslt-xquery-serialization</code>;
it is used to declare serialization parameters.</termdef>
Except for <code>parameter-document</code>, each option corresponds to a serialization parameter element defined in <xspecref
                  spec="SE40" ref="serparams-schema"
                  />. 
The name of each option is the same as the name of the corresponding serialization parameter element, 
and the values permitted for each option are the same as the values allowed in the serialization parameter element. 
QName values are expanded using the <termref def="dt-default-element-namespace-rule"/>.</p>

            <p role="xquery"
               >There is no output declaration for <code>use-character-maps</code>, it can be set only by means of a parameter document. 
When the application requests serialization of the output, the
processor may use these parameters to control the way in which the
serialization takes place.  Processors may also allow external
mechanisms for specifying serialization parameters, which may or may
not override serialization parameters specified in the query prolog.</p>

            <p>The following example illustrates the use of declaration options. </p>

            <example role="xquery">
               <eg role="frag-prolog-parse-test"><![CDATA[
declare namespace output = "http://www.w3.org/2010/xslt-xquery-serialization";
declare option output:method "xml";
declare option output:encoding "iso-8859-1";
declare option output:indent "yes";
declare option output:parameter-document "file:///home/serialization-parameters.xml";
]]></eg>
            </example>

            <p role="xquery"
                  >An <term>output declaration</term> may appear only in a main module;
it is a static error  <errorref
                  class="ST" code="0108"/> if an output declaration appears in a <termref
                  def="dt-library-module">library module</termref>. 
It is a static error  <errorref
                  class="ST" code="0110"
                  /> if the same serialization parameter is declared more than once.
It is a <termref
                  def="dt-static-error">static error</termref>
               <errorref class="ST" code="0109"
                  /> if the local name of an
output declaration in the <code>http://www.w3.org/2010/xslt-xquery-serialization</code> namespace is not  one of the
serialization parameter names listed in <specref
                  ref="id-xq-static-context-components"
                  /> or <code>parameter-document</code>,
or if the name of an output declaration is <code>use-character-maps</code>. 
The default value for the <code>method</code> parameter is <code>"xml"</code>. An
implementation may define additional <termref
                  def="dt-implementation-defined"
               >implementation-defined</termref>
serialization parameters in its own namespaces.
</p>

            <p role="xquery"
                  >If the local name of an output declaration in the
<code>http://www.w3.org/2010/xslt-xquery-serialization</code> namespace is
<code>parameter-document</code>, the value of the output declaration is treated as a
URI literal.  The value is a location hint, and identifies an XDM instance
in an implementation-defined way.  If a processor is performing
serialization, it is a static error <errorref
                  class="ST" code="0119"
                  />  if the implementation
is not able to process the value of the
<code>output:parameter-document</code> declaration to produce an XDM instance.</p>

            <p role="xquery"
                  >If a processor is performing serialization, the XDM instance identified by
an <code>output:parameter-document</code> output declaration specifies the values of
serialization parameters in the manner defined by
<xspecref
                  spec="SE40" ref="serparams-in-xdm-instance"/>.
It is a static error  <errorref
                  class="ST" code="0115"
                  />  if this
yields a serialization error.  The value of any other output declaration
overrides any value that might have been specified for the same
serialization parameter using an output declaration in the
<code>http://www.w3.org/2010/xslt-xquery-serialization</code> namespace with the local name
parameter-document declaration.</p>

            <p role="xquery"
               >A serialization parameter that is not applicable to the chosen output method
must be ignored, except that if its value is not a valid value for that
parameter, an error may be raised.</p>

            <p role="xquery"
               >A processor that is performing serialization must raise a
serialization error if the values of any serialization parameters that it supports (other than any that are ignored under the previous paragraph) are
incorrect.</p>

            <p role="xquery"
               >A processor that is not performing serialization may report errors if any
serialization parameters are incorrect, or may ignore such parameters.</p>

            <p role="xquery"
               >Specifying serialization parameters in a query does not by itself demand
that the output be serialized. It merely defines the desired form of the
serialized output for use in situations where the processor has been asked
to perform serialization. </p>

            <note role="xquery">
               <p>The <termref def="dt-datamodel"
                     >data
model</termref> permits an element node to have
fewer <termref
                     def="dt-in-scope-namespaces"
                     >in-scope
namespaces</termref> than its parent. Correct serialization of such an
element node would require “undeclaration” of namespaces, which is a
feature of <bibref
                     ref="XMLNAMES11"/>. An implementation that does not
support <bibref
                     ref="XMLNAMES11"
                  /> is permitted to serialize such an
element without “undeclaration” of namespaces, which effectively
causes the element to inherit the in-scope namespaces of its
parent. </p>
            </note>
    
    <div3 id="id-serialization-parameters">
      <head>Serialization Parameters</head>
      
      <table width="100%" border="1" role="small">

        <tbody>

<tr>
<th>Component</th>
<th>Default initial value</th>
</tr>
<tr>
  <td>allow-duplicate-names</td>
  <td>no</td>
</tr>

<tr>
  <td>byte-order-mark</td>
  <td>implementation-defined</td>
</tr>
<tr>
  <td>cdata-section-elements</td>
  <td>empty</td>
</tr>
<tr>
  <td>doctype-public</td>
  <td>none</td>
</tr>
<tr>
  <td>doctype-system</td>
  <td>none</td>
</tr>
<tr>
  <td>encoding</td>
  <td>implementation-defined choice between <code>"utf-8"</code> and <code>"utf-16"</code></td>
</tr>
  <tr>
    <td>escape-solidus</td>
    <td>yes</td>
 </tr>  
<tr>
  <td>escape-uri-attributes</td>
  <td>yes</td>
</tr>

<tr>
  <td>html-version</td>
  <td>implementation-defined</td>
 </tr>


<tr>
  <td>include-content-type</td>
  <td>yes</td>
 </tr>
<tr>
  <td>indent</td>
  <td>no</td>
 </tr>

<tr>
  <td>item-separator</td>
  <td>implementation-defined</td>
</tr>


<tr>
  <td>json-node-output-method</td>
  <td>xml</td>
</tr>

<tr>
  <td>media-type</td>
  <td>implementation-defined</td>
 </tr>
<tr>
  <td>method</td>
  <td>xml</td>
 </tr>
<tr>
  <td>normalization-form</td>
  <td>implementation-defined</td>
 </tr>
<tr>
  <td>omit-xml-declaration</td>
  <td>implementation-defined</td>
 </tr>
<tr>
  <td>standalone</td>
  <td>implementation-defined</td>
</tr>
<tr>
  <td>suppress-indentation</td>
  <td>empty</td>
 </tr>
<tr>
  <td>undeclare-prefixes</td>
  <td>no</td>
 </tr>
<tr>
  <td>use-character-maps</td>
  <td>empty</td>
</tr>
<tr>
  <td>version</td>
  <td>implementation-defined</td>
</tr>
        </tbody>
      </table>
    </div3>
    
  </div2>
</div1>
