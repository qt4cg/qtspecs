<?xml version="1.0" encoding="utf-8"?>

   <div1 id="id-basics">
      <head>Basics</head>
      
      <div2 id="id-terminology">
         <head>Terminology</head>
         
         <changes>
            <change issue="1366" PR="1498">The EBNF operators <code>++</code> and <code>**</code>
      have been introduced, for more concise representation of sequences using a character
      such as <code>","</code> as a separator. The notation is borrowed from Invisible XML.</change>
         </changes>
     
      <p>The basic building block of &language; is the
	 <term>expression</term>, which is a string of <bibref
            ref="Unicode"/> characters; the version of Unicode to be used is <termref
            def="dt-implementation-defined"
            >implementation-defined</termref>.
	 The language provides several kinds of expressions which may be constructed
	 from keywords, symbols, and operands. In general, the operands of an expression
	 are other expressions. &language; allows expressions to be nested with full
generality. <phrase
            role="xquery"
            >(However, unlike a pure functional
language, it does not allow variable substitution if the variable
declaration contains construction of new nodes.)</phrase>
      </p>
      <note>
         <p>This specification contains no
assumptions or requirements regarding the character set encoding of strings
of <bibref
               ref="Unicode"/> characters.</p>
      </note>
      <p>Like XML, &language; is a case-sensitive language. Keywords in
	 &language; use lower-case characters and are not reserved&mdash;that is, names in &language; expressions are allowed to be the same as language keywords, except for certain unprefixed function-names listed in <specref
            ref="id-reserved-fn-names"/>.</p>
         
         
         <p>In this specification the phrases <rfc2119>must</rfc2119>, <rfc2119>must
                  not</rfc2119>, <rfc2119>should</rfc2119>, <rfc2119>should not</rfc2119>,
                  <rfc2119>may</rfc2119>, <rfc2119>required</rfc2119>, and
                  <rfc2119>recommended</rfc2119>, when used in normative
                  text and rendered in small capitals, are to be interpreted as described in
                  <bibref ref="RFC2119"/>.</p>
         
         <p>Certain aspects of language processing are described in this specification as
			<term>implementation-defined</term> or <term>implementation-dependent</term>.</p>

	<ulist>
		<item>
			<p>
				<termdef id="dt-implementation-defined" term="implementation defined"
						><term>Implementation-defined</term> indicates an aspect that may differ
					between implementations, but must be specified by the implementer for each
					particular implementation.</termdef>
			</p>
		</item>
		<item>
			<p>
				<termdef id="dt-implementation-dependent" term="implementation
		dependent"
						><term>Implementation-dependent</term> indicates an aspect that may differ
					between implementations, is not specified by this or any W3C specification, and
					is not required to be specified by the implementer for any particular
					implementation.</termdef>
			</p>
		</item>
	</ulist>

	<p role="xpath">A language aspect described in this specification as
			<term>implementation-defined</term> or <term>implementation dependent</term> may be
		further constrained by the specifications of a host language in which XPath is embedded.</p>
   
         <div3 id="id-ebnf-introduction">
            <head>Grammar Notation</head>
            
            <changes>
               <change issue="1366" PR="1498" date="2024-10-30">
                  The EBNF notation has been extended to allow the constructs <code>(A ++ ",")</code>
                  (one or more occurrences of <code>A</code>, comma-separated, and <code>(A ** ",")</code>
                  (zero or more occurrences of <code>A</code>, comma-separated.
               </change>
            </changes>
            
            <p>The grammar of &language; is defined using a version of EBNF defined
            in <specref ref="EBNFNotation"/>. The notation is based on the EBNF dialect used in the
            XML specification, with two notable additions derived from the Invisible XML grammar:</p>
            
            <p><code>(A ++ ",")</code> represents a sequence of one or more comma-separated
               occurrences of <code>A</code>.</p>
            <p><code>(A ** ",")</code> represents a sequence of zero or more comma-separated
               occurrences of <code>A</code>.</p>
            
            <p>For example the following production rule indicates that an <code>Expr</code>
            consists of one or more occurrences of <code>ExprSingle</code>, separated by commas:</p>
            
            <scrap role="example">
               <prodrecap ref="Expr"/>
            </scrap>
            
            <p>In principle any production can be used for the separator, but in practice this notation
            is only used in cases where the separator is a simple constant string.</p>
            
            <p>EBNF grammar rules appear throughout the specification for ease of reference, and the
            entire grammar is summarized in <specref ref="id-grammar"/>.
            <phrase role="xpath">For &language;, the top-level production rule is 
            <nt def="XPath">XPath</nt>, representing an XPath expression.</phrase>
            <phrase role="xquery">For &language;, the top-level production rule is 
            <nt def="Module">Module</nt>, representing an XQuery module.</phrase></p>
            
   
         </div3>  

      <div3 id="id-values">
         <head>Values</head>
         
         <changes>
            <change issue="1337" PR="1361" date="2024-08-02">
               The term <term>atomic value</term> has been replaced by <termref def="dt-atomic-item"/>.
            </change>
         </changes>
      
      <p>
         <termdef term="value" id="dt-value">In the <termref def="dt-datamodel"
               >data model</termref>, a <term>value</term> is always a <termref def="dt-sequence"
               >sequence</termref>.</termdef></p>
         <p>
         <termdef id="dt-sequence" term="sequence"
               >A
<term>sequence</term> is an ordered collection of zero or more
<termref
               def="dt-item">items</termref>.</termdef></p>
         <p><termdef id="dt-item" term="item">
  An <term>item</term> is either an <termref
               def="dt-atomic-item">atomic item</termref>, a <termref def="dt-node"
               >node</termref>,
or a <termref def="dt-function-item">function item</termref>.</termdef></p>
         
      <p><termdef id="dt-atomic-item" term="atomic item">An <term>atomic
	 item</term> is a value in the value space of an <term>atomic
	 type</term>, as defined in <bibref
               ref="XMLSchema10"/>  or <bibref ref="XMLSchema11"/>.</termdef></p>
         
         <p><termdef id="dt-node" term="node"
               >A <term>node</term> is an instance of one of the
	  <term>node kinds</term> defined in <xspecref
               spec="DM40" ref="Node"
            />.</termdef>
Each node has a unique <term>node identity</term>, a <term>typed value</term>, and a <term>string value</term>. In addition, some nodes have a <term>name</term>. The <term>typed value</term> of a node is a sequence
	 of zero or more atomic items. The <term>string value</term> of a node is a
	 value of type <code>xs:string</code>. The <term>name</term> of a node is a value of type <code>xs:QName</code>.</p>
         
         <p><termdef id="dt-function-item" term="function item">A <term>function item</term> is an item that can
         be called using a <termref def="dt-dynamic-function-call"/>.</termdef></p>
         
         
         <p>Maps (see <specref ref="id-maps"/>) and arrays (see <specref ref="id-arrays"/>) are
         specific kinds of <termref def="dt-function-item"/>s.</p>

      <p>
         <termdef id="dt-singleton" term="singleton"
               >A sequence containing exactly one item is called a
	 <term>singleton</term>.</termdef> An item is identical to a singleton sequence
	 containing that item. Sequences are never nested&mdash;for example, combining the
	 values 1, (2, 3), and ( ) into a single sequence results in the sequence (1, 2,
	 3). <termdef
            id="dt-empty-sequence" term="empty sequence"
               >A sequence containing zero items is called an <term>empty sequence</term>.</termdef>
      </p>
      <p>
         <termdef id="dt-data-model-instance" term="XDM instance"
               >The term <term>XDM instance</term> is used,
    synonymously with the term <termref
               def="dt-value">value</termref>, to denote an unconstrained
    <termref
               def="dt-sequence">sequence</termref> of <termref def="dt-item"
            >items</termref>.</termdef>
      </p>



      <p>Element nodes have a property called <term>in-scope namespaces</term>. <termdef
            term="in-scope namespaces" id="dt-in-scope-namespaces"
               >The <term>in-scope namespaces</term> property of an element node is a set of namespace bindings, each of which associates a namespace prefix with a URI.</termdef>
For a given element, one namespace binding may have an empty prefix; the URI of this namespace binding is the default namespace within the scope of the element.</p>
      <p role="xpath">In <bibref ref="xpath"
            />, the in-scope namespaces of an element node are represented by a collection of <term>namespace nodes</term> arranged on a <term>namespace axis</term>. 
As of XPath 2.0, the namespace axis is deprecated and need not be supported by a host language. A host language that does not support the namespace axis need not represent namespace bindings in the form of nodes.</p>
      <note role="xquery">
         <p>In <bibref ref="xpath"
               />, the in-scope namespaces of an element node are represented by a collection of <term>namespace nodes</term> arranged on a <term>namespace axis</term>, which is optional and deprecated in <bibref
               ref="xpath-40"
            />. XQuery does not support the namespace axis and does not represent namespace bindings in the form of nodes.</p>

         <p>However, where other specifications such as <bibref ref="xslt-xquery-serialization-40"
               /> refer to namespace nodes, these nodes may be synthesized from the in-scope namespaces of an element node by interpreting each namespace binding as a namespace node. An application that needs to create a set of namespace nodes to represent these bindings for an element bound to <code>$e</code> can do so using the following code.


<eg
               role="parse-test"><![CDATA[
in-scope-prefixes($e) ! namespace {.}{ namespace-uri-for-prefix(., $e)} 
]]></eg>
         </p>
      </note>


      <!-- -->

      </div3>
      <div3 id="id-namespaces-and-qnames">
         <head>Namespaces and QNames</head>
      



      <p>
         <termdef id="dt-expanded-qname" term="expanded QName"
            >An <term>expanded QName</term> is a
      triple: its components are a prefix, a local name, and a
      namespace URI. In the case of a name in no namespace, the
      namespace URI and prefix are both absent. In the case of a name
      in the default namespace, the prefix is absent.</termdef> When
      comparing two expanded QNames, the prefixes are ignored: the
      local name parts must be equal under the Unicode codepoint
      collation (<xspecref spec="FO40" ref="collations"/>), 
      and the namespace URI parts must either both be
      absent, or must be equal under the Unicode codepoint
      collation.</p>

      <p>In the &language;
      grammar, QNames representing the names of
      elements, attributes, functions, variables, types, or other such
      constructs are written as instances of the grammatical
      production <nt
            def="EQName">EQName</nt>.</p>

      <scrap>
         <prodrecap ref="EQName"/>
         <!--<prodrecap id="QName" ref="QNameToken"/>
         <prodrecap ref="URILiteral" id="URILiteral" role="xquery"/>
         <prodrecap id="URIQualifiedName" ref="URIQualifiedName"/>
         <prodrecap id="BracedURILiteral" ref="BracedURILiteral"/>
         <prodrecap ref="NCNameTok"/>-->
      </scrap>


      <p>The <nt def="EQName">EQName</nt> production allows a QName to
      be written in one of three ways:
      <ulist>
            <item>
               <p>local-name only (for example, <code>invoice</code>).</p>
               <p>A name written in this form has no prefix, and the rules
        for determining the namespace depend on the context in which
        the name appears. This form is a <termref
                     def="dt-qname">lexical QName</termref>.</p>
            </item>
            <item>
               <p>prefix plus local-name (for example, <code>my:invoice</code>).</p>
               <p>In this case the prefix and local name of the QName are as
        written, and the namespace URI is inferred from the prefix by
        examining the in-scope namespaces in the static context where
        the QName appears; the context must include a binding for the
        prefix. This form is a <termref
                     def="dt-qname">lexical
        QName</termref>.</p>
            </item>
            <item>
               <p>URI plus local-name (for example,
        <code>Q{http://example.com/ns}invoice</code>).</p>
               <p>In this case the local name and namespace URI are as
        written, and the prefix is absent. This way of writing a QName
        is context-free, which makes it particularly suitable for use
        in  <phrase role="xquery">queries</phrase>
            <phrase role="xpath">expressions</phrase>
        that are generated by software. This
        form is a <nt
                     def="URIQualifiedName">URIQualifiedName</nt>.  
        If the <nt
                     def="BracedURILiteral"
                     >
        BracedURILiteral</nt> has no content (for example, <code>Q{}invoice</code>) 
        then the namespace URI of the QName is absent.</p>
            </item>
         </ulist>
      </p>



      <p>
         <termdef id="dt-qname" term="lexical QName"
               >A
          <term>lexical QName</term> is a name that conforms to the syntax of the
          <nt
               def="QName">QName</nt> production</termdef>.
          </p>

      <p>
	  The namespace URI value in a <nt def="URIQualifiedName"
            >URIQualifiedName</nt> is whitespace normalized according
	  to the rules for the <code>xs:anyURI</code> type in
          <xspecref
            spec="XS1-2" ref="anyURI"/> or 
          <xspecref spec="XS11-2" ref="anyURI"
            />. 

          It is a <termref def="dt-static-error">static
          error</termref>
         <errorref class="ST" code="0070"
            /> if the
          namespace URI for an EQName is
          <code>http://www.w3.org/2000/xmlns/</code>.
          </p>

      <p>Here are some examples of <nt def="EQName">EQName</nt>s:</p>

      <ulist>
         <item>
            <p>
               <code role="parse-test">pi</code> is a <termref def="dt-qname"
                  >lexical QName</termref> without a namespace prefix.</p>
         </item>
         <item>
            <p>
               <code role="parse-test">math:pi</code> is a <termref def="dt-qname"
                  >lexical QName</termref> with a namespace prefix.</p>
         </item>
         <item>
            <p>
               <code role="parse-test"
                  >Q{http://www.w3.org/2005/xpath-functions/math}pi</code> specifies the namespace URI using a  <nt
                  def="BracedURILiteral">BracedURILiteral</nt>; it is not a  <termref def="dt-qname"
                  >lexical QName</termref>.</p>
         </item>
      </ulist>


      <p>This document uses the following namespace prefixes to represent the namespace URIs with which they are listed. Although these prefixes are used within this specification to refer to the corresponding namespaces, not all of these bindings will necessarily be present in the static context of every expression, and authors are free to use different prefixes for these namespaces, or to bind these prefixes to different namespaces.</p>
      <ulist>

         <item role="xquery">
            <p>
               <code>xml</code>: <code>http://www.w3.org/XML/1998/namespace</code>
            </p>
         </item>
         <item>
            <p>
               <code>xs</code>: <code>http://www.w3.org/2001/XMLSchema</code>
            </p>
         </item>
         <item role="xquery">
            <p>
               <code>xsi</code>: <code>http://www.w3.org/2001/XMLSchema-instance</code>
            </p>
         </item>
         <item>
            <p>
               <code>fn</code>: <code>http://www.w3.org/2005/xpath-functions</code>
            </p>
         </item>
         <item>
            <p>
               <code>array</code>: <code>http://www.w3.org/2005/xpath-functions/array</code>
            </p>
         </item>
         <item>
            <p>
               <code>map</code>: <code>http://www.w3.org/2005/xpath-functions/map</code>
            </p>
         </item>
         <item>
            <p>
               <code>math</code>: <code>http://www.w3.org/2005/xpath-functions/math</code>
            </p>
         </item>
         <item diff="add" at="2023-05-10">
            <p>
               <code>err</code>: <code>http://www.w3.org/2005/xqt-errors</code>
                  (see <specref ref="id-identifying-errors"/>).</p>
         </item>
         <item role="xquery">
            <p>
               <code>local</code>: <code>http://www.w3.org/2005/xquery-local-functions</code>
                  (see <specref ref="FunctionDeclns"/>.)
            </p>
         </item>
         <item>
            <p>
               <code>output</code>: <code>http://www.w3.org/2010/xslt-xquery-serialization</code>
            </p>
         </item>
         <item role="xquery" diff="add" at="2023-12-14">
            <p>
               <code>xq</code>: <code>http://www.w3.org/2012/xquery</code>
            </p>
         </item>
      </ulist>

      <p>
         <termdef term="URI" id="dt-URI"
               >Within this specification, the term <term>URI</term> refers to a Universal Resource Identifier as defined in <bibref
               ref="RFC3986"/> and extended in <bibref ref="RFC3987"
               /> with the new name <term>IRI</term>.</termdef>
The term URI has been retained in preference to IRI to avoid introducing new names for concepts such as “Base URI” that are defined or referenced across the whole family of XML specifications.</p>

      <note>
         <p>In most contexts, processors are not required to raise errors if a URI is not lexically valid according to  <bibref
               ref="RFC3986"/> and  <bibref ref="RFC3987"/>. See <specref ref="id-uri-literals"/>
            <phrase role="xquery">and <specref ref="id-namespaces"/>
            </phrase> for details.</p>
      </note>
      </div3>
         
      </div2>

      <div2 id="context">
         <head>Expression Context</head>

         <p>
            <termdef id="dt-expression-context" term="expression context"
                  >The <term>expression
		context</term> for a given expression consists of all
		the information that can affect the result of the
		expression.</termdef>
         </p>

         

         <p>This information is organized into two categories
		called the <termref
               def="dt-static-context">static
		context</termref> and the <termref
               def="dt-dynamic-context">dynamic
		context</termref>.</p>
         
         <!--<p role="xquery">
            <termdef id="dt-module-context" term="module context"
               >The <term>module context</term> for a given
		module consists of all the information that is
		accessible to top-level expressions in the
		module.</termdef> The context of a top-level
		expression is defined based on the context of the
		module in which it is defined: the context of the <nt
               def="QueryBody"
            >QueryBody</nt> is the context of the
		main module, and the context for evaluating a function
		body or for a variable’s initializing expression is
		defined based on the context of the module in which
		the function or variable is defined.</p>-->

         <div3 id="static_context">
            <head>Static Context</head>
            <changes>
               <change issue="296" PR="1181" date="2024-04-30">
                  The <termref def="dt-default-namespace-elements-and-types"/> can be set to the value <code>##any</code>,
                  allowing unprefixed names in axis steps to match elements with a given local name in any namespace.
               </change>

               <change issue="1343" PR="1344" date="2024-09-23">

                  Parts of the static context that were there purely to assist in static typing, such as the statically
                  known documents, were no longer referenced and have therefore been dropped.
               </change>
               <change issue="1495">
                  The context value static type, which was there purely to assist in static typing, has been dropped.
               </change>
            </changes>
            <p>
               <termdef id="dt-static-context" term="static context"
                  >The <term>static context</term> of an expression is
		  the information that is available during static analysis of the expression, prior
		  to its evaluation.</termdef> This information can be used to decide whether the
		  expression contains a <termref
                  def="dt-static-error">static error</termref>. </p>
            <p>The individual components of the <termref def="dt-static-context"
                  >static context</termref> are described below.</p>
            
            <p role="xpath">In &language;, the static context for an expression is largely defined
               by the host language, that is, by the calling environment that causes an XPath
               expression to be evaluated. Most of the static context components are constant
               throughout an expression; the only exception is <termref def="dt-in-scope-variables"/>.
               (There are constructs in the language, such as the <nt def="ForExpr">ForExpr</nt>
               and <nt def="LetExpr">LetExpr</nt>, that add additional variables to the static context
               of their subexpressions.)</p>
            
            <p role="xquery">In &language;, the static context for an expression is largely defined
               in the query prolog of a module: see <specref ref="id-query-prolog"/>. Declarations in the 
               prolog, such as variable declarations, function declarations, and decimal format declarations
               populate the static context for expressions appearing within the module. In some cases (but
               not all) these declarations may affect the static context for expressions that precede
               the relevant declaration. The static context can also be affected by declarations in other
               modules that are referenced using an <code>import module</code> declaration: see
               <specref ref="id-module-import"/>.</p>
            
            <p role="xquery">In addition, some expressions modify the static context for their subexpressions.
               The most obvious example is <termref def="dt-in-scope-variables"/>
               (a <nt def="FLWORExpr">FLWORExpr</nt> declares bindings of local variables that are available
               for reference within subsequent clauses of the expression). A further example is the
               <termref def="dt-static-namespaces"/>: an element constructor may contain namespace declarations
               such as <code>xmlns:p="some_uri"</code> which cause additional namespace prefixes to be available
               within the content of the element constructor.</p>
            
            
            
            <p role="xquery">Appendix <specref ref="id-xq-static-context-components"/> gives an overview
               of the components in the static context and the way they are initialized.</p>
             
            <p>Some components of the static context, but not all, also affect the dynamic semantics
            of expressions. For example, casting of a string such as <code>"xbrl:xbrl"</code> to
            an <code>xs:QName</code> might expand the prefix <code>xbrl</code> to the namespace
            URI <code>http://www.xbrl.org/2003/instance</code> using the <termref def="dt-static-namespaces"/>
               from the static context;
            since the input string <code>"xbrl:xbrl"</code> is in general not known until execution time (it
            might be read from a source document), this means that the values of the 
            <termref def="dt-static-namespaces"/> must be available at execution time.</p> 
             

            <ulist>


               <item>
                  <p>
                     <termdef id="dt-xpath-compat-mode" term="XPath 1.0 compatibility     mode">
                        <term>XPath 1.0 compatibility
			 mode.</term>
                        <phrase role="xquery"
                              >This
			 component must be set by all host languages
			 that include XPath 3.1  as a subset,
			 indicating whether rules for compatibility
			 with XPath 1.0 are in effect.
			 XQuery sets the value of this component to
			 <code>false</code>.
                         </phrase>
                        <phrase role="xpath"
                              >This value is <code>true</code> if rules for backward compatibility with XPath Version 1.0 are in effect; otherwise it is <code>false</code>.</phrase>
                     </termdef>
                  </p>
               </item>


               <item>
                  <p>
                     <termdef id="dt-static-namespaces" term="statically known namespaces">
                        <term>Statically known namespaces.</term> 
        This is a mapping from prefix to namespace URI that defines all the namespaces 
        that are known during static processing of a given expression.</termdef></p> 
                  <p>The URI value is whitespace normalized according to the rules for the
                     <code>xs:anyURI</code> type in <xspecref spec="XS1-2" ref="anyURI"/> or 
                     <xspecref spec="XS11-2" ref="anyURI"/>.</p>
                  <p diff="add" at="A">The statically known namespaces may include a binding for the zero-length prefix;
                  however, this is used only in limited circumstances because the rules for resolving
                  unprefixed QNames depend on how such a name is used.</p>
                  <p>Note the difference between <termref def="dt-in-scope-namespaces"
                        >in-scope namespaces</termref>, which is a dynamic property of an element node, and <termref
                        def="dt-static-namespaces"
                     >statically known namespaces</termref>, which is a static property of an expression.</p>
                  <p role="xquery"
                        >Some namespaces are predefined; additional  namespaces can be added to the statically known namespaces by <termref
                        def="dt-namespace-declaration">namespace declarations</termref>,
<termref
                        def="dt-schema-import">schema imports</termref>, or  <termref
                        def="dt-module-import">module imports</termref> in a <termref
                        def="dt-prolog">Prolog</termref>, by  a <termref def="dt-module-declaration"
                        >module declaration</termref>, 
and by <termref def="dt-namespace-decl-attr"
                        >namespace declaration attributes</termref> in <termref
                        def="dt-direct-elem-const">direct element constructors</termref>.</p>
               </item>


               <item>
                  <p diff="chg" at="A">
                     <termdef id="dt-default-namespace-elements-and-types" term="default namespace for elements and types">
                        <term>Default namespace for elements and types.</term> This is either a
				namespace URI, or the special value <code>"##any"</code>, or <xtermref spec="DM40" ref="dt-absent"
                        />. This indicates how unprefixed QNames are interpreted when
                        they appear in a position  where an element name or type name is expected.</termdef></p>
                  <ulist>
                     <item><p diff="chg" at="issue372">If the value is set to a namespace URI, 
                        this namespace is used for any such unprefixed QName. The URI value is
               whitespace-normalized according to the rules for the <code>xs:anyURI</code> type in <xspecref
                           spec="XS1-2" ref="anyURI"/> or <xspecref spec="XS11-2" ref="anyURI"/>.</p></item>
                     <item><p>The special value <code>"##any"</code> indicates that:</p>
                        <ulist>
                           <item><p>When an unprefixed QName is used as a <termref def="dt-name-test"/> for selecting
                              named elements in an <termref def="dt-axis-step"/>, the <termref def="dt-name-test"/>
                           will match an element having the specified local name, in any namespace or none.</p></item>
                           <item><p>When an unprefixed QName is used in a context where a type name is expected
                           (but not as a function name), the default namespace is the <code>xs</code>
                           namespace, <code>http://www.w3.org/2001/XMLSchema</code>.</p></item>
                           <item><p>In any other context, an unprefixed QName represents a name in no namespace.</p></item>
                        </ulist>
                     </item>
                     <item><p diff="chg" at="issue372">If the value is <xtermref spec="DM40" ref="dt-absent"/>,
                        an unprefixed QName representing an element or type
                        name is interpreted as being in no namespace.</p></item>
                  </ulist> 
               </item>
               


               <item>
                  <p>
                     <termdef id="dt-default-function-namespace" term="default function namespace">
                        <term>Default function namespace.</term> This is either a namespace URI, or <xtermref spec="DM40"
                           ref="dt-absent"/>. The namespace URI, if present, is used for any unprefixed QName appearing
                     in a position where a function name is expected.</termdef> The URI value is whitespace-normalized according
                     to the rules for the <code>xs:anyURI</code> type in <xspecref
                        spec="XS1-2" ref="anyURI"/> or <xspecref spec="XS11-2" ref="anyURI"/>
                  </p>
                  <p>
                        In its simplest form its value is simply a whitespace-normalized <code>xs:anyURI</code>
                        value (most commonly, the URI <code>http://www.w3.org/2005/xpath-functions</code>)
                        to be used as the default namespace for unprefixed function names. However, the use of a more
                        complex algorithm is not precluded, for example an algorithm which searches multiple namespaces for
                        a matching name.
                  </p>
                  <p role="xquery">
                     In XQuery, a default function namespace can be
                     declared in the prolog in a <term>default function namespace declaration</term>
                     (see <specref ref="id-default-namespace"/>); in the absence of such a declaration, the namespace
                     <code>http://www.w3.org/2005/xpath-functions</code> is used.</p>
               </item>


               <item>
                  <p>
                     <termdef id="dt-issd" term="in-scope schema definitions">
                        <term>In-scope schema
			 definitions</term> is a generic term
			 for all the element declarations, attribute declarations, and schema type
			 definitions that are in scope during
			 static analysis of an expression.</termdef> It includes the
			 following three
			 parts:</p>
                  <ulist>

                     <item>
                        <p>

                           <termdef id="dt-is-types" term="in-scope schema type">
                              <term>In-scope schema types.</term> Each schema type
			        definition is identified either by an <termref
                                 def="dt-expanded-qname"
                                 >expanded
			        QName</termref> (for a <term>named type</term>)
			        or by an <termref
                                 def="dt-implementation-dependent"
                                 >implementation-dependent</termref> type
			        identifier (for an <term>anonymous
			        type</term>). The in-scope schema types include the predefined schema types described in <specref
                                 ref="id-predefined-types"
                                 />.

                                <phrase role="xquery"
                                    >If the
                                <termref
                                    def="dt-schema-aware-feature"
                                 >Schema Aware Feature</termref>
                                is supported, in-scope schema types
                                also include all type definitions
                                found in imported schemas.</phrase>
                           </termdef>
                        </p>

                     </item>




                     <item>
                        <p>
                           <termdef id="dt-is-elems" term="in-scope element declarations">
                              <term>In-scope element declarations.</term> Each element
declaration is identified either by an <termref
                                 def="dt-expanded-qname"
                                 >expanded QName</termref> (for a top-level element
declaration) or by an <termref
                                 def="dt-implementation-dependent"
                                 >implementation-dependent</termref> element identifier (for a
local element declaration). <phrase
                                 role="xquery"> If the
<termref def="dt-schema-aware-feature"
                                    >Schema Aware Feature</termref>
is supported, in-scope element declarations include all element
declarations found in imported schemas. </phrase>
                           </termdef> An element
declaration includes information about the element’s <termref
                              def="dt-substitution-group"
                           >substitution group</termref> affiliation.</p>
                        <p>
                           <termdef term="substitution group" id="dt-substitution-group">
                              <term>Substitution groups</term> are defined in <xspecref spec="XS1-1"
                                 ref="Element_Equivalence_Class"/> and 
<xspecref spec="XS11-1"
                                 ref="Element_Equivalence_Class"
                                 />. Informally, the substitution group headed by a given element (called the <term>head element</term>) consists of  the set of elements that can be substituted for the head element without affecting the outcome of schema validation.</termdef>
                        </p>
                     </item>

                     <item>
                        <p>
                           <termdef id="dt-is-attrs" term="in-scope attribute declarations">
                              <term>In-scope attribute
declarations.</term> Each attribute declaration is identified either
by an <termref
                                 def="dt-expanded-qname"
                                 >expanded QName</termref> (for a top-level attribute declaration) or by an
<termref
                                 def="dt-implementation-dependent"
                                 >implementation-dependent</termref> attribute identifier (for a local attribute
declaration).  <phrase
                                 role="xquery">If the
<termref def="dt-schema-aware-feature"
                                    >Schema Aware Feature</termref>
is supported, in-scope attribute declarations include all attribute
declarations found in imported
schemas.</phrase>
                           </termdef>
                        </p>
                     </item>
                  </ulist>
               </item>

               <item>
                  <p>
                     <termdef id="dt-in-scope-variables" term="in-scope variables">
                        <term>In-scope variables.</term> 
This is a mapping from <termref
                           def="dt-expanded-qname"
                           >expanded QName</termref> to type. It defines the
set of variables that are available for reference within an
expression. The <termref
                           def="dt-expanded-qname"
                           >expanded QName</termref> is the name of the variable, and the type is the
<termref
                           def="dt-static-type">static type</termref> of the
variable.</termdef>
                  </p>

                  <p>
                     <phrase role="xquery">Variable declarations in a <termref def="dt-prolog"
                           >Prolog</termref> are added to <termref def="dt-in-scope-variables"
                           >in-scope variables</termref>.</phrase>
An expression that binds a variable extends the <termref
                        def="dt-in-scope-variables"
                        >in-scope variables</termref>, within the scope of the variable, with the variable and its type. 
Within the body of an
<termref
                        def="dt-inline-func">inline function expression</termref><phrase role="xquery"> or <termref def="dt-udf">user-defined function</termref>
                     </phrase>, the
<termref def="dt-in-scope-variables"
                        >in-scope variables</termref> are extended
by the names and types of the <term>function
parameters</term>.</p>

                  <p role="xquery">The static type of a variable may either be declared in a query or
inferred by static type inference as discussed in  <specref
                        ref="id-static-analysis"/>.</p>

               </item>

               
               
               <item diff="add" at="A">
                  <p>

                     <termdef id="dt-in-scope-named-item-types" term="in-scope named item types">
                        <term>In-scope named item types.</term> This is a mapping from 
                        <termref def="dt-expanded-qname">expanded QName</termref> to 
                        <termref def="dt-named-item-type">named item types</termref>.</termdef></p>
                   <p><termdef id="dt-named-item-type" term="named item type">A <term>named item type</term>
                      is an <code>ItemType</code> identified by an <termref def="dt-expanded-qname"/>.</termdef>
                  </p>
                  <p>Named item types serve two purposes:</p>
                  <ulist>
                     <item><p>They allow frequently used item types, especially complex item types such as
                        record types, to be given simple names, to avoid repeating the definition 
                        every time it is used.</p></item>
                     <item><p>They allow the definition of recursive types, which are useful for
                     describing recursive data structures such as lists and trees. For details see
                     <specref ref="id-recursive-record-tests"/>. </p></item>
                  </ulist>
                  <note>
                     <p role="xquery">In XQuery, named item types can be declared in the Query Prolog.</p>
                     <p role="xpath">Named item types can be defined in a <termref def="dt-host-language">host language</termref> 
                        such as XQuery 4.0 and in XSLT 4.0, but not in XPath 4.0 itself. They are available in XPath
                        only if the host language provides the ability to define them.</p>
                  </note>
               </item>


               <item diff="chg" at="variadicity">
                  <p>
                    
                        <termdef id="dt-statically-known-function-definitions"
                           term="statically known function definitions">
                           <term>Statically known function definitions.</term> This is a set of 
                           <termref def="dt-function-definition">function definitions</termref>.</termdef>
                  </p>
                  <p>Function definitions are described in <specref ref="id-function-definitions"/>.</p>
                  
                  

               </item>

               <item>
                  <p>
                     <termdef id="dt-static-collations" term="statically known collations">
                        <term>Statically known collations.</term> This is an <termref
                           def="dt-implementation-defined"
                           >implementation-defined</termref>
        mapping from URI to collation. It defines the names of the collations that are available for
				use in processing <phrase
                           role="xquery">queries and</phrase> expressions.</termdef>
                     <termdef term="collation" id="dt-collation"
                           >A <term>collation</term> is a specification of the manner in which strings and URIs are compared and, by extension, ordered. For a more complete definition of collation, see <xspecref
                           spec="FO40" ref="string-compare"/>.</termdef>
                  </p>
               </item>


               

               <item role="xquery">
                  <p>
                     <termdef id="dt-construction-mode" term="construction mode">
                        <term>Construction mode.</term> The
			 construction mode governs the behavior of element and document node constructors. If construction mode is <code>preserve</code>, the type of a constructed element node is <code>xs:anyType</code>, and all attribute and element nodes copied during node construction    retain their original types. If construction mode is <code>strip</code>, the type of a constructed element node is <code>xs:untyped</code>; all element nodes copied during node construction receive the type <code>xs:untyped</code>, and all attribute nodes copied during node construction receive the type <code>xs:untypedAtomic</code>.</termdef>
                  </p>
               </item>

              

               <item role="xquery">
                  <p>
                     <termdef id="dt-default-empty-order" term="default order for empty sequences">
                        <term>Default order for empty sequences.</term> This component controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression, as described in <specref
                           ref="id-order-by-clause"
                        />.</termdef>  Its value may be <code>greatest</code> or <code>least</code>.</p>
               </item>

               <item role="xquery">
                  <p>
                     <termdef id="dt-boundary-space-policy" term="boundary-space policy">
                        <term>Boundary-space
			 policy.</term> This component controls the processing of <termref
                           def="dt-boundary-whitespace"
                           >boundary whitespace</termref>
			 by <termref def="dt-direct-elem-const"
                           >direct element constructors</termref>, as described in <specref
                           ref="id-whitespace"
                        />.</termdef> Its value may be <code>preserve</code> or <code>strip</code>.</p>
               </item>


               <item role="xquery">
                  <p>
                     <termdef id="dt-copy-namespaces-mode" term="copy-namespaces mode">
                        <term>Copy-namespaces mode.</term> This component controls the namespace bindings that
are assigned when an existing element node is copied by an element
constructor, as described in <specref
                           ref="id-element-constructor"
                           />. Its value consists of two parts: <code>preserve</code> or <code>no-preserve</code>, and <code>inherit</code> or <code>no-inherit</code>.</termdef>
                  </p>
               </item>

               <item>

                  <p diff="chg" at="2023-05-19">
                     <termdef id="dt-static-base-uri" term="Static Base URI">
                        <term>Static Base URI.</term>
        This is an absolute URI, used to resolve relative URIs during static analysis.
                     </termdef>
                     For example, it is used to resolve module location URIs in XQuery, and 
                     the URIs in <code>xsl:import</code> and <code>xsl:include</code> in XSLT.
                     <phrase role="xquery"
                           >
        All expressions within a module have the same static base URI.
        The Static Base URI can be set using a <termref
                           def="dt-base-uri-decl">base URI declaration</termref>.
      </phrase>
                     <phrase role="xpath"
                           >
        If <var>E</var> is a subexpression of <var>F</var> then the Static 
        Base URI of <var>E</var> is the same as the Static Base URI of <var>F</var>.
        There are no constructs in XPath that require resolution of relative URI references 
        during static analysis.
      </phrase></p>
      <p><phrase diff="del" at="2023-05-19">The Static Base URI is available during dynamic evaluation by use of the 
      <function>fn:static-base-uri</function> function, and is used implicitly during dynamic 
      evaluation by functions such as <function>fn:doc</function>. </phrase>Relative URI references are 
      resolved as described in <specref
                        ref="id-resolve-relative-uri"/>.</p>
                  
                  <p diff="add" at="2023-05-19">At execution time,
                  relative URIs supplied to functions such as <function>fn:doc</function>
                  are resolved against the <termref def="dt-executable-base-uri"/>,
                  which may or may not be the same as the Static Base URI.</p>

                  <p role="xquery" diff="del" at="2023-05-19"
                        >
      If the value of the Static Base URI is based on the location of the 
      query module (in the terminology of <bibref
                        ref="RFC3986"
                        />, the URI used to retrieve 
      the encapsulating entity), then the implementation <rfc2119>may</rfc2119> use 
      different values for the Static Base URI during static analysis and 
      during dynamic evaluation. This might be necessary, for example, if a 
      query consisting of several modules is compiled, and the resulting 
      object code is distributed to a different location for execution. It 
      would then be inappropriate to use the same location when resolving 
      <code>import module</code> declarations as when retrieving source 
      documents using the <function>fn:doc</function> function. If an implementation uses different 
      values for the Static Base URI during static analysis and during dynamic 
      evaluation, then it is implementation-defined which of the two values is 
      used for particular operations that rely on the Static Base URI; for 
      example, it is implementation-defined which value is used for resolving 
      collation URIs.</p>

               </item>
               
               <item>
                  <p>
                     <termdef id="dt-static-decimal-formats" term="statically known decimal formats">
                        <term>Statically known decimal
		      formats.</term> This is a mapping from QNames to decimal formats, with one default format that has no visible name,
		      referred to as the unnamed decimal format. Each
		      format is available for use when formatting numbers using the <function>fn:format-number</function> function.</termdef>
                  </p>
                  
                  <p>Decimal formats are described in <specref ref="id-decimal-formats"/>.</p>

               </item>
            </ulist>
            
            <div4 id="id-function-definitions">
               <head>Function Definitions</head>
               
               <p><termdef id="dt-function-definition" term="function definition">A <term>function definition</term>
                  contains information used to evaluate a static function call, including the name, parameters,
                  and return type of the function.</termdef></p>
               
               <p>The properties of a <termref def="dt-function-definition"/> include:</p>
               
               <ulist>
                  
                  <item><p>The function name, which is an <termref def="dt-expanded-qname"/>.</p></item>
                  <item><p>Parameter definitions, specifically:</p>
                     <ulist>
                        <item><p>A (possibly empty) list of required parameters, each having:</p>
                           <ulist>
                              <item><p>a parameter name (an <termref def="dt-expanded-qname"/>)</p></item>
                              <item><p>a required type (a <termref def="dt-sequence-type"/>)</p></item>
                           </ulist>
                           
                        </item>
                        <item><p>A (possibly empty) list of optional parameters, each having:</p>
                           <ulist>
                              <item><p>a parameter name (an <termref def="dt-expanded-qname"/>)</p></item>
                              <item><p>a required type (a <termref def="dt-sequence-type"/>)</p></item>
                              <item><p>a default value expression (an <term>expression</term>: see <specref ref="id-expressions"/>)</p></item>
                           </ulist>
                        </item>
                     </ulist>
                     <p>The names of the parameters must be distinct.</p>
                     <p><termdef id="dt-arity-range" term="arity range">A <termref def="dt-function-definition"/> has an <term>arity range</term>,
                        which is a range of consecutive non-negative integers. If the function definition has <var>M</var> required parameters
                        and <var>N</var> optional parameters, then its arity range is from <var>M</var> to <var>M</var>+<var>N</var>
                        inclusive.</termdef></p>
                     <!--<p><termdef id="dt-variadic" term="variadic">A <termref def="dt-function-definition"/> may
                     be declared to be <term>variadic</term>. In a static call of a variadic function, multiple
                     arguments may be mapped to a single parameter in the function definition. In a variadic
                     function with <var>M</var> declared parameters, the arity range is from <var>M-1</var>
                     to positive infinity.</termdef></p>
                     
                     <p>For an overview of variadic functions, see <specref ref="id-variadic-functions-overview"/>.</p>
                     
                     <note><p>Examples of system functions defined to be variadic are <function>fn:concat</function>
                     and <function>fn:codepoints-to-string</function>. User-written functions in XQuery may
                     be declared as variadic by using the <code>%variadic</code> annotation; the equivalent
                     in XSLT is to use the attribute <code>xsl:function/@variadic = "yes"</code>.</p></note>
                     
                   -->
                     
                     <p>The static context may contain several <termref def="dt-function-definition">function definitions</termref> with the
                        same name, but the <termref def="dt-arity-range">arity ranges</termref> of two such function definitions must not 
                        overlap. For example, if two function definitions <var>A</var> and <var>B</var> have the same function name, then:</p>
                     <ulist>
                        <item><p>It is acceptable for <var>A</var> to have two required parameters and no optional
                           parameters, while <var>B</var> has three required parameters and one optional
                           parameter.</p></item>
                        <item><p>It is not acceptable for <var>A</var> to have one required parameter while <var>B</var>
                           has three optional parameters.</p></item>
                        <!--<item><p>It is not possible for both <var>A</var> and <var>B</var> to be <termref def="dt-variadic"/>.</p></item>-->
                     </ulist>
                     
                     <note><p>Implementations must ensure that no two <termref def="dt-function-definition">function definitions</termref> 
                        have the same <termref def="dt-expanded-qname">expanded QName</termref> and overlapping
                        arity ranges (even if the signatures are consistent).</p>
                        
                        <p>XQuery and XSLT enforce this rule by defining a static error if the rule is violated; but further constraints
                           may be needed if an API allows external functions to be added to the static context.</p></note>
                     
                     
                     
                  </item>
                  <item><p>A return type (a <termref def="dt-sequence-type"/>)</p></item>
                  
                  <item>
                     <p diff="add" at="2023-03-11">The function category, which is one of application, system, or external:</p>
                     <ulist diff="add" at="2023-03-11">
                        <item><p><termdef id="dt-application-function" term="application function">
                           <term>Application functions</term> are function definitions written in a 
                           host language such as XQuery or XSLT whose syntax and
                           semantics are defined in this family of specifications. Their behavior 
                           (including the rules determining the static and dynamic context) follows the
                           rules for such functions in the relevant host language specification.</termdef>
                           The most common application functions are functions written by users in XQuery or XSLT.
                        </p></item>
                        <item><p><termdef id="dt-system-function" term="system function">
                           <term>System functions</term> include the functions defined in <bibref
                              ref="xpath-functions-40"/>, functions defined by the specifications 
                           of a host language, <termref def="dt-constructor-function">constructor functions</termref> 
                           for atomic types, and any additional functions provided
                           by the implementation. System functions are sometimes called built-in
                           functions.</termdef>
                        </p>
                           <p>The behavior of system functions follows the rules given for the individual
                              function in this family of specifications, or in the specification of the
                              particular processor implementation. A system function may have behavior that depends on the
                              static or dynamic context of the caller (for example, comparing strings
                              using the default collation from the <phrase diff="chg" at="2023-05-19">dynamic</phrase> context of the caller). Such
                              functions are said to be <termref def="dt-context-dependent"/>.</p></item>
                        <item><p><termdef id="dt-external-function" term="external function"><term>External functions</term> 
                           can be characterized as functions that are neither
                           part of the processor implementation, nor written in a language whose semantics
                           are under the control of this family of specifications. The semantics of external
                           functions, including any context dependencies, are entirely implementation-defined. 
                           In XSLT, external functions are called 
                           <xspecref spec="XT30" ref="extension-functions">extension functions</xspecref>. </termdef> </p>
                           <p>For example, an implementation might provide a mechanism allowing
                              external functions to be written in a language such as Java or Python.
                              The way in which argument and return values are converted between
                              the XDM type system and the type system of the external language is
                              implementation-defined.
                           </p></item>
                        
                     </ulist>
                     <p diff="add" at="2023-03-11"><termdef id="dt-context-dependent" term="context dependent">A 
                        <termref def="dt-function-definition"/> is said to be <term>context dependent</term>
                        if its result depends on the static or dynamic context of its caller.
                        A function definition may
                        be context-dependent for some arities in its arity range, and context-independent
                        for others: for example <function>fn:name#0</function> is context-dependent
                        while <function>fn:name#1</function> is context-independent.</termdef></p>
                     
                     <note diff="add" at="2023-03-11"><p>Some system functions, such as <function>fn:position</function>, <function>fn:last</function>,
                        and <function>fn:static-base-uri</function>, exist for the sole purpose of providing information
                        about the static or dynamic context of their caller.</p></note>
                     <note><p diff="add" at="2023-03-11"><termref def="dt-application-function">Application functions</termref> 
                        are context dependent only to the extent that they define optional parameters with default
                        values that are context dependent.</p></note>
                  </item>
                  <item><p>A (possibly empty) set of <term>function annotations</term></p>
                     <p role="xquery">In XQuery, function annotations are described in <specref ref="id-annotations"/>.</p></item>
                  <item><p diff="chg" at="2023-03-11">A body. The function 
                     body contains the logic that enables the function
                     result to be computed from the supplied arguments and information in the static and dynamic context.</p></item>
               </ulist>
               
               
               
               
               
               
               
               
               <!--<p diff="add" at="B"><termref def="dt-system-function">System functions</termref>
                  (also commonly called built-in functions) are <termref def="dt-function-definition">function definitions</termref> that are always
                  present in the static context by virtue of rules in the host language; they will typically include
                  the functions specified in <bibref ref="xpath-functions-40"/>.</p>
               
               -->
               
               <p>The <termref def="dt-function-definition">function definitions</termref> 
                  present in the static context are available for reference from a 
                  <termref
                     def="dt-static-function-call"
                     >static function call</termref>,
                  or from a 
                  <termref
                     def="dt-named-function-ref"
                     >named function reference</termref>.
                  
               </p>
               
               
               
            </div4>
                  
                  <div4 id="id-decimal-formats">
                     <head>Decimal Formats</head>
                     <changes>
                        <change issue="1048" PR="1250" date="2024-06-03">
                           Several decimal format properties, including minus sign, exponent separator, percent, and per-mille,
                           can now be rendered as arbitrary strings rather than being confined to a single
                           character.
                        </change>
                     </changes>
                     <p>Each decimal format defines a set of properties, which control the interpretation of characters
                        in the picture string supplied to the <function>fn:format-number</function>
                        function, and also specify characters to be used in the result
                        of formatting the number.</p>
                     
                     <p>Each property potentially has two parts: a marker character <var>M</var> used
                     in the picture string to mark an insertion position, and a rendition string <var>R</var>
                     to indicate how the relevant property is to be rendered in the output of the 
                     <code>fn:format-number</code> function. In the list below properties are annotated
                     with <emph>(<var>M</var>)</emph>, <emph>(<var>R</var>)</emph>, or 
                     <emph>(<var>M</var>, <var>R</var>)</emph> to indicate whether the property includes a
                     marker character, a rendition string, or both.</p> 
                     
                     <p>In XQuery and XSLT declarations
                     defining the values of properties, a property where the marker character and the
                     rendition differ is indicated using the syntax <code><var>M</var>:<var>R</var></code>. For
                     example the <code>percent</code> property may be expressed as <code>%:pc</code>
                     to indicate that the character <code>%</code> will be used in the picture string,
                     and the string <code>pc</code> will be used in the function output.
                     In this example, the value <code>0.10</code>, formatted with the picture string 
                      <code>#0%</code>, results in the output <code>10pc</code></p>
                     
                     
                     <ulist>
                        <item>
                           <p>
                              <termdef id="id-static-decimal-format-decimal-separator"
                                 term="decimal-separator">
                                 <term>decimal-separator</term> 
                                 <emph>(<var>M</var>, <var>R</var>)</emph> is
                                 used to separate the integer part of the number from the fractional part.
                                 The default value for both the marker and the rendition is <char>U+002E</char>.</termdef>
                           </p>
                        </item>
                        
                        <item>
                           <p>
                              <termdef id="id-static-decimal-format-exponent-separator"
                                 term="exponent-separator">
                                 <term>exponent-separator</term> 
                                 <emph>(<var>M</var>, <var>R</var>)</emph> is
                                 used to separate the mantissa from the exponent in
                                 scientific notation. The default value 
                                 for both the marker and the rendition is <char>U+0065</char>.</termdef>
                           </p>
                        </item>
                        
                        <item>
                           <p>
                              <termdef id="id-static-decimal-format-grouping-separator"
                                 term="grouping-separator">
                                 <term>grouping-separator</term>
                                 <emph>(<var>M</var>, <var>R</var>)</emph> is used to 
                                 separate groups of digits (for example as a thousands separator).
                                 The default value for both the marker and the rendition is <char>U+002C</char>.</termdef>
                           </p>
                        </item>
                        
                        <item>
                           <p>
                              <termdef id="id-static-decimal-format-percent" term="percent">
                                 <term>percent</term>
                                 <emph>(<var>M</var>, <var>R</var>)</emph> is used to 
                                 indicate that the number is written as a per-hundred fraction; the default
                                 value for both the marker and the rendition is <char>U+0025</char>.</termdef>
                           </p>
                        </item>
                        
                        <item>
                           <p>
                              <termdef id="id-static-decimal-format-per-mille" term="per-mille">
                                 <term>per-mille</term>
                                 <emph>(<var>M</var>, <var>R</var>)</emph> is used to 
                                 indicate that the number is written as a per-thousand fraction; the default
                                 value for both the marker and the rendition is <char>U+2030</char>.</termdef>
                           </p>
                        </item>
                        
                        <item>
                           <p>
                              <termdef id="id-static-decimal-format-zero-digit" term="zero-digit">
                                 <term>zero-digit</term>
                                 <emph>(<var>M</var>)</emph>
                                 is the character used in the picture string to represent the digit zero; the default
                                 value is <char>U+0030</char>. This character must be a digit
                                 (category Nd in the Unicode property database), and it must have
                                 the numeric value zero. This property implicitly defines the
                                 ten Unicode characters that are used to represent the values 0
                                 to 9 in the function output: Unicode is organized so that each
                                 set of decimal digits forms a contiguous block of characters in
                                 numerical sequence. Within the picture string any of these ten character 
                                 can be used (interchangeably) as a place-holder for a mandatory digit.
                                 Within the final result string, these ten characters are used to represent
                                 the digits zero to nine.</termdef>
                           </p>
                        </item>
                        
                     <!--</ulist>
                     
                     <p>In the case of the the properties <termref def="id-static-decimal-format-decimal-separator"/>,
                     <termref def="id-static-decimal-format-grouping-separator"/>,
                     <termref def="id-static-decimal-format-exponent-separator"/>,
                        <termref def="id-static-decimal-format-percent"/>
                        and <termref def="id-static-decimal-format-per-mille"/>, the property may take the form
                        <code>m:r</code>, where <code>m</code> is a single-character marker used in the picture
                        string to indicate where the relevant output should appear, and <code>r</code> is the
                        string used to represent the property in the result. .
                     </p>
                     
                     <p>The following properties specify 
                        characters to be used in the picture string supplied to the <function>fn:format-number</function>
                        function, but not in the formatted number. In each case the value must be a single character.
                     </p>
                     
                     <ulist>-->
                        <item>
                           <p>
                              <termdef id="id-static-decimal-format-digit" term="digit">
                                 <term>digit</term>
                                 <emph>(<var>M</var>)</emph>
                                 is a character used in the picture string to represent an optional digit; 
                                 the default value is <char>U+0023</char>.</termdef>
                           </p>
                        </item>
                        
                        <item>
                           <p>
                              <termdef id="id-static-decimal-format-pattern-separator"
                                 term="pattern-separator">
                                 <term>pattern-separator</term>
                                 <emph>(<var>M</var>)</emph> is a character used
                                 to separate positive and negative sub-pictures
                                 in a picture string; the default value is <char>U+003B</char>.</termdef>
                           </p>
                        </item>
 <!--                    </ulist>
                     
                     <p>The following properties specify characters or strings that
                        may appear in the result of formatting the number, but not in the picture string:</p>
                     
                     <ulist>-->
                        <item>
                           <p>
                              <termdef id="id-static-decimal-format-infinity" term="infinity">
                                 <term>infinity</term>
                                 <emph>(<var>R</var>)</emph>
                                 is the string used to represent the double value infinity (<code>INF</code>); the
                                 default value is the string <code>"Infinity"</code></termdef>
                           </p>
                        </item>
                        
                        <item>
                           <p>
                              <termdef id="id-static-decimal-format-NaN" term="NaN">
                                 <term>NaN</term>
                                 <emph>(<var>R</var>)</emph>
                                 is the string used to
                                 represent the double value <code>NaN</code> (not a number); the default value is the string <code>"NaN"</code></termdef>
                           </p>
                        </item>
                        
                        <item>
                           <p>
                              <termdef id="id-static-decimal-format-minus-sign" term="minus-sign">
                                 <term>minus-sign</term>
                                 <emph>(<var>R</var>)</emph> is the string used to mark negative numbers; the
                                 default value is <char>U+002D</char>.</termdef>
                           </p>
                        </item>
                     </ulist>
                  
           </div4>
               

         </div3>
         <div3 id="eval_context">
            <head>Dynamic Context</head>
            
            <changes>
               <change issue="129" PR="368" date="2023-09-14">
                  The concept of the context item has been generalized, so it is now a context value. That is,
                  it is no longer constrained to be a single item.
               </change>
               <change issue="1161" PR="1265" date="2024-06-11">
                  The rules regarding the <code>document-uri</code> property of nodes returned by the
                  <function>fn:collection</function> function have been relaxed.
               </change>
            </changes>
            <p>
               <termdef id="dt-dynamic-context" term="dynamic context"
                     >The <term>dynamic
context</term> of an expression is defined as information that is needed for the dynamic evaluation of an expression,
                  beyond any information that is needed from the <termref def="dt-static-context"/>.</termdef> If
evaluation of an expression relies on some part of the <termref def="dt-dynamic-context"/> that 
is <xtermref spec="DM40" ref="dt-absent"/>, a <termref def="dt-type-error"/> 
               is raised <errorref class="DY" code="0002"/>.</p>
            
            <note><p>In previous versions of the specification, this was classified as a
            <termref def="dt-dynamic-error"/>. The change allows the error to be raised during
            static analysis when possible; for example a function written as
            <code>fn($x) { @code }</code> can now be reported as an error whether or not
            the function is actually evaluated. The actual error code remains unchanged
            for backwards compatibility reasons.</p>
            <p>There are other cases where static detection of the error is not possible.</p>
            </note>
            <p>The individual
components of the <termref def="dt-dynamic-context"
                  >dynamic context</termref> are described below.</p>
            
            <p>In general, the dynamic context for the outermost expression is supplied externally,
               often by some kind of application programming interface (API) allowing &language;
               expressions to be invoked from a host language. Application Programming Interfaces
               are outside the scope of this specification. <phrase role="xquery">In &language;,
               some aspects of the dynamic context (for example, initial values of variables)
               are defined within the query prolog.</phrase> The dynamic context for inner subexpressions
               may be set by their containing expressions: for example in a mapping expression 
               <code><var>E1</var>!<var>E2</var></code>,
               the value of the <termref def="dt-focus"/> (part of the dynamic context) for evaluation
               of <var>E2</var> is defined by the evaluation of <var>E1</var>.</p>
            
            <p>Some aspects of the dynamic context are outside the direct control of the query author;
               they are defined by the implementation, which may or may not allow them to be configured by users.
               An example is <termref def="dt-available-docs"/>, which is an abstraction for the set of XML
               documents that can be retrieved by URI from within an expression. In some environments this may be
               the entire contents of the web; in others it may be constrained to documents that satisfy
               particular security constraints; and in some environments the set of available documents
               might even be empty. These components of the dynamic context are generally treated as being constant for
               the duration of the execution.</p>
               
               
               
               
<p><phrase role="xquery"
                     >Rules governing the initialization and alteration of  these components can be found in  <specref
                     ref="id-xq-evaluation-context-components" role="xquery"/>.</phrase>
               <phrase role="xpath"
                     >Further rules governing the semantics of these components can be found in <specref
                     ref="id-xp-evaluation-context-components" role="xpath"/>.</phrase>
            </p>

            <p>The components of the 
           <termref def="dt-dynamic-context"/> are listed below.</p>
            <p>
               <termdef id="dt-focus" term="focus">The first three components of
the <termref
                     def="dt-dynamic-context"
                     >dynamic context</termref>
(context value, context position, and context size) are called the
<term>focus</term> of the expression. </termdef> The focus enables the
processor to keep track of which items are being processed by the
expression.

<phrase
                  role="xquery"
                  >If any component in the focus is defined, all components of the focus are defined.</phrase>

<phrase role="xpath"
                  >If any component in the focus is defined, both the context value and context position are known.</phrase> 
            </p>
                <note role="xpath">
                  <p>If any component in the focus is defined, context size is usually defined as well.  However, when streaming, 
the context size cannot be determined without lookahead, so it may be undefined.  If so, expressions like <code>last()</code> will 
                     raise a dynamic error because the context size is undefined.</p>
               </note>
               <p><termdef id="dt-fixed-focus" term="fixed focus"
                  >A <term>fixed focus</term> is a focus for an expression that is evaluated once, 
                  rather than being applied to a series of values; in a fixed focus, 
                  the context value is set to one specific value, the context position is 1, and the context size is 1.</termdef>
               </p>
               <p><termdef id="dt-singleton-focus" term="singleton focus"
                     >A <term>singleton focus</term> is a <termref def="dt-fixed-focus"/> in which the
                  <termref def="dt-context-value"/> is a <termref def="dt-singleton"/> item.</termdef>.
               With a singleton focus, the context value is a single item, the context position is 1, and the context size is 1.
               </p>
            
            <p>Certain language constructs, notably the <termref def="dt-path-expression"
                  >path operator</termref>
               <code role="parse-test"><var>E1</var>/<var>E2</var></code>, the <nt def="SimpleMapExpr"
                  >simple map operator</nt>
               <code role="parse-test"><var>E1</var>!<var>E2</var></code>, and the <termref def="dt-predicate"
                  >predicate</termref>
               <code role="parse-test"
                  ><var>E1</var>[<var>E2</var>]</code>, create a new focus
for the evaluation of a sub-expression. In these constructs, <var
                  role="parse-test"
                  >E2</var> is evaluated once for each item in the
sequence that results from evaluating <var
                  role="parse-test">E1</var>. Each time <var role="parse-test"
                  >E2</var> is evaluated, it is evaluated with a
different focus. The focus for evaluating <var
                  role="parse-test"
                  >E2</var> is referred to below as the <term>inner
focus</term>, while the focus for evaluating <var
                  role="parse-test"
                  >E1</var> is referred to as the <term>outer
focus</term>. The inner focus is used only for the evaluation of <var
                  role="parse-test"
               >E2</var>. Evaluation of <var>E1</var> continues with its original focus unchanged.</p>
            <ulist>

               <item>
                  <p>
                     <termdef id="dt-context-value" term="context value"
                           >The <term>context value</term>
is the <termref def="dt-value">value</termref> currently being processed.</termdef>
                     In many cases (but not always), the context value will be a single item.
                     <termdef id="dt-context-node" term="context node"
                           >When the context value is a single item, it can also be referred
                        to as the <term>context item</term>; when it is a single node,
it can also be referred to as the <term>context
node</term>.</termdef> The context value is returned by an expression
consisting of a single dot (<code
                        role="parse-test">.</code>). When an expression <code role="parse-test"
                        ><var>E1</var>/<var>E2</var></code> or <code role="parse-test"
                        ><var>E1</var>[<var>E2</var>]</code> is evaluated, each item in the
sequence obtained by evaluating <code
                        role="parse-test"
                        ><var>E1</var></code>
becomes the context value in the inner focus for an evaluation of <var
                        role="parse-test">E2</var>. </p>
                  <p role="xquery">
                     <termdef id="dt-initial-context-value" term="initial context value">
    
    
      In the dynamic context of every module in a query,
      the context value component must have the same setting.
      If this shared setting is not <xtermref spec="DM40" ref="dt-absent"/>,
      it is referred to as the <term>initial context value</term>.
    
  </termdef>
                  </p>

               </item>

               <item>
                  <p>
                     <termdef id="dt-context-position" term="context position"
                           >The <term>context
position</term> is the position of the context value within the
series of values currently being processed.</termdef> It changes whenever the context value
changes. When the focus is defined, the value of the context position is an integer greater than zero. The context
position is returned by the expression <code
                        role="parse-test">fn:position()</code>. When an expression <code
                        role="parse-test"><var>E1</var>/<var>E2</var></code> or <code role="parse-test"
                        ><var>E1</var>[<var>E2</var>]</code> is evaluated, the context position in
the inner focus for an evaluation of <code
                        role="parse-test"
                        >E2</code>
is the position of the context value in the sequence obtained by
evaluating <var
                        role="parse-test"
                     >E1</var>. The position of the
first item in a sequence is always 1 (one). The context position is
always less than or equal to the context size.</p>
               </item>

               <item>
                  <p>
                     <termdef id="dt-context-size" term="context size"
                        >The <term>context
size</term> is the number of values in the series of values currently
being processed.</termdef> Its value is always an
integer greater than zero. The context size is returned by the
expression <code
                        role="parse-test">fn:last()</code>. When an expression
<code
                        role="parse-test"><var>E1</var>/<var>E2</var></code> or <code role="parse-test"
                        ><var>E1</var>[<var>E2</var>]</code> is evaluated, the context size in the
inner focus for an evaluation of <var
                        role="parse-test"
                        >E2</var> is
the number of items in the sequence obtained by evaluating <var
                        role="parse-test">E1</var>. </p>
               </item>




               <item>
                  <p>
                     <termdef id="dt-variable-values" term="variable values">
                        <term>Variable values</term>. 
        This is a mapping from <termref
                           def="dt-expanded-qname"
                           >expanded QName</termref> to value. 
        It contains the
				same <termref
                           def="dt-expanded-qname">expanded QNames</termref> as the <termref
                           def="dt-in-scope-variables"
                           >in-scope variables</termref> in the
				<termref def="dt-static-context"
                           >static context</termref> for the expression. The <termref
                           def="dt-expanded-qname"
                           >expanded QName</termref> is the name of the variable and the value is the dynamic value of the variable, which includes its <termref
                           def="dt-dynamic-type">dynamic type</termref>.</termdef>
                  </p>


               </item>

               <item>
                  <p diff="chg" at="variadicity">
                     <termdef term="dynamically known function definitions" id="dt-dynamically-known-function-definitions">
                        <term>Dynamically known function definitions</term>.
        This is a set of <termref def="dt-function-definition">function definitions</termref>. It includes the
                        <termref def="dt-statically-known-function-definitions"/> as a subset, but may include
                        other function definitions that are not known statically.
      </termdef></p>
     
                  <p>The function definitions in the dynamic context are used primarily by the <function>fn:function-lookup</function>
                  function.</p>
                  <p>If two function definitions in the <termref def="dt-dynamically-known-function-definitions"/> have the same
                     name, then their <termref def="dt-arity-range">arity ranges</termref> must not overlap.</p>
                  <note><p>The reason for allowing named functions to be available dynamically beyond those that are
                  available statically is primarily to allow for cases where the run-time execution
                  environment is significantly different from the compile-time environment. This could happen, for example,
                  if a stylesheet or query is compiled within a web server and then executed in the web browser.
                  The <function>fn:function-lookup</function> function allows dynamic discovery of resources that were not
                  available statically.</p></note>
                  
  <!--                supplies a function for each signature in 
      <termref
                        def="dt-known-func-signatures"
                        >
        statically known function signatures
      </termref>
      and may supply other functions 
      (see <specref
                        ref="id-consistency-constraints"
                        />).  Named functions can include 
      
      
      <termref
                        def="dt-external-function">external functions</termref>.
      
                        id="dt-implementation-defined-function"
                        term="implementation-defined function"
                           >An <term>implementation-defined function</term> is an <termref
                           def="dt-external-function">external function</termref> that is <termref
                           def="dt-implementation-defined">implementation-defined</termref>
                     </termdef>.
        
        <phrase role="xpath">
                        <termdef id="dt-host-language-function" term="host language function"
                           role="xpath">A <term>host language function</term> is an <termref
                              def="dt-external-function"
                              >external function</termref> defined by the <termref
                              def="dt-host-language">host language</termref>.</termdef>
                     </phrase>
                  </p>-->
               </item>

               <item>
                  <p>
                     <termdef id="dt-date-time" term="current dateTime">
                        <term>Current dateTime.</term> This information represents
				an <termref
                           def="dt-implementation-dependent"
                           >implementation-dependent</termref> point in time during the processing of <phrase
                           role="xquery">a query</phrase>
                        <phrase role="xpath"
                           >an expression</phrase>, and includes an explicit timezone. It can be retrieved by the  <function>fn:current-dateTime</function> function. 
                        If called multiple times during the execution of <phrase
                           role="xquery">a query</phrase>
                        <phrase role="xpath"
                        >an expression</phrase>,
				this function always returns the same result.</termdef>
                  </p>
               </item>

               <item>
                  <p>
                     <termdef id="dt-timezone" term="implicit timezone">
                        <term>Implicit timezone.</term> This is the timezone to be used when a date,
time, or dateTime value that does not have a timezone is used in a
comparison or arithmetic operation. The implicit timezone is an  <termref
                           def="dt-implementation-defined"
                           >implementation-defined</termref> value of type
<code>xs:dayTimeDuration</code>. See <xspecref
                           spec="XS1-2" ref="dateTime-timezones"/> or
<xspecref spec="XS11-2"
                           ref="dateTime"/> for the range of valid values of a timezone.</termdef>
                  </p>
               </item>
               
               <item diff="add" at="2023-05-19">
                  <p><termdef id="dt-executable-base-uri" term="Executable Base URI">
                     <term>Executable Base URI.</term> This is an absolute URI used
                     to resolve relative URIs during the evaluation of expressions;
                     it is used, for example, to resolve a relative URI supplied
                     to the <function>fn:doc</function> or <function>fn:unparsed-text</function>
                     functions.
                  </termdef></p>
                  <p>URIs are resolved as described in <specref ref="id-resolve-relative-uri"/>.</p>
                  <p>The function <function>fn:static-base-uri</function>, despite its name, returns the
                     value of the <termref def="dt-executable-base-uri"/>.</p>
                  <p>In many straightforward processing scenarios, the <termref def="dt-executable-base-uri"/>
                  in the dynamic context will be the same as the <termref def="dt-static-base-uri"/> for the
                     corresponding expression in the static context. There are situations, however, where they may differ:</p>
                  <ulist>
                     <item><p>Some processors may allow the static analysis of a query or stylesheet
                     to take place on a development machine, while execution of the query or stylesheet
                     happens on a test or production server. In this situation, resources needed during
                     static analysis (such as other modules of the query or stylesheet) will be located
                     on the development machine, by reference to the <termref def="dt-static-base-uri"/>,
                     while resources needed during execution (such as reference data files) will be located
                     on the production machine, accessed via the <termref def="dt-executable-base-uri"/>.</p></item>
                     <item><p>When the <function>fn:static-base-uri</function> function is called within
                     the initializing expression of an optional parameter in a function declaration,
                     it returns the executable base URI of the relevant function call. This allows a user-written
                     function to accept two parameters: a required parameter containing a relative URI, and an
                     optional parameter containing a base URI. The optional parameter can be given a default
                     value of <code>fn:static-base-uri()</code>, allowing the code in the function body
                     to resolve the relative URI against the executable base URI of the caller.</p></item>
                  </ulist>
               </item>
               
               <item>
                  
                  <p>
                     <termdef id="dt-def-collation" term="default collation">
                        <term>Default
                           collation.</term> This identifies one of the collations in <termref
                              def="dt-static-collations"
                              >statically known collations</termref> as the  collation to be
                        used by functions and operators for comparing and ordering values of type <code>xs:string</code> and <code>xs:anyURI</code> (and types derived from them) when no
                        explicit collation is
                        specified.</termdef>
                  </p>
                  
                  <note diff="add" at="2023-05-19"><p>Although the default collation is defined (in 4.0) as a property of the
                     dynamic context, its value will in nearly all cases be known statically. The reason it is defined in the
                     dynamic context is to allow a call on the <function>fn:default-collation</function> function to be used when defining
                     the default value of an optional parameter to a user-defined function. In this situation,
                     the actual value supplied for the parameter is taken from the dynamic context of the relevant function call.</p></note>
                  
               </item>

               <item>
                  <p>
                     <termdef id="dt-default-language" term="default language">
                        <term>Default language.</term>
  This is the natural language used when creating human-readable output
  (for example, by the functions <function>fn:format-date</function> and <function>fn:format-integer</function>)
  if no other language is requested. 
  The value is a language code as defined by the type <code>xs:language</code>.</termdef>
                  </p>
               </item>

               <item>
                  <p>
                     <termdef id="dt-default-calendar" term="default calendar">
                        <term>Default calendar.</term>
    This is the calendar used when formatting dates in human-readable output
    (for example, by the functions <function>fn:format-date</function> and <function>fn:format-dateTime</function>)
    if no other calendar is requested. 
    The value is a string.</termdef>
                  </p>
               </item>

               <item>
                  <p>
                     <termdef id="dt-default-place" term="default place">
                        <term>Default place.</term>
    This is a geographical location used to identify the place where events happened (or will happen) when
    processing dates and times using functions such as <function>fn:format-date</function>, <function>fn:format-dateTime</function>,
     and <function>fn:civil-timezone</function>,
    if no other place is specified. It is used when translating timezone offsets to civil timezone names,
    and when using calendars where the translation from ISO dates/times to a local representation is dependent
    on geographical location. Possible representations of this information are an ISO country code or an
    Olson timezone name, but implementations are free to use other representations from which the above
    information can be derived. The only requirement is that it should uniquely identify a civil timezone,
    which means that country codes for countries with multiple timezones, such as the United States,
    are inadequate.</termdef>
                  </p>
               </item>

               <item>
                  <p>
                     <termdef id="dt-available-docs" term="available documents">
                        <term>Available
    documents.</term> This is a mapping of strings to document nodes.  Each string
    represents the absolute URI of a resource. The document node is the root of a tree that represents that resource 
    using the <termref
                           def="dt-datamodel"
                           >data model</termref>. The document node is returned by the <function>fn:doc</function> 
    function when applied to that URI.</termdef> The set of available documents may be empty.</p>
                  <!--<p>If there are one or more 
    URIs in <termref def="dt-available-docs"
                        >available documents</termref> that map to a document
    node <code>D</code>, then the document-uri property of <code>D</code> must either be absent, or must
    be one of these URIs.</p>
                  <note>
                     <p>This means that given a document node <code>$N</code>, the result of
    <code
                           role="parse-test"
                           >fn:doc(fn:document-uri($N)) is $N</code> will always be <code>true</code>, unless
  <code
                           role="parse-test">fn:document-uri($N)</code> is an empty sequence.</p>
                  </note>-->
               </item>


               <item>
                  <p>
                     <termdef id="dt-available-text-resources" term="available text resources">
                        <term>Available text resources</term>. 
  This is a mapping of strings to text resources. Each string
  represents the absolute URI of a resource. The resource is returned
  by the <function>fn:unparsed-text</function> function when applied to that
  URI.</termdef> The set of available text resources may be empty.</p>
               </item>


               <item>
                  <p>
                     <termdef id="dt-available-collections" term="available item collections">
                        <term>Available
                           collections.</term> This is a mapping of
                         strings to sequences of items. Each string
                         represents the absolute URI of a
                         resource. The sequence of items represents
                         the result of the <function>fn:collection</function>
                         function when that URI is supplied as the
                         argument. </termdef> The set of available
                            collections may be empty.</p>

                  <p>Ideally, for every document node <code>D</code> that is in the target of a 
                     mapping in <termref def="dt-available-collections"/>, or that is the root of a tree containing 
                     such a node, the document-uri property of <code>D</code> should either be absent, 
                     or should be a URI <code>U</code> such that <termref
                        def="dt-available-docs"/> contains a mapping from <code>U</code> to <code>D</code>.

</p>
                  <note>
                     <p>That is to say, the <code>document-uri</code> property of nodes returned
                        by the <function>fn:collection</function> function should be such that
                        calling <function>fn:doc</function> with that URI returns the relevant node.</p>
                     <p>It is not always possible to ensure this, especially in cases where 
                        dereferencing of document or collection URIs is configurable using
                        configuration files or user-supplied resolver code.</p>
                  </note>
               </item>


               <item>
                  <p>
                     <termdef id="dt-default-collection" term="default collection">
                        <term>Default  collection.</term>
    This is the sequence of items  that would result from calling the <function>fn:collection</function> function
    with no arguments.</termdef> The value of <term>default   collection</term> may be initialized by the
    implementation.</p>
               </item>

               <item>
                  <p>
                     <termdef id="dt-available-uri-collections" term="available uri collections">
                        <term>Available
    URI collections.</term> This is a mapping of
    strings to sequences of URIs. The string
    represents the absolute URI of a
    resource which can be interpreted as an aggregation of a number of individual resources each of which
    has its own URI. The sequence of URIs represents
    the result of the <function>fn:uri-collection</function>
    function when that URI is supplied as the
    argument. </termdef> There is no implication that the URIs in this sequence
    can be successfully dereferenced, or that the resources they refer to have any particular media type.</p>
                  <note>
                     <p>An implementation <rfc2119>may</rfc2119> maintain some consistent relationship between the available
    collections and the available URI collections, for example by ensuring that the result of
  <code>fn:uri-collection(X)!fn:doc(.)</code> is the same as the result of <code>fn:collection(X)</code>.
    However, this is not required. The <function>fn:uri-collection</function> function is more 
    general than <function>fn:collection</function> in that <phrase diff="del" at="A">it allows access to resources other 
    than XML documents; at the same time,</phrase> <function>fn:collection</function> allows access to 
    nodes that might lack individual URIs, for example nodes corresponding 
    to XML fragments stored in the rows of a relational database.</p>
                  </note>
               </item>

               <item>
                  <p>
                     <termdef id="dt-default-uri-collection" term="default URI collection">
                        <term>Default URI collection.</term>
    This is the sequence of URIs that would result from calling the <function>fn:uri-collection</function> function
    with no arguments.</termdef> The value of <term>default URI collection</term> may be initialized by the
    implementation.</p>
               </item>

               <item>
                  <p>
                     <termdef id="dt-environment-variables" term="environment variables">
                        <term>Environment variables.</term>
  This is a mapping from names to values. 
    Both the names and the values are strings. The names are compared using an
    <termref
                           def="dt-implementation-defined"
                           >implementation-defined</termref> collation, and are unique under this collation. The set of environment variables is
  <termref
                           def="dt-implementation-defined"
                           >implementation-defined</termref> and <rfc2119>may</rfc2119> be empty.</termdef>
                  </p>
                  <note>
                     <p>A possible implementation is to provide the set of POSIX environment variables (or their equivalent on other
      operating systems) appropriate to the process in which the <phrase
                           role="xquery">query is initiated</phrase>
                        <phrase role="xpath">expression is evaluated</phrase>.</p>
                  </note>
               </item>

            </ulist>
         </div3>
      </div2>

      <div2 id="id-processing-model">
         <head>Processing Model</head>
         
         <changes>
           <change issue="1343" PR="1344" date="2024-09-03">
             The static typing option has been dropped.
           </change>
         </changes>
         
         <p>The semantics of &language; are defined in terms
                         of the <termref
               def="dt-datamodel">data
                         model</termref> and the <termref
               def="dt-expression-context"
            >expression
                         context</termref>.</p>
         <graphic source="procmod-xquery.svg"
            alt="Processing                          Model Overview" role="xquery"/>
         <graphic source="procmod-xpath.svg"
            alt="Processing                          Model Overview" role="xpath"/>
         <p>Figure 1:
                         Processing Model Overview</p>

         <p>Figure 1 provides a schematic overview of the processing steps that
are discussed in detail below. Some of these steps are completely
outside the domain of &language;; in Figure 1, these are depicted
outside the line that represents the boundaries of the language, an
area labeled <term>external processing</term>. The external processing
domain includes generation of <termref
               def="dt-data-model-instance"
               >XDM instances</termref> that represent the data to be queried (see <specref
               ref="id-data-model-generation"/>), schema import processing (see
<specref
               ref="id-schema-import-processing"/>), and serialization<phrase role="xquery"
                  > (see
<specref ref="id-serialization"
               />)</phrase>. The area inside the boundaries of
the language is known as the <phrase
               role="xquery">
               <term>query processing domain</term>
            </phrase><phrase role="xpath">
               <term>XPath processing domain</term>
            </phrase>, which includes the static
analysis and dynamic evaluation phases (see <specref
               ref="id-expression-processing"/>).  Consistency constraints on the
<phrase
               role="xquery">query</phrase>
            <phrase role="xpath">XPath</phrase> processing domain are defined in <specref
               ref="id-consistency-constraints"/>.</p>


         <div3 id="id-data-model-generation">
            <head>Data Model Generation</head>

            <p>The input data for <phrase role="xquery">a query</phrase>
               <phrase role="xpath"
                  >an expression</phrase> must be represented as one or more <termref
                  def="dt-data-model-instance"
                  >XDM instances</termref>. This process occurs outside
the domain of &language;, which is why Figure 1 represents it in the
external processing domain.</p>
            
            <p>In many cases the input data might originate as XML.
               Here are some steps by which an XML
document might be converted to an <termref
                  def="dt-data-model-instance">XDM instance</termref>:</p>

            <olist>

               <item>
                  <p id="DM1">A document may be parsed using an XML parser that
generates an <term>XML Information Set</term> (see <bibref
                        ref="XINFO"
                        />). The parsed document may then be validated against one
or more schemas. This process, which is described in <loc
                        href="http://www.w3.org/TR/xmlschema-1/"
                        >[XML Schema 1.0 Part 1]</loc> or
<loc
                        href="http://www.w3.org/TR/xmlschema11-1/"
                        >[XML Schema 1.1 Part 1]</loc>, results in an abstract information structure called
the <term>Post-Schema Validation Infoset</term> (PSVI). If a document
has no associated schema, its Information Set is preserved. (See DM1
in Figure 1)</p>
               </item>

               <item>
                  <p id="DM2">The Information Set or PSVI may be
transformed into an <termref
                        def="dt-data-model-instance"
                        >XDM instance</termref>
by a process described in <bibref
                        ref="xpath-datamodel-40"/>. (See DM2 in
Figure 1)</p>
               </item>
            </olist>
            <p id="DM3">The above steps provide an example of how an <termref def="dt-data-model-instance"
                  >XDM instance</termref> might be constructed. An XDM instance might
also be constructed in some other way (see DM3 in Figure 1), for example it might be 
synthesized directly from a relational database, or
derived by parsing a JSON text or a CSV file. Whatever the origin, &language; is defined in terms
of the <termref def="dt-datamodel">data model</termref>,
but it does not place any constraints on how XDM instances are constructed.</p>
            
            <p>The remainder of this section is concerned with the common case where XML data is being processed.</p>

            <p>
               <termdef term="type annotation" id="dt-type-annotation"
                     >Each element node and attribute node in an <termref
                     def="dt-data-model-instance"
                     >XDM instance</termref> has a <term>type annotation</term> (described in <xspecref
                     spec="DM40" ref="types"
                  />). 
The type annotation of a node is a reference to a <termref def="dt-schema-type"/>. 
</termdef>  The <code>type-name</code> of a node is the name of the type referenced by its <termref
                  def="dt-type-annotation">type annotation</termref> (but note that the
               type annotation can be a reference to an anonymous type). 
If the <termref
                  def="dt-data-model-instance"
                  >XDM instance</termref> was derived from a validated XML document as described in <xspecref
                  spec="DM40" ref="const-psvi"
               />, the type annotations of the element and attribute nodes are derived from schema
validation. &language; does
not provide a way to directly access the type annotation of an element
or attribute node.</p>
            <p>The value of an attribute is represented directly within the
attribute node. An attribute node whose type is unknown (such as might
occur in a schemaless document) is given the <termref
                  def="dt-type-annotation">type annotation</termref>
               <code>xs:untypedAtomic</code>.</p>

            <p>The value of an element is represented by the children of the
element node, which may include text nodes and other element
nodes. The <termref
                  def="dt-type-annotation"
                  >type annotation</termref> of an element node indicates how the values in
its child text nodes are to be interpreted. An element that has not been validated (such as might occur in a schemaless document) is annotated
with the <termref def="dt-schema-type"/> <code>xs:untyped</code>. An element that has been validated and found to be partially valid is annotated with the schema type <code>xs:anyType</code>. If an element node is annotated as <code>xs:untyped</code>, all its descendant element nodes are also annotated as <code>xs:untyped</code>. However, if an element node is annotated as <code>xs:anyType</code>, some of its descendant element nodes may have a more specific <termref
                  def="dt-type-annotation">type annotation</termref>.</p>




         </div3>

         <div3 id="id-schema-import-processing">
            <head>Schema Import Processing</head>
            <p role="xquery">The <termref def="dt-issd"
                  >in-scope
schema definitions</termref> in the <termref def="dt-static-context"
                  >static context</termref> may be extracted from
actual XML schemas (see step SI1 in Figure 1) or may be
generated by some other mechanism (see step SI2 in Figure 1). In
either case, the result must satisfy the consistency constraints
defined in <specref
                  ref="id-consistency-constraints"/>.</p>

            <p role="xpath">The <termref def="dt-issd"
                  >in-scope schema
definitions</termref> in the <termref def="dt-static-context"
                  >static
context</termref> are provided by the host language (see step SI1 in
Figure 1) and must satisfy the consistency constraints defined in
<specref
                  ref="id-consistency-constraints"/>.

</p>
         </div3>
         <div3 id="id-expression-processing">
            <head>Expression
Processing</head>
            <p>&language; defines two phases of processing called
the <termref
                  def="dt-static-analysis">static analysis phase</termref>
and the <termref
                  def="dt-dynamic-evaluation"
                  >dynamic evaluation
phase</termref> (see Figure 1).  During the static analysis phase, <termref
                  def="dt-static-error">static errors</termref>,  <termref def="dt-dynamic-error"
                  >dynamic errors</termref>, or <termref def="dt-type-error"
                  >type errors</termref> may be raised. During the dynamic evaluation phase, only <termref
                  def="dt-dynamic-error">dynamic errors</termref> or <termref def="dt-type-error"
                  >type errors</termref> may be raised. These kinds of errors are defined in <specref
                  ref="id-kinds-of-errors"/>.  </p>
            <p>Within each phase, an implementation is free to use any
strategy or algorithm whose result conforms to the
specifications in this document.</p>

            <div4 id="id-static-analysis">
               <head>Static Analysis Phase</head>
               <p>
                  <termdef id="dt-static-analysis" term="static analysis phase"
                        >The
<term>static analysis phase</term> depends on the expression itself
and on the <termref
                        def="dt-static-context"
                        >static context</termref>. The <term>static analysis phase</term> does
not depend on input data (other than schemas).</termdef>
               </p>
               <p id="SQ1234">During the static analysis phase, the <phrase role="xquery">query</phrase>
                  <phrase role="xpath"
                     >XPath expression</phrase> is typically parsed into an
internal representation called the <term>operation tree</term> (step
SQ1 in Figure 1).  A parse error is raised as a <termref
                     def="dt-static-error">static error</termref>
                  <errorref class="ST" code="0003"/>. The <termref def="dt-static-context"
                     >static context</termref> is initialized by the implementation (step SQ2). <phrase
                     role="xquery">The <termref def="dt-static-context"
                        >static context</termref> is then changed and augmented based on information in the  <term>prolog</term> (step SQ3). If the
<termref
                        def="dt-schema-aware-feature"
                        >Schema Aware Feature</termref>
is supported, the <termref def="dt-issd"
                        >in-scope schema definitions</termref> are populated with information from imported schemas. If the <termref
                        def="dt-module-feature"
                     >Module
Feature</termref> is supported, the static context is extended with function
declarations and variable declarations from imported modules.</phrase> The <termref
                     def="dt-static-context"
                     >static context</termref> is used to resolve schema type names, function names, namespace prefixes, and variable names (step
SQ4).
If a name of one of these kinds in the <term>operation tree</term> is
not found in the <termref
                     def="dt-static-context">static context</termref>, a <termref
                     def="dt-static-error">static error</termref> (<errorref class="ST" code="0008"
                     /> or <errorref class="ST" code="0017"
                     />) is raised (however, see exceptions to this rule in <specref
                     ref="id-element-test"/> and <specref ref="id-attribute-test"/>.)</p>

               <p id="SQ5">The <term>operation tree</term> is then typically
normalized by making explicit the implicit operations
such as <termref
                     def="dt-atomization">atomization</termref> and extraction of <termref
                     def="dt-ebv">effective boolean values</termref> (step SQ5).</p>

               <p>During the <termref def="dt-static-analysis"
                     >static analysis
phase</termref>, a processor may perform type analysis. The
effect of type analysis is to assign a <termref
                     def="dt-static-type"
                     >static type</termref> to each expression in the
operation tree. <termdef
                     id="dt-static-type" term="static type"
                     >The
<term>static type</term> of an expression is the best inference that
the processor is able to make statically about the type of the result
of the expression.</termdef> This specification does not define the
rules for type analysis nor the static types that are assigned to
particular expressions: the only constraint is that the inferred type
must match all possible values that the expression is capable of
returning.</p>

               <p>Examples of inferred static types might be:</p>

               <ulist>
                  <item>
                     <p>For the expression <code>concat(a,b)</code> the inferred static type is <code>xs:string</code>
                     </p>
                  </item>

                  <item>
                     <p>For the expression <code>$a = $v</code> the inferred static type is <code>xs:boolean</code>
                     </p>
                  </item>


                  <item>
                     <p>For the expression <code>$s[exp]</code> the inferred static
    type has the same item type as the static type of <code>$s</code>,
    but a cardinality that allows the empty sequence even if the
    static type of <code>$s</code> does not allow an empty
    sequence.</p>
                  </item>


                  <item>
                     <p>The inferred static type of the expression <code>data($x)</code> (whether written
    explicitly or inserted into the operation tree in places where atomization
    is implicit) depends on the inferred static type of <code>$x</code>: for example, if <code>$x</code>
    has type <code>element(*, xs:integer)</code> then <code>data($x)</code> has static type <code>xs:integer</code>.</p>
                  </item>
               </ulist>


               <p>In XQuery 1.0 and XPath 2.0, rules for static type inferencing were published
normatively in <bibref
                     ref="xquery-semantics"
                  />, but implementations were allowed to
refine these rules to infer a more precise type where possible. In
subsequent versions, the rules for static type inferencing are entirely implementation-dependent.</p>

               <p>Every kind of expression also imposes requirements on the type of its
operands. For example, with the expression <code>substring($a, $b, $c)</code>, <code>$a</code> must be
of type <code>xs:string</code> (or something that can be converted to <code>xs:string</code> by the
function calling rules), while <code>$b</code> and <code>$c</code> must be numeric.</p>

               

               <p>A processor may raise a type
                  error during static analysis if the inferred static type of an
                     expression has no overlap (intersection) with the required type, and cannot be converted
                     to the required type using the <termref def="dt-coercion-rules"/>. For example,
                     given the call <code>fn:upper-case($s)</code>, the processor may raise an error if the
                     declared or inferred type of <code>$s</code> is <code>xs:integer</code>, 
                     but not if it is <code>xs:anyAtomicType</code>.
                  </p>
               
               <p>In addition, type analysis may conclude that an expression is <code>implausible</code>.
               Implausible expressions may be considered erroneous unless such checks have been disabled.
               This topic is described further in <specref ref="id-implausible-expressions"/>.</p>
                
               
               <p>Alternatively, the processor
                  <rfc2119>may</rfc2119> defer all type checking until the dynamic evaluation phase.</p>


            </div4>
            <div4 id="id-dynamic-evaluation">
               <head>Dynamic Evaluation Phase</head>
               <p id="DQ12345">
                  <termdef id="dt-dynamic-evaluation" term="dynamic evaluation phase"
                        >The <term>dynamic evaluation phase</term> is the phase during which the value of an expression is computed.</termdef> It is dependent on successful completion of the <termref
                     def="dt-static-analysis">static analysis phase</termref>.</p>
               <p>The dynamic evaluation phase can occur only if no errors were detected during the <termref
                     def="dt-static-analysis">static analysis phase</termref>.</p>
               <p>The dynamic evaluation phase depends on the <term>operation
tree</term> of the expression being evaluated (step DQ1), on the input
data (step DQ4), and on the <termref
                     def="dt-dynamic-context"
                     >dynamic context</termref> (step DQ5), which in turn draws information from  the external environment (step DQ3) and the <termref
                     def="dt-static-context"
                     >static context</termref> (step DQ2). The dynamic evaluation phase may create new data-model values (step DQ4) and it may extend the <termref
                     def="dt-dynamic-context"
                  >dynamic context</termref> (step DQ5)&mdash;for example, by binding values to variables.</p>

               <p diff="chg" at="B">
                  <termdef term="dynamic type" id="dt-dynamic-type">
                  Every value matches one or more <termref def="dt-sequence-type">sequence types</termref>. 
                     A value is said to have a <term>dynamic type</term> <var>T</var> if it matches (or <term>is an instance of</term>) 
                     the sequence type <var>T</var>.</termdef></p>
               <p diff="chg" at="B">In many cases (but not all), one of the dynamic types that a value matches will 
                     be a subtype of all the others, in which case it makes sense to speak of “the dynamic type” of the value as 
                     meaning this single most specific type. In other cases (examples are 
                     <xtermref spec="DM40" ref="dt-empty-map">empty maps</xtermref> and 
                     <xtermref spec="DM40" ref="dt-empty-array">empty arrays</xtermref>) none of the 
                     dynamic types is more specific than all the others.</p>
               <note diff="chg" at="B"><p>An atomic item has a <termref def="dt-type-annotation"/> which will always be
                  a <termref def="dt-subtype"/> of all the other types that it matches; we can therefore refer to 
                  this as the <termref def="dt-dynamic-type"/> of the atomic item without ambiguity.</p></note>
               
               <p diff="chg" at="B">A value may match a dynamic type that is more specific than the <termref def="dt-static-type"/> 
                  of the expression that computed it (for example, the static type of an expression might be <code>xs:integer*</code>, 
                  denoting a sequence of zero or more integers, but at evaluation time its value may be an instance of <code>xs:integer</code>, 
                  denoting exactly one integer).
               </p>
               
               <p diff="chg" at="B">If an operand of an expression does not have a <termref def="dt-dynamic-type"
                     >dynamic type</termref> that is a <termref def="dt-subtype"/> of the <termref def="dt-static-type"/>
                  required for that operand, a <termref def="dt-type-error">type error</termref> is
                  raised <errorref class="TY" code="0004"/>.</p>
               <p>Even though static typing can catch many <termref def="dt-type-error"
                     >type errors</termref> before an expression is executed, it is possible for an expression to raise an error during evaluation that was not detected by static  analysis. For example, an expression may contain a cast of a string into an integer, which is statically valid. However, if the actual value of the string at run time cannot be cast into an integer, a <termref
                     def="dt-dynamic-error"
                     >dynamic error</termref> will result. Similarly, an expression may apply an arithmetic operator to a value whose <termref
                     def="dt-static-type"
                     >static type</termref> is <code>xs:untypedAtomic</code>. This is not a <termref
                     def="dt-static-error"
                     >static error</termref>, but at run time, if the value cannot be successfully cast to a <termref
                     def="dt-numeric">numeric</termref> type, a <termref def="dt-dynamic-error"
                     >dynamic error</termref> will be raised.</p>
               
            </div4>
         </div3>
         
         <div3 id="id-input-sources">
            <head>Input Sources</head>
            
            <p>&language; has a set of functions that provide access to XML documents (<function>fn:doc</function>, <function>fn:doc-available</function>), collections (<function>fn:collection</function>, <function>fn:uri-collection</function>), text files (<function>fn:unparsed-text</function>, <function>fn:unparsed-text-lines</function>, <function>fn:unparsed-text-available</function>), and environment variables (<function>fn:environment-variable</function>, <function>fn:available-environment-variables</function>).  These functions are defined in <xspecref
               spec="FO40" ref="fns-on-docs"/>.</p>
            
            
            
            <p>An expression can access input data either by calling one
               of these input functions or by referencing some part of the
               <termref
                  def="dt-dynamic-context"
                  >dynamic context</termref> that is initialized by the external
               environment, such as a <termref
                  def="dt-variable-values">variable</termref> or
               <termref def="dt-context-value"/>.</p>
            
            
            
            <note>
               <p>The <loc href="http://expath.org"
                     >EXPath Community Group</loc> has developed a <loc
                     href="http://expath.org/spec/file"
                  >File Module</loc>, which some implementations use to perform file system related operations 
                  such as reading or writing files and directories. Multiple files can be read or written 
                  from a single query.</p>
            </note>
            
            
            
            
         </div3>
         

         <div3 id="id-serialization">
            <head>Serialization</head>

            <p>
               <termdef id="dt-serialization" term="serialization">
                  <term>Serialization</term> is the process of
converting an <termref
                     def="dt-data-model-instance"
                     >XDM
instance</termref> to a sequence of octets (step DM4 in Figure 1.),
as described in <bibref
                     ref="xslt-xquery-serialization-40"/>.</termdef>
            </p>
            
            <p role="xquery">Although serialization of XQuery results is outside
            the scope of this specification, syntax is provided in the query
            prolog to enable default serialization options to be defined.
            See <specref ref="id-output-declarations"/>.</p>
            
            <p role="xquery">Serialization can also be invoked from within a query
               by calling the <function>fn:serialize</function> function.</p>

            <note>
               <p>This definition of serialization is the definition
used in this specification. Any form of serialization that is
not based on <bibref
                     ref="xslt-xquery-serialization-40"
                  /> is outside
the scope of the &language; specification.</p>
            </note>

            <p role="xpath">Serialization is outside the scope of the XPath specification, except
               to the extent that there is a function <function>fn:serialize</function> that enables
               serialization to be invoked.</p>

            

            <p role="xquery"
                  >An XQuery implementation is not required to provide a
serialization interface. For example, an implementation may 
provide only a DOM interface (see <bibref
                  ref="DOM"/>) or an interface
based on an event stream. </p>



         </div3>



         <div3 id="id-consistency-constraints">

            <head>Consistency Constraints</head>
            <p>In order for &language; to
be well defined, the input <termref
                  def="dt-data-model-instance">XDM instances</termref>, the <termref
                  def="dt-static-context">static context</termref>, and the <termref
                  def="dt-dynamic-context"
                  >dynamic context</termref> must be mutually
consistent. The consistency constraints listed below are prerequisites
for correct functioning of an &language; implementation. Enforcement
of these consistency constraints is beyond the scope of this
specification. This specification does not
define the result of  <phrase
                  role="xquery">a query</phrase>
               <phrase role="xpath"
               >an expression</phrase> under any condition in which one
or more of these constraints is not satisfied.</p>

            <ulist>

               <item>
                  <p>For every  node that has a type annotation, if that type annotation is found in the <termref
                        def="dt-issd"
                     >in-scope schema definitions</termref> (ISSD), then its definition in the ISSD must be 
                     <phrase diff="chg" at="Issue451"><xtermref ref="dt-schema-compatible" spec="DM40">compatible</xtermref></phrase> with its definition 
                     in the <xtermref ref="dt-schema" spec="DM40">schema</xtermref> that was used to validate the node. 
                  </p>
               </item>


               <item>
                  <p>Every element name, attribute name, or schema type name referenced in <termref
                        def="dt-in-scope-variables"/> or <termref def="dt-statically-known-function-definitions"/>
                         must be in the <termref def="dt-issd"
                        >in-scope schema definitions</termref>, unless it is an element name referenced as part of an <nt
                        def="ElementTest"
                        >ElementTest</nt> or an attribute name referenced as part of an <nt
                        def="AttributeTest">AttributeTest</nt>.</p>
               </item>

               <item>
                  <p>Any reference to a global element, attribute, or type name in
the <termref
                        def="dt-issd"
                        >in-scope schema definitions</termref> must have a corresponding element, attribute or type
definition in the <termref
                        def="dt-issd">in-scope schema definitions</termref>.</p>
               </item>




               


               

               

               


               <item>
                  <p>For each (variable, type) pair in <termref def="dt-in-scope-variables"
                        >in-scope variables</termref> and the corresponding (variable, value) pair in <termref
                        def="dt-variable-values"
                        >variable values</termref> such that the variable names are equal, the value must match the type, using the matching rules in  <specref
                        ref="id-sequencetype-matching"/>.</p>
               </item>

               <item role="xquery">
                  <p>For each variable declared as external, if the variable declaration does
not include a <nt
                        def="VarDefaultValue"
                     >VarDefaultValue</nt>, the external environment must provide a value
for the variable.</p>

                  <p>For each variable declared as external for which the external environment
provides a value: If the variable declaration includes a declared type,
the value provided by the external environment must match the
declared type, using the matching rules in  <specref
                        ref="id-sequencetype-matching"
                     />. If the variable declaration does not include a declared type, the
external environment must provide a type to accompany the value provided, using the same matching rules.</p>
               </item>

               <item role="xquery">
                  <p>For each function declared as external: the function’s <termref def="dt-function-item"
                        >implementation</termref> must either return a value that matches the declared result type,
using the matching rules in <specref
                        ref="id-sequencetype-matching"/>, or raise an
<termref
                        def="dt-implementation-defined">implementation-defined</termref> error.</p>
               </item>

               <item role="xquery">
                  <p>For a given query, define a <term>participating ISSD</term> as the <termref
                        def="dt-issd"
                        >in-scope schema definitions</termref> of a module that is used in evaluating the query.
                     All participating ISSDs must be <xtermref spec="DM40" ref="dt-schema-compatible">compatible</xtermref>.</p>
                  
                  <note diff="add" at="Issue451">
                     <p>This rule ensures that when one module <var>M</var> imports schema <var>X</var>, and another
                     module <var>N</var> imports schema <var>Y</var>, then an element node validated
                        against type <var>T</var> in <var>M</var> can be safely passed to a function
                        in <var>N</var> that expects an argument of type <code>element(*, T)</code>.
                     The requirement for compatibility does not guarantee that in all cases, validation
                     of an element against the two different schemas will produce exactly the same outcome
                     (there may be differences, for example, in the definition of substitution groups
                     or wildcards), and the processor must allow for such differences.</p>
                  </note>
  

               </item>

               <item>
                  <p>In the <termref def="dt-static-namespaces"
                        >statically known namespaces</termref>, the prefix <code>xml</code> must not be bound to any namespace URI other than <code>http://www.w3.org/XML/1998/namespace</code>, and no prefix other than <code>xml</code> may be bound to this namespace URI.
The prefix <code>xmlns</code> must not be bound to any namespace URI, and no prefix may be bound to the namespace URI <code>http://www.w3.org/2000/xmlns/</code>.</p>
               </item>



            </ulist>
         </div3>
      </div2>

      <div2 id="errors">
         <head>Error Handling</head>

         <div3 id="id-kinds-of-errors">
            <head>Kinds of Errors</head>
            <p>
As described in <specref ref="id-expression-processing"
                  />, &language;
defines a <termref def="dt-static-analysis"
                  >static analysis phase</termref>, which does not depend on input
data, and a <termref
                  def="dt-dynamic-evaluation"
               >dynamic evaluation
phase</termref>, which does depend on input
data.  Errors may be raised during each phase.</p>

            <p>
               <termdef id="dt-static-error" term="static error"
                     >
An error that can be detected during the static analysis phase, and is not a type error, is a <term>static error</term>.</termdef> A syntax error is an example of a <termref
                  def="dt-static-error">static error</termref>.</p>
            <p>
               <termdef id="dt-dynamic-error" term="dynamic error"
                     >A <term>dynamic
error</term> is an error that
must be detected during the dynamic evaluation phase and may be detected
during the static analysis phase.</termdef>
Numeric overflow is an example of a <termref
                     def="dt-dynamic-error">dynamic error</termref>.
            </p>
            <p>
               <termdef id="dt-type-error" term="type error"
                     >A <term>type
error</term> may be raised during the static analysis phase or the dynamic evaluation phase.
During the static analysis phase, a <termref
                     def="dt-type-error">type error</termref> occurs
when the <termref
                     def="dt-static-type"
                     >static type</termref> of an expression does not match the expected type
of the context in which the expression occurs.
During the dynamic evaluation phase, a <termref
                     def="dt-type-error">type error</termref> occurs
when the <termref
                     def="dt-dynamic-type"
                  >dynamic type</termref> of a value does not match the expected type of
the context in which the value occurs.</termdef>
            </p>

            <p>The outcome of the <termref def="dt-static-analysis"
                  >static analysis
phase</termref> is either success or one or more <termref
                  def="dt-type-error">type errors</termref>, <termref def="dt-static-error"
                  >static errors</termref>, or statically detected <termref def="dt-dynamic-error"
                  >dynamic errors</termref>. The result of the <termref def="dt-dynamic-evaluation"
                  >dynamic evaluation
phase</termref> is either a result value, a <termref
                  def="dt-type-error">type
error</termref>, or a <termref def="dt-dynamic-error"
                  >dynamic error</termref>.</p>
            <p>If more than one error is present, or if an error condition comes within the
scope of more than one error defined in this specification, then any non-empty
subset of these errors may be reported.</p>

            
            <p>If an implementation can determine during the
<termref
                  def="dt-static-analysis">static
analysis phase</termref> that <phrase
                  role="xquery">a <nt def="QueryBody">QueryBody</nt>
               </phrase>
               <phrase role="xpath"
                  >an XPath expression</phrase>, if evaluated, would necessarily
raise a <termref
                  def="dt-dynamic-error"
                  >dynamic error</termref> or that an expression, if evaluated, would necessarily raise a <termref
                  def="dt-type-error"
                  >type error</termref>, the implementation may (but is not required to) report that
error during the <termref
                  def="dt-static-analysis">static
analysis phase</termref>.</p>

            <p>An implementation can raise a <termref def="dt-dynamic-error"
                  >dynamic error</termref> for <phrase role="xquery">a <nt def="QueryBody"
                     >QueryBody</nt>
               </phrase>
               <phrase role="xpath">an XPath expression</phrase> statically only if the <phrase
                  role="xquery">query</phrase>
               <phrase role="xpath"
               >expression</phrase> can never execute without raising that error, as in the following example:</p>

            <eg role="parse-test"><![CDATA[
error()
]]></eg>

            <p>The following example contains a type error, which can be reported statically even if the implementation can not prove that the expression will actually be evaluated.</p>

            <eg role="parse-test"><![CDATA[
if (empty($arg))
then "cat" * 2
else 0
]]></eg>


            <p>
               <termdef id="dt-warning" term="warning">In addition to <termref def="dt-static-error"
                     >static errors</termref>, <termref def="dt-dynamic-error"
                     >dynamic errors</termref>, and <termref def="dt-type-error"
                     >type
errors</termref>, an &language;
implementation may raise <term>warnings</term>, either during the <termref
                     def="dt-static-analysis">static analysis
phase</termref> or the
<termref
                     def="dt-dynamic-evaluation"
                     >dynamic evaluation
phase</termref>. The circumstances in which warnings are raised, and
the ways in which warnings are handled, are <termref
                     def="dt-implementation-defined">implementation-defined</termref>.</termdef>
            </p>
            <p>In addition to the errors defined in this
specification, an implementation may raise a <termref
                  def="dt-dynamic-error"
                  >dynamic error</termref> for a reason beyond the scope of this specification. For
example, limitations may exist on the maximum
numbers or sizes of various objects. 
<phrase
                  id="id-error-limit-exceeded"
                     >An error must be raised if such a limitation is exceeded  <errorref class="DY"
                     code="0130"/>.</phrase>
            </p>
         </div3>
         <div3 id="id-identifying-errors">
            <head>Identifying and Reporting Errors</head>
            <p>The errors defined in this specification are identified by QNames that have the form <code
                  role="xpath">err:XPYYnnnn</code>
               <code role="xquery">err:XXYYnnnn</code>, where:</p>
            <ulist>

               <item>
                  <p>
                     <code>err</code> denotes the namespace for XPath and XQuery errors, <code>http://www.w3.org/2005/xqt-errors</code>. This binding of the namespace prefix <code>err</code> is used for convenience in this document, and is not normative.</p>
               </item>

               <item role="xpath">
                  <p>
                     <code>XP</code> identifies the error as an XPath error (some errors, originally defined by XQuery and later added to XPath, use the code <code>XQ</code> instead).</p>
               </item>

               <item role="xquery">
                  <p>
                     <code>XX</code> denotes the language in which the error is defined, using the following encoding:</p>

                  <ulist role="xquery">

                     <item>
                        <p>
                           <code>XP</code> denotes an error defined by XPath. Such an error may also occur XQuery since XQuery  includes XPath as a subset.</p>
                     </item>

                     <item>
                        <p>
                           <code>XQ</code> denotes an error defined by XQuery (or an error originally defined by XQuery and later added to XPath).</p>
                     </item>
                  </ulist>
               </item>

               <item>
                  <p>
                     <code>YY</code> denotes the error category, using the following encoding:</p>
                  <ulist>

                     <item>
                        <p>
                           <code>ST</code> denotes a static error.</p>
                     </item>

                     <item>
                        <p>
                           <code>DY</code> denotes a dynamic error.</p>
                     </item>

                     <item>
                        <p>
                           <code>TY</code> denotes a type error.</p>
                     </item>
                  </ulist>
               </item>

               <item>
                  <p>
                     <code>nnnn</code> is a unique numeric code.</p>
               </item>
            </ulist>
            <note>
               <p>The namespace URI for  XPath and XQuery errors is not expected to
change from one version of <phrase
                     role="xquery">XQuery</phrase>
                  <phrase role="xpath"
                  >XPath</phrase> to another. However, the contents of this
namespace may be extended to include additional error definitions.</p>
            </note>
            <p>The method by which an &language; processor reports error information to the external environment is <termref
                  def="dt-implementation-defined">implementation-defined</termref>.</p>
            <p>An error can be represented by a URI reference that is derived from the error QName as follows: an error with namespace URI <emph>
                  <code>NS</code>
               </emph> and local part <emph>
                  <code>LP</code>
               </emph> can be represented as the URI reference <emph>
                  <code>NS</code>
               </emph>
               <code>#</code>
               <emph>
                  <code>LP</code>
               </emph>. For example, an error whose QName is <code>err:XPST0017</code> could be represented as <code>http://www.w3.org/2005/xqt-errors#XPST0017</code>.</p>
            <note>
               <p>Along with a code identifying an error, implementations may wish to return additional information, such
as the location of the error or the processing phase in which it was detected. If an implementation chooses to do so, then the mechanism that
it uses to return this information is <termref
                     def="dt-implementation-defined">implementation-defined</termref>.</p>
            </note>
         </div3>

         <div3 id="id-handling-dynamic">
            <head>Handling Dynamic Errors</head>
            <p>Except as noted in this document, if any operand of an expression
raises a <termref
                  def="dt-dynamic-error"
                  >dynamic error</termref>, the expression also raises a <termref
                  def="dt-dynamic-error"
                  >dynamic error</termref>.
If an expression can validly return a value or raise a dynamic
error, the implementation may choose to return the value or raise
the dynamic error (see <specref
                  ref="id-errors-and-opt"
                  />).  For example, the logical expression
<code>expr1 and expr2</code> may return the value <code>false</code>
if either operand returns <code>false</code>,
or may raise a dynamic error if either operand raises a dynamic
error.</p>
            <p> If more than one operand of an expression raises
an error, the
implementation may choose which error is raised by the expression.
For example, in this expression:

</p>
            <eg role="parse-test"><![CDATA[($x div $y) + xs:decimal($z)]]></eg>
            <p>

both the sub-expressions <code role="parse-test">($x div $y)</code> and <code
                  role="parse-test"
                  >xs:decimal($z)</code> may
raise an error.  The
implementation may choose which error is raised by the <code>+</code>
expression.  Once one operand raises an error, the implementation is
not required, but is permitted, to evaluate any other operands.</p>

            <p>
               <termdef id="dt-error-value" term="error value"
                     >In addition to its identifying QName, a dynamic error may also carry a descriptive string and one or more additional values called <term>error values</term>.</termdef> An implementation may provide a mechanism whereby an application-defined error handler can process error values and produce diagnostic messages. 
  <phrase role="xquery">XQuery 3.1 provides standard error handling via <xspecref
                  spec="XQ40" ref="id-try-catch"
               />.</phrase>
  <phrase role="xpath">The host language may also provide error handling mechanisms.</phrase>
</p>

            <p>A dynamic error may be raised by a <termref def="dt-system-function"
                  >system
function</termref> or operator.  For example,
the <code>div</code> operator raises an error if its operands are <code>xs:decimal</code> values and its second operand
is equal to zero. Errors raised by system functions and operators are defined in <bibref
                  ref="xpath-functions-40"/> or the host language.</p>

            <p>A dynamic error can also be raised explicitly by calling the
<function>fn:error</function> function, which always raises a dynamic error and never
returns a value.  This function is defined in <xspecref
                  spec="FO40" ref="func-error"
                  />. For example, the following
function call raises a dynamic
error, providing a QName that identifies the error, a descriptive string, and a diagnostic value (assuming that the prefix <code>app</code> is bound to a namespace containing application-defined error codes):</p>

            <eg role="parse-test"
               ><![CDATA[error(xs:QName("app:err057"), "Unexpected value", string($v))]]></eg>

         </div3>
         <div3 id="id-errors-and-opt">
            <head>Errors and
      Optimization</head>
            <p>Because different implementations may
      choose to evaluate or optimize an expression in different ways,
      certain aspects of raising <termref
                  def="dt-dynamic-error">dynamic errors</termref> are <termref
                  def="dt-implementation-dependent"
               >implementation-dependent</termref>, as described in this section.</p>
            <p>An implementation is always free to evaluate the operands of an operator in any order.</p>
            <p>In some cases,  a processor can determine the result of an expression without accessing all the data that would be implied by the formal expression semantics. For example, the formal description of <termref
                  def="dt-filter-expression">filter expressions</termref> suggests that <code
                  role="parse-test"
                  >$s[1]</code> should be evaluated by examining all the items in sequence <code>$s</code>, and selecting all those that satisfy the predicate <code
                  role="parse-test"
                  >position()=1</code>. In practice, many implementations will recognize that they can evaluate this expression by taking the first item in the sequence and then exiting. If <code>$s</code> is defined by an expression such as <code
                  role="parse-test"
                  >//book[author eq 'Berners-Lee']</code>, then this strategy may avoid a complete scan of a large document and may therefore greatly improve performance. However, a consequence of this strategy is that a dynamic error or type error that would be detected if the expression semantics were followed literally might not be detected at all if the evaluation exits early. In this example, such an error might occur if there is a <code>book</code> element in the input data with more than one <code>author</code> subelement.</p>
            <p>The extent to which a processor may optimize its access to data, at the cost of not raising errors, is defined by the following rules.</p>
            <p>Consider an expression <emph>Q</emph> that has an operand (sub-expression) <emph>E</emph>. In general the value of <emph>E</emph> is a sequence. At an intermediate stage during evaluation of the sequence, some of its items will be known and others will be unknown. If, at such an intermediate stage of evaluation, a processor is able to establish that there are only two possible outcomes of evaluating <emph>Q</emph>, namely the value <emph>V</emph> or an error, then the processor may deliver the result <emph>V</emph> without evaluating further items in the operand <emph>E</emph>. For this purpose, two values are considered to represent the same outcome if their items are pairwise the same, where nodes are the same if they have the same identity, and values are the same if they are equal and have exactly the same type.</p>
            <p>There is an exception to this rule: If a processor evaluates an operand <emph>E</emph> (wholly or in part), then it  is required to establish that the actual value of the operand <emph>E</emph> does not violate any constraints on its cardinality. For example, the expression <code
                  role="parse-test"
                  >$e eq 0</code> results in a type error if the value of <code>$e</code> contains two or more items. A processor is not allowed to decide, after evaluating the first item in the value of <code>$e</code> and finding it equal to zero, that the only possible outcomes are the value <code>true</code> or a type error caused by the cardinality violation. It must establish that the value of <code>$e</code> contains no more than one item.</p>
            <p>These rules apply to all the operands of an expression considered in combination: thus if an expression has two operands <emph>E1</emph> and <emph>E2</emph>, it may be evaluated using any samples of the respective sequences that satisfy the above rules.</p>
            <p>The rules cascade: if <emph>A</emph> is an operand of <emph>B</emph> and <emph>B</emph> is an operand of <emph>C</emph>, then the processor needs to evaluate only a sufficient sample of <emph>B</emph> to determine the value of <emph>C</emph>, and needs to evaluate only a sufficient sample of <emph>A</emph> to determine this sample of <emph>B</emph>.</p>
            <p>The effect of these rules is that the processor is free to stop examining further items in a sequence as soon as it can establish that further items would not affect the result except possibly by causing an error. For example, the processor may return <code>true</code> as the result of the expression <code
                  role="parse-test"
               >S1 = S2</code> as soon as it finds a pair of equal values from the two sequences.</p>
            <p>Another consequence of these rules is that where none of the items in a sequence contributes to the result of an expression, the processor is not obliged to evaluate any part of the sequence. Again, however, the processor cannot dispense with a required cardinality check: if an empty sequence is not permitted in the relevant context, then the processor must ensure that the operand is not an empty sequence.</p>
            <p>Examples:</p>


            <ulist>

               <item>
                  <p>If an implementation can find (for example, by using an index) that at
least one item returned by <code>$expr1</code> in the following example has the value <code>47</code>, it is allowed to
return <code>true</code> as the result of the <code>some</code> expression, without searching for
another item returned by <code>$expr1</code> that would raise an error if it were evaluated.
</p>
                  <eg role="parse-test"><![CDATA[some $x in $expr1 satisfies $x = 47]]></eg>
               </item>

               <item>
                  <p>In the following example, if an implementation can find (for example, by using an index) the
<code>product</code> element-nodes that have an <code>id</code> child with the value <code>47</code>, it is allowed to return these nodes as the
result of the <termref
                        def="dt-path-expression"
                        >path expression</termref>, without searching for another <code>product</code> node that
would raise an error because it has an <code>id</code> child whose value is not an integer.</p>
                  <eg role="parse-test"><![CDATA[//product[id = 47]]]></eg>
               </item>
            </ulist>

            <!-- <change diff="chg" at="XQ.E4 and XP.E4"> -->
            <p>For a variety of reasons, including optimization, implementations
          may rewrite expressions into a different
          form. There are a number of rules that limit the extent of this freedom:
          </p>
            <ulist>
               <item>
                  <p>
                Other than the raising or not raising of errors, the result
                of evaluating a rewritten expression must
                conform to the semantics
                defined in this specification for the original expression.
             </p>
                  <note>
                     <p>
                This allows an implementation to return a result in cases where the
                original expression would have raised an error, or to raise an error in cases
                where the original expression would have returned a result. The main cases
                where this is likely to arise in practice are (a) where a rewrite changes the
                order of evaluation, such that a subexpression causing an error is evaluated
                when the expression is written one way and is not evaluated when the expression
                is written a different way, and (b) where intermediate results of the
                evaluation cause overflow or other out-of-range conditions.
             </p>
                  </note>
                  <note>
                     <p>
                This rule does not mean that the result of the expression will always
                be the same in non-error cases as if it had not been rewritten, because there
                are many cases where the result of an expression is to some degree
                <termref
                           def="dt-implementation-dependent"
                           >implementation-dependent</termref>
                or <termref
                           def="dt-implementation-defined"
                        >implementation-defined</termref>.
             </p>
                  </note>
               </item>
               <item>
                  <p diff="add" at="B">
                     The rules described in <specref ref="id-guarded-expressions"/> ensure that for
                     certain kinds of expression (for example conditional expressions), changing the
                     order of evaluation of subexpressions does not result in dynamic errors that
                     would not otherwise occur.</p>
               </item>
 
               <item>
                  <p>
                Expressions must not be rewritten in such a way
                as to create or remove static errors.

                The static errors in this specification are defined
                for the original expression, and must be preserved if
                the expression is rewritten.</p>
               </item>
               
               <item>
                  <p>
                     As stated earlier, an expression
                     must not be rewritten to dispense with a
                     required cardinality check: for example, <code
                        role="parse-test"
                        >string-length(//title)</code>
                     must raise an
                     error if the document contains more than one title element.
                  </p>
               </item>
            </ulist>
 

         </div3>
         <div3 id="id-guarded-expressions" diff="add" at="B">
            <head>Guarded Expressions</head>
            
            <changes>
               <change issue="71" PR="230" date="2022-11-15">
                  The rules for “errors and optimization” have been tightened up to disallow
                  many cases of optimizations that alter error behavior. In particular
                  there are restrictions on reordering the operands of <code>and</code> and <code>or</code>,
                  and of predicates in filter expressions, in a way that might allow the processor to raise dynamic
                  errors that the author intended to prevent.
               </change>
            </changes>
            <p><termdef id="dt-guarded" term="guarded">An expression <var>E</var> is said to be <term>guarded</term>
               by some governing condition <var>C</var> if evaluation of <var>E</var> is not allowed to fail
               with a <termref def="dt-dynamic-error"/> except when <var>C</var> applies.</termdef></p>
            
            <p>For example, in a conditional expression <code>if (P) then T else F</code>, the subexpression
               <var>T</var> is guarded by <var>P</var>, and the subexpression <var>F</var> is guarded by
               <code>not(P)</code>. One way an implementation can satisfy this rule is by not evaluating <var>T</var> unless <var>P</var>
               is true, and likewise not evaluating <var>F</var> unless <var>P</var> is false. Another
               way of satisfying the rule is for the implementation to evaluate all the subexpressions, but to catch any errors that occur 
               in a guarded subexpression so they are not propagated.
            </p>
            
            <p>The existence of this rule enables errors to be prevented by writing expressions such as
            <code>if ($y eq 0) then "N/A" else ($x div $y)</code>. This example will never fail with a divide-by-zero
            error because the <code>else</code> branch of the conditional is <termref def="dt-guarded"/>.</p>
            
            <p>Similarly, in the mapping expression <code><var>E1</var>!<var>E2</var></code>, the subexpression <var>E2</var> is guarded
            by the existence of an item from <var>E1</var>. This means, for example, that the expression <code>(1 to $n)!doc('bad.xml')</code>
            must not raise a dynamic error if <code>$n</code> is zero. The rule governing evaluation of guarded expressions
               is phrased so as not to disallow “loop-lifting” or “constant-folding” optimizations 
               whose aim is to avoid repeated evaluation of a common subexpression;
            but such optimizations must not result in errors that would not otherwise occur.</p>
            
            <p>The complete list of expressions that have guarded subexpressions is as follows:</p>
            
            <ulist>
               <item><p>In a conditional expression (<nt def="IfExpr">IfExpr</nt>) the <code>then</code> branch
                  is guarded by the condition being true, and the <code>else</code> branch
                  is guarded by the condition being false.</p></item>
               <item role="xquery"><p>In a <code>switch</code> expression (<nt def="SwitchExpr">SwitchExpr</nt>), 
               the <code>return</code> expression of a particular <code>case</code> is guarded by the condition for that case
               matching, and no earlier case matching.</p></item>
               <item role="xquery"><p>In a <code>typeswitch</code> expression (<nt def="TypeswitchExpr">TypeswitchExpr</nt>), 
                  the <code>return</code> expression of a particular <code>case</code> is guarded by the condition for that case
                  matching, and no earlier case matching.</p></item>
               <item><p>In an <code>and</code> expression (<nt def="AndExpr">AndExpr</nt>), the second operand
               is guarded by the value of the first operand being true.</p></item>
               <item><p>In an <code>or</code> expression (<nt def="OrExpr">OrExpr</nt>), the second operand
                  is guarded by the value of the first operand being false.</p></item>
               <item><p>In an <code>otherwise</code> expression (<nt def="OtherwiseExpr">OtherwiseExpr</nt>), the second operand
                  is guarded by the value of the first operand being an empty sequence.</p></item>
               <item><p>In a path expression of the form <code><var>E1</var>/<var>E2</var></code> 
                  or <code><var>E1</var>//<var>E2</var></code>, and in a mapping
               expression of the form <code><var>E1</var>!<var>E2</var></code>, the right-hand operand <var>E2</var> is guarded by
               the existence of at least one item in the result of evaluating <var>E1</var>.</p>
                  <p>This rule applies even if <var>E2</var> does not reference the context value.
                     For example, no dynamic error can be thrown by the expression 
               <code>(1 to $n)!doc('bad.xml')</code> in the case where <code>$n</code> is zero.</p></item>
               <item><p>In a filter expression of the form <code><var>E</var>[<var>P</var>]</code>, 
                  the predicate <var>P</var> is guarded by
                  the existence of at least one item in the result of evaluating <var>E</var>.</p>
               <p>This rule has the consequence that in a filter expression with multiple predicates, 
                  such as <code><var>E</var>[<var>P1</var>][<var>P2</var>]</code>,
               evaluation of <var>P2</var> must not raise a dynamic error unless <var>P1</var> returns <code>true</code>. This rule does
               not prevent reordering of predicates (for example, to take advantage of indexes), but it does require that any
               such reordering must not result in errors that would not otherwise occur.</p>
               </item>
               <item><p role="xpath">In a <code>for</code> expression (<nt def="ForExpr">ForExpr</nt>) such
                  as <code>for $x in <var>S</var> return <var>E</var></code>, 
                  the expression <var>E</var> is guarded by the existence of
                  an item bound to <code>$x</code>.</p>
                  <p role="xquery">In a <code>FLWOR</code> expression (<nt def="FLWORExpr">FLWORExpr</nt>), an expression
                     that is logically dependent on the tuples in the tuple stream is guarded by the existence
                     of a relevant tuple. This applies even where the expression does not actually reference
                     any of the variable bindings in the tuple stream. For example, in the expression
                     <code>for $x in <var>S</var> return <var>E</var></code>, the expression 
                     <var>E</var> is guarded by the existence of
                        an item bound to <code>$x</code>.</p>
               <p>This means that the expression <code>for $x in 1 to $n return doc('bad.xml')</code>
               must not raise a dynamic error in the case where <code>$n</code> is zero.</p></item>
               <item><p>In a <code>quantified</code> expression (<nt def="QuantifiedExpr">QuantifiedExpr</nt>) such
                  as <code>some $x in <var>S</var> satisfies <var>P</var></code>, the expression 
                  <var>P</var> is guarded by the existence of
                     an item bound to <code>$x</code>.</p>
               </item>
            </ulist>
            
            <p>The fact that an expression is <termref def="dt-guarded"/> does not remove the obligation to report
            <termref def="dt-static-error">static errors</termref> in the expression; nor does it remove the option
            to report statically detectable <termref def="dt-type-error">type errors</termref>.</p>
            
            <note>
               <p>These rules do not constrain the order of evaluation of subexpressions. For example, given an expression
                  such as <code>//person[@first = "Winston"][@last = "Churchill"]</code>, or equivalently
                  <code>//person[@first = "Winston" and @last = "Churchill"]</code>, an implementation might use an index on the value of
                  <code>@last</code> to select items that satisfy the second condition, and then filter these
                  items on the value of the first condition. Alternatively, it might evaluate both predicates in parallel.
                  Or it might interpose an additional redundant condition: 
                  <code>//person[string-length(@first) + string-length(@last) = 16][@first = "Winston"][@last = "Churchill"]</code>.
                  But implementations must ensure that
                  such rewrites do not result in dynamic errors being reported that would not occur if the predicates
                  were evaluated in order as written.</p>
            </note>
            <note>
               <p>Although the rules for guarded expressions prevent optimizations resulting in spurious errors, 
                  they do not prevent optimizations whose effect is to mask errors. For example, the rules guarantee that
                  <code>("A", 3)[. instance of xs:integer][. eq 3]</code> will not raise an error caused by the comparison
                  <code>("A" eq 3)</code>, but they
                  do not guarantee the converse: the expression <code>("A", 3)[. eq 3][. instance of xs:integer]</code>
                  may or may not raise a dynamic error.</p>
            </note>
            <note>
               <p>The rules in this section do not disallow all expression rewrites that might result in dynamic
                  errors. For example, rewriting <code>($x - $y + $z)</code> as <code>($x + $z - $y)</code> is permitted
               even though it might result in an arithmetic overflow.</p>
            </note>
            
            <note>
               <p>Some implementations allow calls on external functions that have side-effects. The semantics of
               such function calls are entirely <termref def="dt-implementation-defined"/>. Processors <rfc2119>may</rfc2119>
               choose to reference the rules for <termref def="dt-guarded"/> expressions when defining the behavior
               of such function calls, but this is outside the scope of the language specification.</p>
            </note>
            
 
            
            
          
            
         </div3>
         
         <div3 id="id-implausible-expressions" diff="add" at="Issue602">
            <head>Implausible Expressions</head>
            
            <changes>
               <change issue="602" PR="603" date="2023-07-25">
                  The rules for reporting type errors during static analysis have been changed
                  so that a processor has more freedom to report errors in respect of constructs that
                  are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation
                  is defined to return an empty sequence rather than an error.
               </change>
            </changes>
            
            <p><termdef id="dt-implausible" term="implausible">Certain expressions, while not
            erroneous, are classified as being <term>implausible</term>,
            because they achieve no useful effect.</termdef></p>
            
            <p>An example of an implausible expression is <code>@code/text()</code>. This expression
            will always evaluate to an empty sequence, because attribute nodes cannot have text
            node children. The semantics of the expression are well defined, but it is likely
            that the user writing this expression intended something different: if they wanted to write an 
            expression that evaluated to an empty sequence, there would be easier ways to write it.</p>
            
            <p>Where an expression is classified (by rules in this specification) as being
            <termref def="dt-implausible"/>, a processor <rfc2119>may</rfc2119> (but is
            not <rfc2119>required</rfc2119> to) raise a static error.</p>
            
            <p>For reasons of backwards compatibility and interoperability, and to facilitate
            automatic generation of &language; code, a processor <rfc2119>must</rfc2119> 
            provide a mode of operation in which <termref def="dt-implausible"/>
            expressions are not treated as static errors, but are evaluated
            with the defined semantics for the expression.</p>
            
            <p>Some other examples of implausible expressions include:</p>
            
            <ulist>
            
               <item><p><code>round(tokenize($input))</code>. The result of <function>fn:tokenize</function>
               is a sequence of strings (<code>xs:string*</code>), while the required type for the
               first argument of <function>fn:round</function> is optional numeric (<code>xs:numeric?</code>).
               The expression can succeed only in the exceptional case where the result of <function>fn:tokenize</function>
               is an empty sequence, in which case the result of <function>fn:round</function> will also be
               an empty sequence; it is therefore highly likely that the expression was written in error.</p></item>
                  
               <item><p><code>parse-csv($input)?column-names</code>. The signature of the <code>parse-csv</code>
               function declares its return type as <code>record(columns, rows)</code>. There is no field in this
               record named <code>column-names</code>, and therefore the lookup expression will always
               return an empty sequence. Again, there is no good reason that a user would write this,
               so it is likely that it was written in error.</p></item>
            </ulist>
            
            <note><p>The specification is deliberately conservative in the choice of constructs that have
            been classified as implausible. Constructs have not been classified as implausible merely because there
            are better ways of writing the same thing, but only in cases where it is considered that no user in full understanding
            of the specification would intentionally write such a construct. All these cases correspond to situations
            that would be classed as errors in a language with stricter static typing rules.</p></note>
            
            <note><p>In many cases the classification of constructs as implausible is designed to protect users
            from usability problems that have been found with earlier versions of the language. without
            introducing backwards incompatibilities.</p></note>
            
         </div3> 
      </div2>
      <div2 id="id-important-concepts">
         <head>Concepts</head>

         <p>This section explains some concepts that are important to the processing of &language; expressions.</p>

         <div3 id="id-document-order">
            <head>Document Order</head>

            <p>An ordering called <term>document order</term> is defined among all the nodes accessible during processing of a given <phrase
                  role="xquery">query</phrase>
               <phrase role="xpath"
                  >expression</phrase>, which may consist of one or more <term>trees</term> (documents or fragments). 

Document order is defined in <xspecref
                  spec="DM40" ref="document-order"
                  />, and its definition is repeated here for convenience. 

Document order is a total ordering, although the relative order of some nodes is <termref
                  def="dt-implementation-dependent">implementation-dependent</termref>.  

<termdef
                  term="document order" id="dt-document-order"
                     >Informally, <term>document order</term> is the order in which nodes appear in the XML serialization of a document.</termdef>
               <termdef term="stable" id="stable"
                     >Document order is <term>stable</term>, which means that the relative order of two nodes will not change during the processing of a given <phrase
                     role="xquery">query</phrase>
                  <phrase role="xpath">expression</phrase>, even if this order is <termref
                     def="dt-implementation-dependent">implementation-dependent</termref>.</termdef>
               <termdef term="reverse document order" id="dt-reverse-document-order"
                     >The node ordering that is the reverse of document order is called <term>reverse document order</term>.</termdef>
            </p>

            <p>Within a tree, document order satisfies the following constraints:</p>

            <olist>


               <item>
                  <p>The root node is the first node.</p>
               </item>



               <item>
                  <p>Every node occurs before all of its children and descendants.</p>
               </item>



               <item role="xpath">
                  <p>Namespace nodes immediately follow the element node with
which they are associated. The relative order of namespace nodes is
stable but <termref
                        def="dt-implementation-dependent">implementation-dependent</termref>.</p>
               </item>



               <item>
                  <p>Attribute nodes immediately follow the <phrase role="xpath"
                        >namespace nodes of the
</phrase> element node with which they are associated. The relative order of
attribute nodes is stable but <termref
                        def="dt-implementation-dependent">implementation-dependent</termref>.</p>
               </item>



               <item>
                  <p>The relative order of siblings is the order in which they occur
in the <code>children</code> property of their parent node.</p>
               </item>

               <item>
                  <p>Children and descendants occur before following siblings.</p>
               </item>
            </olist>

            <p>The relative order of nodes in distinct trees is stable but
<termref
                  def="dt-implementation-dependent"
               >implementation-dependent</termref>,
subject to the following constraint: If any node in a given tree T1 is before
any node in a different tree T2, then all nodes in tree T1 are before all nodes in
tree T2.</p>

         </div3>
         
         <div3 id="id-typed-value">
            <head>Typed Value and String Value</head>
            
            <p>Every node has a <term>typed value</term> and a <term>string value</term>, except for nodes whose value is <xtermref
               spec="DM40" ref="dt-absent"/>.
               
               <termdef term="typed value" id="dt-typed-value"
                  >The <term>typed
                     value</term> of a node is a sequence of atomic items and can be
                  extracted by applying the <xspecref
                     spec="FO40" ref="func-data"/> function to the
                  node.</termdef>
               <termdef id="dt-string-value" term="string value"
                  >The
                  <term>string value</term> of a node is a string and can be extracted
                  by applying the <xspecref
                     spec="FO40" ref="func-string"/>
                  function to the node.</termdef>
            </p>
            
            
            <p>An implementation may store both the <termref def="dt-typed-value"
               >typed value</termref> and the <termref def="dt-string-value"
                  >string value</termref> of a node, or it may store only one of these and derive the other as needed.
               The string value of a node must be a valid lexical representation of the typed value of the node,
               but the node is not required to preserve the string representation from the original source document.
               For example, if the typed value of a node is the <code>xs:integer</code> value <code>30</code>,
               its string value might be <code>"30"</code> or <code>"0030"</code>.</p>
            <p role="xpath">The <termref def="dt-typed-value">typed value</termref>, <termref
               def="dt-string-value">string value</termref>, and <termref
                  def="dt-type-annotation"
                  >type annotation</termref> of a node are closely related.  If the node was created by mapping from an Infoset or PSVI, the relationships among these properties are defined by rules in <xspecref
                     spec="DM40" ref="types"/>.</p>
            <p role="xquery">The <termref def="dt-typed-value">typed value</termref>, <termref
               def="dt-string-value">string value</termref>, and <termref
                  def="dt-type-annotation"
                  >type annotation</termref> of a node are closely related, and are defined by rules found in the following locations:</p>
            
            <ulist role="xquery">
               
               <item>
                  <p>If the node was created by mapping from an Infoset or PSVI, see rules in <xspecref
                     spec="DM40" ref="types"/>.</p>
               </item>
               
               <item>
                  <p>If the node was created by an XQuery node constructor, see rules in <specref
                     ref="id-element-constructor"/>, <specref ref="id-computedElements"
                     />, or <specref ref="id-computedAttributes"/>.</p>
               </item>
               
               <item>
                  <p>If the node was created by a <code>validate</code> expression, see rules in <specref
                     ref="id-validate"/>.</p>
               </item>
            </ulist>
            <p>The relationship between <termref
               def="dt-typed-value">typed value</termref> and
               <termref def="dt-string-value"
                  >string value</termref> for various kinds of nodes is summarized and illustrated
               by examples below.</p>
            
            <olist>
               
               <item>
                  <p>For text and document nodes, the typed value of the node is the same as its
                     string value, as an instance of  the type <code>xs:untypedAtomic</code>. The
                     string value of a document node is formed by concatenating the string
                     values of all its descendant text nodes, in <termref
                        def="dt-document-order">document
                        order</termref>.</p>
               </item>
               
               <item>
                  <p>The typed value of a comment<phrase role="xpath"
                     >, namespace,</phrase> or processing instruction node is the same as its string value. It is an instance of the type <code>xs:string</code>.</p>
               </item>
               
               <item>
                  <p>The typed value of an attribute node with
                     the <termref def="dt-type-annotation"
                        >type annotation</termref>
                     <code>xs:anySimpleType</code> or <code>xs:untypedAtomic</code> is the same as its
                     string value, as an instance of <code>xs:untypedAtomic</code>. The
                     typed value of an attribute node with any other type annotation is
                     derived from its string value and type annotation using the lexical-to-value-space mapping defined in <bibref
                        ref="XMLSchema10"/> or <bibref ref="XMLSchema11"
                        /> Part 2 for
                     the relevant type.</p>
                  <p>Example: A1 is an attribute
                     having string value <code>"3.14E-2"</code> and type annotation
                     <code>xs:double</code>.  The typed value of A1 is the
                     <code>xs:double</code> value whose lexical representation is
                     <code>3.14E-2</code>. </p>
                  <p>Example: A2 is an attribute with type
                     annotation <code>xs:IDREFS</code>, which is a list datatype whose item type is the atomic datatype <code>xs:IDREF</code>. Its string value is
                     <code>"bar baz faz"</code>. The typed value of A2 is a sequence of
                     three atomic items (<code>"bar"</code>, <code>"baz"</code>",
                     <code>"faz"</code>"), each of type <code>xs:IDREF</code>. The typed
                     value of a node is never treated as an instance of a named list
                     type. Instead, if the type annotation of a node is a list type (such
                     as <code>xs:IDREFS</code>), its typed value is treated as a sequence
                     of the <termref
                        def="dt-generalized-atomic-type"
                        >generalized atomic type</termref> from which it is derived (such as
                     <code>xs:IDREF</code>).</p>
               </item>
               
               <item>
                  <p>For an element node, the
                     relationship between typed value and string value depends on the
                     node’s <termref
                        def="dt-type-annotation">type annotation</termref>, as follows:</p>
                  
                  <olist>
                     
                     
                     
                     <item>
                        
                        <p>If the type annotation is <code>xs:untyped</code> or <code>xs:anySimpleType</code> or
                           denotes a complex type with mixed content (including <code>xs:anyType</code>), then the typed value of the
                           node is equal to its string value, as an instance of
                           <code>xs:untypedAtomic</code>.  However, if the <code>nilled</code>
                           property of the node is <code>true</code>, then its typed value is the empty sequence.</p>
                        
                        
                        
                        <p>Example: E1 is an element node
                           having type annotation <code>xs:untyped</code> and string value
                           <code>"1999-05-31"</code>. The typed value of E1 is
                           <code>"1999-05-31"</code>, as an instance of
                           <code>xs:untypedAtomic</code>.</p>
                        
                        
                        <p>Example: E2 is an element node
                           with the type annotation <code>formula</code>, which is a complex type
                           with mixed content. The content of E2 consists of the character
                           <code>H</code>, a child element named <code>subscript</code> with
                           string value <code>"2"</code>, and the character <code>O</code>. The
                           typed value of E2 is <code>"H2O"</code> as an instance of
                           <code>xs:untypedAtomic</code>.</p>
                     </item>
                     
                     
                     
                     <item>
                        <p>If the type
                           annotation denotes a simple type or a complex type with simple
                           content, then the typed value of the node is derived from its string
                           value and its type annotation in a way that is consistent with schema
                           validation. However, if the <code>nilled</code>
                           property of the node is <code>true</code>, then its typed value is the empty sequence.</p>
                        <p>Example: E3 is an element node with the type
                           annotation <code>cost</code>, which is a complex type that has several
                           attributes and a simple content type of <code>xs:decimal</code>. The
                           string value of E3 is <code>"74.95"</code>. The typed value of E3 is
                           <code>74.95</code>, as an instance of
                           <code>xs:decimal</code>.</p>
                        <p>Example: E4 is an element node with the
                           type annotation <code>hatsizelist</code>, which is a simple type
                           derived from the <termref def="dt-atomic-type"/> 
                           <code>hatsize</code>, which in turn is
                           derived from <code>xs:integer</code>. The string value of E4 is
                           <code>"7 8 9"</code>. The typed value of E4 is a sequence of three
                           values (<code>7</code>, <code>8</code>, <code>9</code>), each of type
                           <code>hatsize</code>.</p>
                        <p>Example: E5 is an element node with the type annotation <code>my:integer-or-string</code>
                           which is a union type with member types <code>xs:integer</code> and <code>xs:string</code>.
                           The string value of E5 is <code>"47"</code>. The typed value of E5 is <code>47</code> as a
                           <code>xs:integer</code>, since <code>xs:integer</code> is the member type that validated the
                           content of E5. In general, when the type annotation of a node is a union type,
                           the typed value of the node will be an instance of one of the member types of the union.</p>
                        <note>
                           <p>If an implementation stores only the string value of a node, and the type annotation of the node is a union type, the implementation must be able to deliver the typed value of the node as an instance of the appropriate member type.</p>
                        </note>
                     </item>
                     
                     <item>
                        <p>If the type annotation
                           denotes a complex type with empty content, then the typed value of the
                           node is the empty sequence and its string value is the zero-length string.</p>
                     </item>
                     
                     <item>
                        <p>If the type annotation
                           denotes a complex type with element-only content, then the typed value
                           of the node is <xtermref
                              spec="DM40" ref="dt-absent"
                           />. The <function>fn:data</function> function raises a
                           <termref
                              def="dt-type-error">type error</termref>
                           <xerrorref spec="FO40" class="TY" code="0012"
                           /> when applied to such a node. The string value of such a node is equal to the concatenated string values of all its text node descendants, in document order.</p>
                        <p>Example: E6 is an
                           element node with the type annotation <code>weather</code>, which is a
                           complex type whose content type specifies
                           <code>element-only</code>. E6 has two child elements named
                           <code>temperature</code> and <code>precipitation</code>. The typed
                           value of E6 is <xtermref
                              spec="DM40" ref="dt-absent"
                           />, and the <function>fn:data</function> function
                           applied to E6 raises an error.
                        </p>
                     </item>
                  </olist>
               </item>
            </olist>
         </div3>
         
         

         <div3 id="id-atomization">
            <head>Atomization</head>
            <p>The semantics of some
&language; operators depend on a process called <termref
                  def="dt-atomization"
                  >atomization</termref>. Atomization is
applied to a value when the value is used in a context in which a
sequence of atomic items is required. The result of atomization is
either a sequence of atomic items or a <termref
                  def="dt-type-error">type error</termref>
               <xerrorref spec="FO40" class="TY" code="0012"/>.  <termdef id="dt-atomization"
                  term="atomization">
                  <term>Atomization</term> of a sequence
is defined as the result of invoking the <function>fn:data</function> function, as defined in <xspecref
                     spec="FO40" ref="func-data"/>.</termdef>
            </p>
            <p> The semantics of
<function>fn:data</function> are repeated here for convenience. The result of
<function>fn:data</function> is the sequence of atomic items produced by
applying the following rules to each item in the input
sequence:</p>
            <ulist>

               <item>
                  <p>If the item is an atomic item, it is
returned.</p>
               </item>

               <item>
                  <p>If the item is a node,
its <termref def="dt-typed-value"
                        >typed value</termref> is returned (a <termref def="dt-type-error"
                        >type error</termref>
                     <xerrorref spec="FO40" class="TY" code="0012"
                     /> is raised if the node has no typed value.)</p>
               </item>

               <item>
                  <p>If the item is a <termref def="dt-function-item"
                        >function item</termref> (other than an array) or map a <termref
                        def="dt-type-error">type error</termref>
                     <xerrorref spec="FO40" class="TY" code="0013"/> is raised.</p>
               </item>

               <item>
                  <p>If the item is an array <code>$a</code>, atomization is defined as <code>$a?* ! fn:data(.)</code>, which is equivalent to atomizing the members of the array.</p>
                  <note>
                     <p>This definition recursively atomizes members that are arrays. Hence, the result of atomizing the array <code>[ [ 1, 2, 3 ], [ 4, 5, 6 ] ]</code> is the sequence <code>(1, 2, 3, 4, 5, 6)</code>.</p>
                  </note>
               </item>

            </ulist>
            <p>Atomization is  used in
processing the following types of expressions: </p>
            <ulist>

               <item>
                  <p>Arithmetic expressions</p>
               </item>

               <item>
                  <p>Comparison expressions</p>
               </item>

               <item>
                  <p>Function calls and returns</p>
               </item>

               <item>
                  <p>Cast expressions</p>
               </item>

               <item role="xquery">
                  <p>Constructor expressions for various kinds of nodes</p>
               </item>

               <item role="xquery">
                  <p>
                     <code>order by</code> clauses in FLWOR expressions</p>
               </item>

               <item role="xquery">
                  <p>
                     <code>group by</code> clauses in FLWOR expressions</p>
               </item>

               <item role="xquery">
                  <p>Switch expressions</p>
               </item>

            </ulist>
         </div3>


         <div3 id="id-ebv">
            <head>Effective Boolean Value</head>
            <p>Under certain circumstances (listed below), it is necessary to find
the <termref
                  def="dt-ebv">effective boolean value</termref> of a
value. <termdef id="dt-ebv"
                  term="effective boolean value"
                     >The
<term>effective boolean value</term> of a value is defined as the result
of applying the <function>fn:boolean</function> function to the value, as
defined in <xspecref
                     spec="FO40" ref="func-boolean"/>.</termdef>
            </p>

            <p>The dynamic semantics of <function>fn:boolean</function> are repeated here for convenience:</p>

            <olist>

               <item>
                  <p>If its operand is an empty sequence, <function>fn:boolean</function> returns <code>false</code>.</p>
               </item>

               <item>
                  <p>If its operand is a sequence whose first item is a node, <function>fn:boolean</function> returns <code>true</code>.</p>
               </item>

               <item>
                  <p>If its operand is a <termref def="dt-singleton"/> value of 
                     type <code>xs:boolean</code> or derived from <code>xs:boolean</code>, 
                     <function>fn:boolean</function> returns the value of its operand unchanged.</p>
               </item>

               <item>
                  <p>If its operand is a <termref def="dt-singleton"/> value of 
                     type <code>xs:string</code>, <code>xs:anyURI</code>, 
                     <code>xs:untypedAtomic</code>, or a type derived from one of these,
                     <function>fn:boolean</function> returns <code>false</code> 
                     if the operand value has zero length; otherwise it returns <code>true</code>.</p>
               </item>

               <item>
                  <p>If its operand is a <termref def="dt-singleton"/> value of 
                     any <termref def="dt-numeric"/> type or derived from a numeric
                     type, <function>fn:boolean</function> returns <code>false</code> 
                     if the operand value is <code>NaN</code> or is numerically 
                     equal to zero; otherwise it returns <code>true</code>.</p>
               </item>

               <item>
                  <p>In all other cases, <function>fn:boolean</function> raises a type error <xerrorref
                        spec="FO40" class="RG" code="0006"/>.</p>
                  <note>
                     <p>For instance, <function>fn:boolean</function> raises a type error if the operand is a function, a map, or an array.</p>
                  </note>
               </item>
            </olist>

            <p>The <termref def="dt-ebv"
               >effective boolean value</termref> of a sequence is computed implicitly during  processing of the following types of expressions: </p>
            <ulist>

               <item>
                  <p>Logical expressions (<code>and</code>, <code>or</code>)</p>
               </item>

               <item>
                  <p>The <function>fn:not</function> function</p>
               </item>

               <item role="xquery">
                  <p>The <code>where</code> clause of a FLWOR expression</p>
               </item>

               <item>
                  <p>Certain types of <termref def="dt-predicate"
                        >predicates</termref>, such as <code>a[b]</code>
                  </p>
               </item>

               <item>
                  <p>Conditional expressions (<code>if</code>)</p>
               </item>

               <item>
                  <p>Quantified expressions (<code>some</code>, <code>every</code>)</p>
               </item>

               <item role="xpath">
                  <p>General comparisons, in <termref def="dt-xpath-compat-mode"
                        >XPath 1.0
		compatibility mode</termref>.</p>
               </item>

               <item role="xquery">
                  <p>
                     <nt def="WindowStartCondition">WindowStartCondition</nt> and <nt
                        def="WindowEndCondition"
                     >WindowEndCondition</nt> in <code>window</code> clauses.</p>
               </item>

            </ulist>

            <note>
               <p>The definition of <termref def="dt-ebv"
                     >effective boolean
  value</termref> is <emph>not</emph> used when casting a value to the
  type <code>xs:boolean</code>, for example in a <code>cast</code>
  expression or when passing a value to a function whose expected
  parameter is of type <code>xs:boolean</code>.</p>
            </note>

         </div3>

         
         <div3 id="id-uri-literals">
            <head>URI Literals</head>

            <p>&language; requires a statically known, valid URI in <phrase role="xquery">a <nt
                     def="URILiteral">URILiteral</nt> or
      </phrase>a <nt def="BracedURILiteral"
                  >BracedURILiteral</nt>. 

      An implementation may raise a <termref
                  def="dt-static-error">static error</termref>
               <errorref class="ST" code="0046"/> if the value of <phrase role="xquery"
                  >a
      URI Literal or</phrase> a Braced URI Literal is of nonzero length
      and is neither an
      absolute URI nor a relative URI.</p>

            <p role="xquery">As in a string literal, any <termref
                  def="dt-predefined-entity-reference"
                  >predefined entity
      reference</termref> (such as <code>&amp;amp;</code>), <termref
                  def="dt-character-reference"
                  >character reference</termref> (such
      as <code>&amp;#x2022;</code>), or <nt
                  def="EscapeQuot">EscapeQuot</nt> or <nt def="EscapeApos"
                  >EscapeApos</nt> (for example, <code>""</code>)
      is replaced by its appropriate expansion. Certain characters,
      notably the ampersand, can only be represented using a <termref
                  def="dt-predefined-entity-reference"
                  >predefined entity
      reference</termref> or a <termref
                  def="dt-character-reference">character reference</termref>.</p>

            <note>
               <p>The <code>xs:anyURI</code>
      type is designed to anticipate the introduction of
      Internationalized Resource Identifiers (IRIs) as defined in
      <bibref
                     ref="RFC3987"/>.</p>
            </note>

            <p>Whitespace is normalized using the whitespace normalization rules
      of <function>fn:normalize-space</function>. If the result of whitespace
      normalization contains only whitespace, the corresponding URI
      consists of the empty string.  <phrase
                  role="xquery"
                     >Whitespace
      normalization is done after the expansion of <termref
                     def="dt-character-reference"
                     >character references</termref>, so
      writing a newline (for example) as <code>&amp;#xA;</code> does
      not prevent its being normalized to a space
      character.</phrase>
            </p>


            <p>A Braced URI Literal or URI Literal is not
      subjected to percent-encoding
      or decoding as defined in <bibref
                  ref="RFC3986"/>.</p>

         </div3>

         <div3 id="id-resolve-relative-uri">
            <head>Resolving a Relative URI Reference</head>

            <p>
               <termdef id="dt-resolve-relative-uri" term="resolve"
                     >To
      <term>resolve a relative URI</term>
                  <code>$rel</code> against a
      base URI <code>$base</code> is to expand it to an absolute URI,
      as if by calling the function <code>fn:resolve-uri($rel,
      $base)</code>.</termdef> During static analysis, the base URI is
      the Static Base URI. During dynamic evaluation, the base URI
      used to resolve a relative URI reference depends on the semantics of the
      expression.</p>

            <p>Any process that attempts to <termref def="dt-resolve-relative-uri"
                  >resolve a URI</termref> against a
      base URI, or to dereference the URI, may apply percent-encoding
      or decoding as defined in the relevant RFCs.</p>

         </div3>

      </div2>
   </div1>
   <div1 id="id-types">
      <head>Types</head>
      
      <p>As noted in <specref ref="id-values"/>, every value in &language; is regarded
      as a <termref def="dt-sequence"/> of zero, one, or more <termref def="dt-item">items</termref>.
      The type system of &language;, described in this section, classifies the
      kinds of value that the language can handle, and the operations permitted
      on different kinds of value.</p>
      
         <p>The type system of &language; is related to the type system of
		<bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/> in two ways:</p>
      
         <ulist>
            <item><p>atomic items in &language; (which are one kind of <termref def="dt-item"/>)
               have <termref def="dt-atomic-type">atomic types</termref> such as <code>xs:string</code>,
               <code>xs:boolean</code>, and <code>xs:integer</code>. These types are taken directly
               from their definitions in <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/>.</p></item>
            <item><p>Nodes (which are another kind of <termref def="dt-item"/>) have a property
            called a <termref def="dt-type-annotation"/> which determines the type of their content.
            The type annotation is a <termref def="dt-schema-type"/>. The type annotation of a node
            must not be confused with the item type of the node. For example, an element 
            <code><![CDATA[<age>23</age>]]></code> might have been validated against a schema
               that defines this element as having <code>xs:integer</code> content. If this
               is the case, the <termref def="dt-type-annotation"/> of the node will be
               <code>xs:integer</code>, and in the &language; type system, the node will
               match the <termref def="dt-item-type"/> <code>element(age, xs:integer)</code>.
            </p></item>
         </ulist>
                
         <p>This chapter of the specification starts by defining 
            <termref def="dt-sequence-type">sequence types</termref> and 
         <termref def="dt-item-type">item types</termref>, which describe the range of
            <termref def="dt-value">values</termref> that can be bound to variables, used in 
            expressions, or passed to functions. It then describes how these
            relate to <termref def="dt-schema-type">schema types</termref>,
            that is, the simple and complex types defined in an XSD schema.</p>
      
      <note><p>In many situations the terms <term>item type</term> and 
         <term>sequence type</term> are used interchangeably to refer either to the type itself,
         or to the syntactic construct that designates the type: so in the expression
         <code>$x instance of xs:string*</code>, the construct <code>xs:string*</code>
         uses the <nt def="SequenceType">SequenceType</nt> syntax to designate a
         <termref def="dt-sequence-type"/> whose instances are sequences of strings.
         When more precision is required, the specification is careful to use the terms
         <termref def="dt-item-type"/> and <termref def="dt-sequence-type"/> to
         refer to the actual types, while using the production names <nt def="ItemType">ItemType</nt>
         and <nt def="SequenceType">SequenceType</nt> to refer to the syntactic
         designators of these types.</p></note>

      <div2 id="id-sequencetype-syntax">
         <head>Sequence Types</head>

         <p>
            <termdef id="dt-sequence-type" term="sequence type"
                  >A <term>sequence type</term> is a type that can be expressed using the <nt
                  def="SequenceType">SequenceType</nt>
                  syntax. Sequence types are used whenever it is necessary to refer to a type in an &language; expression. 
                  Since all values are sequences, every value matches one or more <term>sequence types</term>.</termdef>
         </p>
      
         
         
         <p>Whenever it is necessary to refer to a <term>sequence type</term> 
            in an &language; expression, the <nt
            def="SequenceType">SequenceType</nt> syntax is used.</p>
         <scrap>
            <prodrecap ref="SequenceType"/>
         </scrap>
         
      
      
      
      <p><termdef id="dt-sequence-type-designator" term="sequence type designator">A
      <term>sequence type designator</term> is a syntactic construct conforming to the grammar rule
         <nt def="SequenceType">SequenceType</nt>. A sequence type designator is said
      to <term>designate</term> a <termref def="dt-sequence-type"/>.</termdef></p>
      
       


            <p>With the exception of the special type
<code>empty-sequence()</code>, a <termref
                  def="dt-sequence-type"
                  >sequence type</termref> consists of an
<termref def="dt-item-type"/> that constrains the type of each item in the
sequence, and a <term>cardinality</term> that constrains the number of
items in the sequence. Apart from the item type <code>item()</code>,
which permits any kind of item, item types divide into <term>node
types</term> (such as <code>element()</code>), <term>generalized atomic
types</term> (such as <code>xs:integer</code>) and function types
(such as <code>function() as item()*</code>).</p>

            
            <p>The cardinality of a <termref def="dt-sequence-type"/> is represented
               in the <termref def="dt-sequence-type-designator"/> syntax by
               an <nt def="OccurrenceIndicator"/>. 
               The occurrence indicators <code>+</code>, <code>*</code>, and <code>?</code> 
               bind to the last <nt def="ItemType"
                  >ItemType</nt> in the <nt def="SequenceType"
                  >SequenceType</nt>, as described in the <loc href="#parse-note-occurrence-indicators"
                  >occurrence-indicators</loc> constraint.</p>

          <div3 id="id-sequence-type-examples">
             <head>Examples of Sequence Types</head>

            <p>Here are some examples of <termref def="dt-sequence-type"
               >sequence types</termref> that
		  might be used in &language;:</p>

            <ulist>
               <item>
                  <p>
                     <code>xs:date</code> refers to the built-in atomic schema type named <code>xs:date</code>
                  </p>
               </item>
               <item>
                  <p>
                     <code>attribute()?</code> refers to an optional attribute node</p>
               </item>
               <item>
                  <p>
                     <code>element()</code> refers to any element node</p>
               </item>
               <item>
                  <p>
                     <code>element(po:shipto, po:address)</code> refers to an element node that has the name <code>po:shipto</code> and has the type annotation <code>po:address</code> (or a schema type derived from <code>po:address</code>)</p>
               </item>
               <item>
                  <p>
                     <code>element(*, po:address)</code> refers to an element node of any name that has the type annotation <code>po:address</code> (or a type derived from <code>po:address</code>)</p>
               </item>

               <item>
                  <p>
                     <code>element(customer)</code> refers to an element node named <code>customer</code> with any type annotation</p>
               </item>



               <item>
                  <p>
                     <code>schema-element(customer)</code> refers to an element node whose name is <code>customer</code> (or is in the substitution group headed by <code>customer</code>) and whose type annotation matches the schema type declared for a <code>customer</code> element in the <termref
                        def="dt-is-elems">in-scope element declarations</termref>
                  </p>
               </item>

               <item>
                  <p>
                     <code>node()*</code> refers to a sequence of zero or more nodes of any kind</p>
               </item>
               <item>
                  <p>
                     <code>item()+</code> refers to a sequence of one or more <termref def="dt-item"
                        >items</termref>
                  </p>
               </item>
               <item>
                  <p>
                     <code>function(*)</code> refers to any <termref
                        def="dt-function-item">function item</termref>, regardless of arity or type</p>
               </item>
               <item>
                  <p>
                     <code>function(node()) as xs:string*</code> refers to a <termref 
                        def="dt-function-item"/> that takes a single argument whose value is a single node,
        and returns a sequence of zero or more <code>xs:string</code> values</p>
               </item>
               <item>
                  <p>
                     <code>(fn(node()) as xs:string)*</code> refers to a sequence of zero or more <termref
                        def="dt-function-item"
                     >function items</termref>, each of which takes a single
        argument whose value is a single node, and returns as its result a single <code>xs:string</code> value</p>
               </item>
            </ulist>

          </div3>

         <div3 id="id-sequencetype-matching">
            <head>Sequence Type Matching</head>
            <p diff="chg" at="B">
               <termdef id="dt-sequencetype-matching" term="SequenceType matching">
                  <term>SequenceType matching</term> compares a value with an expected <termref
                     def="dt-sequence-type"
                  >sequence type</termref>. </termdef> For example, an <code>instance of</code> expression 
               returns <code>true</code> if a given value matches a given <termref
                  def="dt-sequence-type"
               >sequence type</termref>, and <code>false</code> if it does not.</p>


            <p>An &language; implementation must be able to determine relationships among the types in type annotations in an <termref
                  def="dt-data-model-instance">XDM instance</termref> and the types in the  <termref
                  def="dt-issd">in-scope schema definitions</termref> (ISSD). <phrase role="xquery"
                  >An &language; implementation must be able to determine relationships among the types in ISSDs used in different modules of the same query.</phrase>
            </p>

            <p diff="chg" at="B">
               <termdef term="subtype substitution" id="dt-subtype-substitution"
                     >The use of a value that has a <termref def="dt-dynamic-type"/>
                      that is a <termref def="dt-subtype"/> of the
		  expected type is known as <term>subtype substitution</term>.</termdef>
		  Subtype substitution does not change the actual type of a value. For
		  example, if an <code>xs:integer</code> value is used where an
		  <code>xs:decimal</code> value is expected, the value retains its type
		  as <code>xs:integer</code>.</p>

        <!--    <p>The definition of <termref def="dt-sequencetype-matching"
                  >SequenceType matching</termref> relies
		  on a pseudo-function named <code>derives-from(</code>
               <emph>AT</emph>,
		  <emph>ET</emph>
               <code>)</code>, which takes an actual simple or complex
		  schema type <emph>AT</emph> and an expected simple or complex schema
		  type <emph>ET</emph>, and either returns a boolean value or raises a
		  <termref
                  def="dt-type-error">type error</termref>
               <errorref class="TY" code="0004"/>.  This function is defined as follows:</p>

            <ulist>

               <item>
                  <p>
                     <code>derives-from(</code>
                     <emph>AT</emph>, <emph>ET</emph>
                     <code>)</code> raises a type error <errorref class="TY" code="0004"
                        /> if <emph>ET</emph> is
		    not present in the <termref def="dt-issd"
                        >in-scope schema definitions</termref> (ISSD). </p>
               </item>

               <item>
                  <p>
                     <code>derives-from(</code>
                     <emph>AT</emph>,
		    <emph>ET</emph>
                     <code>)</code> returns <code>true</code>  
		    if any of the following conditions applies:

		    <ulist> <item>
                           <p>
                              <emph>AT</emph> is <emph>ET</emph>
                           </p>
                        </item> <item>
                           <p>
                              <emph>ET</emph> is the base type of <emph>AT</emph>
                           </p>
                        </item> <item>
                           <p>
                              <emph>ET</emph> is a pure union type of which <emph>AT</emph> is a member type</p>
                        </item> <item>
                           <p>There is a type <emph>MT</emph> such that <code>derives-from(</code>
                              <emph>AT</emph>, <emph>MT</emph>
                              <code>)</code> 
		      and <code>derives-from(</code>
                              <emph>MT</emph>, <emph>ET</emph>
                              <code>)</code>
                           </p>
                        </item> </ulist>
                  </p>
               </item>

               <item>
                  <p>Otherwise, <code>derives-from(</code>
                     <emph>AT</emph>, <emph>ET</emph>
                     <code>)</code> returns <code>false</code>
                  </p>
               </item>

            </ulist>-->

            <p>The rules for <termref def="dt-sequencetype-matching"
                  >SequenceType
		  matching</termref> are given below, with examples (the examples are
		  for purposes of illustration, and do not cover all possible
		  cases).</p>


            
               
               <ulist>

                  <item>
                     <p>The <termref def="dt-sequence-type">sequence type</termref>
                        <code>empty-sequence()</code> matches a value that is the empty sequence.</p>
                  </item>

                  <item>
                     <p>An <nt def="ItemType">ItemType</nt> with no <nt def="OccurrenceIndicator"
                           >OccurrenceIndicator</nt> matches any value that contains exactly one item if the <nt
                           def="ItemType">ItemType</nt> matches that item (see <specref
                           ref="id-matching-item"/>).</p>
                  </item>

                  <item>
                     <p>An <nt def="ItemType">ItemType</nt> with an <nt def="OccurrenceIndicator"
                           >OccurrenceIndicator</nt> matches a value if the number of items in the value matches the <nt
                           def="OccurrenceIndicator">OccurrenceIndicator</nt> and the <nt
                           def="ItemType">ItemType</nt> matches each of the items in the value.</p>
                  </item>
               </ulist>
               <p>An <nt def="OccurrenceIndicator"
                  >OccurrenceIndicator</nt> specifies the number of items in
		    a sequence, as follows:</p>

               <ulist>


                  <item>
                     <p>
                        <code>?</code> matches zero or one items</p>
                  </item>
                  <item>
                     <p>
                        <code>*</code> matches zero or more items</p>
                  </item>
                  <item>
                     <p>
                        <code>+</code> matches one or more items</p>
                  </item>
               </ulist>

               <p>As a consequence of these rules, any <termref def="dt-sequence-type"
                     >sequence type</termref> whose
		    <nt def="OccurrenceIndicator"
                     >OccurrenceIndicator</nt> is <code>*</code> or <code>?</code> matches a
		    value that is an empty sequence.</p>
            
         </div3>
         <div3 id="id-schema-type-derivation">
            <head>Schema Type Relationships</head>
            
            <p>Some <termref def="dt-item-type">item types</termref> are defined in terms
            of <termref def="dt-schema-type">schema types</termref>, and the matching
            rules for such item types depend on the rules defining relationships between
            schema types in the XSD specification.</p>
            
            <p><termdef id="dt-derives-from" term="derives from" open="true">A 
               <termref def="dt-schema-type"/> <var>S1</var> is said to <term>derive from</term>
               <termref def="dt-schema-type"/> <var>S2</var> if any of the following
               conditions is true:</termdef></p>
            
               <ulist> 
                  <item><p><var>S1</var> is the same type as <var>S2</var>.</p></item> 
                  <item><p><var>S2</var> is the base type of <var>S1</var>.</p></item>
                  <item><p><var>S2</var> is a <termref def="dt-pure-union-type"/>
                     of which <var>S1</var> is a member type.</p></item> 
                  <item><p>There is a <termref def="dt-schema-type"/> <var>M</var> such that 
                     <var>S1</var> <termref def="dt-derives-from"/> <var>M</var>
                     and <var>M</var> <termref def="dt-derives-from"/> <var>S2</var>.</p></item> 
               </ulist>
               <p role="closetermdef"/>
            
               <note><p>The XML Schema specification does not completely specify the circumstances
               under which <var>S1</var> and <var>S2</var> are considered to be the same
               type. For example, if both are anonymous union types with the same member types,
               but defined in different places in the schema, then schema processors have
               discretion whether to treat them as the same type.</p></note>
         </div3>
         </div2>
         <div2 id="id-matching-item">
               <head>Item Types</head>
            
            <p diff="add" at="B">
         <termdef id="dt-item-type" term="item type"
            >An <term>item type</term> is a type that can be expressed using the <nt
               def="ItemType">ItemType</nt> syntax, which forms part of the <nt def="SequenceType">SequenceType</nt>
            syntax. Item types match individual <termref def="dt-item">items</termref>.</termdef></p>
            
            <note><p>While this definition is adequate for the purpose of defining the syntax
            of &language;, it ignores the fact that there are also item types that cannot be
            expressed using &language; syntax: specifically, item types that reference
            an anonymous simple type or complex type defined in a schema. Such types 
            can appear as type annotations on nodes following schema validation.</p></note>
         
         <p>In most cases, the set of items matched by an item type consists either
         exclusively of <termref def="dt-atomic-item">atomic items</termref>,
         exclusively of <termref def="dt-node">nodes</termref>, 
         or exclusively of <xtermref spec="DM40" ref="dt-function-item">function items</xtermref>.
         Exceptions include the generic types <code>item()</code>, which matches all items, <code>xs:error</code>,
         which matches no items, and <termref def="dt-choice-item-type">choice item types</termref>,
         which can match any combination of types.
      </p>
            
      <p><termdef id="dt-item-type-designator" term="item type designator">An
         <term>item type designator</term> is a syntactic construct conforming to the grammar rule
         <nt def="ItemType">ItemType</nt>. An item type designator is said
         to <term>designate</term> an <termref def="dt-item-type"/>.</termdef></p>
      
      <note><p>Two <termref def="dt-item-type-designator">item type designators</termref> may designate the
      same item type. For example, <code>element()</code> and <code>element(*)</code> are equivalent,
      as are <code>attribute(A)</code> and <code>attribute(A, xs:anySimpleType)</code>.</p></note>
        
      <p>
               <termref def="dt-qname">Lexical QNames</termref> appearing in an <termref
                  def="dt-item-type-designator"/> <phrase role="xquery">(other than within
                  a <termref def="dt-function-assertion"/>)</phrase> have their
		  prefixes expanded to namespace URIs by means of the
		  <termref
                  def="dt-static-namespaces"
                  >statically known namespaces</termref> and (where applicable) the
		    <termref def="dt-default-namespace-elements-and-types"/>.
      Equality of QNames is defined by the <code>eq</code> operator.</p>


            
   
         
            
            
            <scrap>
               <prodrecap ref="ItemType"/>
            </scrap>

               
               <p>This section defines the syntax and semantics of different <code>ItemTypes</code>
               in terms of the values that they match.</p>
            
            <note>
               <p>For an explanation of the EBNF grammar notation (and in particular, the operators
               <code>++</code> and <code>**</code>), see <specref ref="id-grammar"/>.</p>
            </note>
            
            <p diff="add" at="A">An <termref def="dt-item-type-designator"/> written simply 
               as an <code>EQName</code>
               (that is, a <code>TypeName</code>) is interpreted as follows:</p>
            
            <olist diff="add" at="A">
               <item><p>If the name is written as a lexical QName, then it is expanded using the
               <termref def="dt-in-scope-namespaces"/> in the <termref def="dt-static-context"/>. If the
               name is an unprefixed <code>NCName</code>, then it is expanded according to the
                  <termref def="dt-default-namespace-elements-and-types"/>.</p></item>
               <item><p>If the name matches a <termref def="dt-named-item-type"/> in the <termref def="dt-static-context"/>,
                  then it is taken as a reference to the corresponding item type. The rules that
               apply are the rules for the expanded item type definition.</p></item>
               <item><p>Otherwise, it must match the name of a type in the <termref def="dt-is-types">in-scope schema types</termref>
                  in the <termref def="dt-static-context"/>: specifically, an <termref def="dt-atomic-type"/>
                  or a <termref def="dt-pure-union-type"/>.
                  See <specref ref="id-predefined-types"/> for details.
                  </p>
               <note><p>A name in the <code>xs</code> namespace will always fall into this category, since the namespace
               is reserved. See <specref ref="id-namespaces-and-qnames"/>.</p></note>
               </item>
               <item><p>If the name cannot be resolved to a type, a <termref def="dt-static-error">static error</termref> 
                  is raised <errorref class="ST" code="0051"/>.</p></item>
                           
            </olist>
            
            
            <div3 id="general-item-types">
               <head>General item types</head>
            <ulist>
               <item><p>
                        <code>item()</code> matches
                        any single <termref def="dt-item">item</termref>.</p>
                     <p>For example, <code>item()</code> matches the atomic
                        item <code>1</code>, the element <code>&lt;a/&gt;</code>, or the function <function>fn:concat#3</function>.</p>
               </item>
               <item>
                  
                     <p>A <nt def="ChoiceItemType"
                        >ChoiceItemType</nt> lists a number of alternative item types in parentheses,
                        separated by <code>"|"</code>. An item matches a <code>ChoiceItemType</code>
                        it if matches any of the alternatives.</p>
                     <p>For example, <code>(map(*) | array(*))</code> matches any item that
                     is a map or an array.</p>
                      <note><p>If there is only one alternative, the <code>ChoiceItemType</code>
                         designates the same <termref def="dt-item-type"/>
                         as the <nt def="ItemType">ItemType</nt> that is in parentheses.
                         A singleton choice (that is, a parenthesized item type) is used primarily 
                         when defining nested item types in a function
                      signature. For example, a sequence of functions that each return a single boolean might be denoted
                      <code>(fn() as xs:boolean)*</code>. In this example the parentheses
                      are needed to indicate where the occurrence indicator belongs.</p></note>
                  
               </item>
            </ulist>
               </div3>
            
            <div3 id="id-atomic-types">
               <head>Atomic Types</head>
               
               <p>Atomic types in the &language; type system correspond directly to atomic types
                  as defined in the <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/>
                 type system.</p>
               
               <p>Atomic types are either built-in atomic types such as <code>xs:integer</code>,
               or user-defined atomic types imported from a schema. Atomic types are identified
               by a QName: see <specref ref="id-namespaces-and-qnames"/>.</p>
               
               <note><p>A schema may also include anonymous atomic types. Such types are
               not usable directly in &language;, though they may appear as the values
               of <termref def="dt-type-annotation">type annotations</termref> on nodes.</p></note>
               

                  
                  <p>
                     <termdef id="dt-generalized-atomic-type" term="generalized atomic type"
                        >A <term>generalized atomic type</term> is an 
                        <termref def="dt-item-type"/> whose instances are all
                        atomic items. Generalized atomic types include (a) 
                        <termref def="dt-atomic-type">atomic types</termref>, either built-in
                        (for example <code>xs:integer</code>) or imported from a schema, 
                        (b) <termref def="dt-pure-union-type">pure union types</termref>, either built-in
                        (<code>xs:numeric</code> and <code>xs:error</code>) or imported from a schema,
                        (c) <termref def="dt-choice-item-type">choice item types</termref> if their alternatives
                        are all generalized atomic types, and 
                        (d) <termref def="dt-enumeration-type">enumeration types</termref>.
                     </termdef>.</p>
                  
                  
                  
                 <!-- <p>
                     <termref def="dt-atomic-type">Atomic types</termref>
                     and <termref def="dt-pure-union-type">pure union types</termref>
                     are usable both as <termref def="dt-schema-type">schema types</termref>
                     and as <termref def="dt-item-type">item types</termref>.</p>-->
                  
                  
                  
                  <p>A <termref def="dt-generalized-atomic-type"/> may be designated by 
                     an <nt def="ItemType">ItemType</nt> in any of the following ways:</p>
                  
                  <ulist>
                     <item><p>Using the QName of a type in the <termref def="dt-issd"/> that is an 
                        <termref def="dt-atomic-type"/>
                     or a <termref def="dt-pure-union-type"/>.</p></item>
                     <item><p>Using a QName that identifies a <termref def="dt-named-item-type"/> that resolves
                        to a <termref def="dt-generalized-atomic-type"/>.</p></item>
                     <item><p>Using a <nt def="ChoiceItemType">ChoiceItemType</nt> where every alternative
                        is itself a <termref def="dt-generalized-atomic-type"/>.</p></item>
                     <!--<item><p>Using a <nt def="LocalUnionType">LocalUnionType</nt> as described below.</p></item>-->
                     <item><p>Using an <nt def="EnumerationType">EnumerationType</nt> as described below.</p></item>
                  </ulist>
               
                  <p diff="add" at="2023-02-20">An atomic item <var>A</var> matches the 
                     <termref def="dt-generalized-atomic-type"/> <var>GAT</var> 
                     if the <termref def="dt-type-annotation">type annotation</termref> of <var>A</var> 
                     <termref def="dt-derives-from"/> <var>GAT</var>.</p>

                     <p>Example: The <nt def="ItemType">ItemType</nt>
                        <code>xs:decimal</code> matches any value of type
    <code>xs:decimal</code>.  It also matches any value of type
                        <code>shoesize</code>, if <code>shoesize</code> is an <termref def="dt-atomic-type"/>
    derived by restriction from <code>xs:decimal</code>.</p>

                     <p>Example: Suppose <nt def="ItemType">ItemType</nt>
                        <code>dress-size</code> is a union type that allows
    either <code>xs:decimal</code> values for numeric sizes (for example: 4, 6, 10, 12),
    or one of an enumerated set of <code>xs:strings</code>
    (for example: <code>small</code>, <code>medium</code>, <code>large</code>). The <nt
                           def="ItemType">ItemType</nt>
                        <code>dress-size</code> matches any of these values.</p>

                     <note>
                        <p>The names of <phrase diff="chg" at="A">list</phrase>
    types such as <code>xs:IDREFS</code> are not accepted in this context,
    but can often be replaced by a <termref
                              def="dt-generalized-atomic-type"
                              >generalized atomic type</termref> with an occurrence indicator, such as
    <code>xs:IDREF+</code>.</p>
                     </note>
               </div3>
            <div3 id="id-union-types">
               <head>Union Types</head>
               
               <p>Union types, as defined in XSD, are a variety of simple types. The membership of
                  a union type in XSD may include list types as well as atomic types and other union types.</p>
               
               <p>
                  <termdef id="dt-pure-union-type" term="pure union type"
                     >A <term>pure union type</term> is a <phrase diff="chg" at="2023-02-20"><term>simple type</term></phrase> 
                     that satisfies the following constraints:
                     (a) <xtermref spec="XS11-1" ref="std-variety">{variety}</xtermref> is <code>union</code>, 
                     (b) the <xtermref spec="XS11-1" ref="std-facets">{facets}</xtermref> property is empty, 
                     (c) no type in the transitive membership of the union type has 
                     <xtermref spec="XS11-1" ref="std-variety">{variety}</xtermref>
                     <code>list</code>, and 
                     (d) no type in the transitive membership of the union type is a type with 
                     <xtermref spec="XS11-1" ref="std-variety">{variety}</xtermref>
                     <code>union</code> having a non-empty <xtermref spec="XS11-1" ref="std-facets">{facets}</xtermref> property</termdef>.</p>
               
               <note>
                  <p>The definition of <termref def="dt-pure-union-type"
                     >pure union type</termref>
                     excludes union types derived by non-trivial restriction from other
                     union types, as well as union types that include list types in their
                     membership. Pure union types have the property that every
                     instance of an <termref def="dt-atomic-type"/> defined as one of the member types of the
                     union is also a valid instance of the union type.</p>
               </note>
               
               <note>
                  <p>The current (second) edition of XML Schema 1.0 contains an
                     error in respect of the substitutability of a union type by one of its
                     members: it fails to recognize that this is unsafe if the union is
                     derived by restriction from another union.</p>
                  
                  <p>This problem is fixed in XSD 1.1, but the effect of the resolution
                     is that an atomic item labeled with an atomic type cannot be treated
                     as being substitutable for a union type without explicit validation.
                     This specification therefore allows union types to be used as item
                     types only if they are defined directly as the union of a number of
                     atomic types.</p>
               </note>
               
               <note><p>Local union types (see <specref ref="id-choice-item-types"/>) and 
                  <termref def="dt-enumeration-type">enumeration types</termref> cannot be
                  used as the target for schema validation.</p></note>
               
               <p><termdef id="dt-numeric" term="numeric">The type <code>xs:numeric</code>
               is defined as a union type with member types <code>xs:double</code>, 
               <code>xs:float</code>, and <code>xs:decimal</code>. An item that
               is an instance of any of these types is referred to as a <term>numeric value</term>,
               and a type that is a subtype of <code>xs:numeric</code> is referred to
               as a <term>numeric type</term>.</termdef></p>
               
            </div3>
            <div3 id="id-namespace-sensitive">
               <head>Namespace-sensitive Types</head>
               
               <p>
                  <termdef term="namespace-sensitive" id="dt-namespace-sensitive"
                     >The <term>namespace-sensitive</term>
                     types are <code>xs:QName</code>, <code>xs:NOTATION</code>, types
                     derived by restriction from <code>xs:QName</code> or
                     <code>xs:NOTATION</code>, list types that have a namespace-sensitive
                     item type, and union types with a namespace-sensitive type in their
                     transitive membership.</termdef>
               </p>
               
               
               <p>It is not possible to preserve the type of a <termref def="dt-namespace-sensitive"
                  >namespace-sensitive</termref> value without also preserving the namespace binding that defines the meaning of each namespace prefix used in the value. Therefore, &language; defines some error conditions that occur only with <termref
                     def="dt-namespace-sensitive"
                     >namespace-sensitive</termref> values. For instance, casting to a <termref
                        def="dt-namespace-sensitive"
                        >namespace-sensitive</termref> type raises 
                  a <termref def="dt-type-error"
                     >type error</termref>
                  <xerrorref spec="FO40" class="NS" code="0004"
                  /> if the namespace bindings for the result cannot be determined. </p>
            </div3>
            <div3 id="id-choice-item-types">
               <head>Choice Item Types</head>
               
               <changes>
                  <change issue="122" PR="1132" date="2024-04-09">
                     Choice item types (an item type allowing a set of alternative item types)
                     are introduced.
                  </change>
               </changes>
               
               <p><termdef id="dt-choice-item-type" term="choice item type">A 
                  <term>choice item type</term> defines an item type that is the union
               of a number of alternatives. For example the type 
               <code>(xs:hexBinary | xs:base64Binary)</code> defines the union of 
                  these two primitive <termref def="dt-atomic-type">atomic types</termref>, 
                  while the type <code>(map(*) | array(*))</code>
               matches any item that is either a map or an array.</termdef></p>
               
               <p>An item matches a <code>ChoiceItemType</code> if it matches any of the 
                  alternatives listed within the parentheses.</p>
               
               
               <p>For example, the type <code>(xs:NCName | enum(""))</code> matches any value that is either
                  an instance of <code>xs:NCName</code>, or a zero-length string. This might be a suitable type for
                  a variable that holds a namespace prefix.</p>
               
               
               <p>If all the alternatives are <termref
                  def="dt-generalized-atomic-type">generalized atomic types</termref>
                  then the <termref def="dt-choice-item-type"/> is itself a generalized atomic type,
               which means, for example, that it can be used as the target of a cast expression.</p>
               
               
               
               <note>
                  <p>A <termref def="dt-choice-item-type"/> in which all the alternatives are atomic
                  behaves in most respects like a schema-defined <termref def="dt-pure-union-type"/>.
                     However, because it can be defined at the point of use (for example,
                     within a function signature), it may be more convenient than defining the type in an
                     imported schema.</p>
               </note>
               
               
                  
               <note>
                  <p>Choice item types are particularly useful in function signatures, 
                     allowing a function to take arguments
                  of a variety of types. If the choice item type is a local union type, 
                  then the semantics are identical to using a named union type, but a local union type is more
                  convenient because it does not need to be defined in a schema, and does not require a schema-aware processor.</p>
                  <p>A local union type can also be used in a cast expression: <code>cast @when as (xs:date | xs:dateTime)</code>
                  allows the attribute <code>@when</code> to be either an <code>xs:date</code>, or an <code>xs:dateTime</code>.</p>
                  <p>An <code>instance of</code> expression can be used to test whether a value belongs to one
                  of a number of specified types: <code>$x instance of (xs:string | xs:anyURI | xs:untypedAtomic)</code>
                  returns <code>true</code> if <code>$x</code> is an instance of any of these three atomic types,
                  while <code>$x instance of (map(*) | array(*))</code> tests whether <code>$x</code> is
                  a map or array.</p>
               </note>
            </div3>
            
            <div3 id="id-enumeration-types" diff="add" at="A">
               <head>Enumeration Types</head>

               <changes>
                  <change issue="688" PR="691" date="2023-10-10">Enumeration types are added as a new kind of <code>ItemType</code>, constraining
                     the value space of strings.</change>
               </changes>
               
 

               <p><termdef id="dt-enumeration-type" term="enumeration type">An <term>EnumerationType</term>
                  accepts a fixed set of string values.</termdef></p>
               <scrap>
                  <prodrecap ref="EnumerationType"/>   
               </scrap>
               
               <p>An <termref def="dt-enumeration-type"/> has a value space consisting of a set of <code>xs:string</code>
                  values. When matching strings against an enumeration type, strings are always compared
               using the Unicode codepoint collation.</p>
               
               <p>For example, if an argument of a function declares the required type 
                  as <code>enum("red", "green", "blue")</code>, then the string <code>"green"</code> is accepted,
                  while <code>"yellow"</code> is rejected with a type error.</p>
               
               <p>Technically, enumeration types are defined as follows:</p>
               
               <ulist>
                  <item><p>An enumeration type with a single enumerated value (such as
                     <code>enum("red")</code>) is an anonymous <termref def="dt-atomic-type"/>
                     derived from <code>xs:string</code> by restriction using an enumeration facet
                     that permits only the value <code>"red"</code>. This is referred to
                     as a <term>singleton enumeration type</term>. It is equivalent to the XSD-defined type:</p>
                  <eg><![CDATA[
<xs:simpleType>
  <xs:restriction base="xs:string">
    <xs:enumeration value="red"/>
  </xs:restriction>
</xs:simpleType>]]></eg></item>
                  <item><p>Two singleton enumeration types are the same type if and only
                  if they have the same (single) enumerated value, as determined using the Unicode
                  codepoint collation.</p></item>
                  <item><p>An enumeration type with multiple
                     enumerated values is a union of singleton enumeration types, 
                     so <code>enum("red", "green", "blue")</code>
                     is equivalent to <code>(enum("red") | enum("green") | enum("blue"))</code>.</p></item>
                  <item><p>In consequence, an enumeration type <var>T</var> is a subtype
                  of an enumeration type <var>U</var> if the enumerated values of <var>T</var>
                  are a subset of the enumerated values of <var>U</var>: 
                     see <specref ref="id-itemtype-subtype"/>.</p></item>
                  
               </ulist>
               
               <p>An enumeration type is thus a <termref def="dt-generalized-atomic-type"/>.</p>
               
               <p>It follows from these rules that an atomic item will only satisfy an <code>instance of</code>
               test if it has the correct type annotation, and this can only be achieved using an explicit cast or
               constructor function. So the expression <code>"red" instance of enum("red", "green", "blue")</code>
               returns <code>false</code>. 
                  However, the <termref def="dt-coercion-rules"/> ensure that where a variable
               or function declaration specifies an enumeration type as the required type, a string 
               (or indeed an <code>xs:untypedAtomic</code> or <code>xs:anyURI</code> value) equal
               to one of the enumerated values will be accepted.</p>
               
               <note>
                  <p>Some consequences of these rules may not be immediately apparent.</p>
                  <p>Suppose that an XQuery query contains the declarations:</p>
                  <eg>
declare type my:color := enum("red", "green", "orange");
declare type my:fruit := enum("apple", "orange", "banana");
declare variable $orange-color as my:color := "orange";
declare variable $orange-fruit as my:fruit := "orange";
                  </eg>
                  <p>The same applies with the equivalent XSLT syntax:</p>
                  <eg><![CDATA[
<xsl:item-type name="my:color" as="enum('red', 'green', 'orange')"/>
<xsl:item-type name="my:fruit" as="enum('apple', 'orange', 'banana')"/>
<xsl:variable name="orange-color" as="my:color" select="'orange'"/>
<xsl:variable name="orange-fruit" as="my:fruit" select="'orange'"/>
                     ]]></eg>
                  <p>Now, the value of <code>$orange-color</code> is an atomic item whose datum
                  is the string <code>"orange"</code>, and whose type annotation is the anonymous
                  type designated <code>enum("orange")</code>. Similarly, the value of 
                     <code>$orange-fruit</code> is an atomic item whose datum
                  is the string <code>"orange"</code>, and whose type annotation is the anonymous
                  type designated <code>enum("orange")</code>. That is, the values of the two
                     variables are indistinguishable and interchangeable in every way. In particular,
                  both values are instances of <code>my:color</code>,
                  and both are instances of <code>my:fruit</code>.</p>
                  
                  <p>This way of handling enumeration values has advantages and disadvantages.
                  On the positive side, it means that enumeration subsets and supersets work
                  cleanly: a value that is an instance of <code>enum("red", "green", "orange")</code>
                  can be used where an instance of <code>enum("red", "orange", "yellow", "green", "blue", "indigo",
                     "violet")</code> is expected. The downside is that labeling a string as an instance
                  of an enumeration type does not provide type safety: a function that expects an instance
                  of <code>my:color</code> can be called with any string that matches one of the required
                  colors, whether or not it has an appropriate type annotation. A function that expects a color
                  can be successfully called passing a fruit, if they happen to have the same name.</p>
               </note>
               
 
            </div3>   

               

            <div3 id="node-types">
               <head>Node Types</head>
               
               <changes>
                  <change issue="107" PR="286" date="2023-01-17">
                     Element and attribute tests can include alternative names: <code>element(chapter|section)</code>,
                     <code>attribute(role|class)</code>.
                  </change>
                  <change issue="107" PR="286" date="2023-01-17">
                     The <code>NodeTest</code> in an <code>AxisStep</code> now allows alternatives: 
                     <code>ancestor::(section|appendix)</code>
                  </change>
                  <change issue="1593" date="2024-11-24">
                     The syntax <code>document-node(<var>N</var>)</code>, where <var>N</var> is a <code>NameTestUnion</code>,
                     is introduced as an abbreviation for <code>document-node(element(<var>N</var>))</code>. For example,
                     <code>document-node(*)</code> matches any well-formed XML document (as distinct from a document fragment).
                  </change>
               </changes>
               
               <p>Node types are <termref def="dt-item-type">item types</termref> whose 
                  instances are all <termref def="dt-node">nodes</termref>.</p>
               
               <p>The syntax for node types is also used for <termref def="dt-node-test">node tests</termref>
               within path expressions. This explains why the production rules have names such as
               <code>NodeTest</code> rather than <code>NodeType</code>.</p>
               
               <p>Some of the constructs described in this section include a <nt def="TypeName">TypeName</nt>. This appears 
                  as <var>T</var> in:</p>
               
               <ulist>
                  <item><p><code>element(N, T)</code></p></item>
                  <item><p><code>attribute(N, T)</code></p></item>
                  <item><p><code>document-node(element(N, T))</code></p></item>
               </ulist>
               
               <p>Like other lexical QNames, the type name <var>T</var> is expanded using the <termref def="dt-in-scope-namespaces"/>
                  in the <termref def="dt-static-context"/>, using the <termref def="dt-default-namespace-elements-and-types"/> 
                  if it is unprefixed. The resulting
               QName must identify a type in the <termref def="dt-issd"/>. This can be any <termref def="dt-schema-type"/>: either a simple type,
               or (except in the case of attributes) a complex type. If it is a simple type then it can be an atomic, union, or
               list type. It can be a built-in type (such as <code>xs:integer</code>) or a user-defined type. It must however
               be the name of a type defined in a schema; it cannot be a <termref def="dt-named-item-type"/>.</p>
            
              
            
            
               <div4 id="id-simple-node-tests">
                  <head>Simple Node Types</head>
               <ulist>

                  <item>
                     <p>
                        <code>node()</code>
    matches any node.</p>
                  </item>

                  <item>
                     <p>
                        <code>text()</code> matches any
    text node.</p>
                  </item>

                  <item>
                     <p>
                        <code>processing-instruction()</code>
    matches any processing-instruction
    node.</p>
                  </item>

                  <item>
                     <p at="XQ.E27 and XP.E19">
                        <code>processing-instruction(</code>
                        <emph>N</emph>
                        <code>)</code>
    matches any processing-instruction node whose PITarget is equal to <code
                           role="parse-test"
                           >fn:normalize-space(N)</code>. If the result of <code>fn:normalize-space(N)</code> is not in the lexical space of NCName, a type error is raised <errorref
                           class="TY" code="0004"/>
                     </p>

                     <p>Example:
    <code role="parse-test"
                           >processing-instruction(xml-stylesheet)</code> matches any
    processing instruction whose PITarget is
    <code>xml-stylesheet</code>.</p>

                     <p>For backward compatibility with
    XPath 1.0, the PITarget of a
    processing instruction may also be expressed as a
    string literal, as in this example:
    <code
                           role="parse-test">processing-instruction("xml-stylesheet")</code>.</p>
                     <p>If the specified PITarget is not a syntactically valid NCName, a type error is raised <errorref
                           class="TY" code="0004"/>.</p>
                  </item>


                  <item>
                     <p>
                        <code role="parse-test">comment()</code> matches any comment node.</p>
                  </item>




                  <item>
                     <p>
                        <code role="parse-test"
                        >namespace-node()</code> matches any
    namespace node.</p>
                  </item>




                  <item>
                     <p>
                        <code role="parse-test"
                        >document-node()</code> matches any document
    node.</p>
                  </item>

                  <item>
                     <p>
                        <code>document-node(</code>
                        <emph>E</emph>
                        <code>)</code>, where <var>E</var> is an <nt
                           def="ElementTest">ElementTest</nt> or <nt def="SchemaElementTest"
                           >SchemaElementTest</nt> (see <specref
                           ref="id-element-test"/> and <specref ref="id-schema-element-test"/>)
    matches any document node whose children comprise (in any order) zero or more
    comment and processing instruction nodes, zero text nodes, and exactly one element node,
    which itself must match <var>E</var>.</p>
                     <p>Example:
    <code role="parse-test"
                           >document-node(element(book))</code> matches a document node
    containing
    exactly one element node that is matched by the ElementTest
    <code
                           role="parse-test">element(book)</code>.</p>
                  </item>
                  
                  <item><p>The construct <code>document-node(<var>NTU</var>)</code>, where
                  <var>NTU</var> is a <nt def="NameTestUnion">NameTestUnion</nt>, is
                  an abbreviation for <code>document-node(element(<var>NTU</var>))</code>.
                  For example, <code>document-node(*)</code> is an abbreviation for
                  <code>document-node(element(*))</code>, which matches any document node
                  corresponding to a well-formed XML document, that is, one that has
                  one element child, zero or more comment and processing-instruction children,
                  and no text node children.</p></item>

 
                  <item>
                     <p>An <nt def="ItemType">ItemType</nt> that is an
    <nt def="ElementTest"
                           >ElementTest</nt>, <nt def="SchemaElementTest"
                           >SchemaElementTest</nt>, <nt def="AttributeTest"
                           >AttributeTest</nt>,
    <nt def="SchemaAttributeTest"
                           >SchemaAttributeTest</nt>, or <nt def="FunctionType"
                        >FunctionType</nt> matches an item as described in the following sections.
    </p>
                  </item>

                  
               </ulist>
            </div4>
                  
               
            <div4 id="id-element-test">
               <head>Element Types</head>
               
               <changes>
                  <change issue="107" PR="286" date="2023-01-17">
                     Element and attribute tests of the form <code>element(N)</code>
                     and <code>attribute(N)</code> now allow <code>N</code> to be any <code>NameTest</code>,
                     including a wildcard.
                  </change>
                  <change issue="23" PR="606" date="2023-01-17">
                     Element and attribute tests of the form <code>element(A|B)</code>
                     and <code>attribute(A|B)</code> are now allowed.
                  </change>
                  <change>
                     Setting the default namespace for elements and types to the special value
                     <code>##any</code> causes an unprefixed element name to act as a wildcard,
                     matching by local name regardless of namespace.
                  </change>
               </changes>

               <scrap>
                  <prodrecap ref="ElementTest"/>
               </scrap>


               <p>
    An <nt def="ElementTest"
                     >ElementTest</nt> is used to match an
    element node by its name and/or <termref
                     def="dt-type-annotation">type annotation</termref>.
  </p>
               
               <p diff="chg" at="Issue372">An unprefixed <nt def="EQName">EQName</nt>
                  within the <code>NameTestUnion</code> is interpreted according to the
                  <termref def="dt-default-namespace-elements-and-types"/>.
                  The name need not be present in the <termref
                     def="dt-is-attrs">in-scope element declarations</termref>.
               </p>
               <p>If the <termref def="dt-default-namespace-elements-and-types"/>
               has the special value <code>##any</code>, then an unprefixed name
               <var>N</var> is interpreted as a wildcard <code>*:<var>N</var></code>.</p>
               <p>It is always possible to match no-namespace names explicitly
               by using the form <code>Q{}<var>N</var></code></p>
               
               <p diff="chg" at="Issue23">An unprefixed <nt def="TypeName"
                  >TypeName</nt> is interpreted according to the
                  <termref def="dt-default-namespace-elements-and-types"/>.
                  The <nt def="TypeName">TypeName</nt> must be present in the <termref def="dt-is-types"
                     >in-scope schema types</termref>
                  <errorref class="ST" code="0008"/>                 
                  
                  </p>
               <p>If the <termref def="dt-default-namespace-elements-and-types"/>
                  has the special value <code>##any</code>, then an unprefixed type name
                  <var>T</var> is interpreted as <code>Q{http://www.w3.org/2001/XMLSchema}<var>T</var></code>.</p>
                     
               <note><p><termref
                     def="dt-substitution-group"
                     >Substitution groups</termref> do not affect the semantics of <nt
                        def="ElementTest">ElementTest</nt>.</p></note>
         
         
               <p diff="chg" at="Issue23">An <nt def="ElementTest">ElementTest</nt>
                  <var>ET</var> matches an item <var>E</var> if the following conditions
                  are satisfied:</p>
                     
                     <olist>
                        <item><p><var>E</var> is an element node.</p></item>
                        <item><p>If <var>ET</var> includes a <nt def="NameTestUnion">NameTestUnion</nt>,
                           then the name of the element node <var>E</var> matches one or more of
                           the <nt def="NameTest">NameTests</nt> in the <nt def="NameTestUnion">NameTestUnion</nt>.
                           A name <var>N</var> matches a <nt def="NameTest">NameTest</nt> <var>NT</var> if one of the following
                           conditions is true:</p>
                           <olist>
                              <item><p><var>NT</var> is <code>*</code></p></item>
                              <item><p><var>NT</var> is <code>*:<emph>local</emph></code> and the local part
                                 of <var>N</var> is <var>local</var>.</p></item>
                              <item><p><var>NT</var> is <code><emph>prefix</emph>:*</code> and the namespace URI
                                 of <var>N</var> matches the namespace URI bound to <var>prefix</var> in the static
                                 context.</p></item>
                              <item><p><var>NT</var> is <code><emph>BracedURILiteral</emph>*</code> and the namespace URI
                                 of <var>N</var> matches the namespace URI found in the <code>BracedURILiteral</code>.</p></item>
                              <item><p><var>NT</var> is an <code>EQName</code> equal to <var>N</var>.</p></item>
                           </olist>
                        </item>
                        <item><p>If <var>ET</var> includes a <nt def="TypeName">TypeName</nt> <var>T</var>,
                           then the <termref def="dt-type-annotation"/> of the element node <var>E</var>
                           <termref def="dt-derives-from"/> <var>T</var>.</p></item>
                        <item><p>If <var>E</var> has the <code>nilled</code> property, then <var>ET</var>
                           either includes no <nt def="TypeName">TypeName</nt>, 
                           or includes a <nt def="TypeName">TypeName</nt> followed by the symbol <code>?</code>.</p></item>
                     </olist>

               <p>Here are some examples of <nt def="ElementTest">ElementTests</nt>:</p>


               <olist>

                  <item>
                     <p>
                        <code role="parse-test">element()</code> and

<code role="parse-test"
                           >element(*)</code>  match any
single element node, regardless of its name or
type annotation.</p>
                  </item>

                  <item>
                     <p>
                        <code role="parse-test"
                           >element(person)</code> matches any element node whose name is <code>person</code>,
                        in the <termref def="dt-default-namespace-elements-and-types"/>.</p>
                  </item>
                  
                  <item>
                     <p>
                        <code role="parse-test"
                           >element(doctor|nurse)</code> matches any element node whose name is 
                        <code>doctor</code> or <code>nurse</code>,
                        in the <termref def="dt-default-namespace-elements-and-types"/>.</p>
                  </item>

                  <item diff="add" at="A">
                     <p><code role="parse-test"
                           >element(xhtml:*)</code> matches any element node whose name is in the namespace
                        bound to the prefix <code>xhtml</code>.</p>
                  </item>
                  
                  <item diff="add" at="A">
                     <p><code role="parse-test"
                        >element(xhtml:*|svg:*|mathml:*)</code> matches any element node whose name is one of the
                        three namespaces identified, specifically the namespaces bound to the prefixes
                        <code>xhtml</code>, <code>svg</code>, and <code>mathml</code>.</p>
                  </item>

                  <item diff="add" at="A">
                     <p><code role="parse-test"
                           >element(Q{http://www.w3.org/2000/svg}*)</code> matches any element node whose name is in the SVG namespace.</p>
                  </item>

                  <item diff="add" at="A">
                     <p>
                        <code role="parse-test"
                        >element(*:html)</code> matches any element node whose local name is <code>"html"</code>,
                     in any namespace.</p>
                  </item>

                  <item>
                     <p><code role="parse-test"
                           >element(person, surgeon)</code> matches a
non-nilled element node whose name is <code>person</code> and whose
type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>). </p>
                     
                  </item>

                  <item>
                     <p><code role="parse-test"
                           >element(person, surgeon?)</code> matches a nilled or non-nilled element node whose name is <code>person</code> and whose type
annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>).</p>
                     
                  </item>





                  <item>
                     <p><code role="parse-test"
                           >element(*, surgeon)</code>
matches any non-nilled element node whose type annotation is
<code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</p>
                  </item>

                  <item>
                     <p><code role="parse-test"
                           >element(*, surgeon?)</code>
matches any nilled or non-nilled element node whose type annotation is
<code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</p>
                  </item>
               </olist>
               
               <p diff="add" at="Issue451">
                  Where a <nt def="TypeName">TypeName</nt> is included in an 
                  <nt def="ElementTest">ElementTest</nt> <var>T</var>, an element node will only
                  match the test if it has been validated against a schema that 
                  defines type <var>T</var>; furthermore, <var>T</var> must be
                  present in the <termref def="dt-issd"/> of the static context of the
                  <nt def="ElementTest">ElementTest</nt>. Although it is guaranteed that
                  type <var>T</var> will have 
                  <xtermref spec="DM40" ref="dt-schema-compatible">compatible</xtermref>
                  definitions in the schema that was used for validation and in the
                  <termref def="dt-issd"/>, it is not guaranteed that revalidation
                  using the <termref def="dt-issd"/> would succeed. For example, if
                  substitution group membership varies between the two schemas, the element
                  node may contain children or descendants that the <termref def="dt-issd"/>
                  would not allow.
               </p>
               
               <note><p>Technically, <code>element(p|q)</code> is not the same type as
               the choice item type <code>(element(p)|element(q))</code>. However, (a)
               they match exactly the same set of element nodes, and (b) each is a subtype
               of the other, so in practice they are indistinguishable.</p></note>

            
               

            <div5 id="id-schema-element-test">
               <head>Schema Element Types</head>

               <scrap>
                  <prodrecap ref="SchemaElementTest"/>
               </scrap>

               <p>
    A <nt def="SchemaElementTest"
                     >SchemaElementTest</nt> matches an element node against a corresponding
    element declaration found in the <termref
                     def="dt-is-elems">in-scope element declarations</termref>.
  </p>

               <p>
    The <nt def="ElementName">ElementName</nt> of a <nt def="SchemaElementTest"
                     >SchemaElementTest</nt>
    has its prefixes expanded to a namespace URI by means of the
    <termref
                     def="dt-static-namespaces"
                     >statically known namespaces</termref>, or if unprefixed, the
                  is interpreted according to the
                  <termref def="dt-default-namespace-elements-and-types"/>. If this has the special
                  value <code>"##any"</code>, an unprefixed name represents a name in no namespace.

    If the <nt
                     def="ElementName">ElementName</nt> specified in the <nt def="SchemaElementTest"
                     >SchemaElementTest</nt>
    is not found in the <termref def="dt-is-elems"
                     >in-scope element declarations</termref>, a
    <termref def="dt-static-error"
                     >static error</termref> is raised <errorref class="ST" code="0008"/>.
  </p>

               <p>
    A <nt def="SchemaElementTest"
                  >SchemaElementTest</nt> matches a candidate element node if all of the following conditions are satisfied:
  </p>

               <olist>
                  <item>
                     <p>Either:</p>
                     <olist>
                        <item>
                           <p>The name <var>N</var> of the candidate node matches the specified <nt
                                 def="ElementName">ElementName</nt>, or</p>
                        </item>
                        <item>
                           <p>The name <var>N</var> of the candidate node matches the name of an element declaration that is a member of the actual substitution group headed by the declaration of element <nt
                                 def="ElementName">ElementName</nt>.</p>
                        </item>

                     </olist>

                     <note>
                        <p>The term “actual substitution group” is defined in <bibref
                              ref="XMLSchema11"
                              />. The actual substitution group of an element declaration 
                           <var>H</var> includes those element declarations 
                           <var>P</var> that are declared to have <var>H</var> as their 
                           direct or indirect substitution group head, provided that 
                           <var>P</var> is not declared as abstract, and that <var>P</var> 
                           is validly substitutable for <var>H</var>, which means that 
                           there must be no blocking constraints that prevent substitution.</p>
                     </note>
                  </item>

                  <item>
                     <p>The schema element declaration named <var>N</var> is not abstract.</p>
                  </item>

                  <item>
                     <p><var>AT</var> <termref def="dt-derives-from"/> <var>ET</var>,
                        where <var>AT</var> is the type annotation of the candidate node 
                        and <var>ET</var> is the schema type declared in the schema element 
                        declaration named <var>N</var>.</p>
                  </item>

                  <item>
                     <p>If the schema element declaration named <var>N</var> 
                        is not nillable, then the <code>nilled</code> property of the candidate node 
                        is <code>false</code>.</p>
                  </item>

               </olist>

               <p>Example: The <nt def="SchemaElementTest">SchemaElementTest</nt>
                  <code role="parse-test">schema-element(customer)</code> matches a candidate element node 
in the following two situations:
<olist>
                     <item>
                        <p>customer is a top-level element declaration in the in-scope element declarations; the name of the candidate node is customer; the element declaration of customer is not abstract; the type annotation of the candidate node is the same as or derived from the schema type declared in the customer element declaration; and either the candidate node is not nilled, or customer is declared to be nillable.</p>
                     </item>
                     <item>
                        <p>customer is a top-level element declaration in the in-scope element declarations; the name of the candidate node is client; client is an actual (non-abstract and non-blocked) member of the substitution group of customer; the type annotation of the candidate node is the same as or derived from the schema type declared for the client element; and either the candidate node is not nilled, or client is declared to be nillable.</p>
                     </item>
                  </olist>
               </p>
               
               <p diff="add" at="Issue451">
                  In the case where the schema <var>X</var> used to validate an element node 
                  <var>E</var> (whose name is <var>N</var>)
                  differs from the schema <var>Y</var> represented by the
                  <termref def="dt-issd"/> in the static context of the 
                  <nt def="SchemaElementTest">SchemaElementTest</nt>, the following
                  considerations apply:</p>
               
               <ulist>
                  <item><p>In applying the test <code><var>AT</var> derives-from <var>ET</var></code>,
                  note that <var>AT</var> will necessarily be present in <var>X</var>,
                  but not necessarily in <var>Y</var>. However, <var>ET</var> will 
                  necessarily be present in both; and because the two schemas
                  must be <xtermref spec="DM40" ref="dt-schema-compatible">compatible</xtermref>,
                  <var>ET</var> will be the present in both schemas, will have the same
                  definition in both, and will be the declared type of <var>N</var> in both.
                  The test can therefore be applied from knowledge of type <var>AT</var>
                  as defined in schema <var>X</var>.</p></item>
                  <item><p>The test as to whether the element name <var>N</var> is a member
                  of the actual substitution group is performed entirely by reference
                  to schema <var>Y</var>. Although the two schemas are compatible,
                  substitution group membership can vary.</p></item>
               </ulist>
      

            </div5>
            </div4>
            <div4 id="id-attribute-test">
               <head>Attribute Types</head>
               
               <changes>
                  <change issue="107" PR="286" date="2023-01-17">
                     Element and attribute tests of the form <code>element(N)</code>
                     and <code>attribute(N)</code> now allow <code>N</code> to be any <code>NameTest</code>,
                     including a wildcard.
                  </change>
                  <change issue="23" PR="606" date="2023-01-17">
                     Element and attribute tests of the form <code>element(A|B)</code>
                     and <code>attribute(A|B)</code> are now allowed.
                  </change>
               </changes>

               <scrap>
                  <prodrecap id="AttributeTest" ref="AttributeTest"/>
               </scrap>


               <p>
    An <nt def="AttributeTest"
                     >AttributeTest</nt> is used to match an
    attribute node by its name and/or <termref
                     def="dt-type-annotation">type annotation</termref>.
  </p>

               <p diff="chg" at="Issue23">An unprefixed <nt def="EQName">EQName</nt>
               within the <code>NameTestUnion</code> refers to a name in no namespace.
                  The name need not be present in the <termref
                     def="dt-is-attrs">in-scope attribute declarations</termref>.</p>
               
               <p diff="chg" at="Issue23">An unprefixed <nt def="TypeName"
                  >TypeName</nt> is interpreted according to the
                  <termref def="dt-default-namespace-elements-and-types"/>.
                  The <nt def="TypeName">TypeName</nt> must be present in the <termref def="dt-is-types"
                        >in-scope schema types</termref>
                  <errorref class="ST" code="0008"/>
               </p>
     
 
               
                  
                  <p diff="chg" at="Issue23">An <nt def="AttributeTest">AttributeTest</nt>
                     <var>AT</var> matches an item <var>A</var> if the following conditions
                     are satisfied:</p>
                  
                  <olist>
                     <item><p><var>A</var> is an attribute node.</p></item>
                     <item><p>If <var>AT</var> includes a <nt def="NameTestUnion">NameTestUnion</nt>,
                        then the name of the attribute node <var>A</var> matches one or more of
                        the <nt def="NameTest">NameTests</nt> in the <nt def="NameTestUnion">NameTestUnion</nt>.
                        A name <var>N</var> matches a <nt def="NameTest">NameTest</nt> <var>NT</var> if one of the following
                        conditions is true:</p>
                        <olist>
                           <item><p><var>NT</var> is <code>*</code></p></item>
                           <item><p><var>NT</var> is <code>*:<emph>local</emph></code> and the local part
                           of <var>N</var> matches <var>local</var>.</p></item>
                           <item><p><var>NT</var> is <code><emph>prefix</emph>:*</code> and the namespace URI
                           of <var>N</var> matches the namespace URI bound to <var>prefix</var> in the static
                           context.</p></item>
                           <item><p><var>NT</var> is <code><emph>BracedURILiteral</emph>*</code> and the namespace URI
                              of <var>N</var> matches the namespace URI found in the <code>BracedURILiteral</code>.</p></item>
                           <item><p><var>NT</var> is an <code>EQName</code> equal to <var>N</var>.</p></item>
                        </olist>
                     </item>
                     <item><p>If <var>AT</var> includes a <nt def="TypeName">TypeName</nt> <var>T</var>,
                        then the <termref def="dt-type-annotation"/> of the attribute node <var>A</var>
                        <termref def="dt-derives-from"/> <var>T</var>.</p></item>
                  </olist>
    <p>Here are some examples of <nt def="AttributeTest"
                  >AttributeTests</nt>:
  </p>
               <ulist>
                  <item>
                     <p>
                        <code role="parse-test">attribute()</code> and <code role="parse-test"
                           >attribute(*)</code> match any single attribute node,
regardless of its name or type annotation.</p>
                  </item>



                  <item>
                     <p>
                        <code role="parse-test">attribute(price)</code>
                        matches any attribute node whose name is <code>price</code>
                        (in no namespace), regardless of its type annotation.</p>
                     
                  </item>
                  
                  <item diff="add" at="Issue23">
                     <p>
                        <code role="parse-test">attribute(price|discount)</code>
                        matches any attribute node whose name is <code>price</code> or <code>discount</code>
                        (in no namespace).</p>
                  </item>

                  <item diff="add" at="A">
                     <p>
                        <code role="parse-test"
                           >attribute(xlink:*)</code> matches any attribute node whose name is in the namespace
                        bound to the prefix <code>xlink</code>.</p>
                  </item>

                  <item diff="add" at="A">
                     <p><code role="parse-test"
                           >element(Q{http://www.w3.org/2000/svg}*)</code> matches any attribute node whose name is in the SVG namespace.</p>
                  </item>

                  <item diff="add" at="A">
                     <p><code>attribute(*:default-collation)</code> matches any attribute node
                        whose local name is <code>default-collation</code>,
                        regardless of namespace, and regardless of type annotation.</p>
                  </item>
                  
                  <item diff="add" at="Issue23">
                     <p><code>attribute(*:price|*:discount)</code> matches any attribute node
                        whose local name is <code>price</code> or <code>discount</code>,
                        regardless of namespace, and regardless of type annotation.</p>
                  </item>


                  <item>
                     <p><code role="parse-test"
                           >attribute(price, currency)</code> matches an
attribute node whose name is <code>price</code> (in no namespace) and whose type
annotation is
<code>currency</code> (or is derived from <code>currency</code>).</p>
                  </item>
                  
                  <item diff="add" at="A">
                     <p>
                        <code role="parse-test"
                           >attribute(xlink:*, xs:string)</code> matches any attribute node whose name is in the namespace
                        bound to the prefix <code>xlink</code>, and whose type annotation is <code>xs:string</code>
                     or a type derived from <code>xs:string</code>.</p>
                  </item>
                  

                  <item>
                     <p><code role="parse-test"
                           >attribute(*, currency)</code> matches any attribute node whose
type annotation is <code>currency</code> (or is derived from <code>currency</code>), regardless of its
name.</p>

                  </item>

               </ulist>
               <p diff="add" at="Issue451">
                  Unlike the situation with an <nt def="ElementTest">ElementTest</nt>,
                  few problems arise if the attribute was validated using a different
                  schema. This is because simple types can never be derived by extension,
                  and attributes do not have substitution groups.</p>
               
               <note><p>Technically, <code>attribute(p|q)</code> is not the same type as
               the choice item type <code>(attribute(p)|attribute(q))</code>. However, (a)
               they match exactly the same set of attribute nodes, and (b) each is a subtype
               of the other, so in practice they are indistinguishable.</p></note>
            

            <div5 id="id-schema-attribute-test">
               <head>Schema Attribute Types</head>

               <scrap>
                  <prodrecap ref="SchemaAttributeTest"/>
               </scrap>

               <p>
    A <nt def="SchemaAttributeTest"
                     >SchemaAttributeTest</nt> matches an attribute node against a corresponding
    attribute declaration found in the <termref
                     def="dt-is-attrs">in-scope attribute declarations</termref>.
  </p>
               <p>
    The <nt def="AttributeName">AttributeName</nt> of a <nt
                     def="SchemaAttributeTest"
                     >SchemaAttributeTest</nt>
    has its prefixes expanded to a namespace URI by means of the
    <termref
                     def="dt-static-namespaces"
                     >statically known namespaces</termref>. If unprefixed, an
    <nt
                     def="AttributeName">AttributeName</nt> is in no namespace.

    If the <nt
                     def="AttributeName">AttributeName</nt> specified in the <nt
                     def="SchemaAttributeTest"
                     >SchemaAttributeTest</nt>
    is not found in the <termref def="dt-is-attrs"
                     >in-scope attribute declarations</termref>, a
    <termref
                     def="dt-static-error">static error</termref> is raised <errorref class="ST"
                     code="0008"/>.
  </p>
               <p>
    A <nt def="SchemaAttributeTest"
                  >SchemaAttributeTest</nt> matches a candidate attribute node if both of the
  following conditions are satisfied:
  </p>
               <olist>

                  <item>
                     <p>The name of the candidate node matches the specified <nt def="AttributeName"
                           >AttributeName</nt>.</p>
                  </item>

                  <item>
                     <p><var>AT</var> <termref def="dt-derives-from"/> <var>ET</var>,
                        where <var>AT</var> is the type annotation of the candidate node and 
                        <var>ET</var> is the schema type declared for attribute <nt
                           def="AttributeName">AttributeName</nt> in the <termref def="dt-is-attrs"
                           >in-scope attribute declarations</termref>.</p>
                  </item>
               </olist>
               <p>Example: The <nt def="SchemaAttributeTest">SchemaAttributeTest</nt>
                  <code role="parse-test"
                     >schema-attribute(color)</code> matches a candidate attribute node if <code>color</code> is a top-level attribute declaration in the <termref
                     def="dt-is-attrs"
                     >in-scope attribute declarations</termref>, the name of the candidate node is <code>color</code>, and the type annotation of the candidate node  is the same as or derived from the schema type declared for the <code>color</code> attribute.</p>
               <p diff="add" at="Issue451">
                  Unlike the situation with a <nt def="SchemaElementTest">SchemaElementTest</nt>,
                  few problems arise if the attribute was validated using a different
                  schema. This is because attributes do not have substitution groups.</p>
            </div5>
            </div4>
         </div3>
         <div3 id="id-function-map-array-tests">
            <head>Function, Map, and Array Types</head>
            
            <p>The following sections describe the syntax for <termref def="dt-item-type">item types</termref>
            for functions, including arrays and maps.</p>
            
            <p>The <termref def="dt-subtype"/> relation among these types is described in the various subsections
            of <specref ref="id-itemtype-subtype"/>.</p>
            
            <div4 id="id-function-test">
               <head>Function Types</head>
               <changes>
                  <change issue="1192" PR="1197" date="2024-05-21">The keyword <code>fn</code> is allowed as a synonym for <code>function</code>
                  in function types, to align with changes to inline function declarations.</change>
                  <change>The terms <term>FunctionType</term>, <term>ArrayType</term>,
                     <term>MapType</term>, and <term>RecordType</term> replace 
                     <term>FunctionTest</term>, <term>ArrayTest</term>,
                     <term>MapTest</term>, and <term>RecordTest</term>, with no
                  change in meaning.</change>
                  <change issue="1136" date="2025-01-12">
                     Parameter names may be included in a function signature; they are purely
                     documentary.
                  </change>
               </changes>
               
               <p>A <nt def="FunctionType">FunctionType</nt> matches selected <termref 
                     def="dt-function-item">function items</termref>,
                  potentially checking their <xtermref spec="DM40"
                     ref="dt-signature">signature</xtermref>
                  (which includes the types of the arguments and results).</p>

               
               <scrap>
                  <prodrecap ref="FunctionType"/>
               </scrap>


    <p>The keywords <code>function</code> and <code>fn</code> are synonyms.</p>
               
               <p role="xquery">If the <nt def="FunctionType"/> contains an 
               <nt def="Annotation"/>, then this is interpreted as a
               <termref def="dt-function-assertion"/>, as described below.</p>
               
    <p>An <nt def="AnyFunctionType">AnyFunctionType</nt>
    matches any <termref def="dt-function-item"/>, including a map or an array. For example,
    the following expressions all return true:</p>
               
               <ulist>
                  <item><p><code>fn:name#1 instance of function(*)</code></p></item>
                  <item><p><code>fn{@id} instance of function(*)</code></p></item>
                  <item><p><code>fn:random-number-generator() instance of function(*)</code></p></item>
                  <item><p><code>[1, 2, 3] instance of fn(*)</code></p></item>
                  <item><p><code>{} instance of fn(*)</code></p></item>
               </ulist>

    <p>A <nt def="TypedFunctionType">TypedFunctionType</nt> matches
    a <termref  def="dt-function-item"/> if the function’s type signature (as defined in
    <xspecref spec="DM40" ref="function-items"/>) is a <termref def="dt-subtype"
                     >subtype</termref> of the <nt def="TypedFunctionType"
                  >TypedFunctionType</nt>.</p>
               

               <note><p>The keywords <code>function</code> and <code>fn</code> are synonymous.</p></note>

               <p>If parameter names are included in a <nt def="TypedFunctionType">TypedFunctionType</nt>,
               they are purely documentary and have no semantic effect. In particular, they
               play no part in deciding whether a particular function item matches the
               function type, and they never appear as keywords in function calls. 
               For example the construct
               <code>function($x as node()) as xs:string</code> designates exactly the same type
               as <code>function(node()) as xs:string</code>.</p>
               
               <p>Any parameter names that are supplied must be distinct 
                  <errorref spec="XQ" class="ST" code="0039"/>.</p>
               
               <p diff="add" at="issue730">A <nt def="TypedFunctionType">TypedFunctionType</nt>
               may also match certain maps and arrays, as described in <specref ref="id-map-test"/> and
               <specref ref="id-array-test"/></p>

              

               <p>
    Here are some examples of expressions that 
    use a <nt def="TypedFunctionType">TypedFunctionType</nt>:
  </p>
               <ulist>
                  <item>
                     <p>
                        <code>fn:count#1 instance of function(item()*) as xs:integer</code> returns true,
                        because the signature of the function item <code>fn:count#1</code>
                        is <code>function(item()*) as xs:integer</code>.
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>fn:count#1 instance of function(xs:string*) as item()</code> returns true,
                        because the signature of the function item <code>fn:count#1</code>
                        is a subtype of <code>function(xs:string*) as item()</code>.
                     </p>

                     <note><p>The same type might also be written 
                        <code>fn($x as xs:int, $y as xs:int) as xs:int</code>.</p></note>

                  </item>
                  <item role="xquery">
                     <p>
                        <code>$F instance of %my:assertion function(*)</code> is true if
                        <code>$F</code> is a <termref 
                           def="dt-function-item"
                           >function</termref> that satisfies the implementation-defined 
                        function assertion <code>%my:assertion</code>.
    </p>
                  </item>
                  <item role="xquery">
                     <p>
                        <code>$F instance of %my:assertion function(xs:int, xs:int) as xs:int</code> 
                        is true if <code>$F</code> is a <termref
                           def="dt-function-item"/> with the function signature <code>function(xs:int, xs:int) as xs:int</code> 
                        that satisfies the implementation-defined function assertion <code>%my:assertion</code>.
    </p>
                  </item>
                  <item>
                     <p>
                        <code>function(xs:anyAtomicType) as item()*</code> matches any map, 
                        or any other function item with the required signature.</p>
                  </item>
                  <item>
                     <p>
                        <code>function(xs:integer) as item()*</code> matches any array, 
                        or any other function item with the required signature.</p>
                  </item>
               </ulist>

               <p id="id-function-assertion" role="xquery">
                  <termdef id="dt-function-assertion" term="function assertion"
                        > A
    <term>function assertion</term> is a predicate that restricts the
    set of functions matched by a FunctionType. It uses the same
    syntax as <specref
                        ref="id-annotations"
                  />.</termdef> &language; does not currently
    define any function assertions, but future versions may. Other
    specifications in the XQuery family may also use function
    assertions in the future.</p>
               
               <p role="xquery">An unprefixed QName used 
                  within a <termref def="dt-function-assertion"/> is taken to refer to the namespace
                  <code>http://www.w3.org/2012/xquery</code>. Since this is a 
                  <termref def="dt-reserved-namespaces">reserved namespace</termref>,
                  and no assertions are currently defined in this namespace, this means that
                  in practice, use of an unprefixed QName is always an error.
               </p>

               <p role="xquery"
                  >Implementations are free to define their own function
    assertions, whose behavior is completely implementation-defined. Implementations may also provide a way for
    users to define their own function assertions.</p>

               <p role="xquery"
                     >An implementation may raise implementation-defined
    errors or warnings for function assertions, for example if the parameters
    are not correct for a given assertion. If the namespace URI of a function 
    assertion’s <termref
                     def="dt-expanded-qname"
                  >expanded QName</termref> 
    is not recognized by an implementation, it is ignored, and has no
    effect on the semantics of the function type.</p>

               <note role="xquery">
                  <p>An implementation is free to raise warnings for function
    assertions that it does not recognize.</p>
               </note>

               <note role="xquery">
                  <p>Although function assertions use the same syntax as
    annotations, they are not directly related to annotations. If an
    implementation defines the annotation <code>blue</code> and uses it in
    function declarations, there is no guarantee that it will also
    define a function assertion <code>blue</code>, or that a function
    assertion named <code>blue</code> matches a function declared with
    the annotation <code>blue</code>. Of course, an implementation
    that does so may be more intuitive to users.</p>
               </note>

               <p role="xquery">
    Implementations must not define function assertions in <termref
                     def="dt-reserved-namespaces">reserved namespaces</termref>; it is is a <termref
                     def="dt-static-error">static error</termref>
                  <errorref class="ST" code="0045"
                     /> for a user to define a function assertion  in a <termref
                     def="dt-reserved-namespaces">reserved namespace</termref>.

  
  </p>
            </div4>

            <div4 id="id-map-test">
               <head>Map Types</head>
               
               <p>A <nt def="MapType">MapType</nt> designates an item type that
               either matches any map, or that matches maps whose keys and values
               are constrained to specific types.</p>
               
               <scrap>
                  <head/>
                  <prodrecap ref="MapType"/>
               </scrap>



               <p>An <nt def="AnyMapType"/>
                  <code>map(*)</code> matches any map.</p> 
               
               <p>The <nt def="MapType">MapType</nt>
                  <code>map(K, V)</code> matches any map where every key
                  is an instance of <code>K</code> and every value is an
                  instance of <code>V</code>.</p>
               
               <p>The <xtermref spec="DM40" ref="dt-entry-order">entry-order</xtermref>
               of a map has no effect on whether the map matches a particular
               map type.</p>
               
               
               
               <p diff="add" at="A">Although the grammar for <code>TypedMapType</code>
               allows the key to be described using the full <code>ItemType</code> syntax, the item type used must be
               a <termref def="dt-generalized-atomic-type"/> <errorref class="ST" code="0152"/>.</p>

               
               <p>For example, given a map <code>$M</code> whose keys are integers and whose
  results are strings, such as <code>{ 0: "no", 1: "yes" }</code>,
  the following following expressions deliver the result shown:
  </p>

               <ulist>
                  <item>
                     <p>
                        <code>$M instance of map(*)</code>  returns <code>true()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>$M instance of map(xs:integer, xs:string)</code>  returns <code>true()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>$M instance of map(xs:decimal, xs:anyAtomicType)</code>  returns <code>true()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>$M instance of map(xs:int, xs:string)</code>  returns <code>false()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>$M instance of map(xs:integer, xs:token))</code>  returns <code>false()</code>
                     </p>
                  </item>
               </ulist>

               <p diff="add" at="issue730">A map is also a function item, and therefore matches certain
               function types. Specifically, a map that matches <code>map(K, V)</code> also matches a function
               type of the form <code>function(xs:anyAtomicType) as R</code> provided that both the following
                  conditions are satisfied:</p>
               
               <ulist diff="add" at="issue730">
                  <item><p><var>V</var> is a <termref def="dt-subtype"/> of <var>R</var></p></item>
                  <item><p><code>empty-sequence()</code> is a <termref def="dt-subtype"/> of <var>R</var></p></item>
               </ulist>
              
               
               <note diff="add" at="issue730">
                  <p>To understand this rule, consider the use of a map <code>$M</code> in a function 
                  call <code>$M($K)</code>, which is equivalent to the function call <code>map:get($M, $K)</code>.

                  This function accepts any atomic item for the argument <code>$K</code>, and hence matches
                  a function type that requires an argument type of <code>xs:anyAtomicType</code>. If the

                  key <code>$K</code> is present in the map, the result of the function will be a value of
                  type <var>V</var>; if not, it will be an empty sequence. The map is therefore substitutable
                  for the function type provided that the function type allows both a value of type <var>V</var>
                  and the empty sequence as possible results.</p>
                  <p>The key type <var>K</var> does not enter into this rule. That is because in the function call
                     <code>$M($K)</code>, the sought key <code>$K</code> does not have to be of the same
                  type as the keys actually present in the map.</p>
                  <p>The transitivity rules for item type matching mean that if an item <var>M</var>
                     matches a type <var>T</var>, and <var>T</var> is a <termref def="dt-subtype"/> 
                     of <var>U</var>, then <var>M</var> also matches type <var>U</var>. So the fact
                  that a map from integers to strings (<code>map(xs:integer, xs:string)</code>)
                  matches <code>function(xs:anyAtomicType) as xs:string?</code>
                  means that it will also match other function types such as 
                     <code>function(xs:integer) as xs:string?</code> and 
                     <code>function(xs:decimal) as xs:anyAtomicType?</code></p>
                  <p>Furthermore, the rules for
                     <termref def="dt-function-coercion"/> mean that any map can be supplied as a value in a
                     context where it does not actually match the required function type, but
                     can be coerced to a function that does. For example a map of type 
                     <code>map(xs:integer, xs:string)</code> can be coerced to a function of
                     type <code>function(xs:integer) as xs:string</code>; in this situation a type
                     error will occur only if a call on the function actually returns an empty sequence. </p>
               </note>


              



               <p>Examples:</p>

               <ulist>
                  <item>
                     <p>
                        <code>$M instance of fn(*)</code>  returns <code>true()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>$M instance of fn(xs:anyAtomicType) as item()*</code> returns <code>true()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>$M instance of fn(xs:integer) as item()*</code>  returns <code>true()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>$M instance of fn(xs:int) as item()*</code>  returns <code>true()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>$M instance of fn(xs:string) as item()*</code>  returns <code>true()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>not($M instance of fn(xs:integer) as xs:string)</code>  returns <code>true()</code>
                     </p>
                  </item>
               </ulist>
               <note>
                  <p>The last case might seem surprising; 
                     however, <termref
                        def="dt-function-coercion"
                        >function coercion</termref> ensures that <code>$M</code> can be used successfully 
  anywhere that the required type is <code>fn(xs:integer) as xs:string</code>.</p>
               </note>
               
               <p>Rules defining whether one map type is a <termref def="dt-subtype"/> of another
               are given in <specref ref="id-item-subtype-maps"/>.</p>

            </div4>
            
            
            
            <div4 id="id-record-test" diff="add" at="A">
               <head>Record Types</head>
               
               <changes>
                  <change>
                     Record types are added as a new kind of <code>ItemType</code>, constraining
                     the value space of maps.
                  </change>
                  <change issue="52" PR="728" date="2023-10-10">
                     The syntax <code>record(*)</code> is allowed; it matches any map.
                  </change>
                  <change issue="1491">
                     The syntax <code>record()</code> is allowed; the only thing it matches is an empty map.
                  </change>
               </changes>
               
               <p>A <nt def="RecordType">RecordType</nt> matches maps that meet specific criteria.</p>

               <p>For example, the <code>RecordType</code>
                  <code>record(r as xs:double, i as xs:double)</code>
		             matches a map if the map has exactly two entries: an entry with key <code>"r"</code>
		                whose value is a <termref def="dt-singleton"/> <code>xs:double</code> value, and an entry with key <code>"i"</code>
		                whose value is also a <termref def="dt-singleton"/> <code>xs:double</code> value.</p>
               
               <p>Record types describe a subset of the value space of maps. They do not define any new kinds of
		             values, or any additional operations. They are useful in many cases to describe more accurately the
		             type of a variable, function parameter, or function result, giving benefits both in the readability
		             of the code, and in the ability of the processor to detect and diagnose type errors and to optimize
		             execution.</p>


               <scrap>
                  <prodrecap ref="RecordType"/>
               </scrap>

              
               

               <p>If the list of fields ends with <code>",*"</code> then the record type is said to be
		                <term>extensible</term>. For example, the <code>RecordType</code>
                  <code>record(e as element(Employee), *)</code>
		             matches a map if it has an entry with key <code>"e"</code> whose value matches <code>element(Employee)</code>,
		             regardless what other entries the map might contain.</p>
               
               <p>For generality:</p>
               <ulist>
                  <item><p>The syntax <code>record()</code> defines a record type that has no explicit fields and that
                  is not extensible. The only thing it matches is an <xtermref spec="DM40" ref="dt-empty-map"/>.</p></item>
                  <item><p>The syntax <code>record(*)</code> defines an extensible record type that has no explicit
                  field declarations. It is equivalent to the item type
                  <code>map(*)</code>: that is, it matches any map.</p></item>
               </ulist>
               
               <p>A record type can constrain only those entries whose keys are strings, but when the record
		             type is marked as extensible, then other entries may be present in the map with either string or non-string keys.
		             Entries whose key is a string can be expressed using an (unquoted) NCName if the key conforms to
		             NCName syntax, or using a (quoted) string literal otherwise.</p>
               
               <p>Although constructors for named record types produce a map in which the
                  <xtermref spec="DM40" ref="dt-entry-order">entry order</xtermref> reflects
                  the order of field definitions in the record type definition,
                  the <xtermref spec="DM40" ref="dt-entry-order">entry order</xtermref>
                  of a map has no effect on whether the map matches a particular
                  record type: the entries in a map do not have to be in any particular order.</p>

               <note>
                  <p>Lookup expressions have been extended in 4.0 so that non-NCName keys can be used without
		             parentheses: <code>employee?"middle name"</code></p>
               </note>


               <p>If the type declaration for a field is omitted, then <code>item()*</code> is assumed: that is,
		             the map entry may have any type.</p>

               <p>If the field name is followed by a question mark,
		             then the value must have the specified type if it is present, but it may also be absent. For example,
		             the <code>RecordType</code>
                  <code>record(first as xs:string, middle? as xs:string, last as xs:string, *)</code>
		                requires the map to have string-valued entries with keys <code>"first"</code> and <code>"last"</code>;
		                it also declares that if the map has an entry with key <code>"middle"</code>, the value of that
		                entry must be a single <code>xs:string</code>. Declaring the type as 
		                <code>record(first as xs:string, middle? as xs:string?, last as xs:string, *)</code> also allows
		             the entry with key <code>"middle"</code> to be present but empty.</p>
               
               <note>
                  <p>Within an extensible record type, a <code>FieldDeclaration</code> that is marked optional 
                     and has no declared type does not constrain the
                     map in any way, so it serves no practical purpose, but it is permitted because it may have
                     documentary value.</p>
               </note>
               
               <p>The names of the fields in a record type must be distinct <errorref class="ST" code="0021"/>.</p>
               
              
               

               

               

               <p>If a variable <code>$rec</code> is known to conform to a particular
		             record type, then when a lookup expression <code>$rec?field</code> is used, (a) the processor
		             can report a type error if <code>$rec</code> cannot contain an entry with name <code>field</code>
                   (see <specref ref="id-implausible-lookup-expressions"/>),
		             and (b) the processor can make static type inferences about the type of value returned by 
		             <code>$rec?field</code>.</p>

               <note>
                  <p>(TODO: change function signatures as suggested here!) A number of functions in the standard 
                     function library use maps as function arguments;
		                this is a useful technique where the information to be supplied across the interface is highly
		                variable. However, the type signature for such functions typically declares the argument type
		                as <code>map(*)</code>, which gives very little information (and places very few constraints)
		                on the values that are actually passed across. Using record types offers the possibility of
		                improving this: for example, the options argument of <function>fn:parse-json</function>, previously
		                given as <code>map(*)</code>, can now be expressed as <code>record(liberal? as xs:boolean, 
		                   duplicates? as xs:string, escape? as xs:boolean, fallback as fn(xs:string) as xs:string, *)</code>.
		                In principle the <code>xs:string</code> type used to describe the <code>duplicates</code>
		                   option could also be replaced by a schema-defined subtype
		                of <code>xs:string</code> that enumerates the permitted values (<code>"reject"</code>,
		                   <code>"use-first"</code>, <code>"use-last"</code>). 
		                </p>
                  <p>The use of a record type in the signature of such a function causes the 
		                   <termref def="dt-coercion-rules">coercion rules</termref>
		                to be invoked. So, for example, if the function expects an entry in the map to be an <code>xs:double</code>
		                value, it becomes possible to supply a map in which the corresponding entry has type <code>xs:integer</code>.</p>
                  <p>Greater precision in defining the types of such arguments also enables better type checking,
		                better diagnostics, better optimization, better documentation, and better syntax-directed
		                editing tools.</p>
               </note>

               <note>
                  <p>One of the motivations for introducing record types is to enable better pattern matching
		             in XSLT when processing JSON input. With XML input, patterns are often based
		             around XML element names. JSON has no direct equivalent of XML’s element names; matching a JSON object
		             such as <code>{longitude: 130.2, latitude: 53.4}</code> relies instead on recognizing the property
		             names appearing in the object. XSLT 4.0, by integrating record types into pattern matching syntax,
		             allows such an object to be matched with a pattern of the form 
		                <code>match="record(longitude, latitude)"</code></p>
               </note>

               <p>Rules defining whether one record type is a <termref def="dt-subtype"/> of another
                  are given in <specref ref="id-item-subtype-records"/>.</p>

            
            
            <div5 id="id-recursive-record-tests" diff="add" at="issue295">
               <head>Recursive Record Types</head>
               
               <p>A named record type <var>N</var> is said to be recursive if its 
                  definition includes a direct or indirect reference to <var>N</var>. 
               </p>
               
               <p>For example, the following XQuery declaration defines a linked list:</p>
               
               <p><eg>declare record my:list (value as item()*, next? as my:list);</eg></p>
               
               <p>The equivalent in XSLT is:</p>
               
               <eg><![CDATA[<xsl:record-type name="my:list">
   <xsl:field name="value" as="item()*"/>
   <xsl:field name="next" as="my:list" required="no"/>
</xsl:record-type>]]></eg>
               
               
               
 
               
               
               
               <p>Instances of recursive record types can be constructed and interrogated in the normal way.
               For example a list of length 3 can be constructed as:</p>
               <p><eg>{ "value": 1, "next": { "value": 2, "next": { "value": 3 } } }</eg></p>
               <p>and the third value in the map can be retrieved as <code>$list?next?next?value</code>.
               In practice, recursive data structures are usually manipulated using recursive functions.</p>
               
               <p>It is possible to define a recursive record type that cannot be instantiated, because it
               has no finite instances: for example (in XQuery) <code>declare record X (next as X);</code>.
               Such a record declaration is <termref def="dt-implausible"/>, so the processor may
               treat it as an error <errorref class="ST" code="0023"/>, but it is not obliged to do so.</p>
               
               <note><p>For an example of a practical use of recursive record types, see the
               specification of the function <function>fn:random-number-generator</function>.</p></note>
               
               <p>Recursive type definitions need to be handled specially by the subtyping rules; 
                  a naïve approach of simply replacing each reference to a named item type 
               with its definition would make the assessment of the subtype relationship non-terminating.
               For details see <specref ref="id-itemtype-subtype"/>.</p>
               
               <example id="e-binary-tree">
                  <head>A Binary Tree</head>
                  <p>A record used to represent a node in a binary tree might be represented (using XQuery syntax) as:</p>
                  <eg>declare record t:binary-tree 
   ( left? as t:binary-tree, 
     value as item()*, 
     right? as t:binary-tree
   )</eg>
                  <p>A recursive function to walk this tree and enumerate all the values in depth-first order might be written 
                     (again using XQuery syntax) as:</p>
                  <eg><![CDATA[declare function t:values($tree as t:binary-tree?) as item()* {
  $tree ! (t:values(?left), ?value, t:values(?right))   
}]]></eg>
               </example>
               
               <example id="e-arbitrary-tree">
                  <head>An Arbitrary Tree</head>
                  <p>A record used to represent a node in a tree where each node has an arbitrary number
                     of children might be represented (using XQuery syntax) as:</p>
                  <eg>declare record t:tree as (value, children as t:tree*);</eg>
                  <p>A function to walk this tree and enumerate all the values in order might be written 
                     as:</p>
                  <eg>declare function t:flatten($tree as t:tree) as item()* {
  $tree?value, $tree?children ! t:flatten(.))   
}</eg>
               </example>
               
               <example id="e-mutually-recursive-types">
                  <head>Mutually Recursive Types</head>
                  <p>The usual textbook example of mutually-recursive types is that of a <emph>forest</emph>
                  consisting of a list of <emph>trees</emph>, where each <emph>tree</emph> is a record 
                  comprising a value and a <emph>forest</emph>.
                  As the previous example shows, this structure can be defined straightforwardly in &language; without 
                  recourse to mutual recursion.</p>
                  <p>A more realistic example where mutual recursion is needed is for the schema component model
                     used in <bibref ref="XMLSchema10"/> or <bibref ref="XMLSchema11"/>. Simplifying greatly,
                     the data representing an element declaration in XSD may contain references to a
                     complex type, which in turn will typically contain references to further 
                     element declarations. The structure therefore involves mutual recursion.
                  A simplified version of the schema component model might be written (in part) as:</p>
                  <eg>
declare record ElementDeclaration (
   name as xs:NCName,
   targetNamespace? as xs:anyURI,
   typeDefinition as (SimpleTypeDefinition | ComplexTypeDefinition),
   nillable as xs:boolean,
   abstract as xs:boolean
);
declare record SimpleTypeDefinition (
   name? as xs:NCName,
   targetNamespace? as xs:anyURI,
   baseType? as SimpleTypeDefinition,
   variety as enum("atomic", "list", "union"),
   facets as Facet*,
);
declare record ComplexTypeDefinition (
   name? as xs:NCName,
   targetNamespace? as xs:anyURI,
   baseType? as ComplexTypeDefinition,
   derivationMethod as enum("extension", "restriction"),
   contentType as record (
      variety as enum("empty", "simple", "element-only", "mixed"),
      particle? as Particle,
      simpleTypeDefinition? as SimpleTypeDefinition
   )
);
declare record Particle (
   minOccurs as xs:nonNegativeInteger,
   maxOccurs as (xs:positiveInteger | enum("unbounded")),
   term as (ElementDeclaration | Wildcard | Group)
);</eg>

               </example>
   
               
            </div5>
            </div4>
            <div4 id="id-array-test">
               <head>Array Types</head>
               
               <p>An <nt def="ArrayType">ArrayType</nt> designates an item type that
               either matches all arrays, or that matches arrays whose members
               are constrained to a specific type.</p>

               <scrap>
                  <prodrecap ref="ArrayType"/>
               </scrap>


               <p>An <nt def="AnyArrayType"/>
                  <code>array(*)</code> matches any array.</p> 
               <p>The <nt def="TypedArrayType"
                     >TypedArrayType</nt>
                  <code>array(X)</code> matches any array
  in which every array member matches the <nt
                     def="SequenceType">SequenceType</nt>
                  <code>X</code>.</p>

               <p>Examples:</p>

               <ulist>
                  <item>
                     <p>
                        <code>[ 1, 2 ] instance array(*)</code> returns <code>true()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>[] instance of array(xs:string)</code> returns <code>true()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>[ "foo" ] instance of array(xs:string)</code> returns <code>true()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>[ "foo" ] instance of array(xs:integer)</code> returns <code>false()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>[ (1, 2), (3, 4) ] instance of array(xs:integer)</code> returns <code>false()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>[ (1, 2), (3, 4) ] instance of array(xs:integer+)</code> returns <code>true()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>[ [1, 2], [3, 4] ] instance of array(array(xs:integer+))</code> returns <code>true()</code>
                     </p>
                  </item>
               </ulist>

               <p>An array also matches certain other <termref def="dt-item-type">item types</termref>, 
                  including:</p>

               <ulist>
                  <item>
                     <p>
                        <code>item()</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>function(*)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>function(xs:integer) as item()*</code>
                     </p>
                  </item>
               </ulist>




          <p diff="add" at="issue730">An array that matches <code>array(T)</code>
                  also matches the function type <code>function(xs:integer) as T</code>.</p>

               <note diff="add" at="issue730">
                  <p>To understand this rule, consider the use of an array <code>$A</code> in a function 
                     call <code>$A($I)</code>, which is equivalent to the function call <code>array:get($A, $I)</code>.
                     This function accepts any integer for the argument <code>$I</code>, and the result
                     will either be an instance of <var>T</var>, or an error.</p>
                  
                  <p>The transitivity rules for item type matching mean that if an item <var>A</var>
                     matches a type <var>T</var>, and <var>T</var> is a <termref def="dt-subtype"/> 
                     of <var>U</var>, then <var>A</var> also matches type <var>U</var>. So the fact
                     that an array of strings (<code>array(xs:string)</code>)
                     matches <code>function(xs:integer) as xs:string</code>
                     means that it will also match other function types such as 
                     <code>function(xs:long) as item()*</code>.</p>
                  <p>Furthermore, the rules for
                     <termref def="dt-function-coercion"/> mean that any array can be supplied as a value in a
                        context where it does not actually match the required function type, but
                        can be coerced to a function that does. For example an array of type 
                        <code>array(node())</code> can be coerced to a function of
                        type <code>function(xs:integer) as element()</code>; in this situation a type
                        error will occur only if a call on the function actually returns a node
                        that is not an element node.</p>
               </note>


               <p diff="del" at="issue730">The function signature of an array
  matching <code>array(X)</code>, treated as a function, is
  <code>function(xs:integer) as X</code>.  It is thus always a subtype of
  <code>function(xs:integer) as item()*</code>
  regardless of the actual member types in the array.  The rules for
                  <termref
                     def="dt-function-coercion"
                     >function coercion</termref> mean that any array can be supplied as a value in
  a context where the required type has a more specific return type,
  such as <code>function(xs:integer) as xs:integer</code>, even when the array does
  not match in the sense required to satisfy the <code>instance of</code>
  operator. In such cases, a type error will occur only if an actual
  call on the array (treated as a function) returns a value that is
  not an instance of the required return type.</p>
                 
               <p>Rules defining whether one array type is a <termref def="dt-subtype"/> of another
                  are given in <specref ref="id-item-subtype-arrays"/>.</p>

            </div4>
         </div3>
            <div3 id="id-xs-error">
               <head>The type <code>xs:error</code></head>
               <p>The item type <code>xs:error</code> has an empty value space; 
                  it never appears as a dynamic type or as the content type of a dynamic element or attribute type. 
                  
                  
                  It was defined in XML Schema in the interests of making the type system complete and closed, 
                  and it is also available in &language; for similar reasons.</p>
               
               <note>
                  <p>Even though it cannot occur in an instance, <code>xs:error</code> is a valid type name in a sequence type. The
                     practical uses of <code>xs:error</code> as a sequence type are limited, but they do exist. For instance, an error-handling function that always raises a dynamic error 
                     never returns a value, so <code>xs:error</code> is a good choice for the return type of the function.</p>
                  
                  <p>The semantics of <code>xs:error</code> are well defined as a consequence of the fact that <code>xs:error</code> is defined as a union type with
                     no member types. For example:</p>
                  
                  <ulist>
                     <item>
                        <p>
                           <code role="parse-test"
                              >$x instance of xs:error</code> always returns <code>false</code>, regardless of the value of <code>$x</code>.</p>
                     </item>
                     <item>
                        <p>
                           <code role="parse-test"
                              >$x cast as xs:error</code> fails dynamically with error <xerrorref
                                 spec="FO40" class="RG" code="0001"
                              />,  regardless of the value of <code>$x</code>.</p>
                     </item>
                     <item>
                        <p>
                           <code role="parse-test">$x cast as xs:error?</code> raises a <termref
                              def="dt-dynamic-error">dynamic error</termref>
                           <xerrorref spec="FO40" class="RG" code="0001"
                           /> if <code>exists($x)</code> returns <code>true</code>, and evaluates to the empty sequence if <code>empty($x)</code> returns <code>true</code>.</p>
                     </item>
                     <item>
                        <p>
                           <code role="parse-test"
                              >xs:error($x)</code> has the same semantics as <code>$x cast as xs:error?</code> (see the previous bullet point)</p>
                     </item>
                     <item>
                        <p>
                           <code role="parse-test"
                              >$x castable as xs:error</code> evaluates to <code>false</code>, regardless of the value of <code>$x</code>.</p>
                     </item>
                     <item>
                        <p>
                           <code role="parse-test">$x treat as xs:error</code>  raises a <termref
                              def="dt-dynamic-error">dynamic error</termref>
                           <errorref code="0050" class="DY"
                           /> if evaluated, regardless of the value of <code>$x</code>. It never fails statically.</p>
                     </item>
                     <item role="xquery">
                        <p>
                           <code role="parse-test"
                              >let $x as xs:error := 1 return 2</code>  raises a <termref
                                 def="dt-type-error">type error</termref>
                           <errorref code="0004" class="TY"
                           />, which can be raised statically or dynamically, and need not be raised if the variable <code>$x</code> is never evaluated by the query processor.</p>
                     </item>
                     <item role="xquery">
                        <p>
                           <code>declare function ns:f($arg as xs:error) {...};</code> is a valid function declaration, but it always  raises a <termref
                              def="dt-type-error">type error</termref>
                           <errorref code="0004" class="TY"/> if the function is called.</p>
                     </item>
                  </ulist>
                  
                  <p>All of the above examples assume that <code>$x</code> is actually evaluated. The rules specified in <specref
                     ref="id-errors-and-opt"
                  /> permit an implementation to avoid evaluating <code>$x</code> if the result of the query does not depend upon the value of <code>$x</code> and thus to avoid raising an error.</p>
               </note>
               
            </div3>
         </div2>
      
            

         <div2 id="id-sequencetype-subtype">
            <head>Subtype Relationships</head>
            
            <changes>
               <change issue="196" PR="202" date="2022-10-25">The presentation of the rules for the subtype relationship between 
                  sequence types and item types has been substantially
                  rewritten to improve clarity; no change to the semantics is intended.</change>
            </changes>

            <p diff="chg" at="B"><termdef term="subtype" id="dt-subtype">Given two 
               <termref def="dt-sequence-type">sequence types</termref>
               or <termref def="dt-item-type">item types</termref>, the rules in this section determine if one 
               is a <term>subtype</term> of the other. If a type <var>A</var> is a subtype of type <var>B</var>,
               it follows that every value matched by <var>A</var> is also matched by <var>B</var>.</termdef></p>
            
            <note diff="add" at="B"><p>The relationship <code>subtype(A, A)</code> is always true:
               every type is a subtype of itself.</p></note>
            
            <note diff="add" at="B"><p>The converse is not necessarily true: we cannot infer that 
               if every value matched by <var>A</var> is also matched by <var>B</var>, then 
               <var>A</var> is a subtype of type <var>B</var>. For example, <var>A</var> might be
            defined as the set of strings matching the regular expression <code>[A-Z]*</code>, while <var>B</var>
            is the set of strings matching the regular expression <code>[A-Za-z]*</code>; no subtype
            relationship holds between these types.</p></note>
            
            <p diff="chg" at="B">The rules for deciding whether one <termref def="dt-sequence-type"/> is a subtype
               of another are given in <specref ref="id-seqtype-subtype"/>. The rules for deciding whether
               one <termref def="dt-item-type"/> is a subtype of another are given in <specref ref="id-itemtype-subtype"/>.</p>
  
        
            
            <note diff="add" at="B"><p>The subtype relationship is not acyclic. There are cases where <code>subtype(A, B)</code> and
               <code>subtype(B, A)</code> are both true. This implies that <var>A</var> and <var>B</var>
               have the same value space, but they can still be different types. For example this applies when <var>A</var>
               is a union type with member types <code>xs:string</code> and <code>xs:integer</code>, while 
               <var>B</var> is a union type with member types <code>xs:integer</code> and <code>xs:string</code>.
               These are different types (<code>"23" cast as A</code> produces a string, while <code>"23" cast as B</code>
               produces an integer, because casting is attempted to each member type in order) but both types have the same value space.
            </p></note>


            <div3 id="id-seqtype-subtype">
               <head>Subtypes of Sequence Types</head>

               <p>We use the notation <code>A ⊑ B</code>, or <code>subtype(A, B)</code> to indicate that
                  a <termref def="dt-sequence-type"/> <code>A</code> is a <termref def="dt-subtype"/> of a sequence type <code>B</code>.
               This section defines the rules for deciding whether any two sequence types have this relationship.</p>
               
               <p>To define the rules, we divide sequence types into six categories:</p>
               
               <ulist>
                  <item><p>The category <code>empty</code> includes the sequence types <code>empty-sequence()</code>,
                   <code>xs:error*</code> and <code>xs:error?</code>. All these sequence types
                  match the empty sequence as their only instance.</p></item>
                  <item><p>The category <code>void</code> includes the sequence types <code>xs:error</code> and <code>xs:error+</code>,
                  which have no instances (not even the empty sequence).</p></item>
                  <item><p>The categories <code>X?</code>, <code>X*</code>, <code>X</code> and <code>X+</code> includes all sequence types 
                     having an item type <code>X</code> other than <code>xs:error</code>, together with an occurrence indicator of 
                     <code>?</code> (zero or more), <code>*</code> (one or more), absent (exactly one), or <code>+</code> (one or more)
                     respectively. We use the notation <var>X/i</var> to indicate the item type of such a sequence type.</p></item>
               </ulist>
               
               <p>The judgement <code>A ⊑ B</code> is then determined by the categories of the two sequence types, as defined
               in the table below. In many cases this depends on the relationship between the item types of <code>A</code>
                  and <code>B</code>. This is denoted using the notation <code><var>A/i</var> ⊆ <var>B/i</var></code>, 
                  as defined in <specref ref="id-itemtype-subtype"/>.</p>
               
               

               <table role="medium">
                  <tbody>
                     <tr>
                        <th rowspan="2" colspan="2"/>
                        <th colspan="6">
                           <termref def="dt-sequence-type">Sequence type</termref>
                           <var>B</var>
                        </th>
                     </tr>
                     <tr>
                        <th>
                           <code>empty</code>
                        </th>
                        <th>
                           <code><var>B/i</var>?</code>
                        </th>
                        <th>
                           <code><var>B/i</var>*</code>
                        </th>
                        <th>
                           <code><var>B/i</var></code>
                        </th>
                        <th>
                           <code><var>B/i</var>+</code>
                        </th>
                        <th>
                           <code>void</code>
                        </th>
                     </tr>
                     <tr>
                        <th rowspan="6">
                           <termref def="dt-sequence-type">Sequence type</termref>
                           <var>A</var>
                        </th>
                        <th>
                           <code>empty</code>
                        </th>
                        <td>true</td>
                        <td>true</td>
                        <td>true</td>
                        <td>false</td>
                        <td>false</td>
                        <td>false</td>
                     </tr>
                     <tr>
                        <th>
                           <code><var>A/i</var>?</code>
                        </th>
                        <td>false</td>
                        <td>
                           <code><var>A/i</var> ⊆ <var>B/i</var></code>
                        </td>
                        <td>
                           <code><var>A/i</var> ⊆ <var>B/i</var></code>
                        </td>
                        <td>false</td>
                        <td>false</td>
                        <td>false</td>
                     </tr>
                     <tr>
                        <th>
                           <code><var>A/i</var>*</code>
                        </th>
                        <td>false</td>
                        <td>false</td>
                        <td>
                           <code><var>A/i</var> ⊆ <var>B/i</var></code>
                        </td>
                        <td>false</td>
                        <td>false</td>
                        <td>false</td>
                     </tr>
                     <tr>
                        <th>
                           <code><var>A/i</var></code>
                        </th>
                        <td>false</td>
                        <td>
                           <code><var>A/i</var> ⊆ <var>B/i</var></code>
                        </td>
                        <td>
                           <code><var>A/i</var> ⊆ <var>B/i</var></code>
                        </td>
                        <td>
                           <code><var>A/i</var> ⊆ <var>B/i</var></code>
                        </td>
                        <td>
                           <code><var>A/i</var> ⊆ <var>B/i</var></code>
                        </td>
                        <td>false</td>
                     </tr>
                     <tr>
                        <th>
                           <code><var>A/i</var>+</code>
                        </th>
                        <td>false</td>
                        <td>false</td>
                        <td>
                           <code><var>A/i</var> ⊆ <var>B/i</var></code>
                        </td>
                        <td>false</td>
                        <td>
                           <code><var>A/i</var> ⊆ <var>B/i</var></code>
                        </td>
                        <td>false</td>
                     </tr>
                     <tr>
                        <th>
                           <code>void</code>
                        </th>
                        <td>true</td>
                        <td>true</td>
                        <td>true</td>
                        <td>true</td>
                        <td>true</td>
                        <td>true</td>
                     </tr>
                  </tbody>
               </table>


            <!--   <p>
                  <code>xs:error+</code> is treated the same way as <code>xs:error</code> in the above table. 
                  <code>xs:error?</code> and <code>xs:error*</code> are treated the same way as <code>empty-sequence()</code>.</p>-->

            </div3>

            <div3 id="id-itemtype-subtype">
               <head>Subtypes of Item Types</head>
               
               <p>We use the notation <code>A ⊆ B</code>, or <code>itemtype-subtype(A, B)</code> to indicate that
                  an <termref def="dt-item-type"/> <code>A</code> is a <termref def="dt-subtype"/> of an item type <code>B</code>.
                  This section defines the rules for deciding whether any two item types have this relationship.</p>
               


             
               <p diff="chg" at="Issue451">The rules in this section apply to 
                  <termref def="dt-item-type">item types</termref>, not to 
                  <termref def="dt-item-type-designator">item type designators</termref>.
                  For example, if the name <code>STR</code> has been defined in the
                  static context as a <termref def="dt-named-item-type"/> referring to the type <code>xs:string</code>,
                  then anything said here about the type <code>xs:string</code> applies equally
                  whether it is designated as <code>xs:string</code> or as <code>STR</code>,
                  or indeed as the parenthesized forms <code>(xs:string)</code> or
                 <code>(STR)</code>.</p>


               
               <p diff="chg" at="issue295">References to <termref def="dt-named-item-type">named item types</termref> 
                  are handled as described in <specref ref="id-itemtype-subtype-aliases"/>.</p>            
               
               <p>The relationship <code>A ⊆ B</code> is true
               if and only if at least one of the conditions listed in the following subsections applies:</p>

               <div4 id="id-item-subtype-general">
                  <head>General Subtyping Rules</head>
                  <p>Given <termref def="dt-item-type">item types</termref> <var>A</var> and <var>B</var>, 
                     <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply:</p>
 
 
                     <olist>
                        <item diff="chg" at="A">
                           <p><var>A</var> is <code>xs:error</code>.</p>
                        </item>
                        <item>
                           <p><var>B</var> is <code>item()</code>.</p>
                        </item>
                        <item diff="chg" at="A">
                           <p><var>A</var> and <var>B</var> are the same <termref def="dt-item-type"/>.</p> 
                        </item>
                        <item diff="chg" at="A">
                           <p>There is an <termref def="dt-item-type"/>
                              <var>X</var> such that <code><var>A</var> ⊆ <var>X</var></code>
                              and <code><var>X</var> ⊆ <var>B</var></code>. (This is referred to below as the <term>transitivity rule</term>).</p>
                        </item>
                     </olist>
                  <note>
                     <p>The first rule is technically redundant: it is implied by the second rule in <specref ref="id-item-subtype-atomic"/>.
                     The type <code>xs:error</code> is defined as a union type with no member types; therefore it is automatically true that
                        every member type <var>T</var> satisfies <code><var>T</var> ⊆ <var>B</var></code>.</p>
                  </note>
               </div4>
               
               <div4 id="id-item-subtype-choice">
                  <head>Subtyping of Choice Item Types</head>
                  <p>The following rules determine whether <code><var>A</var> ⊆ <var>B</var></code> is true in the
                  case where either <var>A</var> or <var>B</var> or both is a <termref def="dt-choice-item-type"/>.</p>
                  
                  <p>Firstly, if one of the operands is <emph>not</emph> a choice item type, then it is treated
                  as a choice item type with a single member type. The rule is then:</p>
                  
                  <p><code><var>A</var> ⊆ <var>B</var></code> is true if for every member type <var>a</var> in 
                  <var>A</var>, there is a member type <var>b</var> in <var>B</var> such that <code><var>a</var> ⊆ <var>b</var></code>.</p>
                  
                  <p>For example, <code>(xs:int | xs:long)</code> is a subtype of <code>(xs:decimal | xs:date)</code>
                  because both <code>xs:int</code> and <code>xs:long</code> are subtypes of <code>xs:decimal</code>.</p>
                  
                 
                  <note>
                     <p>Because an <termref def="dt-enumeration-type"/> is defined as a choice type
                        of singleton enumerations, these
                     rules have the consequence, for example, that <code>enum("A", "B")</code> is a subtype
                     of <code>enum("A", "B", "C")</code>.</p>
                  </note>
                  <note>
                     <p>The type <code>xs:int</code> is not a subtype of <code>(xs:negativeInteger | xs:nonNegativeInteger)</code>,
                     because it does not satisfy this rule. This is despite the fact that the value space of <code>xs:int</code>
                     is a subset of the value space of <code>(xs:negativeInteger | xs:nonNegativeInteger)</code>.</p>
                  </note>
               </div4>
               <div4 id="id-item-subtype-atomic">
                  <head>Subtyping of Atomic and Union Types</head>
                  <p>Given item types <var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply:</p>
  
                     <olist>
                        <item>
                           <p><var>A</var> and <var>B</var> are <termref def="dt-generalized-atomic-type">generalized atomic types</termref>, 
                              and <var>A</var> <termref def="dt-derives-from"/> <var>B</var>.</p>
                           <example diff="add" at="B">
                              <head>Examples:</head>
                              <ulist>
                                 <item><p><code>xs:integer ⊆ xs:decimal</code> because <code>xs:integer</code> is derived
                                 by restriction from <code>xs:decimal</code>.</p></item>
                                 <item><p><code>xs:decimal ⊆ xs:numeric</code> because <code>xs:numeric</code> is a pure union
                                    type that includes <code>xs:decimal</code> as a member type.</p></item>
                                 <item><p><code>enum("red") ⊆ xs:string</code> because the singleton
                                    enumeration type <code>enum("red")</code> is defined to be an atomic
                                    type derived from <code>xs:string</code>.</p></item>
                                 <item><p><code>enum("red") ⊆ enum("red", "green")</code> because the 
                                    enumeration type <code>enum("red", "green")</code> is defined to be a union type
                                       that has the generalized atomic type <code>enum("red")</code> as a member type.</p></item>
                              </ulist>
                           </example>
                        </item>
                        <item>
                           <p><var>A</var> is a <termref def="dt-pure-union-type"/>, 
                              and every type <var>T</var> in the transitive membership of <var>A</var>
                              satisfies <code><var>T</var> ⊆ <var>B</var></code>.</p>
                           <example diff="add" at="B">
                              <head>Examples:</head>
                              <ulist>
                                 <item><p><code>(xs:short | xs:long) ⊆ xs:integer</code>
                                    because <code>xs:short ⊆ xs:integer</code> and <code>xs:long ⊆ xs:integer</code>.</p></item>
                                 <item><p><code>(P | Q) ⊆ (P | Q | R)</code>
                                 because <code>P ⊆ (P | Q | R)</code> and <code>Q ⊆ (P | Q | R)</code>.</p></item>
                                 <item><p><code>enum("red", "green") ⊆ xs:string</code> because the 
                                    enumeration type <code>enum("red") ⊆ xs:string</code> 
                                    and <code>enum("green") ⊆ xs:string</code>.</p></item>
                                 <item><p><code>enum("red", "green") ⊆ enum("red", "green", "blue")</code> because 
                                    <code>enum("red") ⊆ enum("red", "green", "blue")</code> and 
                                    <code>enum("green") ⊆ enum("red", "green", "blue")</code>.</p></item>
                                 <item><p><code>enum("red", "green", "blue") ⊆ (enum("red", "green") | enum("blue"))</code> because 
                                    each of the types <code>enum("red")</code>, <code>enum("green")</code>, and <code>enum("blue")</code>
                                    is a subtype of one of the two members of the union type.</p></item>
                              </ulist>                             
                           </example>
                           <!--<note><p>This rule applies both when <code>A</code> is a schema-defined union type
                              and when it is a <termref def="dt-local-union-type"/>; in addition it
                              applies when <code>A</code> is an enumeration type with multiple enumerated values,
                              which is defined to be equivalent to a union type.
                           </p></note>-->
                        </item>
             
                     </olist>
               </div4>
               <div4 id="id-item-subtype-nodes">
                  <head>Subtyping of Node Types</head>
                  <p>The following subsections describe the subtype relationships
                  among node types.</p>
                  <div5 id="id-item-subtype-nodes-general">
                     <head>Subtyping Nodes: General Rules</head>
                  
                  <p>Given item types <var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply:</p>
                  
                     <olist>
                        <item>
                           <p><var>A</var> is a <nt def="KindTest">KindTest</nt> and <var>B</var> is <code>node()</code>.</p>
                           <example>
                              <head>Example:</head>
                              <p><code>comment() ⊆ node()</code></p>
                           </example>
                        </item>
                        <item>
                           <p><var>A</var> is <code>processing-instruction(<var>N</var>)</code> for any name <var>N</var>,
                              and <var>B</var> is <code>processing-instruction()</code>.</p>
                           <example>
                              <head>Example:</head>
                              <p><code>processing-instruction('pi') ⊆ processing-instruction()</code></p>
                           </example>
                        </item>
                        <item>
                           <p><var>A</var> is <code>document-node(<var>E</var>)</code> for any <var>E</var>,
                              and <var>B</var> is <code>document-node()</code>.</p>
                           <example>
                              <head>Examples:</head>
                              <p><code>document-node(element(chap)) ⊆ document-node()</code></p>
                              <p><code>document-node(*) ⊆ document-node()</code></p>
                           </example>
                        </item>
                        <item>
                           <p>All the following are true, after expanding <code>document-node(<var>NameTestUnion</var>)</code>
                              to <code>document-node(element(<var>NameTestUnion)</var>)</code>:</p>
                           <olist>
                              <item><p><var>A</var> is <code>document-node(<var>A/e</var>)</code></p></item>
                              <item><p><var>B</var> is <code>document-node(<var>B/e</var>)</code></p></item>
                              <item><p><code><var>A/e</var> ⊆ <var>B/e</var></code></p></item>
                           </olist>
                           <example>
                              <head>Examples:</head>
                              <p><code>document-node(element(title)) ⊆ document-node(element(*))</code>.</p>
                              <p><code>document-node(title) ⊆ document-node(*)</code>.</p>
                           </example>
                        </item>
                     </olist>
               </div5>
               <div5 id="id-item-subtype-elements">
                  <head>Subtyping Nodes: Elements</head>
                  
                  <p diff="chg" at="Issue23"><termdef id="dt-wildcard-matches" term="wildcard-matches">In these rules, if <var>MU</var> and <var>NU</var> 
                     are <nt def="NameTestUnion">NameTestUnions</nt>, 
                     then <var>MU</var> <term>wildcard-matches</term> <var>NU</var> is true if every name that matches <var>MU</var>
                     also matches <var>NU</var>.</termdef></p>
                  
                  <p diff="chg" at="Issue23">More specifically, this is the case if for every <nt def="NameTest">NameTest</nt> <var>M</var>
                     in <var>MU</var> there is a <nt def="NameTest">NameTest</nt> <var>N</var> in <var>NU</var>
                     where at least one of the following applies:</p>
                  
                  <olist>
                     <item><p><var>M</var> and <var>N</var> are the same <code>NameTest</code>.</p></item>
                     <item><p><var>M</var> is an <code>EQName</code> and <var>N</var> is a 
                        <nt def="Wildcard">Wildcard</nt> that matches <var>M</var>.</p></item>
                     <item><p><var>N</var> is the <nt def="Wildcard">Wildcard</nt> <code>*</code>.</p></item>
                  </olist>
                  
                  <p>Given item types <var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> 
                     is true if any of the following apply.</p>
                  
                  <olist>
                     <item>
                        <p><var>A</var> is an <nt def="ElementTest">ElementTest</nt> and
                           <var>B</var> is either <code>element()</code> or <code>element(*)</code>
                        </p>
                     </item>
                        <item>
                           <p>All the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is either <code>element(<var>A/n</var>)</code> or <code>element(<var>A/n</var>, <var>T</var>)</code>  
                                 or <code>element(<var>A/n</var>, <var>T</var>?)</code> for any type <var>T</var></p></item>
                              <item><p><var>B</var> is either <code>element(<var>B/n</var>)</code> or <code>element(<var>B/n</var>, xs:anyType?)</code></p></item>
                              <item><p><var>A/n</var> <termref def="dt-wildcard-matches"/> <var>B/n</var></p></item>
                              
                           </olist>
                           <example>
                              <head>Examples:</head>
                              <ulist>
                                 <item><p><code>element(title) ⊆ element(*)</code></p></item>
                                 <item><p><code>element(title, xs:string) ⊆ element(*)</code></p></item>
                                 <item diff="add" at="Issue23"><p><code>element(title|heading, xs:string) ⊆ element(*)</code></p></item>
                                 <item diff="add" at="Issue23"><p><code>element(title, xs:string) ⊆ element(title|heading)</code></p></item>
                                 <item><p><code>element(title, xs:string?) ⊆ element(*)</code></p></item>
                                 <item diff="add" at="Issue23"><p><code>element(title|heading, xs:string) ⊆ element(*)</code></p></item>
                                 <item><p><code>element(title) ⊆ element(title, xs:anyType?)</code></p></item>
                                 <item><p><code>element(title, xs:integer) ⊆ element(title|heading, xs:anyType?)</code></p></item>
                                 <item><p><code>element(title, xs:string?) ⊆ element(title, xs:anyType?)</code></p></item>
                                 <item diff="add" at="Issue23"><p><code>element(my:title|your:title) ⊆ element(*:title)</code></p></item>
                                 <item diff="add" at="Issue23"><p><code>element(my:title|my:heading) ⊆ element(my:*)</code></p></item>
                              </ulist>
                           </example>
                        </item>
                        <item>
                           <p>All the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is <code>element(<var>A/n</var>, <var>A/t</var>)</code>.</p></item>
                              <item><p><var>B</var> is <code>element(<var>B/n</var>, <var>B/t</var>)</code>.</p></item>
                              <item><p><var>A/n</var> <termref def="dt-wildcard-matches"/> <var>B/n</var>.</p></item>
                              <item><p><var>A/t</var> <termref def="dt-derives-from"/> <var>B/t</var>.</p></item>
                           </olist>
                           <example>
                              <head>Examples:</head>
                              <ulist>
                                 <item><p><code>element(size, xs:integer) ⊆ element(size, xs:decimal)</code></p></item>
                                 <item diff="add" at="Issue23"><p><code>element(size, xs:integer) ⊆ element(size|größe, xs:decimal)</code></p></item>
                                 <item><p><code>element(size, xs:integer) ⊆ element(*, xs:decimal)</code></p></item>
                                 <item><p><code>element(*, xs:integer) ⊆ element(*, xs:decimal)</code></p></item>
                                 <item><p><code>element(my:*, xs:integer) ⊆ element(*, xs:decimal)</code></p></item>
                             
                              </ulist>
                           </example>
                        </item>
                        <item>
                           <p>All the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is either <code>element(<var>A/n</var>, <var>A/t</var>)</code> or 
                                 <code>element(<var>A/n</var>, <var>A/t</var>?)</code></p></item>
                              <item><p><var>B</var> is <code>element(<var>B/n</var>, <var>B/t</var>?)</code></p></item>
                              <item><p><var>A/n</var> <termref def="dt-wildcard-matches"/> <var>B/n</var></p></item>                             
                              <item><p><var>A/t</var> <termref def="dt-derives-from"/> <var>B/t</var>.</p></item>
                           </olist>
                           <example>
                              <head>Examples:</head>
                              <ulist>
                                 <item><p><code>element(size, xs:integer) ⊆ element(size, xs:decimal?)</code></p></item>
                                 <item><p><code>element(size, xs:integer?) ⊆ element(*, xs:decimal?)</code></p></item>
                                 <item><p><code>element(*, xs:integer) ⊆ element(*, xs:decimal?)</code></p></item>
                                 <item><p><code>element(my:*, xs:integer?) ⊆ element(*, xs:decimal?)</code></p></item>
                                 
                              </ulist>
                           </example>
                        </item>
                        

                        <item>
                           <p>All the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is <code>schema-element(<var>A/n</var>)</code></p></item>
                              <item><p><var>B</var> is <code>schema-element(<var>B/n</var>)</code></p></item>
                              <item><p>Every element declaration that is an actual member of the substitution group of <var>A/n</var> 
                                 is also an actual member of the substitution group of <var>B/n</var>.</p></item>
                           </olist>
                           <note>
                                <p>The fact that <var>P</var> is a member of the substitution group of <var>Q</var> 
                                   does not mean that every element declaration in the substitution group of <var>P</var> 
                                   is also in the substitution group of <var>Q</var>. For example, <var>Q</var> might 
                                   block substitution of elements whose type is derived by extension, while <var>P</var> does not.</p>
                           </note>
                        </item>
                     
                        <item>
                           <p><var>A</var> is <code>element(<var>A/1</var>|<var>A/2</var>|..., <var>T</var>)</code> 
                              (where <var>T</var> may be absent),
                           and for each <var>A/n</var>, <code>element(<var>A/n</var>, <var>T</var>) ⊆ <var>B</var></code>.</p>
                           <example>
                              <head>Examples:</head>
                              <ulist>
                                 <item><p><code>element(a|b) ⊆ (element(a)|element(b)|element(c))</code></p></item>
                                 <item><p><code>element(a|b, xs:integer) ⊆ (element(a, xs:decimal) | element(b, xs:integer))</code></p></item>
  
                              </ulist>
                           </example>

                        </item>
                  </olist>
               </div5>
               <div5 id="id-item-subtype-attributes">
                  <head>Subtyping Nodes: Attributes</head>
                  <p>Given item types <var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply:</p>
                    <olist>
                        <item>
                           <p><var>A</var> is an <nt
                                 def="AttributeTest">AttributeTest</nt> and
                              <var>B</var> is either <code>attribute()</code> or <code>attribute(*)</code>
                           </p>
                        </item>
                        <item>
                           <p>All the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is either <code>attribute(<var>A/n</var>)</code> or 
                                 <code>attribute(<var>A/n</var>, <var>T</var>)</code> 
                                 for any type <var>T</var>.</p></item>
                              <item><p><var>B</var> is either <code>attribute(Bn)</code> or 
                                 <code>attribute(<var>B/n</var>, xs:anyAtomicType)</code></p></item>
                              <item><p><var>A/n</var> <termref def="dt-wildcard-matches"/> <var>B/n</var></p></item>
                              
                           </olist>
                           <example>
                              <head>Examples:</head>
                              <ulist>
                                 <item><p><code>attribute(code) ⊆ attribute(*)</code></p></item>
                                 <item diff="add" at="Issue23"><p><code>attribute(code|status) ⊆ attribute(*)</code></p></item>
                                 <item><p><code>attribute(code, xs:untypedAtomic) ⊆ attribute(*)</code></p></item>
                                 <item><p><code>attribute(code|status, xs:string) ⊆ attribute(code, xs:anyAtomicType)</code></p></item>                                
                                 <item diff="add" at="Issue23"><p><code>attribute(my:code|your:code) ⊆ attribute(*:code)</code></p></item>
                                 <item diff="add" at="Issue23"><p><code>attribute(my:code|my:status) ⊆ attribute(my:*)</code></p></item>
                              </ulist>
                           </example>
                           
                           </item>
                        
                        
                        
                        
                        <item>
                           <p>All the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is <code>attribute(<var>A/n</var>, <var>A/t</var>)</code></p></item>
                              <item><p><var>B</var> is <code>attribute(<var>B/n</var>, <var>B/t</var>)</code></p></item>
                              <item><p><var>A/n</var> <termref def="dt-wildcard-matches"/> <var>B/n</var></p></item>
                              <item><p><var>A/t</var> <termref def="dt-derives-from"/> <var>B/t</var>.</p></item>
                           </olist>
                           
                           <example>
                              <head>Examples:</head>
                              <ulist>
                                 <item><p><code>attribute(*, xs:ID) ⊆ attribute(*, xs:string)</code></p></item>
                                 <item><p><code>attribute(my:*, xs:ID) ⊆ attribute(*, xs:string)</code></p></item>
                                 <item diff="add" at="Issue23"><p><code>attribute(code, xs:ID) ⊆ attribute(code|status, xs:string)</code></p></item>
                                 <item><p><code>attribute(code, xs:ID) ⊆ attribute(*, xs:string)</code></p></item>
                                 <item><p><code>attribute(code, xs:ID) ⊆ attribute(*:code, xs:ID)</code></p></item>
                                 <item diff="add" at="Issue23"><p><code>attribute(my:code|my:status, xs:ID) ⊆ attribute(my:*, xs:string)</code></p></item>
                              </ulist>
                           </example>
                           
                        </item>
                        
                        <item>
                           <p>All the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is <code>schema-attribute(<var>A/n</var>)</code></p></item>
                              <item><p><var>B</var> is <code>schema-attribute(<var>B/n</var>)</code></p></item>
                              <item><p>the <termref
                                 def="dt-expanded-qname"
                                 >expanded QName</termref> of <var>A/n</var> equals the <termref
                                 def="dt-expanded-qname"
                                 >expanded QName</termref> of <var>B/n</var></p></item>
       
                           </olist>
                        </item>
                       <item>
                           <p><var>A</var> is <code>attribute(<var>A/1</var>|<var>A/2</var>|..., <var>T</var>)</code> (where <var>T</var> may be absent),
                           and for each <var>A/n</var>, <code>attribute(<var>A/n</var>, <var>T</var>) ⊆ <var>B</var></code>.</p>
                          <example>
                              <head>Examples:</head>
                              <ulist>
                                 <item><p><code>attribute(a|b) ⊆ (attribute(a)|attribute(b)|attribute(c))</code></p></item>
                                 <item><p><code>attribute(a|b, xs:integer) ⊆ (attribute(a, xs:decimal) | attribute(b))</code></p></item>
                              </ulist>
                           </example>
                        </item>
                     </olist>
               </div5>
               </div4>
               <div4 id="id-item-subtype-functions">
                  <head>Subtyping Functions</head>
                  <p>Given item types <var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply:</p>
                  

                     <olist>
                        <item><p>All the following are true:</p>
                        <olist>
                           <item><p><var>A</var> is a <nt def="FunctionType">FunctionType</nt>
                              <phrase role="xquery"> with annotations <code>[AnnotationsA]</code></phrase></p></item>
                           <item><p><var>B</var> is <code>
                                 <phrase role="xquery">[AnnotationsB]</phrase> function(*)</code></p></item>
                           <item role="xquery"><p><code>subtype-assertions(AnnotationsA, AnnotationsB)</code>, 
                              where <code>[AnnotationsB]</code> and <code>[AnnotationsA]</code> 
                              are optional lists of one or more annotations.</p></item>
                        </olist>
                           <example>
                              <head>Example:</head>
                              <p><code>function(xs:integer) as xs:string ⊆ function(*)</code></p>
                           </example>
                        </item>
                        

                        <item>
                           <p>All the following are true:</p>
                              <olist>
                                 <item><p><var>A</var> is <code>
                                    <phrase role="xquery"
                                       >AnnotationsA </phrase>function(<var>a/1</var>, <var>a/2</var>, ... <var>a/M</var>) as <var>R/A</var></code></p></item>
                                 <item><p><var>B</var> is <code>
                                    <phrase role="xquery"
                                       >AnnotationsB </phrase>function(<var>b/1</var>, <var>b/2</var>, ... <var>b/N</var>) as <var>R/B</var></code></p></item>
                                 <item role="xquery"><p><code>[AnnotationsB]</code> and <code>[AnnotationsA]</code> are optional lists of one or more annotations;</p></item>
                                 <item><p><var>N</var> (the arity of <var>B</var>) equals <var>M</var> (the arity of <var>A</var>)
                                    </p></item>
                                 <item><p><code><var>R/A</var> ⊑ <var>R/B</var></code></p></item>
                                 <item><p>For all values of <var>p</var> between 1 and <var>N</var>, <code><var>b/p</var> ⊑ <var>a/p</var></code>
                                    <phrase role="xquery">, and <code>subtype-assertions(AnnotationsA, AnnotationsB)</code>
                                    </phrase></p></item>
                              </olist>
                           <example>
                              <head>Examples:</head>
                              <ulist>
                                 <item><p><code>function(xs:integer) as xs:string ⊆ function(xs:long) as xs:string</code></p></item>
                                 <item><p><code>function(xs:integer) as xs:ID ⊆ function(xs:integer) as xs:string</code></p></item>
                                 <item><p><code>function(xs:integer) as xs:ID ⊆ function(xs:long) as xs:string</code></p></item>
                               
                              </ulist>
                           </example>
                           <note>
 
                              <p>Function return types are covariant because this rule requires <code><var>R/A</var> ⊑ <var>R/B</var></code> for return types. 
                                 Function parameter types are contravariant because this rule requires <code><var>b/p</var> ⊑ <var>a/p</var></code> for parameter types.</p>
                           </note>
                        </item>
                     </olist>
               </div4>
               <div4 id="id-item-subtype-maps">
                  <head>Subtyping Maps</head>
                  <p>Given item types <var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply:</p>
                  
                     <olist>
                        <item>
                           <p>Both of the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is <code>map(<var>K</var>, <var>V</var>)</code>,
                                 for any <var>K</var> and <var>V</var></p></item>
                              <item><p><var>B</var> is <code>map(*)</code></p></item>
                           </olist>
                           <example>
                              <head>Example:</head>
                              <p><code>map(xs:integer, item()*) ⊆ map(*)</code></p>
                           </example>
                        </item>
                        
                        <item>
                           <p>All the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is <code>map(<var>K/a</var>, <var>V/a</var>)</code></p></item>
                              <item><p><var>B</var> is <code>map(<var>K/b</var>, <var>V/b</var>)</code></p></item>
                              <item><p><code><var>K/a</var> ⊆ <var>K/b</var></code></p></item>
                              <item><p><code><var>V/a</var> ⊑ <var>V/b</var></code></p></item>
                           </olist>
                           <example>
                              <head>Example:</head>
                              <p><code>map(xs:long, item()) ⊆ map(xs:integer, item()+)</code></p>
                           </example>
                        </item>
                        
                        <item>
                           <p>Both the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is <code>map(*)</code>
                                 (or, because of the transitivity rules, any other map type)</p></item>
                              <item><p><var>B</var> is <code>function(*)</code></p></item>
                           </olist>
                           <example>
                              <head>Example:</head>
                              <p><code>map(xs:long, xs:string?) ⊆ function(*)</code></p>
                           </example>
                        </item>
                        
                        <item>
                           <p>Both the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is <code>map(*)</code>
                                 (or, because of the transitivity rules, any other map type)</p></item>
                              <item><p><var>B</var> is 
                                 <code>function(xs:anyAtomicType) as item()*</code></p></item>
                           </olist>
                           <example>
                              <head>Example:</head>
                              <p><code>map(xs:long, xs:string?) ⊆ function(xs:anyAtomicType) as item()*</code></p>
                           </example>
                        </item>
                        
                        <item diff="chg" at="issue730">
                           <p>All the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is <code>map(<var>K</var>, <var>V</var>)</code></p></item>
                              <item><p><var>B</var> is <code>function(xs:anyAtomicType) as <var>R</var></code></p></item>
                              <item><p><var>V</var> ⊆ <var>R</var></p></item>
                              <item><p><code>empty-sequence()</code> ⊆ <var>R</var></p></item>
                           </olist>
                           <example>
                              <head>Examples:</head>
                              <ulist>
                                 <item><p><code>map(xs:int, node()) ⊆ function(xs:anyAtomicType) as node()?</code></p></item>
                                 <item><p><code>map(xs:int, node()+) ⊆ function(xs:anyAtomicType) as node()*</code></p></item>
                              </ulist>
                              <p>The function accepts type <code>xs:anyAtomicType</code> rather than <code>xs:int</code>,
                              because <code>$M("xyz")</code> is a valid call on a map (treated as a function) even
                              when all the keys in the map are integers.</p>
                              <p>The return type of the function is extended from <code>node()</code> or <code>node()+</code> to allow an empty sequence
                                 because <code>$M("xyz")</code> can return an empty sequence even if none of the entries
                              in the map contains an empty sequence.</p>
                           </example>
                        </item>
                     </olist>
               </div4>
               <div4 id="id-item-subtype-arrays">
                  <head>Subtyping Arrays</head>
                  <p>Given item types <var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply:</p>
                  
                     <olist>   
                        
                        <item>
                           <p>Both the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is <code>array(<var>X</var>)</code></p></item>
                              <item><p><var>B</var> is <code>array(*)</code></p></item>
                           </olist>
                           <example>
                              <head>Example:</head>
                              <p><code>array(xs:integer) ⊆ array(*)</code></p></example>
                        </item>
                        
                        <item>
                           <p>All the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is <code>array(<var>X</var>)</code></p></item>
                              <item><p><var>B</var> is <code>array(<var>Y</var>)</code></p></item>
                              <item><p><code><var>X</var> ⊑ <var>Y</var></code></p></item>
                           </olist>
                           <example>
                              <head>Example:</head>
                              <p><code>array(xs:integer) ⊆ array(xs:decimal+)</code></p></example>
                        </item>
                        
                        <item>
                           <p>Both the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is <code>array(*)</code>
                                 (or, because of the transitivity rules, any other array type)</p></item>
                              <item><p><var>B</var> is <code>function(*)</code></p></item>
                           </olist>
                           <example>
                              <head>Example:</head>
                              <p><code>array(xs:integer) ⊆ function(*)</code></p>
                           </example>
                        </item>
                        
                        <item>
                           <p>Both the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is <code>array(*)</code>
                                 (or, because of the transitivity rules, any other array type)</p></item>
                              <item><p><var>B</var> is <code>function(xs:integer) as item()*</code></p></item>
                           </olist>
                           <example>
                              <head>Example:</head>
                              <p><code>array(*) ⊆ function(xs:integer) as item()*</code></p>
                           </example>
                        </item>
                      
                        <item>
                           <p>Both the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is <code>array(<var>X</var>)</code></p></item>
                              <item><p><var>B</var> is <code>function(xs:integer) as <var>X</var></code></p></item>
                           </olist>
                           <example>
                              <head>Example:</head>
                              <p><code>array(xs:string) ⊆ function(xs:integer) as xs:string</code></p>
                           </example>
                        </item>
                     </olist>
               </div4>
               <div4 id="id-item-subtype-records">
                  <head>Subtyping Records</head>
                  <p>Given item types <var>A</var> and <var>B</var>, <var>A</var> <code>⊆</code> <var>B</var> is true if any of the following apply:</p>
                  <olist>
                     <item diff="add" at="issue52">
                        <p><var>A</var> is <code>map(*)</code> and <var>B</var> is <code>record(*)</code>.</p>
                     </item>
                     <item diff="add" at="A">
                        <p>All of the following are true:</p>
                        <olist>
                           <item><p><var>A</var> is a record type.</p></item>
                           <item><p><var>B</var> is <code>map(*)</code> or <code>record(*)</code>.</p></item>
                        </olist>
                        <example>
                           <head>Examples:</head>
                           <p><code>record(longitude, latitude)</code> ⊆ <code>map(*)</code></p>
                           <p><code>record(longitude, latitude, *)</code> ⊆ <code>record(*)</code></p>
                           <p><code>record(*)</code> ⊆ <code>map(*)</code></p>
                        </example>
                     </item>
                     
                     <item diff="add" at="A">
                        <p>All of the following are true:</p>
                        <olist>
                           <item><p><var>A</var> is a non-extensible record type</p></item>
                           <item><p><var>B</var> is <code>map(<var>K</var>, <var>V</var>)</code></p></item>
                           <item><p><var>K</var> is either <code>xs:string</code> or <code>xs:anyAtomicType</code></p></item>
                           <item><p>For every field <var>F</var> in <var>A</var>,
                              where <var>T</var> is the declared type of <var>F</var> (or its default, <code>item()*</code>),
                              <code><var>T</var> ⊑ <var>V</var></code>.</p></item>
                        </olist>
                        <example>
                           <head>Examples:</head>
                           <ulist>
                              <item><p><code>record(x, y)</code> ⊆ <code>map(xs:string, item()*)</code></p></item>
                              <item><p><code>record(x as xs:double, y as xs:double)</code> ⊆ <code>map(xs:string, xs:double)</code></p></item>
                           </ulist>
                         </example>
                     </item>
                     
                     <item diff="add" at="A">
                        <p>All of the following are true:</p>
                        <olist>
                           <item><p><var>A</var> is a non-extensible record type.</p></item>
                           <item><p><var>B</var> is a non-extensible record type.</p></item>
                           <item><p>Every field in <var>A</var> is also declared in <var>B</var>.</p></item>
                           <item><p>Every mandatory field in <var>B</var> is also declared  as mandatory in <var>A</var>.</p></item>
                           <item><p>For every field that is declared in both <var>A</var> and <var>B</var>,
                              where the declared type in <var>A</var> is <var>T</var> 
                              and the declared type in <var>B</var> is <var>U</var>, <code><var>T</var> ⊑ <var>U</var></code>.</p>                               
                           </item>
                        </olist>
                        <example>
                           <head>Examples:</head>
                           <ulist>
                              <item><p><code>record(x, y as xs:integer) ⊆ record(x, y as xs:decimal)</code></p></item>
                              <item><p><code>record(x, y) ⊆ record(x, y, z?)</code></p></item>
                           </ulist>
                        </example>
                     </item>
                        
                        <item diff="add" at="A">
                           <p>All of the following are true:</p>
                           <olist>
                              <item><p><var>A</var> is an extensible record type</p></item>
                              <item><p><var>B</var> is an extensible record type</p></item>
                              <item><p>Every mandatory field in <var>B</var> is also declared  as mandatory in <var>A</var>.</p></item>
                              <item><p>For every field that is declared in both <var>A</var> and <var>B</var>,
                                 where the declared type in <var>A</var> is <var>T</var> 
                                 and the declared type in <var>B</var> is <var>U</var>, <code><var>T</var> ⊑ <var>U</var></code>.</p></item> 
                              <item><p>For every field that is declared in <var>B</var>
                                 but not in <var>A</var>, the declared type in <var>B</var> is <code>item()*</code>.</p>
                              </item>  
                           </olist>
                           <example>
                              <head>Examples:</head>
                              <ulist>
                                 <item><p><code>record(x, y, z, *) ⊆ record(x, y, *)</code></p></item>
                                 <item><p><code>record(x?, y?, z?, *) ⊆ record(x, y, *)</code></p></item>
                                 <item><p><code>record(x as xs:integer, y as xs:integer, *) ⊆ record(x as xs:decimal, y as xs:integer*, *)</code></p></item>
                                 <item><p><code>record(x as xs:integer, *) ⊆ record(x as xs:decimal, y as item(), *)</code></p></item>                               
                              </ulist>
                           </example>
                           
                        </item>
                     
                     <item diff="add" at="A">
                        <p>All of the following are true:</p>
                        <olist>
                           <item><p><var>A</var> is a non-extensible record type.</p></item>
                           <item><p><var>B</var> is an extensible record type.</p></item>
                           <item><p>Every mandatory field in <var>B</var> is also declared as mandatory in <var>A</var>.</p></item>
                           <!--<item><p>Every field that is declared in <var>B</var> with a type other than <code>item()*</code>
                              is also declared in <var>A</var>.</p></item>-->
                           <item><p>For every field that is declared in both <var>A</var> and <var>B</var>,
                              where the declared type in <var>A</var> is <var>T</var> 
                              and the declared type in <var>B</var> is <var>U</var>, <code><var>T</var> ⊑ <var>U</var></code>.</p>                               
                           </item>
                        </olist>
                        <example>
                           <head>Examples:</head>
                           <ulist>
                              <item><p><code>record(x, y as xs:integer) ⊆ record(x, y as xs:decimal, *)</code></p></item>
                              <item><p><code>record(y as xs:integer) ⊆ record(x?, y as xs:decimal, *)</code></p></item>
                           </ulist>
                        </example>
                     </item>
                        
                        
                  </olist>
               </div4>
               <div4 id="id-itemtype-subtype-aliases" diff="add" at="issue295">
                  <head>Subtyping of Named Item Types</head>
                  <p>This section describes how references to <termref def="dt-named-item-type">named item types</termref>
                  are handled when evaluating the subtype relationship.</p>
                  <p>Named item types can be classified as recursive or non-recursive. 
                     A recursive type is one that references itself, directly or indirectly. Only named record
                  types are allowed to be recursive.</p>
                  <p>In the case of references to non-recursive named item types, the reference
                  is fully expanded as the first step in evaluating the subtype relationship. For example
                  this means that if <var>U</var> is a named item type with the expansion 
                     <code>(xs:integer | xs:double)</code>,
                     then <code>xs:integer ⊆ U</code> is true, because 
                     <code>xs:integer ⊆ (xs:integer | xs:double)</code> is true.</p>
                  <p>Recursive record types are considered to be, in the terminology of the computer science
                  literature, <term>iso-recursive</term> (rather than <term>equi-recursive</term>). 
                     This means that a recursive type name is not
                  treated as being equivalent to its expansion (at any depth). 
                  For example, if the named item type <var>T</var>
                  has the expansion <code>record(A as item()*, B as T?)</code>, then the type 
                     <code>array(T)</code> is not considered to be equivalent to 
                     <code>array(record(A as item()*, B as T?))</code>, despite the fact
                  that the two types have exactly the same instances.</p>
                  <p>The rules are therefore defined as follows:</p>
                  <ulist>
                     <item><p>If <var>B</var> is a reference to a recursive record type, then
                        <var>A</var> ⊆ <var>B</var> is true if and only if 
                        <var>A</var> and <var>B</var>
                        are references to the same named record type.</p></item>
                     <item><p>If <var>A</var> is a reference to a recursive named item type, then
                        <var>A</var> ⊆ <var>B</var> is true if either:</p>
                        <ulist>
                           <item><p><var>A</var> and <var>B</var>
                              are references to the same named record type.</p></item>
                           <item><p><code>record(*) ⊆ B</code>.</p>
                           <note><p>This is because only record types are allowed to be recursive.</p></note></item>
                        </ulist>
                     </item>
                  </ulist>

                  <note><p>The decision to make recursive types iso-recursive rather than equi-recursive
                  was made largely because it saves a great deal of implementation complexity without any serious
                  adverse effects for users. In practice, problems can be avoided by using named record types
                  consistently (for example, avoiding having two named record types with
                  different names but identical definitions).</p>
                  </note>
               </div4>
   


            </div3>

 

            <div3 id="id-assertions-subtype" role="xquery">
               <head>The judgement <code>subtype-assertions(AnnotationsA, AnnotationsB)</code>
               </head>

               <p>
      The judgement <code>subtype-assertions(AnnotationsA, AnnotationsB)</code> determines if <code>AnnotationsA</code> is a subtype of <code>AnnotationsB</code>,
      where <code>AnnotationsA</code> and <code>AnnotationsB</code> are annotation lists from two FunctionTypes.
      It is defined to ignore function assertions in namespaces not understood by the XQuery
      implementation. For assertions that are understood, their effect on the result
      of <code>subtype-assertions()</code> is implementation defined.
    </p>

               <p>
      The following examples are some possible ways to define <code>subtype-assertions()</code> for some
      implementation defined assertions in the <code>local</code> namespace. These examples assume that some implementation uses annotations to label functions as deterministic or nondeterministic, and treats deterministic functions as a subset of nondeterministic functions. In this implementation, nondeterministic functions are not a subset of deterministic functions.
    </p>

               <ulist>
                  <item>
                     <p>
        AnnotationsA is
        <eg><![CDATA[%local:inline]]></eg>
        It has no influence on the outcome of <code>subtype-assertions()</code>.
      </p>
                  </item>
                  <item>
                     <p>
        AnnotationsA is
        <eg><![CDATA[%local:deterministic]]></eg>
        AnnotationsB is
        <eg><![CDATA[%local:nondeterministic]]></eg>
        Since deterministic functions are a subset of nondeterministic functions, <code>subtype-assertions()</code> is true.
      </p>
                  </item>
                  <item>
                     <p>
        AnnotationsA contains
        <eg><![CDATA[%local:nondeterministic]]></eg>
        AnnotationsB is empty.
        If FunctionTypes without the <code>%local:nondeterministic</code> annotation only match deterministic functions,
        <code>subtype-assertions()</code> must be false.
      </p>
                  </item>
               </ulist>

            </div3>

         </div2>
         
      
         <div2 id="id-coercion-rules">
               <head>Coercion Rules</head>
            
            <changes>
               <change PR="254" date="2022-11-29">
                  The term "function conversion rules" used in 3.1 has been replaced by the term "coercion rules".
               </change>
               <change issue="117" PR="254" date="2022-11-29">
                  The coercion rules allow “relabeling” of a supplied atomic item where
                  the required type is a derived atomic type: for example, it is now permitted to supply
                  the value 3 when calling a function that expects an instance of <code>xs:positiveInteger</code>.
               </change>
               <change issue="980" PR="911" date="2024-01-30">
                  The coercion rules now allow any numeric type to be implicitly converted to any other, for example
                  an <code>xs:double</code> is accepted where the required type is <code>xs:double</code>.
               </change>
               <change issue="130 480" PR="815" date="2023-11-07">
                  The coercion rules now allow conversion in either direction between <code>xs:hexBinary</code>
                  and <code>xs:base64Binary</code>.
               </change>
            </changes>

               <p diff="chg" at="2022-11-17">
                  <termdef term="coercion rules" id="dt-coercion-rules"
                        >The <term>coercion rules</term> are rules used to convert a supplied value to a required type,
                     for example when converting an argument of a function call to the declared type of the function parameter.
                  </termdef> The required type is expressed as a <termref def="dt-sequence-type"
                     >sequence type</termref>. The effect of the coercion rules may be to accept the value as supplied,
                  to convert it to a value that matches the required type, or to reject it with a type error.</p>
                        
               <p diff="chg" at="2022-11-17">This section defines how the coercion rules operate; the situations in which the rules apply
                  are defined elsewhere, by reference to this section.</p>
                        
                        <note diff="add" at="A">
                           <p>In previous versions of this specification, the coercion rules were referred to as the
                              <emph>function conversion</emph> rules. The terminology has changed because the rules are not exclusively
                              associated with functions or function calling.</p>
                        </note>
            
               <p diff="chg" at="2023-03-11">If the required type is <code>empty-sequence()</code>, 
                  no coercion takes place (the supplied
               value must be an empty sequence, or a type error occurs).</p>
            
            <p>In all other cases, the required 
                  <termref def="dt-sequence-type"/> <var>T</var> comprises a required <termref def="dt-item-type"/> <var>R</var> 
                  and an optional occurrence indicator. The coercion rules are then 
                  applied to a supplied value <var>V</var> 
               and the required type <var>T</var> as follows:</p>
            
            <olist>
               <item role="xpath">
                  <p>If  <termref def="dt-xpath-compat-mode">XPath
                     1.0 compatibility mode</termref> is <code>true</code> and <var>V</var>
                     is not an instance of the required type <var>T</var>, then the conversions defined in
                     <specref ref="id-xpath-10-compatibility"/> are applied to <var>V</var>. Then:</p>
               </item>
               <item>
                  <p>Each item in <var>V</var> is processed against the required item type <var>R</var>
                     using the item coercion rules defined
                  in <specref ref="id-item-coercion-rules"/>, and the results are sequence-concatenated
                  into a single sequence <var>V'</var>.</p>
               </item>
               <item><p>A type error is raised if the cardinality of <var>V'</var> does not match the
                  required cardinality of <var>T</var> <errorref code="0004" class="TY"/>.</p></item>
            </olist>
            
            <div3 id="id-xpath-10-compatibility" role="xpath">
               <head>XPath 1.0 Compatibility Rules</head>
               <p>These rules are used to process a value <var>V</var> against a required sequence type 
                  <var>T</var> when 
                  <termref def="dt-xpath-compat-mode">XPath 1.0 compatibility mode</termref> is <code>true</code>.</p>
               <olist>
                  
                  <item>
                     <p>If the occurrence indicator of <var>T</var> is either absent or <code>?</code>
                        (examples: <code>xs:string</code>, <code>xs:string?</code>, 
                        <code>xs:untypedAtomic</code>, <code>xs:untypedAtomic?</code>, 
                        <code>node()</code>, <code>node()?</code>, <code>item()</code>, 
                        <code>item()?</code>), then <var>V</var> is effectively replaced by <code>V[1]</code>.</p>
                  </item>
                  
                  <item>
                     <p>If <var>T</var> is <code>xs:string</code> or <code>xs:string?</code>,
                        then <var>V</var> is effectively replaced by
                        <code>fn:string(V)</code>.</p>
                     <note diff="add" at="2022-11-17"><p>This rule does not apply where <var>T</var> is derived from <code>xs:string</code>
                        or <code>xs:string?</code>, because derived types did not arise in XPath 1.0.</p></note>
                  </item>
                  
                  <item>
                     <p>If <var>T</var> is <code>xs:double</code> or <code>xs:double?</code>, then 
                        <code>V</code> is effectively replaced by <code>fn:number(V)</code>.</p>
                     <note diff="add" at="2022-11-17"><p>This rule does not apply where <var>T</var> is derived from <code>xs:double</code>
                        or <code>xs:double?</code>, because derived types did not arise in XPath 1.0.</p></note>
                  </item>
               </olist>
               
               <note>
                  <p>
                     The special rules for <termref def="dt-xpath-compat-mode"
                        >XPath 1.0 compatibility
                        mode</termref> are used for converting the arguments of a static function call, and
                     in certain XSLT constructs. They are not invoked in other contexts such as dynamic function calls,
                     for converting the result of an inline function to its required type,
                     for partial function application, or for implicit function calls such as
                     occur when evaluating functions such as <function>fn:for-each</function> and <function>fn:filter</function>.</p>
               </note>
               
               
            </div3>
            
            <div3 id="id-item-coercion-rules">
               <head>Item Coercion Rules</head>
               <p>The rules in this section are used to process each item <var>J</var> in a supplied
               sequence, given a required <termref def="dt-item-type"/> <var>R</var>.</p>
               
               <olist>
                  <item><p>If <var>R</var> is a <termref def="dt-generalized-atomic-type"/>
                     (for example, if it is an <termref def="dt-atomic-type"/>,
                     a <termref def="dt-pure-union-type"/>, or
                     an <termref def="dt-enumeration-type"/>), and <var>J</var>
                     is not an atomic item, then:
                     <olist>
                        <item><p><var>J</var> is atomized to produce a sequence of atomic items
                        <var>JJ</var>.</p></item>
                        <item><p>Each atomic item in <var>JJ</var> is coerced to the required
                        type <var>R</var> by recursive application of the item coercion rules (the 
                        rules in this section) to produce a value <var>V</var>.</p></item>
                        <item><p>The result is the sequence-concatenation of the <var>V</var> values.</p></item>
                     </olist>
                  </p>
                  <note><p>For example, if <code>J</code> is an element with type annotation
                  <code>xs:integer</code>, and <code>R</code> is the union type <code>xs:numeric</code>,
                  then the effect is to atomize the element to an <code>xs:integer</code>, and then
                  to coerce the resulting <code>xs:integer</code> to <code>xs:numeric</code>
                  (which leaves the integer unchanged). This is not the same as attempting to
                  coerce the element to each of the alternatives of the union type in turn, which
                  would deliver an instance of <code>xs:double</code>.</p></note>
                  </item>
                  <item><p>Otherwise, if <var>R</var> is a <termref def="dt-choice-item-type"/> or
                     a <termref def="dt-pure-union-type"/> (which includes the case where
                     it is an <termref def="dt-enumeration-type"/>), then:</p>
                     
                     <olist>
                        <item><p>If <var>J</var> matches (is an instance of) one of the alternatives
                           in <var>R</var>, then:</p>
                        
                           <olist>
                              <item><p>If the first alternative in <var>R</var> that <var>J</var>
                              matches is a typed function type (see <specref ref="id-function-test"/>),
                              then function coercion is applied to coerce <var>J</var> to that
                              function type, as described in <specref ref="id-function-coercion"/>.</p></item>
                              <item><p>Otherwise, <var>J</var> is used as is.</p></item>
                           </olist>
                        
                        </item>

                        <item>
                           <p>Otherwise, the item coercion rules (the rules in this section)
                              are applied to <var>J</var> recursively
                              with <var>R</var> set to each of the alternatives in the
                              choice or union item type, in order, until an alternative is found that
                              does not result in a type error; a type error is raised
                              only if all alternatives fail.</p>
                           <p>The error code used in the event of failure 
                              should be the error code arising from the
                              first unsuccessful matching attempt. (The diagnostic information
                              associated with the error may also describe how further attempts
                              failed.)</p>
                        </item>
                     </olist>
                    
                     
                     <note>
                        <p>Suppose the required type is <code>(xs:integer | element(e))*</code>
                           and the supplied value is the sequence 
                           <code><![CDATA[(<e>22</e>, 23, <f>24</f>)]]></code>. 
                        Item coercion is applied independently to each of the three items in this
                        sequence. The first item matches one of the alternatives, namely <code>element(e)</code>,
                        so it is returned unchanged as an element node. The second item (the integer 23) also matches one of the
                        alternatives, and is returned unchanged as an integer. The third item does not match any of
                        the alternatives, so coercion is attempted to each one in turn. Coercion
                        to type <code>xs:integer</code> succeeds (by virtue of atomization and untyped
                           atomic conversion), so the final result is the sequence <code><![CDATA[(<e>22</e>, 23, 24)]]></code></p>
                     </note>
                     <note>
                        <p>Suppose the required type is <code>enum("red", "green", "blue")</code>
                           and the supplied value is <code>"green"</code>. The enumeration type is defined
                           as a choice item type whose alternatives are singleton enumerations, so the rules
                           are applied first to the type <code>enum("red")</code> (which fails), and
                           then to the type <code>enum("green")</code> (which succeeds). The strings in an
                           enumeration type are required to be distinct so the order
                           of checking is in this case immaterial. The supplied value will be accepted, and
                           will be relabeled as an instance of <code>enum("green")</code>, which is treated
                           as a schema type equivalent to a type derived from <code>xs:string</code> by 
                           restriction.</p>
                     </note>
                     <note><p>Schema-defined union types behave in exactly the same way as
                        <termref def="dt-choice-item-type">choice item types.</termref></p></note>
                  </item>
                  
                  <!--<item>
                     <p>If <var>R</var> is an <termref def="dt-atomic-type"/>
                        and <var>J</var> is not an atomic item,
                        then <var>J</var> is <termref def="dt-atomization">atomized</termref>. 
                        The result of atomization is
                        in general a sequence of atomic items. The item coercion rules
                        (that is, the rules in this section) are then applied recursively to each of
                        these atomic items in turn, with the same item type <var>R</var>
                        as the required type, and the results are concatenated
                        in order to form the result sequence.</p>
                  </item>-->
                        
                  <item>
                     <p>If <var>R</var> is an <termref def="dt-atomic-type"/>
                     and <var>J</var> is an <termref def="dt-atomic-item"/>, then:</p>

                           <olist>
                              <item diff="chg" at="2024-01-04"><p>If <var>J</var> is an instance of 
                                 <var>R</var> then it is used unchanged.</p></item>
                              <item><p>If <var>J</var> is an instance of type <code>xs:untypedAtomic</code>
                              then:</p>
                                 <olist>
                                    <item>
                                       <p>If <var>R</var> is an 
                                       <termref def="dt-enumeration-type"/> then
                                       <var>A</var> is cast to <code>xs:string</code>.</p></item>
                                    <item>
                                       <p>If <var>R</var> is <termref
                                       def="dt-namespace-sensitive">namespace-sensitive</termref> then 
                                          a <termref def="dt-type-error">type error</termref>
                                             <errorref class="TY" code="0117"/> is raised.</p></item>
                                       </olist>
                                    </item>
                                    <item><p>Otherwise,  <var>J</var> is cast to type <var>R</var>.</p>
                                    </item>
                                 </olist>
                              </item>
                              
  
                              <item><p>If there is an entry (<var>from</var>, <var>to</var>)
                                 in the following table such that <var>J</var> is an instance of <var>from</var>,
                                 and <var>to</var> is <var>R</var>, then <var>J</var> is cast to type <var>R</var>.</p>
                                 
                                 <table border="1" role="medium">
                                    <caption>Implicit Casting</caption>
                                    <thead>
                                       <tr>
                                          <th>from</th>
                                          <th>to</th>
                                       </tr>
                                    </thead>
                                    <tbody>
                                       <tr><td><code>xs:decimal</code></td><td><code>xs:double</code></td></tr>
                                       <tr><td><code>xs:double</code></td><td><code>xs:decimal</code></td></tr>
                                       <tr><td><code>xs:decimal</code></td><td><code>xs:float</code></td></tr>
                                       <tr><td><code>xs:float</code></td><td><code>xs:decimal</code></td></tr>
                                       <tr><td><code>xs:float</code></td><td><code>xs:double</code></td></tr>
                                       <tr><td><code>xs:double</code></td><td><code>xs:float</code></td></tr>
                                       <tr><td><code>xs:string</code></td><td><code>xs:anyURI</code></td></tr>
                                       <tr><td><code>xs:anyURI</code></td><td><code>xs:string</code></td></tr>
                                       <tr><td><code>xs:hexBinary</code></td><td><code>xs:base64Binary</code></td></tr>
                                       <tr><td><code>xs:base64Binary</code></td><td><code>xs:hexBinary</code></td></tr>
                                    </tbody>
                                    
                                 </table>
                                 
                                 <note><p>The item type in the <var>to</var> column must match <var>R</var>
                                    exactly; however, <var>J</var> may belong to a subtype of the type in the <var>from</var>
                                    column.</p>
                                    <p>For example, an <code>xs:NCName</code> will be cast to type <code>xs:anyURI</code>,
                                    but an <code>xs:anyURI</code> will not be cast to type <code>xs:NCName</code>.</p>
                                    <p>Similarly, an <code>xs:integer</code> will be cast to type <code>xs:double</code>,
                                    but an <code>xs:double</code> will not be cast to type <code>xs:integer</code>.</p>
                                 </note>
                                 
                              </item>
                              <item><p>If <var>R</var> is derived from some primitive atomic type <var>P</var>, 
                                 then <var>J</var> is <term>relabeled</term> as an instance of <var>R</var> if it satisfies
                                 all the following conditions:</p> 
                                 <ulist>
                                    <item><p><var>J</var> is an instance of <var>P</var>.</p></item>
                                    <item><p><var>J</var> is not an instance of <var>R</var>.</p></item>
                                    <item><p>The <xtermref spec="DM40" ref="dt-datum"/> of <var>J</var> is 
                                       within the value space of <var>R</var>.</p></item>
                                 </ulist>
                                 <p>Relabeling an atomic item changes the <termref def="dt-type-annotation"/> but not the 
                                    <xtermref spec="DM40" ref="dt-datum"/>. For example, the
                                    <code>xs:integer</code> value 3 can be relabeled as an instance of <code>xs:unsignedByte</code>, because
                                    the datum is within the value space of <code>xs:unsignedByte</code>.</p>
                                 <note><p>Relabeling is not the same as casting. For example, the <code>xs:decimal</code> value 10.1
                                    can be cast to <code>xs:integer</code>, but it cannot be relabeled as <code>xs:integer</code>,
                                    because its datum not within the value space of <code>xs:integer</code>.</p></note>
                              
                                 <note><p>The effect of this rule is that if, for example, a function parameter is declared
                                    with an expected type of <code>xs:positiveInteger</code>, then a call that supplies the literal
                                    value 3 will succeed, whereas a call that supplies -3 will fail.</p>
                                 
                                    <p>This differs from previous versions of this specification, where both these calls would fail.</p>
                                    
                                    <p>This change allows the arguments of existing functions to be defined with a
                                       
                                       more precise type. For example, the <code>$position</code> argument of <function>array:get</function>
                                       
                                       could be defined as <code>xs:positiveInteger</code> 
                                       rather than <code>xs:integer</code>.</p>
                                 </note>
                                 <note>
                                    <p>If <var>T</var>
                                       is a union type with members <code>xs:negativeInteger</code> and 
                                       <code>xs:positiveInteger)*</code> and the supplied value is the
                                       sequence <code>(20, -20)</code>, then the effect of these rules 
                                       is that the first item <code>20</code> is relabeled as type
                                       <code>xs:positiveInteger</code> and the second item <code>-20</code>is relabeled as type 
                                       <code>xs:negativeInteger</code>.</p>
                                    
                                    
                                 
                                 </note>
                                 
                                 <note><p>Promotion (for example of <code>xs:float</code> to <code>xs:double</code>)
                                    occurs only when <var>T</var> is a primitive type.
                                    Relabeling occurs only when <var>T</var> is a derived type. Promotion and relabeling are therefore
                                    never combined.</p></note>
                              
                                 <note><p>A singleton enumeration type such as <code>enum("green")</code> is treated
                                 as an atomic type derived by restriction from <code>xs:string</code>; so if the
                                 <code>xs:string</code> value <code>"green"</code> is supplied in a context where
                                 the required type is <code>enum("red", "green", "blue")</code>, the value will be
                                    accepted and will be relabeled as an instance of <code>enum("green")</code>.</p></note>
                              
                              </item>
                              
                  <item diff="add" at="A">
                     <p>If <var>R</var> is an <nt def="ArrayType"
                        >ArrayType</nt> other than <code>array(*)</code> and <var>J</var>
                        is an array, then <var>J</var> is converted to a new array by converting
                        each member to the required member type by applying the coercion rules
                        recursively.</p>
                     <note><p>For example, if the required type is
                     <code>array(xs:double)</code> and the supplied value is
                        <code>[ 1, 2 ]</code>, the array is converted to
                        <code>[ 1e0, 2e0 ]</code>.</p></note>
                  </item>
                              
                  <item diff="add" at="A">
                     <p>If <var>R</var> is a <nt def="MapType"
                        >MapType</nt> other than <code>map(*)</code> and <var>J</var>
                        is a map, then <var>J</var> is converted to a new map as follows:</p>
                     <olist>
                        <item><p>Each key in the supplied map is converted to the required
                           map key type by applying the coercion rules. If the resulting map would
                           contain duplicate keys, a type error is raised
                           <errorref class="TY" code="0004"/>.</p></item>
                        <item><p>The corresponding value is converted to the required
                           map value type by applying the coercion rules recursively.</p></item>
                     </olist>

                     <note><p>For example, if the required type is
                     <code>map(xs:string, xs:double)</code> and the supplied value is
                        <code>{ "x": 1, "y": 2 }</code>, the map is converted to
                        <code>{ "x": 1e0, "y": 2e0 }</code>.</p></note>
                     <note><p>Duplicate keys can occur if the value space of the target type
                        is more restrictive than the original type. For example, an error is raised
                        if the map <code>{ 1.2: 0, 1.2000001: 0 }</code>, which contains two keys
                        of type <code>xs:decimal</code>, is coerced to the type
                        <code>map(xs:float, xs:integer)</code>.</p></note>
                  </item>

                  <item diff="add" at="A">
                     <p>If <var>R</var> is a <nt def="RecordType"
                           >RecordType</nt> and <var>J</var> is a map, then <var>J</var> is converted
                        to a new map as follows:</p>
                     <olist>
                        <item><p>The keys in the supplied map are unchanged.</p></item>
                        <item><p>In any map entry whose key is an <code>xs:string</code> equal to the
                        name of one of the field declarations in <var>R</var>, the corresponding
                           value is converted to the required type defined by that field declaration, 
                           by applying the coercion rules recursively 
                           (but with XPath 1.0 compatibility mode treated as false).</p></item>
                     </olist>

                     <note><p>For example, if the required type is
                     <code>record(longitude as xs:double, latitude as xs:double)</code> and the supplied value is <code>{ "longitude": 0, "latitude": 53.2 }</code>,
                        then the map is converted to <code>{ "longitude": 0.0e0, "latitude": 53.2e0 }</code>.</p></note>
                  </item>

                  <item>
                     <p>If <var>R</var> is a <nt def="TypedFunctionType"
                        >TypedFunctionType</nt> and <var>J</var> is a function item, then <termref
                           def="dt-function-coercion"
                        >function coercion</termref> is applied to <var>J</var>.</p>
                     <note>
                        <p>Function coercion applies even if <var>J</var> is already an instance
                        of <var>R</var>.</p>
                        <p>Maps and arrays are functions, so function coercion applies to them as well.</p>
                     </note>
                  </item>

                  <item>
                     <p> If, after the
		above conversions, the resulting item does not match
		the expected item type <var>R</var> according to the rules for <termref
                           def="dt-sequencetype-matching"
                           >SequenceType
		Matching</termref>, a type error is
		raised <errorref class="TY" code="0004"
                           />.</p>
                     <note diff="add" at="Issue602">
                        <p>Under the general rules for type errors 
                           (see <specref ref="id-kinds-of-errors"/>), a processor
                        <rfc2119>may</rfc2119> report a type error during static
                        analysis if it will necessarily occur when the expression is evaluated.
                        For example, the function call <code>fn:abs("beer")</code>
                        will necessarily fail when evaluated, because the function requires
                        a numeric value as its argument; this <rfc2119>may</rfc2119> be detected and reported
                        as a static error.</p>
                     </note>   
		
                  </item>
               </olist>
            </div3>
            <div3 id="id-implausible-coercions" diff="add" at="2023-06-01">
               <head>Implausible Coercions</head>
               
            <p>An expression is deemed to be
                     <termref def="dt-implausible"/> <errorref
                        class="TY" code="0006"/> if the static type of the expression, after applying
                     all necessary coercions, is <term>substantively disjoint</term>
                     with the required type <var>T</var>.</p>
            <p><termdef id="dt-substantively-disjoint" term="substantively disjoint" open="true">Two 
               <termref def="dt-sequence-type">sequence types</termref> are
                     deemed to be <term>substantively disjoint</term> if (a) neither is a subtype
                     of the other (see <specref ref="id-seqtype-subtype"/>) and 
                     (b) the only values that
                     are instances of both types are one or more of the following:</termdef></p>
                     <ulist>
                        <item><p>The empty sequence, <code>()</code>.</p></item>
                        <item><p>The <xtermref spec="DM40" ref="dt-empty-map"/>, <code>{}</code>.</p></item>
                        <item><p>The <xtermref spec="DM40" ref="dt-empty-array"/>, <code>[]</code>.</p></item>
                     </ulist>
               <p role="closetermdef"/>
                     
                     <note>
                        <p>Examples of pairs of sequence types that are substantively disjoint
                        include:</p>
                        <ulist>
                           <item><p><code>xs:integer*</code> and <code>xs:string*</code></p></item>
                           <item><p><code>map(xs:integer, node())</code> and <code>map(xs:string, node())</code></p></item>
                           <item><p><code>array(xs:integer)</code> and <code>array(xs:string)</code></p></item>
                        </ulist>
                     </note>
                  <p>For example, supplying a value whose static type is <code>xs:integer*</code>
                     when the required type is <code>xs:string*</code> is <termref def="dt-implausible"/>,
                     because it can succeed only in the special case where the actual value supplied
                     is an empty sequence.</p>
                  <note><p>The case where the supplied type and the required type are completely
                  disjoint (for example <code>map(*)</code> and <code>array(*)</code>) is covered
                  by the general rules for type errors: that case can always be reported as a static
                  error.</p></note>
               
               <p>Examples of implausible coercions include the following:</p>
               
               <ulist>
                  <item><p><code>round(timezone-from-time($now))</code>. The result of <function>fn:timezone-from-time</function>
                  is of type <code>xs:dayTimeDuration?</code>, which is substantively disjoint with the required type
                  of <function>fn:round</function>, namely <code>xs:numeric?</code>.</p></item>
                  <item><p><code>function($x as xs:integer) as array(xs:string) { array { 1 to $x } }</code>. The type
                  of the function body is <code>array(xs:integer)</code>, which is substantively disjoint with the
                  required type <code>array(xs:string)</code>: the function can succeed only in the exceptional case
                  where the function body delivers an <xtermref spec="DM40" ref="dt-empty-array"/>.</p></item>
               </ulist>
                  
            </div3>
               

            <div3 id="id-function-coercion">
               <head>Function Coercion</head>
               
               <changes>
                  <change>
                     Function coercion now allows a function with arity <var>N</var> to be supplied where a function of arity 
                     greater than <var>N</var> is expected. For example this allows the function <code>true#0</code> 
                     to be supplied where a predicate function is required.
                  </change>
                  <change issue="1020" PR="1023 1128" date="2024-04-09">
                     It has been clarified that function coercion applies even when the supplied function item
                     matches the required function type. This is to ensure that arguments supplied when calling
                     the function are checked against the signature of the required function type, which might
                     be stricter than the signature of the supplied function item.
                  </change>
               </changes>
               <p>
        Function coercion is a transformation applied to <termref def="dt-function-item"
                     >function items</termref> during application of the
        <termref
                     def="dt-coercion-rules">coercion rules</termref>.
        <termdef
                     term="function coercion" id="dt-function-coercion">
                     <term>Function coercion</term> wraps a <termref def="dt-function-item"/>
        in a new function whose signature is the same as the expected type.
        This effectively delays the checking
        of the argument and return types
        until the function is called.</termdef>
               </p>

               <p>Given a function <var>F</var>, and an expected function type <var>T</var>,
                  <termref
                     def="dt-function-coercion"
                  >function coercion</termref>
	proceeds as follows:</p>
               <olist>
                  <item>
                     <p>If <var>F</var> has higher arity than <var>T</var>,
                     a type error is raised <errorref
                           class="TY" code="0004"/></p>
                  </item>
                  <item diff="add" at="A">
                     <p>If <var>F</var> has lower arity than <var>T</var>,
                     then <var>F</var> is wrapped in a new function that declares and ignores the
                  additional argument; the following steps are then applied to this new function.</p>
                     <p>For example, if <var>T</var> is <code>function(node(), xs:boolean) as xs:string</code>,
                  and the supplied function is <function>fn:name#1</function>, then the supplied function is effectively
                  replaced by <code>function($n as node(), $b as xs:boolean) as xs:string { fn:name($n) }</code></p>
                     <note>
                        <p>This mechanism makes it easier to design versatile and extensible higher-order functions. 
                     For example, in previous versions of this specification, the second argument of
                     the <function>fn:filter</function> function expected an argument of type 
                     <code>function(item()) as xs:boolean</code>. This has now been extended to
                     <code>function(item(), xs:integer) as xs:boolean</code>, but existing code continues
                     to work, because callback functions that are not interested in the value of the second
                     argument simply ignore it.                    
                  </p>
                        
                     </note>
                  </item>
                  
                  <item>
                     <p>A type error is raised <errorref class="TY" code="0004"/> 
                        if, for any parameter type, or for the result type, the 
                        relevant type in the signature of the supplied function and the relevant type
                        in the expected function type are <termref def="dt-substantively-disjoint"/>.
                     </p>
                     <p>For example, the types <code>xs:integer</code> and <code>xs:string</code>
                     are substantively disjoint, so a function with signature <code>function(xs:integer) as xs:boolean</code>
                        cannot be supplied where the expected type is <code>function(xs:string) as xs:boolean</code>.</p>
                  </item>


                  <item>
                     <p>Function coercion then
        returns a new <termref def="dt-function-item"/>
        with the following properties
        (as defined in <xspecref
                           spec="DM40" ref="function-items"/>):

        <ulist>
                           <item>
                              <p>
                                 <term>name</term>:
            The name of <var>F</var> <phrase diff="add" at="B">(if not absent)</phrase>.
          </p>
                           </item>
           <item><p diff="add" at="2023-05-25"><term>identity</term>: A new function
              identity distinct from the identity of any other function item.</p>
              <note><p>See also <specref ref="id-function-identity"/>.</p></note>
           </item>
                           <item>
                              <p>
                                 <term>parameter names</term>:
	      The parameter names of <var>F</var>.
            </p>
                           </item>
                           <item>
                              <p>
                                 <term>signature</term>:
            <code>Annotations</code> is set to the annotations of <var>F</var>. <code>TypedFunctionType</code> is set to the expected type.
          </p>
                           </item>
                           <item>
                              <p>
                                 <term>implementation</term>:
            In effect,
            a <code>FunctionBody</code> that calls <var>F</var>,
            passing it the parameters of this new function,
            in order.
          </p>
                           </item>
                           <item>
                              <p>
                                 <term>nonlocal variable bindings</term>:
            An empty mapping.
          </p>
                           </item>
                        </ulist>
                     </p>
                  </item>
               </olist>
               <!--<p>
        If the result of invoking the new function would
        necessarily result in a type error, that
        error may be raised during
                  <termref
                     def="dt-function-coercion"
                  >function coercion</termref>. It is implementation dependent whether this
        happens or not.
      </p>-->

               <p>
        These rules have the following consequences:

        <ulist>
           <item>
             <p>SequenceType matching of the function’s arguments and result are delayed until that function is called.
          </p>
           </item>
           <item>
              <p>When the coerced function is called, the supplied arguments must match the parameter
              typed defined in <var>T</var>; it is not sufficient to match the parameter types defined
              in <var>F</var>.</p>
           </item>
           
                     <item>
                        <p>
                           The <termref def="dt-coercion-rules"
                              >coercion rules</termref> rules applied to the function’s arguments and result are defined by the SequenceType
            it has most recently been coerced to. Additional coercion rules could apply when the wrapped function
            is called.
          </p>
                     </item>
                     <item>
                        <p>
            If an implementation has static type information about a function, that can be used to type check the
            function’s argument and return types during static analysis.
          </p>
                     </item>
           <item><p>When function coercion is applied to a map or an array, the resulting function is not
           a map or array, and cannot be used as such. For example, the expression </p>
              <eg>let $f as function(xs:integer) as xs:boolean := { 0: false(), 1: true() }
return $f?0</eg>
           <p>raises a type error, because a lookup expression requires the left hand
           operand to be a map or array, and <code>$f</code> is neither.</p></item>
           <item>
              <p>When function types are used as alternatives in a <termref def="dt-choice-item-type"/>,
                 the supplied function is coerced to the first alternative for which coercion does
                 not raise a type error. In this situation it is important to write the alternatives
                 in order, with the most specific first. </p>
           </item>
                  </ulist>
               </p>

               <p role="xquery">
      For instance, consider the following query:
      <eg
                     role="parse-test"><![CDATA[
declare function local:filter(
  $s as item()*, 
  $p as function(xs:string) as xs:boolean
) as item()* {
  $s[$p(.)]
};
let $f := function($a) { starts-with($a, "E") }
return local:filter(("Ethel", "Enid", "Gertrude"), $f)
      ]]></eg>
               </p>

               <p role="xquery"
                     >
        The function <code>$f</code> has a static type of <code>function(item()*) as item()*</code>. When the <code>local:filter()</code> function
        is called, the following occurs to the function:

        <olist>
                     <item>
                        <p>
                           The <termref def="dt-coercion-rules"
                              >coercion rules</termref> result in applying 
                           <termref
                              def="dt-function-coercion"
                              >function coercion</termref> to 
            <code>$f</code>,
            wrapping $f in a new function (<code>$p</code>)
            with the signature <code>function(xs:string) as xs:boolean</code>.
          </p>
                     </item>
                     <item>
                        <p>
            <code>$p</code> is matched against the SequenceType of <code>function(xs:string) as xs:boolean</code>, and succeeds.
          </p>
                     </item>
                     <item>
                        <p>
                           When <code>$p</code> is called inside the predicate, <termref
                              def="dt-coercion-rules"
                              >coercion</termref> 
                           and SequenceType matching rules are applied to the context value argument,
            resulting in an <code>xs:string</code> value or a type error.
          </p>
                     </item>
                     <item>
                        <p>
            <code>$f</code> is called with the <code>xs:string</code>, which returns an <code>xs:boolean</code>.
          </p>
                     </item>
                     <item>
                        <p><code>$p</code> applies <termref def="dt-coercion-rules"
                              >coercion rules</termref> to the result sequence from <code>$f</code>, 
                           which already matches its declared return type of <code>xs:boolean</code>.
          </p>
                     </item>
                     <item>
                        <p>
            The <code>xs:boolean</code> is returned as the result of <code>$p</code>.
          </p>
                     </item>
                  </olist>
               </p>

               <note>
                  <p>
                     The semantics of <termref
                        def="dt-function-coercion"
                     >function coercion</termref> are specified in terms of wrapping the functions.
        Static typing may be able to reduce the number of places where this is actually necessary.
        However, it cannot be assumed that because a supplied function is an instance of the required
        function type, no function coercion is necessary: the supplied function might not perform
        all required checks on the types of its arguments.
      </p>
               </note>

               <p>Since maps and arrays are also functions in &language;, 
                  <termref
                     def="dt-function-coercion"
                  >function coercion</termref> applies to them as well.

        For instance, consider the following expression:
      </p>

               <eg role="parse-test"><![CDATA[
let $m := {
  "Monday" : true(),
  "Wednesday" : false(),
  "Friday" : true()
}
let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
return filter($days, $m)
      ]]></eg>

               <p>
        The map <code>$m</code> is an instance of 
                  <code>function(xs:anyAtomicType?) as item()*</code>. 
                  When the <code>fn:filter()</code> function is called, the following 
                  occurs to the map:

<olist>
                     <item>
                        <p>The map <code>$m</code> is treated as a function equivalent to <code>map:get($m, ?)</code>.</p>
                     </item>
                     <item>
                        <p>The <termref def="dt-coercion-rules"
                              >coercion rules</termref> result in applying 
                           <termref
                              def="dt-function-coercion"
                              >function coercion</termref> 
                           to this function, wrapping it in a new function (<var>M'</var>) with the 
                           signature <code>function(item(), xs:integer) as xs:boolean</code>.</p>
                     </item>
                     <item>
                        <p>When <var>M'</var> is called by <code>fn:filter()</code>, <termref
                              def="dt-coercion-rules"
                              >coercion</termref> 
                           and SequenceType matching rules are applied to the argument, 
                           resulting in an <code>item()</code> value 
                           (<code>$a</code>) or a type error.</p>
                     </item>
                     <item>
                        <p>
                           The function <code>map:get($m, ?)</code> is called with <code>$a</code>
                           as the argument; this returns either an <code>xs:boolean</code> or the empty sequence
                           (call the result <var>R</var>).</p>
                     </item>
                     <item>
                        <p>
                           The wrapper function <code>$p</code> applies the <termref def="dt-coercion-rules"/>
                              to <var>R</var>. If <var>R</var> is an <code>xs:boolean</code> the matching succeeds. 
                              When it is an empty sequence (in particular, <code>$m</code> does not contain a 
                           key for <code>"Tuesday"</code>), a type error is raised <errorref
                              class="TY" code="0004"
                              />, since the expected type is <code>xs:boolean</code> 
                           and the actual type is an empty sequence.</p>
                     </item>
                  </olist>
               </p>

               <p>Consider the following expression:
      </p>

               <eg role="parse-test"><![CDATA[

let $m := {
   "Monday" : true(),
   "Wednesday" : false(),
   "Friday" : true(),
}
let $days := ("Monday", "Wednesday", "Friday")
return filter($days, $m)
      ]]></eg>

               <p>In this case the result of the expression is the sequence <code>("Monday", "Friday")</code>.
                  But if the input sequence included the string <code>"Tuesday"</code>, the filter operation
                  would fail with a type error.
               </p>
               
               <note diff="add" at="issue1020">
                  <p>Function coercion applies even if the supplied function matches the required type.</p>
                  <p>For example, consider this case:</p>
                  <eg
                     role="parse-test"><![CDATA[
declare function local:filter(
  $s as item()*, 
  $p as function(xs:string) as xs:boolean
) as item()* {
  $s[$p(.)]
};

let $f := function($a) { $a mod 2 = 0 }
return local:filter(1 to 10, $f)
      ]]></eg>
                  
                  <p>Here the supplied function <code>$f</code> is an instance of the required type,
                  because its signature defaults the argument type to <code>item()*</code>, which
                  is a supertype of <code>xs:string</code>. The expression <code>$s[$p(.)]</code>
                  could in principle succeed. However, function coercion ensures that the supplied function 
                  is wrapped in a function that requires the argument to be of type <code>xs:string</code>,
                  so the call fails with a type error when the wrapping function is invoked supplying an
                  <code>xs:integer</code> as the argument.</p>
                  
                  <p role="xquery">This has the consequence that in XQuery 4.0, there is a backwards
                     incompatibility introduced because coercion rules
                  now apply to global variable declarations (<code>declare variable</code>) and
                  local variable bindings (for example <code>let</code> clauses). Previously
                  the following would execute without error:</p>
                  
                  <eg role="xquery"><![CDATA[let $f as function(xs:integer) as item()* := function($x) { $x + 1 }
return $f(12.3)]]></eg>
                  
                  <p role="xquery">With XQuery 4.0, as a consequence of function coercion,
                     this fails with a type error because the
                  argument supplied in the function call is not of type <code>xs:integer</code>.</p>
               </note>
               
            </div3>
            
            <div3 id="id-coercion-examples">
               <head>Examples of Coercions</head>
               <p>This section illustrates the effect of the coercion rules with examples.</p>
               <example id="eg-coercion-to-string">
                  <head>Coercion to <code>xs:string</code></head>
                  <p>Consider the case where the required type (of a variable, or a function argument)
                  is <code>xs:string</code>. For example, the second argument of <function>fn:matches</function>,
                  which expects a regular expression. The table below illustrates the values that might be supplied, and
                  the coercions that are applied.</p>
                  
                  <table role="medium">
                     <thead>
                        <tr>
                           <th align="left">Supplied Value</th>
                           <th align="left">Coercion</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td valign="top"><code>"[0-9]"</code></td>
                           <td valign="top"><p>None; the supplied value is an instance of the required type.</p></td>
                        </tr>
                        <tr>
                           <td valign="top"><code>default-language()</code></td>
                           <td valign="top"><p>None; the supplied value is an instance of <code>xs:language</code>, which
                              is a subtype of the required type <code>xs:string</code>.</p></td>
                        </tr>
                        <tr>
                           <td valign="top"><code><![CDATA[<a>[0-9]</a>]]></code></td>
                           <td valign="top"><p>The supplied element node is atomized. Unless it has been schema-validated,
                           the typed value will be an instance of <code>xs:untypedAtomic</code>, which
                           is accepted when the required type is <code>xs:string</code>.</p>
                              <p>Supplying an element whose type annotation is (say) <code>xs:date</code> 
                                 will fail with a type error.</p>
                              <p role="xpath">The effect is subtly different if XPath 1.0
                                 compatibility mode is enabled. In this case coercion takes the string
                              value of the element node. This differs from the typed value only
                              in the case where the element has been schema-validated and has a type
                              annotation other than <code>xs:string</code>.</p></td>
                        </tr>
                        <tr>
                           <td valign="top"><code><![CDATA[xs:anyURI("urn:dummy")]]></code></td>
                           <td valign="top"><p>Supplying an instance of <code>xs:anyURI</code> where the expected type
                              is <code>xs:string</code> is permitted; this is one of the pairs of types
                           where implicit casting is allowed.</p></td>
                        </tr>
                        <tr role="xpath">
                           <td valign="top"><code>17.2</code></td>
                           <td valign="top"><p>Supplying a number where a string is expected raises a type error.</p>
                              <p role="xpath">However, if XPath 1.0
                              compatibility mode is enabled, the number is converted to a string as if
                           by the <function>fn:string</function> function.</p></td>
                        </tr>
                        <tr role="xpath">
                           <td valign="top"><code>//author/@id</code></td>
                           <td valign="top"><p>Supplying a sequence of nodes where a single string is expected will raise a type
                              error unless either there is only one node in the sequence. In this case
                              the typed value of the node will be used (this must be of type
                              <code>xs:string</code>, <code>xs:untypedAtomic</code>, or <code>xs:anyURI</code>).</p>
                              <p role="xpath">If XPath 1.0 compatibility mode is enabled, however, 
                                 all strings after the first are discarded, and the string value of 
                                 the first node is used; if the sequence is empty, a zero-length string is supplied.</p></td>
                        </tr>
                        <tr role="xpath">
                           <td valign="top"><code>("red", "green", "blue")</code></td>
                           <td valign="top"><p>Supplying a sequence of strings where a single string is expected 
                              raises a type error.</p>
                              <p role="xpath">If XPath 1.0
                              compatibility mode is enabled, however, all strings after the first are discarded; the effect
                              is as if the supplied value were <code>"red"</code>.</p></td>
                        </tr>
                        <tr role="xpath">
                           <td valign="top"><code>()</code></td>
                           <td valign="top"><p>Supplying an empty sequence where a single string is expected will fail.</p>
                              <p role="xpath">If XPath 1.0 compatibility mode is enabled, however, the value is coerced by
                                 applying the function <code>fn:string(())</code>,
                                 which delivers the zero-length string.</p></td>
                        </tr>
                        <tr>
                           <td valign="top"><code><![CDATA[["a|b"]]]></code></td>
                           <td valign="top"><p>Supplying an array holding a single string succeeds, because the rules cause the
                              array to be atomized, and the value after atomization is a single string.</p>
                              <p>Supplying an array holding multiple strings would fail.</p>
                              <p role="xpath">In XPath 1.0 compatibility mode, supplying an array will fail, 
                                 regardless of the array contents, because the <function>fn:string</function> function does not 
                                 accept arrays.</p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </example>
               
               <example id="eg-coercion-to-decimal">
                  <head>Coercion to <code>xs:decimal?</code></head>
                  <p>Consider the case where the required type (of a variable, or a function argument)
                     is <code>xs:decimal?</code>. For example, the first argument of <function>fn:seconds</function>,
                     which expects a decimal number of seconds. The table below illustrates the values that might be supplied, and
                     the coercions that are applied.</p>
                  
                  <table role="medium">
                     <thead>
                        <tr>
                           <th align="left">Supplied Value</th>
                           <th align="left">Coercion</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td valign="top"><code>12.4</code></td>
                           <td valign="top"><p>None; the supplied value is an instance of the required type.</p></td>
                        </tr>
                        <tr>
                           <td valign="top"><code>()</code></td>
                           <td valign="top"><p>None; an empty sequence is an instance of the required type.</p></td>
                        </tr>
                        <tr>
                           <td valign="top"><code>42</code></td>
                           <td valign="top"><p>None; the supplied value is an instance of <code>xs:integer</code>,
                              which is a subtype of the required type.</p></td>
                        </tr>
                        <tr>
                           <td valign="top"><code>math:pi()</code></td>
                           <td valign="top"><p>The supplied value is an instance of <code>xs:double</code>,
                              which can be converted to <code>xs:decimal</code> under the coercion rules.</p></td>
                        </tr>
                        <tr>
                           <td valign="top"><code>("a", "b")[.="c"]</code></td>
                           <td valign="top"><p>The supplied value is an empty sequence, which is a valid
                              instance of the required type <code>xs:decimal?</code>. However,
                           the processor may (optionally) reject this as an implausible coercion,
                           on the grounds that it can only succeed in one special case, namely
                           where the filter expression selects no values. </p>
                              </td>
                        </tr>
                        <tr>
                           <td valign="top"><code>(1.5, 2.5, 3.5)</code></td>
                           <td valign="top"><p>A type error is raised<phrase role="xpath">, except in the case where XPath 1.0
                           compatibility is enabled, in which case all values after the first are discarded</phrase>.</p>
                           </td>
                        </tr>
                        <tr>
                           <td valign="top"><code><![CDATA[<a>3.14159</a>]]></code></td>
                           <td valign="top"><p>The element node is atomized; unless it has been schema-validated, the
                              result will be <code>"3.14159"</code> as an instance of <code>xs:untypedAtomic</code>.
                             This is converted to an instance of <code>xs:decimal</code> following the rules
                           of the <code>cast as</code> operator.</p></td>
                        </tr>
                        <tr role="xpath">
                           <td valign="top"><code>"12.2"</code></td>
                           <td valign="top"><p>Supplying a string where an <code>xs:decimal</code> is a type error<phrase role="xpath">,
                              even if XPath 1.0 compatibility mode is enabled. The rules for compatibility
                              mode would allow conversion if the required type were <code>xs:double</code>,
                              but not for <code>xs:decimal</code></phrase>.
                        </p></td>
                        </tr>
                        <tr>
                           <td valign="top"><code>[1.5]</code></td>
                           <td valign="top"><p>The array is atomized, and the result is a valid instance of the required
                           type <code>xs:decimal?</code></p>
                           </td>
                        </tr>
                        <tr>
                           <td valign="top"><code>[]</code></td>
                           <td valign="top"><p>The array is atomized, and the result is an empty sequence, which is a valid instance of the required
                              type <code>xs:decimal?</code></p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </example>
               
               <example id="eg-coercion-to-positive-integer">
                  <head>Coercion to <code>xs:positive-integer</code></head>
                  <p>Consider the case where the required type (of a variable, or a function argument)
                     is <code>xs:positive-integer</code>. The table below illustrates the values that might be supplied, and
                     the coercions that are applied.</p>
                  
                  <table role="medium">
                     <thead>
                        <tr>
                           <th align="left">Supplied Value</th>
                           <th align="left">Coercion</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td valign="top"><code>12</code></td>
                           <td valign="top"><p>The supplied value is of type <code>xs:integer</code>. Because the supplied value and
                              the required type, <code>xs:positiveInteger</code>, both come under the primitive
                           type <code>xs:decimal</code>, and the value <code>12</code> is within the value space
                           of <code>xs:positiveInteger</code>, the value is relabeled as an <code>xs:positiveInteger</code>
                           and the call succeeds.</p></td>
                        </tr>
                        <tr>
                           <td valign="top"><code>12.1</code></td>
                           <td valign="top"><p>This fails with a type error, because the <code>xs:decimal</code> value <code>12.1</code>
                              is not a value in the value space of <code>xs:positiveInteger</code>. This is so even though
                           casting to <code>xs:positiveInteger</code> would succeed.</p></td>
                        </tr>
                        <tr>
                           <td valign="top"><code>math:pi()</code></td>
                           <td valign="top"><p>This fails with a type error. A value of type <code>xs:double</code> is accepted
                           where the required type is <code>xs:decimal</code> or <code>xs:float</code>,
                           but not where it is <code>xs:positiveInteger</code>.</p></td>
                        </tr>
                        <tr>
                           <td valign="top"><code><![CDATA[<a>1200</a>]]></code></td>
                           <td valign="top"><p>The supplied element node is atomized. If the element has not been schema-validated,
                           the result will be an <code>xs:untypedAtomic</code> item, which is successfully cast to the
                           required type <code>xs:positiveInteger</code>. If the element has been validated against a schema,
                           then coercion succeeds if the typed value would itself be acceptable, for example if it
                           is an <code>xs:positiveInteger</code>, or some other <code>xs:decimal</code> within the value space
                           of <code>xs:positiveInteger</code>.</p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </example>
               <example id="eg-coercion-to-union">
                  <head>Coercion to a union type</head>
                  <p>Consider the first parameter of the function <function>fn:char</function>, whose declared
                  type is <code>(xs:string | xs:positiveInteger)</code>. The rules are the same
                  as if it were a union typed declared in an imported schema.</p>
                  
                  <table role="medium">
                     <thead>
                        <tr>
                           <th align="left">Supplied Value</th>
                           <th align="left">Coercion</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td valign="top"><code>"amp"</code></td>
                           <td valign="top"><p>The supplied value is of type <code>xs:string</code>, which is one of the allowed
                           types. The call therefore succeeds.</p></td>
                        </tr>
                        <tr>
                           <td valign="top"><code>"#"</code></td>
                           <td valign="top"><p>The supplied value is of type <code>xs:string</code>, which is one of the allowed
                              types. As far as the coercion rules are concerned, the call therefore succeeds. Under the
                              semantic rules for the <function>fn:char</function> function, however, this value is not accepted;
                              a dynamic error (as distinct from a type error) is therefore raised.</p></td>
                        </tr>
                        <tr>
                           <td valign="top"><code>0x25</code></td>
                           <td valign="top"><p>The supplied value is of type <code>xs:integer</code>. Although this is not one of the allowed
                              types, it is acceptable because coercion of the value to type <code>xs:positiveInteger</code>
                              succeeds. The value is relabeled as an instance of <code>xs:positiveInteger</code>.</p></td>                          
                        </tr>
                        <tr>
                           <td valign="top"><code><![CDATA[<a>0x25</a>]]></code></td>
                           <td valign="top"><p>The supplied element node is atomized. Assuming that the node has not been schema-validated,
                              the result is an instance of <code>xs:untypedAtomic</code>. The member types of the choice
                              are tested in order. Conversion to <code>xs:string</code> with the value "0x25" succeeds, so 
                              the <function>fn:char</function> function is called supplying this string; but the function rejects this
                              string as semantically invalid. The same would happen if the value were, say, <![CDATA[<a>37</a>]]>.
                              Supplying such a value requires an explicit cast, for example <code>fn:char( xs:positiveInteger( ./a ))</code>.</p>
                           </td>
                        </tr>
                        
                        
                     </tbody>
                  </table>
               </example>
               <example id="eg-coercion-to-choice">
                  <head>Coercion to a choice type</head>
                  <p>Suppose the required type is <code>(record(x as xs:decimal, y as xs:decimal, *) | record(size as enum("S", "M", "L", "XL"), *))</code>.</p>
                  
                  <table role="medium">
                     <thead>
                        <tr>
                           <th align="left">Supplied Value</th>
                           <th align="left">Coercion</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td valign="top"><code>{ "x": 1, "y": 2, "z": 3 }</code></td>
                           <td valign="top"><p>The supplied value is an instance of the first record type: no coercion is necessary.</p></td>
                        </tr>
                        <tr>
                           <td valign="top"><code>{ "size": "M" }</code></td>
                           <td valign="top"><p>The supplied value is an instance of the second record type: no coercion is necessary.</p></td>                          
                        </tr>
                        <tr>
                           <td valign="top"><code>{ "x": 1, "y": 2, "size": "XL" }</code></td>
                           <td valign="top"><p>The supplied value is an instance of both record types: no coercion is necessary.</p>
                           </td>
                        </tr>
                        <tr>
                           <td valign="top"><code>{ "x": 1e0, "y": 2e0, "size": "XL" }</code></td>
                           <td valign="top"><p>The supplied value is not an instance of the first record type because the fields are of
                              type <code>xs:double</code> rather than <code>xs:decimal</code>. It is however an instance
                              of the second record type. It is therefore accepted <emph>as is</emph>; the fields
                           <code>x</code> and <code>y</code> are not converted from <code>xs:double</code> to
                           <code>xs:decimal</code>.</p>
                           </td>
                        </tr>
                        <tr>
                           <td valign="top"><code>{ "x": 1e0, "y": 2e0, "size": "XXL" }</code></td>
                           <td valign="top"><p>The supplied value is not an instance of the first record type because the fields are of
                              type <code>xs:double</code> rather than <code>xs:decimal</code>, and it is not an instance
                              of the second record type because the <code>size</code> value does not match the enumeration
                              type. Coercion is therefore attempted to the first record type, and succeeds. The <code>x</code>
                           and <code>y</code> fields are coerced to <code>xs:decimal</code>, and the <code>size</code> field
                           is accepted <emph>as is</emph>.</p>
                           </td>
                        </tr>
                        
                        
                     </tbody>
                  </table>
               </example>
            </div3>
            </div2>
         
         
      <div2 id="id-predefined-types">
         <head>Schema Types</head>
         
         <p><termdef id="dt-schema-type" term="schema type">A <term>schema type</term>
            is a complex type or simple type as defined in the <bibref
               ref="XMLSchema10"/> or <bibref ref="XMLSchema11"
               /> specifications, including built-in types as well as user-defined types.</termdef></p>
         
         <p>Every schema type is either a <term>complex type</term> or a
            <term>simple type</term>; simple types are further subdivided into <term>list types</term>, <term>union
               types</term>, and <term>atomic types</term> (see <bibref
                  ref="XMLSchema10"/> or <bibref ref="XMLSchema11"
                  /> for definitions and explanations of these terms.)</p>
         
         <p>A schema type can appear as a type annotation on an
            element or attribute node. The type annotation on an element node can be
            a complex type or a simple type; the type annotation on an attribute node
            is always a simple type. Non-instantiable types such as <code>xs:NOTATION</code> or
            <code>xs:anyAtomicType</code> never appear as type annotations, but their derived
            types can be so used. Union types never appear as type annotations; when
            an element or attribute is validated against a union type, the resulting
            type annotation will be one of the types in the transitive membership of 
            the union type.</p>
         
         <p><termdef id="dt-atomic-type" term="atomic type">An <term>atomic type</term>
            is a simple <termref def="dt-schema-type"/> whose 
            <xtermref spec="XS11-1" ref="std-variety">{variety}</xtermref>
            is <code>atomic</code>.</termdef></p>
         
         <p>An <term>atomic type</term> is either a built-in atomic
            type (defined either in the XSD specification or in this specification), or
            it is a user-defined atomic type included in an imported schema.</p>
         
         <p role="xpath">The <termref def="dt-is-types"
            >in-scope schema types</termref>
            in the <termref
               def="dt-static-context"
               >static
               context</termref> are initialized with a set of
            predefined schema types that is determined by the host
            language. This set may include some or all of the
            schema types in the
            namespace
            <code>http://www.w3.org/2001/XMLSchema</code>,
            represented in this document by the namespace prefix
            <code>xs</code>. The schema types in this namespace are defined in <bibref
               ref="XMLSchema10"/> or <bibref ref="XMLSchema11"
               />
            and augmented by additional types defined in <bibref
               ref="xpath-datamodel-40"
            />. An implementation
            that has based its type system on <bibref
               ref="XMLSchema10"
            /> is not required to support the <code>xs:dateTimeStamp</code> or <code>xs:error</code> types.</p>
         
         <p>The schema types defined in  <xspecref spec="DM40" ref="types-predefined"
         /> are summarized below.</p>
         
         
         <p role="xquery">The <termref def="dt-is-types"
            >in-scope schema types</termref> in the <termref def="dt-static-context"
               >static context</termref>
            are initialized with certain predefined schema types,
            including the built-in schema types in the namespace
            <code>http://www.w3.org/2001/XMLSchema</code>,
            which has the predefined namespace prefix
            <code>xs</code>.  The schema types in this namespace are defined in <bibref
               ref="XMLSchema10"/> or  <bibref ref="XMLSchema11"
               />
            and augmented by additional types defined in <bibref
               ref="xpath-datamodel-40"
            />.  Element and attribute
            declarations in the <code>xs</code> namespace are
            not implicitly included in the static context. The schema types defined in  <bibref
               ref="xpath-datamodel-40"/> are summarized below.</p>
         
         <olist>
            
            <item>
               <p>
                  <termdef term="xs:untyped" id="dt-untyped">
                     <code>xs:untyped</code> is  used as the <termref def="dt-type-annotation"
                        >type annotation</termref> of an element node that has not been validated, or has been validated in <code>skip</code> mode.</termdef> 
                  No predefined schema types are derived from <code>xs:untyped</code>.</p>
            </item>
            
            <item>
               <p>
                  <termdef id="dt-untypedAtomic" term="xs:untypedAtomic">
                     <code>xs:untypedAtomic</code>
                     is an <termref def="dt-atomic-type"/> that is used to denote untyped atomic data, 
                     such as text that has not been assigned a more specific type.</termdef> 
                  An attribute that has been validated in <code>skip</code> mode is represented in the <termref
                     def="dt-datamodel">data model</termref> by an attribute node with the <termref
                        def="dt-type-annotation">type annotation</termref>
                  <code>xs:untypedAtomic</code>. No predefined schema types are derived from <code>xs:untypedAtomic</code>.</p>
            </item>
            
            <item>
               <p>
                  <termdef term="xs:dayTimeDuration" id="dt-dayTimeDuration">
                     <code>xs:dayTimeDuration</code> is derived by restriction from <code>xs:duration</code>. The  lexical representation of <code>xs:dayTimeDuration</code>
                     is restricted to contain only day, hour, minute, and second
                     components.</termdef>
               </p>
            </item>
            
            <item>
               <p>
                  <termdef term="xs:yearMonthDuration" id="dt-yearMonthDuration">
                     <code>xs:yearMonthDuration</code> is derived by restriction from <code>xs:duration</code>. The lexical representation of <code>xs:yearMonthDuration</code> is
                     restricted to contain only year and month
                     components.</termdef>
               </p>
            </item>
            
            <item>
               <p>
                  <termdef term="xs:anyAtomicType" id="dt-anyAtomicType">
                     <code>xs:anyAtomicType</code> is an <termref def="dt-atomic-type"/> 
                     that includes all atomic items (and no values that
                     are not atomic). Its base type is
                     <code>xs:anySimpleType</code> from which all simple types, including atomic,
                     list, and union types, are derived. All primitive atomic types, such as
                     <code>xs:decimal</code> and <code>xs:string</code>, have <code>xs:anyAtomicType</code> as their base type.</termdef>
               </p>
               <note>
                  <p>
                     <code>xs:anyAtomicType</code>  will not appear as the type of an actual value in an <termref
                        def="dt-data-model-instance">XDM instance</termref>.</p>
               </note>
            </item>
            
            <item>
               <p>
                  <termdef term="xs:error" id="dt-xs-error">
                     <code>xs:error</code> is a simple type with no value space.  It is defined in <xspecref
                        spec="XS11-1" ref="xsd-error"/> and  can be used in the <specref
                           ref="id-sequencetype-syntax"/> to raise errors.</termdef>
               </p>
            </item>
         </olist>
         
         <p>The relationships among the schema types in the <code>xs</code> namespace are illustrated in Figure 2. A more complete description of the &language; type hierarchy can be found in 
            <xspecref
               spec="FO40" ref="datatypes"/>.</p>
         <graphic source="types.jpg" alt="Type Hierarchy Diagram"/>
         <p>Figure 2: Hierarchy of Schema Types used in &language;.</p>
         
         
      </div2>
      
      
         
      </div1>



   <div1 id="id-expressions">
      <head>Expressions</head>
      <p>This section discusses each of the basic kinds of expression. Each kind of expression has a name such as <code>PathExpr</code>, which is introduced on the left side of the grammar production that defines the expression. Since &language; is a composable language, each kind of expression is defined in terms of other expressions whose operators have a higher precedence. In this way, the precedence of operators is represented explicitly in the grammar.</p>
      <p>The order in which expressions are discussed in this document does not reflect the order of operator precedence. In general, this document introduces the simplest kinds of expressions first, followed by more complex expressions.  For the complete grammar, see Appendix [<specref
            ref="nt-bnf"/>].</p>
      <p>
         <phrase role="xpath">The highest-level symbol in the XPath grammar is XPath.</phrase>
         <phrase role="xquery">
            <termdef id="dt-query" term="query"
                  >A <term>query</term> consists of one or more <termref def="dt-module"
                  >modules</termref>.</termdef>  If a query is executable, one of its modules has a <termref
               def="dt-queryBody"
               >Query Body</termref>  containing an expression whose value is the result of the query. An expression is represented in the XQuery grammar by the symbol <nt
               def="Expr">Expr</nt>.</phrase>
      </p>
      <scrap role="xpath">
         <prodrecap ref="XPath"/>
      </scrap>
      <scrap role="xquery">
         <prodrecap ref="Expr"/>
      </scrap>
      <scrap>
         <prodrecap ref="ExprSingle"/>
      </scrap>
      <p>The &language; operator that has lowest precedence is the <termref def="dt-comma-operator"
            >comma operator</termref>, which is used to combine two operands to form a sequence. 
         As shown in the grammar, a general expression (<nt
            def="Expr">Expr</nt>) can consist of multiple <nt def="ExprSingle"
            >ExprSingle</nt> operands, separated by commas.</p>
      
      
      
         <p>The name <nt def="ExprSingle"
            >ExprSingle</nt> denotes an expression that does not contain a top-level <termref
            def="dt-comma-operator">comma operator</termref> (despite its name, an <nt
            def="ExprSingle"
         >ExprSingle</nt> may evaluate to a sequence containing more than one item.)</p>
      <p>The symbol <nt def="ExprSingle"
            >ExprSingle</nt> is used in various places in the grammar where an expression 
         is not allowed to contain a top-level comma. For example, each of the arguments 
         of a function call must be a <nt def="ExprSingle">ExprSingle</nt>, because commas are 
         used to separate the arguments of a function call.</p>
      <p>After the comma, the expressions that have next lowest precedence are
<phrase role="xquery">
            <nt def="FLWORExpr">FLWORExpr</nt>,</phrase>
         <phrase role="xpath">
            <nt def="ForExpr">ForExpr</nt>, <nt def="LetExpr">LetExpr</nt>, </phrase>
         <nt def="QuantifiedExpr">QuantifiedExpr</nt>,
<phrase role="xquery">
            <nt def="SwitchExpr">SwitchExpr</nt>, <nt def="TypeswitchExpr"
            >TypeswitchExpr</nt>, </phrase>
         <nt def="IfExpr">IfExpr</nt>,
<phrase role="xquery">
            <nt def="TryCatchExpr">TryCatchExpr</nt>, </phrase>
and <nt def="OrExpr"
         >OrExpr</nt>. Each of these expressions is described in a separate section of this document.</p>
      
     
      
      <div2 id="comments">
         <head>Comments</head>
         <scrap>
            <prodrecap ref="Comment"/>
         </scrap>
         <p>Comments may be used to provide information relevant to programmers who read <phrase
            role="xquery">a query, either in the <termref def="dt-prolog"
               >Prolog</termref> or in the <termref def="dt-queryBody">Query Body</termref>
         </phrase>
            <phrase role="xpath"
               >an expression</phrase>. Comments are lexical constructs only, and do not affect  <phrase
                  role="xquery">query</phrase>
            <phrase role="xpath">expression</phrase> processing.</p>
         <p>Comments are strings, delimited by the symbols <code>(:</code> and <code>:)</code>. Comments may be nested.</p>
         
         
         <p>A comment may be used anywhere <termref def="IgnorableWhitespace"
            >ignorable whitespace</termref> is allowed (see <specref
               ref="DefaultWhitespaceHandling"/>).</p>
         <p>The following is an example of a comment:</p>
         <eg><![CDATA[(: Houston, we have a problem :)]]></eg>
      </div2>
      
      <div2 id="id-primary-expressions">
         <head>Primary Expressions</head>
         <p>
            <termdef id="dt-primary-expression" term="primary expression">
               <term>Primary expressions</term> are the basic primitives of the
	 language. They include literals, variable references, context value references, <phrase
                  role="xquery"
               >constructors, </phrase> and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.</termdef>
            <phrase role="xquery">Node Constructors are described in <specref ref="id-constructors"
               />.</phrase>Map and Array Constructors are described in <specref
               ref="id-maps"/> and <specref ref="id-arrays"/>.
<phrase role="xquery">String Constructors are described in <specref
               ref="id-string-constructors"/>.</phrase>
</p>
         <scrap>
            <prodrecap ref="PrimaryExpr"/>
         </scrap>
 
         <!--<p>The usage of the <nt def="TildeExpr"/> is described in <specref ref="id-arrow-operator"/>.</p>
-->
         <div3 id="id-literals">
            <head>Literals</head>
            
            <scrap>
               <prodrecap ref="Literal"/>
            </scrap>
            <p>
               <termdef id="dt-literal" term="literal"
                  >A <term>literal</term> is a direct syntactic representation of an
		atomic item.</termdef> &language; supports two kinds of literals: numeric literals and
		string literals.</p>
            
            
            <div4 id="id-numeric-literals">
               <head>Numeric Literals</head>
               
               <changes>
                  <change issue="429" PR="433" date="2023-04-25">
                     Numeric literals can now be written in hexadecimal or binary notation; 
                     and underscores can be included for readability.
                  </change>
               </changes>
               
               <scrap>
                  <prodrecap ref="NumericLiteral"/>
               </scrap>
            
            
         
               <p diff="add" at="2023-04-07">The value of a numeric literal is determined as follows (taking the rules in order):</p>
               
               <olist diff="chg" at="2023-04-07">
                  <item><p>Underscore characters are stripped out. Underscores may be included in a numeric
                  literal to aid readability, but have no effect on the value. For example, <code>1_000_000</code>
                  is equivalent to <code>1000000</code>.</p>
                     <note><p diff="add" at="2023-04-25">Underscores must not appear at the beginning or end of a sequence of digits, only
                  in intermediate positions. Multiple adjacent underscores are allowed.</p></note>
                  </item>
                  <item><p>A <code>HexIntegerLiteral</code> represents a non-negative integer
                      expressed in hexadecimal: for example <code>0xffff</code> represents the integer 65535, and
                     <code>0xFFFF_FFFF</code> represents the integer 4294967295.</p>
                  </item>
                  <item><p>A <code>BinaryIntegerLiteral</code> represents a non-negative integer
                     expressed in binary: for example <code>0b101</code> represents the integer 5, and
                     <code>0b1111_1111</code> represents the integer 255.</p>
                  </item>
                  <item><p>The value of a <term>numeric literal</term> containing no <code>.</code> and 
                     no <code>e</code> or <code>E</code> character is an atomic item of type <code>xs:integer</code>;
                     the value is obtained by casting from <code>xs:string</code> to <code>xs:integer</code> as specified in
                     <xspecref spec="FO40" ref="casting-from-strings"/>.</p>
                  </item>
                  <item><p>The value of a numeric literal containing <code>.</code> but no <code>e</code> or <code>E</code> 
                     character is an atomic item of type <code>xs:decimal</code>;
                     the value is obtained by casting from <code>xs:string</code> to <code>xs:decimal</code> as specified in
                     <xspecref spec="FO40" ref="casting-from-strings"/>.</p>
                  </item>
                  <item><p>The value of a numeric literal 
                     containing an <code>e</code> or <code>E</code> character is an atomic item of type 
                     <code>xs:double</code>;
                     the value is obtained by casting from <code>xs:string</code> to <code>xs:double</code> as specified in
                     <xspecref spec="FO40" ref="casting-from-strings"/>.</p>
                  </item>
               </olist>
               
               <note diff="add" at="2023-04-07"><p>The value of a numeric literal is always non-negative. An expression may
                  appear to include a negative number such as <code>-1</code>, but this is technically
                  an arithmetic expression comprising a unary minus operator followed by a numeric literal.</p></note>
    
               <note>
                  <p>The effect of the above rules is that in the case of an integer or decimal literal, a dynamic error <xerrorref
                        spec="FO40" class="AR" code="0002"
                        /> will generally be raised if the literal is outside the range of values supported by the implementation (other options are available: see <xspecref
                        spec="FO40" ref="op.numeric"/> for details.)</p>
                  <p role="xquery">The limits of numeric datatypes are specified in <specref
                        ref="id-data-model-conformance"/>.</p>
                  <p role="xpath"
                        >The XML Schema specification allows implementations to impose a limit (which
   must not be less than 18 digits) on the size of integer and decimal
   values. The full range of values of built-in subtypes of <code>xs:integer</code>,
   such as <code>xs:long</code> and <code>xs:unsignedLong</code>, can be supported only if the
   limit is 20 digits or higher. Negative numbers such as the minimum
   value of <code>xs:long</code> (<code>-9223372036854775808</code>) are technically unary
   expressions rather than literals, but implementations may prefer to
   ensure that they are expressible.</p>
               </note>
               
               <p>Here are some examples of numeric literals:</p>
               
               <ulist>
                  
                  <item>
                     <p>
                        <code role="parse-test"
                           >12</code> denotes the <code>xs:integer</code> value twelve.</p>
                  </item>
                  
                  <item>
                     <p>
                        <code role="parse-test"
                           >1_000_000</code> denotes the <code>xs:integer</code> value one million.</p>
                  </item>
                  
                  
                  <item>
                     <p>
                        <code role="parse-test"
                           >12.5</code> denotes the <code>xs:decimal</code> value twelve and one half.</p>
                  </item>
                  
                  <item><p><code role="parse-test">3.14159_26535_89793e0</code>
                  is an <code>xs:double</code> value representing the mathematical constant
                  <var>π</var> to 15 decimal places. </p></item>
                  
                  
                  <item>
                     <p>
                        <code role="parse-test"
                           >125E2</code> denotes the <code>xs:double</code> value twelve thousand, five hundred.</p>
                  </item>
                  
                  <item>
                     <p>
                        <code role="parse-test"
                           >0xffff</code> denotes the <code>xs:integer</code> value 65535.</p>
                  </item>
                  
                  <item>
                     <p>
                        <code role="parse-test"
                           >0b1000_0001</code> denotes the <code>xs:integer</code> value 129.</p>
                  </item>
               </ulist>
                  
            </div4>
            
            <div4 id="id-string-literal">
               <head>String Literals</head>
               
               <scrap>
                  <prodrecap id="StringLiteral" ref="StringLiteral"/>
               </scrap>
 


            <p>The value of a <term>string literal</term> is an atomic item whose type is
               <code>xs:string</code> and whose value is the string denoted by the characters between the
		delimiting apostrophes or quotation marks. If the literal is delimited by apostrophes, two adjacent 
		apostrophes within the literal are interpreted as a single apostrophe. Similarly, if the literal 
		is delimited by quotation marks, two adjacent quotation marks within the literal are interpreted 
		as one quotation mark.</p>

            
             
               <p role="xquery"><termdef
                  term="predefined entity reference" id="dt-predefined-entity-reference"
                     >A <term>predefined entity reference</term> is a short sequence of characters, 
                  beginning with an ampersand, that represents a single character that might otherwise 
                  have syntactic significance.</termdef> Each predefined entity reference is replaced 
                  by the character it represents when the string literal is processed. The predefined 
                  entity references recognized by XPath and XQuery are as follows:</p>
            <p role="xquery">
               <table width="60%" border="1" role="medium">
                  <tbody>
                     <tr>
                        <th align="center">Entity Reference</th>
                        <th align="center">Character Represented</th>
                     </tr>
                     <tr>
                        <td align="center">
                           <code>&amp;lt;</code>
                        </td>
                        <td align="center">
                           <code>&lt;</code>
                        </td>
                     </tr>
                     <tr>
                        <td align="center">
                           <code>&amp;gt;</code>
                        </td>
                        <td align="center">
                           <code>&gt;</code>
                        </td>
                     </tr>
                     <tr>
                        <td align="center">
                           <code>&amp;amp;</code>
                        </td>
                        <td align="center">
                           <code>&amp;</code>
                        </td>
                     </tr>
                     <tr>
                        <td align="center">
                           <code>&amp;quot;</code>
                        </td>
                        <td align="center">
                           <code>&quot;</code>
                        </td>
                     </tr>
                     <tr>
                        <td align="center">
                           <code>&amp;apos;</code>
                        </td>
                        <td align="center">
                           <code>'</code>
                        </td>
                     </tr>
                  </tbody>
               </table>
            </p>
               <p role="xquery"><termdef
                  term="character reference" id="dt-character-reference"
                     >A <term>character reference</term> is an XML-style reference to a <bibref
                     ref="Unicode"
                  /> character, identified by its decimal or hexadecimal codepoint.</termdef> For example, 
                  the character <char>U+20AC</char> 
               can be represented by the character reference <code>&amp;#8364;</code> or <code>&amp;#x20ac;</code>. Character references are 
               normatively defined in Section 4.1 of the XML specification (it is <termref
                  def="dt-implementation-defined"
                  >implementation-defined</termref> whether the rules in <bibref ref="XML"
                  /> or <bibref ref="XML1.1"/> apply.) A <termref def="dt-static-error"
                  >static error</termref>
               <errorref class="ST" code="0090"
               /> is raised if a character reference does not identify a valid character in the version of XML that is in use.</p>
               
           

            <p>Here are some examples of string literals:</p>
               <ulist>
               <item>
                  <p>
                     <code role="parse-test"
                     >"He said, ""I don't like it."""</code> denotes a string containing two quotation marks and one apostrophe.</p>
                  
               </item>

               <item role="xquery">
                  <p>
                     <code role="parse-test"
                        >"Ben &amp;amp; Jerry&amp;apos;s"</code> denotes the <code>xs:string</code> value  <code>"Ben &amp; Jerry's"</code>.</p>
               </item>

               <item role="xquery">
                  <p>
                     <code role="parse-test"
                        >"&amp;#8364;99.50"</code> denotes the <code>xs:string</code>  value <code>"€99.50"</code>.</p>
               </item>
               <item>
                  <p>In XQuery, the string literal <code>"&amp;lt;"</code> denotes a string of length 1 containing the single character
                     <code>"&lt;"</code>. In XPath, the string literal <code>"&amp;lt;"</code> denotes a string of length 4 containing the four 
                     characters <code>"&amp;"</code>, <code>"l"</code>, <code>"t"</code>, <code>";"</code>. (However, when the XPath
                     expression is embedded in an XML document, the sequence <code>"&amp;lt;"</code> will typically have already been converted
                     to <code>"&lt;"</code> by the XML parser.)</p>
               </item>
            </ulist>
               <note>
                  <p>When XPath or XQuery expressions are embedded in contexts where quotation
                     marks have special significance, such as inside XML attributes, or in string literals in a host language such
                     as Java or C#, then additional
                     escaping may be needed.</p>
                  
               </note>
               <note><p>Fixed string values can also be written as string templates: 
                  see <specref ref="id-string-templates"/>. A string template with no enclosed
               expressions, such as <code>`Jamaica`</code> evaluates to the same value as
               the string literals <code>"Jamaica"</code> or <code>'Jamaica'</code>. 
               A string template can contain both single and double quotation marks:
               <code>`He said: "I don't like it"`</code>. However, there there are
               some subtle differences:</p>
               <ulist>
                  <item><p>In string literals, the treatment of character and entity references
                  such as <code>&amp;amp;</code> varies between XQuery and XPath; in string templates,
                  such references are not expanded in either language.</p></item>
                  <item><p>String templates can only be used where an expression is expected. String
                  literals are also used in some non-expression contexts, for example in
                  defining an enumeration type: see <specref ref="id-enumeration-types"/>.</p></item>
                  <item><p>Curly brackets (<char>U+007B</char> and <char>U+007D</char>) and backticks 
                  (<char>U+0060</char>) have a reserved meaning in string templates.</p></item>
               </ulist></note>
            </div4>
            <div4 id="id-constants-other-types">
               <head>Constants of Other Types</head>
 
            <p>
               
      The <code>xs:boolean</code> values <code>true</code> and <code>false</code> can be constructed by calls to the
      <termref
            def="dt-system-function">system functions</termref>
               <code>fn:true()</code> and <code>fn:false()</code>, respectively.
    </p>

            <p>Values of other simple types can be constructed by calling the <termref
                  def="dt-constructor-function"
                  >constructor function</termref> for the given type. The constructor functions for XML Schema
		built-in types are defined in <xspecref
                  spec="FO40" ref="constructor-functions-for-xsd-types"
               />. In general, the name of a constructor function for a given type is the same as the name of the type (including its namespace). For
		example:</p>


            <ulist>



               <item>
                  <p>
                     <code role="parse-test"
                     >xs:integer("12")</code> returns the integer value twelve.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >xs:date("2001-08-25")</code> returns an item whose type is <code>xs:date</code> and whose value represents the date 25th August 2001.</p>
               </item>

               <item>
                  <p>
                     <code role="parse-test"
                        >xs:dayTimeDuration("PT5H")</code> returns an item whose type is <code>xs:dayTimeDuration</code> and whose value represents a duration of five hours.</p>
               </item>
            </ulist>
            <p>Constructor functions can also be used to create special values that have no literal representation, as in the following examples:
<ulist> <item>
                     <p>
                        <code role="parse-test"
                        >xs:float("NaN")</code> returns the special floating-point value, "Not a Number."</p>
                  </item> <item>
                     <p>
                        <code role="parse-test"
                        >xs:double("INF")</code> returns the special double-precision value, "positive infinity."</p>
                  </item>
               </ulist>
            </p>

            <p>Constructor functions are available for all simple types,
including union types. For example, if <code>my:dt</code> is a user-defined union
type whose member types are <code>xs:date</code>, <code>xs:time</code>, and <code>xs:dateTime</code>, then
the expression <code>my:dt("2011-01-10")</code> creates an atomic item of type
<code>xs:date</code>. The rules follow XML Schema validation rules for union types:
the effect is to choose the first member type that accepts the given
string in its lexical space.</p>

            <p>It is also possible to construct values of various types by using a <code>cast</code> expression. For example:</p>

            <ulist>


               <item>
                  <p>
                     <code role="parse-test"
                        >9 cast as
                        hatsize</code> returns the atomic item <code>9</code>
			 whose type is  <code>hatsize</code>.</p>
               </item>
            </ulist>
            </div4>
         </div3>
         <div3 id="id-variables">
            <head>Variable References</head>
            <scrap>
               <prodrecap ref="VarRef"/>
            </scrap>
            <p>
               <termdef id="dt-variable-reference" term="variable reference"
                     >A <term>variable reference</term> is an EQName preceded by a $-sign.</termdef> 
An unprefixed variable reference is in no namespace. Two variable references are equivalent if their  <termref
                  def="dt-expanded-qname"
                  >expanded QNames</termref>  are equal (as defined by the <code>eq</code> operator). The scope of a variable binding is defined separately for each kind of
expression that can bind variables.</p>

            <p>Every variable reference must match a name in the <termref
                  def="dt-in-scope-variables">in-scope variables</termref>. </p>

            <p>Every variable binding has a static scope. The scope defines where
references to the variable can validly occur.

It is a <termref
                  def="dt-static-error">static error</termref>
               <errorref class="ST" code="0008"
                  /> to reference a variable that is not in scope. If a variable is bound in the <termref
                  def="dt-static-context"
               >static context</termref> for an expression, that variable is in scope for the entire expression except where it is occluded by another binding that uses the same name within that scope.</p>
            <p role="xquery"
                  >A reference to a variable that was declared <code>external</code>, but was not bound to a value by the external environment, raises a <termref
                  def="dt-dynamic-error">dynamic error</termref>
               <errorref code="0002" class="DY"/>.</p>
            <p>
At evaluation time, the value of a variable reference is the value to which the relevant variable is bound.</p>
            
            <!--<p diff="add" at="A">A <code>VarRef</code> consisting of a $-sign followed by an integer literal is refered to as a
            <term>numeric parameter reference</term>, and is allowed only within an inline function declared using hash notation:
            see <specref ref="id-hash-inline-functions"/></p>-->
         </div3>

         <div3 id="id-context-value-references">
            <head>Context Value References</head>
            <scrap>
               <prodrecap ref="ContextValueRef"/>
            </scrap>

            <p>A <term>context value reference</term> evaluates to
              the <termref def="dt-context-value"/>.</p>
            
            <p>In many syntactic contexts, the context value will be a single item.
               For example this applies on the right-hand side of the <code>/</code> 
               or <code>!</code> operators, or within a <nt def="Predicate">Predicate</nt>.</p>
            
            <p>If the <termref def="dt-context-value"/> is <xtermref spec="DM40"
                  ref="dt-absent"/>, a context value reference raises a <termref
                  def="dt-type-error"/> <errorref class="DY" code="0002"/>.</p>
            
            <note><p>Being absent is not the same thing as being empty.</p></note>
         </div3>
 
         <div3 id="id-paren-expressions">
            <head>Parenthesized Expressions</head>
            <scrap>
               <prodrecap ref="ParenthesizedExpr"/>


            </scrap>
            <p>Parentheses may be used to override the precedence rules.
        For example, the expression <code
                  role="parse-test"
                  >(2 + 4)
		    * 5</code> evaluates to thirty, since the parenthesized expression <code
                  role="parse-test"
                  >(2 + 4)</code> is evaluated first and its result is multiplied by five. Without
			 parentheses, the expression <code
                  role="parse-test"
               >2 + 4 * 5</code> evaluates to twenty-two, because the multiplication operator has higher
			 precedence than the addition operator.</p>

            <p>Empty parentheses are used to denote an empty sequence, as
		described in <specref
                  ref="construct_seq"/>.</p>
         </div3>

         <div3 id="id-enclosed-expr">
            <head>Enclosed Expressions</head>
            <p>
               <scrap>
                  <prodrecap ref="EnclosedExpr"/>
               </scrap>
               <termdef term="enclosed expression" id="dt-enclosed-expression"
                  >An <term>enclosed expression</term> is an instance of the <nt def="EnclosedExpr"
                     >EnclosedExpr</nt> production, which allows an optional expression within curly brackets.</termdef>
               <termdef id="dt-content-expression" term="content expression">In an  <termref
                  def="dt-enclosed-expression"
                  >enclosed expression</termref>, the optional expression enclosed in curly brackets is called the <term>content expression</term>.</termdef> If the <termref
                     def="dt-content-expression"
                     >content expression</termref> is not provided explicitly,  the content expression is <code>()</code>.</p>
            
            <note diff="add" at="A">
               <p>Despite the name, an enclosed expression is not actually an expression
                  in its own right; rather it is a construct that is used in the grammar of many other expressions.</p>
            </note>
            
         </div3>


      </div2>
      
      <div2 id="id-postfix-expression">
         <head>Postfix Expressions</head>
         
         <scrap>
            <head/>
            <prodrecap ref="PostfixExpr"/>
         </scrap>
         
         <p>A postfix expression takes one of the following forms:</p>
         
         <ulist>
            <item><p><termdef term="filter expression" id="dt-filter-expression">
               A <term>filter expression</term> is an expression in the form <code>E1[E2]</code>: 
               its effect is
               to return those items from the value of <code>E1</code> that
               satisfy the predicate in E2.</termdef></p>
            <p>Filter expressions are described in <specref ref="id-filter-expression"/>.</p>
            <p>An example of a filter expression is <code>(1 to 100)[. mod 2 = 0]</code>
            which returns all even numbers in the range 1 to 100.</p>
            <p>The base expression <code>E1</code> can itself be a postfix expression,
            so multiple predicates are allowed, in the form <code>E1[E2][E3][E4]</code>.</p></item>
            <item><p>An expression (other than a raw EQName) followed by an argument
               list in parentheses (that is, <code>E1(E2, E3, ...)</code>) is
               referred to as a <termref
                  def="dt-dynamic-function-invocation"
                  >dynamic function call</termref>. Its
               effect is to evaluate <code>E1</code> to obtain a function,
               and then call that function, with
               <code>E2</code>, <code>E3</code>, <code>...</code> as
               arguments. Dynamic function calls are described in <specref
                  ref="id-dynamic-function-invocation"/>.</p>
            <p>An example of a dynamic function call is <code>$f("a", 2)</code> where
            the value of variable <code>$f</code> must be a function item.</p></item>
            <item><p>A <code>lookup-expression</code> takes the form
            <code>E1?K</code>, where <code>E1</code> is an expression returning a sequence
            of maps or arrays, and <code>K</code> is a key specifier, which indicates which
            entries in a map, or members in an array, should be selected.</p>
               <p>Lookup expressions are described in <specref ref="id-postfix-lookup"/>.</p>
            <p>An example of a lookup expression is <code>$emp?name</code>, where
            the value of variable <code>$emp</code> is a map, and the string <code>"name"</code>
            is the key of one of the entries in the map.</p></item>
         </ulist>
         
         <p>Postfix expressions are evaluated from left-to-right. For example, the 
         expression <code>$E1[E2]?(E3)(E4)</code> is evaluated by first evaluating
            the filter expression <code>$E1[E2]</code> to produce a sequence of maps and arrays 
            (say <code>$S</code>), then evaluating the lookup expression <code>$S?(E3)</code>
            to produce a function item (say <code>$F</code>), then evaluating the dynamic
            function call <code>$F(E4)</code> to produce the final result.</p>
         
         <note><p>The grammar for postfix expressions is defined here in a way designed
         to link clearly to the semantics of the different kinds of expression. For parsing
         purposes, the equivalent production rule:</p>
         <eg>PostfixExpr := PrimaryExpr (Predicate | PositionalArgumentList | Lookup)*</eg>
         <p>(as used in XPath 3.1) is probably more convenient.</p></note>
         
      </div2>
         
         <div2 id="id-filter-expression">
            <head>Filter Expressions</head>
            
            <changes>
               <change issue="816" PR="996" date="2024-02-06">
                  The value of a predicate in a filter expression can now be a sequence of integers.
               </change>
            </changes>
            
            <scrap>
               <prodrecap ref="FilterExpr"/>
            </scrap>
            
            <p>A filter expression consists of a base expression followed by
               a predicate, which is an expression written in square
               brackets. The result of the filter expression consists of the
               items returned by the base expression, filtered by applying the
               predicate to each item in turn. The ordering of the items
               returned by a filter expression is the same as their order in
               the result of the primary expression.</p>
            
            <note>
               <p>Where the expression before the square brackets is a
                  <nt def="ReverseStep"
                     >ReverseStep</nt> or <nt def="ForwardStep"
                        >ForwardStep</nt>, the expression is technically not a
                  filter expression but an <nt
                     def="AxisStep"
                     >AxisStep</nt>. There are minor differences
                  in the semantics: see <specref
                     ref="id-predicate"/>
               </p>
            </note>
            
            
            
            <p>Here are some examples of filter expressions:</p>
            
            <ulist>
               
               <item>
                  <p>Given a sequence of products in a variable, return only those products whose price is greater than 100.</p>
                  <eg role="parse-test"><![CDATA[$products[price gt 100]]]></eg>
               </item>
               
               <item>
                  <p>List all the integers from 1 to 100 that are divisible by 5. (See <specref
                     ref="construct_seq"
                  /> for an explanation of the <code>to</code> operator.)</p>
                  <eg role="parse-test"><![CDATA[(1 to 100)[. mod 5 eq 0]]]></eg>
               </item>
               
               <item>
                  <p>The result of the following expression is the integer 25:</p>
                  <eg role="parse-test"><![CDATA[(21 to 29)[5]]]></eg>
               </item>
               
               <item>
                  <p>The following example returns the fifth through ninth items in the sequence bound to variable <code>$orders</code>.</p>
                  <eg role="parse-test" diff="chg" at="issue816"><![CDATA[$orders[5 to 9]]]></eg>
               </item>
               
               <item>
                  <p>The following example illustrates the use of a filter expression as a <termref
                     def="dt-step">step</termref> in a <termref def="dt-path-expression"
                        >path expression</termref>. It returns the last chapter or appendix within the book bound to variable <code>$book</code>:</p>
                  <eg role="parse-test"><![CDATA[$book/(chapter | appendix)[last()]]]></eg>
               </item>
               
            </ulist>
            
            <p>For each item in the input sequence, the predicate expression
               is evaluated using an <term>inner focus</term>, defined as
               follows: The context value is the item currently being tested
               against the predicate. The context size is the number of items
               in the input sequence. The context position is the position of
               the context value within the input sequence. </p>
            
            <p>For each item in the input sequence, the result of the
               predicate expression is coerced to an <code>xs:boolean</code>
               value, called the <termref def="dt-predicate-truth-value"/>, as
               described below. Those items for which the predicate truth value
               is <code>true</code> are retained, and those for which the
               predicate truth value is <code>false</code> are discarded.</p>
            
            <p><termdef id="dt-predicate-truth-value" term="predicate truth value">The
            <term>predicate truth value</term> of a value <code>$V</code>
            is the result of the expression <code>if ($V instance of xs:numeric+)
            then ($V = position()) else fn:boolean($V)</code>.</termdef></p>
            
            
            <p>Expanding this definition, the predicate truth value can be obtained 
               by applying the following rules, in order:</p>
            
            <olist>
               
               <item diff="chg" at="issue816">
                  <p>If the value <var>V</var> of the predicate expression 
                     is a sequence whose first item is an instance of the type <code>xs:numeric</code>,
                     then:</p>
                  
                     <olist>
                        <item><p><var>V</var> must be an instance of the type
                        <code>xs:numeric+</code> (that is, every item in <var>V</var>
                           must be numeric). A type error <xerrorref spec="FO40" class="RG" code="0006"/> is
                        raised if this is not the case.</p></item>
                        <item><p>The predicate truth value is <code>true</code> if 
                           <var>V</var> is equal (by the
                           <code>=</code> operator) to the <term>context
                              position</term>, and is <code>false</code>
                           otherwise.</p></item>
                     </olist>
                  
                  <p>In effect this means that an item in the input sequence is selected
                  if its position in the sequence is equal to one or more of the numeric
                  values in the predicate. For example, the predicate <code>[3 to 5]</code>
                  is true for the third, fourth, and fifth items in the input sequence.</p>
                  
                  <p><termdef term="numeric predicate" role="xquery" id="dt-numeric-predicate"
                     >A predicate whose predicate
                     expression returns a value of type <code>xs:numeric+</code> is called a <term>numeric
                        predicate</term>.</termdef> 
                  </p>
                  
                  <note><p>It is possible, though not generally useful, for the value of a numeric
                  predicate to depend on the focus, and thus to differ for different items
                  in the input sequence. For example, the predicate <code>[xs:integer(@seq)]</code>
                  selects those items in the input sequence whose <code>@seq</code> attribute
                  is numerically equal to their position in the input sequence.</p>
                  
                  <p>It is also possible, and again not generally useful, for the value of the predicate
                  to be numeric for some items in the input sequence, and boolean for others.
                  For example, the predicate <code>[@special otherwise last()]</code>
                  is true for an item that either has an <code>@special</code> attribute,
                     or is the last item in the input sequence.</p></note>
                  
                  <note><p>The truth value of a numeric predicate does not depend on the order
                  of the numbers in <var>V</var>. The predicates <code>[ 1, 2, 3 ]</code>
                  and <code>[ 3, 2, 1 ]</code> have exactly the same effect. The items in 
                  the result of a filter expression always retain the ordering of the input
                  sequence.</p></note>
                  
                  <note><p>The truth value of a numeric predicate whose value is non-integral
                  or non-positive is always false.</p></note>
                  
                  <note><p>Beware that using boolean operators (<code>and</code>, <code>or</code>,
                  <code>not()</code>) with numeric values may not have the intended effect.
                  For example the predicate <code>[1 or last()]</code> selects every item
                  in the sequence, because <code>or</code> operates on the <termref def="dt-ebv"/>
                  of its operands. The required effect can be achieved with the predicate
                  <code>[1, last()]</code>.</p></note>
                  
                  
                  
                  
               </item>
               
               
               <item>
                  <p>Otherwise, the predicate truth value is the <termref def="dt-ebv"
                     >effective boolean value</termref> of the
                     predicate expression.</p>
               </item>
               
            </olist>
         </div2>
         
      
      
      
      <div2 id="id-functions">
         <head>Functions</head>
         
         <p diff="chg" at="B">Functions in &language; arise in two ways:</p>
         
         <ulist diff="chg" at="B">
            <item><p>A <termref def="dt-function-definition"/> contains information
               about a family of functions with the same name and a defined arity range. These functions
               are in most cases known statically (they appear in the <termref def="dt-statically-known-function-definitions"/>), 
               but there may be further function definitions
               that are known only dynamically (appearing in the <termref def="dt-dynamically-known-function-definitions"/>).</p>
            </item>
     
            <item><p><termref def="dt-function-item">Function items</termref> are XDM items that can be called
               using a <termref def="dt-dynamic-function-call"/>. They  are values that can be bound to variables, passed as
            arguments, returned as function results, and generally manipulated in the same way as other XDM values.</p></item>
         </ulist>
         
         <p diff="chg" at="B">The functions defined by a statically known <termref def="dt-function-definition"/> can be invoked using a
            <termref def="dt-static-function-call"/>. <termref def="dt-function-item">Function items</termref> corresponding
            to these definitions can also be obtained, as dynamic values, by evaluating a <termref def="dt-named-function-ref"/>. 
            <termref def="dt-function-item">Function items</termref> can also be obtained using the <function>fn:function-lookup</function>
            function: in this case the function name and arity do not need to be known statically, and the function definition
            need not be present in the <termref def="dt-static-context"/>, so long as it is in the <termref def="dt-dynamic-context"/>.</p>
         
         
         <p>Static and dynamic function calls are described in the following sections.</p>
         
         <div3 id="id-static-functions" diff="add" at="A">
            
            <head>Static Function Calls</head>
            
            <!--<changes>
               <change PR="1137" issue="161" date="2024-04-23">
                  Functions may be declared to be variadic.
               </change>
            </changes>-->

               <p>The <termref def="dt-static-context"/> for an expression includes a set 
                  of <termref def="dt-statically-known-function-definitions"/>. Every <termref def="dt-function-definition"/>
               in the static context has a name (which is an <termref def="dt-expanded-qname"/>) and 
                  an <termref def="dt-arity-range"/>, which is a range of permitted arities for
               calls on that function. Two <termref def="dt-function-definition">function definitions</termref> 
                  having the same name must not have overlapping arity ranges.
               This means that for a given static function call, it is possible to identify the target function definition
               in the static context unambiguously from knowledge of the function name and the number of supplied arguments.</p>
               
               
               
               <p>A <termref def="dt-static-function-call"/> is bound to a <termref def="dt-function-definition"/> 
                  in the static context by matching the name
               and arity. If the function call has <var>P</var> positional arguments followed by
                  <var>K</var> keyword arguments, then the required arity is <var>P+K</var>, and the static context 
                  must include a <termref def="dt-function-definition"/> whose name matches the <termref def="dt-expanded-qname"/> 
                  in the function call, and whose <termref def="dt-arity-range"/> 
               includes this required arity. This is the function chosen to be called.
               The result of the function is obtained by evaluating the expression that forms its implementation, with
               a dynamic context that provides values for all the declared parameters, initialized
               as described in <specref ref="id-eval-static-function-call"/> below.</p>
               
               <p>Similarly, a function reference of the form <code>f#N</code> binds to a 
                  <termref def="dt-function-definition"/> in the
                  static context whose name matches <var>f</var> where <code>MinP ≤ N and MaxP ≥ N</code>.
               The result of evaluating a function reference is a <termref def="dt-function-item"/> which can be called
               using a dynamic function call. Function items are never variadic and their arguments
               are always supplied positionally. For example, the function reference <function>fn:concat#3</function>
               returns a function item with arity 3, which is always called by supplying three positional
               arguments, and whose effect is the same as a static call on <function>fn:concat</function> with
               three positional arguments. <!--The arity must not exceed the number of arguments that
               can be supplied positionally. Therefore, in the case of a function reference to a map-variadic functions
               such as <function>fn:serialize#2</function>, a dynamic call must supply the map-valued argument
               (the serialization parameters) in the form of a map; the function reference <function>fn:serialize#3</function>
               is an error, because <var>MaxP</var> = 2.--></p>
               
               <p>The detailed rules for evaluating static function calls and function references are defined
               in subsequent sections.</p>
                      
         <div4 id="id-function-calls">
            <head>Static Function Call Syntax</head>
            
            <changes>
               <change issue="155" PR="159" date="2020-09-30">
                  Keyword arguments are allowed on static function calls, as well as positional arguments.
               </change>
            </changes>
            
            <scrap>
               <prodrecap ref="FunctionCall"/>
            </scrap>
            
            <p><termdef term="static function call" id="dt-static-function-call">A <term>static function call</term> 
               consists of an EQName followed by a parenthesized list of zero or more arguments.</termdef></p>
            <p diff="add" at="A">The argument list consists of zero or more positional arguments,
               followed by zero or more keyword arguments.</p>
            
            <p><termdef term="argument expression" id="dt-arg-expr">An argument to a function call is either an
               <term>argument expression</term> or an <nt def="ArgumentPlaceholder">ArgumentPlaceholder</nt> 
               (<code>?</code>); in both cases it may
            either be supplied positionally, or identified by a name (called a keyword).</termdef></p>
            <p>This section is concerned with static function calls in which none of the arguments are
               <nt def="ArgumentPlaceholder">ArgumentPlaceholders</nt>. 
               Calls using one or more <nt def="ArgumentPlaceholder">ArgumentPlaceholders</nt> are covered in the 
               section <specref ref="id-partial-function-application"/>.</p>
            <p>If the function name supplied in a static function call is an unprefixed <termref def="dt-qname"
               >lexical QName</termref>, it is expanded using the <termref def="dt-default-function-namespace"/> 
               in the <termref def="dt-static-context">static context</termref>.
            </p>
            <p><phrase diff="del" at="A">In other cases, </phrase>The <termref def="dt-expanded-qname"
               >expanded QName</termref> used as the function name and the number of arguments used in the static function call 
               (the required arity) must match the name and arity range of a <termref def="dt-function-definition"/> 
               in the <termref def="dt-static-context">static context</termref> 
               <phrase> using the rules defined in the previous section</phrase>; if there is no match, a
               <termref def="dt-static-error">static error</termref> is raised <errorref class="ST" code="0017"/>.
               </p>
            
            
            <p>Evaluation of static function calls is described in <specref ref="id-eval-static-function-call"/><phrase diff="del" at="B">,
               while evaluation of dynamic function calls is described in 
               <specref ref="id-eval-dynamic-function-call"/></phrase>.</p>
            
            
            <p>Since the arguments of a function call are separated by commas, any <termref
               def="dt-arg-expr">argument expression</termref> that contains a top-level <termref
                  def="dt-comma-operator">comma operator</termref> must be
               enclosed in parentheses. Here are some illustrative examples of
               static function calls:</p>
            
            <ulist>
               
               
               <item>
                  <p>
                     <code role="parse-test"
                        >my:three-argument-function(1, 2, 3)</code> denotes a static function call with three 
                     <phrase diff="add" at="A">positional</phrase> arguments. <phrase diff="add" at="A">The 
                  corresponding function declaration must define at least three parameters, and may define
                  more, provided they are optional.</phrase></p>
               </item>
               
               
               <item>
                  <p>
                     <code role="parse-test"
                        >my:two-argument-function((1, 2), 3)</code> denotes a static function call with two arguments, the first of which is a
                     sequence of two values. <phrase diff="add" at="A">The 
                        corresponding function declaration must define at least two parameters, and may define
                        more, provided they are optional.</phrase></p>
               </item>
               
               
               <item>
                  <p>
                     <code role="parse-test"
                        >my:two-argument-function(1, ())</code> denotes a static function call with two arguments, 
                     the second of which is an empty sequence.</p>
               </item>
               
               
               <item>
                  <p>
                     <code role="parse-test"
                        >my:one-argument-function((1, 2,
                        3))</code> denotes a static function call with one argument that is a sequence of three
                     values. </p>
               </item>
               
               
               <item>
                  <p>
                     <code role="parse-test"
                        >my:one-argument-function(( ))</code> denotes a static function call with one argument that is an empty sequence.</p>
               </item>
               
               <item>
                  <p>
                     <code role="parse-test"
                        >my:zero-argument-function( )</code> denotes a static function call with zero arguments.</p>
               </item>
               <item diff="add" at="A">
                  <p>
                     <code role="parse-test">lang(node := $n, language := 'de')</code> is a static function 
                     call with two keyword arguments. The corresponding function declaration defines two parameters,
                     a required parameter <code>language</code> and an optional parameter <code>node</code>.
                     This call supplies values for both parameters. It is equivalent to the call 
                     <code>fn:lang('de', $n)</code>. Note that the keyword arguments are in a different
                     order from the parameter declarations.
                  </p>
               </item>
               <item diff="add" at="A">
                  <p>
                     <code role="parse-test">sort(//employee, key := fn($e) { xs:decimal($e/salary) })</code> is a static function 
                     call with one positional argument and one keyword argument. 
                     The corresponding function declaration defines three parameters,
                     a required parameter <code>$input</code>, an optional parameter <code>$collation</code>,
                     and an optional parameter <code>$key</code>
                     This call supplies values for the first and third parameters, leaving the second parameter (<code>$collation</code>)
                     to take its default value. The default value of the <code>$collation</code> parameter
                     is given as <code>fn:default-collation()</code>, so the value supplied to the function is the
                     default collation from the dynamic context of the caller. It is equivalent to the call 
                     <code>fn:sort(//employee, fn:default-collation(), fn($e) { xs:decimal($e/salary) })</code>.
                  </p>
               </item>
               
            </ulist>
            
            <p>An <code>EQName</code> in a <code>KeywordArgument</code> is expanded to a QName value; if there
            is no prefix, then the name is in no namespace (otherwise the prefix is resolved in the usual way).
            The keywords used in a function call (after expansion to QNames) must be distinct 
               <errorref class="ST" code="0017"/>; <errorref class="ST" code="0017"/>.</p>
         </div4> 
         
         <div4 id="id-eval-static-function-call" diff="chg" at="A">
               <head>Evaluating Static Function Calls</head>
            
            <p>This section applies to static function calls where none of the
            arguments is an <code>ArgumentPlaceholder</code>. For function calls involving
            placeholders, see <specref ref="id-partial-function-application"/>.</p>

               <p>
                      When a static function call <var>FC</var> is evaluated
                      with respect to a static context <var>SC</var> and
                      a dynamic context <var>DC</var>,
                      the result is obtained as follows:
                    </p>


               <olist>


                  <item>
                     <p>
                          The <termref def="dt-function-definition"/> <var>FD</var> to be used is found in 
                        the <termref def="dt-statically-known-function-definitions"/> of <var>SC</var>.
                        </p>
                     
                     <p>The <term>required arity</term> is the total number of arguments in the
                        function call, including both positional and keyword arguments.</p>
                     
                           <p>
                              There can be at most one <termref def="dt-function-definition"/> <var>FD</var> in the 
                              <termref def="dt-statically-known-function-definitions"/> component of <var>SC</var> whose function name
                              matches the expanded QName in <var>FC</var> and whose <termref def="dt-arity-range"/>
                              includes the arity of <var>FC</var>’s <code>ArgumentList</code>.
                           </p>
                     
                     <p>If there is no such <termref def="dt-function-definition"/>, a static error <errorref
                        class="ST" code="0017"/> is raised.</p>
                     
                     
 
                     
                  </item>

     
            
                  <item>
                     <p>Each parameter in the <termref def="dt-function-definition"/> <var>FD</var> is matched to an argument
                     expression as follows:</p>
                     <olist>
            
                        <item><p>If there are <var>N</var> positional arguments in the function call <var>FC</var>,
                           <!--and <var>FD</var> is not <termref def="dt-variadic"/>, -->then
                           the corresponding argument expressions are matched pairwise to the first <var>N</var>
                           parameters in the declaration. For this purpose the required parameters and optional parameters
                           in <var>FD</var> are concatenated into a single list, in order.</p></item>
                        <!--<item><p>If there are <var>N</var> positional arguments and no keyword arguments
                           in the function call <var>FC</var>,
                           and <var>FD</var> is <termref def="dt-variadic"/> with <var>M</var> declared
                           parameters, then:</p>
                           <olist>
                              <item><p>If <var>N</var> = <var>M-1</var>, then the <var>N</var>
                              supplied arguments are matched to the first <var>N</var> declared parameters,
                              and the <var>M</var>th parameter is bound to an empty sequence (which might cause
                              a type error if the declared type does not allow an empty sequence).</p></item>
                              <item><p>If <var>N</var> = <var>M</var>, then the <var>N</var>
                                 supplied arguments are matched to the first <var>N</var> declared parameters.</p></item>
                              <item><p>If <var>N</var> &gt; <var>M</var>, the values of the <var>M</var>th and subsequent arguments
                              are sequence-concatenated into a single value, which is matched to the <var>M</var>th
                              declared parameter. This means, for example, that if a variadic function <var>F</var>
                              with two declared parameters is called using a static function call of the form 
                                 <code>F(a, b, c)</code>, then the call is effectively equivalent to
                              <code>F(a, (b, c))</code>.</p>
                              <note><p>The combined value <code>(b, c)</code> must satisfy the required type
                              for the relevant parameter, after the coercion rules are applied.</p></note>
                              </item>
                           </olist>
                        </item>-->
                        <item><p>Any keyword arguments in <var>FC</var> are then matched to
                           parameters (whether required or optional) in <var>FD</var> by comparing the keyword
                           used in <var>FC</var> with the paramater name declared in <var>FD</var>.
                           Each keyword must match the name of a declared parameter <errorref class="ST" code="0017"/>, 
                           and this must be one that has not already
                           been matched to a positional argument. <errorref class="ST" code="0017"/>.</p></item>
                        <item><p>If any required parameter has not been matched to any argument in <var>FC</var>
                           by applying the above rules, a static error is reported <errorref class="ST" code="0017"/></p></item>
                        <item><p>If any optional parameter has not been matched to any argument in <var>FC</var>
                           by applying the above rules, then the parameter is matched to the 
                           default value expression for that parameter in <var>FD</var>.</p></item>
                     </olist>
                  </item>   
  

                  <item>
                     <p>
                          Each argument expression established by the above rules is evaluated with respect to DC.
                          The order of argument evaluation is <termref def="dt-implementation-dependent"/> and it is not
                        required that an argument be evaluated if the function body can be evaluated without evaluating
                        that argument.</p>
                     
                     <note><p>All argument expressions, including default value expressions, are evaluated in the dynamic
                     context of the function call. It is therefore possible to use a default value expression such as 
                     <code>.</code>, or <code>/</code>, or <code>fn:current-dateTime()</code>, whose value depends on the
                     dynamic context of the function call.</p></note>
                     
                     <p>If the expression used for the default value of a parameter has no dependencies on the dynamic
                     context, then an implementation <rfc2119>may</rfc2119> choose to reuse the same value on repeated
                     function calls rather than re-evaluating it on each function call.</p>
                     
                     <note><p>This is relevant, for example, if the expression constructs new nodes.</p></note>
 

                  </item>
                     
                     <item><p>The result of evaluating the argument expression is converted to the required type (the
                     declared type associated with the corresponding parameter in the function declaration, defaulting
                     to <code>item()*</code>) by applying the <termref def="dt-coercion-rules"/>.</p> 
                        <p><phrase diff="add" at="2023-12-12">This applies both to explicitly supplied arguments, and
                        to values obtained by evaluating default value expressions. In both cases a type
                        error will be raised if the value (after coercion) does not match the required type.</phrase></p>
                     <!--<p>In the case of a <termref def="dt-variadic"/> function, the coercion rules are applied
                     to the sequence-concatenation of any supplied arguments that are combined to provide a value
                     for the parameter.</p>--></item>
                  
                  

                  <item>
                     <p>The result of the function call is obtained as follows:</p>
                                 <ulist>
                                    <item>
                                       <p>
                                          <var>FD</var>’s <phrase diff="chg" at="2023-03-11">body</phrase> is invoked
                                      in an implementation-dependent way.
                                      The processor makes the following information
                                      available to that invocation:
                                      
                                    </p>
                                       <ulist>
                                          <item>
                                             <p>The converted argument values;</p>
                                          </item>
                                          <item diff="del" at="2023-03-11">
                                             <p diff="del" at="2023-03-11">
                                                An empty set of nonlocal variable bindings; and</p>
                                          </item>
                                          <item>
                                             <p diff="chg" at="2023-03-11">If the function is <termref def="dt-context-dependent"/>,
                                          the static context <var>SC</var> and dynamic context <var>DC</var> of the function call.
                                           </p>
                                          </item>
                                       </ulist>
                                       <p diff="del" at="2023-03-11">
                                      How this information is used is <termref
                                             def="dt-implementation-defined"
                                             >implementation-defined</termref>.
                                      An API used to call external functions must state
                                      how the static and dynamic contexts are provided
                                      to a function that is called.
                                      The F&amp;O specification states how the static and dynamic contexts
                                      are used in each function that it defines. 
                                      <phrase
                                             role="xpath"
                                             >
                                      A host language must state how the static and dynamic contexts
                                      are used in functions that it provides.
                                      </phrase>
                                       </p>
                                    </item>
                                    <item>
                                       <p>The result is converted to the required type (the
                                             declared return type in the function declaration, defaulting
                                             to <code>item()*</code>) by applying the <termref def="dt-coercion-rules"/>.</p>
                                      <p>The result of applying the coercion rules is either an instance of <var>FD</var>’s return type
                                      or a dynamic error.
                                      This result is then the result of evaluating <var>FC</var>.</p>
                                      <note><p>A host language may define alternative rules for processing the result, especially
                                      in the case of external functions implemented using a non-XDM type system.</p></note>
                                    </item>
                                    
                                    <item>
                                       <p>
                                      Errors raised by system functions are defined in
                                      <bibref
                                             ref="xpath-functions-40"
                                          />.
                                    </p>
                                    </item>
                                    <item role="xquery">
                                       <p>
                                      Errors raised by external functions are
                                      <termref
                                             def="dt-implementation-defined"
                                             >implementation-defined</termref>
                                      (see <specref
                                             ref="id-consistency-constraints"
                                          />).
                                    </p>
                                    </item>
                                    <item role="xpath">
                                       <p>
                                      Errors raised by host-language-dependent functions are
                                      <termref
                                             def="dt-implementation-defined"
                                             >implementation-defined</termref>.
                                    </p>
                                    </item>
                                 </ulist>
                                 <example>
                                    <head>A System Function</head>
                                    <p>The following function call uses the function 
                                  <xspecref
                                          spec="FO40" ref="func-base-uri"
                                          />.  Use of <code>SC</code> and <code>DC</code> and errors raised by this function are all defined in 
                                  <bibref
                                          ref="xpath-functions-40"/>.</p>

                                    <eg role="parse-test"><![CDATA[base-uri()]]></eg>

                                 </example>
                             
                  </item>

               
               </olist>

            
               </div4>
               
            </div3>
         
         <div3 id="id-dynamic-functions">
            <head>Function Items</head>

            <p>A <termref def="dt-function-item"/> is an XDM
            value that can be bound to a variable, or manipulated in various ways by &language; expressions.
            The most significant such expression is a <termref def="dt-dynamic-function-call"/>, which supplies
            values of arguments and evaluates the function to produce a result.</p>
            
            <p>The syntax of dynamic function calls is defined in <specref ref="id-dynamic-function-invocation"/>.</p>
            
            <p>A number of constructs can be used to produce a <termref def="dt-function-item"/>, notably:</p>
            
            <ulist>
               <item><p>A <term>named function reference</term> (see <specref ref="id-named-function-ref"/>)
               constructs a function item by reference to <termref def="dt-function-definition">function definitions</termref>
                  in the static context. For example, <function>fn:node-name#1</function>
               returns a function item whose effect is to call the static <function>fn:node-name</function> function
               with one argument.</p></item>
               <item><p>An <term>inline function</term> (see <specref ref="id-inline-func"/><!-- and <specref ref="id-lambda-expressions"/>-->)
                  constructs a function item whose <phrase diff="chg" at="2023-03-11">body</phrase> is defined locally. For example, the
               construct <code>fn($x) { $x + 1 }</code> returns a function item whose effect is to increment
               the value of the supplied argument.</p></item>
               <item><p>A <term>partial function application</term> (see 
                  <specref ref="id-partial-function-application"/>) derives one function item from another by supplying
               the values of some of its arguments. For example, <code>fn:ends-with(?, ".txt")</code> returns
               a function item with one argument that tests whether the supplied string ends with the substring
                  <code>".txt"</code>.</p></item>
               <item><p>Maps and arrays are also function items. See <specref ref="id-map-constructors"/>
               and <specref ref="id-array-constructors"/>.</p></item>
               <item diff="add" at="B"><p>The <function>fn:function-lookup</function> function can be called to discover functions
               that are present in the <termref def="dt-dynamic-context"/>.</p></item>
               <item diff="add" at="B"><p>The <function>fn:load-xquery-module</function> function can be called to load functions
                  dynamically from an external XQuery library module.</p></item>
               <item diff="add" at="B"><p>Some system functions such as <function>fn:random-number-generator</function> 
                  and <function>fn:op</function> return a <termref def="dt-function-item"/> as their result.</p></item>
            </ulist>
            
            <p>These constructs are described in detail in the following sections, or in
               <bibref ref="xpath-functions-40"/>.</p>
         
            <div4 id="id-dynamic-function-invocation">
               <head>Dynamic Function Calls</head>
               
               <scrap>
                  <prodrecap ref="DynamicFunctionCall"/>
               </scrap>
               
               <p>
                  <termdef term="dynamic function call" id="dt-dynamic-function-invocation"
                     >A <term>dynamic function call</term>
                     consists of a base expression that returns the function and a
                     parenthesized list of zero or more arguments (<termref
                        def="dt-arg-expr">argument expressions</termref> or
                     ArgumentPlaceholders).</termdef>
               </p>
               
               <p>
                  A dynamic function call is evaluated as described in
                  <specref
                     ref="id-eval-dynamic-function-call"/>.
               </p>
               
               <p>The following are examples of some dynamic function calls:</p>
               
               <ulist>
                  <item>
                     <p>This example calls the function contained in <code>$f</code>, passing the arguments 2 and 3:
                        <eg
                           role="parse-test"><![CDATA[$f(2, 3)]]></eg>
                     </p>
                  </item>
                  <item>
                     <p>This example fetches the second item from sequence <code>$f</code>, treats it as a function and calls it, passing an <code>xs:string</code> argument:
                        <eg
                           role="parse-test"><![CDATA[$f[2]("Hi there")]]></eg>
                     </p>
                  </item>
                  <item>
                     <p>This example calls the function <code>$f</code> passing no arguments, and filters the result with a positional predicate:
                        <eg
                           role="parse-test"><![CDATA[$f()[2]]]></eg>
                     </p>
                  </item>
                  
               </ulist>
               
               <note diff="add" at="A">
                  <p>Arguments in a dynamic function call are always supplied positionally.</p>
               </note>
               
            </div4>
         
         <div4 id="id-eval-dynamic-function-call">
               <head>Evaluating Dynamic Function Calls</head>
           
            
            <p>This section applies to dynamic function calls whose arguments do not include
            an <code>ArgumentPlaceholder</code>. For function calls that include a placeholder,
            see <specref ref="id-partial-function-application"/>.</p>
            
            <p diff="add" at="B"><termdef id="dt-dynamic-function-call" term="dynamic function call">A <term>dynamic function call</term>
            is an expression that is evaluated by calling a <termref def="dt-function-item"/>, which is
            typically obtained dynamically.</termdef></p>

               <p>
                      When a dynamic function call <var>FC</var> is evaluated,
                      the result is obtained as follows:
                    </p>


               <olist>

                  <item>
                     <p>
                          The <termref def="dt-function-item"/> <var>FI</var> to be called
                          is obtained by evaluating the base expression of the function call.
                              If this yields a sequence consisting of a single function item
                              whose arity matches the number of arguments in the <code>ArgumentList</code>,
                              let <var>FI</var> denote that function item.
                              Otherwise, a type error is raised
                              <errorref
                                 class="TY" code="0004"/>.
                            </p>
                     <note diff="add" at="A"><p>Keyword arguments are not allowed in a dynamic function call.</p></note>
                       
                  </item>

                  <item>
                     <p>
                        <termref def="dt-arg-expr">Argument expressions</termref> are evaluated, 
                        producing <term>argument values</term>. The order of argument evaluation is <termref
                           def="dt-implementation-dependent"
                        >implementation-dependent</termref> and an argument need not be evaluated 
                        if the function body can be evaluated without evaluating that argument.</p>
                  </item>


                  <item>
                     <p>
                          Each argument value is converted
                          to the corresponding parameter type in <var>FI</var>’s signature
                          by applying the <termref def="dt-coercion-rules">coercion rules</termref>, resulting in a
                        <term>converted argument value</term>
                     </p>

                  </item>
                  
                  
                  <item>
                     <p>If <var>FI</var> is a map, it is evaluated as described in <specref
                           ref="id-map-lookup"/>.</p>
                  </item>
                  
                  <item>
                     <p>If <var>FI</var> is an array, it is evaluated as described in <specref
                        ref="id-array-lookup"/>.</p>
                  </item>

                              <item>
                                 
                                 <p>
                                  If <var>FI</var>’s <phrase diff="chg" at="2023-03-11">body</phrase> is 
                                  
                                  an &language; expression
                                  
                                    (for example, if <var>FI</var> is
                                    <phrase
                                       role="xquery">a <termref def="dt-udf"
                                          >user-defined function</termref> or</phrase>
                                    an <termref
                                       def="dt-anonymous-function"
                                       >anonymous function</termref>,
                                    or a
                                    <termref
                                       def="dt-partially-applied-function"
                                       >partial application</termref>
                                    of such a function):
                                  
                                </p>

                                 <olist>
                                    <item>
                                       <p>
                                          <var>FI</var>’s <phrase diff="chg" at="2023-03-11">body</phrase> 
                                      is evaluated.
                                      
                                        The static context for this evaluation
                                        is the static context of the &language; expression.
                                      
                                      The dynamic context for this evaluation is obtained
                                      by taking the dynamic context of the
                                      <phrase
                                             role="xquery">module</phrase>
                                          <phrase role="xpath">
                                             <code>InlineFunctionExpr</code>
                                          </phrase>
                                      that contains the <code>FunctionBody</code>, and
                                      making the following changes:
                                    </p>
                                       <ulist>
                                          <item>
                                             <p>
                                          The <termref
                                                  def="dt-focus"
                                                  >focus</termref>
                                          (context value, context position, and context size)
                                          is <xtermref
                                                  spec="DM40" ref="dt-absent"
                                                />.
                                        </p>
                                          </item>

                                          <item>
                                             <p>
                                          In the <termref
                                                  def="dt-variable-values"
                                                >variable values</termref> component of the dynamic context,
                                          each converted argument value is bound to the
                                          corresponding parameter name.
                                        </p>

                                             <p>
                                          <phrase diff="chg" at="B">When this is done,
                                          the converted argument values retain
                                          their <termref def="dt-dynamic-type">dynamic types</termref>,
                                          even where these are <termref def="dt-subtype">subtypes</termref> 
                                          of the declared parameter types.</phrase>
                                          For example, a function with
                                          a parameter <code>$p</code> of type <code>xs:decimal</code>
                                          can be called with an argument of type <code>xs:integer</code>,
                                          which is derived from <code>xs:decimal</code>.
                                          During the processing of this function
                                          call, the value of <code>$p</code> inside the body of the function 
                                          retains its <termref def="dt-dynamic-type"/> of <code>xs:integer</code>.
                                        </p>
                                          </item>

                                          <item>
                                             <p>
                                          <var>FI</var>’s nonlocal variable bindings
                                          are also added to the <termref
                                                  def="dt-variable-values"
                                                >variable values</termref>.
                                          (Note that the names of the nonlocal variables
                                          are by definition disjoint from the parameter names,
                                          so there can be no conflict.)
                                        </p>
                                          </item>

                                       </ulist>

                                    </item>

                                    <item>
                                       <p>
                                      The value returned by evaluating the function body
                                      is then converted to the declared return type of <var>FI</var>
                                      by applying the
                                      <termref
                                             def="dt-coercion-rules"
                                             >coercion rules</termref>.
                                      The result is then the result of evaluating <var>FC</var>.
                                    </p>

                                       <p>
                                      As with argument values,
                                      the value returned by a function
                                      retains its <termref def="dt-dynamic-type"/>,
                                      which may be a <termref def="dt-subtype"/> of the declared return type of <var>FI</var>.
                                      For example, a function that has
                                      a declared return type of <code>xs:decimal</code>
                                      may in fact return a value of dynamic type <code>xs:integer</code>.
                                    </p>
                                    </item>
                                 </olist>
                                 <example>
                                    <head>Derived Types and Nonlocal Variable Bindings</head>
                                    <p>
                                       <code>$incr</code> is a nonlocal variable that is available within the function because its variable binding has been added to the variable values of the function..  Even though the parameter and return type of this function are both <code>xs:decimal</code>,
                                  the more specific type <code>xs:integer</code> is preserved in both cases.</p>
                                    <eg role="parse-test"><![CDATA[
let $incr := 1
let $f := function($i as xs:decimal) as xs:decimal { $i + $incr }
return $f(5)]]></eg>
                                 </example>
                                 <example>
                                    <head>Using the Context Value in an Anonymous Function</head>
                                    <p>The following example will raise a <termref def="dt-type-error"/> <errorref
                                          class="DY" code="0002"/>:</p>
                                    <eg role="parse-test"><![CDATA[
let $vat := function() { @vat + @price }
return doc('wares.xml')/shop/article/$vat()]]></eg>
                                    <p>Instead, the context value can be used as an argument to the anonymous function:</p>
                                    <eg role="parse-test"><![CDATA[
let $vat := function($art) { $art/@vat + $art/@price }
return doc('wares.xml')/shop/article/$vat(.)]]></eg>
                                    <p>Alternatively, the value can be referenced as a nonlocal variable binding:</p>
                                    <eg role="parse-test"><![CDATA[
let $ctx := doc('wares.xml')/shop/article
let $vat := function() { for $a in $ctx return $a/@vat + $a/@price }
return $vat()
]]></eg>
                                    <p>Finally, a <termref def="dt-focus-function"/> can be used.
                                       This binds the value of the argument to the context value within the function body:</p>
                                    <eg role="parse-test"><![CDATA[
let $vat := function { @vat + @price }
return $vat(doc('wares.xml')/shop/article)
]]></eg>
                                 </example>

                              </item>

                              <item>
                                 <p>                                  
                                  If the implementation of <var>FI</var> is
                                  not an &language; expression
                                  (for example, <var>FI</var> is
                                  a <termref
                                       def="dt-system-function">system function</termref>
                                    <phrase role="xquery">or an <termref def="dt-external-function"
                                          >external function</termref>,
                                    </phrase>
                                    the <phrase diff="chg" at="2023-03-11">body</phrase> of the function is
                                       evaluated, and the result is converted
                                       to the declared return type, in the same way as for a 
                                       static function call (see <specref ref="id-function-calls"/>).</p>
                                 
                                 <p>Errors may be raised in the same way.</p>
                                    
                                
                                 
                              </item>

                           
               </olist>
            </div4>


            <div4 id="id-partial-function-application"  diff="chg" at="2023-03-12">
               <head>Partial Function Application</head>
               
               <p>
                  <termdef term="partial function application" id="dt-partial-function-application">
                     A static or <termref def="dt-dynamic-function-invocation">dynamic</termref>
                     function call is a <term>partial function application</term>
                     if one or more arguments is an <nt def="ArgumentPlaceholder">ArgumentPlaceholder</nt>.</termdef>
               </p>
               
               <p>The rules for partial function application in static function calls and dynamic function
               calls have a great deal in common, but they are stated separately below for clarity.</p>
               
               <p>In each case, the result of a partial function application is a 
                  <termref def="dt-function-item"/>, whose
                  arity is equal to the number of placeholders in the call.</p>
               
               <p>More specifically, the result of the partial function application is 
                  a <termref
                  def="dt-partially-applied-function"
                  >partially applied function</termref>.
                  <termdef term="partially applied function"
                  id="dt-partially-applied-function"
                  >A <term>partially applied function</term>
                  is a function created by  <termref
                     def="dt-partial-function-application"
                     >partial function application</termref>.</termdef>
               </p>
               
               
               <p>For static function calls, the result is obtained as follows:</p>
               
               <olist>
                  <item>
                     <p>The <termref def="dt-function-definition"/> <var>FD</var> to be partially applied
                        is determined in the same way as for a static function call without placeholders, 
                        as described in <specref ref="id-function-calls"/>.
                        For this purpose an <code>ArgumentPlaceholder</code> contributes to the count of
                        arguments.</p>
                  </item>
                  
                  <!--<item><p>If <var>FD</var> is <termref def="dt-variadic"/>, and
                     the function call has no keyword arguments, then the static function call
                  <code><var>F</var>(<var>ARGS</var>)</code> is transformed into the dynamic
                  call <code><var>F</var>#<var>N</var>(<var>ARGS</var>)</code>, where <var>N</var>
                  is the number of supplied arguments.</p>
                  <note><p>For example, <code>fn:concat('[', ?, ']')</code> is transformed
                  into the expression <code>fn:concat#3('[', ?, ']')</code>. For the meaning
                     of a named function reference applied to a variadic function, 
                     see <specref ref="id-named-function-ref"/>.</p></note></item>-->
                  
                  <!--<item><p>If <var>FD</var> is <termref def="dt-variadic"/>, and
                     the function call does have keyword arguments, then a static error
                     is raised <errorref class="ST" code="0017"/>. </p></item>-->
                  
                  
                  <item>
                     <p>The parameters of <var>FD</var> are classified into three categories:</p>
                     <ulist>
                        <item><p>Parameters that map to a placeholder, referred to as <term>placeholder parameters</term>.</p></item>
                        <item><p>Parameters for which an explicit value is given in the function call (either
                        positionally or by keyword), referred to as <term>explicitly supplied parameters</term>.</p></item>
                        <item><p>Parameters (which are necessarily optional parameters) for which no corresponding
                        argument is supplied, either as a placeholder or with an explicit value. These are referred to
                        as <term>defaulted parameters</term>.</p></item>
                     </ulist>
                     
                     <note>
                        <p>A partial function application need not have any explicitly supplied parameters.
                        For example, the partial function application <code>fn:string(?)</code>
                        is allowed; it has exactly the same effect as the named function reference
                        <function>fn:string#1</function>. </p></note>
                  </item>
                  <item>
                     <p>Explicitly supplied parameters and defaulted parameters are evaluated and 
                        converted to the required type using the rules for a static function call.
                        This may result in an error being raised.</p>
                     
                     <p diff="add" at="2023-12-12">A type error is raised if any of the explicitly supplied or defaulted
                        parameters, after applying the
                        <termref def="dt-coercion-rules"/>, does not match the required type 
                        of the corresponding parameter.</p>
                     
                     <p diff="add" at="2023-12-12">In addition, a dynamic error <rfc2119>may</rfc2119> 
                        be raised if any of the explicitly supplied or defaulted parameters does not match other constraints on the
                        value of that parameter (for example, if the value supplied for a parameter expecting
                        a regular expression is not a valid regular expression); or if the processor is
                        able to establish that evaluation of the resulting function will fail
                        for any other reason (for example, if an error is raised while evaluating 
                        a subexpression in the function
                        body that depends only on explicitly supplied and defaulted parameters).</p>
                     
                     <p diff="add" at="2023-12-12">In all cases the error code is the same as for a static
                        function call supplying the same invalid value(s).</p>
                     
                     <p diff="add" at="2024-02-02">In the particular case where all the supplied arguments
                     are placeholders, the error behavior <rfc2119>should</rfc2119> be the same as
                     for an equivalent <termref def="dt-named-function-ref"/>: for example, <function>fn:id#1</function>
                     fails if there is no context node, and <code>fn:id(?)</code> <rfc2119>should</rfc2119>
                     fail likewise.</p>
                     
                     
                     

                  </item>

                  <item>
                     <p>
                        The result is a <termref
                           def="dt-partially-applied-function"
                           >partially applied function</termref> having
                        the following properties (which are defined in <xspecref
                           spec="DM40" ref="function-items"/>):
                     </p>
                     <ulist>
                        <item>
                           <p><term>name</term>: The name of <var>FD</var> if all parameters map
                              to placeholders, that is, if the partial function application is
                              equivalent to the corresponding <termref
                                 def="dt-named-function-ref">named function reference</termref>.
                              Otherwise, the name is absent.
                           </p>
                        </item>
                        <item><p diff="add" at="2023-05-25"><term>identity</term>: A new function
                           identity distinct from the identity of any other function item.</p>
                           <note><p>See also <specref ref="id-function-identity"/>.</p></note>
                        </item>
                        <item>
                           <p><term>arity</term>: The number of placeholders in the function call.</p>
                        </item>
                        <item>
                           <p>
                              <term>parameter names</term>:
                              The names of the parameters of <var>FD</var>
                              that have been identified as placeholder parameters,
                              retaining the order in which the placeholders appear in the
                              function call.
                           </p>
                           <note><p>A partial function application can be used to change the order
                           of parameters, for example <code>fn:contains(substring := ?, value := ?)</code>
                           returns a function item that is equivalent to <function>fn:contains#2</function>,
                           but with the order of arguments reversed.</p></note>
                        </item>
                        
                        <item>
                           <p>
                              <term>signature</term>: The parameters in the returned function
                              are the parameters of <var>FD</var>
                              that have been identified as placeholder parameters,
                              retaining the order in which the placeholders appear in the
                              function call. The result type of the returned function
                              is the same as the result type of <var>FD</var>.</p>
                              
                              <p>An implementation which can determine a more specific signature (for example, 
                              through use of type analysis) is permitted to do so.
                           </p>
                        </item>
                        
                        <item>
                           <p><term>body</term>: The body of <var>FD</var>.</p>
                        </item>
                        
                        <item>
                           <p>
                              <term>captured context</term>: The
                              static and dynamic context of the function call, augmented,
                              for each explicitly supplied parameter and each defaulted parameter, with
                              a binding of the converted argument value
                              to the corresponding parameter name.
                           </p>
                        </item>
                     </ulist>
 
                     <example>
                        <head>Partial Application of a System Function</head>
                        
                        <p>The following partial function application creates a function 
                           item that computes the sum of squares of a sequence.</p>
                        <eg role="parse-test"><![CDATA[let $sum-of-squares := fold-right(?, 0, function($a, $b) { $a*$a + $b })
return $sum-of-squares(1 to 3)]]></eg>
                        <p>
                           <code>$sum-of-squares</code> is an anonymous function. It has one parameter, named <code>$seq</code>, which is taken from the corresponding parameter in <function>fn:fold-right</function> (the other two parameters are fixed). The implementation is the implementation of <function>fn:fold-right</function>, which is a context-independent system function. The nonlocal bindings contain the fixed bindings for the second and third parameters of <function>fn:fold-right</function>.</p>
                     </example>
              
                  </item>
                  
                  
               </olist>
               
               
               <p>For dynamic function calls,  the result is obtained as follows:</p>

               <olist>
                  <item>
                     <p>The <termref def="dt-function-item"/> <var>FI</var> to be partially applied is 
                        determined in the same way as for a 
                        dynamic function call without placeholders, as described in <specref ref="id-dynamic-function-invocation"/>.
                        For this purpose an <code>ArgumentPlaceholder</code> contributes to the count of
                        arguments.</p>
                  </item>
                  
                  <item>
                     <p>The parameters of <var>FI</var> are classified into two categories:</p>
                     <ulist>
                        <item><p>Parameters that map to a placeholder, referred to as <term>placeholder parameters</term>.</p></item>
                        <item><p>Parameters for which an explicit value is given in the function call, 
                           referred to as <term>supplied parameters</term>.</p></item>
                     </ulist>
                     
                     <note>
                        <p>A partial function application need not have any explicitly supplied parameters.
                        For example, if <code>$f</code> is a function with arity 2, then
                           the partial function application <code>$f(?, ?)</code> returns
                           a function that has exactly the same effect as <code>$f</code>. </p></note>
                  </item>

                  
                  <item>
                     <p>Arguments corresponding to supplied parameters are evaluated
                        and converted to the required
                     type of the parameter, using the rules for dynamic function calls.</p>
                     
                     <p diff="add" at="2023-12-12">A type error is raised if any of the supplied
                        parameters, after applying the
                        <termref def="dt-coercion-rules"/>, does not match the required type.</p>
                     
                     <p diff="add" at="2023-12-12">In addition, a dynamic error <rfc2119>may</rfc2119> 
                     be raised if any of the supplied parameters does not match other constraints on the
                     value of that parameter (for example, if the value supplied for a parameter expecting
                     a regular expression is not a valid regular expression); or if the processor is
                     able to establish that evaluation of the resulting function will fail
                     for any other reason (for example, if an error is raised while evaluating 
                     a subexpression in the function
                     body that depends only on explicitly supplied parameters).</p>
                     
                     <p diff="add" at="2023-12-12">In both cases the error code is the same as for a dynamic
                     function call supplying the same invalid value.</p>
                     
                     
                  </item>


                  
                  
                  
                     
                     
                        <item>
                           <p>
                              The result of the partial function application is a  <termref
                                 def="dt-partially-applied-function"
                                 >partially applied function</termref> with
                              the following properties (which are defined in <xspecref
                                 spec="DM40" ref="function-items"
                              />):
                            </p>
                           <ulist>
                              <item>
                                 <p>
                                    <term>name</term>:
                                  Absent.
                                </p>
                              </item>
                              <item>
                                 <p><term>arity</term>: The number of placeholders in the function call.</p>
                              </item>
                              <item>
                                 <p>
                                    <term>parameter names</term>:
                                  The names of parameters in <var>FI</var> that have
                                    been identified as placeholder parameters, in order.
                                </p>
                                 <note><p>In a dynamic partial function application, argument keywords
                                 are not available, so it is not possible to change the order of parameters.</p></note>
                              </item>

                              <item>
                                 <p>
                                    <term>signature</term>:
                                  The signature of <var>FI</var>,
                                  removing the types of supplied parameters.
				  
				                      An implementation which can determine a more specific signature (for example, 
				                      through use of type analysis) is permitted to do so.
                                </p>
                              </item>

                              <item>
                                 <p><term>body</term>: The body of <var>FI</var>.
                                </p>
                              </item>

                              <item>
                                 <p>
                                    <term>captured context</term>: the
                                    captured context of <var>FI</var>, augmented,
                                  for each supplied parameter, with
                                  a binding of the converted argument value
                                  to the corresponding parameter name.
                                </p>
                              </item>
                           </ulist>
                           <example>
                              <head>Partial Application of an Anonymous Function</head>
                              <p>In the following example, <code>$f</code> is an anonymous function, and <code>$paf</code> is a partially applied function created from <code>$f</code>.</p>
                              <eg role="parse-test"><![CDATA[
let $f := function($seq, $delim) { fold-left($seq, "", concat(?, $delim, ?)) }
let $paf := $f(?, ".")
return $paf(1 to 5)
]]></eg>
                              <p>
                                 <code>$paf</code> is also an anonymous function.  It has one parameter, named <code>$delim</code>, which is taken from the corresponding parameter in <code>$f</code>
                              (the other parameter is fixed).  The implementation of <code>$paf</code> is the implementation of <code>$f</code>, which is <code>fn:fold-left($seq, "", fn:concat(?, $delim, ?))</code>.  This implementation is associated with the <code>SC</code> and <code>DC</code> of the original expression in <code>$f</code>.  The nonlocal bindings associate the value <code>"."</code> with the parameter <code>$delim</code>.</p>
                           </example>
                          
                        </item>


                    </olist>
               
               
               
               
               <p>Partial function application never returns a map or an array.  If <code>$f</code> is a map or an array, then <code>$f(?)</code> is 
                  a partial function application that returns a function, but the function it returns is neither a map nor an array.</p>
               <example>
                  <head>Partial Application of a Map</head>
                  <p>The following partial function application converts a map to an equivalent function that is not a map.</p>
                  <eg role="parse-test"><![CDATA[let $a := { "A": 1, "B": 2 }(?)
return $a("A")]]></eg>
               </example>
                  
               
               
            </div4>



         



         <!-- ******************************************************************** -->

         <div4 id="id-named-function-ref">
            <head>Named Function References</head>

            <scrap>
               <prodrecap ref="NamedFunctionRef"/>
            </scrap>

            <p>
               <termdef term="named function reference" id="dt-named-function-ref">
          A <term>named function reference</term> is an expression (written <code>name#arity</code>)
                  which evaluates to a <termref def="dt-function-item"/>, <phrase diff="add" at="2023-03-11">the details
                  of the function item being based on the properties of a <termref def="dt-function-definition"/>
                  in the <termref def="dt-static-context"/></phrase>.</termdef></p>
            
            <p>The name and arity of the required function are known statically.</p>
          
            <p diff="chg" at="A">If the EQName is a <termref def="dt-qname">lexical QName</termref>, it is expanded using the 
               <termref def="dt-default-function-namespace"/> in the <termref def="dt-static-context">static context</termref>.</p>
            
            <p>The expanded QName and arity must correspond to a <termref def="dt-function-definition"/>
               present in the <termref def="dt-static-context">static context</termref>.
            <phrase diff="add" at="variadicity">More specifically, for a named function reference <code>F#N</code>,
               there must be a <termref def="dt-function-definition"/> in the <termref def="dt-statically-known-function-definitions"/>
               whose name matches <var>F</var>, and whose <termref def="dt-arity-range"/> includes <var>N</var></phrase>.
               Call this <termref def="dt-function-definition"/> <var>FD</var>.</p>
            
            <p diff="chg" at="2023-03-11">If <var>FD</var> is
          <termref def="dt-context-dependent"/> for the given arity, then the returned function item has
               a captured context comprising
          the static and dynamic context of the named function reference.</p>
            
            <note diff="chg" at="2023-03-11"><p>In practice, it is necessary to retain only those
            parts of the static and dynamic context that can affect the outcome. These means it is 
            unnecessary to retain parts of the context that no <termref def="dt-system-function"/>
            depends on (for example, local variables), or parts that are invariant within an
            execution scope (for example, the implicit timezone).</p></note>
            
            
            <example diff="add" at="B">
               <head>A Context-Dependent Named Function Reference</head>
               <p>Consider:</p>
               <eg role="parse-test"><![CDATA[let $f := <foo/>/fn:name#0 return <bar/>/$f()]]></eg>
               <p>The function <code>fn:name()</code>, with no arguments, returns the name of the context node. The function
               item delivered by evaluating the expression <function>fn:name#0</function> returns the name of the element that was the
               context node at the point where the function reference was evaluated (that is, the <code>&lt;foo&gt;</code> element).
               This expression therefore returns <code>"foo"</code>, not <code>"bar"</code>.</p>
            </example>
            

               <p diff="add" at="2023-12-12">An error is raised if the identified function depends on components of the static or dynamic
                  context that are not present, or that have unsuitable values. For example <errorref 
                     class="DY" code="0002" type="type"/> is raised for the expression <function>fn:name#0</function>
                  if the context item is absent, and <xerrorref spec="FO" class="DC" code="0001" type="dynamic"
                  /> is raised for the call <function>fn:id#1</function> if the context item is not a node
                  in a tree that is rooted at a document node. The error that is raised is the same as the error that would
                  be raised by the corresponding function if called with the same static and dynamic context.</p>
           
            <p>If the <termref def="dt-expanded-qname"
                  >expanded QName</termref> and arity in a named function reference do not match the 
               name and <termref def="dt-arity-range"/> of a <termref def="dt-function-definition"/> in the
          static context, a static error is raised <errorref
                  class="ST" code="0017"/>.</p>

            <p diff="chg" at="variadicity">
            The value of a <code>NamedFunctionRef</code>
               is a <termref def="dt-function-item">function item</termref> <var>FI</var> 
               obtained from <var>FD</var>
               as follows:
               <ulist>
                  <item>
                     <p><term>name</term>: The name of <var>FD</var>.</p>
                  </item>
                  <item><p diff="add" at="2023-05-25"><term>identity</term>:</p>
                     <ulist>
                        <item><p>If <var>FD</var> is <termref def="dt-context-dependent"/> for the given arity, then a new function
                        identity distinct from the identity of any other function item.</p>
                           <note><p>In the general case, a function reference to a context-dependent function
                           will produce different results every time it is evaluated, because the resulting function
                           item has a <term>captured context</term> 
                              (see <xspecref spec="DM40" ref="function-items"/>) that includes the dynamic context
                           of the particular evaluation. Optimizers, however, are allowed to detect cases where
                           the captured context happens to be the same, or where any variations are immaterial,
                           and where it is therefore safe to return the same function item each time. This might be
                           the case, for example, where the only context dependency of a function is on the default
                           collation, and the default collation for both evaluations is known to be the same.</p></note></item>
                        <item><p>Otherwise, a function identity that is the same as that produced by the evaluation
                           of any other named function reference with the same function name and arity.</p>
                             <p>This rule applies even across different 
                                <xtermref spec="FO40" ref="execution-scope">execution scopes</xtermref>:
                             for example if a parameter to a call to <function>fn:transform</function> is set to the
                             result of the expression <function>fn:abs#1</function>, then the function item passed as the parameter
                                value will be identical to that obtained by evaluating the expression <function>fn:abs#1</function>
                             within the target XSLT stylesheet.</p>
                           <p>This rule also applies when the target function definition is 
                           <xtermref spec="FO40" ref="dt-nondeterministic">nondeterministic</xtermref>. 
                           For example all evaluations of the named function reference <function>map:keys#2</function>
                           return identical function items, even though two evaluations of <function>map:keys</function>
                           with the same arguments may produce different results.</p>
                        </item>
                     </ulist>
                     <note><p>See also <specref ref="id-function-identity"/>.</p></note>
                  </item>
                  <item>
                     <p><term>arity</term>: As specified in the named function reference.</p>
                  </item>
                  <item>
                     <p><term>parameter names</term>: The first <var>A</var> parameter names of
                        <var>FD</var>, where <var>A</var> is the required arity.</p>
                     <!--<p>In the case where <var>FD</var> is <termref def="dt-variadic"/> and
                     <var>A</var> exceeds the number of declared parameters in <var>FD</var>,
                     the parameter names are <termref def="dt-implementation-defined"/>.</p>-->
                  </item>
                  <item>
                     <p><term>signature</term>: Formed from the required types of the first
                        <var>A</var> parameters of <var>FD</var>, and the function result type of
                        <var>FD</var>.</p>
                     <!--<p>In the case where <var>FD</var> is <termref def="dt-variadic"/> and
                     <var>A</var> exceeds the number of declared parameters in <var>FD</var>,
                     the required type of each excess parameter in the result is the same
                     as the required type of the last declared parameter of <var>FD</var>.</p>
                     <note><p>The required type of each
                     parameter of <function>fn:concat#3</function> is thus <code>xs:anyAtomicType*</code>,
                     which means that a call such as <code>concat#3(("a","b"), ("c","d"), ())</code>
                     is allowed.</p></note>-->
                  </item>
                  <item>
                     <p><term>body</term>: The body of <var>FD</var>.</p>
                  </item>
                  <item>
                     <p diff="chg" at="2023-03-12"><term>captured context</term>: Comprises the
                        static and dynamic context of the named function reference, augmented with
                        bindings of the names of parameters of <var>FD</var> beyond the
                        <var>A</var>’th parameter, to their respective default values.</p>
                     <note diff="chg" at="2023-03-12"><p>In practice, it is necessary to retain
                        only the parts of the context that the function actually depends on
                        (if any).</p></note></item>
               </ulist>
            </p>
            
            <note diff="add" at="variadicity"><p>Consider the system function <function>fn:format-date</function>,
            which has an arity range of 2 to 5. The named function reference <function>fn:format-date#3</function>
            returns a function item whose three parameters correspond to the first three parameters
            of <function>fn:format-date</function>; the remaining two arguments will take their default values.
               To obtain an arity-3 function that binds to arguments 1, 2, and 5 of <function>fn:format-date</function>,
            use the partial function application <code>format-date(?, ?, place := ?)</code>.</p></note>

            





            <p>The following are examples of named function references:
          </p>

            <ulist>
               <item>
                  <p>
                     <code role="parse-test"
                     >fn:abs#1</code> references the <function>fn:abs</function> function which takes a single argument.</p>
               </item>
               <item>
                  <p>
                     <code role="parse-test"
                     >fn:concat#5</code> references the <function>fn:concat</function> function which takes 5 arguments.</p>
               </item>
               <item>
                  <p>
                     <code role="parse-test"
                     >local:myfunc#2</code> references a function named <code>local:myfunc</code> which takes 2 arguments.</p>
               </item>
            </ulist>
            
            <note diff="add" at="A"><p>Function items, as values in the data model, have a fixed arity, and
            a dynamic function call always supplies the arguments positionally. <!--Although the base function
            referred to may be variadic, the result of evaluating the function reference is a function that
            has fixed arity. -->In effect, the result of evaluating <code>my:func#3</code> is the
            same as the result of evaluating the inline function expression <code>fn($x, $y, $z) { my:func($x, $y, $z) }</code>,
            except that the returned function has a name (it retains the name <code>my:func</code>).</p></note>

         </div4>

         <div4 id="id-inline-func">
            <head>Inline Function Expressions</head>
            
            <changes>
               <change issue="1192" PR="1197" date="2024-05-21">
                  In inline function expressions, the keyword <code>function</code> may be abbreviated
                  as <code>fn</code>.
               </change>
               <change issue="503" PR="521" date="2023-05-30">New abbreviated syntax is introduced 
                     (<termref def="dt-focus-function"/>) 
                     for simple inline functions taking a single argument. 
                     An example is <code>fn { ../@code }</code>
               </change>
            </changes>

            <scrap>
               <prodrecap ref="InlineFunctionExpr"/>
            </scrap>


            <p>
               <termdef term="inline function expression" id="dt-inline-func">An 
                  <term>inline function expression</term><phrase diff="add" at="2023-03-111">, when evaluated,</phrase> creates
          an <termref def="dt-anonymous-function">anonymous function</termref>
          defined directly in the inline function expression.</termdef> 
               An inline function expression specifies the names and SequenceTypes of the parameters to the function,
          the SequenceType of the result, and the body of the function.</p>
            <p diff="add" at="2023-05-25">An <termref def="dt-inline-func"/> whose 
               <nt def="FunctionSignature">FunctionSignature</nt> is omitted
               is known as a <termref def="dt-focus-function"/>. Focus functions are 
               described in <specref ref="id-focus-functions"/>.</p>
            <p><termdef
                  id="dt-anonymous-function" term="anonymous function">
             An <term>anonymous function</term> is a <termref def="dt-function-item"/> with no name.  
             Anonymous functions may be created, for example, by evaluating an inline function 
             expression or by partial function application.</termdef>
            </p>
            
            <p diff="add" at="2023-07-04">The keywords <code>function</code> and <code>fn</code> 
               are synonymous.</p>


   

               <p>The syntax allows the names and types of the function argument to be declared, along
           with the type of the result:</p>

               <eg>function($x as xs:integer, $y as xs:integer) as xs:integer { $x + $y }</eg>

               <p>The types can be omitted<phrase diff="add" at="2023-07-04">, and the keyword can be abbreviated</phrase>:</p>

               <eg>fn($x, $y) { $x + $y }</eg>
               
               
            
 
            <p diff="add" at="A">A zero-arity function can be written as, for example, <code>fn() { current-date() }</code>.</p>


         
               <p>
          If a function parameter is declared using a name but no type, its default type is <code>item()*</code>.
                  <!--<phrase diff="add" at="A">If it is bound to the context value using the notation <code>.</code>,
                  the implicit type is <code>item()</code>.</phrase>-->
               If the result type is omitted, its default result type is <code>item()*</code>.
          </p>

               <p>
          The parameters of an inline function expression are considered to be variables whose scope is the function body. It is a static error
          <errorref
                     class="ST" code="0039"
                  /> for an inline function expression to have more than one parameter with the same name.
          </p>

               <p role="xquery"
                     >An inline function
	  expression may have
	  annotations. &language; does not define annotations that
	  apply to inline function
	  expressions, in particular it is a <termref
                     def="dt-static-error">static error</termref>
                  <errorref class="ST" code="0125"
                     /> if an inline function expression is annotated as
	  <code>%public</code> or <code>%private</code>. An
	  implementation can define annotations, in its own namespace,
	  to support functionality beyond the scope of this
	  specification.</p>

               <p>
          The static context for the function body is inherited from the location of the inline function expression, with the exception of the
          static type of the context value which is initially <xtermref
                     spec="DM40" ref="dt-absent"/>.
          </p>
         
               <p>
          The variables in scope for the function body include all variables representing the function parameters, as well as all variables that
          are in scope for the inline function expression.</p>
          
          

          <note>
                     <p>
            Function parameter names can mask variables that would otherwise be in scope for the function body.
          </p>
                  </note>
            
            

               <p>The result of an inline function expression is a single function <phrase diff="add" at="2024-01-01">item</phrase>
                  with the following properties (as defined in <xspecref
                     spec="DM40" ref="function-items"/>):</p>

          <ulist>
                     <item>
                        <p>
                           <term>name</term>:
              Absent.
            </p>
                     </item>
                     <item><p diff="add" at="2023-05-25"><term>identity</term>: A new function
                              identity distinct from the identity of any other function item.</p>
                        <note><p>See also <specref ref="id-function-identity"/>.</p></note>
                     </item>
                     <item>
                        <p>
                           <term>parameter names</term>:
              The parameter names in
              the <code>InlineFunctionExpr</code>’s
              <code>ParamList</code>.
            </p>
                     </item>
                     <item>
                        <p>
                           <term>signature</term>:
              A <code>FunctionType</code>
              constructed from the
              <phrase
                              role="xquery">
                              <code>Annotation</code>s and</phrase>
                           <code>SequenceType</code>s in the <code>InlineFunctionExpr</code>.
	      An implementation which can determine a more specific signature (for example, through use of type analysis of the function’s body) is permitted to do so.
            </p>
                     </item>
                     <item>
                        <p>
                           <term>body</term>:
              The <code>InlineFunctionExpr</code>’s <code>FunctionBody</code>.
            </p>
                     </item>
                     <item>
                        <p diff="chg" at="2023-03-11">
                           <term>captured context</term>: the static context
                           is the static context of the inline function expression,
                           with the exception of the static context value type which is
                           <xtermref spec="DM40" ref="dt-absent"/>. The dynamic context has an absent
                           <termref def="dt-focus"/>, and a set of variable bindings
                           comprising the <termref def="dt-variable-values"
                              >variable values</termref> component
                           of the dynamic context of the <code>InlineFunctionExpr</code>.
            </p>
                     </item>
                  </ulist>
              
         
               <p>The following are examples of some inline function expressions:</p>

               <ulist>
                  <item>
                     <p>This example creates a function that takes no arguments and returns a sequence of the first 6 primes:
                <eg
                           role="parse-test"
                           ><![CDATA[function() as xs:integer+ { 2, 3, 5, 7, 11, 13 }]]></eg>
                     </p>
                  </item>
                  <item>
                     <p>This example creates a function that takes two <code>xs:double</code> arguments and returns their product:
                <eg
                           role="parse-test"
                           ><![CDATA[fn($a as xs:double, $b as xs:double) as xs:double { $a * $b }]]></eg>
                     </p>
                  </item>
                  <item>
                     <p>This example creates and invokes a function that captures the value of a local variable in its scope:
                        <eg role="parse-test"
                           ><![CDATA[let $incrementors := (
  for $x in 1 to 10
  return function($y) as xs:integer { $x + $y }
)
return $incrementors[2](4)]]></eg>
                     </p>
                     <p>The result of this expression is <code>6</code></p>
                  </item>
               </ulist>    
         
         </div4>
            <div4 id="id-focus-functions" diff="add" at="2023-05-25">
               <head>Focus Functions</head>
               <p><termdef id="dt-focus-function" term="focus function">A <term>focus function</term>
               is an inline function expression in which the function signature is implicit: the function takes
               a single argument of type <code>item()*</code> (that is, any value), and binds this to the 
                  context value when evaluating
               the function body, which returns a result of type <code>item()*</code>.</termdef></p>
               <p>Here are some examples of focus functions:</p>
               <ulist>
                  <item><p><code>fn { @age }</code> - a function that expects a node as its argument, and returns
                  the <code>@age</code> attribute of that node.</p></item>
                  <item><p><code>fn { . + 1 }</code> - a function that expects a number as its argument, and returns
                  that number plus one.</p></item>
                  <item><p><code>function { `${ . }` }</code> - a function that expects a string as its argument, and prepends
                     a <code>"$"</code> character.</p></item>
                  <item><p><code>function { head(.) + foot(.) }</code> - a function that expects a sequence of numbers
                     as its argument, and returns the sum of the first and last items in the sequence.</p></item>
               </ulist>
               <p>Focus functions are often useful as arguments to simple higher-order functions such as <function>fn:sort</function>.
               For example, to sort employees by salary, write <code>sort(//employee, (), fn { +@salary })</code>.
               (The unary plus has the effect of converting the attribute’s value to a number, for numeric sorting).</p>
               <p>Focus functions can also be useful on the right-hand side of the <termref def="dt-sequence-arrow-operator"/>
                  and <termref def="dt-mapping-arrow-operator"/>.
               For example, <code>$s => tokenize() =!> fn { `"{.}"` }()</code> first tokenizes the string <code>$s</code>,
               then wraps each token in double quotation marks.</p>
               <p>The result of calling the <code>function { EXPR }</code> (or <code>fn { EXPR }</code>), with
                  a single argument whose value is <var>$Z</var> arguments, is obtained by evaluating <code>EXPR</code>
                  with a <termref def="dt-fixed-focus"/> in which the context value is <var>$Z</var>, the context position is 1 (one),
                  and the context size is 1 (one).</p>
               
               <p>The expression <code>function { EXPR }</code> is thus formally equivalent to the expression
               <code>function($Z as item()*) as item()* { $Z -> (EXPR) }</code>, where <code>$Z</code> is some variable name
               that is otherwise unused. Here <code>-></code> is the pipeline operator described
               in <specref ref="id-pipeline-operator"/>.</p>
               
               <p>For example, the expression <code>every(1 to 10, fn { . gt 0 })</code> returns <code>true</code>.</p>
               
            </div4>
            
         
            
            <div4 id="id-function-identity" diff="add" at="2023-05-25">
               <head>Function Identity</head>
               <p>It is sometimes useful to be able to establish whether two variables refer to the same function
               or to different functions. For this purpose, every function item has an identity. Functions with the
               same identity are indistinguishable in every way; in particular, any function call with identical
               arguments will produce an identical result.</p>
               <p>In general, evaluation of an expression that returns a function item other than one that was
               present in its operands delivers a function item whose identity is unique, and thus distinct
               from any other function item. There are two exceptions to this rule:</p>
               
               <ulist>
                  <item><p>Evaluating a function reference such as <code>count#1</code> returns the same function
                  every time. Specifically, if the function name identifies a <termref def="dt-function-definition"/>
                  that is not <termref def="dt-context-dependent"/> (which is the most usual case), then all 
                     function references using this function name and arity return the same function.
                  For more details see <specref ref="id-named-function-ref"/>.</p>
                  </item>
                  <item><p>An optimizer is permitted to rewrite <xtermref spec="FO40" ref="dt-deterministic"/>
                     expressions in such a way that repeated evaluation is avoided, and this may be
                     done without consideration of function identity. For example:</p>
                     <ulist>
                        <item><p>If the expression
                           <code>contains(?, "e")</code> appears within the body of a <code>for</code>
                           clause, or if the same expression is written repeatedly in a query, then an
                           optimizer may decide to evaluate it once only, and thus return the same function
                           item each time.</p></item>
                        <item><p>Similarly, if the expression <code>fn($x) { $x + 1 }</code>
                           appears more than once, or is evaluated repeatedly, then it may return the same
                           function each time.</p></item>
                        <item><p>Optimizers are allowed to replace any expression with an
                           equivalent expression. For example, <code>count(?)</code> may be rewritten as
                           <code>count#1</code>. Similarly, <code>fn($x) { $x + 1 }</code> may be
                           rewritten as <code>fn($y) { $y + 1 }</code>. This may lead to different
                           expressions returning identical function items.</p></item>
                        <item><p>In principle, two function items are not identical if they
                           differ in their captured context. Optimizers, however, will often
                           be able to eliminate parts of the captured context that a function does
                           not actually use. For example, an inline function expression delivers
                           a function item whose captured context includes the values of all nonlocal
                           in-scope variables; but in practice the implementation is unlikely to retain the
                           values of such variables unless they are actually referenced.
                        </p></item>
                     </ulist>
                  </item>
               </ulist>
            </div4>
         </div3>
         
         <!--<div3 id="id-variadic-functions-overview">
            <head>Variadic Functions</head>
            
            <changes>
               <change PR="1137" issue="161" date="2024-04-23">
                  Functions may be declared to be variadic.
               </change>
            </changes>
            
            <p>This section summarizes the way <termref def="dt-variadic"/> 
               functions work in &language;. The detailed
            rules are distributed around the relevant sections of the specification, but this section
            attempts to provide an overview in one place for convenience.</p>
            
            <p>A <termref def="dt-function-definition"/> can be declared to be 
               <termref def="dt-variadic"/>. Specifically:</p>
            
            <ulist>
               <item><p>Some <termref def="dt-system-function">system functions</termref>
               such as <function>fn:concat</function> and <function>fn:codepoints-to-string</function>
               are defined to be variadic.</p></item>
               <item><p>User-written functions defined in XQuery can be defined as variadic by
               use of the annotation <code>%variadic</code> on the function declaration.</p></item>
               <item><p>User written functions defined in XSLT can be defined as variadic
               by adding the attribute <code>variadic="yes"</code> to the <code>xsl:function</code>
               declaration.</p></item>
            </ulist>
            
            <p>In many cases a variadic function definition will declare a single parameter,
            which will normally have a required type whose occurrence indicator is <code>+</code>
               or <code>*</code>. The parameter has an implicit default of <code>()</code>,
               but this is only useful if the occurrence indicator is <code>*</code>
               or <code>?</code>; in other cases omitting the relevant argument and invoking
               the default will lead inevitably to a type error. </p>
            
            <p>It is also possible to define other parameters before the final variadic parameter.
            If present these must be required parameters.</p>
            
            <p>In static function calls the effect of defining a function as variadic is that
            the value for the (single or final) parameter can be spread across multiple arguments
            rather than being supplied as a single argument. For example a sequence
            of strings can be supplied to the <function>fn:concat</function> function either as
            a single argument: <code>concat(("a", "b", "c"))</code> or as a series of separate
            arguments: <code>concat("a", "b", "c")</code>. It is also possible to mix
            the two approaches: the call <code>concat("a", (), ("b", "c"))</code> has
            the same effect.</p>
            
            <p>The argument sequence can also be supplied with a keyword 
               (<code>concat(values := ("a", "b", "c"))</code>) but in that case it
            must be supplied as a single argument.</p>
            
            <p>Type checking (using the <termref def="dt-coercion-rules"/>) is applied
            to the argument value after it has been fully assembled. So, for example,
            if the declared type in the function definition is <code>xs:string+</code>,
            then any of the individual arguments may be an empty sequence, but the assembled
            result must be non-empty.</p>
            
            <p>Function items may be constructed from a variadic function definition
            in two ways, as usual: either by using a named function reference, or by
            partial function application. The resulting function items are not themselves
            variadic: a function item always has a fixed arity and must be called with the
            correct number of arguments.</p>
            
            <p>So, for example, <function>fn:concat#3</function> creates a function item with
            arity 3, which must always be called with three arguments. The required type
            for each of these arguments is the same as the required type declared on the
            final parameter in the function definition, which in this case is
            <code>xs:anyAtomicType*</code>. This means that a call such as
               <code>fn:concat#3(("a", "b"), (), ("c", "d"))</code> is permitted.</p>
            
            <p>Similarly, the partial function application <code>fn:concat("[", ?, "]")</code>
            returns a function item with arity one, with the required type of the single
            parameter being <code>xs:anyAtomicType*</code>. This function is equivalent
               to the anonymous function <code>fn($x) { fn:concat("[", $x, "]") }</code>.
            The semantics of partial function application are equivalent to first evaluating
            a named function reference with appropriate arity (in this case <function>fn:concat#3</function>)
            and then performing a dynamic partial application of the resulting function item.</p>
            
            <example id="example-variadic-function">
               <head>A Variadic Function</head>
               <p>The following function, declared in XQuery syntax, 
                  computes the product of a sequence of numbers
                  (it might be useful in calculating compound interest).</p>
               <eg><![CDATA[declare %variadic function m:product as xs:double (
       $input as xs:double*) {
   if (empty($input)) then 1 else head($input) * m:product(tail($input))
};]]></eg>
               <p>The function might be called supplying a single sequence-valued argument:</p>
               <eg>m:product(for $year in 2000 to 2024 return $inflation?$year)</eg>
               <p>Alternatively it might be called with multiple arguments:</p>
               <eg>m:product(1.05, 1.04, 1.02, 1.06)</eg>
            </example>
            
            
            
            
         </div3>-->
 
      </div2>
      


      <div2 id="id-path-expressions">
         <head>Path Expressions</head>

         <scrap>
            <prodrecap ref="PathExpr"/>
         </scrap>
         <p>
            <termdef id="dt-path-expression" term="path expression"
                  >A path expression consists of a series of one or more
	              <termref def="dt-step"
                  >steps</termref>, separated by <code>/</code> or
	 <code>//</code>, and optionally beginning with
               <code>/</code> or <code>//</code>.  
               A <term>path expression</term> is typically used to locate nodes
               within trees. </termdef></p>
         
         <p>Absolute path expressions (those starting with an initial <code>/</code>
            or <code>//</code>), start their selection from the root node of a tree;
            relative path expressions (those without a leading <code>/</code> or
            <code>//</code>) start from the <termref def="dt-context-value"/>.</p>
         
         <p>A path expression consisting of a single step is evaluated as
            described in <specref ref="id-steps"/>.</p>
         
         <div3 id="id-absolute-path-expressions">
            <head>Absolute Path Expressions</head>
       
            
         <p>A path expression consisting of <code>/</code> on its own
            is treated as an abbreviation for <code>/.</code>.</p>
         
         
         <p>An expression of the form <code>/<var>PP</var></code> (that is, a path expression
            with a leading <code>/</code>) is treated as an abbreviation for
	 the expression <code>self::node()/(fn:root(.) treat as document-node())/<var>PP</var></code>. 
            The effect of this expansion is that for every item <var>J</var> 
            in the context value <var>V</var>:</p>
	 
	 <olist>
	    <item><p>A <termref def="dt-type-error"/> occurs if <var>J</var> is not a node
	       <errorref class="TY" code="0020"/>.</p></item>
	    <item><p>The root node <var>R</var> of the tree containing <var>J</var> is selected.</p></item>
	    <item><p>A <termref def="dt-dynamic-error"/> occurs if <var>R</var> is not a document node
	       <errorref class="DY" code="0050"/>.</p></item>
	    <item><p>The expression that follows the leading <code>/</code> is evaluated with 
	       <var>R</var> as the context value.</p></item>
	 </olist>
         
    <p>The results of these multiple evaluations are then combined into a single sequence;
       if the result is a set of nodes, the nodes are delivered in document order with
       duplicates eliminated.</p>
            
            <note>
               <p id="Chg-slash-note"
                     >The <code>/</code> character
	 can be used either as a complete path expression or as the
	 beginning of a longer path expression such as
	 <code>/*</code>.  Also, <code
                     role="parse-test"
                     >*</code>
	 is both the multiply operator and a wildcard in path
	 expressions.  This can cause parsing difficulties when
	 <code>/</code> appears on the left-hand side of
	 <code>*</code>.  This is resolved using the <loc
                     href="#parse-note-leading-lone-slash"
                     >leading-lone-slash
	 </loc> constraint.  For example, <code role="parse-test"
                     >/*</code> and <code role="parse-test"
                     >/
	 *</code> are valid path expressions containing wildcards,
	 but <code>/*5</code> and <code>/ * 5</code> raise syntax
	 errors. Parentheses must be used when <code>/</code> is
	 used on the left-hand side of an operator that could be confused with a node test, as in <code
                     role="parse-test"
                     >(/) * 5</code>. Similarly, <code>4 + / *
	 5</code> raises a syntax error, but <code
                     role="parse-test"
                     >4 + (/) * 5</code> is a valid expression.
	 The expression <code
                     role="parse-test"
                  >4 + /</code> is also
	 valid, because <code>/</code> does not occur on the left-hand
	 side of the operator.</p>

               <p>Similarly, in the expression <code role="parse-test"
                     >/
	 union /*</code>, <code>union</code> is interpreted as an element name
	 rather than an operator. For it to be parsed as an operator,
	 the expression should be written <code
                     role="parse-test">(/)
	 union /*</code>.</p>

            </note>

       

         <p>An expression of the form <code>//<var>PP</var></code> (that is, a path expression
            with a leading <code>//</code>) is treated as an abbreviation for
            the expression <code>self::node()/(fn:root(.) treat as document-node())/descendant-or-self:node()/<var>PP</var></code>. 
            The effect of this expansion is that for every item <var>J</var> 
            in the context value <var>V</var>:</p>


         
         <olist>
            <item><p>A <termref def="dt-type-error"/> occurs if <var>J</var> is not a node
               <errorref class="TY" code="0020"/>.</p></item>
            <item><p>The root node <var>R</var> of the tree containing <var>J</var> is selected.</p></item>
            <item><p>A <termref def="dt-dynamic-error"/> occurs if <var>R</var> is not a document node
               <errorref class="DY" code="0050"/>.</p></item>
            <item><p>The descendants of <var>R</var> are selected, along with <var>R</var> itself.</p></item>
            <item><p>For every node <var>D</var> in this set of nodes, the expression that 
               follows the leading <code>//</code> is evaluated with <var>D</var> as the context value.</p></item>
         </olist>
         
         <p>The results of these multiple evaluations are then combined into a single sequence;
            if the result is a set of nodes, the nodes are delivered in document order with
            duplicates eliminated.</p>
         
         <p>If the context value is not a node, a
	 <termref
               def="dt-type-error">type error</termref> is
	 raised <errorref class="TY" code="0020"
               />. At evaluation time, if the
	 root node of the context node is not a document node, a
	 <termref
               def="dt-dynamic-error">dynamic error</termref> is
	 raised <errorref class="DY"
               code="0050"/>.</p>

         <note>
            <p>The descendants of a node do not include attribute
	 nodes<phrase role="xpath"
                  > or namespace nodes</phrase>. However, the rules for expanding <code>//</code>
            ensure that <code>.//@*</code> selects all attributes of all descendants<phrase role="xpath">,
            and similarly <code>.//namespace::*</code> selects all namespaces of all descendants.</phrase></p>
         </note>
         
         <note>
            <p><code>//</code> on its own is not a valid expression.</p>
         </note>


         </div3>

         <div3 id="id-relative-path-expressions">
            <head>Relative Path Expressions</head>

            <scrap>
               <prodrecap ref="RelativePathExpr"/>
            </scrap>

            <p>
          A relative path expression is a path expression that selects
          nodes within a tree by following a series of steps starting
          at the nodes in the context value (which may be any kind of node,
          not necessarily the root of the tree).
          </p>
            <p>
          Each non-initial occurrence of <code>//</code> in a path expression is
          expanded as described in <specref ref="abbrev"/>, leaving a
          sequence of steps separated by <code>/</code>. This sequence of steps
          is then evaluated from left to right. So a path such as
          <code><var>E1</var>/<var>E2</var>/<var>E3</var>/<var>E4</var></code> is evaluated
          as <code>((<var>E1</var>/<var>E2</var>)/<var>E3</var>)/<var>E4</var></code>. 
               The semantics of a path
          expression are thus defined by the semantics of the
          binary <code>/</code> operator, which is defined in
          <specref ref="id-path-operator"/>.
          </p>

            <note>
               <p>
         Although the semantics describe the evaluation of a path with
         more than two steps as proceeding from left to right, the <code>/</code>
         operator is in most cases associative, so evaluation from
         right to left usually delivers the same result. The cases
         where <code>/</code> is not associative arise when the functions
         <code>fn:position()</code> and <code>fn:last()</code> are
         used: <code>A/B/position()</code> delivers a sequence of
         integers from 1 to the size of <code>(A/B)</code>, whereas
         <code>A/(B/position())</code> restarts the counting at each <code>B</code> element.
         </p>
            </note>

            <p>The following example illustrates the use of relative path expressions.
            In each case it is assumed that the context value is a single node,
            referred to as the context node.</p>

            <example>
               <ulist>
                  <item>
                     <p>
                        <code role="parse-test">child::div1/child::para</code>
                     </p>
                     <p>Selects the
	     <code>para</code> element children of the <code>div1</code>
	     element children of the context node; that is, the
	     <code>para</code> element grandchildren of the context node
	     that have <code>div1</code> parents.</p>
                  </item>
               </ulist>
            </example>



            <note>
               <p>Since each step in a path provides context nodes for the following step, 
                  in effect, only the last step in a path is allowed to return a sequence of non-nodes.</p>
            </note>


            
         </div3>
            <div3 id="id-path-operator">
               <head>Path operator (<code>/</code>)</head>

               <p>The path operator <code>/</code> is primarily used for 
                  locating nodes within trees. Its left-hand operand must return 
                  a sequence of nodes. The result of the operator is either a sequence of nodes
                  (in document order, with no duplicates), or a sequence of non-nodes.</p>

               <p>The operation <code><var>E1</var>/<var>E2</var></code> is evaluated as follows: Expression <var>E1</var> 
                  is evaluated, and if the result is not a (possibly empty) sequence <var>S</var> of nodes, 
                  a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY"
                     code="0019"
                     />. Each node in <var>S</var> then serves in turn to provide an inner focus 
                  (the node as the context value, its position in <var>S</var> as the context 
                  position, the length of <code>S</code> as the context size) for an evaluation 
                  of <var>E2</var>, as described in  <specref
                     ref="eval_context"
                     />. The sequences resulting from all the evaluations of <var>E2</var> 
                  are combined as follows:</p>


               <olist>
                  <item>
                     <p>If every evaluation of <var>E2</var> returns a (possibly empty) sequence of nodes, 
                        these sequences are combined, and duplicate nodes are eliminated based on node identity.
                        The resulting node sequence is returned in <termref
                              def="dt-document-order">document order</termref>.
                     </p>
                  </item>

                  <item>

                     <p>If every evaluation of <var>E2</var> returns a (possibly empty) 
                        sequence of non-nodes, these sequences are concatenated, in order, and returned.
                        The returned sequence preserves the orderings within and among the subsequences 
                        generated by the evaluations of <var>E2</var>.
                     </p>
                  </item>

                  <item>
                     <p>If the multiple evaluations of <var>E2</var> return at least one node and at least one non-node, a <termref
                           def="dt-type-error">type error</termref> is raised <errorref class="TY"
                           code="0018"/>.</p>
                  </item>
               </olist>

               <note>
                  <p>The semantics of the path operator can also be defined using the simple 
                     map operator (<code>!</code>) as follows (the function
                     <code>fn:distinct-ordered-nodes($R)</code> has the effect of 
                     eliminating duplicates and sorting nodes into document order):</p>
                  <eg><![CDATA[let $R := E1 ! E2
return if (every $r in $R satisfies $r instance of node())
       then (fn:distinct-ordered-nodes($R))
       else if (every $r in $R satisfies not($r instance of node()))
       then $R
       else error()]]></eg>
                  <p>For a table comparing the step operator to the map operator, see <specref ref="id-map-operator"/>.</p>
               </note>
    

         </div3>



         <div3 id="id-steps">
            <head>Steps</head>
            <scrap>
               <head/>
               <prodrecap ref="StepExpr"/>
            </scrap>
            <p>
               <termdef term="step" id="dt-step">A <term>step</term> is a part of a <termref
                     def="dt-path-expression"
                     >path expression</termref> that generates a sequence of items
		and then filters the sequence by zero or more
		<termref
                     def="dt-predicate"
                     >predicates</termref>. The value of the step
		consists of those items that satisfy the
		predicates, working from left to right. A step may be either an <termref
                     def="dt-axis-step"
                  >axis step</termref> or a postfix expression.</termdef> Postfix expressions are described in <specref
                  ref="id-postfix-expression"/>.</p>
            <p>
               <termdef term="axis step" id="dt-axis-step"
                     >An <term>axis step</term> returns a sequence of nodes that are 
                  reachable from a starting node via a specified axis. Such a step has two parts: an
		<term>axis</term>, which defines the "direction of
		movement" for the step, and a <termref
                     def="dt-node-test"
                     >node test</termref>,
		which selects nodes based on their kind, name, and/or
		<termref def="dt-type-annotation">type annotation</termref> .</termdef></p> 
            
            <p>If the context value is a 
               sequence of zero or more nodes, an axis
		step returns a sequence of zero or more
		nodes; otherwise, a <termref def="dt-type-error">type error</termref> is
		raised <errorref class="TY" code="0020"/>.</p>
            
            <p>The step expression <code>S</code> is equivalent to <code>./S</code>.
               Thus, if the context value is a sequence containing multiple nodes,
               the semantics of a step expression are equivalent to a path expression
               in which the step is always applied to a single node. The following
               description therefore explains the semantics for the case where
               the context value is a single node, called the context node.</p>
            
            
            <note><p>The equivalence of a step <code>S</code> to the
            path expression <code>./S</code> means that 
            the resulting node sequence is returned in <termref def="dt-document-order">document
	         order</termref>.</p></note> 
            
            <p>An axis step may be either a <term>forward
		step</term> or a <term>reverse step</term>, followed
		by zero or more <termref def="dt-predicate">predicates</termref>.</p>

            <p>In the <term>abbreviated syntax</term> for a step, the axis can
		be omitted and other shorthand notations can be used as described in
		<specref
                  ref="abbrev"/>.</p>
            <p>The unabbreviated syntax for an axis step consists of the axis name
		and node test separated by a double colon. The result of the step consists of the nodes
		reachable from the starting node via the specified axis that have the node kind, name,
		and/or <termref
                  def="dt-type-annotation"
                  >type annotation</termref> specified by the node test. For example, the
		step <code
                  role="parse-test"
                  >child::para</code> selects the <code>para</code> element children of the context node: <code>child</code> is the name of the axis, and <code>para</code> is the name of the element nodes to be selected on this axis. The available axes are described in <specref
                  ref="axes"/>. The
		available node tests are described in <specref
                  ref="node-tests"/>. Examples of
		steps are provided in <specref ref="unabbrev"
                  /> and <specref ref="abbrev"/>.</p>
            
            <div4 id="axes">
               <head>Axes</head>
               <changes>
                  <change issue="1519">
                     Four new axes have been defined: <code>preceding-or-self</code>, <code>preceding-sibling-or-self</code>,
                     <code>following-or-self</code>, and <code>following-sibling-or-self</code>.
                  </change>
               </changes>
               
               <scrap>
                  <prodrecap ref="ForwardAxis"/>
                  <prodrecap ref="ReverseAxis"/>
               </scrap>




               <p role="xpath"
                     >XPath defines a set of <term>axes</term>
		  for traversing documents, but a <term>host language</term> may define a subset
		  of these axes. The following axes are defined:</p>

               <p role="xquery"
                  >XQuery supports the following axes<!-- <phrase diff="del"/>
		  (subject to limitations as described in <specref ref="id-full-axis-feature"/>)-->:</p>


               <ulist>
                 

                  <item>

                     <p>The <code>child</code> axis
				contains the children of the context
				node, which are the nodes returned by the
				<xspecref
                           spec="DM40" ref="dm-children"/>.
                                </p>


                     <note>

                        <p>Only document nodes and element
                                                  nodes have
                                                  children. If the
                                                  context node is any
                                                  other kind of node,
                                                  or if the context
                                                  node is an empty
                                                  document or element
                                                  node, then the child
                                                  axis is an empty
                                                  sequence.  The
                                                  children of a
                                                  document node or
                                                  element node may be
                                                  element, processing
                                                  instruction,
                                                  comment, or text
                                                  nodes.  Attribute<phrase
                              role="xpath"
                              >,
                                                  namespace,</phrase> and
                                                  document nodes can
                                                  never appear as
                                                  children.</p>
                     </note>
                                      
                  </item>

                  <item>
                     <p>The <code>descendant</code>
			 axis is defined as the transitive closure of
			 the child axis; it contains the descendants
			 of the context node (the children, the children of the children, and so on).</p>
                     <p>More formally, <code>$node/descendant::node()</code> delivers the result
                     of <code>fn:transitive-closure($node, fn { child::node() })</code>.</p>
                  </item>
                  
                  <item>
                     <p>The <code>descendant-or-self</code> axis contains the context node and the descendants of the context
				node.</p>
                     <p>More formally, <code>$node/descendant-or-self::node()</code> delivers the result
                     of <code>$node/(. | descendant::node())</code>.</p>
                  </item>



                  <item>

                     <p>The <code>parent</code>
                                          axis contains the sequence
                                          returned by the
				          <xspecref
                           spec="DM40" ref="dm-parent"
                        />, 
                                          which returns
                                          the parent of the context
                                          node, or an empty sequence
                                          if the context node has no
                                          parent.</p>

                     <note>
                        <p>An attribute node may have an element node as its parent, even though the attribute node is not a child of the element node.</p>
                     </note>
                  </item>



                  <item>
                     <p>The
                                        <code>ancestor</code> axis is
                                        defined as the transitive
                                        closure of the parent axis; it
                                        contains the ancestors of the
                                        context node (the parent, the
                                        parent of the parent, and so
                                        on).</p>
                     
                     <p>More formally, <code>$node/ancestor::node()</code> delivers the result
                     of <code>fn:transitive-closure($node, fn { parent::node() })</code>.</p>

                     <note>
                        <p>The ancestor axis
                                        includes the root node of the
                                        tree in which the context node
                                        is found, unless the context
                                        node is the root node.</p>
                     </note>

                  </item>
                  
                  <item>
                     <p>The <code>ancestor-or-self</code> axis contains the context node and the ancestors of the context node;
				thus, the ancestor-or-self axis will always include the root node.</p>
                     
                     <p>More formally, <code>$node/ancestor-or-self::node()</code> delivers the result
                     of <code>$node/(. | ancestor::node())</code>.</p>
                  </item>



                  <item>
                     <p>The <code>following-sibling</code>
			 axis contains the context node’s following
			 siblings, that is, those children of the context
			 node’s parent that occur after the context
			 node in <termref
                           def="dt-document-order"
                           >document order</termref>. If the context node
			 is an attribute or namespace node, the
			 <code>following-sibling</code> axis is
			 empty.</p>
                     <p>More formally, <code>$node/following-sibling::node()</code> delivers the result
                     of <code>fn:siblings($node)[. >> $node])</code>.</p>
                  </item>
                  
                  <item>
                     <p>The <code>following-sibling-or-self</code> axis contains the context node,
                     together with the contents of the <code>following-sibling</code> axis.</p>
                     
                     <p>More formally, <code>$node/following-sibling-or-self::node()</code> delivers the result
                     of <code><![CDATA[fn:siblings($node)[not(. << $node)]]]></code></p>
                  </item>



                  <item>
                     <p>The <code>preceding-sibling</code>
			 axis contains the context node’s preceding
			 siblings, that is, those children of the context
			 node’s parent that occur before the context
			 node in <termref
                           def="dt-document-order"
                           >document order</termref>. If the context node
			 is an attribute or namespace node, the
			 <code>preceding-sibling</code> axis is
			 empty.</p>
                     <p>More formally, <code>$node/preceding-sibling::node()</code> delivers the result
                     of <code><![CDATA[fn:siblings($node)[. << $node]]]></code>.</p>
                  </item>
                  
                  <item>
                     <p>The <code>preceding-sibling-or-self</code> axis contains the context node,
                     together with the contents of the <code>preceding-sibling</code> axis.</p>
                     <p>More formally, <code>$node/preceding-sibling-or-self::node()</code> delivers the result
                     of <code><![CDATA[fn:siblings($node)[not(. >> $node)]]></code>.</p>
                  </item>



                  <item>

                     <p>The <code>following</code> axis
				contains all nodes that are
				descendants of the root of the tree in
				which the context node is found, are
				not descendants of the context node,
				and occur after the context node in
				<termref
                           def="dt-document-order">document order</termref>.
                     </p>
                     <p>More formally, <code>$node/following::node()</code> delivers the result
                     of <code>$node/ancestor-or-self::node()/following-sibling::node()/descendant-or-self::node()</code></p>

                  </item>

                  <item>
                     <p>The <code>following-or-self</code> axis contains the context node,
                     together with the contents of the <code>following</code> axis.</p>
                     <p>More formally, <code>$node/following-or-self::node()</code> delivers the result
                     of <code>$node/(. | following::node())</code>.</p>
                  </item>        

                  <item>

                     <p>The <code>preceding</code> axis
				contains all nodes that are
				descendants of the root of the tree in
				which the context node is found, are
				not ancestors of the context node, and
				occur before the context node in
				<termref
                           def="dt-document-order">document order</termref>.
                     </p>
                     <p>More formally, <code>$node/preceding::node()</code> delivers the result
                     of <code>$node/ancestor-or-self::node()/preceding-sibling::node()/descendant-or-self::node()</code>.</p>

                  </item>

                  <item>
                     <p>The <code>preceding-or-self</code> axis contains the context node,
                     together with the contents of the <code>preceding</code> axis.</p>
                     <p>More formally, <code>$node/preceding-or-self::node()</code> delivers the result
                     of <code>$node/(. | preceding::node())</code>.</p>
                  </item>  

                  <item>
                     <p>The <code>attribute</code> axis
			 contains the attributes of the context node,
			 which are the nodes returned by the
			 <phrase diff="chg" at="B">
			 <xspecref spec="DM40" ref="dm-attributes"/></phrase>; the axis will be
			 empty unless the context node is an
			 element.</p>

                  </item>



                  <item>
                     <p>The <code>self</code> axis contains just the context node itself.</p>
                     <p>The <code>self</code> axis is primarily useful when testing whether the context
                     node satisfies particular conditions, for example <code>if ($x[self::chapter])</code>.</p>
                     <p>More formally, <code>$node/self::node()</code> delivers the result
                     of <code>$node</code>.</p>
                  </item>


                  


                  



                  <item role="xpath">

                     <p>The <code>namespace</code> axis
				contains the namespace nodes of the
				context node, which are the nodes
				returned by the
                                <xspecref
                           spec="DM40" ref="dm-namespace-nodes"
                           />; this axis
				is empty unless the context node is an
				element node. The
				<code>namespace</code> axis is
				deprecated as of XPath 2.0. If <termref
                           def="dt-xpath-compat-mode"
                           >XPath 1.0
		compatibility mode</termref> is <code>true</code>, the <code>namespace</code> axis must be supported. If <termref
                           def="dt-xpath-compat-mode"
                           >XPath 1.0
		compatibility mode</termref> is <code>false</code>, then support for the
				<code>namespace</code> axis is
				<termref
                           def="dt-implementation-defined"
                           >implementation-defined</termref>. An implementation
				that does not support the
				<code>namespace</code> axis when <termref
                           def="dt-xpath-compat-mode"
                           >XPath 1.0
		compatibility mode</termref> is <code>false</code> must raise
				a <termref
                           def="dt-static-error">static
				error</termref>
                        <errorref class="ST" code="0010"
                           /> if it is
				used. Applications needing information
				about the <termref
                           def="dt-in-scope-namespaces"
                           >in-scope namespaces</termref> of an element
				should use the functions
				<xspecref
                           spec="FO40" ref="func-in-scope-prefixes"/>, 
				and
				<xspecref
                           spec="FO40" ref="func-namespace-uri-for-prefix"
                        />.
                                </p>

                  </item>
               </ulist>
               <p>Axes can be categorized as <term>forward axes</term> and
		  <term>reverse axes</term>. An axis that only ever contains the context node or
		  nodes that are after the context node in <termref
                     def="dt-document-order"
                     >document order</termref> is a forward axis. An
		  axis that only ever contains the context node or nodes that are before the
		  context node in <termref
                     def="dt-document-order">document order</termref> is a reverse axis.</p>
               <p>The <code>parent</code>, <code>ancestor</code>, <code>ancestor-or-self</code>, 
                  <code>preceding</code>, <code>preceding-or-self</code>, 
                  <code>preceding-sibling</code>, and <code>preceding-sibling-or-self</code> axes 
                  are reverse axes; all other axes are forward axes.</p>
               
                 <p>The <code>ancestor</code>, <code>descendant</code>, 
                  <code>following</code>, <code>preceding</code> and <code>self</code> axes partition a document (ignoring attribute <phrase
                     role="xpath"
                  >and namespace</phrase> nodes):
		  they do not overlap and together they contain all the nodes in the
		  document.</p>

               <p>
                  <termdef id="dt-principal-node-kind" term="principal node kind"
                        >Every axis has a <term>principal node kind</term>. If an axis can
		  contain elements, then the principal node kind is element; otherwise, it is the
		  kind of nodes that the axis can contain.</termdef> Thus:</p>

               <ulist>


                  <item>
                     <p>For the attribute axis, the principal node kind is
				attribute.</p>
                  </item>


                  <item role="xpath">
                     <p>For the namespace axis, the principal node kind is
				namespace.</p>
                  </item>


                  <item>
                     <p>For all other axes, the principal node kind is element.</p>
                  </item>
               </ulist>

            </div4>
            <div4 id="node-tests">
               <head>Node Tests</head>
               <changes>
                  <change issue="296" PR="1181" date="2024-04-30">
                     If the default namespace for elements and types has the special value <code>##any</code>,
                     then an unprefixed name in a <code>NameTest</code> acts as a wildcard, matching
                     names in any namespace or none.
                  </change>
               </changes>
               <p>
                  <termdef id="dt-node-test" term="node test"
                        >A <term>node test</term> is a condition on the name, kind (element, attribute, text, document, comment,
		  or processing instruction), and/or  <termref
                        def="dt-type-annotation"
                        >type annotation</termref> of a node. 
      A node test determines which nodes contained by an axis are selected by a <termref
                        def="dt-step">step</termref>.</termdef>
               </p>
               
               <scrap>
                  <prodrecap id="NodeTest" ref="NodeTest"/>
               </scrap>
               
               <p diff="add" at="2022-12-13">A <nt def="UnionNodeTest">UnionNodeTest</nt> matches a node <var>N</var>
                  if at least one of the constituent <nt def="SimpleNodeTest">SimpleNodeTest</nt>s matches <var>N</var>.</p>
               
               <p diff="add" at="2022-12-13">For example, <code>(div1|div2|div3)</code> matches a node named <code>div1</code>, <code>div2</code>, or <code>div3</code></p>

               <p>
                  <termdef id="dt-name-test" term="name test"
                        >A node test that consists only of an EQName or a
		  Wildcard is called a <term>name test</term>.</termdef> A name
                  test that consists of an EQName matches a node <var>N</var> if and only if the <term>kind</term> of
                  node <var>N</var> is the <termref
                     def="dt-principal-node-kind"
                     >principal node kind</termref> for the step axis and the
		  <termref
                     def="dt-expanded-qname"
                     >expanded QName</termref> of the node is equal (as defined by the <code>eq</code> operator) to the
		  <termref
                     def="dt-expanded-qname"
                     >expanded QName</termref> specified by the name test. For
		  example, <code
                     role="parse-test"
                     >child::para</code>
		  selects the <code>para</code> element children of
		  the context node; if the context node has no
		  <code>para</code> children, it selects an empty set
		  of nodes. <code
                     role="parse-test"
                     >attribute::abc:href</code> selects
		  the attribute of the context node with the QName
		  <code>abc:href</code>; if the context node has no
		  such attribute, it selects an empty set of
		  nodes.</p>
               <p>If the EQName is a <termref def="dt-qname"
                     >lexical QName</termref>, it is resolved into an <termref
                     def="dt-expanded-qname">expanded QName</termref> using the
		  <termref
                     def="dt-static-namespaces"
                     >statically known namespaces</termref> in the expression
		  context. It is a <termref
                     def="dt-static-error">static error</termref>
                  <errorref class="ST" code="0081"
                     /> if the QName has a prefix that does not
		  correspond to any statically known namespace.

          An unprefixed QName, when used as a
		  name test on an axis whose <termref
                     def="dt-principal-node-kind"
                     >principal node kind</termref> is <code>element</code>, is interpreted as follows:</p>
               <ulist>
                  <item><p>If the <termref def="dt-default-namespace-elements-and-types"/> is a namespace URI,
                  then the name is interpreted as having that namespace URI.</p></item>
                  <item><p>If the <termref def="dt-default-namespace-elements-and-types"/> is the
                     special value <code>"##any</code>,
                     then the name is interpreted as a wildcard that matches any element with
                     the specified local name, in any namespace or none.</p></item>
                  <item><p>If the <termref def="dt-default-namespace-elements-and-types"/> is absent,
                     then the name is interpreted as being in no namespace.</p></item>
                  
               </ulist>
               <p>A name test is not satisfied by an element node whose name does not match the <termref
                     def="dt-expanded-qname"
                     >expanded QName</termref> of the name test, even if it is in a <termref
                     def="dt-substitution-group"
                  >substitution group</termref> whose head is the named element.</p>
               <p>A node test <code>*</code> is true for any node of the
		  <termref
                     def="dt-principal-node-kind"
                     >principal node
		  kind</termref> of the step axis. For example, <code
                     role="parse-test"
                     >child::*</code> will select all element
		  children of the context node, and <code
                     role="parse-test"
                  >attribute::*</code> will select all
		  attributes of the context node.</p>

               <p>A node test can have the form
		  <code role="parse-test"
                     >NCName:*</code>. In this case, the prefix is
		  expanded in the same way as with a <termref
                     def="dt-qname">lexical QName</termref>, using the
		  <termref
                     def="dt-static-namespaces"
                     >statically known
		  namespaces</termref> in the <termref
                     def="dt-static-context"
                     >static context</termref>. If
		  the prefix is not found in the statically known namespaces,
		  a <termref
                     def="dt-static-error">static
		  error</termref> is raised <errorref class="ST"
                     code="0081"/>.
		  The node test is true for any node of the <termref
                     def="dt-principal-node-kind"
                     >principal
		  node kind</termref> of the step axis whose <termref
                     def="dt-expanded-qname"
                  >expanded QName</termref> has the namespace URI
		  to which the prefix is bound, regardless of the
		  local part of the name.</p>

               <p>A node test can contain a <nt def="BracedURILiteral">BracedURILiteral</nt>, for example
		  <code role="parse-test"
                     >Q{http://example.com/msg}*</code>. Such a node test is true for any node of the principal 
                  node kind of the step axis whose expanded QName has the namespace URI specified in 
                  the <nt def="BracedURILiteral">BracedURILiteral</nt>, regardless of the local part of the name.</p>

               <p>A node test can also
		  have the form <code role="parse-test"
                     >*:NCName</code>. In this case,
		  the node test is true for any node of the <termref
                     def="dt-principal-node-kind"
                  >principal
		  node kind</termref> of the step axis whose local name matches the given NCName,
		  regardless of its namespace or lack of a namespace.</p>
               <p>
                  <termdef term="kind test" id="dt-kind-test"
                        >An alternative
		  form of a node test called a
		  <term>kind test</term> can select nodes based
		  on their kind, name, and <termref
                        def="dt-type-annotation"
                     >type annotation</termref>.</termdef> The syntax
		  and semantics of a kind test are described in
		  <specref
                     ref="id-sequencetype-syntax"/> and <specref ref="id-sequencetype-matching"
                     />. When a kind test is used
		  in a <termref def="dt-node-test"
                     >node test</termref>, only those nodes on the designated
		  axis that match the kind test are selected. Shown
		  below are several examples of kind tests that might
		  be used in path
		  expressions:</p>
               <ulist>

                  <item>
                     <p>
                        <code role="parse-test">node()</code>
		  matches any
		  node.</p>
                  </item>

                  <item>
                     <p>
                        <code role="parse-test">text()</code> matches
		  any text
		  node.</p>
                  </item>

                  <item>
                     <p>
                        <code role="parse-test"
                        >comment()</code>
		  matches any comment
		  node.</p>
                  </item>


                  <item>
                     <p>
                        <code role="parse-test"
                        >namespace-node()</code> matches any
		  namespace node.</p>
                  </item>



                  <item>
                     <p>
                        <code role="parse-test"
                        >element()</code>
		  matches any element
		  node.</p>
                  </item>

                  <item>
                     <p>
                        <code role="parse-test"
                           >schema-element(person)</code>
		  matches any element node whose name is
		  <code>person</code> (or is in the <termref
                           def="dt-substitution-group"
                           >substitution group</termref>
		  headed by <code>person</code>), and whose type
		  annotation is the same as (or is derived from) the declared type of the <code>person</code>
		  element in the <termref
                           def="dt-is-elems">in-scope element declarations</termref>.</p>
                  </item>

                  <item>
                     <p>
                        <code role="parse-test"
                           >element(person)</code> matches any element node whose name is
		  <code>person</code>, regardless of its type annotation.</p>
                  </item>
                  
                  <item diff="add" at="Issue23">
                     <p>
                        <code role="parse-test"
                           >element(doctor|nurse)</code> matches any element node whose name is
                        <code>doctor</code> or <code>nurse</code>, regardless of its type annotation.</p>
                  </item>

                  <item>
                     <p>
                        <code role="parse-test"
                           >element(person, surgeon)</code> matches any non-nilled element node whose name
		  is <code>person</code>, and whose type
		  annotation is
		  <code>surgeon</code> or is derived from <code>surgeon</code>.</p>
                  </item>
                  
                  <item diff="add" at="Issue23">
                     <p>
                        <code role="parse-test"
                           >element(doctor|nurse, medical-staff)</code> matches any non-nilled element node whose name
                        is <code>doctor</code> or <code>nurse</code>, and whose type
                        annotation is
                        <code>medical-staff</code> or is derived from <code>medical-staff</code>.</p>
                  </item>

                  <item>
                     <p>
                        <code role="parse-test"
                           >element(*,
		  surgeon)</code> matches any non-nilled element node whose type
		  annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of
		  its
		  name.</p>
                  </item>




                  <item>
                     <p>
                        <code role="parse-test"
                        >attribute()</code> matches any
                  attribute node.</p>
                  </item>



                  <item>
                     <p>
                        <code role="parse-test"
                           >attribute(price)</code> matches
                  any attribute whose name is <code>price</code>,
                  regardless of its type annotation.</p>
                  </item>

                  <item>
                     <p>
                        <code role="parse-test"
                           >attribute(*,
                  xs:decimal)</code> matches any attribute whose type
                  annotation is <code>xs:decimal</code> (or is derived from <code>xs:decimal</code>), regardless of
                  its
                  name.</p>
                  </item>

                  <item>
                     <p>
                        <code role="parse-test"
                        >document-node()</code>
                  matches any document
                  node.</p>
                  </item>

                  <item>
                     <p>
                        <code role="parse-test"
                           >document-node(element(book))</code>
                  matches any document node whose children consist of
                  a single element node that satisfies the <termref
                           def="dt-kind-test">kind test</termref>
                        <code role="parse-test"
                        >element(book)</code>, interleaved with zero or more
                  comments and processing
                  instructions, and no text nodes.</p>
                  </item>
                  <item><p><code>document-node(book)</code> is an abbreviation
                  for <code>document-node(element(book))</code>.</p></item>

               </ulist>
            </div4>
            <div4 id="implausible-axis-steps" diff="add" at="Issue602">
               <head>Implausible Axis Steps</head>
               <changes>
                  <change issue="602" PR="603" date="2023-07-25">
                     The rules for reporting type errors during static analysis have been changed
                     so that a processor has more freedom to report errors in respect of constructs that
                     are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation
                     is defined to return an empty sequence rather than an error.
                  </change>
               </changes>
               <p>Certain axis steps, given an inferred type for the context value, are
               classified as <termref def="dt-implausible"/>. During the static analysis
               phase, a processor <rfc2119>may</rfc2119> (subject to the rules in
               <specref ref="id-implausible-expressions"/>) report a static error
               when such axis steps are encountered: <errorref class="TY" code="0144"/>.</p>
               <p>More specifically, an axis step is classified as <termref def="dt-implausible"/>
               if any of the following conditions applies:</p>
               <olist>
                  <item><p>The inferred item type of the context value is a node kind for which the
                     specified axis is always empty: for example, the inferred item type
                     of the context value is <code>attribute()</code> 
                     and the axis is <code>child</code>.</p></item>
                  <item><p>The node test exclusively selects node kinds that cannot appear
                  on the specified axis: for example, the axis is <code>child</code>
                  and the node test is <code>document-node()</code>.</p></item>
                  <item><p>In a schema-aware environment, when using the <code>child</code>,
                     <code>descendant</code>, <code>descendant-or-self</code>, or <code>attribute</code>
                     axes, the inferred item type of the
                     context value has a content type that does not allow any node matching
                  the node test to be present on the relevant axis. For example, if the inferred
                  item type of the context value 
                  is <code>schema-element(list)</code> and the relevant element declaration 
                     (taking into account substitution group membership and wildcards) 
                     only allows <code>item</code> children,
                  the axis step <code>child::li</code> will never select anything and is therefore
                  classified as <termref def="dt-implausible"/>.</p></item>
               </olist>
               
               <p>Examples of implausible axis steps include the following:</p>
               
               <ulist>
                  <item><p><code>@code/text()</code>: attributes cannot have text node children.</p></item>
                  <item><p><code>/@code</code>: document nodes cannot have attributes.</p></item>
                  <item><p><code>ancestor::text()</code>: the ancestor axis never returns text nodes.</p></item>
               </ulist>
               
               <note><p>Processors may choose not to classify the expression <code>/..</code>
               as implausible, since XSLT 1.0 users were sometimes advised to use this construct
               as an explicit way of denoting the empty sequence.</p></note>
            </div4>
         </div3>

         <div3 id="id-predicate">
            <head>Predicates within Steps</head>

            <scrap>
               <prodrecap ref="AxisStep"/>
            </scrap>
            <p id="dt-predicate"
                  >A predicate within a <nt def="AxisStep"/> has similar syntax and semantics
	 to a predicate within a <termref def="dt-filter-expression"/>.  The
	 only difference is in the way the context position is set for
	 evaluation of the predicate.</p>
            
            <note>
               <p>The operator <code>[]</code> binds more tightly than <code>/</code>.
            This means that the expression <code>a/b[1]</code> is interpreted as <code>child::a/(child::b[1])</code>:
                  it selects the first <code>b</code>
            child of every <code>a</code> element, in contrast to <code>(a/b)[1]</code> which
            selects the first <code>b</code> element that is a child of some <code>a</code>
            element.</p>
               <p>A common mistake is to write <code>//a[1]</code> where <code>(//a)[1]</code>
               is intended. The first expression, <code>//a[1]</code>, selects every descendant 
                  <code>a</code> element that is the first child of its parent (it expands
                  to <code>/descendant-or-self::node()/child::a[1]</code>), whereas 
               <code>(//a)[1]</code> selects the <code>a</code> element in the document.
               </p>
            
            </note>

            <p>For the purpose of evaluating the context position within
	 a predicate, the input sequence is considered to be sorted as
	 follows: into document order if the predicate is in a
	 forward-axis step, into reverse document order if the
	 predicate is in a reverse-axis step, or in its original order
	 if the predicate is not in a step.</p>
            
            <p>More formally:</p>
            
            <ulist>
               <item><p>For a step using a forwards axis, such as <code>child::<var>test</var>[<var>P</var>]</code>,
               the result is the same as for the equivalent <termref def="dt-filter-expression"/> 
               <code>(child::<var>test</var>)[<var>P</var>]</code> (note the parentheses). The same applies if there
               are multiple predicates, for example <code>child::<var>test</var>[<var>P1</var>][<var>P2</var>][<var>P3</var>]</code>
               is equivalent to <code>(child::<var>test</var>)[<var>P1</var>][<var>P2</var>][<var>P3</var>]</code>.</p></item>
               
               <item><p>For a step using a reverse axis, such as <code>ancestor::<var>test</var>[<var>P</var>]</code>,
               the result is the same as the expression  
               <code>reverse(ancestor::<var>test</var>)[<var>P</var>] => reverse()</code>. The same applies if there
               are multiple predicates, for example <code>ancestor::<var>test</var>[<var>P1</var>][<var>P2</var>][<var>P3</var>]</code>
               is equivalent to <code>reverse(ancestor::<var>test</var>)[<var>P1</var>][<var>P2</var>][<var>P3</var>] => reverse()</code>.</p></item>
            </ulist>
            
            <note>
               <p>The result of the expression <code>preceding-sibling::*</code> is in document order, but
               <code>preceding-sibling::*[1]</code> selects the last preceding sibling element,
               that is, the one that immediately precedes the context node.</p>
               <p>Similarly, the expression <code>preceding-sibling::x[1,2,3]</code> selects the last three
               preceding siblings, returning them in document order. For example, given the input:</p>
               <eg><![CDATA[<doc><a/><b/><c/><d/><e/><f/></doc>]]></eg>
               <p>The result of <code>//e ! preceding-sibling::*[1,2,3]</code> is <code><![CDATA[<b/>, <c/>, <d/>]]></code>.
               The expression <code>//e ! preceding-sibling::*[3,2,1]</code> delivers exactly the same result.</p>
            </note>

            <p>Here are some examples of <termref def="dt-axis-step"
               >axis steps</termref> that contain predicates:</p>

            <ulist>


               <item>
                  <p>This example selects the second <code>chapter</code> element that is a child
			 of the context node:</p>
                  <eg role="parse-test"><![CDATA[child::chapter[2]]]></eg>
               </item>


               <item>
                  <p>This example selects all the descendants of the
		  context node that are elements named
		  <code>"toy"</code> and whose <code>color</code>
		  attribute has the value <code>"red"</code>:</p>
                  <eg role="parse-test"><![CDATA[descendant::toy[attribute::color = "red"]]]></eg>
               </item>


               <item>
                  <p>This example selects all the <code>employee</code> children of the context node
		that have both a <code>secretary</code> child element and an <code>assistant</code> child element:</p>
                  <eg role="parse-test"><![CDATA[child::employee[secretary][assistant]]]></eg>
               </item>
               
               <item>
                  <p>This example selects the innermost <code>div</code> ancestor of the context node:</p>
                  <eg role="parse-test"><![CDATA[ancestor::div[1]]]></eg>
               </item>
               
               <item>
                  <p>This example selects the outermost <code>div</code> ancestor of the context node:</p>
                  <eg role="parse-test"><![CDATA[ancestor::div[last()]]]></eg>
               </item>
               
               <item>
                  <p>This example selects the names of all the ancestor elements of the context node that have an
                     <code>@id</code> attribute, outermost element first:</p>
                  <eg role="parse-test"><![CDATA[ancestor::*[@id]]]></eg>
               </item>
            </ulist>






            <note>
               <p>The expression <code role="parse-test"
                     >ancestor::div[1]</code> parses as an <nt def="AxisStep"/>
                  with a reverse axis, and the position <code>1</code> therefore
                  refers to the first ancestor <code>div</code> in reverse document order,
                  that is, the innermost <code>div</code>. By
contrast, <code role="parse-test"
                     >(ancestor::div)[1]</code> parses as a <nt def="FilterExpr">FilterExpr</nt>,
                  and therefore returns the first qualifying <code>div</code>
element in the order of the <code>ancestor::div</code> expression, which is
                  in <termref def="dt-document-order"/>.</p>
               <p>The fact that a reverse-axis step assigns context positions in reverse
document order for the purpose of evaluating predicates does not alter the
fact that the final result of the step is always in document order.</p>
               
               <p diff="add" at="2022-01-17">The expression <code>ancestor::(div1|div2)[1]</code> 
               does not have the same meaning as <code>(ancestor::div1|ancestor::div2)[1]</code>. 
                  In the first expression,
               the predicate <code>[1]</code> is within a step that uses a reverse axis, so nodes are counted
               in reverse document order. In the second expression, the predicate applies to the result of
               a union expression, so nodes are counted in document order.</p>
            </note>
            
            <p>When the context value for evaluation of a step includes multiple nodes, the step is evaluated
            separately for each of those nodes, and the results are combined without reordering. This means, for example, that
            if the context value contains three <code>list</code> nodes, and each of those nodes has multiple
               <code>item</code> children, then the step <code>item[1]</code> will deliver a sequence of three <code>item</code>
               elements, namely the first <code>item</code> from each <code>list</code>, retaining the order of the
            respective <code>list</code> elements.</p>
         </div3>
         <div3 id="unabbrev">
            <head>Unabbreviated Syntax</head>
            <p>This section provides a number of examples of path expressions in which the
axis is explicitly specified in each <termref
                  def="dt-step"
                  >step</termref>. The syntax used in these examples is
called the <term>unabbreviated syntax</term>. In many common cases, it is
possible to write path expressions more concisely using an <term>abbreviated
syntax</term>, as explained in <specref
                  ref="abbrev"/>.</p>
            
            <p>These examples assume that the context value is a single node, referred to as the context node.</p>

            <ulist>


               <item>
                  <p>
                     <code role="parse-test"
                     >child::para</code> selects
the <code>para</code> element children of the context node.</p>
               </item>
               
               <item diff="add" at="2022-12-13">
                  <p>
                     <code role="parse-test"
                        >child::(para|bullet)</code> selects
                     the <code>para</code> and <code>bullet</code> element children of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                     >child::*</code> selects all element children of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                     >child::text()</code> selects all text node children of the context node.</p>
               </item>
               
               <item diff="add" at="2022-12-13">
                  <p>
                     <code role="parse-test"
                        >child::(text()|comment())</code> selects all text node and comment node children of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                     >child::node()</code> selects all the children of the context node. Note that no attribute nodes are returned, because attributes are not children.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                     >attribute::name</code> selects the <code>name</code> attribute of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                     >attribute::*</code> selects all the attributes of the context node.</p>
               </item>

               <item>
                  <p>
                     <code role="parse-test"
                     >parent::node()</code> selects the parent of the context node. If the context node is an attribute node, this expression returns the element node (if any) to which the attribute node is attached.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                     >descendant::para</code> selects the <code>para</code> element descendants of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                     >ancestor::div</code> selects all <code>div</code> ancestors of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >ancestor-or-self::div</code> selects the <code>div</code> ancestors of the context node and, if the context node is a <code>div</code> element, the context node as well.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >descendant-or-self::para</code> selects the <code>para</code> element descendants of the context node and, if the context node is a <code>para</code> element, the context node as well.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >self::para</code> selects the context node if it is a <code>para</code> element, and otherwise returns an empty sequence.</p>
               </item>
               
               <item diff="add" at="2022-12-13">
                  <p>
                     <code role="parse-test"
                        >self::(chapter|appendix)</code> selects the context node if it is a
                     <code>chapter</code> or <code>appendix</code> element, and otherwise returns an empty sequence.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >child::chapter/descendant::para</code> selects the <code>para</code> element
descendants of the <code>chapter</code> element children of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >child::*/child::para</code> selects all <code>para</code> grandchildren of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                     >/</code> selects the root of the tree that contains the context node, but raises a dynamic error if this root is not a document node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >/descendant::para</code> selects all the <code>para</code> elements in the same document as the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >/descendant::list/child::member</code> selects all
the <code>member</code> elements that have a <code>list</code> parent and that are in the same document as the context node.</p>

               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >child::para[position() = 1]</code> selects the first <code>para</code> child of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >child::para[position() = last()]</code> selects the last <code>para</code> child of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >child::para[position() = last()-1]</code> selects the last but one <code>para</code> child of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >child::para[position() &gt; 1]</code> selects all the <code>para</code> children of the context node other than the first <code>para</code> child of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >following-sibling::chapter[position() = 1]</code> selects the next <code>chapter</code> sibling of the context node.</p>
               </item>
               
               <item diff="add" at="2022-12-13">
                  <p>
                     <code role="parse-test"
                        >following-sibling::(chapter|appendix)[position() = 1]</code> selects the next sibling of the context node
                        that is either a <code>chapter</code> or an <code>appendix</code>.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >preceding-sibling::chapter[position() = 1]</code> selects the previous <code>chapter</code> sibling of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >/descendant::figure[position() = 42]</code> selects the forty-second <code>figure</code> element in the document containing the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >/child::book/child::chapter[position() = 5]/child::section[position() = 2]</code> selects the
second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >child::para[attribute::type eq "warning"]</code> selects
all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code>.
                  </p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >child::para[attribute::type eq 'warning'][position() = 5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code>.
                  </p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >child::para[position() = 5][attribute::type eq "warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code>.
                  </p>
               </item>



               <item>
                  <p>
                     <code role="parse-test"
                        >child::chapter[child::title = 'Introduction']</code> selects
the <code>chapter</code> children of the context node that have one or
more <code>title</code> children whose <termref
                        def="dt-typed-value"
                        >typed value</termref> is equal to the
string <code>Introduction</code>.
                  </p>
               </item>



               <item>
                  <p>
                     <code role="parse-test"
                        >child::chapter[child::title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >child::*[self::chapter or self::appendix]</code>
selects the <code>chapter</code> and <code>appendix</code> children of the context node.</p>
               </item>


               <item diff="chg" at="2022-12-13">
                  <p>
                     <code role="parse-test"
                        >child::*[self::(chapter|appendix)][position() = last()]</code> selects the
last <code>chapter</code> or <code>appendix</code> child of the context node.</p>
               </item>
            </ulist>
         </div3>
         <div3 id="abbrev">
            <head>Abbreviated Syntax</head>
            <scrap>
               <prodrecap id="AbbrevForwardStep" ref="AbbrevForwardStep"/>
               <prodrecap id="AbbrevReverseStep" ref="AbbrevReverseStep"/>
            </scrap>
            <p>The abbreviated syntax permits the following abbreviations:</p>


            <olist>


               <item>
                  <p>The attribute axis <code>attribute::</code> can be
    abbreviated by <code>@</code>. For example, a path expression <code
                        role="parse-test">para[@type = "warning"]</code> is short
    for <code
                        role="parse-test"
                        >child::para[attribute::type = "warning"]</code> and
    so selects <code>para</code> children with a <code>type</code> attribute with value
    equal to <code>warning</code>.</p>
               </item>

               <item>
                  <p>If the axis name is omitted from an <termref def="dt-axis-step"
                        >axis step</termref>, the default axis is
    <code>child</code>, with two exceptions:

    (1) if the <nt
                        def="NodeTest">NodeTest</nt> in an axis step contains an <nt
                        def="AttributeTest">AttributeTest</nt> or <nt def="SchemaAttributeTest"
                        >SchemaAttributeTest</nt> then the
    default axis is <code>attribute</code>;     
    (2) if the <nt
                        def="NodeTest">NodeTest</nt> in an axis step is a <nt
                        def="NamespaceNodeTest">NamespaceNodeTest</nt>
                     <phrase role="xquery">then a static error
    is raised <errorref class="ST"
                           code="0134"/>.</phrase>
                     <phrase role="xpath"
                           >then the default axis is <code>namespace</code>, but in an implementation that does not support
    the namespace axis, an error is raised <errorref
                           class="ST" code="0134"/>.</phrase>
                     <note>
                        <p> The namespace
    axis is deprecated as of XPath 2.0, but is required in some languages
    that use XPath, including XSLT.</p>
                     </note>

    For example, the path expression <code role="parse-test"
                        >section/para</code> is an abbreviation for <code role="parse-test"
                        >child::section/child::para</code>, and the path
    expression <code
                        role="parse-test">section/@id</code> is an
    abbreviation for <code
                        role="parse-test">child::section/attribute::id</code>.  Similarly,
    <code
                        role="parse-test"
                        >section/attribute(id)</code> is an
    abbreviation for <code
                        role="parse-test"
                        >child::section/attribute::attribute(id)</code>. Note
    that the latter expression contains both an axis specification and
    a <termref
                        def="dt-node-test">node test</termref>.</p>
                  <note diff="add" at="2022-12-13"><p>An abbreviated axis step that omits the axis name must use a
                  <nt def="SimpleNodeTest">SimpleNodeTest</nt> rather than a <nt def="UnionNodeTest">UnionNodeTest</nt>.
                  This means that a construct such as <code>(ul|ol)</code>
                  is treated as an abbreviation for <code>(child::ul|child::ol)</code> rather than <code>child::(ul|ol)</code>.
                  Since the two constructs have exactly the same semantics, this is not actually a restriction.</p></note>
               </item>


               <item>
                  <p> Each non-initial occurrence of <code>//</code> is effectively replaced by  <code>/descendant-or-self::node()/</code> during processing of a path expression. For example, <code
                        role="parse-test">div1//para</code> is
short for <code role="parse-test"
                        >child::div1/descendant-or-self::node()/child::para</code> and so will select all <code>para</code> descendants of <code>div1</code> children.</p>
                  <note>
                     <p>The path expression <code role="parse-test"
                           >//para[1]</code> does <emph>not</emph> mean the same as the path
expression <code
                           role="parse-test"
                           >/descendant::para[1]</code>. The latter selects the first descendant <code>para</code> element; the former
selects all descendant <code>para</code> elements that are the first <code>para</code> children of their respective parents.</p>
                  </note>
               </item>


               <item>
                  <p>A step consisting
of <code role="parse-test">..</code> is short
for <code
                        role="parse-test">parent::node()</code>. For example, <code
                        role="parse-test">../title</code> is short for <code role="parse-test"
                        >parent::node()/child::title</code> and so will select the <code>title</code> children of the parent of the context node.</p>
                  <note>
                     <p>The expression <code>.</code>, known as a <term>context value
   reference</term>, is a <termref
                           def="dt-primary-expression"
                           >primary expression</termref>,
   and is described in <specref
                           ref="id-context-value-references"/>.</p>
                  </note>
               </item>
            </olist>



            <p>Here are some examples of path expressions that use the abbreviated
syntax. These examples assume that the context value is a single node, referred to as the context node:</p>

            <ulist>


               <item>
                  <p>
                     <code>para</code> selects the <code>para</code> element children of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                     >*</code> selects all element children of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                     >text()</code> selects all text node children of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                     >@name</code> selects
the <code>name</code> attribute of the context node.</p>
               </item>
               
               <item diff="add" at="2022-12-13">
                  <p>
                     <code role="parse-test"
                        >@(id|name)</code> selects
                     the <code>id</code> and <code>name</code> attributes of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                     >@*</code> selects all the attributes of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                     >para[1]</code> selects the first <code>para</code> child of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >para[last()]</code> selects the last <code>para</code> child of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                     >*/para</code> selects
all <code>para</code> grandchildren of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >/book/chapter[5]/section[2]</code> selects the
second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >chapter//para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >//para</code> selects all
the <code>para</code> descendants of the root document node and thus selects all <code>para</code> elements in the same document as the context node.</p>
               </item>

               <item>
                  <p>
                     <code role="parse-test"
                     >//@version</code> selects all the <code>version</code> attribute nodes that are in the same document as the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >//list/member</code> selects all the <code>member</code> elements in the same document as the context node that have a <code>list</code> parent.</p>

               </item>



               <item>
                  <p>
                     <code role="parse-test"
                     >.//para</code> selects
the <code>para</code> element descendants of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test">..</code> selects the parent of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                     >../@lang</code> selects
the <code>lang</code> attribute of the parent of the context node.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >para[@type = "warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code>.
                  </p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >para[@type = "warning"][5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code>.
                  </p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >para[5][@type = "warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code>.
                  </p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >chapter[title = "Introduction"]</code> selects the <code>chapter</code> children of the context node that have one
or more <code>title</code> children whose <termref
                        def="dt-typed-value"
                        >typed value</termref> is equal to the string <code>Introduction</code>.
                  </p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >chapter[title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >employee[@secretary and @assistant]</code> selects all
the <code>employee</code> children of the context node that have both a <code>secretary</code> attribute and
an <code>assistant</code> attribute.</p>
               </item>


               <item>
                  <p>
                     <code role="parse-test"
                        >book/(chapter|appendix)/section</code> selects
every <code>section</code> element that has a parent that is either a <code>chapter</code> or an <code>appendix</code> element, that in turn is a child of a <code>book</code> element that is a child of the context node.</p>
               </item>


               <item>
                  <p>If <code>E</code> is any expression that returns a sequence of nodes, then the expression <code
                        role="parse-test">E/.</code> returns the same nodes in <termref
                        def="dt-document-order"
                     >document order</termref>, with duplicates eliminated based on node identity.</p>
               </item>
            </ulist>
         </div3>
      </div2>
      <div2 id="id-sequence-expressions">
         <head>Sequence Expressions</head>
         <p>&language; supports operators to construct, filter,  and combine
<termref
               def="dt-sequence">sequences</termref> of <termref def="dt-item"
               >items</termref>.
Sequences are never nested&mdash;for
example, combining the values <code>1</code>, <code>(2, 3)</code>, and <code>( )</code> into a single sequence results
in the sequence <code>(1, 2, 3)</code>.</p>
         <div3 id="construct_seq">
            <head>Sequence Concatenation</head>
 
            <p>
               <termdef term="comma operator" id="dt-comma-operator"
                     >One way to construct a sequence is by using the <term>comma operator</term>, 
                  which evaluates each of its operands and concatenates the resulting sequences, in order, 
                  into a single result sequence.</termdef> See <nt def="Expr"/>. 
               Empty parentheses can be used to denote an empty sequence.</p>
            <p>A sequence may contain duplicate
<termref def="dt-item"
               >items</termref>, but a sequence is never an item in another sequence. When a
new sequence is created by concatenating two or more input sequences, the new
sequence contains all the items of the input sequences and its length is the
sum of the lengths of the input sequences.</p>
            
            <p><termdef id="dt-sequence-concatenation" term="sequence concatenation">The 
               <term>sequence concatenation</term> of a number of sequences <var>S/1</var>, <var>S/2</var>, ... <var>S/n</var>
               is defined to be the sequence formed from the items of <var>S/1</var>, followed by the items
               from <var>S/2</var>, and so on, retaining order.</termdef> The comma operator returns the sequence
            concatenation of its two operands; repeated application (for example <code>$s1, $s2, $s3, $s4</code>)
            delivers the sequence concatenation of multiple sequences.</p>
            <note>
               <p>In places where the grammar calls for <nt def="ExprSingle"
                  >ExprSingle</nt>, such as the arguments of a function call, any expression that contains a top-level comma operator must be enclosed in parentheses.</p>
            </note>
            <p>Here are some examples of expressions that construct sequences:
</p>

            <ulist>


               <item>
                  <p>The result of this expression is a sequence of five integers:</p>
                  <eg role="parse-test"><![CDATA[(10, 1, 2, 3, 4)]]></eg>
               </item>


               <item>
                  <p>This expression combines four sequences of length one, two, zero, and two, respectively, into a single sequence of length five. The result of this expression is the sequence <code>10, 1, 2, 3, 4</code>.</p>
                  <eg role="parse-test"><![CDATA[(10, (1, 2), (), (3, 4))]]></eg>


               </item>


               <item>
                  <p>The result of this expression is a sequence containing
all <code>salary</code> children of the context node followed by all <code>bonus</code> children.</p>
                  <eg role="parse-test"><![CDATA[(salary, bonus)]]></eg>
               </item>


               <item>
                  <p>Assuming that <code>$price</code> is bound to
the value <code>10.50</code>, the result of this expression is the sequence <code>10.50, 10.50</code>.</p>
                  <eg role="parse-test"><![CDATA[($price, $price)]]></eg>


               </item>
            </ulist>
         </div3>
         <div3 id="id-range-expressions" diff="chg" at="A">
            <head>Range Expressions</head>
            <scrap>
               <prodrecap ref="RangeExpr"/>
            </scrap>
            <p>A <term>RangeExpression</term> can be used to construct a sequence of 
integers. Each of the operands is
converted as though it was an argument of a function with the expected
parameter type <code>xs:integer?</code>.
If either operand is an empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is an empty sequence. If the two operands convert to the same integer, the result of the range expression is that integer. Otherwise, the result is a sequence containing the two integer operands and
every integer between the two operands, in increasing order. </p>
            
            <p>The following examples illustrate the semantics:</p>

            <ulist>
               <item><p><code>1 to 4</code> returns the sequence <code>1, 2, 3, 4</code></p></item>
               <item><p><code>10 to 10</code> returns the <termref def="dt-singleton"/> sequence <code>10</code></p></item>
               <item><p><code>10 to 1</code> returns the empty sequence</p></item>
               <item><p><code>-13 to -10</code> returns the sequence <code>-13, -12, -11, -10</code></p></item>
            </ulist>
            
            <!--<p>A <term>ByExpression</term> can be used in conjunction with a <term>RangeExpression</term>
            to select some of the integers in the range, in forwards or reverse sequence. For example:</p>
            
            <ulist>
               <item><p><code>1 to 10 by 2</code> returns the sequence <code>1, 3, 5, 7, 9</code></p></item>
               <item><p><code>1 to 4 by -1</code> returns the sequence <code>4, 3, 2, 1</code></p></item>
               <item><p><code>0 to 10 by -2</code> returns the sequence <code>10, 8, 6, 4, 2, 0</code></p></item>
            </ulist>
            
            <p>Although the <code>to</code> and <code>by</code> expressions are designed to work well when
            used together, both are binary operators defined quite independently of each other, and the
            <code>by</code> operator can be applied to any sequence, not just a sequence of integers.</p>
            -->
            <p>More formally, a <term>RangeExpression</term> is evaluated as follows:</p>
            <olist>
               <item><p>Each of the operands of the <code>to</code> operator is converted as though it was an argument of a function
                  with the expected parameter type <code>xs:integer?</code>.</p></item>
               <item><p>If either operand is an empty sequence, or if the integer derived from the first operand is greater
                  than the integer derived from the second operand, the result of the range expression is an empty sequence.</p></item>
               <item><p>If the two operands convert to the same integer, the result of the range expression is that integer.</p></item>
               <item><p>Otherwise, the result is a sequence containing the two integer operands and every integer between the 
                  two operands, in increasing order.</p></item>
            </olist>
            
<!--            <p>A <term>ByExpression</term> is evaluated as follows:</p>
            <olist>
               <item><p>The left-hand operand is evaluated; the result is an arbitrary sequence: call it <code>$seq</code>.</p></item>
               <item><p>The right operand of the <code>by</code> operator is converted as though it was an argument 
                  of a function with the expected parameter type <code>xs:integer?</code>: 
                  call the result <code>$step</code>.</p></item>
               <item><p>If <code>$step</code> is an empty sequence or zero, the result of the
               <code>ByExpression</code> is an empty sequence.</p></item>
               <item><p>If <code>$step</code> is an integer greater than zero, 
                  the result consists of all items in <code>$seq</code> whose zero-based position is an integer
               multiple of <code>$seq</code>, in order. </p></item>
               <item><p>If <code>$step</code> is an integer less than zero, 
                  the result consists of all items in <code>fn:reverse($seq)</code> whose zero-based position is an integer
                  multiple of <code>fn:abs($seq)</code>, in order. </p></item>
            </olist>-->
            
            <p>The following examples illustrate the use of <code>RangeExpressions</code><!-- and
            <code>ByExpressions</code>, independently and in conjunction-->.</p>
            
            <example>
               <p>This example uses a range expression as one operand in constructing a sequence. 
                  It evaluates to the sequence <code>10, 1, 2, 3, 4</code>.</p>
               <eg role="parse-test">(10, 1 to 4)</eg>
               <p>This example selects the first four items from an input sequence:</p>
               <eg role="parse-test">$input[position() = 1 to 4]</eg>
               <!--<p>This example selects the first four items from an input sequence, in reverse order:</p>
               <eg role="parse-test">slice($input, 1 to 4 by -1)</eg>
               <p>This example returns the array <code>[ "b", "c" ]</code>:</p>
               <eg role="parse-test">array:slice([ "a", "b", "c", "d" ], 2 to 3)</eg>
               <p>This example returns the array <code>[ "d", "b" ]</code>:</p>
               <eg role="parse-test">array:slice([ "a", "b", "c", "d" ], 1 to 4 by -2)</eg>
               <p>This example tests whether <code>$x</code> is an even number in the range 100 to 200:</p>
               <eg role="parse-test">$x = (100 to 200 by 2)</eg>-->
               <p>This example returns the sequence <code>(0, 0.1, 0.2, 0.3, 0.5)</code>:</p>
               <eg role="parse-test">$x = (1 to 5)!.*0.1</eg>
               <p>This example constructs a sequence of length one containing the single integer 10.</p>
               <eg role="parse-test">10 to 10</eg>
               <p>The result of this example is a sequence of length zero.</p>
               <eg role="parse-test">15 to 10</eg>
               <p>This example uses the <function>fn:reverse</function> function to construct a sequence of six integers in decreasing order. 
                  It evaluates to the sequence 15, 14, 13, 12, 11, 10.</p>
               <eg role="parse-test">reverse(10 to 15)</eg>
            </example>
          
            <!--<note>
               <p>Since <code>10 to 1</code> returns an empty sequence, <code>10 to 1 by -1</code>
               also returns an empty sequence. The correct expression is <code>1 to 10 by -1</code>.</p>
               <p>The expression <code>1 by 2 to 10</code> means <code>1 by (2 to 10)</code> which
               fails with a type error because the second argument of <code>by</code> is not
               a singleton integer. However, <code>-200 by 2 to -100</code> returns an empty
               sequence, because <code>(2 to -100)</code> is an empty sequence. The correct expression
               is <code>-200 to -100 by 2</code>.</p>
            </note>-->
            
            <note><p>To construct a sequence of integers based on steps other than 1, use the <function>fn:slice</function>
               function, as defined in <xspecref spec="FO31" ref="general-seq-funcs"/>.</p></note>

         </div3>


         <div3 id="combining_seq">
            <head>Combining Node Sequences</head>
            <scrap>
               <prodrecap ref="UnionExpr"/>
            </scrap>
            <p>&language; provides the following operators for combining sequences of
nodes:</p>
            <ulist>

               <item>
                  <p>The <code>union</code> and <code>|</code> operators are equivalent. They take two node sequences as operands and
return a sequence containing all the nodes that occur in either of the
operands.</p>
               </item>

               <item>
                  <p>The <code>intersect</code> operator takes two node sequences as operands and returns a sequence
containing all the nodes that occur in both operands.</p>
               </item>

               <item>
                  <p>The <code>except</code> operator takes two node sequences as operands and returns a sequence
containing all the nodes that occur in the first operand but not in the second
operand.</p>
               </item>
            </ulist>
            <p>All these operators eliminate duplicate nodes from their result sequences based on node identity. 
               The resulting sequence is returned in <termref
                     def="dt-document-order">document order</termref>.
            </p>
            <p>If an operand
of <code>union</code>, <code>intersect</code>, or <code>except</code> contains an item that is not a node, a <termref
                  def="dt-type-error">type error</termref> is raised <errorref class="TY"
                  code="0004"/>.</p>

            <p>
If an <code>IntersectExceptExpr</code> contains more than two <code>InstanceofExprs,
they are grouped from left to right.</code>
With a <code>UnionExpr</code>, it makes no difference how operands are grouped,
the results are the same.
</p>
            <example>
               <p>Here are some examples of expressions that combine sequences. 
                  Assume the existence of three element nodes that we will refer to by symbolic names A, B, and C. 
                  Assume that the variables <code>$seq1</code>, <code>$seq2</code>  and <code>$seq3</code> 
                  are bound to the following sequences of these nodes:</p>
               <ulist>

                  <item>
                     <p>
                        <code>$seq1</code> is bound to (A, B)</p>
                  </item>

                  <item>
                     <p>
                        <code>$seq2</code> is bound to (A, B)</p>
                  </item>

                  <item>
                     <p>
                        <code>$seq3</code> is bound to (B, C)</p>
                  </item>
               </ulist>
               <p>Then: </p>

               <ulist>


                  <item>
                     <p>
                        <code role="parse-test"
                        >$seq1 union $seq2</code>  evaluates to the sequence (A, B). </p>
                  </item>


                  <item>
                     <p>
                        <code role="parse-test"
                        >$seq2 union $seq3</code>   evaluates to the sequence (A, B, C). </p>
                  </item>


                  <item>
                     <p>
                        <code role="parse-test"
                        >$seq1 intersect $seq2</code>  evaluates to the sequence (A, B). </p>
                  </item>


                  <item>
                     <p>
                        <code role="parse-test"
                        >$seq2 intersect $seq3</code>  evaluates to the sequence containing B only.</p>
                  </item>


                  <item>
                     <p>
                        <code role="parse-test"
                        >$seq1 except $seq2</code>   evaluates to the empty sequence.</p>
                  </item>


                  <item>
                     <p>
                        <code role="parse-test"
                        >$seq2 except $seq3</code>  evaluates to the sequence containing A only.</p>
                  </item>
               </ulist>
            </example>
            <p>In addition to the sequence operators described here, see <xspecref spec="FO40"
                  ref="sequence-functions"/> for functions defined on sequences.
</p>
         </div3>
      </div2>
      <div2 id="id-arithmetic">
         <head>Arithmetic Expressions</head>
         
         <changes>
            <change>
               The symbols <code>×</code> and <code>÷</code> can be used for multiplication and division.
            </change>
         </changes>
         <p>&language; provides arithmetic operators for addition, subtraction,
multiplication, division, and modulus, in their usual binary and unary
forms.</p>
         <scrap>
            <prodrecap ref="AdditiveExpr"/>
            <prodrecap ref="UnaryExpr"/>
         </scrap>
         <p>A subtraction operator must be preceded by whitespace if
it could otherwise be interpreted as part of the previous token. For
example, <code
               role="parse-test">a-b</code> will be interpreted as a
name, but <code
               role="parse-test">a - b</code> and <code role="parse-test"
               >a -b</code> will be interpreted as arithmetic expressions. (See <specref
               ref="whitespace-rules"/> for further details on whitespace handling.)</p>
         <p diff="add" at="2023-05-02">The arithmetic operator symbols <code>*</code> and <code>×</code> (xD7) are interchangeable,
         and denote multiplication.</p>
         <p diff="add" at="2023-05-02">The arithmetic operator symbols <code>div</code> and <code>÷</code> (xF7) are interchangeable,
            and denote division.</p>
         <p>
If an <code>AdditiveExpr</code> contains more than two <code>MultiplicativeExprs</code>,
they are grouped from left to right. So, for instance,
<eg
               role="parse-test"><![CDATA[A - B + C - D]]></eg>
is equivalent to
<eg
               role="parse-test"
            ><![CDATA[((A - B) + C) - D]]></eg>
Similarly, the operands of a <code>MultiplicativeExpr</code> are grouped from left to right.
</p>

         <p>The first step in evaluating an arithmetic expression is to evaluate its operand (for
            a unary operator) or operands (for a binary operator). 
            The order in which the operands are evaluated is <termref
               def="dt-implementation-dependent">implementation-dependent</termref>.</p>
         <p role="xpath">If <termref def="dt-xpath-compat-mode"
               >XPath 1.0 compatibility mode</termref> is <code>true</code>, each operand is evaluated by applying the following steps, in order:</p>


         <olist role="xpath">

            <item>
               <p>
                  <termref def="dt-atomization"
                     >Atomization</termref> is applied to the operand. The result of this
    operation is called the <term>atomized operand</term>.</p>

            </item>

            <item>
               <p>If the atomized operand is an empty sequence, the result of
    the arithmetic expression is the <code>xs:double</code> value <code>NaN</code>, and the implementation
    need not evaluate the other operand or apply the operator. However,
    an implementation may choose to evaluate the other operand in order
    to determine whether it raises an error.</p>
            </item>

            <item>
               <p>If the atomized operand is a sequence of length greater than one, any items after the first item in the sequence are discarded.</p>
            </item>

            <item>
               <p>If the atomized operand is now an instance of type <code>xs:boolean</code>, <code>xs:string</code>,
<code>xs:decimal</code> (including <code>xs:integer</code>), <code>xs:float</code>, or <code>xs:untypedAtomic</code>, then it
is converted to the type <code>xs:double</code> by applying the <function>fn:number</function> function. (Note that <function>fn:number</function> returns the value <code>NaN</code> if its operand cannot be converted to a number.)</p>
            </item>
         </olist>
         <p>
            <phrase role="xpath">If <termref def="dt-xpath-compat-mode"
                  >XPath 1.0 compatibility mode</termref> is <code>false</code>, each</phrase>
            <phrase role="xquery"
            >Each</phrase> operand is evaluated by applying the following steps, in order:</p>

         <olist>

            <item>
               <p>
                  <termref def="dt-atomization"
                     >Atomization</termref> is applied to the operand. The result of this
    operation is called the <term>atomized operand</term>.</p>

            </item>

            <item>
               <p>If the atomized operand is an empty sequence, the result of
    the arithmetic expression is an empty sequence, and the implementation
    need not evaluate the other operand or apply the operator. However,
    an implementation may choose to evaluate the other operand in order
    to determine whether it raises an error.</p>
            </item>

            <item>
               <p> If the atomized operand is a sequence of
length greater than one, a <termref
                     def="dt-type-error">type error</termref> is raised <errorref class="TY"
                     code="0004"/>.</p>
            </item>

            <item>
               <p>If the atomized operand is of type <code>xs:untypedAtomic</code>, it is cast to  <code>xs:double</code>. If
the cast fails, a <termref
                     def="dt-dynamic-error">dynamic
error</termref> is raised. <xerrorref
                     spec="FO40" class="RG" code="0001"/>
               </p>
            </item>
         </olist>
         
         <p>If, after this process, both operands of a binary arithmetic operator
            are instances of <code>xs:numeric</code>
         but have different primitive types, they are coerced to a common type by applying
         the following rules:</p>
         
         <olist>
            <item><p>If either of the items is of type <code>xs:double</code>, then 
            both the values are cast to type <code>xs:double</code>.</p></item>
            <item><p>Otherwise, if either of the items is of type <code>xs:float</code>, then 
              both the values are cast to type <code>xs:float</code>.</p></item>
            <item><p>Otherwise, no casting takes place: the values remain as <code>xs:decimal</code>.</p></item>
         </olist>
         
         <p>After this preparation, the arithmetic expression is evaluated by applying the appropriate
         function listed in the table below. The definitions of these functions are found in <bibref
               ref="xpath-functions-40"/>.</p>
         
         <table border="1" role="small">
<caption>Unary Arithmetic Operators</caption>
  <thead>
    <tr>
      <th>Expression</th>
      <th>Type of A</th>
      <th>Function</th>
      <th>Result type</th>
    </tr>
  </thead>
<tbody>



<tr><td>+ A</td><td>xs:numeric</td><td><function>op:numeric-unary-plus</function><code>(A)</code></td><td>xs:numeric</td></tr>

<tr><td>- A</td><td>xs:numeric</td><td><function>op:numeric-unary-minus</function><code>(A)</code></td><td>xs:numeric</td></tr>
</tbody>
</table>
         
         <table border="1" role="small">
<caption>Binary Arithmetic Operators</caption>
<tbody>

<tr>
<th>Expression</th>
<th>Type of A</th>
<th>Type of B</th>
<th>Function</th>
<th>Result type</th>
</tr>

<tr><td>A + B</td><td>xs:numeric</td><td>xs:numeric</td><td><function>op:numeric-add</function><code>(A, B)</code></td><td>xs:numeric</td></tr>

<tr><td>A + B</td><td>xs:date</td><td>xs:yearMonthDuration</td><td><function>op:add-yearMonthDuration-to-date</function><code>(A, B)</code></td><td>xs:date</td></tr>

<tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:date</td><td><function>op:add-yearMonthDuration-to-date</function><code>(B, A)</code></td><td>xs:date</td></tr>
<tr><td>A + B</td><td>xs:date</td><td>xs:dayTimeDuration</td><td><function>op:add-dayTimeDuration-to-date</function><code>(A, B)</code></td><td>xs:date</td></tr>
<tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:date</td><td><function>op:add-dayTimeDuration-to-date</function><code>(B, A)</code></td><td>xs:date</td></tr>

<tr><td>A + B</td><td>xs:time</td><td>xs:dayTimeDuration</td><td><function>op:add-dayTimeDuration-to-time</function><code>(A, B)</code></td><td>xs:time</td></tr>
<tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:time</td><td><function>op:add-dayTimeDuration-to-time</function><code>(B, A)</code></td><td>xs:time</td></tr>


<tr><td>A + B</td><td>xs:dateTime</td><td>xs:yearMonthDuration</td><td><function>op:add-yearMonthDuration-to-dateTime</function><code>(A, B)</code></td><td>xs:dateTime</td></tr>
<tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:dateTime</td><td><function>op:add-yearMonthDuration-to-dateTime</function><code>(B, A)</code></td><td>xs:dateTime</td></tr>

<tr><td>A + B</td><td>xs:dateTime</td><td>xs:dayTimeDuration</td><td><function>op:add-dayTimeDuration-to-dateTime</function><code>(A, B)</code></td><td>xs:dateTime</td></tr>
<tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:dateTime</td><td><function>op:add-dayTimeDuration-to-dateTime</function><code>(B, A)</code></td><td>xs:dateTime</td></tr>

<tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td><function>op:add-yearMonthDurations</function><code>(A, B)</code></td><td>xs:yearMonthDuration</td></tr>
<tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td><function>op:add-dayTimeDurations</function><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr>


<tr><td>A - B</td><td>xs:numeric</td><td>xs:numeric</td><td><function>op:numeric-subtract</function><code>(A, B)</code></td><td>xs:numeric</td></tr>


<tr><td>A - B</td><td>xs:date</td><td>xs:date</td><td><function>op:subtract-dates</function><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr>
<tr><td>A - B</td><td>xs:date</td><td>xs:yearMonthDuration</td><td><function>op:subtract-yearMonthDuration-from-date</function><code>(A, B)</code>
</td><td>xs:date</td></tr>
<tr><td>A - B</td><td>xs:date</td><td>xs:dayTimeDuration</td><td><function>op:subtract-dayTimeDuration-from-date</function><code>(A, B)</code></td><td>xs:date</td></tr>

<tr><td>A - B</td><td>xs:time</td><td>xs:time</td><td><function>op:subtract-times</function><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr>

<tr><td>A - B</td><td>xs:time</td><td>xs:dayTimeDuration</td><td><function>op:subtract-dayTimeDuration-from-time</function><code>(A, B)</code></td><td>xs:time</td></tr>


<tr><td>A - B</td><td>xs:dateTime</td><td>xs:dateTime</td><td><function>op:subtract-dateTimes</function><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr>
<tr><td>A - B</td><td>xs:dateTime</td><td>xs:yearMonthDuration</td><td><function>op:subtract-yearMonthDuration-from-dateTime</function><code>(A, B)</code></td><td>xs:dateTime</td></tr>
<tr><td>A - B</td><td>xs:dateTime</td><td>xs:dayTimeDuration</td><td><function>op:subtract-dayTimeDuration-from-dateTime</function><code>(A, B)</code></td><td>xs:dateTime</td></tr>

<tr><td>A - B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td><function>op:subtract-yearMonthDurations</function><code>(A, B)</code></td><td>xs:yearMonthDuration</td></tr>
<tr><td>A - B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td><function>op:subtract-dayTimeDurations</function><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr>


<tr><td>A * B</td><td>xs:numeric</td><td>xs:numeric</td><td><function>op:numeric-multiply</function><code>(A, B)</code></td><td>xs:numeric</td></tr>
<tr><td>A * B</td><td>xs:yearMonthDuration</td><td>xs:numeric</td><td><function>op:multiply-yearMonthDuration</function><code>(A, B)</code></td><td>xs:yearMonthDuration</td></tr>
<tr><td>A * B</td><td>xs:numeric</td><td>xs:yearMonthDuration</td><td><function>op:multiply-yearMonthDuration</function><code>(B, A)</code></td><td>xs:yearMonthDuration</td></tr>
<tr><td>A * B</td><td>xs:dayTimeDuration</td><td>xs:numeric</td><td><function>op:multiply-dayTimeDuration</function><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr>
<tr><td>A * B</td><td>xs:numeric</td><td>xs:dayTimeDuration</td><td><function>op:multiply-dayTimeDuration</function><code>(B, A)</code></td><td>xs:dayTimeDuration</td></tr> 

<tr><td>A idiv B</td><td>xs:numeric</td><td>xs:numeric</td><td><function>op:numeric-integer-divide</function><code>(A, B)</code></td><td>xs:integer</td></tr>

   <tr><td>A div B</td><td>xs:numeric</td><td>xs:numeric</td><td><function>op:numeric-divide</function><code>(A, B)</code></td><td>numeric; but xs:decimal if both operands are xs:integer</td></tr>
<tr><td>A div B</td><td>xs:yearMonthDuration</td><td>xs:numeric</td><td><function>op:divide-yearMonthDuration</function><code>(A, B)</code></td><td>xs:yearMonthDuration</td></tr>
<tr><td>A div B</td><td>xs:dayTimeDuration</td><td>xs:numeric</td><td><function>op:divide-dayTimeDuration</function><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr>
<tr><td>A div B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td><function>op:divide-yearMonthDuration-by-yearMonthDuration</function><code>(A, B)</code></td><td>xs:decimal</td></tr>
<tr><td>A div B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td><function>op:divide-dayTimeDuration-by-dayTimeDuration</function><code>(A, B)</code></td><td>xs:decimal</td></tr>
 
<tr><td>A mod B</td><td>xs:numeric</td><td>xs:numeric</td><td><function>op:numeric-mod</function><code>(A, B)</code></td><td>xs:numeric</td></tr>
</tbody>
         </table>

<note><p>The operator symbol <code>×</code> is a synonym of <code>*</code>, while <code>÷</code> is
a synonym of <code>div</code>.</p></note>      
         
 <p>If there is no entry in the table for the combination of operator and operands,
    then a <termref def="dt-type-error"/> is raised <errorref class="TY" code="0004"/>.</p>
   
 <p>Errors may also occur during coercion of the operands, or during evaluation of the
 identified function (for example, an error
might result from dividing by zero).</p>  
         
 
         
      <note>
         <p>&language; provides three division operators:</p>
         <ulist>
            <item><p>The <code>div</code> and <code>÷</code> operators are synonyms, and implement
               numeric division as well as division of duration values; the semantics are defined in
               <xspecref spec="FO40" ref="func-numeric-divide"/></p></item>
            <item><p>The <code>idiv</code> operator implements integer division; the semantics are defined
               in <xspecref spec="FO40" ref="func-numeric-integer-divide"/></p></item>
         </ulist> 
      </note>

         <p>Here are some examples of arithmetic expressions:</p>

         <ulist>


            <item>
               <p>The first expression below returns the <code>xs:decimal</code> value <code
                     role="parse-test"
                     >-1.5</code>, and the second expression returns the <code>xs:integer</code> value <code
                     role="parse-test">-1</code>:</p>
               <eg role="parse-test"><![CDATA[-3 div 2
-3 idiv 2]]></eg>
            </item>


            <item>

               <p>Subtraction of two date values results in a value of type <code>xs:dayTimeDuration</code>:</p>
               <eg role="parse-test"><![CDATA[$emp/hiredate - $emp/birthdate]]></eg>
            </item>



            <item>
               <p>This example illustrates the difference between a subtraction operator and a
hyphen:</p>
               <eg role="parse-test"><![CDATA[$unit-price - $unit-discount]]></eg>
            </item>


            <item>
               <p>Unary operators have higher precedence than binary operators (other than <code>!</code>, <code>/</code>, and <code>[]</code>), subject of
course to the use of parentheses. Therefore, the following two examples have different meanings:</p>
               <eg><![CDATA[-$bellcost + $whistlecost
-($bellcost + $whistlecost)]]></eg>
            </item>
         </ulist>
         <note>
            <p id="note-consecutive-unary-ops"
               >Multiple consecutive unary arithmetic operators are permitted.</p>
         </note>
      </div2>
      <div2 id="id-string-expr">
         <head>String Expressions</head>
         <p>This section describes several ways of constructing strings.</p>
         <div3 id="id-string-concat-expr">
            <head>String Concatenation Expressions</head>
            <scrap>
               <prodrecap ref="StringConcatExpr"/>
            </scrap>
            <p>String concatenation expressions allow the string representations of values to be
               concatenated. In &language;, <code>$a || $b</code> is equivalent to
               <code>fn:concat($a, $b)</code>.
               The following expression evaluates to the string <code>concatenate</code>:</p>
            <eg><![CDATA[() || "con" || ("cat", "enate")]]></eg>
            
         </div3>
         <div3 id="id-string-templates" diff="add" at="2023-01-29">
            <head>String Templates</head>
            
            <changes>
               <change issue="58" PR="324" date="2023-01-29">
                  String templates provide a new way of constructing strings: for example <code>`{$greeting}, {$planet}!`</code>
                  is equivalent to <code>$greeting || ', ' || $planet || '!'</code>
               </change>
            </changes>
            
            <scrap>
               <prodrecap ref="StringTemplate"/>
            </scrap>
            <p>String templates provide an alternative way of constructing strings. For example,
            the expression <code>`Pi is { round(math:pi(), 4) }`</code> returns the string <code>"Pi is 3.1416"</code>.</p>
            <p>A string template starts and ends with <char>U+0060</char>, popularly known as a back-tick. Between
               the back-ticks is a string consisting of an sequence of fixed parts and
               variable parts:</p>
            <ulist>
               <item><p>A variable part consists of an optional XPath expression enclosed in curly brackets (<code>{}</code>):
                  more specifically, a string conforming 
                  to the XPath production <code>Expr?</code>.</p>
                  <note>
                     <p>An expression within a variable part may contain an unescaped <char>U+007B</char> 
                        or <char>U+007D</char> within
                        a <nt def="StringLiteral">StringLiteral</nt> or within
                        a comment.</p>
                     
                     <p>The fact that the expression is optional means that the
                        string contained between the curly brackets may be zero-length, may comprise whitespace
                        only, or may contain XPath comments. The effective value in this case is a zero-length
                        string, which is equivalent to omitting the variable part entirely, together with its 
                        curly-bracket delimiters. </p> 
                  </note>
               </item>
               <item>
                  <p>A fixed part may contain any characters, except that:</p>
                  <ulist>
                     <item><p>The character <char>U+007B</char> <rfc2119>must</rfc2119>
                        be written as <code>{{</code>.</p></item>
                     <item><p>The character <char>U+007D</char> <rfc2119>must</rfc2119> be
                        written as <code>}}</code>.</p></item>
                     <item><p>The character <char>U+0060</char> <rfc2119>must</rfc2119> be
                        written as <code>``</code>.</p>
                     </item>
                  </ulist>
                  <p>Following the principles of the “longest token” rule, any occurrence
                  of <code>{{</code> within the fixed part is interpreted as an escaped left
                  curly bracket. This means that the enclosed expression must not start with
                  <char>U+007B</char>: if this is required, the two left curly brackets can
                  be separated by whitespace. For example the string template
                     <code>`{{"key":"{ {1:"yes", 0:"no"}?$condition}"}}`</code>
                     evaluates to the string <code>{"key":"yes"}</code> or <code>{"key":"no"}</code>
                     depending on the value of <code>$condition</code>.</p>
                  <p>By contrast, if the enclosed expression ends with <char>U+007D</char>,
                  this can be immediately followed by the closing <char>U+007D</char>
                  delimiter without intervening whitespace.</p>
               </item>
            </ulist>
            

            <p>
               The result of evaluating a
                  string template is the string obtained by concatenating the expansions of the fixed
               and variable parts:</p>
            <ulist>
               <item>
                  <p>The expansion of a fixed part is obtained by replacing any double curly
                     brackets (<code>{{</code> or <code>}}</code>) by the corresponding single curly
                     bracket, and replacing doubled back-ticks (<code>``</code>) by a single back-tick.</p>
               </item>
               <item>
                  <p>The expansion of a variable part containing an expression is as follows:</p>
                  
                  <olist>
                     
                     <item>
                        <p>
                           <termref def="dt-atomization"
                              >Atomization</termref> is applied to the value of the enclosed expression, 
                           converting it to a sequence of atomic items.</p>
                        
                     </item>
                     
                     <item>
                        <p>If the result of atomization is an empty sequence, the result 
                           is the zero-length string. Otherwise, each atomic item in the 
                           atomized sequence is cast into a string.</p>
                     </item>
                     
                     <item>
                        <p>The individual strings resulting from the previous step are 
                           merged into a single string by concatenating them with a 
                           single space character between each pair.</p>
                     </item>
                  </olist>
                  
               </item>
               <item>
                  <p>The expansion of an empty variable part (one that contains no expression) is a zero-length string.</p>
               </item>
            </ulist>
            
            <p>For example:</p>
            <eg role="parse-test"><![CDATA[let $greeting := "Hello",
    $planet := "Mars"
return `{ $greeting }, { $planet }!`]]></eg>
            <p>returns <code>"Hello, Mars!"</code>.</p>
            <p>The expression:</p>
            <eg role="parse-test"><![CDATA[let $longMonths := (1, 3, 5, 7, 8, 10, 12)
return `The months with 31 days are: { $longMonths }.`]]></eg>
            <p>returns <code>"The months with 31 days are: 1 3 5 7 8 10 12."</code>.</p>
            
            <note>
               <p>The rules for processing an enclosed expression are identical to the rules for attributes in
               XQuery direct element constructors. These rules differ slightly from the rules in XSLT
               attribute value templates, where adjacent text nodes are concatenated with no separator,
               prior to atomization.</p>
            </note>
            
            <note>
               <p>A string template containing no variable parts is effectively just another
                  way of writing a string literal: <code>"Goethe"</code>, <code>'Goethe'</code>, and <code>`Goethe`</code>
               are interchangeable. This means that back-ticks can sometimes be a useful way of delimiting a string
               that contains both single and double quotes: <code>`He said: "I didn't."`</code>.</p>
               <p>It is sometimes useful to use string templates in conjunction with the <function>fn:char</function> function
                  to build strings containing special characters, for example <code>`Chapter{ fn:char("nbsp") }{ $chapNr }`</code>.</p>
            </note>
            
            <note>
               <p>String literals containing an ampersand behave differently between XPath and XQuery: in XPath 
               (unless first expanded by an XML parser) the string literal <code>"Bacon &amp; Eggs"</code> 
               represents a string containing an ampersand, while in XQuery
               it is an error, because an ampersand is taken as introducing a character reference. This difference
               does not arise for string templates, since neither XPath nor XQuery recognizes entity or character references
               in a string template.
               This means that back-tick delimited strings (such as <code>`Bacon &amp; Eggs`</code>) 
                  may be useful in contexts where an XPath expression
               is required to have the same effect whether it is evaluated using an XPath or an XQuery processor.</p>
            </note>
            
            <p>In XQuery, the token <code>``[</code> is recognized as the start of a 
               <termref def="dt-string-constructor" role="xquery"/><code role="xpath">StringConstructor</code>,
            under the “longest token” rule (see <specref ref="lexical-structure"/>). This means that the construct
               <code>``[1]</code> is not recognized as a <nt def="StringTemplate">StringTemplate</nt> followed by a predicate. 
               <phrase role="xpath">Although
               the token <code>``[</code> is not used in XPath, it is reserved for compatibility reasons, and <rfc2119>must</rfc2119>
               be rejected as syntactically invalid.</phrase> In the unlikely event that an empty <nt def="StringTemplate">StringTemplate</nt>
            followed by a predicate is wanted, whitespace or parentheses can be used to avoid the tokenization problem.</p>
            
         </div3>
         
         <div3 id="id-string-constructors" role="xquery">
            <head>String Constructors</head>
            
            <p>
               <termdef term="string constructor" id="dt-string-constructor"
                  >A
                  <term>String Constructor</term> creates a string from literal text and interpolated expressions.
               </termdef>
            </p>
            
            <p>The syntax of a string constructor is convenient for generating
               JSON, JavaScript, CSS, SPARQL, XQuery, XPath, or other languages that
               use curly brackets, quotation marks, or other strings that are
               delimiters in &language;.</p>
            
            <scrap>
               <prodrecap ref="StringConstructor"/>
            </scrap>
            
            <note diff="add" at="2023-01-29">
               <p>String templates (see <specref ref="id-string-templates"/>) and string constructors
               have overlapping functionality. String constructors were introduced in XQuery 3.1,
               and are not available in XPath; string templates are new in XQuery 4.0 and XPath 4.0.
               String constructors were designed specifically for convenience when generating
               code in languages that use curly brackets, but with experience, they have been found to
               be somewhat unwieldy for simpler applications; this motivated the introduction of
               a simpler syntax in 4.0.</p>
            </note>
            
            <p>In a <nt def="StringConstructor">string constructor</nt>, adjacent
               <nt
                  def="StringConstructorChars"
                  >string constructor characters</nt>
               are treated as literal text. Line endings are processed as elsewhere
               in XQuery; no other processing is performed on this text. 
               
               To evaluate a string constructor, each sequence of adjacent string
               constructor characters is converted to a string containing the same
               characters, and each <nt
                  def="StringInterpolation">string
                  constructor interpolation</nt>
               <code>$i</code> is evaluated, then
               converted to a string using the expression <code
                  role="parse-test"
                  >string-join($i, ' ')</code>.  
               
               A string constructor interpolation that does not contain an expression (<code>`{ }`</code>) is ignored. 
               
               The strings
               created from string constructor characters and the strings created
               from string constructor interpolations are then concatenated, in
               order.</p>
            
            <p>For instance, the following expression:</p>
            <eg role="parse-test"><![CDATA[for $s in ("one", "two", "red", "blue")
return ``[`{ $s }` fish]``
]]></eg>
            <p>evaluates to the sequence  <code>("one fish", "two fish", "red fish", "blue fish")</code>.</p>
            
            <note>
               <p>Character entities are not expanded in string constructor
                  content.  Thus, <code>``[&amp;lt;]``</code> evaluates to the string
                  <code>"&amp;lt;"</code>, not the string
                  <code>"&lt;"</code>.</p>
            </note>
            
            
            <p>Interpolations can contain string constructors. For instance, consider the following expression:</p>
            
            <eg><![CDATA[``[`{ $i, ``[literal text]``, $j, ``[more literal text]`` }`]``]]></eg>
            
            <p>Assuming the values <code>$i := 1</code> and <code>$j := 2</code>, this evaluates to the string <code>"1 literal text 2 more literal text"</code>.</p>
            
            <p>The following examples are based on an example taken from the documentation of <bibref
               ref="Moustache"
            />, a JavaScript template library. Each function takes a map, containing values like these:</p>
            
            <eg><![CDATA[{
  "name": "Chris",
  "value": 10000,
  "taxed_value": 10000 - (10000 * 0.4),
  "in_ca": true
}]]></eg>
            
            <p>This function creates a simple string.</p>
            
            <eg><![CDATA[declare function local:prize-message($a) as xs:string {
  ``[Hello `{ $a?name }`
You have just won `{ $a?value }` dollars!
`{ 
   if ($a?in_ca) 
   then ``[Well, `{ $a?taxed_value }` dollars, after taxes.]``
   else ""
}`]``
};]]></eg>
            
            <p>This is the output of the above function :</p>
            
            <eg><![CDATA[Hello Chris
You have just won 10000 dollars!
Well, 6000 dollars, after taxes.]]></eg>
            
            <p>This function creates a similar string in HTML syntax.</p>
            
            <eg><![CDATA[declare function local:prize-message($a) as xs:string {
  ``[<div>
  <h1>Hello `{ $a?name }`</h1>
  <p>You have just won `{ $a?value }` dollars!</p>
    `{ 
      if ($a?in_ca) 
      then ``[  <p>Well, `{ $a?taxed_value }` dollars, after taxes.</p> ]``
      else ""
    }`
</div>]``
};]]></eg>
            
            <p>This is the output of the above function :</p>
            
            <eg>&lt;div&gt;
  &lt;h1&gt;Hello Chris&lt;/h1&gt;
  &lt;p&gt;You have just won 10000 dollars!&lt;/p&gt;
  &lt;p&gt;Well, 6000 dollars, after taxes.&lt;/p&gt; 
&lt;/div&gt;</eg>
            
            <p>This function creates a similar string in JSON syntax.</p>
            
            <eg><![CDATA[
declare function local:prize-message($a) as xs:string {
  ``[{ 
  "name": `{ $a?name }`
  "value": `{ $a?value }`
  `{
  if ($a?in_ca) 
  then 
  ``[, 
  "taxed_value": `{ $a?taxed_value }`]``  
  else ""
  }`
}]`` 
};]]></eg>
            
            <p>This is the output of the above function :</p>
            
            <eg><![CDATA[{ 
  "name": "Chris",
  "value": 10000,
  "taxed_value": 6000
}]]></eg>
            
            <p>Within an enclosed expression, the handling of expressions that start with <char>U+007B</char> or that
            end with <char>U+007D</char> is the same as for <specref ref="id-string-templates"/>.</p>
            
         </div3>
      </div2>
      
      <div2 id="id-comparisons">
         <head>Comparison Expressions</head>
         <p>Comparison expressions allow two values to be compared. &language; provides
three kinds of comparison expressions, called value comparisons, general
comparisons, and node comparisons.</p>
         <scrap>
            <prodrecap ref="ComparisonExpr"/>
         </scrap>

         <note role="xpath">
            <p role="xpath"
                  >When an XPath expression is written
within an XML document, the XML escaping rules for special characters
must be followed; thus <code>&lt;</code> must be written as
<code>&amp;lt;</code>.</p>
         </note>
         
         <p>For a summary of the differences between different ways of comparing atomic items
         in &language;, see <specref ref="id-atomic-comparisons"/>.</p>


         <div3 id="id-value-comparisons">
            <head>Value Comparisons</head>
            
            <changes>
               <change>
                  The rules for value comparisons when comparing values of different types (for example, decimal and double)
                  have changed to be transitive. A decimal value is no longer converted to double, instead the double is converted
                  to a decimal without loss of precision. This may affect compatibility in edge cases involving comparison of
                  values that are numerically very close.
               </change>
            </changes>
            
            <p>The value comparison operators are <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code>. Value comparisons are used for comparing single values.</p>
            <p>The first step in evaluating a value comparison is to evaluate its operands. The order in which the operands are evaluated is <termref
                  def="dt-implementation-dependent"
               >implementation-dependent</termref>. Each operand is evaluated by applying the following steps, in order:</p>

            <olist>

               <item>
                  <p>
                     <termref def="dt-atomization"
                        >Atomization</termref> is applied to each  operand. The result of this
    operation is called the <term>atomized operand</term>.</p>

               </item>

               <item>
                  <p>If an atomized operand is an empty sequence, the result of
    the value comparison is an empty sequence, and the implementation
    need not evaluate the other operand or apply the operator. However,
    an implementation may choose to evaluate the other operand in order
    to determine whether it raises an error.</p>
               </item>

               <item>
                  <p> If an atomized operand is a sequence of
length greater than one, a <termref
                        def="dt-type-error">type error</termref> is raised <errorref class="TY"
                        code="0004"/>.</p>
               </item>

               <item>
                  <p>If an  atomized operand is of type
  <code>xs:untypedAtomic</code>, it is cast to
  <code>xs:string</code>.</p>
                  <note>
                     <p>The purpose of this rule is to
  make value comparisons transitive. Users should be aware that the
  general comparison operators have a different rule for casting of
  <code>xs:untypedAtomic</code> operands. Users should also be aware
  that transitivity of value comparisons may be compromised by loss of
  precision during type conversion (for example, two
  <code>xs:integer</code> values that differ slightly may both be
  considered equal to the same <code>xs:float</code> value because
  <code>xs:float</code> has less precision than
  <code>xs:integer</code>).</p>
                  </note>
               </item>

               <item>


                  <p>If the two operands are instances of different primitive types (meaning the 19 primitive types defined in <xspecref
                        spec="XS2" ref="built-in-primitive-datatypes"/>), then:
    <olist>
                        <item>
                           <p>If each operand is an instance of one of the types <code>xs:string</code> or <code>xs:anyURI</code>, then both operands are cast to type <code>xs:string</code>.</p>
                        </item>
                        <item>
                           <p>If each operand is an instance of one of the types <code>xs:decimal</code> or <code>xs:float</code>, then both operands are cast to type <code>xs:float</code>.</p>
                        </item>
                        <item>
                           <p>If each operand is an instance of one of the types <code>xs:decimal</code>, <code>xs:float</code>, or <code>xs:double</code>, then both operands are cast to type <code>xs:double</code>.</p>
                        </item>
                        <item>
                           <p>Otherwise, a <termref def="dt-type-error"
                                 >type error</termref> is raised <errorref class="TY" code="0004"
                              />.</p>
                           <note>
                              <p>The primitive type of an <code>xs:integer</code> value for this purpose is <code>xs:decimal</code>.</p>
                           </note>
                        </item>
                     </olist>
                  </p>
               </item>
               
               <item>
                  <p>Expressions using operators other than <code>eq</code> and <code>lt</code>
                  are rewritten as follows:</p>
                  <slist>
                     <sitem><code>A ne B</code> becomes <code>not(A eq B)</code></sitem>
                     <sitem><code>A le B</code> becomes <code>A lt B or A eq B</code></sitem>
                     <sitem><code>A gt B</code> becomes <code>B lt A</code></sitem>
                     <sitem><code>A ge B</code> becomes <code>B lt A or B eq A</code></sitem>
                  </slist>
               </item>

               <item>
                  <p>Finally, if the types of the operands are a valid
  combination for the given operator, the operator is applied to the
  operands by applying the appropriate function from the table below.</p>
               </item>

            </olist>
            
            
           <table border="1" role="small">
<caption>Value Comparison Operators</caption>
<tbody>

<tr>
<th>Expression</th>
<th>Type(A)</th>
<th>Type(B)</th>
<th>Function</th>
<th>Result type</th>
</tr>



<tr><td>A eq B</td><td>xs:numeric</td><td>xs:numeric</td><td><function>op:numeric-equal</function><code>(A, B)</code></td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:boolean</td><td>xs:boolean</td><td><function>op:boolean-equal</function><code>(A, B)</code></td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:string</td><td>xs:string</td><td><function>op:numeric-equal</function><code>(</code><function>fn:compare</function><code>(A, B), 0)</code></td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:date</td><td>xs:date</td><td><function>op:date-equal</function><code>(A, B)</code></td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:time</td><td>xs:time</td><td><function>op:time-equal</function><code>(A, B)</code></td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:dateTime</td><td>xs:dateTime</td><td><function>op:dateTime-equal</function><code>(A, B)</code></td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:duration</td><td>xs:duration</td><td><function>op:duration-equal</function><code>(A, B)</code></td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:gYear</td><td>xs:gYear</td><td><function>op:gYear-equal</function><code>(A, B)</code></td><td>xs:boolean</td></tr>
<tr><td>A eq B</td><td>xs:gYearMonth</td><td>xs:gYearMonth</td><td><function>op:gYearMonth-equal</function><code>(A, B)</code></td><td>xs:boolean</td></tr>
<tr><td>A eq B</td><td>xs:gMonth</td><td>xs:gMonth</td><td><function>op:gMonth-equal</function><code>(A, B)</code></td><td>xs:boolean</td></tr>
<tr><td>A eq B</td><td>xs:gMonthDay</td><td>xs:gMonthDay</td><td><function>op:gMonthDay-equal</function><code>(A, B)</code></td><td>xs:boolean</td></tr>
<tr><td>A eq B</td><td>xs:gDay</td><td>xs:gDay</td><td><function>op:gDay-equal</function><code>(A, B)</code></td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>(xs:hexBinary | xs:base64Binary)</td><td>(xs:hexBinary | xs:base64Binary)</td><td><function>op:binary-equal</function><code>(A, B)</code></td><td>xs:boolean</td></tr>


<tr><td>A eq B</td><td>xs:QName</td><td>xs:QName</td><td><function>op:QName-equal</function><code>(A, B)</code></td><td>xs:boolean</td></tr>

<tr><td>A eq B</td><td>xs:NOTATION</td><td>xs:NOTATION</td><td><function>op:NOTATION-equal</function><code>(A, B)</code></td><td>xs:boolean</td></tr>




<tr><td>A lt B</td><td>xs:numeric</td><td>xs:numeric</td><td><function>op:numeric-less-than</function><code>(A, B)</code></td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:boolean</td><td>xs:boolean</td><td><function>op:boolean-less-than</function><code>(A, B)</code></td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:string</td><td>xs:string</td><td><function>op:numeric-less-than</function><code>(</code><function>fn:compare</function><code>(A, B), 0)</code></td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:date</td><td>xs:date</td><td><function>op:date-less-than</function><code>(A, B)</code></td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:time</td><td>xs:time</td><td><function>op:time-less-than</function><code>(A, B)</code></td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:dateTime</td><td>xs:dateTime</td><td><function>op:dateTime-less-than</function><code>(A, B)</code></td><td>xs:boolean</td></tr>

<tr><td>A lt B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td><function>op:yearMonthDuration-less-than</function><code>(A, B)</code></td><td>xs:boolean</td></tr>
<tr><td>A lt B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td><function>op:dayTimeDuration-less-than</function><code>(A, B)</code></td><td>xs:boolean</td></tr>
<tr><td>A lt B</td><td>(xs:hexBinary | xs:base64Binary)</td><td>(xs:hexBinary | xs:base64Binary)</td><td><function>op:binary-less-than</function><code>(A, B)</code></td><td>xs:boolean</td></tr>




</tbody>
</table>


            <p>The definitions of the operator functions are found in <bibref
                  ref="xpath-functions-40"/>.</p>

 

            <p>If the table contains no entry corresponding to the types of the operands, 
               after evaluation, then a <termref def="dt-type-error"
                  >type error</termref>
is raised <errorref class="TY" code="0004"/>.</p>

            <p>Here are some examples of value comparisons:</p>

            <ulist>


               <item>
                  <p>The following comparison atomizes the node(s) that are returned by the expression <code>$book/author</code>. The comparison is true only if the result of atomization is the value "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>. If the result of atomization is an empty sequence, the result of the comparison is an empty sequence. If the result of atomization is a sequence containing more than one value, a <termref
                        def="dt-type-error">type error</termref> is raised <errorref class="TY"
                        code="0004"/>.</p>
                  <eg role="parse-test"><![CDATA[$book1/author eq "Kennedy"]]></eg>
               </item>


               <item>
                  <p>The following comparison is <code>true</code> because atomization converts an array to its member sequence:</p>
                  <eg role="parse-test"><![CDATA[[ "Kennedy" ] eq "Kennedy"]]></eg>
               </item>

               <item>
                  <p>The following <termref def="dt-path-expression"
                        >path expression</termref> contains a predicate that selects products whose weight is greater than 100. For any product that does not have a <code>weight</code> subelement, the value of the predicate is the empty sequence, and the product is not selected. This example assumes that <code>weight</code> is a validated element with a numeric type.</p>
                  <eg role="parse-test"><![CDATA[//product[weight gt 100]]]></eg>
               </item>

               <item role="xquery">
                  <p>The following comparisons are true because, in each case, the two constructed nodes have the same value after atomization, even though they have different identities and/or names:</p>
                  <eg role="parse-test"
                     >&lt;a&gt;5&lt;/a&gt; eq &lt;a&gt;5&lt;/a&gt;</eg>
                  <eg role="parse-test"
                     >&lt;a&gt;5&lt;/a&gt; eq &lt;b&gt;5&lt;/b&gt;</eg>
               </item>

               <item>
                  <p>The following comparison is true if <code>my:hatsize</code> and <code>my:shoesize</code> are both user-defined types that are derived by restriction from a primitive <termref
                        def="dt-numeric">numeric</termref> type:</p>
                  <eg role="parse-test"><![CDATA[my:hatsize(5) eq my:shoesize(5)]]></eg>
               </item>


               <item>
                  <p>The following comparison is true. The <code>eq</code> operator compares two QNames by performing codepoint-comparisons of their namespace URIs and their local names, ignoring their namespace prefixes.</p>
                  <eg role="parse-test"
                     ><![CDATA[QName("http://example.com/ns1", "this:color") eq
QName("http://example.com/ns1", "that:color")]]></eg>
               </item>
            </ulist>
         </div3>
         <div3 id="id-general-comparisons">
            <head>General Comparisons</head>
            
            <changes>
               <change>
                  Operators such as <code>&lt;</code> and <code>&gt;</code> can use the full-width forms
                  <code>&#xFF1C;</code> and <code>&#xFF1E;</code> to avoid the need for XML escaping.
               </change>
            </changes>
            <p>The general comparison operators are <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>. General comparisons are existentially quantified comparisons that may be applied to operand sequences of any length. The result of a general comparison that does not raise an error is
always <code>true</code> or <code>false</code>.</p>
            
         
            
            <p role="xpath">If <termref def="dt-xpath-compat-mode"
                  >XPath 1.0 compatibility mode</termref> is <code>true</code>, a general comparison is evaluated by applying the following rules, in order:</p>

            <olist role="xpath">

               <item>
                  <p>If either operand is a single atomic item that is an instance of
<code>xs:boolean</code>, then the other operand is converted to <code>xs:boolean</code> by taking its
<termref
                        def="dt-ebv">effective boolean value</termref>.</p>
               </item>

               <item>
                  <p>
                     <termref def="dt-atomization"
                     >Atomization</termref> is applied to each operand. After atomization, each operand is a sequence of atomic items.</p>

               </item>

               <item>
                  <p>If the comparison operator is <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code>, then each item in both of the
operand sequences is converted to the type  <code>xs:double</code> by applying the
<function>fn:number</function> function. (Note that <function>fn:number</function> returns the value <code>NaN</code> if its operand cannot be converted to a number.)</p>
               </item>

               <item>
                  <p>The result of the comparison is <code>true</code> if and only if there is a pair of
atomic items, one in the first operand sequence and the other in the second operand sequence, that have the required
<term>magnitude relationship</term>. Otherwise the result of the  comparison is
<code>false</code> or an error. The <term>magnitude relationship</term> between two atomic items is determined by
applying the following rules. If a <code>cast</code> operation called for by these rules is not successful, a <termref
                        def="dt-dynamic-error">dynamic error</termref>  is raised. <xerrorref
                        spec="FO40" class="RG" code="0001"/>
                  </p>

                  <olist>

                     <item>
                        <p>If at least one of the two atomic items is an instance of a <termref
                              def="dt-numeric"
                              >numeric</termref> type, then both atomic items are converted to the type <code>xs:double</code> by
applying the <function>fn:number</function> function.</p>
                     </item>

                     <item>
                        <p>If at least one of the two atomic items is an instance of <code>xs:string</code>,
or if both atomic items are instances of <code>xs:untypedAtomic</code>, then both
atomic items are cast to the type <code>xs:string</code>.</p>
                     </item>

                     <item>
                        <p>If one of the atomic items is an instance of <code>xs:untypedAtomic</code> and the other is not an instance of <code>xs:string</code>, <code>xs:untypedAtomic</code>, or any <termref
                              def="dt-numeric"
                              >numeric</termref> type, then the <code>xs:untypedAtomic</code> item is
cast to the <termref
                              def="dt-dynamic-type">dynamic type</termref> of the other value.</p>
                     </item>

                     <item>
                        <p>After performing the conversions described above, the atomic items are
compared using one of the value comparison operators <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, or
<code>ge</code>, depending on whether the general comparison operator was <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, or <code>&gt;=</code>. The values have the required <term>magnitude relationship</term> if and only if the result
of this value comparison is <code>true</code>.</p>
                     </item>
                  </olist>
               </item>
            </olist>
            <p>
               <phrase role="xpath">If <termref def="dt-xpath-compat-mode"
                     >XPath 1.0 compatibility mode</termref> is <code>false</code>, a</phrase>
               <phrase role="xquery"
               >A</phrase> general comparison is evaluated by applying the following rules, in order:</p>

            <olist>

               <item>
                  <p>
                     <termref def="dt-atomization"
                     >Atomization</termref> is applied to each operand. After atomization, each operand is a sequence of atomic items.</p>

               </item>

               <item>
                  <p>The result of the comparison is <code>true</code> if and only if there is a pair of
atomic items, one in the first operand sequence and the other in the second operand sequence, that have the required
<term>magnitude relationship</term>. Otherwise the result of the  comparison is
<code>false</code> or an error. The <term>magnitude relationship</term> between two atomic items is determined by
applying the following rules. If a <code>cast</code> operation called for by these rules is not successful, a <termref
                        def="dt-dynamic-error">dynamic error</termref>  is raised. <xerrorref
                        spec="FO40" class="RG" code="0001"/>
                  </p>
                  <note role="xquery">
                     <p>The purpose of these rules is to preserve compatibility with XPath 1.0, in which (for example) <code
                           role="parse-test"
                           >x &lt; 17</code> is a numeric comparison if <code>x</code> is an untyped value. Users should be aware that the value comparison operators have different rules for casting of <code>xs:untypedAtomic</code> operands.</p>
                  </note>

                  <olist>

                     <item>
                        <p>If both atomic items are instances of <code>xs:untypedAtomic</code>,
                then the values are cast to the type <code>xs:string</code>.
             </p>
                     </item>
                     <item>
                        <p>If exactly one of the atomic items is an instance of
                <code>xs:untypedAtomic</code>, it is cast to a type depending on
                the other value’s dynamic type T according to the following rules,
                in which V denotes the value to be cast:
             </p>
                        <olist>
                           <item>
                              <p>If T is a numeric type or is derived from a numeric type,
                      then V is cast to <code>xs:double</code>.</p>
                           </item>
                           <item>
                              <p>If T is <code>xs:dayTimeDuration</code> or is derived from
                      <code>xs:dayTimeDuration</code>,
                      then V is cast to <code>xs:dayTimeDuration</code>.</p>
                           </item>
                           <item>
                              <p>If T is <code>xs:yearMonthDuration</code> or is derived from
                      <code>xs:yearMonthDuration</code>,
                      then V is cast to <code>xs:yearMonthDuration</code>.</p>
                           </item>
                           <item>
                              <p>In all other cases, V is cast to the primitive base type of T.</p>
                           </item>
                        </olist>
                        <note>
                           <p>
                The special treatment of the duration types is required to avoid
                errors that may arise when comparing the primitive type
                <code>xs:duration</code> with any duration type.
             </p>
                        </note>
                     </item>
                     <item>
                        <p>After performing the conversions described above, the atomic items are
compared using one of the value comparison operators <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, or
<code>ge</code>, depending on whether the general comparison operator was <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, or <code>&gt;=</code>. The values have the required <term>magnitude relationship</term> if and only if the result
of this value comparison is <code>true</code>.</p>
                     </item>
                  </olist>
               </item>
            </olist>
            <p>When evaluating a general comparison in which either operand is a sequence of items, an implementation may return <code>true</code> as soon as it finds an item in the first operand and an item in the second operand that have the required <term>magnitude relationship</term>. Similarly, a general comparison may raise a <termref
                  def="dt-dynamic-error"
               >dynamic error</termref> as soon as it encounters an error in evaluating either operand, or in comparing a pair of items from the two operands. As a result of these rules, the result of a general comparison is not deterministic in the presence of errors.</p>


            <p>Here are some examples of  general comparisons:</p>

            <ulist>


               <item>
                  <p>The following comparison is true if the <termref def="dt-typed-value"
                        >typed value</termref> of any
<code>author</code> subelement of <code>$book1</code> is "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>:</p>
                  <eg role="parse-test"><![CDATA[$book1/author = "Kennedy"]]></eg>
               </item>

               <item>
                  <p>The following comparison is <code>true</code> because atomization converts an array to its member sequence:</p>
                  <eg role="parse-test"><![CDATA[[ "Obama", "Nixon", "Kennedy" ] = "Kennedy"]]></eg>
               </item>

               <item>
                  <p>The following example contains three general comparisons. The value of the first two comparisons is <code>true</code>, and the value of the third comparison is <code>false</code>. This example illustrates the fact that general comparisons are not transitive.</p>
                  <eg><![CDATA[(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)]]></eg>
               </item>

               <item>
                  <p>The following example contains two general comparisons, both of which are <code>true</code>. This example illustrates the fact that the <code>=</code> and <code>!=</code> operators are not inverses of each other.</p>
                  <eg><![CDATA[(1, 2) = (2, 3)
(1, 2) != (2, 3)]]></eg>
               </item>

               <item>
                  <p>Suppose that <code>$a</code>, <code>$b</code>, and <code>$c</code> are bound to element nodes with type annotation <code>xs:untypedAtomic</code>, with <termref
                        def="dt-string-value"
                        >string values</termref> <code>"1"</code>, <code>"2"</code>, and <code>"2.0"</code> respectively. Then <code
                        role="parse-test"
                        >($a, $b) = ($c, 3.0)</code> returns <code>false</code>, because <code>$b</code> and <code>$c</code> are compared as strings. However, <code
                        role="parse-test"
                        >($a, $b) = ($c, 2.0)</code> returns <code>true</code>, because <code>$b</code> and <code>2.0</code> are compared as numbers.</p>
               </item>
            </ulist>
         </div3>
         <div3 id="id-node-comparisons">
            <head>Node Comparisons</head>
            <p>Node comparisons are used to compare two nodes, by their identity or by their <termref
                  def="dt-document-order"
               >document order</termref>. The result of a node comparison is defined by the following rules:</p>


            <olist>


               <item>
                  <p>The operands of a node comparison are evaluated in <termref
                        def="dt-implementation-dependent"
                     >implementation-dependent</termref> order.</p>
               </item>


               <item>
                  <p>If either operand is an empty sequence, the result of the
    comparison is an empty sequence, and the implementation need not
    evaluate the other operand or apply the operator. However, an
    implementation may choose to evaluate the other operand in order to
    determine whether it raises an error.</p>
               </item>


               <item>
                  <p> Each operand must be either a single node or an empty sequence; otherwise
a <termref
                        def="dt-type-error">type error</termref> is raised <errorref class="TY"
                        code="0004"/>.</p>
               </item>

               <item>
                  <p>A comparison with the <code>is</code> operator is <code>true</code> if the two operand nodes are the same node; otherwise it
is <code>false</code>. See <bibref
                        ref="xpath-datamodel-40"/> for  the definition of node identity.</p>
               </item>


               <item>
                  <p>A comparison with the <code>&lt;&lt;</code> operator returns <code>true</code> if the left operand node precedes the right operand node in
<termref
                        def="dt-document-order"
                        >document order</termref>; otherwise it returns <code>false</code>.</p>
               </item>


               <item>
                  <p>A comparison with the <code>&gt;&gt;</code> operator returns <code>true</code> if the left operand node follows the right operand node in
<termref
                        def="dt-document-order"
                        >document order</termref>; otherwise it returns <code>false</code>.</p>
               </item>
            </olist>
            <p>Here are some examples of node comparisons:</p>

            <ulist>


               <item>
                  <p>The following comparison is true only if the left and right sides each
evaluate to exactly the same single node:</p>
                  <eg role="parse-test"
                     ><![CDATA[/books/book[isbn = "1558604820"] is /books/book[call = "QA76.9 C3845"]]]></eg>
               </item>

               <item role="xquery">
                  <p>The following comparison is false because each constructed node has its own identity:</p>
                  <eg role="parse-test"
                     >&lt;a&gt;5&lt;/a&gt; is &lt;a&gt;5&lt;/a&gt;</eg>
               </item>


               <item>
                  <p>The following comparison is true only if the node identified by the left
side occurs before the node identified by the right side in document order:</p>
                  <eg role="parse-test"
                     >/transactions/purchase[parcel = "28-451"] &lt;&lt; /transactions/sale[parcel = "33-870"]</eg>
               </item>
            </ulist>
         </div3>

      </div2>
      <div2 id="id-logical-expressions">
         <head>Logical Expressions</head>
         <p>A <term>logical expression</term> is either an <term>and-expression</term> or
an <term>or-expression</term>. If a logical expression does not raise an error, its value is always one
of the boolean values <code>true</code> or <code>false</code>.</p>
         <scrap>
            <prodrecap ref="OrExpr"/>
         </scrap>
         <p>The first step in evaluating a logical expression is to find the  <termref def="dt-ebv"
               >effective boolean value</termref> of each of its operands (see <specref ref="id-ebv"
            />).</p>

         <p>The value of an and-expression is determined by the effective
boolean values (EBVs) of its operands, as shown in the following table:</p>
         <table role="medium" width="80%">
            <tbody>
               <tr>
                  <th>AND:</th>
                  <th>EBV<sub>2</sub> =
<code>true</code>
                  </th>
                  <th>EBV<sub>2</sub> = <code>false</code>
                  </th>
                  <th>error in EBV<sub>2</sub>
                  </th>
               </tr>
               <tr>
                  <th>EBV<sub>1</sub> =
<code>true</code>
                  </th>
                  <td>
                     <code>true</code>
                  </td>
                  <td>
                     <code>false</code>
                  </td>
                  <td>error</td>
               </tr>
               <tr>
                  <th>EBV<sub>1</sub>
= <code>false</code>
                  </th>
                  <td>
                     <code>false</code>
                  </td>
                  <td>
                     <code>false</code>
                  </td>
                  <td>
                     <phrase role="xquery">either <code>false</code> or
error</phrase>
                     <phrase role="xpath">if <termref def="dt-xpath-compat-mode"
                           >XPath 1.0 compatibility mode</termref> is <code>true</code>, then <code>false</code>; otherwise either <code>false</code> or error.</phrase>
                  </td>
               </tr>
               <tr>
                  <th>error in EBV<sub>1</sub>
                  </th>
                  <td>error</td>
                  <td>
                     <phrase role="xquery">either <code>false</code> or
error</phrase>
                     <phrase role="xpath">if <termref def="dt-xpath-compat-mode"
                           >XPath 1.0 compatibility mode</termref> is <code>true</code>, then error; otherwise either <code>false</code> or error.</phrase>
                  </td>
                  <td>error</td>
               </tr>
            </tbody>
         </table>
         <p>The value of an
or-expression is determined by the effective boolean values (EBVs) of
its operands, as shown in
the following table:</p>
         <table role="medium" width="80%">
            <tbody>
               <tr>
                  <th>OR:</th>
                  <th>EBV<sub>2</sub> =
<code>true</code>
                  </th>
                  <th>EBV<sub>2</sub> = <code>false</code>
                  </th>
                  <th>error in
EBV<sub>2</sub>
                  </th>
               </tr>
               <tr>
                  <th>EBV<sub>1</sub> =
<code>true</code>
                  </th>
                  <td>
                     <code>true</code>
                  </td>
                  <td>
                     <code>true</code>
                  </td>
                  <td>
                     <phrase role="xquery">either <code>true</code> or
error</phrase>
                     <phrase role="xpath">if <termref def="dt-xpath-compat-mode"
                           >XPath 1.0 compatibility mode</termref> is <code>true</code>, then <code>true</code>; otherwise either <code>true</code> or error.</phrase>
                  </td>
               </tr>
               <tr>
                  <th>EBV<sub>1</sub> =
<code>false</code>
                  </th>
                  <td>
                     <code>true</code>
                  </td>
                  <td>
                     <code>false</code>
                  </td>
                  <td>error</td>
               </tr>
               <tr>
                  <th>error
in EBV<sub>1</sub>
                  </th>
                  <td>
                     <phrase role="xquery">either <code>true</code> or
error</phrase>
                     <phrase role="xpath">if <termref def="dt-xpath-compat-mode"
                           >XPath 1.0 compatibility mode</termref> is <code>true</code>, then error; otherwise either <code>true</code> or error.</phrase>
                  </td>
                  <td>error</td>
                  <td>error</td>
               </tr>
            </tbody>
         </table>
         <p role="xpath">If <termref def="dt-xpath-compat-mode"
               >XPath 1.0 compatibility mode</termref> is <code>true</code>, the order in which the operands of a logical expression are evaluated is effectively prescribed. Specifically, it is defined that when there is no
need to evaluate the second operand in order to determine the result, then
no error can occur as a result of evaluating the second operand.</p>
         <p>
            <phrase role="xpath">If <termref def="dt-xpath-compat-mode"
                  >XPath 1.0 compatibility mode</termref> is <code>false</code>, the
order in which the operands of a logical expression are evaluated is
<termref
                  def="dt-implementation-dependent"
               >implementation-dependent</termref>. In this case,</phrase>
            <phrase role="xquery"
                  >The
order in which the operands of a logical expression are evaluated is
<termref
                  def="dt-implementation-dependent"
               >implementation-dependent</termref>. The tables above are defined in such a way
that</phrase> an or-expression can return <code>true</code> if the first
expression evaluated is true, and it can raise an error if evaluation
of the first expression raises an error. Similarly, an and-expression
can return <code>false</code> if the first expression evaluated is
false, and it can raise an error if evaluation of the first expression
raises an error. As a result of these rules, a logical expression is
not deterministic in the presence of errors, as illustrated in the examples
below.</p>
         <p>Here are some examples of logical expressions:</p>


         <ulist>

            <item>
               <p>The following expressions return
<code>true</code>:</p>
               <eg role="parse-test"><![CDATA[1 eq 1 and 2 eq 2]]></eg>
               <eg role="parse-test"><![CDATA[1 eq 1 or 2 eq 3]]></eg>
            </item>

            <item>
               <p>The following
expression may return either <code>false</code> or raise a <termref
                     def="dt-dynamic-error">dynamic error</termref>
                  <phrase role="xpath"> (in <termref def="dt-xpath-compat-mode"
                        >XPath 1.0 compatibility mode</termref>, the result must be <code>false</code>)</phrase>:</p>
               <eg role="parse-test"><![CDATA[1 eq 2 and 3 idiv 0 = 1]]></eg>
            </item>

            <item>
               <p>The
following expression may return either <code>true</code> or raise a
<termref
                     def="dt-dynamic-error">dynamic error</termref>
                  <phrase role="xpath"> (in <termref def="dt-xpath-compat-mode"
                        >XPath 1.0 compatibility mode</termref>, the result must be <code>true</code>)</phrase>:</p>
               <eg role="parse-test"><![CDATA[1 eq 1 or 3 idiv 0 = 1]]></eg>
            </item>

            <item>
               <p>The
following expression must raise a <termref def="dt-dynamic-error"
                     >dynamic error</termref>:</p>
               <eg role="parse-test"><![CDATA[1 eq 1 and 3 idiv 0 = 1]]></eg>
            </item>
         </ulist>

         <p>In addition to and- and or-expressions, &language; provides a
function named <function>fn:not</function> that takes a general sequence as
parameter and returns a boolean value.  The <function>fn:not</function> function
is defined in <bibref
               ref="xpath-functions-40"
               />. The
<function>fn:not</function> function reduces its parameter to an <termref
               def="dt-ebv"
               >effective boolean value</termref>. It then returns
<code>true</code> if the effective boolean value of its parameter is
<code>false</code>, and <code>false</code> if the effective boolean
value of its parameter is <code>true</code>. If an error is
encountered in finding the effective boolean value of its operand,
<function>fn:not</function> raises the same error.</p>


      </div2>
      <div2 role="xquery" id="id-constructors">
         <head role="xquery">Node Constructors</head>
         <p>XQuery provides node constructors that can create XML nodes within a query.</p>

         <scrap>
            <prodrecap ref="NodeConstructor"/>
         </scrap>

         <p>Constructors are provided for element, attribute, document, text, comment, and processing instruction nodes. Two kinds of constructors are provided: <term>direct constructors</term>, which use an XML-like notation that can incorporate enclosed expressions, and <term>computed constructors</term>, which use a notation based on enclosed expressions. </p>

         <p>The rest of this section contains a conceptual description of the semantics of various kinds of constructor expressions. An XQuery implementation is free to use any implementation technique that produces the same result as the processing steps described here.</p>

         <div3 id="id-element-constructor">
            <head>Direct Element Constructors</head>
            <p>An <term>element constructor</term> creates an element node. <termdef
                  term="direct element constructor" id="dt-direct-elem-const"
                     >A <term>direct element constructor</term> is a form of element constructor in which the name of the constructed element is a constant.</termdef> Direct element constructors are based on standard XML notation. For example, the following expression is a direct element constructor
that creates a <code>book</code> element containing an attribute and some nested elements:</p>
            <eg role="parse-test"><![CDATA[<book isbn="isbn-0060229357">
  <title>Harold and the Purple Crayon</title>
  <author>
    <first>Crockett</first>
    <last>Johnson</last>
  </author>
</book>]]></eg>
            <p>If the element name in a direct element constructor has a namespace prefix, the namespace prefix
               is resolved to a namespace URI using the <termref def="dt-static-namespaces"/>. 
               If the element name has no namespace prefix, <phrase diff="chg" at="2023-10-16">the 
                  namespace binding for the zero-length prefix in the <termref def="dt-static-namespaces"/>
               is used; if there is no such binding, the element name will be in no namespace</phrase>.</p>
            <note><p>The statically known namespaces 
               may be affected by <termref def="dt-namespace-decl-attr"
                  >namespace declaration attributes</termref> 
               found inside the element constructor.</p></note>
            <p>The namespace prefix of the element name is retained after 
               expansion of the <termref
                  def="dt-qname">lexical QName</termref>, as described in 
               <bibref
                  ref="xpath-datamodel-40"/>. The resulting <termref def="dt-expanded-qname"
                  >expanded QName</termref> 
               becomes the <code>node-name</code> property of the constructed element node.</p>
            <p>In a direct element constructor, the name used in the end tag must exactly match the name
used in the corresponding start tag, including its prefix or absence of a prefix  <errorref
                  class="ST" code="0118"/>.</p>

            <p>In a direct element constructor, curly brackets 
               (<char>U+007B</char> and <char>U+007D</char>) delimit  <termref
                  def="dt-enclosed-expression"
               >enclosed expressions</termref>, distinguishing them from literal text. Enclosed expressions
are evaluated and replaced by their value, as illustrated by the following
example:</p>
            <eg role="parse-test"><![CDATA[<example>
  <p> Here is a query. </p>
  <eg> $b/title </eg>
  <p> Here is the result of the query. </p>
  <eg>{ $b/title }</eg>
</example>]]></eg>
            <p>The above query might generate the following result (whitespace has been added for readability to this result and other result examples in this document):</p>
            <eg role="parse-test"><![CDATA[
<example>
  <p> Here is a query. </p>
  <eg> $b/title </eg>
  <p> Here is the result of the query. </p>
  <eg><title>Harold and the Purple Crayon</title></eg>
</example>]]></eg>
            <p>Since XQuery uses <char>U+007B</char> and <char>U+007D</char> to delimit enclosed expressions, some
convention is needed to denote a curly bracket used as an ordinary character. For
this purpose, a pair of identical curly bracket characters within the content of an element or attribute are interpreted by XQuery  as a single curly bracket
character (that is, the pair <code>"{{"</code> represents the
  character <char>U+007B</char> and the pair <code>"}}"</code> represents
  the character <char>U+007D</char>.) Alternatively, the <termref
                  def="dt-character-reference">character references</termref>
               <code>&amp;#x7b;</code> and <code>&amp;#x7d;</code> can be used to denote curly bracket characters.  
               A single <char>U+007B</char> is interpreted as the beginning delimiter for an
  enclosed expression. A single <char>U+007D</char>
  without a matching left curly bracket is treated as a <termref
                  def="dt-static-error">static error</termref>
               <errorref class="ST" code="0003"/>.</p>
            <p>Within an enclosed expression, the handling of expressions that start with <char>U+007B</char> or that
            end with <char>U+007D</char> is the same as for <specref ref="id-string-templates"/>.</p>
            <p>The result of an element constructor is a new element node, with its own node identity. All the attribute and descendant nodes of the new element node are also new nodes with their own identities, even if they are copies of existing nodes.</p>
            <div4 id="id-attributes">
               <head>Attributes</head>
               <p>The start tag of a direct element constructor may contain one or more attributes. As in XML, each attribute is specified by a name and a value. In a direct element constructor, the name of each attribute is specified by a constant <termref
                     def="dt-qname"
                     >lexical QName</termref>, and the value of the attribute is specified by a string of characters enclosed in single or double quotes. As in the main content of the element constructor, an attribute value may contain  <termref
                     def="dt-enclosed-expression"
                  >enclosed expressions</termref>, which are evaluated and replaced by their value during processing of the element constructor.</p>
               <p>Each attribute in a direct element constructor creates a new attribute node, with its own node identity, whose parent is the constructed element node. However, note that <termref
                     def="dt-namespace-decl-attr"
                     >namespace declaration attributes</termref> (see <specref ref="id-namespaces"
                  />) do not create attribute nodes.</p>
               <p>If an attribute name has a namespace prefix, the prefix is resolved to a namespace URI using the <termref
                     def="dt-static-namespaces"
                     >statically known namespaces</termref>. If the attribute name  has no namespace prefix, the attribute is in no namespace. Note that the statically known namespaces used in  resolving an attribute name may be affected by <termref
                     def="dt-namespace-decl-attr"
                     >namespace declaration attributes</termref> that are found inside the same element constructor. The namespace prefix of the attribute name is retained after expansion of the <termref
                     def="dt-qname">lexical QName</termref>, as described in <bibref
                     ref="xpath-datamodel-40"/>. The resulting <termref def="dt-expanded-qname"
                     >expanded QName</termref> becomes the <code>node-name</code> property of the constructed attribute node.</p>
               <p>If the attributes in a direct element constructor do not have distinct <termref
                     def="dt-expanded-qname"
                     >expanded
			        QNames</termref> as their respective <code>node-name</code> properties, a <termref
                     def="dt-static-error">static error</termref> is raised <errorref class="ST"
                     code="0040"/>.</p>
               <p>Conceptually, an attribute (other than a namespace declaration attribute) in a direct element constructor is processed by the following steps:</p>

               <olist>

                  <item>

                     <p>Each consecutive sequence of literal characters in the
	attribute content is processed as a string literal containing
	those characters, with the following exceptions:</p>
                     <olist>
                        <item>
                           <p>Each occurrence of two consecutive <code>{</code>
             characters is replaced by a single <code>{</code> character.
             </p>
                        </item>
                        <item>
                           <p>Each occurrence of two consecutive <code>}</code>
             characters is replaced by a single <code>}</code> character.
             </p>
                        </item>
                        <item>
                           <p>Each occurrence of <nt def="EscapeQuot"
                                 >EscapeQuot</nt> is replaced by a single
             <code>"</code> character.  </p>
                        </item>
                        <item>
                           <p>Each occurrence of <nt def="EscapeApos"
                                 >EscapeApos</nt> is replaced by a single
             <code>'</code> character.  </p>
                        </item>
                     </olist>
                     
                     <p>Within an enclosed expression, the handling of expressions that start with <char>U+007B</char> or that
            end with <char>U+007D</char> is the same as for <specref ref="id-string-templates"/>.</p>

                     <p>Attribute value normalization is then applied to
          normalize whitespace and expand <termref
                           def="dt-character-reference"
                           >character references</termref>
          and <termref
                           def="dt-predefined-entity-reference"
                           >predefined
          entity references</termref>. 
	  The rules for attribute value
	  normalization are the rules from Section 3.3.3 of [XML 1.0]
	  or Section 3.3.3 of [XML 1.1] (it is implementation-defined
	  which version is used). The rules are applied as though the
	  type of the attribute were CDATA (leading and trailing
	  whitespace characters are not stripped.)
          </p>
                  </item>


                  <item>
                     <p>Each enclosed expression is converted to a string as follows:</p>

                     <olist>

                        <item>
                           <p>
                              <termref def="dt-atomization"
                              >Atomization</termref> is applied to the value of the enclosed expression, converting it to a sequence of atomic items.</p>

                        </item>

                        <item>
                           <p>If the result of atomization is an empty sequence, the result is the zero-length string. Otherwise, each atomic item in the atomized sequence is cast into a string.</p>
                        </item>

                        <item>
                           <p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair.</p>
                        </item>
                     </olist>
                  </item>

                  <item>
                     <p>Adjacent strings resulting from the above steps are concatenated with no intervening blanks. The resulting string becomes the <code>string-value</code> property of the attribute node. The attribute node is given a <termref
                           def="dt-type-annotation"
                           >type annotation</termref> of <code>xs:untypedAtomic</code> (this type annotation may change if the parent element is validated). The <code>typed-value</code> property of the attribute node is the same as its <code>string-value</code>, as an instance of <code>xs:untypedAtomic</code>.</p>
                  </item>

                  <item>
                     <p>The <code>parent</code> property of the attribute node is set to the element node constructed by the direct element constructor that contains this attribute.</p>
                  </item>

                  <item>
                     <p>If the attribute name is <code>xml:id</code>, then <code>xml:id</code> processing is performed as defined in <bibref
                           ref="XMLID"
                           />. This ensures that the attribute has the type <code>xs:ID</code> and that its value is properly normalized. If an error is encountered during <code>xml:id</code> processing, an implementation may raise a <termref
                           def="dt-dynamic-error">dynamic error</termref>
                        <errorref class="DY" code="0091"/>.</p>
                  </item>

                  <item>
                     <p>If the attribute name is <code>xml:id</code>, the <code>is-id</code> property of the resulting attribute node is set to <code>true</code>; otherwise the <code>is-id</code> property is set to <code>false</code>. The <code>is-idrefs</code> property of the attribute node is unconditionally set to <code>false</code>.</p>
                  </item>
               </olist>
               <ulist>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test">&lt;shoe size="7"/&gt;</eg>
                     <p>The string value of the <code>size</code> attribute is <code>"7"</code>.</p>
                  </item>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test">&lt;shoe size="{ 7 }"/&gt;</eg>
                     <p>The string value of the <code>size</code> attribute is <code>"7"</code>.</p>
                  </item>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test">&lt;shoe size="{ () }"/&gt;</eg>
                     <p>The string value of the <code>size</code> attribute is the zero-length string.</p>
                  </item>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test">&lt;chapter ref="[{ 1, 5 to 7, 9 }]"/&gt;</eg>
                     <p>The string value of the <code>ref</code> attribute is <code>"[1 5 6 7 9]"</code>.</p>
                  </item>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test"
                        >&lt;shoe size="As big as { $hat/@size }"/&gt;</eg>
                     <p>The string value of the <code>size</code> attribute is the
string <code>"As big as "</code>, concatenated with the string value of the
node denoted by the expression
  <code>$hat/@size</code>.</p>
                  </item>
               </ulist>
            </div4>
            <div4 id="id-namespaces">
               <head>Namespace Declaration Attributes</head>
               <changes>
                  <change issue="65" PR="753" date="2023-10-31">
                     The <termref def="dt-default-namespace-elements-and-types"/> can now be declared to be fixed
                     for a query module, meaning it is unaffected by a namespace declaration appearing on a direct
                     element constructor.
                   </change>
               </changes>
               <p>The names of
  a constructed element and its attributes may be <termref
                     def="dt-qname"
                     >lexical QNames</termref> that
  include <term>namespace prefixes</term>. Namespace prefixes can be
  bound to namespaces in the <termref
                     def="dt-prolog"
                     >Prolog</termref> or by  <term>namespace
  declaration attributes</term>. It is a
  <termref
                     def="dt-static-error"
                     >static error</termref> to use a
  namespace prefix that has not been bound to a namespace <errorref
                     class="ST" code="0081"/>.</p>

               <p at="XQ.E13">
                  <termdef term="namespace declaration attribute" id="dt-namespace-decl-attr"
                        >A <term>namespace declaration
attribute</term> is used inside a direct element constructor. Its
purpose is to bind a namespace prefix <phrase diff="add" at="A">(including the zero-length prefix)</phrase> for
the constructed element node, including its attributes.</termdef>
Syntactically, a namespace declaration attribute has the form of an
attribute with namespace prefix <code>xmlns</code>, or with name
<code>xmlns</code> and no namespace prefix. All the namespace
declaration attributes of a given element must have distinct names
<errorref
                     class="ST" code="0071"
                  />. Each namespace declaration
attribute is processed as follows:</p>


               <ulist>

                  <item at="XQ.E13">
                     <p>The value of the namespace declaration attribute (a <nt
                           def="DirAttributeValue"
                           >DirAttributeValue</nt>) is processed as follows. If the <nt
                           def="DirAttributeValue">DirAttributeValue</nt> contains an <nt
                           def="EnclosedExpr"
                           >EnclosedExpr</nt>, a static error is raised <errorref class="ST"
                           code="0022"
                           />. Otherwise, it is processed as described in rule 1 of <specref
                           ref="id-attributes"
                           />. An implementation may raise a static error<errorref class="ST"
                            code="0046"/> if the resulting value is of
                           nonzero length and is neither an absolute URI nor a
                           relative URI. The resulting value is used as the namespace
                           URI in the following rules.
                           </p>
                  </item>

                  <item>
                     <p>If the prefix of the attribute name is <code>xmlns</code>, then the
                     local part of the attribute name is interpreted as a namespace prefix.
                     This prefix and the namespace URI are added to the
                     <termref def="dt-static-namespaces"
                           >statically known namespaces</termref>
                     of the constructor expression (overriding any existing binding of
                     the given prefix), and are also added as a namespace binding to the
                     <termref def="dt-in-scope-namespaces"
                           >in-scope namespaces</termref>
                        of the constructed element. If the namespace URI is a zero-length
                        string and the implementation supports <bibref
                                   ref="XMLNAMES11"
                                   />,
                        any existing namespace binding for the given prefix is removed from the
                        <termref
                                   def="dt-in-scope-namespaces"
                                   >in-scope namespaces</termref>
                        of the constructed element and from the
                        <termref
                                   def="dt-static-namespaces"
                                   >statically known namespaces</termref>
                        of the constructor expression. If the namespace URI is a zero-length
                        string and the implementation does not support <bibref
                                   ref="XMLNAMES11"/>,
                        a static error is raised <errorref
                                   code="0085" class="ST"/>. It is
                        <termref
                                   def="dt-implementation-defined"
                                   >implementation-defined</termref>
                        whether an implementation supports <bibref
                                   ref="XMLNAMES"/> or
                        <bibref ref="XMLNAMES11"
                                />.
                     </p>
                  </item>

                  <item>
                     <p>If the name of the namespace declaration attribute is <code>xmlns</code>
                        with no prefix, then:</p>
                     <ulist>
                        <item><p>If the namespace URI is a zero-length string, then:</p>
                           <ulist>
                              <item><p>Any no-prefix namespace binding is removed from the
                                 <termref def="dt-in-scope-namespaces"
                                    >in-scope namespaces</termref> of the constructed element
                                 and from the <termref def="dt-static-namespaces"
                                    >statically known namespaces</termref>
                                 of the constructor expression.</p></item>
                              <item><p>Unless
                                 the query prolog contains a default namespace declaration or import schema declaration
                                 defining the <termref def="dt-default-namespace-elements-and-types"/> as being
                                 <code>fixed</code>, the <termref def="dt-default-namespace-elements-and-types"/> 
                                 in the static context of the element constructor is set to <xtermref ref="dt-absent" spec="DM40"/>.</p></item>
                           </ulist>
                        </item>
                        <item><p>Otherwise (when the namespace URI is not a zero-length string):
                           <ulist>
                              <item><p>The namespace URI is added (with no prefix) to the <termref
                                 def="dt-in-scope-namespaces">in-scope namespaces</termref> of the constructed element 
                                 (overriding any existing binding of the zero-length prefix), 
                                 and to the <termref def="dt-static-namespaces"
                                    >statically known namespaces</termref>
                                 of the constructor expression.</p></item>
                              <item><p>Unless
                                 the query prolog contains a default namespace declaration or import schema declaration
                                 defining the <termref def="dt-default-namespace-elements-and-types"/> as being
                                 <code>fixed</code>, the <termref def="dt-default-namespace-elements-and-types"/> 
                                 in the static context of the constructor expression is set to the specified namespace URI.</p></item>
                           </ulist>
                        </p></item>
                     </ulist>
                    
                  </item>
 
                  <item>
                     <p>It is a <termref def="dt-static-error">static error</termref>
                        <errorref class="ST" code="0070"/> if a namespace declaration
                attribute attempts to do any of the following:
                <ulist>
                           <item>
                              <p>Bind the prefix <code>xml</code> to some namespace URI
                      other than <code>http://www.w3.org/XML/1998/namespace</code>.
                   </p>
                           </item>
                           <item>
                              <p>Bind a prefix other than <code>xml</code> to the namespace
                      URI <code>http://www.w3.org/XML/1998/namespace</code>.
                   </p>
                           </item>
                           <item>
                              <p>Bind the prefix <code>xmlns</code> to any namespace URI.
                   </p>
                           </item>
                           <item>
                              <p>Bind a prefix to the namespace
                      URI <code>http://www.w3.org/2000/xmlns/</code>.
                   </p>
                           </item>
                        </ulist>
                     </p>
                  </item>

               </ulist>

               <p> A namespace declaration attribute does not cause an attribute node to be created. </p>
               <p>The following examples illustrate namespace declaration attributes:</p>
               <ulist>

                  <item>
                     <p>In this element constructor, a namespace declaration attribute
                        is used to set the default namespace
                        to <code>http://example.org/animals</code>:<eg
                           role="parse-test"><![CDATA[<cat xmlns="http://example.org/animals">
  <breed>{ variety/@name }</breed>
</cat>]]></eg>
                     </p>
                     <p diff="add" at="2023-10-16">More specifically:</p>
                     <ulist>
                        <item><p>The expanded name of the constructed element will be 
                           <code>Q{http://example.org/animals}cat</code>.</p></item>
                        <item><p>The constructed element will have a namespace binding
                           that associates the empty prefix with the namespace URI 
                           <code>http://example.org/animals</code>.</p></item>
                        <item><p>The static context for evaluation of any expressions within the
                        element constructor will include a binding of the empty prefix
                        to the namespace URI <code>http://example.org/animals</code>. This ensures
                        that the nested <code>breed</code> element will also be in the namespace
                           <code>http://example.org/animals</code>.</p></item>
                        <item><p>The <termref def="dt-default-namespace-elements-and-types"/>
                           within the element constructor will be <code>http://example.org/animals</code>,
                        which means that the element name <code>variety</code> is also interpreted
                        as being in this namespace. This effect may be unwanted, since the document
                        containing the context node may well use a different default namespace. 
                        In XQuery 4.0 this effect can
                        be prevented by declaring, in the query prolog, that the 
                           <termref def="dt-default-namespace-elements-and-types"/> is <code>fixed</code>.
                        Alternatively the path expression can be written <code>Q{}variety/@name</code>
                        to make it explicit that <code>variety</code> refers to a no-namespace element.</p></item>
                     </ulist>
                  </item>

                  <item>
                     <p>In this element constructor, namespace declaration attributes are used to bind the namespace prefixes <code>metric</code> and <code>english</code>:</p>
                     <eg role="parse-test"><![CDATA[<box xmlns:metric="http://example.org/metric/units"
     xmlns:english = "http://example.org/english/units">
  <height> <metric:meters>3</metric:meters> </height>
  <width> <english:feet>6</english:feet> </width>
  <depth> <english:inches>18</english:inches> </depth>
</box>]]></eg>
                  </item>
               </ulist>
            </div4>
            <div4 id="id-content">
               <head>Content</head>
               <p>The part of a direct element constructor between the start tag and the end tag is called the <term>content</term> of the element constructor. This content may consist of text characters (parsed as <nt
                     def="ElementContentChar"
                     >ElementContentChar</nt>), nested direct constructors, <nt def="CDataSection"
                     >CDataSections</nt>, character and <termref
                     def="dt-predefined-entity-reference"
                     >predefined entity references</termref>, and <termref
                     def="dt-enclosed-expression"
                  >enclosed expressions</termref>. In general, the value of an enclosed expression may be any sequence of nodes and/or atomic items. Enclosed expressions can be used in the content of an element  constructor to compute both the content and the attributes of the constructed node.</p>

               <p>Conceptually, the content of an element constructor is processed as
follows:</p>

               <olist>

                  <item>
                     <p>The content is evaluated to produce a
sequence of nodes called the <term>content sequence</term>, as
follows:</p>

                     <olist>

                        <item>
                           <p>If the <termref def="dt-boundary-space-policy"
                                 >boundary-space policy</termref> in the <termref
                                 def="dt-static-context"
                                 >static context</termref> is <code>strip</code>, <termref
                                 def="dt-boundary-whitespace"
                                 >boundary whitespace</termref> is identified and deleted (see <specref
                                 ref="id-whitespace"
                              /> for the definition of boundary whitespace.)</p>
                        </item>

                        <item>
                           <p>
                              <termref def="dt-predefined-entity-reference"
                                 >Predefined entity references</termref>
and <termref
                                 def="dt-character-reference"
                                 >character references</termref> are expanded into their
referenced strings, as described in <specref
                                 ref="id-literals"/>. Characters inside a <nt def="CDataSection"
                                 >CDataSection</nt>, including special characters such as <code>&lt;</code> and <code>&amp;</code>, are treated as literal characters rather than as markup characters (except for the sequence <code>]]&gt;</code>, which terminates the CDataSection).</p>
                        </item>

                        <item>
                           <p>Each consecutive sequence of
literal characters evaluates to a single text node containing the
characters.</p>
                        </item>

                        <item>
                           <p>Each nested direct constructor is evaluated according to the rules in <specref
                                 ref="id-element-constructor"/> or <specref
                                 ref="id-otherConstructors"
                              />, resulting in a new element, comment, or processing instruction node. Then:</p>

                           <olist>

                              <item>
                                 <p>The <code>parent</code> property of the resulting node is then set to the newly constructed element node.</p>
                              </item>

                              <item>
                                 <p>The <code>base-uri</code> property of the
resulting node, and of each of its descendants, is set to be the same as that
of its new parent, unless it (the child node) has an <code>xml:base</code> attribute, in
which case its <code>base-uri</code> property is set to the value of that attribute,
<termref
                                       def="dt-resolve-relative-uri"
                                       >resolved (if it is relative)</termref> against the <code>base-uri</code> property of its new parent
node.</p>
                              </item>
                           </olist>
                        </item>

                        <item>
                           <p>Enclosed expressions are evaluated as follows: </p>

                           <olist>
                              <item>
                                 <p>Each array returned by the enclosed expression is flattened by calling the function <code>array:flatten()</code> before the steps that follow.</p>
                              </item>

                              <item>
                                 <p>If an enclosed expression returns a <termref def="dt-function-item"/>, a type error is raised <errorref
                                       class="TY" code="0105"/>.</p>
                              </item>

                              <item>
                                 <p>For each adjacent sequence of one or more atomic items returned by an enclosed expression, a new text node is constructed, containing the result of casting each atomic item to a string, with a single space character inserted between adjacent values.</p>
                                 <note>
                                    <p>The insertion of blank characters between adjacent values applies even if one or both of the values is a zero-length string.</p>
                                 </note>
                              </item>

                              <item>
                                 <p>For each node returned by an enclosed expression, a new copy is made of the given node and all nodes that have the given node as an ancestor,  collectively referred to as <term>copied nodes</term>. The properties of the copied nodes are as follows:</p>

                                 <olist>

                                    <item>
                                       <p>Each copied node receives a new node identity.</p>
                                    </item>

                                    <item>
                                       <p>The <code>parent</code>, <code>children</code>, and <code>attributes</code> properties of the copied nodes are set so as to preserve their inter-node relationships. For the topmost node (the node directly returned by the enclosed expression), the <code>parent</code> property is set to the node constructed by this constructor.</p>
                                    </item>

                                    <item>
                                       <p>If <termref def="dt-construction-mode"
                                             >construction mode</termref> in the <termref
                                             def="dt-static-context"
                                             >static context</termref> is <code>strip</code>:</p>

                                       <olist>

                                          <item>
                                             <p>If the copied node is an element node, its <termref
                                                  def="dt-type-annotation"
                                                  >type annotation</termref> is set to  <code>xs:untyped</code>. Its <code>nilled</code>, <code>is-id</code>, and <code>is-idrefs</code> properties are set to <code>false</code>.</p>
                                          </item>

                                          <item>
                                             <p>If the copied node is an attribute node, its <code>type-name</code> property  is set to <code>xs:untypedAtomic</code>. Its <code>is-idrefs</code> property is set to <code>false</code>. Its <code>is-id</code> property is set to <code>true</code> if the qualified name of the attribute node is <code>xml:id</code>; otherwise it is set to <code>false</code>.</p>
                                          </item>

                                          <item>
                                             <p>The <code>string-value</code> of each copied element and attribute node remains unchanged, and its <code>typed-value</code> becomes equal to its <code>string-value</code> as an instance of <code>xs:untypedAtomic</code>.<note>
                                                  <p> Implementations that store only the <termref
                                                  def="dt-typed-value"
                                                  >typed value</termref> of a node are required at this point to convert the typed value to a string form.</p>
                                                </note>
                                             </p>
                                          </item>
                                       </olist>
                                       <p>On the other hand, if <termref def="dt-construction-mode"
                                             >construction mode</termref> in the <termref
                                             def="dt-static-context"
                                             >static context</termref> is <code>preserve</code>, the <code>type-name</code>, <code>nilled</code>, <code>string-value</code>, <code>typed-value</code>, <code>is-id</code>, and <code>is-idrefs</code> properties of the copied nodes are preserved.</p>
                                    </item>

                                    <item>
                                       <p>The <code>in-scope-namespaces</code> property of a copied element node is
determined by the following rules. In applying these rules, the default
namespace or absence of a default namespace is treated like any other
namespace binding:</p>

                                       <olist>

                                          <item>
                                             <p>If <termref def="dt-copy-namespaces-mode"
                                                  >copy-namespaces mode</termref> specifies <code>preserve</code>, all in-scope-namespaces of the original element are
retained in the new copy.
If <termref
                                                  def="dt-copy-namespaces-mode"
                                                  >copy-namespaces mode</termref> specifies <code>no-preserve</code>, the new copy retains only those in-scope namespaces of the original element that are used in the names of the element and its
attributes.</p>
                                          </item>

                                          <item>
                                             <p>If <termref def="dt-copy-namespaces-mode"
                                                  >copy-namespaces mode</termref> specifies <code>inherit</code>, the copied node inherits all the in-scope namespaces of the constructed node, augmented and overridden by the in-scope namespaces of the original element that were preserved by the preceding rule. If <termref
                                                  def="dt-copy-namespaces-mode"
                                                  >copy-namespaces mode</termref> specifies <code>no-inherit</code>, the copied node does not inherit any in-scope namespaces from the constructed node.</p>
                                          </item>

                                       </olist>
                                    </item>



                                    <item>
                                       <p>An enclosed expression in the content of an element constructor may cause one or more existing nodes to be copied. Type error
<errorref
                                             class="TY" code="0086"
                                          />
is raised in the following cases:</p>
                                       <olist>
                                          <item>
                                             <p>
An element node is copied, and the
<termref
                                                  def="dt-typed-value"
                                                  >typed value</termref> of the element node or one of its attributes is
<termref
                                                  def="dt-namespace-sensitive"
                                                  >namespace-sensitive</termref>,
and <termref
                                                  def="dt-construction-mode"
                                                  >construction mode</termref>
is <code>preserve</code>, and
<termref
                                                  def="dt-copy-namespaces-mode"
                                                  >copy-namespaces mode</termref>
is <code>no-preserve</code>.
</p>
                                          </item>
                                          <item>
                                             <p>
An attribute node is copied but its parent element node is not
copied, and the <termref
                                                  def="dt-typed-value"
                                                  >typed value</termref>
of the copied attribute node is
<termref
                                                  def="dt-namespace-sensitive"
                                                  >namespace-sensitive</termref>,
and <termref
                                                  def="dt-construction-mode"
                                                  >construction mode</termref>
is <code>preserve</code>.</p>
                                          </item>
                                       </olist>

                                       <note>
                                          <p>
                The rationale for error <errorref
                                                class="TY" code="0086"
                                             /> is as follows:
                It is not possible to preserve the type of a QName without also preserving
                the namespace binding that defines the prefix of the QName.</p>
                                       </note>
                                    </item>



                                    <item>
                                       <p>When an element or processing instruction node is copied, its <code>base-uri</code>
property is set to be the same as that of its new parent,
with the following exception: if a copied element node has an <code>xml:base</code> attribute, its <code>base-uri</code> property is set to
the value of that attribute, <termref
                                             def="dt-resolve-relative-uri"
                                             >resolved (if it is relative)</termref> against
the <code>base-uri</code> property of the new parent node.</p>
                                    </item>

                                    <item>
                                       <p>All other properties of the copied nodes are preserved.</p>
                                    </item>
                                 </olist>
                              </item>
                           </olist>
                        </item>
                     </olist>
                  </item>

                  <item>
                     <p> If the content sequence contains a document node, the document node is replaced in the content sequence by its children.</p>
                  </item>

                  <item>
                     <p>Adjacent text nodes in the content sequence are merged into a single text node by concatenating their contents, with no intervening blanks. After concatenation, any text node whose content is a zero-length string is deleted from the content sequence.</p>
                  </item>



                  <item>
                     <p>If the content sequence contains an attribute node or a
namespace node following a node that is not an attribute node or a
namespace node, a <termref
                           def="dt-type-error">type error</termref> is
raised <errorref class="TY"
                           code="0024"/>.</p>
                  </item>




                  <item>
                     <p>The properties of the newly constructed element node are determined as follows:</p>

                     <olist>

                        <item>
                           <p>
                              <code>node-name</code> is the <termref def="dt-expanded-qname"
                                 >expanded QName</termref> resulting from resolving the element name in the start tag, including its original namespace prefix (if any), as described in <specref
                                 ref="id-element-constructor"/>.</p>
                        </item>

                        <item>
                           <p>
                              <code>parent</code> is set to empty.</p>
                        </item>

                        <item>
                           <p>
                              <code>attributes</code> consist of all the attributes specified in the start tag as described in <specref
                                 ref="id-attributes"
                                 />, together with all the attribute nodes in the content sequence, in <termref
                                 def="dt-implementation-dependent"
                                 >implementation-dependent</termref> order. Note that the <code>parent</code> property of each of these attribute nodes has been set to the newly constructed element node. If two or more attributes have the same <code>node-name</code>,  a <termref
                                 def="dt-dynamic-error">dynamic error</termref> is raised <errorref
                                 class="DY" code="0025"
                                 />. If an attribute named <code>xml:space</code> has a value other than <code>preserve</code> or <code>default</code>, a <termref
                                 def="dt-dynamic-error"
                                 >dynamic error</termref>  may be raised <errorref code="0092"
                                 class="DY"/>.</p>
                        </item>

                        <item>
                           <p>
                              <code>children</code> consist of all the element, text, comment, and processing
   instruction nodes in the content sequence. Note that the <code>parent</code> property of each of these nodes has been set to the newly constructed element node.</p>
                        </item>

                        <item>
                           <p>
                              <code>base-uri</code> is set to the following value:</p>

                           <olist> 
                              <item>
                                    <p>If the constructed node has an attribute named <code>xml:base</code>, then the value of this attribute, <termref
                                          def="dt-resolve-relative-uri"
                                          >resolved (if it is relative)</termref> against the
                                       <phrase diff="chg" at="2023-05-19"><termref def="dt-executable-base-uri"/></phrase>, as described in
                                       <specref ref="id-resolve-relative-uri"/>. </p>
                              </item> 
                              <item>
                                    <p>Otherwise,
                                       the <phrase diff="chg" at="2023-05-19"><termref def="dt-executable-base-uri"/></phrase>.</p>
                              </item>
                           </olist>
                           
                        </item>

                        <item>
                           <p>
                              <code>in-scope-namespaces</code> consist of all the namespace bindings resulting from namespace declaration attributes as described in <specref
                                 ref="id-namespaces"
                                 />, and possibly additional namespace bindings as described in <specref
                                 ref="id-ns-nodes-on-elements"/>.</p>
                        </item>

                        <item>
                           <p>The <code>nilled</code> property is <code>false</code>.</p>
                        </item>

                        <item>
                           <p>The <code>string-value</code> property is equal to the concatenated contents of the text-node descendants in document order. If there are no text-node descendants, the <code>string-value</code> property is a zero-length string.</p>
                        </item>

                        <item>
                           <p>The <code>typed-value</code> property is equal to the <code>string-value</code> property, as an instance of <code>xs:untypedAtomic</code>.</p>
                        </item>

                        <item>
                           <p>If <termref def="dt-construction-mode"
                                 >construction mode</termref> in the <termref
                                 def="dt-static-context"
                                 >static context</termref> is <code>strip</code>, the <code>type-name</code> property is <code>xs:untyped</code>. On the other hand, if construction mode is <code>preserve</code>, the <code>type-name</code> property is <code>xs:anyType</code>.</p>
                        </item>

                        <item>
                           <p>The <code>is-id</code> and <code>is-idrefs</code> properties are set to <code>false</code>.</p>
                        </item>
                     </olist>
                  </item>
               </olist>
               <ulist>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test">&lt;a&gt;{ 1 }&lt;/a&gt;</eg>
                     <p>The constructed element node has one child, a text node containing the value <code>"1"</code>.</p>
                  </item>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test">&lt;a&gt;{ 1, 2, 3 }&lt;/a&gt;</eg>
                     <p>The constructed element node has one child, a text node containing the value <code>"1 2 3"</code>.</p>
                  </item>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test">&lt;c&gt;{ 1 }{ 2 }{ 3 }&lt;/c&gt;</eg>
                     <p>The constructed element node has one child, a text node containing the value <code>"123"</code>.</p>
                  </item>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test">&lt;b&gt;{ 1, "2", "3" }&lt;/b&gt;</eg>
                     <p>The constructed element node has one child, a text node containing the value <code>"1 2 3"</code>.</p>
                  </item>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test">&lt;fact&gt;I saw 8 cats.&lt;/fact&gt;</eg>
                     <p>The constructed element node has one child, a text node containing the value <code>"I saw 8 cats."</code>.</p>
                  </item>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test"
                        >&lt;fact&gt;I saw { 5 + 3 } cats.&lt;/fact&gt;</eg>
                     <p>The constructed element node has one child, a text node containing the value <code>"I saw 8 cats."</code>.</p>
                  </item>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test"
                        >&lt;fact&gt;I saw &lt;howmany&gt;{ 5 + 3 }&lt;/howmany&gt; cats.&lt;/fact&gt;</eg>
                     <p>The constructed element node has three children: a text node containing
                        <code>"I saw </code> ", a child element node named <code>howmany</code>,
                        and a text node containing <code>" cats."</code>. The child element node
                        in turn has a single text node child containing the value <code>"8"</code>.</p>
                  </item>
               </ulist>
            </div4>
            <div4 id="id-whitespace">
               <head>Boundary Whitespace</head>
               <p>In a direct element constructor, whitespace characters may appear in the content of the constructed element. In some cases, enclosed expressions and/or nested elements may be separated only by whitespace characters.   For
example, in the expression below, the end-tag
<code>&lt;/title&gt;</code> and the start-tag <code>&lt;author&gt;</code> are separated by a newline character and four space
characters:</p>
               <eg role="parse-test"><![CDATA[<book isbn="isbn-0060229357">
  <title>Harold and the Purple Crayon</title>
  <author>
    <first>Crockett</first>
    <last>Johnson</last>
  </author>
</book>]]></eg>
               <p>
                  <termdef term="boundary whitespace" id="dt-boundary-whitespace">
                     <term>Boundary whitespace</term> is a
sequence of consecutive whitespace characters within the content of a <termref
                        def="dt-direct-elem-const"
                        >direct element constructor</termref>, that is delimited at each end either by the start or
end of the content, or by a <nt
                        def="DirectConstructor">DirectConstructor</nt>, or by an <nt
                        def="EnclosedExpr"
                        >EnclosedExpr</nt>. For this purpose, characters generated by
   <termref
                        def="dt-character-reference"
                        >character references</termref> such as <code>&amp;#x20;</code> or by <nt
                        def="CDataSection"
                     >CDataSections</nt> are not
   considered to be whitespace characters.</termdef>
               </p>
               <p>The <termref def="dt-boundary-space-policy"
                     >boundary-space policy</termref> in the <termref def="dt-static-context"
                     >static context</termref> controls whether boundary whitespace is
   preserved by element constructors. If boundary-space policy is <code>strip</code>, boundary whitespace is not considered significant and
   is discarded. On the other hand, if boundary-space policy is <code>preserve</code>, boundary whitespace is
   considered significant and is
   preserved.</p>
               <ulist>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test">&lt;cat&gt;
  &lt;breed&gt;{ $b }&lt;/breed&gt;
  &lt;color&gt;{ $c }&lt;/color&gt;
&lt;/cat&gt;</eg>
                     <p>The constructed
   <code>cat</code> element node has two child element nodes named
   <code>breed</code> and <code>color</code>. Whitespace surrounding
   the child elements will be stripped away by the element
   constructor if boundary-space policy is
   <code>strip</code>.</p>
                  </item>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test">&lt;a&gt; { "abc" } &lt;/a&gt;</eg>
                     <p>If
   boundary-space policy is <code>strip</code>, this example is equivalent to <code
                           role="parse-test"
                           >&lt;a&gt;abc&lt;/a&gt;</code>. However, if
   boundary-space policy is <code>preserve</code>, this example is
   equivalent to <code
                           role="parse-test"
                        >&lt;a&gt;&nbsp;&nbsp;abc&nbsp;&nbsp;&lt;/a&gt;</code>.</p>
                  </item>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test">&lt;a&gt; z { "abc" }&lt;/a&gt;</eg>
                     <p>Since the
   whitespace surrounding the <code>z</code> is not boundary
   whitespace, it is always preserved. This example is equivalent to
   <code
                           role="parse-test">&lt;a&gt;&nbsp;z&nbsp;abc&lt;/a&gt;</code>.</p>
                  </item>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test">&lt;a&gt;&amp;#x20;{ "abc" }&lt;/a&gt;</eg>
                     <p>This
   example is equivalent to <code role="parse-test"
                           >&lt;a&gt;&nbsp;abc&lt;/a&gt;</code>, regardless
   of the boundary-space policy, because the space generated by the <termref
                           def="dt-character-reference"
                        >character reference</termref> is not treated as a whitespace character.</p>
                  </item>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test">&lt;a&gt;{ "  " }&lt;/a&gt;</eg>
                     <p>This example constructs an element containing two space characters,
   regardless of the boundary-space policy, because whitespace inside an enclosed expression is never considered to be boundary whitespace.</p>
                  </item>

                  <item>
                     <p>Example:</p>
                     <eg role="parse-test"
                        >&lt;a&gt;{ [ "one", "little", "fish" ] }&lt;/a&gt;</eg>
                     <p>This example constructs an element containing the text <code>one little fish</code>, because the array is flattened, and the resulting sequence of atomic items is converted to a text node with a single blank between values.</p>
                  </item>

               </ulist>
               <note>
                  <p>Element constructors treat attributes named <code>xml:space</code> as ordinary attributes. An <code>xml:space</code> attribute does not affect the handling of whitespace by an element constructor.</p>
               </note>
            </div4>
         </div3>
         <div3 id="id-otherConstructors">
            <head>Other Direct Constructors</head>
            <p>XQuery allows an expression to generate a processing instruction node or a comment node. This can be accomplished by using a <term>direct processing instruction constructor</term> or a <term>direct comment constructor</term>. In each case, the syntax of the constructor expression is
based on the syntax of a similar construct in XML.</p>
            <scrap>
               <prodrecap ref="DirPIConstructor"/>
            </scrap>
            <p>A direct processing instruction constructor creates a processing instruction node whose <code>target</code> property is <nt
                  def="PITarget" id="PITarget"
                  >PITarget</nt> and whose <code>content</code> property is <nt def="DirPIContents"
                  >DirPIContents</nt>. The <code>base-uri</code> property of the node is empty.  The <code>parent</code> property of the node is empty.</p>
            <p>The <nt def="PITarget"
                  >PITarget</nt> of a processing instruction must not consist of the characters <code>XML</code> in any combination of upper and lower case,
               <phrase diff="add" at="B">and must not contain a colon</phrase>. The <nt
                  def="DirPIContents"
                  >DirPIContents</nt> of a processing instruction must not contain the string <code>"?&gt;"</code>.</p>
            <p>The following example illustrates a direct processing instruction constructor:</p>
            <eg role="parse-test">&lt;?format role="output" ?&gt;</eg>
            <p>A direct comment constructor creates a comment node whose  <code>content</code> property is <nt
                  def="DirCommentContents"
               >DirCommentContents</nt>. Its <code>parent</code> property is empty.</p>
            <p>The <nt def="DirCommentContents"
               >DirCommentContents</nt> of a comment must not contain two consecutive hyphens or end with a hyphen. These rules are syntactically enforced by the grammar shown above.</p>
            <p>The following example illustrates a direct comment constructor:</p>
            <eg role="parse-test"
               >&lt;!-- Tags are ignored in the following section --&gt;</eg>
            <note>
               <p>A direct comment constructor is different from a <nt def="Comment"
                     >comment</nt>, since a direct comment constructor actually constructs a comment node, whereas a <nt
                     def="Comment"
                  >comment</nt> is simply used in documenting a query and is not evaluated.</p>
            </note>



         </div3>


         <div3 id="id-computedConstructors">
            <head>Computed Constructors</head>

            <scrap>
               <prodrecap ref="ComputedConstructor"/>
            </scrap>

            <p>An alternative way to create nodes is by using a <term id="term-elem-ctor"
                  >computed constructor</term>. A computed
constructor begins with a keyword that identifies the type of node to
be created: <code>element</code>, <code>attribute</code>,
<code>document</code>, <code>text</code>,
<code>processing-instruction</code>, <code>comment</code>, or
<code>namespace</code>.</p>

            <p>For those kinds of nodes that have names (element, attribute, 
processing instruction, and namespace nodes), the keyword that specifies the node
kind is followed by the name of the node to be created. This name may
be specified either as an EQName or as an expression enclosed in
braces. <termdef term="name expression" id="dt-name-expression"
                     >When
an expression is used to specify the name of a constructed node, that
expression is called the <term>name expression</term> of the
constructor.</termdef>
            </p>

            <p>The following example illustrates the use of computed element and
attribute constructors in a simple case where the names of the
constructed nodes are constants. This example generates exactly the
same result as the first example in <specref
                  ref="id-element-constructor"/>:</p>

            <eg role="parse-test"><![CDATA[element book {
  attribute isbn { "isbn-0060229357" },
  element title { "Harold and the Purple Crayon" },
  element author {
    element first { "Crockett" },
    element last { "Johnson" }
  }
}]]></eg>
            
            <note><p>XQuery 4.0 allows the node name to be written in quotation
            marks (for example, <code>element "book" {}</code>, and at the same
            time it disallows the use of a defined set of language keywords
            without quotes: for example <code>element div {}</code> was allowed
            in XQuery 3.1 but must now be written <code>element "div" {}</code> or
            <code>element { "div" } {}</code>. The reason for this incompatible
            change is that allowing map constructors to omit the <code>map</code>
            keyword would otherwise create an ambiguity: consider for example the
            expression <code>element otherwise {}</code>.</p>
            
            <p>Because the list of reserved keywords may be extended in future
            versions of this specification, the safest strategy is to always to
            use quotation marks (for example <code>element "div"</code>) 
            when the node name is a simple <code>NCName</code>. To avoid
            any dependency on the default namespace context, the form
            <code>element Q{}div</code> might also be used.</p>
               
            <p>To write code that is portable between XQuery 3.1 and XQuery 4.0,
            the best advice is to use either the form <code>element { "div" }</code>
            or the form <code>element Q{}div</code>.</p>
            </note>

            <div4 id="id-computedElements">
               <head>Computed Element Constructors</head>
               
               <changes>
                  <change issue="1450" PR="1480" date="2024-10-03">
                     When the element name matches a language keyword such as <code>div</code> or <code>value</code>, 
                     it must now be written in quotes as a string literal. This is a backwards incompatible change.
                  </change>
               </changes>

               <scrap>
                  <prodrecap ref="CompElemConstructor"/>
               </scrap>

               <p>
                  <termdef term="computed element constructor" id="dt-computed-elem-const"
                        >A <term>computed element constructor</term> creates an element node, allowing both the name 
                     and the content of the node to be computed.</termdef>
               </p>
               
               <p>The element name is determined by the <nt def="CompNodeName">CompNodeName</nt>, which 
                  may be provided in a number of ways:</p>
               
               <olist>
                  <item><p>As a string literal, for example <code>element "para" {}</code>. The content
                     of the string literal must take the form of an <code>EQName</code>:
                  examples are <code>"p"</code>, <code>"html:p"</code>, <code>"Q{}p"</code>, 
                  or <code>"Q{http://www.w3.org/1999/xhtml}p"</code> <errorref class="ST" code="0151"/>. 
                     Namespace prefixes are resolved
                  in the same way as for an <code>EQName</code> written without quotation marks (see below).</p></item>
                  
                  <item><p>As a simple unprefixed <code>NCName</code>, for example <code>element para {}</code>. This
                  form is allowed only if the element name is not a reserved keyword: see
                  <loc href="#parse-note-unreserved-name">unreserved-name</loc>. 
                     The name is implicitly qualified by the namespace URI that is bound
                  to the zero-length prefix in the <termref def="dt-static-namespaces">statically known namespaces</termref>;
                     if there is no such binding, the expanded name will be in no namespace.</p></item>
                  
                  <item><p>As a prefixed <code>QName</code> (for example <code>element html:p {}</code>).
                  The prefix is expanded using the <termref def="dt-static-namespaces"
                     >statically known namespaces</termref>.
                  If expansion of the QName is not successful, a static error is raised <errorref
                           class="ST" code="0081"/>.</p></item>
                  
                  <item><p>As a <code>BracedURILiteral</code> 
                     (for example <code>element Q{http://www.w3.org/1999/xhtml}p {}</code>).</p></item>
                  
                  <item><p>As an expression in curly brackets. This is processed as follows:</p>
                  

               <olist>

                  <item>
                     <p>
                        <termref def="dt-atomization"
                           >Atomization</termref> is applied to the value of the <termref
                           def="dt-name-expression"
                           >name expression</termref>. If the result of atomization is not a single atomic item of type <code>xs:QName</code>, <code>xs:string</code>, or <code>xs:untypedAtomic</code>, a <termref
                           def="dt-type-error">type
   error</termref> is raised <errorref
                           class="TY" code="0004"/>.</p>
                  </item>

                  <item>
                     <p>If the atomized value of the <termref def="dt-name-expression"
                           >name expression</termref> is of type
   <code>xs:QName</code>, that <termref
                           def="dt-expanded-qname"
                           >expanded QName</termref> is used as the <code>node-name</code> property of the constructed
   element, retaining the prefix part of the QName.</p>
                  </item>

                  <item>
                     <p>If the atomized value of the <termref def="dt-name-expression"
                        >name expression</termref> is of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, 
                        that value is converted to an <termref def="dt-expanded-qname"
                           >expanded QName</termref> <phrase diff="add" at="A">as follows:</phrase></p>
                     <olist>
                        <item><p>Leading and trailing whitespace is removed.</p></item>
                        <item><p>If the value is an unprefixed <code>NCName</code>, 
                           the name is implicitly qualified by the namespace URI that is bound
                  to the zero-length prefix in the <termref def="dt-static-namespaces">statically known namespaces</termref>;
                     if there is no such binding, the expanded name will be in no namespace..</p></item>
                        <item><p>If the value is a lexical QName with a prefix, that prefix is <termref
                           def="dt-resolve-relative-uri">resolved to a namespace URI</termref> using the <termref
                              def="dt-static-namespaces">statically known namespaces</termref>.</p></item>
                        <item><p>If the value is a URI-qualified name (<code>Q{uri}local</code>), it
                           is converted to an <termref def="dt-expanded-qname"/> with the supplied namespace URI and
                           local name, and with no prefix.</p></item>
                     </olist>
                     <note diff="add" at="A"><p>This was under-specified in XQuery 3.1.</p></note>
                     
                     
                  </item>
                  <item><p>If conversion of the atomized <termref
                           def="dt-name-expression">name expression</termref> to an <termref
                              def="dt-expanded-qname">expanded QName</termref> is not successful, a <termref
                                 def="dt-dynamic-error">dynamic error</termref> is raised <errorref
                                    class="DY" code="0074"/>.</p></item>
               </olist>
                  
                  
                  </item>
               </olist>
               
               <p>The resulting <termref def="dt-expanded-qname">expanded QName</termref> is used as the
                        <code>node-name</code> property of the constructed element, retaining the prefix part of the QName
                        <phrase diff="add" at="A">(or its absence)</phrase>.</p>

               

               <!--	<change diff="add" at="XQ.E19"> -->
               <p>An error is raised
             <errorref class="DY"
                     code="0096"
                  /> if the node-name of the constructed
             element node has any of the following properties:
          </p>
               <ulist>
                  <item>
                     <p>Its namespace prefix is <code>xmlns</code>.
             </p>
                  </item>
                  <item>
                     <p>Its namespace URI is <code>http://www.w3.org/2000/xmlns/</code>.
             </p>
                  </item>
                  <item>
                     <p>Its namespace prefix is <code>xml</code> and its namespace
                URI is not <code>http://www.w3.org/XML/1998/namespace</code>.
             </p>
                  </item>
                  <item>
                     <p>Its namespace prefix is other than <code>xml</code> and its
                namespace URI is <code>http://www.w3.org/XML/1998/namespace</code>.
             </p>
                  </item>
               </ulist>
               
               <p>The above error <rfc2119>may</rfc2119> be raised as a <termref def="dt-static-error"/> if
               the element name is computed statically; in other cases it <rfc2119>must</rfc2119> 
                  be raised as a <termref def="dt-dynamic-error"/>.</p>


               <p>The <termref def="dt-content-expression"
                     >content expression</termref> of a computed element constructor (if present) is processed in exactly the same way as an enclosed expression in the content of a <termref
                     def="dt-direct-elem-const"
                     >direct element constructor</termref>, as described in Step 1e of <specref
                     ref="id-content"
                     />. The result of processing the content expression is a sequence of nodes called the <term>content sequence</term>. If the <termref
                     def="dt-content-expression"
                  >content expression</termref> is absent, the content sequence is an empty sequence.</p>
               <p>Processing of the computed element constructor proceeds as follows:</p>

               <olist>

                  <item>
                     <p>If the content sequence contains a document node, the document node is replaced in the content sequence by its children.</p>
                  </item>
                  <item>
                     <p>Adjacent text nodes in the content sequence are merged into a single text node by concatenating their contents, with no intervening blanks. After concatenation, any text node whose content is a zero-length string is deleted from the content sequence.</p>
                  </item>

                  <item>
                     <p> If the content
   sequence contains an attribute node or a namespace node following a node that is not an
   attribute node or a namespace node, a <termref
                           def="dt-type-error">type error</termref>
   is raised <errorref
                           class="TY" code="0024"/>.</p>
                  </item>

                  <item>
                     <p>The properties of the newly constructed element node are determined as follows:</p>

                     <olist>

                        <item>
                           <p>
                              <code>node-name</code> is the <termref def="dt-expanded-qname"
                                 >expanded QName</termref> resulting from processing the specified 
                              <nt def="CompNodeName">CompNodeName</nt>, as described above.</p>
                        </item>

                        <item>
                           <p>
                              <code>parent</code> is empty.</p>
                        </item>

                        <item>
                           <p>
                              <code>attributes</code> consist of all the attribute nodes in the content sequence, in <termref
                                 def="dt-implementation-dependent"
                                 >implementation-dependent</termref> order. Note that the <code>parent</code> property of each of these attribute nodes has been set to the newly constructed element node. If two or more  attributes have the same <code>node-name</code>,  a <termref
                                 def="dt-dynamic-error">dynamic error</termref> is raised <errorref
                                 class="DY" code="0025"
                                 />. If an attribute named <code>xml:space</code> has a value other than <code>preserve</code> or <code>default</code>, a <termref
                                 def="dt-dynamic-error"
                                 >dynamic error</termref>  may be raised <errorref code="0092"
                                 class="DY"/>.</p>
                        </item>

                        <item>
                           <p>
                              <code>children</code> consist of all the element, text, comment, and processing
   instruction nodes in the content sequence. Note that the <code>parent</code> property of each of these nodes has been set to the newly constructed element node.</p>
                        </item>

                        <item>
                           <p>
                              <code>base-uri</code> is set to the following value:

                              <olist> 
                                 <item>
                                    <p>If the constructed node has an attribute named <code>xml:base</code>, then the value of this attribute, <termref
                                          def="dt-resolve-relative-uri"
                                          >resolved (if it is relative)</termref> against the 
                                       <phrase diff="chg" at="2023-05-19"><termref def="dt-executable-base-uri"/></phrase>, as described
                                       in <specref ref="id-resolve-relative-uri"/>.</p>
                                 </item> 
                                 <item>
                                    <p>Otherwise, the <phrase diff="chg" at="2023-05-19"><termref def="dt-executable-base-uri"/></phrase>.</p>
                                 </item>
                              </olist>
                           </p>
                        </item>

                        <item>
                           <p>
                              <code>in-scope-namespaces</code> are computed as described in <specref
                                 ref="id-ns-nodes-on-elements"/>.</p>
                        </item>

                        <item>
                           <p>The <code>nilled</code> property is <code>false</code>.</p>
                        </item>

                        <item>
                           <p>The <code>string-value</code> property is equal to the concatenated contents of the text-node descendants in document order.</p>
                        </item>

                        <item>
                           <p>The <code>typed-value</code> property is equal to the <code>string-value</code> property, as an instance of <code>xs:untypedAtomic</code>.</p>
                        </item>

                        <item>
                           <p>If <termref def="dt-construction-mode"
                                 >construction mode</termref> in the <termref
                                 def="dt-static-context"
                                 >static context</termref> is <code>strip</code>, the <code>type-name</code> property is <code>xs:untyped</code>. On the other hand, if construction mode is <code>preserve</code>, the <code>type-name</code> property is <code>xs:anyType</code>.</p>
                        </item>

                        <item>
                           <p>The <code>is-id</code> and <code>is-idrefs</code> properties are set to <code>false</code>.</p>
                        </item>
                     </olist>
                  </item>
               </olist>
               <p>A computed element constructor might be
   used to make a modified copy of an existing element. For example,
   if the variable <code>$e</code> is bound to an element with <termref
                     def="dt-numeric"
                     >numeric</termref>
   content, the following constructor might be used to create a new
   element with the same name and attributes as <code>$e</code> and
   with numeric content equal to twice the value of
   <code>$e</code>:</p>
               <eg role="parse-test"><![CDATA[element { node-name($e) } { $e/@*, 2 * data($e) }]]></eg>
               <p>In this example, if <code>$e</code> is
   bound by the expression <code>let $e := &lt;length
   units="inches"&gt;{ 5 }&lt;/length&gt;</code>, then the result of the
   example expression is the element <code>&lt;length
   units="inches"&gt;10&lt;/length&gt;</code>.</p>
               <note>
                  <p>The <termref def="dt-static-type">static type</termref> of the expression <code
                        role="parse-test"
                        >fn:node-name($e)</code> is <code>xs:QName?</code>, denoting zero or one QName. 
                     The example can be successfully evaluated as written provided that 
                     <code>$e</code> is bound to exactly one element node with numeric content.</p>
               </note>
               <p>One important
   purpose of computed constructors is to allow the name of a node to
   be computed. We will illustrate this feature by an expression that
   translates the name of an element from one language to
   another. Suppose that the variable <code>$dict</code> is bound to a
   <code>dictionary</code> element containing a sequence of <code>entry</code> elements, each of which encodes translations for a specific word.  Here is an example
   entry that encodes the German and Italian variants of the word “address”:</p>
               <eg role="parse-test"><![CDATA[
<entry word="address">
  <variant xml:lang="de">Adresse</variant>
  <variant xml:lang="it">indirizzo</variant>
</entry>
]]></eg>
               <p>Suppose further that the variable <code>$e</code> is bound to the following element:</p>
               <eg role="parse-test"
                  ><![CDATA[<address>123 Roosevelt Ave. Flushing, NY 11368</address>]]></eg>
               <p>Then the following expression generates a new element in which the name of <code>$e</code> has been translated into Italian and the content of <code>$e</code> (including its attributes, if any) has been preserved. The first enclosed expression after the <code>element</code> keyword generates the name of the element, and the second enclosed
expression generates the content and attributes:</p>
               <eg role="parse-test"><![CDATA[
element {
  $dict/entry[@word = name($e)]/variant[@xml:lang = "it"]
} {
  $e/@*, $e/node()
}]]></eg>
               <p>The result of this expression is as follows:</p>
               <eg role="parse-test"
                  ><![CDATA[<indirizzo>123 Roosevelt Ave. Flushing, NY 11368</indirizzo>]]></eg>
               
               
            </div4>

            <div4 id="id-computedAttributes">
               <head>Computed Attribute Constructors</head>
               <changes>
                  <change issue="1450" PR="1480" date="2024-10-03">
                     When the attribute name matches a language keyword such as <code>by</code> or <code>of</code>, 
                     it must now be written in quotes as a string literal. This is a backwards incompatible change.
                  </change>
               </changes>
               <scrap>
                  <prodrecap ref="CompAttrConstructor"/>
               </scrap>

               <p>A computed attribute constructor creates a new attribute node,
   with its own node identity.</p>

               <p>Attributes have no default namespace. The rules that expand attribute names create an  <termref
                     def="dt-implementation-dependent"
                  >implementation-dependent</termref> prefix if an attribute name has a namespace URI but no prefix is provided.</p>
               
               <p>The attribute name may be provided in a number of ways:</p>
               
               <olist>
                  <item><p>As a string literal, for example <code>attribute "href" {}</code>. The content
                     of the string literal must take the form of an <code>EQName</code>:
                  examples are <code>"href"</code>, <code>"xlink:href"</code>, <code>"Q{}href"</code>, 
                  or <code>"Q{http://www.w3.org/1999/xlink}href"</code> <errorref class="ST" code="0151"/>. 
                     Namespace prefixes are resolved
                  in the same way as for an <code>EQName</code> written without quotation marks.
                  </p></item>
                  
                  <item><p>As a simple unprefixed <code>NCName</code>, for example <code>attribute href {}</code>. This
                  form is allowed only if the attribute name is not a reserved keyword: see
                  <loc href="#parse-note-unreserved-name">unreserved-name</loc>. 
                     The expanded attribute name will be in no namespace.</p></item>
                  
                  <item><p>As a prefixed <code>QName</code> (for example <code>attribute xlink:href {}</code>).
                  The prefix is expanded using the <termref def="dt-static-namespaces"
                     >statically known namespaces</termref>. If expansion of the QName is
                     not successful, a static error is raised <errorref class="ST" code="0081"/>.</p></item>
                  
                  <item><p>As a <code>BracedURILiteral</code> 
                     (for example <code>attribute Q{http://www.w3.org/1999/xlink}href {}</code>).</p></item>
                  
                  <item><p>As an expression in curly brackets. This is processed as follows:</p>
                  

               <olist>


                  <item>
                     <p>
                        <termref def="dt-atomization"
                           >Atomization</termref> is
     applied to the result of the <termref
                           def="dt-name-expression"
                           >name expression</termref>. If the result
     of <termref
                           def="dt-atomization"
                           >atomization</termref> is not a
     single atomic item of type <code>xs:QName</code>,
     <code>xs:string</code>, or <code>xs:untypedAtomic</code>, a
     <termref
                           def="dt-type-error">type error</termref> is raised
     <errorref
                           class="TY" code="0004"/>.</p>
                  </item>



                  <item>
                     <p>If the atomized value of the <termref def="dt-name-expression"
                           >name expression</termref> is of type
   <code>xs:QName</code>:</p>
                     <olist>
                        <item>
                           <p>If the <termref def="dt-expanded-qname"
                                 >expanded QName</termref> returned by the atomized name expression has a namespace URI but has no prefix, it is given an <termref
                                 def="dt-implementation-dependent"
                                 >implementation-dependent</termref> prefix.</p>
                        </item>

                        <item>
                           <p>The resulting <termref def="dt-expanded-qname"
                                 >expanded QName</termref> (including its prefix) is used as the <code>node-name</code> property of the constructed
attribute node.</p>
                        </item>
                     </olist>
                  </item>


                  <item>
                     <p>If the atomized value of the <termref def="dt-name-expression"
                        >name expression</termref> is of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, 
                        that value is converted to an <termref def="dt-expanded-qname"
                           >expanded QName</termref> <phrase diff="add" at="A">as follows:</phrase></p> 
                     
                     
                     <olist>
                        <item><p>Leading and trailing whitespace is removed.</p></item>
                        <item><p>If the value is an unprefixed <code>NCName</code>, it is treated as a local name 
                           in no namespace.</p></item>
                        <item><p>If the value is a lexical QName with a prefix, that prefix is <termref
                           def="dt-resolve-relative-uri">resolved to a namespace URI</termref> using the <termref
                              def="dt-static-namespaces">statically known namespaces</termref>.</p></item>
                        <item><p>If the value is a URI-qualified name (<code>Q{uri}local</code>), it
                           is converted to an <termref def="dt-expanded-qname"/> with the supplied namespace URI and
                           local name, and with an <termref def="dt-implementation-dependent"/> prefix.</p></item>
                        <item><p>If conversion of the atomized name expression to an expanded QName is not successful, 
                           a dynamic error is raised <errorref class="DY" code="0074"/>.</p></item>
                     </olist>
                     <note diff="add" at="A"><p>This was under-specified in XQuery 3.1.</p></note>
                     
                     <!--<p>The resulting <termref def="dt-expanded-qname">expanded
                        QName</termref> (including its prefix) is used as the
                        <code>node-name</code> property of the constructed attribute. If
                        conversion of the atomized <termref
                           def="dt-name-expression">name
                           expression</termref> to an <termref
                              def="dt-expanded-qname"
                              >expanded QName</termref> is not
                        successful, a <termref
                           def="dt-dynamic-error">dynamic
                           error</termref> is raised <errorref
                              class="DY" code="0074"/>.</p>-->
                  </item>

               </olist>

                  
                  
                  </item>
               </olist>
               
               
               
               

               <p>The resulting <termref def="dt-expanded-qname"
                     >expanded QName</termref> (including its
   prefix) is used as the <code>node-name</code> property of the
   constructed attribute node. If expansion of the QName is not
   successful, a <termref
                     def="dt-static-error">static error</termref>
   is raised <errorref code="0081"
                     class="ST"/>.</p>

               <p>If the keyword <code>attribute</code> is followed by a <termref
                     def="dt-name-expression"
                  >name expression</termref>, the name
   expression is processed as follows:</p>

               
               <!--	<change diff="chg" at="XQ.E19"> -->
               <p>A <termref def="dt-dynamic-error"
                     >dynamic error</termref> is raised
             <errorref class="DY"
                     code="0044"
                  /> if the node-name of the constructed
             attribute node has any of the following properties:
          </p>
               <ulist>
                  <item>
                     <p>Its namespace prefix is <code>xmlns</code>.
             </p>
                  </item>
                  <item>
                     <p>It has no namespace prefix and its local name is
                <code>xmlns</code>.
             </p>
                  </item>
                  <item>
                     <p>Its namespace URI is <code>http://www.w3.org/2000/xmlns/</code>.
             </p>
                  </item>
                  <item>
                     <p>Its namespace prefix is <code>xml</code> and its namespace
                URI is not <code>http://www.w3.org/XML/1998/namespace</code>.
             </p>
                  </item>
                  <item>
                     <p>Its namespace prefix is other than <code>xml</code> and its
                namespace URI is <code>http://www.w3.org/XML/1998/namespace</code>.
             </p>
                  </item>
               </ulist>
               <!--	</change> -->

               <p>The <termref def="dt-content-expression"
                  >content
   expression</termref> of a computed attribute constructor is
   processed as follows:</p>



               <olist>


                  <item>
                     <p>
                        <termref def="dt-atomization"
                           >Atomization</termref> is
     applied to the result of the <termref
                           def="dt-content-expression"
                           >content expression</termref>,
     converting it to a sequence of atomic items. (If the <termref
                           def="dt-content-expression"
                        >content expression</termref> is
     absent, the result of this step is an empty
     sequence.)</p>

                  </item>



                  <item>
                     <p>If the result of atomization is an empty sequence, the
     value of the attribute is the zero-length string. Otherwise, each
     atomic item in the atomized sequence is cast into a
     string.</p>
                  </item>



                  <item>
                     <p>The individual strings resulting from the previous step
     are merged into a single string by concatenating them with a
     single space character between each pair. The resulting string
     becomes the <code>string-value</code> property of the new
     attribute node. The <termref
                           def="dt-type-annotation"
                           >type
     annotation</termref> (<code>type-name</code> property) of the new
     attribute node is <code>xs:untypedAtomic</code>. The
     <code>typed-value</code> property of the attribute node is the
     same as its <code>string-value</code>, as an instance of
     <code>xs:untypedAtomic</code>.</p>
                  </item>



                  <item>
                     <p>The <code>parent</code> property of the attribute node
     is set to empty.</p>
                  </item>



                  <item>
                     <p>If the attribute name is <code>xml:id</code>, then
     <code>xml:id</code> processing is performed as defined in <bibref
                           ref="XMLID"
                           />. This ensures that the attribute node has the type
     <code>xs:ID</code> and that its value is properly normalized. If
     an error is encountered during <code>xml:id</code> processing, an
     implementation may raise a <termref
                           def="dt-dynamic-error">dynamic error</termref>
                        <errorref class="DY" code="0091"/>.</p>
                  </item>



                  <item>
                     <p>If the attribute name is <code>xml:id</code>, the
     <code>is-id</code> property of the resulting attribute node is
     set to <code>true</code>; otherwise the <code>is-id</code>
     property is set to <code>false</code>. The <code>is-idrefs</code>
     property of the attribute node is unconditionally set to
     <code>false</code>.</p>
                  </item>



                  <item>
                     <p>If the attribute name is <code>xml:space</code> and the
     attribute value is other than <code>preserve</code> or
     <code>default</code>, a <termref
                           def="dt-dynamic-error">dynamic error</termref>  may be raised <errorref
                           code="0092" class="DY"/>.</p>
                  </item>
               </olist>
               <ulist>



                  <item>
                     <p>Example:</p>

                     <eg role="parse-test"><![CDATA[attribute size { 4 + 3 }]]></eg>

                     <p>The <termref def="dt-string-value"
                           >string
     value</termref> of the <code>size</code> attribute is
     <code>"7"</code> and its type is
     <code>xs:untypedAtomic</code>.</p>
                  </item>



                  <item>
                     <p>Example:</p>

                     <eg role="parse-test">
attribute {
  if ($sex = "M") then "husband" else "wife"
} {
  &lt;a&gt;Hello&lt;/a&gt;, 1 to 3, &lt;b&gt;Goodbye&lt;/b&gt;
}
</eg>

                     <p>The name of the constructed attribute is
     either <code>husband</code> or
     <code>wife</code>. Its <termref
                           def="dt-string-value"
                           >string
     value</termref> is "<code>Hello 1 2 3
     Goodbye</code>".</p>
                  </item>
               </ulist>
            </div4>


            <div4 id="id-documentConstructors">



               <head>Document Node Constructors</head>

               <scrap>
                  <prodrecap ref="CompDocConstructor"/>
               </scrap>

               <p>All document node constructors are computed constructors. The result of a document node constructor is a new document node, with its own node identity.</p>
               <p>A document node constructor is useful when the result of a query is to be a document in its own right. The following example illustrates a query that returns an XML document containing a root element named <code>author-list</code>:</p>

               <eg role="parse-test">document {
  &lt;author-list&gt;{
    doc("bib.xml")/bib/book/author
  }&lt;/author-list&gt;
}</eg>

               <p>The <termref def="dt-content-expression"
                     >content expression</termref> of a document node constructor is processed in exactly the same way as an enclosed expression in the content of a <termref
                     def="dt-direct-elem-const"
                     >direct element constructor</termref>, as described in Step 1e of <specref
                     ref="id-content"
                     />. The result of processing the content expression is a sequence of nodes called the <term>content sequence</term>. Processing of the document node constructor then proceeds as follows:</p>

               <olist>

                  <item>
                     <p>If the content sequence contains a document node, the document node is replaced in the content sequence by its children.</p>
                  </item>
                  <item>
                     <p>Adjacent text nodes in the content sequence are merged into a single text node by concatenating their contents, with no intervening blanks. After concatenation, any text node whose content is a zero-length string is deleted from the content sequence.</p>
                  </item>



                  <item>
                     <p> If the content sequence contains an attribute node, a
<termref
                           def="dt-type-error">type error</termref> is raised <errorref class="TY"
                           code="0004"/>.</p>
                  </item>



                  <item>
                     <p> If the content sequence contains a namespace node, a
<termref
                           def="dt-type-error">type error</termref> is raised <errorref class="TY"
                           code="0004"/>.</p>
                  </item>




                  <item>
                     <p>The properties of the newly constructed document node are determined as follows:</p>

                     <olist>

                        <item>
                           <p>
                              <code>base-uri</code> is
    set to the <phrase diff="chg" at="2023-05-19"><termref def="dt-executable-base-uri"/></phrase>.</p>
                        </item>

                        <item>
                           <p>
                              <code>children</code> consist of all the element, text, comment, and processing
   instruction nodes in the content sequence. Note that the <code>parent</code> property of each of these nodes has been set to the newly constructed document node.</p>
                        </item>

                        <item>
                           <p>The <code>unparsed-entities</code> and <code>document-uri</code> properties are empty.</p>
                        </item>

                        <item>
                           <p>The <code>string-value</code> property is equal to the concatenated contents of the text-node descendants in document order.</p>
                        </item>

                        <item>
                           <p>The <code>typed-value</code> property is equal to the <code>string-value</code> property, as an instance of <code>xs:untypedAtomic</code>.</p>
                        </item>
                     </olist>
                  </item>
               </olist>
               <p>No validation is performed on the constructed document node. The <bibref ref="XML"
                  /> rules that govern the structure of an XML document (for example, the document node must have exactly one child that is an element node)  are not enforced by the XQuery document node constructor.</p>
            </div4>
            <div4 id="id-textConstructors">
               <head>Text Node Constructors</head>

               <scrap>
                  <prodrecap ref="CompTextConstructor"/>
               </scrap>

               <p>All text node constructors are computed constructors. The result of a text node constructor is a new text node, with its own node identity.</p>
               <p>The <termref def="dt-content-expression"
                  >content expression</termref> of a text node constructor is processed as follows:</p>

               <olist>

                  <item>
                     <p>
                        <termref def="dt-atomization"
                           >Atomization</termref> is applied to the value of the <termref
                           def="dt-content-expression"
                        >content expression</termref>, converting it to a sequence of atomic items.</p>
                  </item>

                  <item>
                     <p>If the result of atomization is an empty sequence, no text node is constructed. Otherwise, each atomic item in the atomized sequence is cast into a string.</p>
                  </item>

                  <item>
                     <p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. The resulting string becomes the <code>content</code> property of the constructed text node.</p>
                  </item>
               </olist>
               <p>The <code>parent</code> property of the constructed text node is set to empty.</p>
               <note>
                  <p>It is possible for a text node constructor to construct a text node containing a zero-length string. However, if used in the content of a constructed element or document node, such a text node will be deleted or merged with another text node.</p>
               </note>
               <p>The following example illustrates a text node constructor:</p>
               <eg role="parse-test"><![CDATA[text { "Hello" }]]></eg>
            </div4>

            <div4 id="id-computed-pis">
               <head>Computed Processing Instruction Constructors</head>
               
               <changes>
                  <change issue="1512" PR="1513"  date="2024-10-18">
                     When the processing instruction name matches a language keyword such as <code>try</code> or <code>validate</code>, 
                     it must now be written in quotes as a string literal. This is a backwards incompatible change.
                  </change>
               </changes>

               <scrap>
                  <prodrecap ref="CompPIConstructor"/>
               </scrap>

               <p>A computed processing instruction constructor (<nt def="CompPIConstructor"
                     >CompPIConstructor</nt>) constructs a new processing instruction node with its own node identity.
   </p>
               
               <p>The name of a processing-instruction node is always an NCName, and may be provided in a number of ways:</p>
               
               <olist>
                  <item><p>As a string literal, for example <code>processing-instruction "xref" {}</code>. 
                     The content of the string literal must take the form of an <code>NCName</code>.
                  </p></item>
                  
                  <item><p>As a simple <code>NCName</code>, for example <code>processing-instruction xref {}</code>. This
                  form is allowed only if the name is not a reserved keyword: see
                  <loc href="#parse-note-unreserved-name">unreserved-name</loc>.</p></item>
                  
                  
                  <item><p>As an expression in curly braces. This is processed as follows:</p>
                  

  
                     <olist>
      
                        <item>
                           <p>
                              <termref def="dt-atomization"
                                 >Atomization</termref> is applied to the value of the <termref
                                 def="dt-name-expression"
                                 >name expression</termref>. If the result of <termref
                                 def="dt-atomization"
                                 >atomization</termref> is not a single atomic item of type <code>xs:NCName</code>, 
                              <code>xs:string</code>, or <code>xs:untypedAtomic</code>, a <termref
                                 def="dt-type-error">type error</termref> is raised <errorref
                                 class="TY" code="0004"/>.</p>
                        </item>
      
                        <item>
                           <p>If the atomized value of the <termref def="dt-name-expression"
                                 >name expression</termref> is of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, 
                              that value is cast to the type <code>xs:NCName</code>. If the value cannot be cast to <code>xs:NCName</code>, a <termref
                                 def="dt-dynamic-error">dynamic error</termref> is raised <errorref
                                 class="DY" code="0041"/>.</p>
                        </item>
      
                        <item>
                           <p>The resulting NCName is then used as the <code>target</code> property of the newly constructed 
                              processing instruction node. However, a <termref
                                 def="dt-dynamic-error"
                                 >dynamic error</termref> is raised if the  NCName is equal to <code>"XML"</code> (in any combination of upper and lower case) <errorref
                                 class="DY" code="0064"/>.</p>
                        </item>
                     </olist>
                  </item>
               </olist>
               <p>The
   <termref def="dt-content-expression"
                  >content expression</termref> of a computed processing instruction constructor
   is processed as follows:</p>

               <olist>

                  <item>
                     <p>
                        <termref def="dt-atomization"
                           >Atomization</termref> is applied to the value of the <termref
                           def="dt-content-expression"
                           >content expression</termref>, converting it to a sequence of atomic items. (If the <termref
                           def="dt-content-expression"
                        >content expression</termref> is absent, the result of this step is an empty sequence.)</p>
                  </item>

                  <item>
                     <p>If the result of atomization is an empty sequence, it is replaced by a zero-length string.
                        Otherwise, each atomic item in the atomized sequence is cast into a string.
                        If any of the resulting strings contains the string <code>"?&gt;"</code>, a <termref
                           def="dt-dynamic-error">dynamic error</termref>
                        <errorref class="DY" code="0026"/> is raised.</p>
                  </item>

                  <item>
                     <p>The individual strings resulting from the previous step are merged into a single string by
                        concatenating them with a single space character between each pair.
                        Leading whitespace is removed from the resulting string. The resulting string then
                        becomes the <code>content</code> property of the constructed processing instruction node.</p>
                  </item>
               </olist>
               <p>The remaining properties of the new processing instruction node are determined as follows:</p>

               <olist>

                  <item>
                     <p>The <code>parent</code> property is empty.</p>
                  </item>

                  <item>
                     <p>The <code>base-uri</code> property is empty.</p>
                  </item>
               </olist>
               <p>The following example illustrates a computed processing instruction constructor:</p>
               <eg role="parse-test"><![CDATA[let $target := "audio-output",
return processing-instruction { $target } { "beep" }]]></eg>
               <p>The processing instruction node constructed by this example might be serialized as follows:</p>
               <eg>&lt;?audio-output beep?&gt;</eg>
            </div4>

            <div4 id="id-computed-comments">
               <head>Computed Comment Constructors</head>

               <scrap>
                  <head/>
                  <prodrecap ref="CompCommentConstructor"/>
               </scrap>

               <p>A computed comment constructor (<nt def="CompCommentConstructor"
                     >CompCommentConstructor</nt>) constructs a new comment node with its own node identity.
   The <termref
                     def="dt-content-expression"
                  >content expression</termref> of a computed comment constructor is processed as follows:</p>

               <olist>

                  <item>
                     <p>
                        <termref def="dt-atomization"
                           >Atomization</termref> is applied to the value of the <termref
                           def="dt-content-expression"
                        >content expression</termref>, converting it to a sequence of atomic items.</p>
                  </item>

                  <item>
                     <p>If the result of atomization is an empty sequence, it is replaced by a zero-length string. Otherwise, each atomic item in the atomized sequence is cast into a string.</p>
                  </item>

                  <item>
                     <p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. The resulting string becomes the <code>content</code> property of the constructed comment node.</p>
                  </item>

                  <item>
                     <p>It is a <termref def="dt-dynamic-error">dynamic
 error</termref>
                        <errorref class="DY" code="0072"/> if the result of the <termref
                           def="dt-content-expression"
                        >content expression</termref> of a computed comment constructor contains two adjacent hyphens or ends with a hyphen.</p>
                  </item>
               </olist>
               <p>The <code>parent</code> property of the constructed comment node is set to empty.</p>
               <p>The following example illustrates a computed comment constructor:</p>
               <eg role="parse-test"><![CDATA[let $homebase := "Houston"
return comment { concat($homebase, ", we have a problem.") }]]></eg>
               <p>The comment node constructed by this example might be serialized as follows:</p>
               <eg>&lt;!--Houston, we have a problem.--&gt;</eg>
            </div4>



            <div4 id="id-computed-namespaces">
               <head>Computed Namespace Constructors</head>
               
               <changes>
                  <change issue="1512" PR="1513"  date="2024-10-18">
                     When the namespace prefix matches a language keyword such as <code>as</code> or <code>at</code>, 
                     it must now be written in quotes as a string literal. This is a backwards incompatible change.
                  </change>
               </changes>
               
               <scrap>
                  <prodrecap ref="CompNamespaceConstructor"/>
               </scrap>


               <p>A computed namespace constructor creates a new namespace node,
   with its own node identity. The parent of the newly created
   namespace node is absent.</p>
               
               <p>The name of a namespace node is always an <code>NCName</code>, and represents
               the namespace prefix.</p>
               
               <p>The string value of a namespace node should be a <code>URI</code>, and represents
               the namespace URI.</p>
               
               
               <p>The namespace prefix may be provided in a number of ways:</p>
               
               <olist>
                  <item><p>As a string literal, for example <code>namespace "xlink" { "http://www.w3.org/1999/xlink" }</code>. 
                     The content of the string literal must either take the form of an <code>NCName</code>, or must
                     be a zero-length string.
                  </p></item>
                  
                  <item><p>As a simple <code>NCName</code>, for example <code>namespace xlink { "http://www.w3.org/1999/xlink" }</code>. This
                  form is allowed only if the namespace prefix is not a reserved keyword: see
                  <loc href="#parse-note-unreserved-name">unreserved-name</loc>.</p></item>
                  
                  
                  <item><p>As an expression in curly braces. This is processed as follows:</p>
                  

                       
               
               
 

                   <olist>
    
                      <item>
                         <p>
                            <termref def="dt-atomization"
                               >Atomization</termref> is
      applied to the result of the enclosed expression.</p>
                      </item>
    
                      <item>
                         <p>
      If the result of <termref def="dt-atomization"
                               >atomization</termref>
        is an empty sequence
        or a single atomic item of type <code>xs:string</code> or <code>xs:untypedAtomic</code>,
      then the following rules are applied in order:</p>
    
                         <olist>
                            <item>
                               <p>If the result is castable to <code>xs:NCName</code>, then it is used as the local name
         of the newly constructed namespace node. (The local name of a namespace node
         represents the prefix part of the namespace binding.)</p>
                            </item>
    
                            <item>
                               <p>If the result is the empty sequence
                      or a zero-length <code>xs:string</code>
                      or <code>xs:untypedAtomic</code> item,
               the new namespace node has no name (such a namespace node represents a binding for the default namespace).</p>
                            </item>
    
                            <item>
                               <p>Otherwise, a <termref def="dt-dynamic-error"
                                     >dynamic error</termref>  is raised  <errorref class="DY"
                                     code="0074"/>.</p>
                            </item>
    
                         </olist>
                      </item>
    
                      <item>
                         <p>If the result of atomization is not an empty sequence
                               or a single atomic item of type <code>xs:string</code> or <code>xs:untypedAtomic</code>,
      a type error is raised <errorref
                               class="TY" code="0004"/>.</p>
                      </item>
                   </olist>
                  </item>
               </olist>

               <p>The <termref def="dt-content-expression"
                     >content expression</termref> is evaluated, and the result is cast
    to <code>xs:anyURI</code> to create the <code>URI</code> property
    for the newly created node.  
    An implementation may raise a <termref
                     def="dt-dynamic-error">dynamic error</termref>
                  <errorref class="DY" code="0074"
                     /> if the <code>URIExpr</code> of a computed namespace constructor is not a valid instance of <code>xs:anyURI</code>.</p>

               <p>An error <errorref class="DY" code="0101"
                  /> is raised if a
    computed namespace constructor attempts to do any of the
    following:</p>

               <ulist>
                  <item>
                     <p>Bind the prefix <code>xml</code> to some namespace URI
      other than <code>http://www.w3.org/XML/1998/namespace</code>.
      </p>
                  </item>
                  <item>
                     <p>Bind a prefix other than <code>xml</code> to the namespace
      URI <code>http://www.w3.org/XML/1998/namespace</code>.
      </p>
                  </item>
                  <item>
                     <p>Bind the prefix <code>xmlns</code> to any namespace URI.
      </p>
                  </item>
                  <item>
                     <p>Bind a prefix to the namespace
      URI <code>http://www.w3.org/2000/xmlns/</code>.
      </p>
                  </item>
                  <item>
                     <p>Bind any prefix (including the empty prefix) to a zero-length namespace URI.</p>
                  </item>
               </ulist>

               <p>By itself, a computed namespace constructor has no effect on
    in-scope namespaces, but if an element constructor’s content
    sequence contains a namespace node, the namespace binding it
    represents is added to the element’s <termref
                     def="dt-in-scope-namespaces">in-scope namespaces</termref>.</p>

               <p>A computed namespace constructor has no effect on the statically
    known namespaces.</p>

               <note>
                  <p>The newly created namespace node has all properties defined
      for a namespace node in the data model, but its parent is always absent.  As defined in the
      data model, the name of the node is the prefix, the string value
      of the node is the URI. Since the nodes are parentless, their relative order is implementation
      dependent.</p>
               </note>

               <p>Examples:</p>


               <ulist>


                  <item>
                     <p>A computed namespace constructor with a prefix:</p>
                     <eg role="parse-test"><![CDATA[namespace a { "http://a.example.com" }]]></eg>
                  </item>


                  <item>
                     <p>A computed namespace constructor with a prefix expression:</p>
                     <eg role="parse-test"
                        ><![CDATA[namespace { "a" } { "http://a.example.com" }]]></eg>
                  </item>


                  <item>
                     <p>A computed namespace constructor with an empty prefix:</p>
                     <eg role="parse-test"
                        ><![CDATA[namespace "" { "http://a.example.com" }]]></eg>
                  </item>
               </ulist>

               <p>Computed namespace constructors are generally used to add to the
in-scope namespaces of elements created with element constructors:</p>
               <eg role="parse-test"><![CDATA[
<age xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"> {
  namespace xs { "http://www.w3.org/2001/XMLSchema" },
  attribute xsi:type { "xs:integer" },
  23
}</age>
]]></eg>

               <p>In the above example, note that the <code>xsi</code> namespace binding is created for the element because it is used in an attribute name. The attribute’s content is simply character data, and has no effect on namespace bindings. The computed namespace constructor ensures that the <code>xs</code> binding is created.</p>

               <p>Computed namespace constructors have no effect on the statically known
namespaces. If the prefix a is not already defined in the statically
known namespaces, the following expression results in a static error
<errorref
                     class="ST" code="0081"/>.</p>
               <eg role="parse-test"><![CDATA[
<a:form>{
  namespace a { "http://a.example.com" }
}</a:form>
]]></eg>


            </div4>


         </div3>

         <div3 id="id-ns-nodes-on-elements">
            <head>In-scope Namespaces of a Constructed Element</head>

            <p>An element node constructed by a direct or computed element
constructor has an <termref
                  def="dt-in-scope-namespaces"
                  >in-scope
namespaces</termref> property that consists of a set of <termref
                  def="dt-in-scope-namespaces"
                  >namespace bindings</termref>.  The
in-scope namespaces of an element node may affect the way the node is
serialized (see <specref
                  ref="id-serialization"
                  />), and may also
affect the behavior of certain functions that operate on nodes, such
as <function>fn:name</function>. Note the difference between <termref
                  def="dt-in-scope-namespaces"
                  >in-scope namespaces</termref>, which is a
dynamic property of an element node, and <termref
                  def="dt-static-namespaces"
               >statically known namespaces</termref>,
which is a static property of an expression.  Also note that one of
the namespace bindings in the in-scope namespaces may have no prefix
(denoting the default namespace for the given element). The in-scope
namespaces of a constructed element node consist of the following
namespace bindings:</p>


            <ulist>


               <item>
                  <p>A namespace binding is created for each namespace declared
  in the current element constructor by a <termref
                        def="dt-namespace-decl-attr"
                     >namespace declaration
  attribute</termref>.</p>
               </item>



               <item>
                  <p>A namespace binding is created for each namespace node in
  the content sequence of the current element constructor.</p>
               </item>



               <item>
                  <p>A namespace binding is created for each namespace that is
  declared in a <termref
                        def="dt-namespace-decl-attr"
                        >namespace
  declaration attribute</termref> of an enclosing <termref
                        def="dt-direct-elem-const"
                     >direct element constructor</termref> and
  not overridden by the current element constructor or an intermediate
  constructor.</p>
               </item>



               <item>
                  <p>A namespace binding is always created to bind the prefix
  <code>xml</code> to the namespace URI
  <code>http://www.w3.org/XML/1998/namespace</code>.</p>
               </item>



               <item>
                  <p>For each prefix used in the name of the
  constructed element or in the names of its attributes, a namespace
  binding must exist.

  If a namespace binding does not already exist for one of these
  prefixes, a new namespace binding is created for it.

  If this would result in a conflict, because it would require two
  different bindings of the same prefix, then the prefix used in the
  node name is changed to an arbitrary <termref
                        def="dt-implementation-dependent"
                     >implementation-dependent</termref>
  prefix that does not cause such a conflict, and a namespace binding
  is created for this new prefix.

  If there is an in-scope default namespace, then a binding is created
  between the empty prefix and that URI.</p>
               </item>
            </ulist>


            <note>
               <p>
                  <termref def="dt-copy-namespaces-mode"
                  >Copy-namespaces
mode</termref> does not affect the namespace bindings of a newly
constructed element node. It applies only to existing nodes that are
copied by a constructor expression.</p>
            </note>

            <p>In an element constructor, if two or more namespace bindings in the
in-scope bindings would have the same prefix, then an error is raised
if they have different URIs <errorref
                  class="DY" code="0102"
                  />; if they
would have the same prefix and URI, duplicate bindings are
ignored. 
If the name of an element in an element constructor is in no namespace,
creating a default namespace for that element using a computed namespace constructor is an error <errorref
                  class="DY" code="0102"
               />. 
For instance, the following computed constructor raises an error because the element’s name is not in a namespace, but a default namespace is defined.</p>

            <eg role="parse-test"><![CDATA[element e { namespace { '' } { 'u' } }]]></eg>

            <p>The following query illustrates the in-scope namespaces of a constructed element:</p>

            <eg role="parse-test">declare namespace p = "http://example.com/ns/p";
declare namespace q = "http://example.com/ns/q";
declare namespace f = "http://example.com/ns/f";

&lt;p:a q:b="{ f:func(2) }" xmlns:r="http://example.com/ns/r"/&gt;
</eg>
            <p>The <termref def="dt-in-scope-namespaces"
                  >in-scope namespaces</termref> of the resulting <code>p:a</code> element consists of the following namespace bindings:</p>
            <ulist>

               <item>
                  <p>
                     <code>p = "http://example.com/ns/p"</code>
                  </p>
               </item>

               <item>
                  <p>
                     <code>q = "http://example.com/ns/q"</code>
                  </p>
               </item>

               <item>
                  <p>
                     <code>r = "http://example.com/ns/r"</code>
                  </p>
               </item>


               <item>
                  <p>
                     <code>xml = "http://www.w3.org/XML/1998/namespace"</code>
                  </p>
               </item>
            </ulist>

            <p>The namespace bindings for <code>p</code> and <code>q</code> are added to the result element because their respective namespaces
are used in the names of the element and its attributes. The namespace binding <code>r="http://example.com/ns/r"</code> is added to the in-scope namespaces of the constructed
element because it is defined by a <termref
                  def="dt-namespace-decl-attr"
               >namespace declaration attribute</termref>, even though it is not used in a name.</p>

            <p>No  namespace binding corresponding to <code>f="http://example.com/ns/f"</code> is created, because the namespace prefix <code>f</code> appears only in the query prolog and is not used in an element or attribute name of the constructed node. This namespace binding does not appear in the query result, even though it is present in the <termref
                  def="dt-static-namespaces"
               >statically known namespaces</termref> and is available for use during processing of the query.</p>

            <p>Note that the following constructed element, if nested within a <code>validate</code> expression, cannot be validated:
</p>
            <eg role="parse-test">&lt;p xsi:type="xs:integer"&gt;3&lt;/p&gt;</eg>

            <p>The constructed element will have namespace bindings for the prefixes <code>xsi</code> (because it is used in a name) and <code>xml</code> (because it is defined for every constructed element node). During validation of the constructed element, the validator will be unable to interpret the namespace prefix <code>xs</code> because it is has no namespace binding. Validation of this constructed element could be made possible by providing a <termref
                  def="dt-namespace-decl-attr"
               >namespace declaration attribute</termref>, as in the following example:</p>

            <eg role="parse-test">&lt;p xmlns:xs="http://www.w3.org/2001/XMLSchema" xsi:type="xs:integer"&gt;3&lt;/p&gt;</eg>
         </div3>
      </div2>

      <div2 id="id-flwor-expressions">
         <head><phrase role="xquery">FLWOR Expressions</phrase><phrase role="xpath">For and Let Expressions</phrase></head>
         <p role="xquery">XQuery provides a versatile expression called a FLWOR expression 
            that may contain multiple clauses. The FLWOR expression can be used for many purposes, 
            including iterating over sequences, joining multiple documents, and performing grouping 
            and aggregation. The name FLWOR, pronounced "flower", is suggested by the keywords 
            <code>for</code>, <code>let</code>, <code>where</code>, <code>order by</code>, 
            and <code>return</code>, which introduce some of the clauses used in FLWOR expressions 
            (but this is not a complete list of such clauses.)</p>
         <p role="xquery">The overall syntax of a FLWOR expression is shown here, and relevant parts 
            of the syntax are expanded in subsequent sections.</p>
         <p role="xpath">XPath provides two closely-related expressions, called For and Let
         expressions, that can be used to bind variables to values. These are described in the
         following sections.</p>
         <scrap role="xquery">
            <prodrecap ref="FLWORExpr"/>
         </scrap>
         <p role="xquery">The semantics of FLWOR expressions are based on a concept called a <term>tuple stream</term>. <termdef
               id="id-tuple-stream-foobar" term="tuple stream"
                  >A <term>tuple stream</term> is an ordered sequence of zero or more <term>tuples</term>.</termdef>
            <termdef term="tuple" id="id-tuple-foobar"
                  >A <term>tuple</term> is a set of zero or more named variables, each of which is bound to a value that is an <termref
                  def="dt-data-model-instance"
               >XDM instance</termref>.</termdef> Each tuple stream is homogeneous in the sense that all its  tuples contain variables with the same names and the same <termref
               def="dt-static-type"
               >static types</termref>. The following example illustrates a tuple stream consisting of four tuples, each containing three variables named <code>$x</code>, <code>$y</code>, and <code>$z</code>:</p>
         <eg role="xquery">($x = 1003, $y = "Fred", $z = &lt;age&gt;21&lt;/age&gt;)
($x = 1017, $y = "Mary", $z = &lt;age&gt;35&lt;/age&gt;)
($x = 1020, $y = "Bill", $z = &lt;age&gt;18&lt;/age&gt;)
($x = 1024, $y = "John", $z = &lt;age&gt;29&lt;/age&gt;)</eg>
         <note role="xquery">
            <p>In this section, tuple streams are represented as shown in the above example. Each tuple is on a separate line and is enclosed in parentheses, and the variable bindings inside each tuple are separated by commas. This notation does not represent XQuery syntax, but is simply a representation of a tuple stream for the purpose of defining the semantics of  FLWOR expressions.</p>
         </note>
         <p role="xquery">Tuples and tuple streams are not part of the <termref def="dt-datamodel"
               >data model</termref>. They exist only as conceptual intermediate results during the processing of a FLWOR expression.</p>
         <p role="xquery">Conceptually, the first clause generates a tuple stream. Each clause between the first clause and the return clause takes the tuple stream generated by the previous clause as input and generates a (possibly different) tuple stream as output. The return clause takes a tuple stream as input and, for each tuple in this tuple stream, generates an <termref
               def="dt-data-model-instance"
               >XDM instance</termref>; the final result of the FLWOR expression is the ordered concatenation of these <termref
               def="dt-data-model-instance">XDM instances</termref>.</p>
         <p role="xquery">The initial clause in a FLWOR expression may be a <code>for</code>, <code>let</code>, or <code>window</code> clause. 
Intermediate clauses may be <code>for</code>, <code>let</code>, <code>window</code>, <code>count</code>, <code>where</code>, <code>group by</code>, or <code>order by</code> clauses. These intermediate clauses may be repeated as many times as desired, in any order. The final clause of the FLWOR expression must be a <code>return</code> clause. The semantics of the various clauses are described in the following sections.</p>

         <div3 id="id-binding-rules" role="xquery">
            <head>Variable Bindings</head>
            <p>The following clauses in FLWOR expressions bind values to variables: 
<code>for</code>, <code>let</code>, <code>window</code>, <code>count</code>, and <code>group by</code>. 
The binding of variables for <code>for</code>, <code>let</code>, and <code>count</code> is governed by the following rules
(the binding of variables in <code>group by</code> is discussed in <specref
                  ref="id-group-by"
                  />,
the binding of variables in <code>window</code> clauses is discussed in <specref
                  ref="id-windows"/>):</p>

            <olist>

               <item>
                  <p>The scope of a bound variable includes all subexpressions of the containing FLWOR that appear after the variable binding. The scope does not include the expression to which the variable is bound. The following code fragment, containing two <code>let</code> clauses, illustrates how variable bindings may reference variables that were bound in earlier clauses, or in earlier bindings in the same clause:</p>
                  <eg><![CDATA[let $x := 47, $y := f($x)
let $z := g($x, $y)]]></eg>
               </item>

               <item>
                  <p>A given variable name may be bound more than once in a FLWOR expression, 
                     or even within one clause of a FLWOR expression. In such a case, each new 
                     binding occludes the previous one, which becomes inaccessible in the 
                     remainder of the FLWOR expression.</p>
                  <p>For example, it is valid to write:</p>
                  <eg>let $x := 0, $x := $x*2, $x := $x + 1</eg>
                  <p>This binds three separate variables, each of which happens to have the
                  same name. It should not be construed as binding a series of different values
                  to the same variable.</p>
               </item>

               <item>
                  <p>
                     <termdef term="type declaration" id="dt-type-declaration"
                           >A variable binding may be accompanied by a <term>type declaration</term>, which consists of the 
                        keyword <code>as</code> followed by the static type of the variable, declared using the syntax in  <specref
                           ref="id-sequencetype-syntax"
                        />.</termdef> The type declaration defines a required type for the
                        value. At run-time, the supplied value for the variable is converted to the required type
                        by applying the <termref def="dt-coercion-rules"/>. If conversion is not possible,                     
                        a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY"
                        code="0004"
                        />. For example, the following <code>let</code> clause raises a <termref
                        def="dt-type-error"
                        >type error</termref> because the variable <code>$salary</code> has a type declaration that is not satisfied by the value that is bound to it:</p>
                  <eg><![CDATA[let $salary as xs:decimal := "cat"]]></eg>
                  <p  diff="add" at="2022-11-17">The following <code>let</code> clause, however, succeeds, because the <termref def="dt-coercion-rules"/>
                  allow an <code>xs:decimal</code> to be supplied where an <code>xs:double</code> is required:</p>
                  <eg><![CDATA[let $temperature as xs:double := 32.5]]></eg>
                  <p>In applying the <termref def="dt-coercion-rules"/>, <termref def="dt-xpath-compat-mode"/> does not apply.</p>
               </item>
               <item diff="add" at="A">
                  <p>
                     <termdef id="dt-binding-collection" term="binding collection"
                        >In a <code>for</code> clause, when an expression is 
                        preceded by the keyword <code>in</code>, the value of that expression is 
                        called a <term>binding collection</term>.</termdef> The collection may be either
                     a sequence, an array, or a map. The <code>for</code>  
                     clause iterates over its binding collection, producing multiple bindings for one or more variables. 
                     Details on how binding collections are used in <code>for</code> clauses 
                     are described in the following sections.</p>
               </item>
               <item diff="chg" at="A">
                  <p>
                     <termdef id="dt-binding-sequence" term="binding sequence"
                           >In a <code>window</code> clause, when an expression is 
                        preceded by the keyword <code>in</code>, the value of that expression is 
                        called a <term>binding sequence</term>.</termdef> The <code>window</code> 
                     clause iterates over its binding sequence, producing multiple bindings for one or more variables. 
                     Details on how binding sequences are used in <code>for</code> and <code>window</code> clauses 
                     are described in the following sections.</p>
               </item>
               
            </olist>
         </div3>

         <div3 id="id-xquery-for-clause" role="xquery">
            <head>For Clause</head>
            
            <changes>
               <change issue="49" PR="344" date="2023-02-10">A <code>for member</code> clause is added to 
                  FLWOR expressions to allow iteration over an array.
               </change>
               <change issue="31" PR="1249" date="2024-06-01">A <code>for key/value</code> clause is added to 
                  FLWOR expressions to allow iteration over a map.
               </change>
               <change issue="189" PR="820" date="2023-11-08">
                  The value bound to a variable in a <code>for</code> clause is now converted
                     to the declared type by applying the coercion rules.
               </change>
            </changes>
            
            <scrap>
               <prodrecap ref="ForClause"/>
            </scrap>
            
            <p>A <code>for</code> clause is used for iteration. Each variable in a <code>for</code> clause iterates over a 
               sequence, an array, or a map.</p>
            
            <p>The expression following the keyword <code>in</code> is evaluated; we refer to the 
               resulting sequence, array, or map generically as the <termref def="dt-binding-collection"/>, and to
               its items, members, or entries as the <code>components</code> of the collection.</p>
            
            <ulist>
               <item><p>When a <nt def="ForItemBinding">ForItemBinding</nt> is used (that is, when none of the
                  keywords <code>member</code>, <code>key</code>, or <code>value</code> is used), 
                  the range variable is bound in turn to each item in the <termref def="dt-binding-collection"/>,
                  which is treated as a sequence of items.</p></item>
               <item><p>When a <nt def="ForItemBinding">ForMemberBinding</nt> is used (that is, when the
               keyword <code>member</code> is used), 
               the range variable is bound in turn to each member of the array.</p>
                  <p>In this case the corresponding <code>ExprSingle</code>
                  must evaluate to a single array, otherwise a type error is raised <errorref
                  class="TY" code="0141"/>.</p></item>
               <item><p>When a <nt def="ForItemBinding">ForEntryBinding</nt> is used (that is, when either
                  or both of the keywords <code>key</code> and <code>value</code> are used), 
                  the <code>key</code> range variable (if present) is bound in turn to each key in the map 
                  (in <xtermref spec="DM40" ref="dt-entry-order">entry order</xtermref>), and the <code>value</code>
                  range variable (if present) is bound to the corresponding value.</p>
                  <p>In this case the corresponding <code>ExprSingle</code>
                  must evaluate to a single map, otherwise a type error is raised <errorref
                  class="TY" code="0141"/>.</p>
               <p>If both the <code>key</code> and <code>value</code> variables are declared,
               their <termref def="dt-expanded-qname">expanded
			        QNames</termref> must be distinct <errorref
                  class="ST" code="0089"/>.</p></item>
            </ulist>
            

            <p>If a <code>for</code> clause contains multiple bindings separated by commas 
               it is semantically equivalent to multiple <code>for</code> clauses, 
               each containing one of the bindings in the original <code>for</code> clause.</p>

            <p>Example:</p>

            <ulist>
               <item>
                  <p>The clause</p>
                  <eg><![CDATA[for $x in $expr1, $y in $expr2]]></eg>
                  <p>is semantically equivalent to:</p>
                  <eg><![CDATA[for $x in $expr1
for $y in $expr2]]></eg>
               </item>
               <item>
                  <p>The clause</p>
                  <eg><![CDATA[for member $x in $expr1, member $y in $expr2]]></eg>
                  <p>is semantically equivalent to:</p>
                  <eg><![CDATA[for member $x in $expr1
for member $y in $expr2]]></eg>
               </item>
            </ulist>
            
            
           

            <p>In the remainder of this section, we define the semantics of a <code>for</code> clause containing 
               a single variable and an associated expression 
               (following the keyword <code>in</code>) whose value is the <termref
                  def="dt-binding-collection">binding collection</termref> for that variable.</p>
            <p>If a single-variable <code>for</code> clause is the initial clause in a FLWOR expression, it iterates over its <termref
               def="dt-binding-collection">binding collection</termref>, binding the variable(s) to each component in turn. 
               The resulting sequence of variable bindings becomes the initial tuple stream that serves as input to the next clause 
               of the FLWOR expression. The order of tuples in the tuple stream preserves the order of the <termref
                  def="dt-binding-collection">binding collection</termref>.</p>
            <p>If the <termref def="dt-binding-sequence"
                  >binding collection</termref> is empty, the output tuple stream depends on whether <code>allowing empty</code> is specified. 
               If <code>allowing empty</code> is specified, the output tuple stream consists of one tuple in which the variable is bound to an empty sequence.
               This option is not available when the keywords <code>member</code>, <code>key</code>, or <code>value</code>
               are used.
               If <code>allowing empty</code> is not specified, the output tuple stream consists of zero tuples.</p>
            <p>The following  examples illustrates tuple streams that are generated by initial <code>for</code> clauses:</p>
            <ulist>

               <item>
                  <p>Initial clause:</p>
                  <eg><![CDATA[for $x in (100, 200, 300)]]></eg>
                  <p>or (equivalently):</p>
                  <eg><![CDATA[for $x allowing empty in (100, 200, 300)]]></eg>
                  <p>Output tuple stream:</p>
                  <eg><![CDATA[($x = 100)
($x = 200)
($x = 300)]]></eg>
               </item>

               <item>
                  <p>Initial clause:</p>
                  <eg><![CDATA[for $x in ()]]></eg>
                  <p>Output tuple stream contains no tuples.</p>
               </item>

               <item>
                  <p>Initial clause:</p>
                  <eg><![CDATA[for $x allowing empty in ()]]></eg>
                  <p>Output tuple stream:</p>
                  <eg><![CDATA[($x = ())]]></eg>
               </item>
               
               <item diff="add" at="A">
                  <p>Initial clause:</p>
                  <eg><![CDATA[for member $x in [ 1, 2, (5 to 10) ] ]]></eg>
                  <p>Output tuple stream:</p>
                  <eg><![CDATA[($x = (1))
($x = (2))
($x = (5, 6, 7, 8, 9, 10)]]></eg>
               </item>
               
               <item diff="add" at="A">
                  <p>Initial clause:</p>
                  <eg><![CDATA[for member $x in []]]></eg>
                  <p>Output tuple stream contains no tuples.</p>
               </item>
               
               <item>
                  <p>Initial clause:</p>
                  <eg><![CDATA[for key $k value $v in { 'x': 1, 'y': 2 }]]></eg>
                  <p>Output tuple stream:</p>
                  <eg><![CDATA[($k = 'x', $v = 1)
($k = 'y', $v = 2)]]></eg>
               </item>
            </ulist>
            <p>
               <termdef term="positional variable" id="dt-positional-variable">A <term>positional variable</term> 
                  is a variable that is preceded by the keyword <code>at</code>.</termdef> A positional variable 
               may be associated with the range variable(s) that are bound in a <code>for</code> clause. In this case, as 
               the main range variable(s) iterate over the components of its <termref def="dt-binding-collection" diff="chg" at="A">binding collection</termref>, 
               the positional variable iterates over the integers that represent the ordinal numbers of these component in the 
               <termref def="dt-binding-collection" diff="chg" at="A">binding collection</termref>, starting with one. Each tuple in the output 
               tuple stream contains bindings for both the main variable and the positional variable. If the 
               <termref def="dt-binding-collection" diff="chg" at="A">binding collection</termref> is empty and <code>allowing empty</code> is 
               specified, the positional variable in the output tuple is bound to the integer zero. Positional variables  
               have the implied type <code>xs:integer</code>.</p>
            <p>The <termref def="dt-expanded-qname">expanded
			        QName</termref> of a positional variable must be distinct from the <termref def="dt-expanded-qname"
                  >expanded QName</termref> of the main variable with which it is associated <errorref
                  class="ST" code="0089"/>.</p>
            <p>The following  examples illustrate how a positional variable would have affected the results of the previous examples that generated tuples:</p>
            <ulist>

               <item>
                  <p>Initial clause:</p>
                  <eg><![CDATA[for $x at $i in (100, 200, 300)]]></eg>
                  <p>Output tuple stream:</p>
                  <eg><![CDATA[($x = 100, $i = 1)
($x = 200, $i = 2)
($x = 300, $i = 3)]]></eg>
               </item>
               
               <item diff="add" at="A">
                  <p>Initial clause:</p>
                  <eg><![CDATA[for $x at $i in [1 to 3, 11 to 13, 21 to 23]]></eg>
                  <p>Output tuple stream:</p>
                  <eg><![CDATA[($x = (1, 2, 3), $i = 1)
($x = (11, 12, 13), $i = 2)
($x = (21, 22, 23), $i = 3)]]></eg>
               </item>

               <item>
                  <p>Initial clause:</p>
                  <eg><![CDATA[for $x allowing empty at $i in ()]]></eg>
                  <p>Output tuple stream:</p>
                  <eg><![CDATA[($x = (), $i = 0)]]></eg>
               </item>
            </ulist>
            <p>If a single-variable <code>for</code> clause is an intermediate clause in a FLWOR expression, its <termref
                  def="dt-binding-collection" diff="chg" at="A"
                  >binding collection</termref> is evaluated for each input tuple, given the bindings in that input tuple. Each input tuple generates 
                  zero or more tuples in the output tuple stream. Each of these output tuples consists of  the original variable bindings of the 
                  input tuple plus a binding of the new variable to one of the items in its <termref
                     def="dt-binding-collection" diff="chg" at="A">binding collecction</termref>.</p>
            <note>
               <p>Although the <termref def="dt-binding-collection" diff="chg" at="A"
                     >binding collection</termref> is conceptually evaluated independently for each input tuple, 
                  an optimized implementation may sometimes be able to avoid re-evaluating the <termref
                     def="dt-binding-collection" diff="chg" at="A"
                     >binding collection</termref> if it can show that the variables that the <termref
                        def="dt-binding-collection" diff="chg" at="A"
                  >binding collection</termref> depends on have the same values as in a previous evaluation.</p>
            </note>
            <p>For a given input tuple, if the <termref def="dt-binding-collection" diff="chg" at="A"
                  >binding collection</termref> for the new variable in the <code>for</code> clause <phrase diff="add" at="A">is empty 
               (that is, it is an empty sequence or an <xtermref spec="DM40" ref="dt-empty-array"/> depending on whether <code>member</code> is specified)</phrase>,
               and if <code>allowing empty</code> is not specified, the input tuple generates zero output tuples 
               (it is not represented in the output tuple stream.)</p>
            
            <p>The <code>allowing empty</code> option is available only when processing sequences, not when processing arrays or maps.
               The effect is that if the binding collection is an empty sequence, the input tuple generates one output tuple, 
               with the original variable bindings plus a binding of the new variable to an empty sequence.</p>
            
            <note diff="add" at="2023-10-16"><p>If a type declaration is present and <code>allowing empty</code> is specified, the type declaration
            should include an occurrence indicator of <code>"?"</code> to indicate that the variable may be bound to an
            empty sequence.</p></note>
            
            <p>If the new variable introduced by a <code>for</code> clause has an associated <termref
                  def="dt-positional-variable"
                  >positional variable</termref>, the output tuples generated by the <code>for</code> clause  also contain bindings for the <termref
                  def="dt-positional-variable"
                  >positional variable</termref>. In this case, as the new variable is bound to each item in its <termref
                     def="dt-binding-collection" diff="chg" at="A">binding collection</termref>, the <termref
                  def="dt-positional-variable"
                  >positional variable</termref> is bound to the ordinal position of that item within the <termref
                     def="dt-binding-collection" diff="chg" at="A"
                  >binding collection</termref>, starting with one. Note that, since the <termref
                  def="dt-positional-variable"
                  >positional variable</termref> represents a position within a <termref
                     def="dt-binding-collection" diff="chg" at="A"
                  >binding collection</termref>, the output tuples corresponding to each input tuple are independently numbered, starting with one. For a given input tuple, if the <termref
                     def="dt-binding-collection"  diff="chg" at="A"
                  >binding collection</termref> is empty and <code>allowing empty</code> is specified, the <termref
                  def="dt-positional-variable"
               >positional variable</termref> in the output tuple is bound to the integer zero.</p>
            <p>The tuples in the output tuple stream are ordered primarily by the order of the 
               input tuples from which they are derived, and secondarily by the order of the <termref
                  def="dt-binding-sequence"
                  >binding sequence</termref> for the new variable; otherwise the order of the output tuple stream is <termref
                  def="dt-implementation-dependent">implementation-dependent</termref>.</p>
            <p>The following examples illustrates the effects of  intermediate <code>for</code> clauses:</p>
            <ulist>

               <item>
                  <p>Input tuple stream:</p>
                  <eg><![CDATA[($x = 1)
($x = 2)
($x = 3)
($x = 4)]]></eg>
                  <p>Intermediate <code>for</code> clause:</p>
                  <eg><![CDATA[for $y in ($x to 3)]]></eg>
                  <p>Output tuple stream:</p>
                  <eg><![CDATA[($x = 1, $y = 1)
($x = 1, $y = 2)
($x = 1, $y = 3)
($x = 2, $y = 2)
($x = 2, $y = 3)
($x = 3, $y = 3)
]]></eg>
                  <note>
                     <p>In this example, there is no output tuple that corresponds to the input tuple <code>($x = 4)</code> because, when the <code>for</code> clause is evaluated with the bindings in this input tuple, the resulting <termref
                        def="dt-binding-collection" diff="chg" at="A"
                        >binding collection</termref> for <code>$y</code> is empty.</p>
                  </note>
               </item>
               

               <item>
                  <p>This  example shows how the previous example would have been affected by a <termref
                        def="dt-positional-variable"
                     >positional variable</termref> (assuming the same input tuple stream):</p>
                  <eg><![CDATA[for $y at $j in ($x to 3)]]></eg>
                  <p>Output tuple stream:</p>
                  <eg><![CDATA[($x = 1, $y = 1, $j = 1)
($x = 1, $y = 2, $j = 2)
($x = 1, $y = 3, $j = 3)
($x = 2, $y = 2, $j = 1)
($x = 2, $y = 3, $j = 2)
($x = 3, $y = 3, $j = 1)
]]></eg>
               </item>

               <item>
                  <p>This example shows how the previous example would have been affected by <code>allowing empty</code>. Note that <code>allowing empty</code> causes the input tuple <code>($x = 4)</code> to be represented in the output tuple stream, even though the <termref
                        def="dt-binding-sequence"
                        >binding sequence</termref> for <code>$y</code> contains no items for this input tuple.
                        This example illustrates that <code>allowing empty</code> in a <code>for</code> clause
                        serves a purpose similar to that of an “outer join” in a relational database query.
                        (Assume the same input tuple stream as in the previous example.)</p>
                  <eg><![CDATA[for $y allowing empty at $j in ($x to 3)]]></eg>
                  <p>Output tuple stream:</p>
                  <eg><![CDATA[($x = 1, $y = 1, $j = 1)
($x = 1, $y = 2, $j = 2)
($x = 1, $y = 3, $j = 3)
($x = 2, $y = 2, $j = 1)
($x = 2, $y = 3, $j = 2)
($x = 3, $y = 3, $j = 1)
($x = 4, $y = (), $j = 0)
]]></eg>
               </item>
               
               <item diff="add" at="A">
                  <p>This example illustrates processing of arrays:</p>
                  <p>Input tuple stream:</p>
                  <eg><![CDATA[($x = 1)
($x = 2)
($x = 3)]]></eg>
                  <p>Intermediate <code>for</code> clause:</p>
                  <eg><![CDATA[for member $y in [[$x+1, $x+2], [[$x+3, $x+4]] ]]></eg>
                  <p>Output tuple stream:</p>
                  <eg><![CDATA[($x = 1, $y = [ 2, 3 ])
($x = 1, $y = [ 4, 5 ])
($x = 2, $y = [ 3, 4 ])
($x = 2, $y = [ 5, 6 ])
($x = 3, $y = [ 4, 5 ])
($x = 3, $y = [ 6, 7 ])
]]></eg>
                  
               </item>
               

               <item>
                  <p>This example shows how a <code>for</code> clause that binds two variables is semantically equivalent to two <code>for</code> clauses that bind one variable each. We assume that this <code>for</code> clause occurs at the beginning of a FLWOR expression. It is equivalent to an initial single-variable <code>for</code> clause that provides an input tuple stream to an intermediate single-variable <code>for</code> clause.</p>
                  <eg><![CDATA[for $x in (1, 2, 3, 4), $y in ($x to 3)]]></eg>
                  <p>Output tuple stream:</p>
                  <eg><![CDATA[($x = 1, $y = 1)
($x = 1, $y = 2)
($x = 1, $y = 3)
($x = 2, $y = 2)
($x = 2, $y = 3)
($x = 3, $y = 3)
]]></eg>
               </item>
            </ulist>
            
            <p>A <code>for</code> clause may contain one or more <termref def="dt-type-declaration"
                  >type declarations</termref>, identified by the keyword <code>as</code>. The semantics of <termref
                  def="dt-type-declaration">type declarations</termref> are defined in <specref
                  ref="id-binding-rules"/>.</p>
         </div3>
         <div3 id="id-xquery-let-clause" role="xquery">
            <head>Let Clause</head>
            
            <changes>
               <change issue="189" PR="254" date="2022-11-29">
                  The value bound to a variable in a <code>let</code> clause is now converted
               to the declared type by applying the coercion rules.
               </change>
            </changes>
            <scrap>
               <prodrecap ref="LetClause"/>
            </scrap>
            <p>The purpose of a <code>let</code> clause is to bind values to one or more variables. Each variable is bound to the result of evaluating an expression.</p>
            <p>If a <code>let</code> clause contains multiple variables, it is semantically equivalent to multiple <code>let</code> clauses, each containing a single variable. For example, the clause</p>
            <eg><![CDATA[let $x := $expr1, $y := $expr2]]></eg>
            <p>is semantically equivalent to the following sequence of clauses:</p>
            <eg><![CDATA[let $x := $expr1
let $y := $expr2]]></eg>
            <p>In the remainder of this section, we define the semantics of a <code>let</code> clause containing a single variable <emph>V</emph> and an associated expression <emph>E</emph>.</p>
            <p>If a single-variable <code>let</code> clause is the initial clause in a FLWOR expression, it simply binds the variable <emph>V</emph> to the result of the expression <emph>E</emph>. The result of the <code>let</code> clause is a tuple stream consisting of one tuple with a single binding that binds <emph>V</emph> to the result of <emph>E</emph>. This tuple stream serves as input to the next clause in the FLWOR expression.</p>
            <p>If a single-variable <code>let</code> clause is an intermediate clause in a FLWOR expression, it adds a new binding for variable <emph>V</emph> to each tuple in the input tuple stream. For each input tuple, the value bound to <emph>V</emph> is the result of evaluating expression <emph>E</emph>, given the bindings that are already present in that input tuple. The resulting tuples become the output tuple stream of the <code>let</code> clause.</p>
            <p>The number of tuples in the output tuple stream of an intermediate <code>let</code> clause is the same as the number of tuples in the input tuple stream. The number of bindings in the output tuples is one more than the number of bindings in the input tuples, unless the input tuples already contain bindings for <emph>V</emph>; in this case, the new binding for <emph>V</emph> occludes (replaces) the earlier binding for <emph>V</emph>, and the number of bindings is unchanged.</p>
            <p>A <code>let</code> clause may contain one or more <termref def="dt-type-declaration"
                  >type declarations</termref>, identified by the keyword <code>as</code>. The semantics of type declarations are defined in <specref
                  ref="id-binding-rules"/>.</p>
            <p>The following code fragment illustrates how a <code>for</code> clause and a <code>let</code> clause can be used together. The <code>for</code> clause produces an initial tuple stream containing a binding for variable <code>$d</code> to each department number found in a given input document. The <code>let</code> clause adds an additional binding to each tuple, binding variable <code>$e</code> to a sequence of employees whose department number matches the value of <code>$d</code> in that tuple.</p>
            <eg><![CDATA[for $d in doc("depts.xml")/depts/deptno
let $e := doc("emps.xml")/emps/emp[deptno eq $d]]]></eg>
         </div3>



         <div3 id="id-windows" role="xquery">
            <head>Window Clause</head>
            
            <changes>
               <change issue="452" PR="483" date="2023-05-18">
                  The <code>start</code> clause in window expressions has become optional, as well as
                  the <code>when</code> keyword and its associated expression.
               </change>
            </changes>
            
            <scrap>
               <prodrecap ref="WindowClause"/>
            </scrap>

            <p>Like a <code>for</code> clause, a <code>window</code> clause
iterates over its <termref
                  def="dt-binding-sequence"
                  >binding
sequence</termref> and generates a sequence of tuples. In the case of
a <code>window</code> clause, each tuple represents a window. <termdef
                  term="window" id="dt-window"
                     >A <term>window</term> is a sequence of
consecutive items drawn from the <termref
                     def="dt-binding-sequence"
               >binding sequence</termref>.</termdef> Each
window is represented by at least one and at most nine bound
variables. The variables have user-specified names, but their roles
are as follows:</p>

            <ulist>

               <item>
                  <p>
                     <emph>Window-variable:</emph> Bound to the sequence of
  items from the <termref
                        def="dt-binding-sequence"
                     >binding
  sequence</termref> that comprise the window.</p>
               </item>

               <item>
                  <p>
                     <emph>Start-item:</emph> (Optional) Bound to the first item
  in the window.</p>
               </item>

               <item>
                  <p>
                     <emph>Start-item-position:</emph> (Optional) Bound to the
  ordinal position of the first window item in the <termref
                        def="dt-binding-sequence"
                        >binding
  sequence</termref>. <emph>Start-item-position</emph> is a <termref
                        def="dt-positional-variable"
                        >positional variable</termref>; hence, its type
  is <code>xs:integer</code>.
                  </p>
               </item>

               <item>
                  <p>
                     <emph>Start-previous-item:</emph> (Optional) Bound to the
  item in the <termref
                        def="dt-binding-sequence"
                     >binding
  sequence</termref> that precedes the first item in the window (empty
  sequence if none).</p>
               </item>

               <item>
                  <p>
                     <emph>Start-next-item:</emph> (Optional) Bound to the item
  in the <termref
                        def="dt-binding-sequence"
                     >binding sequence</termref>
  that follows the first item in the window (empty sequence if
  none).</p>
               </item>

               <item>
                  <p>
                     <emph>End-item:</emph> (Optional) Bound to the last item in
  the window.</p>
               </item>

               <item>
                  <p>
                     <emph>End-item-position:</emph> (Optional) Bound to the
  ordinal position of the last window item in the <termref
                        def="dt-binding-sequence"
                        >binding
  sequence</termref>. <emph>End-item-position</emph> is a <termref
                        def="dt-positional-variable"
                        >positional variable</termref>; hence, its type
  is <code>xs:integer</code>.
                  </p>
               </item>

               <item>
                  <p>
                     <emph>End-previous-item:</emph> (Optional) Bound to the
  item in the <termref
                        def="dt-binding-sequence"
                     >binding
  sequence</termref> that precedes the last item in the window (empty
  sequence if none).</p>
               </item>

               <item>
                  <p>
                     <emph>End-next-item:</emph> (Optional) Bound to the item in
  the <termref
                        def="dt-binding-sequence"
                     >binding sequence</termref>
  that follows the last item in the window (empty sequence if
  none).</p>
               </item>

            </ulist>

            <p>All variables in a <code>window</code> clause must have distinct names;
 otherwise a <termref
                  def="dt-static-error">static error</termref> is raised <errorref class="ST"
                  code="0103"/>.</p>

            <p>The following is an example of a <code>window</code> clause that
binds nine variables to the roles listed above. In this example, the
variables are named <code>$w</code>, <code>$s</code>,
<code>$spos</code>, <code>$sprev</code>, <code>$snext</code>,
<code>$e</code>, <code>$epos</code>, <code>$eprev</code>, and
<code>$enext</code> respectively. A <code>window</code> clause always
binds the window variable, but typically binds only a subset of the
other variables.</p>

            <eg><![CDATA[for tumbling window $w in (2, 4, 6, 8, 10)
  start $s at $spos previous $sprev next $snext when true() 
  end   $e at $epos previous $eprev next $enext when true()]]></eg>

            <p>Windows are
created by iterating over the items in the <termref
                  def="dt-binding-sequence"
                  >binding sequence</termref>, in order,
identifying the start item and the end item of each window by
evaluating the <nt
                  def="WindowStartCondition">WindowStartCondition</nt> and the <nt
                  def="WindowEndCondition"
                  >WindowEndCondition</nt>. Each of these
conditions is satisfied if the <termref
                  def="dt-ebv"
                  >effective boolean
value</termref> of the expression following the <code>when</code>
keyword is <code>true</code>.

The start item of the window is an item that satisfies the <nt
                  def="WindowStartCondition">WindowStartCondition</nt> (see <specref
                  ref="id-tumbling-windows"/> and <specref ref="id-sliding-windows"
                  /> for a more complete explanation.) The end item of the window is the first item in the <termref
                  def="dt-binding-sequence"
                  >binding sequence</termref>, beginning with the start item, that satisfies the <nt
                  def="WindowEndCondition">WindowEndCondition</nt> (again, see <specref
                  ref="id-tumbling-windows"/> and <specref ref="id-sliding-windows"
                  /> for more details.) Each window contains its start item, its end
item, and all items that occur between them in the <termref
                  def="dt-binding-sequence"
                  >binding sequence</termref>.
If the end item is the start item, then the window contains only one
item.  If a start item is identified, but no following item in the <termref
                  def="dt-binding-sequence">binding sequence</termref> satisfies the <nt
                  def="WindowEndCondition"
                  >WindowEndCondition</nt>, then the <code>only</code> keyword determines whether a window is
generated: if <code>only end</code> is specified, then no window is
generated; otherwise, the end item is set to the last item in the
<termref
                  def="dt-binding-sequence"
               >binding sequence</termref> and a window is generated.</p>
            <p>In the above example, the <nt def="WindowStartCondition"
                  >WindowStartCondition</nt> and <nt def="WindowEndCondition"
                  >WindowEndCondition</nt> are both <code>true</code>,
which causes each item in the <termref
                  def="dt-binding-sequence"
                  >binding sequence</termref> to be in a separate window. 
Typically, the <nt
                  def="WindowStartCondition">WindowStartCondition</nt> and <nt
                  def="WindowEndCondition"
                  >WindowEndCondition</nt> are expressed in terms of bound variables. For example, the following <nt
                  def="WindowStartCondition"
                  >WindowStartCondition</nt> might be used to start a new window for every item in the <termref
                  def="dt-binding-sequence"
               >binding sequence</termref> that is larger than both the previous item and the following item:</p>
            <eg>start $s previous $sprev next $snext
when  $s &gt; $sprev and $s &gt; $snext</eg>
            <p>The scoping rules for the variables bound by a <code>window</code> clause are as follows:</p>
            <ulist>



               <item>
                  <p>In the <code>when</code>-expression of the <nt def="WindowStartCondition"
                        >WindowStartCondition</nt>, the following variables (identified here by their roles) are in scope (if bound): <emph>start-item, start-item-position, start-previous-item, start-next-item.</emph>
                  </p>
               </item>



               <item>
                  <p>In the <code>when</code>-expression of the <nt def="WindowEndCondition"
                        >WindowEndCondition</nt>, the following variables (identified here by their roles) are in scope (if bound): <emph>start-item, start-item-position, start-previous-item, start-next-item, end-item, end-item-position, end-previous-item, end-next-item.</emph>
                  </p>
               </item>



               <item>
                  <p>In the clauses of the FLWOR expression that follow the <code>window</code> clause, all nine of the variables bound by the <code>window</code> clause (including <emph>window-variable</emph>) are in scope (if bound).</p>
               </item>
            </ulist>

            <p>The <code>when</code> keyword of a condition and the associated expression is optional.
               If omitted, the expression defaults to <code>true()</code>.
               If the complete <code>start</code> clause is omitted, no variables are bound and
               the expression also defaults to <code>true()</code>.
               The <code>end</code> clause can be omitted only within a <nt
                  def="TumblingWindowClause">TumblingWindowClause</nt>.</p>

            <p>In a <code>window</code> clause, the keyword <code>tumbling</code> or <code>sliding</code> determines the way in which the starting item of each window is identified, as explained in the following sections.</p>
            <div4 id="id-tumbling-windows">
               <head>Tumbling Windows</head>



               <p>If the window type is <code>tumbling</code>, then windows
never overlap. The search for the start of the first window begins at the beginning of the <termref
                     def="dt-binding-sequence"
                     >binding sequence</termref>. After each window is generated, the search
for the start of the next window begins with the item in the <termref
                     def="dt-binding-sequence"
                     >binding sequence</termref> that occurs after the ending item of the last generated
window. Thus, no item that occurs in one window can occur in another
window drawn from the same <termref
                     def="dt-binding-sequence"
                     >binding sequence</termref> (unless the sequence contains the same item more than once). 
In a tumbling window clause,
the <code>end</code> clause is optional; if it is omitted, the
<code>start</code> clause is applied to identify all potential
starting items in the <termref
                     def="dt-binding-sequence"
                     >binding sequence</termref>, and a window is constructed
for each starting item, including all items from that starting item up
to the item before the next window’s starting item, or the end of the
<termref
                     def="dt-binding-sequence"
                  >binding sequence</termref>, whichever comes first.</p>
               <p>The following examples illustrate the use of tumbling windows.</p>
               <ulist>



                  <item>
                     <p>Show non-overlapping windows of three items.</p>
                     <eg role="parse-test"><![CDATA[for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
  start at $s
  only end at $e when $e - $s eq 2
return <window>{ $w }</window>]]></eg>

                     <p>Result:</p>
                     <eg><![CDATA[<window>2 4 6</window>
<window>8 10 12</window>]]></eg>
                  </item>



                  <item>
                     <p>Show averages of non-overlapping three-item windows.</p>
                     <eg role="parse-test"><![CDATA[
for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
  start at $s
  only end at $e when $e - $s eq 2
return avg($w)]]></eg>

                     <p>Result:</p>
                     <eg><![CDATA[4 10]]></eg>
                  </item>



                  <item>
                     <p>Show first and last items in each window of three items.</p>
                     <eg role="parse-test"><![CDATA[for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
  start $first at $s
  only end $last at $e when $e - $s eq 2
return <window>{ $first, $last }</window>]]></eg>

                     <p>Result:</p>
                     <eg><![CDATA[<window>2 6</window>
<window>8 12</window>]]></eg>
                  </item>



                  <item>
                     <p>Show non-overlapping windows of up to three items (illustrates <code>end</code> clause without the <code>only</code> keyword).</p>
                     <eg role="parse-test"><![CDATA[for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
  start at $s
  end at $e when $e - $s eq 2
return <window>{ $w }</window>]]></eg>

                     <p>Result:</p>
                     <eg><![CDATA[<window>2 4 6</window>
<window>8 10 12</window>
<window>14</window>]]></eg>
                  </item>



                  <item>
                     <p>Show non-overlapping windows of up to three items (illustrates use of <code>start</code> without explicit <code>end</code>).</p>
                     <eg role="parse-test"><![CDATA[for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
  start at $s when $s mod 3 = 1
return <window>{ $w }</window>]]></eg>

                     <p>Result:</p>
                     <eg><![CDATA[<window>2 4 6</window>
<window>8 10 12</window>
<window>14</window>]]></eg>
                  </item>



                  <item>
                     <p>Show non-overlapping sequences starting with a number divisible by 3.</p>

                     <eg role="parse-test"><![CDATA[for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
  start $first when $first mod 3 = 2
return <window>{ $w }</window>]]></eg>

                     <p>Result:</p>
                     <eg><![CDATA[<window>2 4 6</window>
<window>8 10 12</window>
<window>14</window>]]></eg>
                  </item>

                  <item>
                     <p>Show non-overlapping sequences ending with a number divisible by 3.</p>

                     <eg role="parse-test"><![CDATA[for tumbling window $w in (2, 4, 6, 8, 10, 12, 14)
  end $last when $last mod 3 = 0
return <window>{ $w }</window>]]></eg>

                     <p>Result (identical to the result of the previous query):</p>
                     <eg><![CDATA[<window>2 4 6</window>
<window>8 10 12</window>
<window>14</window>]]></eg>
                  </item>

               </ulist>










            </div4>
            <div4 id="id-sliding-windows">
               <head>Sliding Windows</head>

               <p>If the window type is <code>sliding window</code>, then windows may
overlap. Every item in the <termref
                     def="dt-binding-sequence">binding sequence</termref> that satisfies the <nt
                     def="WindowStartCondition"
                     >WindowStartCondition</nt> is the starting item of a new window. Thus, a given
item may be found in multiple windows drawn from the same <termref
                     def="dt-binding-sequence">binding sequence</termref>.</p>
               <p>The following examples illustrate the use of sliding windows.</p>


               <ulist>



                  <item>
                     <p>Show windows of three items.</p>
                     <eg role="parse-test"><![CDATA[for sliding window $w in (2, 4, 6, 8, 10, 12, 14)
  start at $s
  only end at $e when $e - $s eq 2
return <window>{ $w }</window>]]></eg>

                     <p>Result:</p>

                     <eg><![CDATA[<window>2 4 6</window>
<window>4 6 8</window>
<window>6 8 10</window>
<window>8 10 12</window>
<window>10 12 14</window>]]></eg>
                  </item>



                  <item>
                     <p>Show moving averages of three items.</p>

                     <eg role="parse-test"><![CDATA[for sliding window $w in (2, 4, 6, 8, 10, 12, 14)
  start at $s
  only end at $e when $e - $s eq 2
return avg($w)]]></eg>

                     <p>Result:</p>
                     <eg><![CDATA[4 6 8 10 12]]></eg>
                  </item>



                  <item>
                     <p>Show overlapping windows of up to three items (illustrates <code>end</code> clause without the <code>only</code> keyword).</p>

                     <eg role="parse-test"><![CDATA[for sliding window $w in (2, 4, 6, 8, 10, 12, 14)
  start at $s
  end at $e when $e - $s eq 2
return <window>{ $w }</window>]]></eg>

                     <p>Result:</p>
                     <eg><![CDATA[<window>2 4 6</window>
<window>4 6 8</window>
<window>6 8 10</window>
<window>8 10 12</window>
<window>10 12 14</window>
<window>12 14</window>
<window>14</window>]]></eg>
                  </item>
               </ulist>





            </div4>
            <div4 id="id-effects-of-window-clauses">
               <head>Effects of Window Clauses on the Tuple Stream</head>
               <p>The effects of a <code>window</code> clause on the tuple stream are similar to the effects of a <code>for</code> clause. As described in <specref
                     ref="id-windows"
                  />, a <code>window</code> clause generates zero or more windows, each of which is represented by at least one and at most nine bound variables.</p>
               <p>If the <code>window</code> clause is the initial clause in a FLWOR expression, 
                  the bound variables that describe each window become an output tuple. 
                  These tuples form the initial tuple stream that serves as input to the next clause of the FLWOR expression. 
                  The order of tuples in the tuple stream is the
                  order in which their start items appear in the <termref
                     def="dt-binding-sequence"
                     >binding sequence</termref>. The cardinality of the tuple stream is equal to the number of windows.</p>
               <p>If a <code>window</code> clause is an intermediate clause in a FLWOR expression, each input tuple generates zero or more output tuples, each consisting of  the original bound variables of the input tuple plus the new bound variables that represent one of the generated windows. For each tuple <emph>T</emph> in the input tuple stream, the output tuple stream will contain <emph>N<sub>T</sub>
                  </emph> tuples, where <emph>N<sub>T</sub>
                  </emph> is the number of windows generated by the <code>window</code> clause, 
                  given the bindings in the input tuple <emph>T</emph>. Input tuples for which no windows 
                  are generated are not represented in the output tuple stream. 
                  The order of tuples in the output stream is determined primarily by the order of the 
                  input tuples from which they were derived, and secondarily by the order in which their 
                  start items appear in the <termref
                     def="dt-binding-sequence">binding sequence</termref>. </p>
               <p>The following example illustrates a <code>window</code> clause that is the initial clause in a FLWOR expression. The example is based on input data that consists of a sequence of closing stock prices for a specific company. For this example we assume the following input data (assume that the <code>price</code> elements have a validated type of <code>xs:decimal</code>):</p>
               <eg><![CDATA[<stock>
  <closing> <date>2008-01-01</date> <price>105</price> </closing>
  <closing> <date>2008-01-02</date> <price>101</price> </closing>
  <closing> <date>2008-01-03</date> <price>102</price> </closing>
  <closing> <date>2008-01-04</date> <price>103</price> </closing>
  <closing> <date>2008-01-05</date> <price>102</price> </closing>
  <closing> <date>2008-01-06</date> <price>104</price> </closing>
</stock>]]></eg>
               <p>A user wishes to find “run-ups,” which are defined as sequences of dates that begin with a “low” and end with a “high” price (that is, the stock price begins to rise on the first day of the run-up, and continues to rise or remain even through the last day of the run-up.) The following query uses a tumbling window to find run-ups in the input data:</p>
               <eg role="parse-test">for tumbling window $w in //closing
   start $first next $second when $first/price &lt; $second/price
   end $last next $beyond when $last/price &gt; $beyond/price
return
  &lt;run-up&gt;
    &lt;start-date&gt;{ data($first/date) }&lt;/start-date&gt;
    &lt;start-price&gt;{ data($first/price) }&lt;/start-price&gt;
    &lt;end-date&gt;{ data($last/date) }&lt;/end-date&gt;
    &lt;end-price&gt;{ data($last/price) }&lt;/end-price&gt;
  &lt;/run-up&gt;</eg>
               <p>For our sample input data, this <code>tumbling window</code> clause generates a tuple stream consisting of two tuples, each representing a window and containing five bound variables named <code>$w</code>, <code>$first</code>, <code>$second</code>, <code>$last</code>, and <code>$beyond</code>. The <code>return</code> clause is evaluated for each of these tuples, generating the following query result:</p>
               <eg>&lt;run-up&gt;
  &lt;start-date&gt;2008-01-02&lt;/start-date&gt;
  &lt;start-price&gt;101&lt;/start-price&gt;
  &lt;end-date&gt;2008-01-04&lt;/end-date&gt;
  &lt;end-price&gt;103&lt;/end-price&gt;
&lt;/run-up&gt;
&lt;run-up&gt;
  &lt;start-date&gt;2008-01-05&lt;/start-date&gt;
  &lt;start-price&gt;102&lt;/start-price&gt;
  &lt;end-date&gt;2008-01-06&lt;/end-date&gt;
  &lt;end-price&gt;104&lt;/end-price&gt;
&lt;/run-up&gt;</eg>
               <p>The following example illustrates a <code>window</code> clause that is an intermediate clause in a FLWOR expression. In this example, the input data contains closing stock prices for several different companies, each identified by a three-letter symbol. We assume the following input data (again assuming that the type of the <code>price</code> element is <code>xs:decimal</code>):</p>
               <eg><![CDATA[<stocks>
  <closing> <symbol>ABC</symbol> <date>2008-01-01</date> <price>105</price> </closing>
  <closing> <symbol>DEF</symbol> <date>2008-01-01</date> <price>057</price> </closing>
  <closing> <symbol>ABC</symbol> <date>2008-01-02</date> <price>101</price> </closing>
  <closing> <symbol>DEF</symbol> <date>2008-01-02</date> <price>054</price> </closing>
  <closing> <symbol>ABC</symbol> <date>2008-01-03</date> <price>102</price> </closing>
  <closing> <symbol>DEF</symbol> <date>2008-01-03</date> <price>056</price> </closing>
  <closing> <symbol>ABC</symbol> <date>2008-01-04</date> <price>103</price> </closing>
  <closing> <symbol>DEF</symbol> <date>2008-01-04</date> <price>052</price> </closing>
  <closing> <symbol>ABC</symbol> <date>2008-01-05</date> <price>101</price> </closing>
  <closing> <symbol>DEF</symbol> <date>2008-01-05</date> <price>055</price> </closing>
  <closing> <symbol>ABC</symbol> <date>2008-01-06</date> <price>104</price> </closing>
  <closing> <symbol>DEF</symbol> <date>2008-01-06</date> <price>059</price> </closing>
</stocks>]]></eg>
               <p>As in the previous example, we want to find "run-ups," which are defined as sequences of dates that begin with a "low" and end with a "high" price for a specific company. In this example, however, the input data consists of stock prices for multiple companies. Therefore it is necessary to isolate the stock prices of each company before forming windows. This can be accomplished by an initial <code>for</code> and <code>let</code> clause, followed by a <code>window</code> clause, as follows:</p>
               <eg role="parse-test">for $symbol in distinct-values(//symbol)
let $closings := //closing[symbol = $symbol]
for tumbling window $w in $closings
  start $first next $second when $first/price &lt; $second/price
  end $last next $beyond when $last/price &gt; $beyond/price
return
  &lt;run-up symbol="{ $symbol }"&gt;
    &lt;start-date&gt;{ data($first/date) }&lt;/start-date&gt;
    &lt;start-price&gt;{ data($first/price) }&lt;/start-price&gt;
    &lt;end-date&gt;{ data($last/date) }&lt;/end-date&gt;
    &lt;end-price&gt;{ data($last/price) }&lt;/end-price&gt;
  &lt;/run-up&gt;</eg>
               <note>
                  <p>In the above example, the <code>for</code> and <code>let</code> clauses could be rewritten as follows:</p>
                  <eg><![CDATA[for $closings in //closing
let $symbol := $closings/symbol
group by $symbol]]></eg>
                  <p>The <code>group by</code> clause is described in <specref ref="id-group-by"
                     />.</p>
               </note>
               <p>The <code>for</code> and <code>let</code> clauses in this query generate an initial tuple stream consisting of two tuples. In the first tuple, <code>$symbol</code> is bound to "ABC" and <code>$closings</code> is bound to the sequence of <code>closing</code> elements for company ABC. In the second tuple, <code>$symbol</code> is bound to "DEF" and <code>$closings</code> is bound to the sequence of <code>closing</code> elements for company DEF.</p>
               <p>The <code>window</code> clause operates on this initial tuple stream, generating two windows for the first tuple and two windows for the second tuple. The result is a tuple stream consisting of four tuples, each with the following bound variables: <code>$symbol</code>, <code>$closings</code>, <code>$w</code>, <code>$first</code>, <code>$second</code>, <code>$last</code>, and <code>$beyond</code>. The <code>return</code> clause is then evaluated for each of these tuples, generating the following query result:</p>
               <eg>&lt;run-up symbol="ABC"&gt;
   &lt;start-date&gt;2008-01-02&lt;/start-date&gt;
   &lt;start-price&gt;101&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-04&lt;/end-date&gt;
   &lt;end-price&gt;103&lt;/end-price&gt;
&lt;/run-up&gt;
&lt;run-up symbol="ABC"&gt;
   &lt;start-date&gt;2008-01-05&lt;/start-date&gt;
   &lt;start-price&gt;101&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-06&lt;/end-date&gt;
   &lt;end-price&gt;104&lt;/end-price&gt;
&lt;/run-up&gt;
&lt;run-up symbol="DEF"&gt;
   &lt;start-date&gt;2008-01-02&lt;/start-date&gt;
   &lt;start-price&gt;054&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-03&lt;/end-date&gt;
   &lt;end-price&gt;056&lt;/end-price&gt;
&lt;/run-up&gt;
&lt;run-up symbol="DEF"&gt;
   &lt;start-date&gt;2008-01-04&lt;/start-date&gt;
   &lt;start-price&gt;052&lt;/start-price&gt;
   &lt;end-date&gt;2008-01-06&lt;/end-date&gt;
   &lt;end-price&gt;059&lt;/end-price&gt;
&lt;/run-up&gt;</eg>
            </div4>
         </div3>


         
         
         <div3 id="id-where" role="xquery">
            <head>Where Clause</head>
            <scrap>
               <prodrecap ref="WhereClause"/>
            </scrap>
            <p>A <code>where</code> clause serves as a filter for the tuples in its input tuple stream. The expression in the <code>where</code> clause, called the <term>where-expression</term>, is evaluated once for
               each of these tuples. If the <termref
                  def="dt-ebv"
                  >effective boolean value</termref> of the
               where-expression is <code>true</code>, the tuple is retained in the output tuple stream; otherwise the tuple is discarded.</p>
            <p>Examples:</p>
            <ulist>
               
               
               
               <item>
                  <p>This example illustrates the effect of a <code>where</code> clause on a tuple stream:</p>
                  <p>Input tuple stream:</p>
                  <eg><![CDATA[($a = 5, $b = 11)
($a = 91, $b = 42)
($a = 17, $b = 30)
($a = 85, $b = 63)]]></eg>
                  <p>
                     <code>where</code> clause:</p>
                  <eg>where $a &gt; $b</eg>
                  <p>Output tuple stream:</p>
                  <eg><![CDATA[($a = 91, $b = 42)
($a = 85, $b = 63)]]></eg>
               </item>
               
               
               
               <item>
                  <p>The following query illustrates how a <code>where</code> clause might be used with a <termref
                     def="dt-positional-variable"
                     >positional variable</termref> to perform sampling on an input sequence. The query returns one value out of each one hundred input values.</p>
                  <eg role="parse-test">
                     <phrase role="parse-test">for $x at $i in $input
where $i mod 100 = 0
return $x</phrase>
                  </eg>
               </item>
            </ulist>
         </div3>
         
         <div3 id="id-while" diff="add" at="issue187" role="xquery">
            <head>While Clause</head>
            
            <changes>
               <change issue="187" PR="943" date="2024-02-06">
                  A FLWOR expression may now include a <code>while</code> clause,
               which causes early exit from the iteration when a condition is encountered.
               </change>
            </changes>
            
            <scrap>
               <prodrecap ref="WhileClause"/>
            </scrap>
            
            <p>A <code>while</code> clause serves as a filter for the tuples 
               in its input tuple stream. The expression in the while clause, 
               called the <code>while-expression</code>, is evaluated once for each of these tuples. 
               If the <termref def="dt-ebv">effective boolean value</termref> 
               of the <code>while-expression</code> is true, the 
               tuple is retained in the output tuple stream; otherwise the tuple 
               and all subsequent tuples in the stream are discarded.</p>
            
            <p>Examples:</p>
            
            <ulist>
               <item>
                  <p>This example illustrates the effect of a <code>while</code> clause on a tuple stream.</p>
                  <p>Input tuple stream:</p>
                  <eg><![CDATA[($a = 13, $b = 11)
($a = 91, $b = 42)
($a = 17, $b = 30)
($a = 85, $b = 63)]]></eg><p>while clause:</p>
                  <eg>while $a > $b</eg>
                  <p> Output tuple stream:</p>
                  <eg><![CDATA[($a = 13, $b = 11)
($a = 91, $b = 42)]]></eg>
               </item>
               <item>
                  <p>The following query illustrates how a <code>while</code> clause might be used to 
                     extract all items in an input sequence before the first one that 
                     fails to satisfy some condition. In this case it selects the 
                     leading <code>para</code> elements in the input sequence, stopping 
                     before the first element that is not a <code>para</code> element.
                  </p>
                  <eg><![CDATA[for $x in $section/*
while $x[self::para]
return $x]]></eg>
               </item>
               <item>
                  <p>The following query illustrates how a <code>while</code> clause might be used to 
                     limit the number of items returned in the query result.
                  </p>
                  <eg><![CDATA[for $x in $section/para
where contains($x, 'the')
count $total
while $total le 10
return $x]]></eg>
                  <p>In this example a <code>where</code> clause would have exactly the same effect,
                  but might require a smarter optimizer to deliver the same performance.</p>
               </item>
            </ulist>
            
            <note>
               <p>Although the semantics are described in terms of discarding 
                  all the tuples following the first one that fails to match 
                  the condition, a practical implementation is likely to avoid 
                  evaluating those tuples, thus giving an "early exit" from 
                  the iteration performed by the FLWOR expression.
               </p>
            </note>
            
            <note><p>The expression <code>for $i in $input while $i le 3</code> differs
               from the expression <code>subsequence-where($input, to := fn {. gt 3 })</code> in that
               the <code>while</code> expression drops the first item that is greater than 3,
               while the <code>subsequence-where</code> expression retains it.</p></note>
            
            <note><p>The effect of the <code>while</code> clause is unpredictable in cases
            where the ordering of the tuple stream is unpredictable. This can happen, for example,
            when iterating over the entries in a map.</p></note>
            
            
            
         </div3>

         <div3 id="id-count" role="xquery">
            <head>Count Clause</head>
            <scrap>
               <prodrecap ref="CountClause"/>
            </scrap>

            <p>The purpose of a <code>count</code> clause is to enhance the tuple
stream with a new variable that is bound, in each tuple, to the
ordinal position of that tuple in the tuple stream. The name of the
new variable is specified in the <code>count</code> clause. Its type
            is implicitly <code>xs:integer</code>.</p>

            <p>The output tuple stream of a <code>count</code> clause is the same
as its input tuple stream, with each tuple enhanced by one additional
variable that is bound to the ordinal position of that tuple in the
tuple stream. However, if the name of the new variable is the same as
the name of an existing variable in the input tuple stream, the new
variable occludes (replaces) the existing variable of the same name,
and the number of bound variables in each tuple is unchanged.</p>

            <p>The following examples illustrate uses of the <code>count</code> clause:</p>


            <ulist>



               <item>
                  <p>This example illustrates the effect of a <code>count</code> clause on an input tuple stream:</p>
                  <p>Input tuple stream:</p>
                  <eg><![CDATA[($name = "Bob", $age = 21)
($name = "Carol", $age = 19)
($name = "Ted", $age = 20)
($name = "Alice", $age = 22)]]></eg>
                  <p>
                     <code>count</code> clause:</p>
                  <eg><![CDATA[count $counter]]></eg>
                  <p>Output tuple stream:</p>
                  <eg><![CDATA[($name = "Bob", $age = 21, $counter = 1)
($name = "Carol", $age = 19, $counter = 2)
($name = "Ted", $age = 20, $counter = 3)
($name = "Alice", $age = 22, $counter = 4)]]></eg>
               </item>





               <item>
                  <p>This example illustrates how a counter might be used to filter the result of a query. The query ranks products in order by decreasing sales, and returns the three products with the highest sales. Assume that the variable <code>$products</code> is bound to a sequence of <code>product</code> elements, each of which has <code>name</code> and <code>sales</code> child-elements.</p>
                  <eg role="parse-test">for $p in $products
order by $p/sales descending
count $rank
while $rank &lt;= 3
return &lt;product rank="{ $rank }"&gt;{ $p/name, $p/sales }&lt;/product&gt;</eg>
                  <p>The result of this query has the following structure:</p>
                  <eg>&lt;product rank="1"&gt;
  &lt;name&gt;Toaster&lt;/name&gt;
  &lt;sales&gt;968&lt;/sales&gt;
&lt;/product&gt;
&lt;product rank="2"&gt;
  &lt;name&gt;Blender&lt;/name&gt;
  &lt;sales&gt;520&lt;/sales&gt;
&lt;/product&gt;
&lt;product rank="3"&gt;
  &lt;name&gt;Can Opener&lt;/name&gt;
  &lt;sales&gt;475&lt;/sales&gt;
&lt;/product&gt;</eg>
               </item>
            </ulist>
         </div3>

         <div3 id="id-group-by" role="xquery">
            <head>Group By Clause</head>
            <scrap>
               <prodrecap ref="GroupByClause"/>
            </scrap>


            <p>A <code>group by</code> clause generates an output tuple stream in which each tuple represents a group of tuples from the input tuple stream
that have equivalent grouping keys. 
We will refer to the tuples in the input tuple stream as  <term>pre-grouping tuples</term>, and the tuples in the output tuple stream as <term>post-grouping tuples</term>.</p>

            <p>The <code>group by</code> clause assigns each pre-grouping tuple to a group, and
generates one post-grouping tuple for each group. 

In the post-grouping tuple for a group, each grouping key is represented by a variable that was specified in a <nt
                  def="GroupingSpec"
               >GroupingSpec</nt>, and every variable that appears in the pre-grouping tuples that were assigned to that group is represented by a variable of the same name, bound to a sequence of all values bound to the variable in any of these pre-grouping tuples.

Subsequent clauses in the FLWOR expression see only the variable
bindings in the post-grouping tuples; they no longer have access to
the variable bindings in the pre-grouping tuples. 
The number of post-grouping tuples is less than or equal to
the number of pre-grouping tuples.</p>

            <p>A <code>group by</code> clause contains one or more <nt def="GroupingSpec"
                  >grouping specifications</nt>, as shown in the grammar. <termdef
                  id="dt-grouping-variable" term="grouping variable"
                     >Each grouping specification specifies one <term>grouping variable</term>, 
                     which refers to variable bindings in the pre-grouping tuples. The values of the grouping variables are used to assign pre-grouping tuples to groups.</termdef> Each grouping specification may optionally provide an expression to which its grouping variable is bound.  If no expression is provided, the grouping variable name must be equal (by the <code>eq</code> operator on <termref
                  def="dt-expanded-qname"
                  >expanded QNames</termref>) to the name of a variable in the input tuple stream, and it refers to that variable; otherwise a <termref
                  def="dt-static-error">static error</termref> is raised <errorref class="ST"
                  code="0094"
                  />. For each grouping specification that contains a binding expression, a <code>let</code> binding is created in the pre-grouping tuples, and the grouping variable refers to that <code>let</code> binding. For example, the clause:</p>

            <eg><![CDATA[group by $g1, $g2 := $expr1, $g3 := $expr2 collation "Spanish"]]></eg>

            <p>is semantically equivalent to the following sequence of clauses:</p>

            <eg><![CDATA[let $g2 := $expr1
let $g3 := $expr2
group by $g1, $g2, $g3 collation "Spanish"]]></eg>

            <p>The process of group formation proceeds as follows:

<olist> <item>
                     <p>
                        <termdef term="grouping key" id="dt-grouping-key"
                              >The
  atomized value of a <termref def="dt-grouping-variable"
                              >grouping
  variable</termref> is called a <term>grouping key</term>.</termdef>
  For each pre-grouping tuple, the <termref
                           def="dt-grouping-key">grouping keys</termref> are created by
  <termref
                           def="dt-atomization">atomizing</termref> the values of the
  <termref
                           def="dt-grouping-variable"
                           >grouping variables</termref> (in
  the post-grouping tuples, each grouping variable is set to the value
  of the corresponding grouping key, as discussed below).

  If the value of any <termref
                           def="dt-grouping-variable"
                           >grouping variable</termref> consists of
  more than one item, a <termref
                           def="dt-type-error">type
  error</termref> is raised <errorref class="TY"
                           code="0004"
                           />. If a type declaration is present
  and the resulting atomized value is not an instance of the specified
  type, a <termref
                           def="dt-type-error">type error</termref> is raised
  <errorref class="TY"
                           code="0004"/>.</p>
                  </item> <item>
                     <p>The input tuple stream is partitioned into groups of tuples
  whose grouping keys are <termref
                           def="dt-equivalent-grouping-keys">equivalent</termref>. <termdef
                           id="dt-equivalent-grouping-keys" term="equivalent grouping keys"
                              >Two
  tuples <var>T1</var> and <var>T2</var> have <term>equivalent
  grouping keys</term> if and only if, for each grouping variable
  <var>GV</var>, the atomized value of <var>GV</var> in <var>T1</var>
  is deep-equal to the atomized value of <var>GV</var> in
  <var>T2</var>, as defined by applying the function
  <function>fn:deep-equal</function> using the appropriate
  collation.</termdef></p>
                     
                     <note diff="add" at="2023-12-05"><p>The <function>fn:deep-equal</function> has been changed
                     in &language; so that it is now transitive; the problem that existed
                     in earlier versions when comparing numeric values of different
                     types has thereby been resolved.</p></note>

  <note>
                        <p>The atomized grouping key will always be either an empty
     sequence or a single atomic item. Defining equivalence by
     reference to the <function>fn:deep-equal</function> function
     ensures that the empty sequence is equivalent only to the empty
     sequence, that <code>NaN</code> is equivalent to
     <code>NaN</code>, that untypedAtomic items are compared as
     strings, and that values for which the <code>eq</code> operator
     is not defined are considered
     non-equivalent.</p>
                     </note> </item> <item>
                     <p>The appropriate collation for comparing two grouping keys is the collation
   specified in the pertinent <nt
                           def="GroupingSpec"
                           >GroupingSpec</nt> if present, or the default collation
                        from the <phrase diff="chg" at="2023-05-19">dynamic</phrase> context otherwise. 
                        If the collation is specified by a relative
   URI, that relative URI is  <termref
                           def="dt-resolve-relative-uri"
                           >resolved to
   an absolute URI</termref> using the <termref
                           def="dt-static-base-uri"
                           >Static Base URI</termref>.
   If the specified collation is not found in statically known
   collations, a static error is raised  <errorref
                           class="ST" code="0076"/>.</p>
                  </item> </olist>
            </p>



            <p>Each group of tuples produced by the above process results in one
post-grouping tuple. The pre-grouping tuples from which the group is
derived have <emph>equivalent</emph>
               <termref def="dt-grouping-key"
                  >grouping keys</termref>, but these keys are not
necessarily identical (for example, the strings <code>"Frog"</code> and <code>"frog"</code>
might be <emph>equivalent</emph> according to the collation in use.)

In the post-grouping tuple, each <termref
                  def="dt-grouping-variable"
               >grouping variable</termref> is bound to the
value of the corresponding grouping key. 
</p>

            <p>In the post-grouping tuple generated for a given group, each
non-grouping variable is bound to a sequence containing the
concatenated values of that variable in all the pre-grouping tuples
that were assigned to that group. The values derived from individual tuples are
concatenated in a way that preserves the order of the pre-grouping
tuple stream.</p>


            <note>
               <p>This behavior may be surprising to SQL programmers, since SQL reduces
the equivalent of a non-grouping variable to one representative
value. Consider the following query:</p>

               <eg role="parse-test"><![CDATA[let $x := 64000
for $c in //customer
where $c/salary > $x
group by $d := $c/department
return <department name="{ $d }">
  Number of employees earning more than ${ $x } is { count($c) }
</department>]]></eg>

               <p>If there are three qualifying customers in the sales department this
evaluates to:</p>

               <eg><![CDATA[
<department name="sales">
  Number of employees earning more than $64000 64000 64000 is 3
</department>]]></eg>

               <p>In XQuery, each group is a sequence of items that match the group
by criteria&mdash;in a tree-structured language like XQuery, this is
convenient, because further structures can be built based on the items
in this sequence. Because there are three items in the group,
<code>$x</code> evaluates to a sequence of three items. To reduce this
to one item, use <code>fn:distinct-values()</code>:</p>

               <eg role="parse-test"><![CDATA[
let $x := 64000
for $c in //customer
let $d := $c/department
where $c/salary > $x
group by $d
return <department name="{ $d }">
  Number of employees earning more than ${ distinct-values($x) } is { count($c) }
</department>]]></eg>
            </note>

            <note>
               <p>In general, the <termref def="dt-static-type"
                     >static
type</termref> of a variable in a post-grouping tuple is different
from the <termref
                     def="dt-static-type"
                  >static type</termref> of the
variable with the same name in the pre-grouping
tuples.</p>
            </note>
            <p>The order in which tuples appear in the
post-grouping tuple stream is <termref
                  def="dt-implementation-dependent">implementation-dependent</termref>.</p>
            <note>
               <p>An
<code>order by</code> clause can be used to impose a value-based
ordering on the post-grouping tuple stream. Similarly, if it is
desired to impose a value-based ordering within a group (i.e., on the
sequence of items bound to a non-grouping variable), this can be
accomplished by a nested FLWOR expression that iterates over these
items and applies an <code>order by</code> clause. In some cases, a
value-based ordering within groups can be accomplished by applying an
<code>order by</code> clause on a non-grouping variable before
applying the <code>group by</code> clause.</p>
            </note>
            <p>A <code>group
by</code> clause rebinds all the variables in the input tuple
stream. The scopes of these variables are not affected by the
<code>group by</code> clause, but in post-grouping tuples the values
of the variables represent group properties rather than properties of
individual pre-grouping tuples.</p>

            <p>Examples:</p>
            <ulist>
               <item>
                  <p>This example illustrates the effect of a <code>group by</code> clause on a tuple stream.</p>

                  <p>Input tuple stream:</p>

                  <eg>($storeno = &lt;storeno&gt;S101&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P78395&lt;/itemno&gt;)
($storeno = &lt;storeno&gt;S102&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P94738&lt;/itemno&gt;)
($storeno = &lt;storeno&gt;S101&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P41653&lt;/itemno&gt;)
($storeno = &lt;storeno&gt;S102&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P70421&lt;/itemno&gt;)
</eg>

                  <p>
                     <code>group by</code> clause:</p>

                  <eg><![CDATA[group by $storeno]]></eg>

                  <p>Output tuple stream:</p>

                  <eg>($storeno = S101, $itemno = (&lt;itemno&gt;P78395&lt;/itemno&gt;, &lt;itemno&gt;P41653&lt;/itemno&gt;))
($storeno = S102, $itemno = (&lt;itemno&gt;P94738&lt;/itemno&gt;, &lt;itemno&gt;P70421&lt;/itemno&gt;))</eg>
               </item>
            </ulist>
            <ulist>



               <item>
                  <p>This example and the ones that follow are based on two separate sequences of elements, named <code>$sales</code> and <code>$products</code>. We assume that the variable <code>$sales</code> is bound to a sequence of elements with the following structure:</p>
                  <eg>&lt;sales&gt;
  &lt;storeno&gt;S101&lt;/storeno&gt;
  &lt;itemno&gt;P78395&lt;/itemno&gt;
  &lt;qty&gt;125&lt;/qty&gt;
&lt;/sales&gt;</eg>
                  <p>We also assume that the variable <code>$products</code> is bound to a sequence of  elements with the following structure:</p>
                  <eg>&lt;product&gt;
  &lt;itemno&gt;P78395&lt;/itemno&gt;
  &lt;price&gt;25.00&lt;/price&gt;
  &lt;category&gt;Men's Wear&lt;/category&gt;
&lt;/product&gt;</eg>
                  <p>The simplest kind of grouping query has a single <termref
                        def="dt-grouping-variable"
                     >grouping variable</termref>. The query in this example finds the total quantity of items sold by each store:</p>
                  <eg role="parse-test">for $s in $sales
let $storeno := $s/storeno
group by $storeno
return &lt;store number="{ $storeno }" total-qty="{ sum($s/qty) }"/&gt;</eg>
                  <p>The result of this query is a sequence of elements with the following structure:</p>
                  <eg>&lt;store number="S101" total-qty="1550" /&gt;
&lt;store number="S102" total-qty="2125" /&gt;</eg>
               </item>



               <item>
                  <p>In a more realistic example, a user might be interested in the total revenue generated by each store for each product category. Revenue depends on both the quantity sold of various items and the price of each item. The following query joins the two input sequences and groups the resulting tuples by two <termref
                        def="dt-grouping-variable">grouping variables</termref>:</p>

                  <eg role="parse-test">
for $s in $sales
for $p in $products[itemno = $s/itemno]
let $revenue := $s/qty * $p/price
group by $storeno := $s/storeno, 
         $category := $p/category
return &lt;summary storeno="{ $storeno }"
                category="{ $category }"
                revenue="{ sum($revenue) }"/>
</eg>


                  <p>The result of this query is a sequence of elements with the following structure:</p>
                  <eg>&lt;summary storeno="S101" category="Men's Wear" revenue="10185"/&gt;
&lt;summary storeno="S101" category="Stationery" revenue="4520"/&gt;
&lt;summary storeno="S102" category="Men's Wear" revenue="9750"/&gt;
&lt;summary storeno="S102" category="Appliances" revenue="22650"/&gt;
&lt;summary storeno="S102" category="Jewelry" revenue="30750"/&gt;</eg>
               </item>



               <item>
                  <p>The result of the previous example was a “flat” list of elements. A user might prefer the query result to be presented in the form of a  hierarchical report, grouped primarily by store (in order by store number) and secondarily by product category. Within each store, the user might want to see only those product categories whose total revenue exceeds $10,000, presented in descending order by their total revenue. This report is generated by the following query:</p>
                  <eg role="parse-test">for $s1 in $sales
let $storeno := $s1/storeno
group by $storeno
order by $storeno
return &lt;store storeno="{ $storeno }"&gt;{
  for $s2 in $s1
  for $p in $products[itemno = $s2/itemno]
  let $category := $p/category
  let $revenue := $s2/qty * $p/price
  group by $category
  let $group-revenue := sum($revenue)
  where $group-revenue &gt; 10000
  order by $group-revenue descending
  return &lt;category name="{ $category }" revenue="{ $group-revenue }"/&gt;
}&lt;/store&gt;
</eg>
                  <p>The result of this example query has the following structure:</p>
                  <eg>&lt;store storeno="S101"&gt;
  &lt;category name="Men's Wear" revenue="10185"/&gt;
&lt;/store&gt;
&lt;store storeno="S102"&gt;
  &lt;category name="Jewelry" revenue="30750"/&gt;
  &lt;category name="Appliances" revenue="22650"/&gt;
&lt;/store&gt;</eg>
               </item>



               <item>
                  <p>The following example illustrates how to avoid a possible pitfall in writing grouping queries.</p>

                  <p>In each post-grouping tuple, all variables except for the grouping
variable are bound to sequences of items derived from all the
pre-grouping tuples from which the group was formed. For instance, in
the following query, <code>$high-price</code> is bound to a sequence
of items in the post-grouping tuple.</p>

                  <eg role="parse-test">let $high-price := 1000
for $p in $products[price &gt; $high-price]
let $category := $p/category
group by $category
return &lt;category name="{ $category }"&gt;{
  count($p) || ' products have price greater than ' || $high-price || '.'
}&lt;/category&gt;</eg>
                  <p>If three products in the “Men’s Wear” category have prices greater than 1000, the result of this query might look (in part) like this:</p>
                  <eg>&lt;category name="Men’s Wear"&gt;
  3 products have price greater than 1000 1000 1000.
&lt;/category&gt;</eg>
                  <p>The repetition of "1000" in this query result is due to the fact that <code>$high-price</code> is not a <termref
                        def="dt-grouping-variable"
                        >grouping variable</termref>. One way to avoid this repetition is to move the binding of <code>$high-price</code> to an outer-level FLWOR expression, as follows:</p>
                  <eg role="parse-test">let $high-price := 1000
return (
  for $p in $products[price &gt; $high-price]
  let $category := $p/category
  group by $category
  return &lt;category name="{ $category }"&gt;{
    count($p) || ' products have price greater than ' || $high-price || '.'
  }&lt;/category&gt;  
)</eg>
                  <p>The result of the revised query might contain the following element:</p>
                  <eg>&lt;category name="Men's Wear"&gt;
  3 products have price greater than 1000.
&lt;/category&gt;</eg>
               </item>
            </ulist>
            <note>
               <p>If a collation name is specified, it must be supplied as a literal string; it cannot
                  be computed dynamically. A workaround in such cases is to use
                   the <function>fn:collation-key</function> function. For example:</p>
               
               <eg role="parse-test">for $p in $products
group by collation-key($p/description, $collation)
return $product/@code</eg>
               
               <p>Note however that the <function>fn:collation-key</function> function might not work
                  for all collations.</p>
            </note>
            
            <note>
            <p>Grouping can also be achieved by constructing a map. For example, 
            the function call <code>map:build(//employee, fn{department})</code> constructs a map
            in which employees are grouped by department.</p>
         </note>
         </div3>
         <div3 id="id-order-by-clause" role="xquery">
            <head>Order By Clause</head>
            <scrap>
               <prodrecap ref="OrderByClause"/>
            </scrap>
            
            <p>The purpose of an <code>order by</code> clause is to impose a value-based ordering on the tuples in the tuple stream. The output tuple stream of the <code>order by</code> clause contains the same tuples as its input tuple stream, but the tuples may be in a different order.</p>
            <p>An <code>order by</code> clause contains one or more ordering specifications, called <nt
                  def="OrderSpec"
                  >orderspecs</nt>, as shown in the grammar. For each tuple in the input tuple stream, the orderspecs are evaluated, using the variable bindings in that tuple. The relative order of two tuples is determined by comparing the values of their orderspecs, working from left to right until a pair of unequal values is encountered. If an orderspec specifies a <termref
                  def="dt-collation"
                  >collation</termref>, that collation is used in comparing values of type <code>xs:string</code>, <code>xs:anyURI</code>, or types derived from them (otherwise, the <termref
                  def="dt-def-collation"
                  >default collation</termref> is used in comparing values of these types). If an orderspec specifies a collation by a relative URI, that relative URI is  <termref
                  def="dt-resolve-relative-uri"
                  >resolved to an absolute URI</termref> using the <termref def="dt-static-base-uri"
                  >Static Base URI</termref>. 
If an orderspec specifies a collation that is not found in <termref
                  def="dt-static-collations"
                  >statically known collations</termref>, an error is raised <errorref class="ST"
                  code="0076"/>.</p>
            <p>The process of evaluating and comparing the orderspecs is based on
the following rules:</p>

            <ulist>

               <item>
                  <p>
                     <termref def="dt-atomization"
                        >Atomization</termref> is applied to the result of the expression
    in each orderspec.  If the result of atomization is neither a single atomic item nor an empty sequence, a <termref
                        def="dt-type-error">type error</termref> is raised <errorref class="TY"
                        code="0004"/>.</p>
               </item>


 <!--              <item>
                  <p>If the value of an orderspec has the <termref def="dt-dynamic-type"
                        >dynamic type</termref>
                     <code>xs:untypedAtomic</code> (such as character
    data in a schemaless document), it is cast to the type <code>xs:string</code>.</p>
                  <note>
                     <p>Consistently treating untyped values as strings enables the sorting process to begin without complete knowledge of the types of all the values to be sorted.</p>
                  </note>
               </item>




               <item>
                  <p>If the resulting sequence contains values that are instances of more than one primitive type (meaning the 19 primitive types defined in <xspecref
                        spec="XS2" ref="built-in-primitive-datatypes"/>, then:</p>
                  <olist>
                     <item>
                        <p>If each value is an instance of one of the types <code>xs:string</code> or <code>xs:anyURI</code>, then all values are cast to type <code>xs:string</code>.</p>
                     </item>
                     <item>
                        <p>If each value is an instance of one of the types <code>xs:decimal</code> or <code>xs:float</code>, then all values are cast to type <code>xs:float</code>.</p>
                     </item>
                     <item>
                        <p>If each value is an instance of one of the types <code>xs:decimal</code>, <code>xs:float</code>, or <code>xs:double</code>, then all values are cast to type <code>xs:double</code>.</p>
                     </item>
                     <item>
                        <p>Otherwise, a <termref def="dt-type-error"
                              >type error</termref> is raised <errorref class="TY" code="0004"
                           />.</p>
                        <note>
                           <p>The primitive type of an <code>xs:integer</code> value for this purpose is <code>xs:decimal</code>.</p>
                        </note>
                     </item>
                  </olist>
               </item>-->
            </ulist>


            <!-- <change diff="chg" at="XQ.E17"> -->
            <p>For the purpose of determining their relative position in the ordering sequence, the <emph>greater-than</emph>
             relationship between two orderspec values <var>W</var> and <var>V</var> is defined as follows:</p>
            <ulist>
               <item>
                  <p>When the orderspec specifies <code>empty least</code>,
                   the following rules are applied in order:
                </p>
                  <olist>
                     <item>
                        <p>If <var>V</var> is an empty sequence and <var>W</var> is not an empty sequence,
                         then <var>W</var>
                           <emph>greater-than</emph>
                           <var>V </var> is true.</p>
                     </item>
                     <item>
                        <p>If <var>V</var> is <code>NaN</code> and <var>W</var> is neither <code>NaN</code>
                         nor an empty sequence, then
                         <var>W</var>
                           <emph>greater-than</emph>
                           <var>V</var> is true.</p>
                     </item>
                     <item>
                        <p>If <var>V</var> and <var>W</var> are both instances of <code>xs:string</code>,
                        <code>xs:anyURI</code>, or <code>xs:untypedAtomic</code>, they are compared
                           using the function <code>fn:compare(V, W, C)</code> where <var>C</var> is the
                        requested collation, defaulting to the default collation from the static context.</p>
                        
                        <p>If <code>fn:compare(V, W, C)</code> is less than
                         zero, then <emph>W</emph>
                           <emph>greater-than</emph>
                           <emph>V</emph> is true; otherwise <emph>W</emph>
                           <emph>greater-than</emph>
                           <emph>V</emph> is false.</p>
                     </item>
                     <item>
                        <p>If <var>V</var> and <var>W</var> are both instances of <code>xs:numeric</code>,
                           they are compared
                           using the function <code>fn:compare(V, W)</code>.</p>
                        
                        <p>If <code>fn:compare(V, W)</code> is less than
                           zero, then <var>W</var>
                           <emph>greater-than</emph>
                           <var>V</var> is true; otherwise <var>W</var>
                           <emph>greater-than</emph>
                           <var>V</var> is false.</p>
                     </item>
                     <item>
                        <p>If none of the above rules apply, then:</p>
                        <p>If <code>W gt V</code> is true,
                         then <var>W</var>
                           <emph>greater-than</emph>
                           <var>V</var> is true; otherwise <var>W</var>
                           <emph>greater-than</emph>
                           <var>V</var> is false.</p>
                     </item>
                  </olist>
               </item>
               <item>
                  <p>When the orderspec specifies <code>empty greatest</code>,
                   the following rules are applied in order:
                </p>
                  <olist>
                     <item>
                        <p>If <var>W</var> is an empty sequence and <emph>V</emph> is not an empty sequence,
                         then <var>W</var>
                           <emph>greater-than</emph>
                           <var>V</var> is true.</p>
                     </item>
                     <item>
                        <p>If <var>W</var> is <code>NaN</code> and <var>V</var> is neither <code>NaN</code>
                         nor an empty sequence, then
                         <var>W</var>
                           <emph>greater-than</emph>
                           <var>V</var> is true.</p>
                     </item>
                     <item>
                        <p>If <var>V</var> and <var>W</var> are both instances of <code>xs:string</code>,
                           <code>xs:anyURI</code>, or <code>xs:untypedAtomic</code>, they are compared
                           using the function <code>fn:compare(V, W, C)</code> where <var>C</var> is the
                           requested collation, defaulting to the default collation from the static context.</p>
                        
                        <p>If <code>fn:compare(V, W, C)</code> is less than
                           zero, then <emph>W</emph>
                           <emph>greater-than</emph>
                           <emph>V</emph> is true; otherwise <emph>W</emph>
                           <emph>greater-than</emph>
                           <emph>V</emph> is false.</p>
                     </item>
                     <item>
                        <p>If <var>V</var> and <var>W</var> are both instances of <code>xs:numeric</code>,
                           they are compared
                           using the function <code>fn:compare(V, W)</code>.</p>
                        
                        <p>If <code>fn:compare(V, W)</code> is less than
                           zero, then <var>W</var>
                           <emph>greater-than</emph>
                           <var>V</var> is true; otherwise <var>W</var>
                           <emph>greater-than</emph>
                           <var>V</var> is false.</p>
                     </item>
                     <item>
                        <p>If none of the above rules apply, then:</p>
                        <p>If <code>W gt V</code> is true,
                           then <var>W</var>
                           <emph>greater-than</emph>
                           <var>V</var> is true; otherwise <var>W</var>
                           <emph>greater-than</emph>
                           <var>V</var> is false.</p>
                     </item>
                  </olist>
               </item>
               <item>
                  <p>When the orderspec specifies neither <code>empty least</code>
                   nor <code>empty greatest</code>, the
                   <termref
                        def="dt-default-empty-order"
                        >default order for empty
                   sequences</termref> in the
                   <termref
                        def="dt-static-context"
                        >static context</termref>
                   determines whether the rules for <code>empty least</code>
                   or <code>empty greatest</code> are used.
                </p>
               </item>
            </ulist>
            <!-- </change> -->

            <p>If <emph>T1</emph> and <emph>T2</emph> are two tuples in the input tuple stream, and <emph>V1</emph> and <emph>V2</emph> are the first pair of  values encountered when evaluating their orderspecs  from left to right for which one value is <emph>greater-than</emph> the other (as defined above), then:</p>


            <olist>




               <item>
                  <p>If <emph>V1</emph> is <emph>greater-than</emph>
                     <emph>V2:</emph> If the orderspec specifies <code>descending</code>, then <emph>T1</emph> precedes <emph>T2</emph> in the output tuple stream; otherwise, <emph>T2</emph> precedes <emph>T1</emph> in the output tuple stream.</p>
               </item>



               <item>
                  <p>If <emph>V2</emph> is <emph>greater-than</emph>
                     <emph>V1</emph>: If the orderspec specifies <code>descending</code>, then <emph>T2</emph> precedes <emph>T1</emph> in the output tuple stream; otherwise, <emph>T1</emph> precedes <emph>T2</emph> in the output tuple stream.</p>
               </item>



            </olist>
            <p>If neither <emph>V1</emph> nor <emph>V2</emph> is <emph>greater-than</emph> the other for any pair of orderspecs for tuples <emph>T1</emph> and <emph>T2</emph>, the following rules apply.</p>

            <olist>



               <item>
                  <p>If <code>stable</code> is specified, the original order of <emph>T1</emph> and <emph>T2</emph> is preserved in the output tuple stream.</p>
               </item>



               <item>
                  <p>If <code>stable</code> is not specified, the order of <emph>T1</emph> and <emph>T2</emph> in the output tuple stream is <termref
                        def="dt-implementation-dependent">implementation-dependent</termref>.</p>
               </item>
            </olist>
            <note>
               <p>If two orderspecs return the special floating-point values positive and negative zero, neither of these values is <emph>greater-than</emph> the other, since <code
                     role="parse-test">+0.0 gt -0.0</code> and <code role="parse-test"
                     >-0.0 gt +0.0</code> are both <code>false</code>.</p>
            </note>
            <p>Examples:</p>
            <ulist>



               <item>
                  <p>This example illustrates the effect of an <code>order by</code> clause on a tuple stream. The keyword <code>stable</code> indicates that, when two tuples have equal sort keys, their order in the input tuple stream is preserved.</p>
                  <p>Input tuple stream:</p>
                  <eg><![CDATA[($license = "PFQ519", $make = "Ford",  $value = 16500)
($license = "HAJ865", $make = "Honda", $value = 22750)
($license = "NKV473", $make = "Ford",  $value = 21650)
($license = "RCM922", $make = "Dodge", $value = 11400)
($license = "ZBX240", $make = "Ford",  $value = 16500)
($license = "KLM030", $make = "Dodge", $value = () )]]></eg>
                  <p>
                     <code>order by</code> clause:</p>
                  <eg><![CDATA[stable order by $make,
  $value descending empty least]]></eg>
                  <p>Output tuple stream:</p>
                  <eg><![CDATA[($license = "RCM922", $make = "Dodge", $value = 11400)
($license = "KLM030", $make = "Dodge", $value = () )
($license = "NKV473", $make = "Ford",  $value = 21650)
($license = "PFQ519", $make = "Ford",  $value = 16500)
($license = "ZBX240", $make = "Ford",  $value = 16500)
($license = "HAJ865", $make = "Honda", $value = 22750)]]></eg>
               </item>



               <item>
                  <p>The following example shows how an <code>order by</code> clause can be used to sort the result of a query, even if the sort key is not included in the query result. This query returns employee names in descending order by salary, without returning the actual salaries:</p>
                  <eg role="parse-test"><![CDATA[for $e in $employees
order by $e/salary descending
return $e/name]]></eg>

               </item>
            </ulist>
            <note>
               <p>If a collation name is specified, it must be supplied as a literal string; it cannot
                  be computed dynamically. Two possible workarounds are to use the <function>fn:sort</function> function
               or the <function>fn:collation-key</function> function.</p>
               <p>Using <function>fn:sort</function> the expression</p>
               <eg role="parse-test">for $b in $books/book[price &lt; 100]
order by $b/title
return $b</eg>

               <p>can be replaced with the following, which uses a dynamically-chosen collation:</p>

               <eg role="parse-test">
sort(
  $books/book[price &lt; 100],
  $collation,
  function($book) { $book/title }
)
</eg>
               
               <p>Alternatively, it is possible to compute collation keys using a dynamically-chosen
               collation, and sort on the values of the collation keys:</p>
               
               <eg role="parse-test">for $b in $books/book[price &lt; 100]
order by collation-key($b/title, $collation)
return $b</eg>
               
               <p>Note however that the <function>fn:collation-key</function> function might not work
               for all collations.</p>
               
            </note>


         </div3>
         <div3 id="id-return-clause" role="xquery">
            <head>Return Clause</head>
            <scrap>
               <prodrecap ref="ReturnClause"/>
            </scrap>
            
            <p>The <code>return</code> clause is the final clause of a FLWOR expression. The <code>return</code> clause is evaluated once for each tuple in its input tuple stream,  using the variable bindings in the respective tuples, in the order in which these tuples appear in the input tuple stream. The results of these evaluations are concatenated, as if by the <termref
                  def="dt-comma-operator"
               >comma operator</termref>, to form the result of the FLWOR expression.</p>
            <p>The following example illustrates a FLWOR expression containing several clauses. The <code>for</code> clause iterates over all the departments in an input document named <code>depts.xml</code>, binding the variable <code>$d</code> to each department  in turn. For each binding of <code>$d</code>, the <code>let</code> clause binds variable <code>$e</code> to all the employees in the given department, selected from another input document named <code>emps.xml</code> (the relationship between employees and departments is represented by matching their <code>deptno</code> values). Each tuple in the resulting tuple stream contains a pair of bindings for <code>$d</code> and <code>$e</code> (<code>$d</code> is bound to a department and <code>$e</code> is bound to a set of employees in that department). The <code>where</code> clause filters the tuple stream, retaining only those tuples that represent departments having at least ten employees. The <code>order by</code> clause orders the surviving tuples in descending order by the average salary of the employees in the department. The <code>return</code> clause constructs a new <code>big-dept</code> element for each surviving tuple, containing the department number, headcount, and average salary.</p>
            <eg role="parse-test"><![CDATA[for $d in doc("depts.xml")//dept
let $e := doc("emps.xml")//emp[deptno eq $d/deptno]
where count($e) >= 10
order by avg($e/salary) descending
return <big-dept>{
  $d/deptno,
  <headcount>{ count($e) }</headcount>,
  <avgsal>{ avg($e/salary) }</avgsal>
}</big-dept>]]></eg>
            <notes>
               <ulist>



                  <item>
                     <p>The order in which items appear in the result of a FLWOR expression depends
                        on the ordering of the input tuple stream to the <code>return</code> clause, 
                        which in turn is influenced by <code>order by</code> clauses. For example, 
                        consider the following query, which is based on the same two input documents as the previous example:</p>
                     <eg role="parse-test">for $d in doc("depts.xml")//dept
order by $d/deptno
for $e in doc("emps.xml")//emp[deptno eq $d/deptno]
return &lt;assignment&gt;{
  $d/deptno, $e/name
}&lt;/assignment&gt;</eg>
                     <p>The result of this query is a sequence of <code>assignment</code> elements, 
                        each containing a <code>deptno</code> element and a <code>name</code> element. 
                        The sequence will be ordered primarily by the <code>deptno</code> values because 
                        of the <code>order by</code> clause. 
                        Subsequences of <code>assignment</code> elements with equal <code>deptno</code> 
                        values will be ordered by the document order of their <code>name</code> elements 
                        within the <code>emps.xml</code> document.</p>
                  </item>

                  <item>
                     <p>Parentheses are helpful in <code>return</code> clauses that contain comma operators,
since FLWOR expressions have a higher precedence than the comma
operator. For example, the following query raises an error because
after the comma, <code>$j</code> is no longer within the FLWOR expression, and is an
undefined variable:</p>
                     <eg role="parse-test"><![CDATA[let $i := 5
let $j := 20 * $i
return $i, $j]]></eg>
                     <p>Parentheses can be used to bring <code>$j</code> into the <code>return</code> clause of the FLWOR expression, as the
programmer probably intended:</p>
                     <eg role="parse-test"><![CDATA[let $i := 5
let $j := 20 * $i
return ($i, $j)]]></eg>
                  </item>
               </ulist>
            </notes>
         </div3>
      <div3 role="xpath" id="id-for-expressions">
         <head>For Expressions</head>
         
         <changes>
            <change issue="49" PR="344" date="2023-02-10">A <code>for member</code> clause is added to FLWOR expressions to allow iteration over
               an array.</change>
            <change issue="22" PR="28" date="2020-12-18">
               Multiple <code>for</code> and <code>let</code> clauses can be combined
               in an expression without an intervening <code>return</code> keyword.
            </change>
            <change issue="31" PR="1249" date="2024-06-01">
               A <code>for key/value</code> clause is added to FLWOR expressions to allow iteration over
               maps.</change>
            <change issue="231" PR="1131" date="2024-04-01">
               A positional variable can be defined in a <code>for</code> expression.
            </change>
            <change issue="796" PR="1131" date="2024-04-01">
               The type of a variable used in a <code>for</code> expression can be declared.
               </change>
         </changes>

         <p>XPath provides an iteration facility called a <term>for expression</term>. 
         It can be used to iterate over the items of a sequence, the
            members of an array, or the entries in a map.</p>

         <scrap>
            <prodrecap ref="ForExpr"/>
         </scrap>

         <p>A <code>for</code> expression is evaluated as follows:</p>
         <olist>

            <item>
               <p>If the <nt def="ForClause">ForClause</nt> includes multiple 
                  <nt def="ForBinding">ForBinding</nt>s with a comma separator, 
                  the <code>for</code>expression is first expanded to a set of nested <code>for</code> 
                  expressions, each of which contains a single <nt def="ForBinding">ForBinding</nt>.
               More specifically, every separating comma is replaced by <code>for</code>.</p>
               <p>For example, the expression
               <code role="parse-test">for $x in X, $y in Y return $x + $y</code> is expanded to
               <code role="parse-test">for $x in X for $y in Y return $x + $y</code>.</p>
            </item>
            
            <item>
               <p>Having performed this expansion, 
                  variables bound in the <nt def="ForClause">ForClause</nt>
                  are called the <term>range variables</term>,
                  the variable named in the <nt def="PositionalVar">PositionalVar</nt> (if present)
                  is called the <term>position variable</term>,
                  the expression that follows the <code>in</code> keyword is called the <term>binding expression</term>, 
                  and the expression in the <nt def="ForLetReturn">ForLetReturn</nt> part 
                  (that is, the following <nt def="LetExpr">LetExpr</nt> or
                  <nt def="ForExpr">ForExpr</nt>, or the <nt def="ExprSingle">ExprSingle</nt> 
                  that follows the <code>return</code> keyword) is called the <term>return expression</term>. 
               </p>
               <p><termdef id="dt-binding-collection-xp" term="binding collection">The 
                  result of evaluating the <term>binding expression</term> in a 
                  <code>for</code> expression is called the 
                  <term>binding collection</term></termdef>.</p>
            </item>
            <item>
               <p>If a <term>position variable</term> is declared, its type is implicitly
                  <code>xs:integer</code>. Its name (as a QName) must be
               different from the name of a <term>range variable</term> declared in the same
                <nt def="ForBinding">ForBinding</nt>.  
                  <errorref spec="XQ" class="ST" code="0089"/>.
               </p>
            </item>
            <item>
               <p>When a <nt def="ForItemBinding">ForItemBinding</nt> is used (that is, when none
                  of the keywords <code>member</code>, <code>key</code>, or <code>value</code>
                  is used), the expression iterates over the items in a sequence:
                  <olist>
                     <item><p>If a <nt def="TypeDeclaration">TypeDeclaration</nt>
                        is present then each item in the <termref def="dt-binding-collection-xp"/>
                        is converted to the specified type by applying the <termref def="dt-coercion-rules"/>.</p></item>
                     <item><p>The <term>return expression</term> is evaluated once 
                        for each item in the <termref def="dt-binding-collection-xp"/>, with a dynamic context in which
                        the <term>range variable</term> is bound to that item, and the <term>position variable</term> 
                        (if present) is bound to the one-based position of that item in the 
                        <termref def="dt-binding-collection-xp"/>, as an instance of type 
                        <code>xs:integer</code>.</p></item>
                     <item><p>The result of the <code>for</code> expression is the <termref def="dt-sequence-concatenation"/>
                        of the results of the successive evaluations of the <term>return expression</term>.</p></item>
                  </olist>
              
               </p>
            </item>
            <item>
               <p>When the <code>member</code> keyword is present:
                  <olist>
                     <item><p>The value of the <termref def="dt-binding-collection-xp"/> must be a single array.
                        Otherwise, a <termref def="dt-type-error">type error</termref> is raised: <errorref class="TY" code="0141"/>.
                     </p></item>
                     <item><p>If a <nt def="TypeDeclaration">TypeDeclaration</nt>
                        is present then each member of the <termref def="dt-binding-collection-xp"/> array
                        is converted to the specified type by applying the <termref def="dt-coercion-rules"/>.
                        (Recall that this can be any sequence, not necessarily a single item). </p></item>
                     <item><p>The result of the single-variable <code>for member</code> expression is obtained
                        by evaluating the <term>return expression</term> once 
                        for each member of that array, with the range variable bound to that member </p></item>
                     <item><p>The <term>return expression</term> is evaluated once 
                        for each member of the <termref def="dt-binding-collection-xp"/> array, 
                        with a dynamic context in which
                        the <term>range variable</term> is bound to that member, and the <term>position variable</term> 
                        (if present) is bound to the one-based position of that member in the <termref def="dt-binding-collection-xp"/>.</p></item>
                     <item><p>The result of the <code>for</code> expression is the <termref def="dt-sequence-concatenation"/>
                        of the results of the successive evaluations of the <term>return expression</term>.</p>
                     <p>Note that the result is a sequence, not an array.</p></item>
                  </olist>   
                  
                  
      
               </p>
               
            </item>
            <item>
               <p>When the <code>key</code> and/or <code>value</code> keywords are present:
                  <olist>
                     <item><p>The value of the <termref def="dt-binding-collection-xp"/> must be a single map.
                        Otherwise, a <termref def="dt-type-error">type error</termref> is raised: 
                        <errorref class="TY" code="0141"/>. The map is treated as a sequence of key/value
                        pairs, in <termref def="dt-implementation-dependent"/> order.
                     </p></item>
                     <item><p>If the <code>key</code> keyword is present, then the corresponding
                     variable is bound to the key part of the key/value pair.</p></item>
                     <item><p>If the <code>value</code> keyword is present, then the corresponding
                     variable is bound to the value part of the key/value pair.</p></item>
                     <item><p>If both the <code>key</code> and <code>value</code> keywords are present, 
                        then the corresponding variables must have distinct names.
                        <errorref spec="XQ" class="ST" code="0089"/>.</p></item>
                     <item><p>If a <nt def="TypeDeclaration">TypeDeclaration</nt>
                        is present for the key, then each key is converted to the specified type by 
                        applying the <termref def="dt-coercion-rules"/>.</p></item>
                     <item><p>If a <nt def="TypeDeclaration">TypeDeclaration</nt>
                        is present for the value, then each value is converted to the specified type by 
                        applying the <termref def="dt-coercion-rules"/>.</p></item>
                     <item><p>The result of the single-variable <code>for key/value</code> expression is obtained
                        by evaluating the <term>return expression</term> once 
                        for each entry in the map, with the range variables bound to that entry as described.</p></item>
                     <item><p>The <term>return expression</term> is evaluated once 
                        for each entry of the <termref def="dt-binding-collection-xp"/> map, 
                        with a dynamic context in which
                        the <code>key</code> <term>range variable</term> (if present)
                        is bound to the key part of that entry, 
                        the <code>value</code> <term>range variable</term> (if present)
                        is bound to the value part of that entry, and the <term>position variable</term> 
                        (if present) is bound to the one-based position of that entry in the 
                        <termref def="dt-implementation-dependent"/> ordering of the 
                        <termref def="dt-binding-collection-xp"/>.</p></item>
                     <item><p>The result of the <code>for</code> expression is the <termref def="dt-sequence-concatenation"/>
                        of the results of the successive evaluations of the <term>return expression</term>.</p>
                     <p>Note that the result is a sequence, not a map.</p></item>
                  </olist>   
               </p>
               
            </item>
         </olist>
         <p role="xpath"
            >The following example illustrates the use of a <code>for</code> expression in restructuring an input document. The example is based on the following
input:</p>
         <eg><![CDATA[<bib>
  <book>
    <title>TCP/IP Illustrated</title>
    <author>Stevens</author>
    <publisher>Addison-Wesley</publisher>
  </book>
  <book>
    <title>Advanced Programming in the Unix Environment</title>
    <author>Stevens</author>
    <publisher>Addison-Wesley</publisher>
  </book>
  <book>
    <title>Data on the Web</title>
    <author>Abiteboul</author>
    <author>Buneman</author>
    <author>Suciu</author>
  </book>
</bib>]]></eg>



         <p>The following example transforms the input document into a list in
which each author’s name appears only once, followed by a list of
titles of books written by that author. This example assumes that the
context value is the <code>bib</code> element in the input
document.</p>


         <eg role="parse-test"><phrase role="parse-test">for $a in distinct-values(book/author)
return ((book/author[. = $a])[1], book[author = $a]/title)</phrase>
         </eg>

         <p>The result of the above expression consists of the following
sequence of elements. The titles of books written by a given author
are listed after the name of the author.

The ordering of <code>author</code> elements in the result is <termref
               def="dt-implementation-dependent"
               >implementation-dependent</termref> due to the semantics of the <function>fn:distinct-values</function> function.</p>
         <eg><![CDATA[<author>Stevens</author>
<title>TCP/IP Illustrated</title>
<title>Advanced Programming in the Unix environment</title>
<author>Abiteboul</author>
<title>Data on the Web</title>
<author>Buneman</author>
<title>Data on the Web</title>
<author>Suciu</author>
<title>Data on the Web</title>]]></eg>
         <p>The following example illustrates a <code>for</code> expression containing more than one variable:</p>
         <eg role="parse-test"><phrase role="parse-test">for $i in (10, 20),
    $j in (1, 2)
return ($i + $j)</phrase>
         </eg>
         <p>The result of the above expression, expressed as a sequence of numbers, is as follows: <code>11, 12, 21, 22</code>
         </p>
         <p>The scope of a variable bound in a <code>for</code> expression is the <term>return expression</term>. 
            The scope does not include the expression to which the variable is bound. 
            The following example illustrates how a variable binding may reference another variable 
            bound earlier in the same  <code>for</code> expression:</p>
         <eg role="parse-test"><phrase role="parse-test">for $x in $z, $y in f($x)
return g($x, $y)</phrase>
         </eg>

         <p>The following example illustrates processing of an array.</p>
         <eg>for member $map in parse-json('[{ "x": 1, "y": 2 }, { "x": 10, "y": 20 }]') 
return $map ! (?x + ?y)</eg>
         <p>The result is the sequence <code>(3, 30)</code>.</p>
         
         <p>The following example illustrates processing of a map.</p>
         <eg>for key $key value $value in { "x": 1, "y": 2, "z: 3 }
return `{$key}={$value}`</eg>
         <p>The result is the sequence <code>("x=1", "y=2", "z=3")</code> (but
         not necessarily in that order).</p>
         
         <note>
            <p>The focus for evaluation of the <code>return</code> clause of a <code>for</code> expression
is the same as the focus for evaluation of the <code>for</code> expression itself. The
following example, which attempts to find the total value of a set of
order-items, is therefore incorrect:

</p>
            <eg role="error"><![CDATA[sum(for $i in order-item return @price * @qty)]]></eg>
            <p>

Instead, the expression must be written to use the variable bound in the <code>for</code> clause:</p>
            <eg role="parse-test"
               ><![CDATA[sum(for $i in order-item return $i!(@price * @qty))]]></eg>
         </note>
         <note diff="add" at="2023-02-16">
            <p>XPath 4.0 allows the format:</p>
            <eg role="parse-test"><![CDATA[for $order in //orders
for $line in $order/order-line
return $line/value]]></eg>
            <p>primarily because it is familiar to XQuery users, some of whom may regard it as more
            readable than the XPath 3.1 alternative which uses a comma in place of the second <code>for</code>.</p>
         </note>
      </div3>

      <div3 id="id-let-expressions" role="xpath">
         <head>Let Expressions</head>
         
         <changes>
            <change issue="22" PR="28" date="2020-12-18">
               Multiple <code>for</code> and <code>let</code> clauses can be combined
               in an expression without an intervening <code>return</code> keyword.
            </change>
            <change issue="796" PR="1131" date="2024-04-01">
               The type of a variable used in a <code>let</code> expression can be declared.
            </change>
         </changes>

         <p>XPath allows a variable to be declared and bound to a value using a <term>let expression</term>.</p>

         <scrap>
            <prodrecap ref="LetExpr"/>
         </scrap>

         <p>A let expression is evaluated as follows:</p>

         <ulist>
            <item>
               <p>If the let expression uses multiple variables, it is first expanded to a
set of nested let expressions, each of which uses only one variable. 
Specifically, any separating comma is replaced by <code>let</code>.</p>
               <p>For example, the expression 
                  <code role="parse-test">let $x := 4, $y := 3 return $x + $y</code> is expanded to
                   <code role="parse-test">let $x := 4 let $y := 3 return $x + $y</code>.</p>
               
            </item>

            <item>
               <p>In a single-variable let expression, the variable is called the range
variable. The expression that follows the <code>:=</code> symbol is evaluated, and
                  if a <nt def="TypeDeclaration">TypeDeclaration</nt> is present, its value is converted
                     to the specified type by applying the <termref def="dt-coercion-rules"/>.
                     The resulting value is called
the binding sequence. The expression in the <nt def="ForLetReturn">ForLetReturn</nt> part 
                  (that is, the following <nt def="LetExpr">LetExpr</nt> or
                  <nt def="ForExpr">ForExpr</nt>, or the <nt def="ExprSingle">ExprSingle</nt> 
                  that follows the <code>return</code> keyword) is
called the <term>return expression</term>. The result of the let expression is obtained
by evaluating the <term>return expression</term> with a dynamic context in which the range variable is bound to the
binding sequence. </p>
            </item>
            
           

         </ulist>

         <p>The scope of a variable bound in a let expression is the
            <term>return expression</term>.
The scope does not include the expression to which the variable is bound.
The following example illustrates how a variable binding may reference
another variable bound earlier in the same let expression:</p>

         <eg role="parse-test"><![CDATA[
let $x := doc('a.xml')/*, $y := $x//*
return $y[@value gt $x/@min]
]]></eg>
         
         <note diff="add" at="2023-02-09">
            <p>It is not required that the variables should have distinct names. It is permitted, 
               for example, to write:</p>
            <eg role="parse-test"><![CDATA[
let $x := "[A fine romance]"
let $x := substring-after($x, "[")
let $x := substring-before($x, "]")
return upper-case($x)
]]></eg>
            <p>which returns the result <code>"A FINE ROMANCE"</code>. Note that this expression declares
            three separate variables which happen to have the same name; it should not be read as declaring
            a single variable and binding it successively to different values.</p>
         </note>
         
      </div3>

      </div2>
      

      
      

      <div2 id="id-maps-and-arrays">
         <head>Maps and Arrays</head>

         <p>Most modern programming languages have support for collections of
key/value pairs, which may be called maps, dictionaries, associative
arrays, hash tables, keyed lists, or objects (these are not the same
thing as objects in object-oriented systems). In &language;, we call
these maps. Most modern programming languages also support ordered
lists of values, which may be called arrays, vectors, or sequences.
In &language;, we have both
sequences and arrays. Unlike sequences, an array is an
item, and can appear as an item in a sequence.</p>

         <p diff="del" at="B">In previous versions of the language, element structures and
sequences were the only complex data structures.  We are adding maps
and arrays to &language; in order to provide lightweight data
structures that are easier to optimize and less complex to use for
intermediate processing and to allow programs to easily combine XML
processing with JSON processing.</p>


         <note>
            <p>The &language; specification focuses on syntax provided for maps
  and arrays, especially constructors and lookup.</p>

            <p>Some of the functionality typically needed for maps and
  arrays is provided by functions defined in <xspecref spec="FO40" ref="maps"/>
               and <xspecref spec="FO40" ref="arrays"/>, including functions used to
  read JSON to create maps and arrays, serialize maps and arrays to
  JSON, combine maps to create a new map, remove map entries to create
  a new map, iterate over the keys of a map, convert an array to
  create a sequence, combine arrays to form a new array, and iterate
  over arrays in various ways.</p>
         </note>


         <div3 id="id-maps">
            <head>Maps</head>
            
            <changes>
               <change issue="1651" PR="1703" date="2025-01-14">Ordered maps are introduced.</change>
            </changes>
            
            <p>
               <termdef term="map" id="dt-map"
                  >A <term>map</term> is a function
  that associates a set of keys with values, resulting in a collection
  of key / value pairs.</termdef>

               <termdef term="entry" id="dt-entry"
                     >Each key / value pair in a map
  is called an <term>entry</term>.</termdef>

               <termdef term="associated value" id="dt-associated-value"
                     >The value
  associated with a given key is called the <term>associated
  value</term> of the key.</termdef>
            </p>
            
            <p>Maps and their properties are defined in the data model:
               see <xspecref spec="DM40" ref="map-items"/>. For an overview
            of the functions available for processing maps,
            see <xspecref spec="FO40" ref="maps"/>.</p>
            
            <note>
               <p>Maps in &language; are ordered.
                  The effect of this property is explained 
                  in <xspecref spec="DM40" ref="map-items"/>. 
                  In an ordered map, the order of entries is predictable
                  and depends on the order in which they were added to the map.</p>
            </note>

            <div4 id="id-map-constructors">
               <head>Map Constructors</head>
               
               <changes>
                  <change issue="1070" PR="1071" date="2024-03-26">
                     In map constructors, the keyword <code>map</code> is now optional, so 
                     <code>map { 0: false(), 1: true() }</code> can now be written <code>{ 0: false(), 1: true() }</code>,
                     provided it is used in a context where this creates no ambiguity.
                  </change>
                  <change issue="1651" PR="1703" date="2025-01-14">The order of key-value
                     pairs in the map constructor is now retained in the constructed map.</change>
               </changes>

               <p>A map can be created using a <nt def="MapConstructor">MapConstructor</nt>.</p>

               <scrap>
                  <prodrecap ref="MapConstructor"/>
               </scrap>
               
               <note>
                  <p>The keyword <code>map</code> was required in earlier versions
                  of the language; in &language; it becomes optional. There may be cases
                  where using the keyword improves readability.</p>
                  
                  <p>In order to allow the <code>map</code> keyword to be omitted,
                  an incompatible change has been made to XQuery computed element
                  and attribute constructors: if the name of the constructed element
                  or attribute is a language keyword, it must now be written in quotes,
                  for example <code>element "div" {}</code>.</p>
                  
                  <p>Although the grammar allows a <nt def="MapConstructor">MapConstructor</nt>
                  to appear within an <nt def="EnclosedExpr">EnclosedExpr</nt> (that is, between
                  curly brackets), this may be confusing to readers, and using the <code>map</code>
                  keyword in such cases may improve clarity. In any event, if the <nt def="EnclosedExpr">EnclosedExpr</nt>
                  appears in a context such as a <nt def="StringTemplate">StringTemplate</nt>,
                  the two adjacent left opening braces must at least be separated by whitespace.</p>
               </note>


               <note>
                  <p>
    In some circumstances, it is necessary to include whitespace before or after the colon
    of a <nt
                        def="MapConstructorEntry"
                     >MapConstructorEntry</nt> to ensure that it is parsed as intended.
    </p>

                  <p>
    For instance, consider the expression <code>{a:b}</code>.
    Although it matches the EBNF for MapConstructor
    (with <code>a</code> matching MapKeyExpr and <code>b</code> matching MapValueExpr),
    the "longest possible match" rule requires that <code>a:b</code> be parsed as a QName,
    which results in a syntax error.
    Changing the expression to <code>{a :b}</code> or <code>{a: b}</code>
    will prevent this, resulting in the intended parse.
    </p>

                  <p>Similarly, consider these three expressions:</p>
                  <eg><![CDATA[
{a:b:c}
{a:*:c}
{*:b:c}]]></eg>
                  <p>
    In each case, the expression matches the EBNF in two different ways,
    but the “longest possible match” rule forces the parse in which
    the MapKeyExpr is <code>a:b</code>, <code>a:*</code>, or <code>*:b</code> (respectively)
    and the MapValueExpr is <code>c</code>.
    To achieve the alternative parse
    (in which the MapKeyExpr is merely <code>a</code> or <code>*</code>),
    insert whitespace before and/or after the first colon.
    </p>

                  <p>See <specref ref="lexical-structure"/>.</p>
               </note>

               <p>The value of the expression (whether or not the <code>map</code> keyword is present)
                  is a map whose entries
    correspond to the key-value pairs obtained by
    evaluating the successive <nt
                     def="MapKeyExpr">MapKeyExpr</nt> and
    <nt def="MapValueExpr"
                     >MapValueExpr</nt> expressions.</p>
               <p>Each <nt def="MapKeyExpr"
                     >MapKeyExpr</nt> expression is evaluated
    and atomized; a 

    
    <termref
                     def="dt-type-error">type error</termref>
                  <errorref class="TY" code="0004"
                     /> occurs if the result is
    not a single atomic item.

      The associated value is the
    result of evaluating the corresponding
    <nt
                     def="MapValueExpr">MapValueExpr</nt>.

    If the <nt def="MapValueExpr"
                     >MapValueExpr</nt> evaluates to a node, the
    associated value is the node itself, not a new node with the same
    values.

    
                  <termdef id="dt-same-key" term="same key"
                        >Two atomic items <code>K1</code> and
    <code>K2</code> have the <term>same key value</term> if
    
    
      <code>fn:atomic-equal(K1, K2)</code> returns <code>true</code>, as specified in <xspecref
         spec="FO40" ref="func-atomic-equal"  diff="chg" at="2023-01-25"/>
                  </termdef>

    If two or more entries have the <termref def="dt-same-key"
                     >same key value</termref> then a dynamic
    error is raised <errorref
                     class="DY" code="0137"/>.
                  
                  The error <rfc2119>may</rfc2119> be raised statically if two or more entries can be determined statically
                  to have the <termref def="dt-same-key">same key value</termref>.

    
    </p>
               
               <p>The <xtermref spec="DM40" ref="dt-entry-order"/>
                  of the entries in the constructed map retains the order of the 
                  <nt def="MapConstructorEntry">MapConstructorEntry</nt> entries
                  in the input.</p>
               
               

      <example>
         <head>Constructing a fixed map</head>

               <p>The following expression constructs a map with seven entries:</p>
               <eg id="map-weekdays"><![CDATA[
{
  "Su" : "Sunday",
  "Mo" : "Monday",
  "Tu" : "Tuesday",
  "We" : "Wednesday",
  "Th" : "Thursday",
  "Fr" : "Friday",
  "Sa" : "Saturday"
}]]></eg>

      </example>
      <example>
         <head>Constructing nested maps</head>
               

               <p>Maps can nest, and can contain any XDM value. Here is an example of a nested map with values that can be string values, numeric values, or arrays:</p>

               <eg id="map-book"><![CDATA[

{
  "book": {
    "title": "Data on the Web",
    "year": 2000,
    "author": [
      {
        "last": "Abiteboul",
        "first": "Serge"
      },
      {
        "last": "Buneman",
        "first": "Peter"
      },
      {
        "last": "Suciu",
        "first": "Dan"
      }
    ],
    "publisher": "Morgan Kaufmann Publishers",
    "price": 39.95
  }
}
    ]]></eg>
               
               <note><p>The syntax deliberately mimics JSON, but there are a few differences.
               JSON constructs that are not accepted in &language; map
               constructors include the keywords <code>true</code>, <code>false</code>,
               and <code>null</code>, and backslash-escaped characters such as <code>"\n"</code>
               in string literals. In an &language; map constructor, of course, any literal 
               value can be replaced with an expression.</p></note>
      </example>
               
               <p>Both the keys and the values in a map constructor can be supplied as expressions
               rather than as constants; the number of entries in the map, however, is fixed.
               There are several functions that can be used to construct maps with a variable
               number of entries:</p>
               
               <ulist>
                  <item><p><function>map:build</function> takes any sequence as input, and for each
                  item in the sequence, it computes a key and a value, by calling user-supplied functions.</p></item>
                  <item><p><function>map:merge</function> takes a sequence of maps (often but not necessarily
                  <xtermref spec="DM40" ref="dt-single-entry-map"/>) and merges them into a single map.</p></item>
                  <item><p><function>map:of-pairs</function> takes a sequence of 
                     <xtermref spec="FO40" ref="dt-key-value-pair-map">key-value pair maps</xtermref>
                     and merges them into a single map.</p></item>
               </ulist>
               
               <p>Any of these functions can be used to build an index of employee
                  elements using the value of the <code>@id</code> attribute as a key:</p>
               <ulist>
                  <item><p><code>map:build(//employee, fn{@id})</code></p></item>
                  <item><p><code>map:merge(//employee ! {@id, .})</code></p></item>
                  <item><p><code>map:of-pairs(//employee ! {'key':@id, 'value':.})</code></p></item>
               </ulist>
               
               <p>All three functions also provide control over:</p>
               <ulist>
                  <item><p>The way in which duplicate keys are handled, and </p></item>
                  <item><p>The ordering of entries in the resulting map.</p></item>
               </ulist>

            </div4>
            <div4 id="id-map-lookup">
               <head>Maps as Functions</head>

               <p>Maps are <termref def="dt-function-item">function items</termref>, and 
                  a <termref def="dt-dynamic-function-call"/> can be used to look up
    the value associated with a key in a map.

    
    If <code>$map</code> is a map and <code>$key</code> is a key,
    then <code>$map($key)</code> is equivalent to <code>map:get($map, $key)</code>.
    The semantics of such a function call are formally defined in
    <xspecref
                     spec="FO40" ref="func-map-get"/>.
    
    </p>

               <p>Examples:</p>

               <ulist>
                  <item>
                     <p>
                        <code>$weekdays("Su")</code> returns the <termref def="dt-associated-value"
                           >associated value</termref> of the key <code>Su</code>.</p>
                  </item>
                  <item>
                     <p>
                        <code>$books("Green Eggs and Ham")</code> returns  <termref
                           def="dt-associated-value"
                           >associated value</termref>  of the key <code>Green Eggs and Ham</code>.</p>
                  </item>
               </ulist>

               <note>
                  <p>&language; also provides an alternate syntax for map and
      array lookup that is more terse, supports wildcards, and allows lookup to
      iterate over a sequence of maps or arrays. See <specref
                        ref="id-lookup"/> for details.</p>
               </note>

               <p>Map lookups can be chained.</p>

               <p>Examples: (These examples assume that <code>$b</code> is bound to the books map from the previous section)</p>
               <ulist>
                  <item>
                     <p>The expression <code>$b("book")("title")</code> returns the string <code>Data on the Web</code>.</p>
                  </item>
                  <item>
                     <p>The expression <code>$b("book")("author")</code> returns the array of authors.</p>
                  </item>
                  <item>
                     <p>The expression <code>$b("book")("author")(1)("last")</code> returns the string <code>Abiteboul</code>.</p>
                     <p>(This example combines <specref ref="id-array-lookup"
                        /> with map lookups.)</p>
                  </item>
               </ulist>
            </div4>



         </div3>
         <div3 id="id-arrays">
            <head>Arrays</head>
            <p/>
            <div4 id="id-array-constructors">
               <head>Array Constructors</head>

               <p>
                  <termdef id="dt-array" term="array"
                     >An <term>array</term> is
      a <termref def="dt-function-item"/> that associates a set of positions, represented as
      positive integer keys, with values.</termdef> The first position
      in an array is associated with the integer 1.
      <termdef
                     id="dt-member" term="member"
                        >The values of an array are called
      its <term>members</term>.</termdef>

      In the type hierarchy, array has a distinct type, which is
      derived from function.
      Atomization converts arrays to sequences (see <termref
                     def="dt-atomization">Atomization</termref>).  
      </p>

               <p>An array is created using an <nt def="ArrayConstructor">ArrayConstructor</nt>.</p>
               <scrap>
                  <prodrecap ref="ArrayConstructor"/>
               </scrap>

               <p>
      If a member of an array is a
      node, its node identity is preserved.

      

        In both forms of an <nt
                     def="ArrayConstructor"
                  >ArrayConstructor</nt>, if a member
        expression evaluates to a node, the associated value is the
        node itself, not a new node with the same values.  If the
        member expression evaluates to a map or array, the associated
        value is a new map or array with the same values.

        </p>



               <p>A <nt def="SquareArrayConstructor"
                  >SquareArrayConstructor</nt> 
      consists of a comma-delimited set of argument expressions. It returns an array in which each member contains the value of the corresponding argument expression.</p>

               <p>Examples:</p>

               <ulist>
                  <item>
                     <p>
                        <code>[ 1, 2, 5, 7 ]</code> creates an array with four members: <code>1</code>, <code>2</code>, <code>5</code>, and <code>7</code>.</p>
                  </item>
                  <item>
                     <p>
                        <code>[ (), (27, 17, 0) ]</code> creates an array with two members: <code>()</code> and the sequence <code>(27, 17, 0)</code>.</p>
                  </item>
                  <item>
                     <p>
                        <code>[ $x, local:items(), &lt;tautology&gt;It is what it is.&lt;/tautology&gt; ]</code> creates an array with three members: the value of $x, the result of evaluating the function call, and a tautology element.</p>
                  </item>
               </ulist>

               <p>A <nt def="CurlyArrayConstructor"
                     >CurlyArrayConstructor</nt>
      can use any  expression to create its members.  It
      evaluates its operand expression to obtain a sequence of items
      and creates an array with these items as members.  Unlike a
      SquareArrayConstructor, a comma in a CurlyArrayConstructor is
      the  <termref
                     def="dt-comma-operator">comma operator</termref>, not a delimiter.
      </p>

               <p>Examples:</p>
               <ulist>
                  <item>
                     <p>
                        <code>array { $x }</code> creates an array with one member for each item in the sequence to which $x is bound.</p>
                  </item>
                  <item>
                     <p>
                        <code>array { local:items() }</code> creates an array with one member for each item  in the sequence to which <code>local:items()</code> evaluates.</p>
                  </item>
                  <item>
                     <p>
                        <code>array { 1, 2, 5, 7 }</code> creates an array with four members: <code>1</code>, <code>2</code>, <code>5</code>, and <code>7</code>.</p>
                  </item>
                  <item>
                     <p>
                        <code>array { (), (27, 17, 0) }</code> creates an array with three members: <code>27</code>, <code>17</code>, and <code>0</code>.</p>
                  </item>
                  <item>
                     <p>
                        <code>array { $x, local:items(), &lt;tautology&gt;It is what it is.&lt;/tautology&gt; }</code> creates an array with the following members: the items to which <code>$x</code> is bound, followed by the items to which <code>local:items()</code> evaluates, followed by a tautology element.</p>
                  </item>
               </ulist>

               <note>
                  <p>&language; does not provide explicit support for sparse arrays. Use integer-valued maps to represent sparse arrays, 
                     for example: <code>{ 27 : -1, 153 : 17 }</code>.</p>
               </note>

            </div4>
            <div4 id="id-array-lookup">
               <head>Arrays as Functions</head>

               <p>Arrays are <termref def="dt-function-item">function items</termref>, 
                  and a <termref def="dt-dynamic-function-call"/> can be used to look up
    the value associated with position in an array.

    

    
    If <code>$array</code> is an array and <code>$index</code> is an integer corresponding to a position in the array,
    then <code>$array($key)</code> is equivalent to <code>array:get($array, $key)</code>.
    The semantics of such a function call are formally defined in
    <xspecref
                     spec="FO40" ref="func-array-get"/>.
    
    </p>

               <p>Examples:</p>

               <ulist>
                  <item>
                     <p>
                        <code>[ 1, 2, 5, 7 ](4)</code> evaluates to <code>7</code>.</p>
                  </item>
                  <item>
                     <p>
                        <code>[ [ 1, 2, 3 ], [ 4, 5, 6 ] ](2)</code> evaluates to <code>[ 4, 5, 6 ]</code>.</p>
                  </item>
                  <item>
                     <p>
                        <code>[ [ 1, 2, 3 ], [ 4, 5, 6 ] ](2)(2)</code> evaluates to <code>5</code>.</p>
                  </item>
                  <item>
                     <p>
                        <code>[ 'a', 123, &lt;name&gt;Robert Johnson&lt;/name&gt; ](3)</code> evaluates to <code>&lt;name&gt;Robert Johnson&lt;/name&gt;</code>.</p>
                  </item>
                  <item>
                     <p>
                        <code>array { (), (27, 17, 0) }(1)</code> evaluates to  <code>27</code>.</p>
                  </item>
                  <item>
                     <p>
                        <code>array { (), (27, 17, 0) }(2)</code> evaluates to  <code>17</code>.</p>
                  </item>
                  <item>
                     <p>
                        <code>array { "licorice", "ginger" }(20)</code> raises a dynamic error <xerrorref
                           spec="FO40" class="AY" code="0001"/>.</p>
                  </item>

               </ulist>

               <note>
                  <p>&language; also provides an alternate syntax for map and
      array lookup that is more terse, supports wildcards, and allows
      lookup to iterate over a sequence of maps or arrays. See
      <specref
                        ref="id-lookup"/> for details.</p>
               </note>


            </div4>





         </div3>
         <div3 id="id-lookup">
            <head>Lookup Expressions</head>
            
            <changes>
               <change>
                  The lookup operator <code>?</code> can now be followed by a string literal, for cases where
                     map keys are strings other than NCNames. It can also be followed by a variable
                     reference.
               </change>
               <change issue="297" PR="837" date="2023-11-23">
                  A deep lookup operator <code>??</code> is provided for searching
                  trees of maps and arrays.
               </change>
               <change issue="960 1094" PR="1125" date="2024-04-23">
                  Lookup expressions can now take a modifier (such as <code>keys</code>,
                  <code>values</code>, or <code>pairs</code>) enabling them to return
                  structured results rather than a flattened sequence. <!--In addition
                  they can be qualified with a type to select only the results that
                  match that type.-->
               </change>
            </changes>

            <p>&language; provides two lookup operators <code>?</code> and <code>??</code>
               for maps and arrays. These provide a terse syntax
               for accessing the entries in a map or the members of an array.</p>
            
            <p diff="add" at="2023-11-15">The operator "?", known as the shallow lookup operator,
               returns values found immediately in the operand map or array. The operator "??",
            known as the deep lookup operator, also searches nested maps and arrays. The effect of the
            deep lookup operator "??" is explained in <specref ref="id-deep-lookup"/>.</p>
            
         

            
            <div4 id="id-postfix-lookup">
               <head>Postfix Lookup Expressions</head>

               <scrap>
                  <prodrecap ref="LookupExpr"/>
               </scrap>
               
               <p>A <code>Lookup</code> has two parts: the <code>KeySpecifier</code>
               determines which entries (in a map) or members (in an array) are
               selected, and the <code>Modifier</code> determines how they are
               delivered in the result. The default modifier is <code>items</code>,
               which delivers the result as a flattened sequence of items.</p>
               
               <p>To take a simple example, given <code>$A</code> as an array
                  <code>[ ("a", "b"), ("c", "d"), ("e", "f") ]</code>, some example Lookup expressions
                  are:</p>
               
               <table width="100%">
                  <caption>Example Lookup Expressions on an Array</caption>
                  <thead>
                     <tr>
                        <th>Expression</th>
                        <th>Result</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td><code>$A?*</code> (or <code>$A?items::*)</code></td>
                        <td><eg>("a", "b", "c", "d", "e", "f")</eg></td>
                     </tr>
                     <tr>
                        <td><code>$A?pairs::*</code></td>
                        <td><eg>({ "key": 1, "value": ("a", "b") }, 
 { "key": 2, "value": ("c", "d") }, 
 { "key": 3, "value": ("e", "f") })</eg></td>
                     </tr>
                     <tr>
                        <td><code>$A?values::*</code></td>
                        <td><eg>([ "a", "b" ], [ "c", "d" ], [ "e", "f" ])</eg></td>
                     </tr>
                     <tr>
                        <td><code>$A?keys::*</code></td>
                        <td><eg>(1, 2, 3)</eg></td>
                     </tr>
                     <tr>
                        <td><code>$A?2</code> (or <code>$A?items::2)</code></td>
                        <td><eg>("c", "d")</eg></td>
                     </tr>
                     <tr>
                        <td><code>$A?pairs::2</code></td>
                        <td><eg>({ "key": 2, "value":("c", "d") })</eg></td>
                     </tr>
                     <tr>
                        <td><code>$A?values::2</code></td>
                        <td><eg>([ "c", "d" ])</eg></td>
                     </tr>
                     <tr>
                        <td><code>$A?keys::2</code></td>
                        <td><eg>(2)</eg></td>
                     </tr>
                     <tr>
                        <td><code>$A?(3, 1)</code> (or <code>$A?items::(3, 1))</code></td>
                        <td><eg>("e", "f", "a", "b")</eg></td>
                     </tr>
                     <tr>
                        <td><code>$A?pairs::(3, 1)</code></td>
                        <td><eg>({ "key": 3, "value": ("e", "f") }, 
 { "key": 1, "value": ("a", "b") })</eg></td>
                     </tr>
                     <tr>
                        <td><code>$A?values::(3, 1)</code></td>
                        <td><eg>([ "e", "f" ][ "a", "b" ])</eg></td>
                     </tr>
                     <tr>
                        <td><code>$A?keys::(3, 1)</code></td>
                        <td><eg>(3, 1)</eg></td>
                     </tr>
                  </tbody>
               </table>
               
               <p>Similarly, given <code>$M</code> as a map
                  <code>{ "X": ("a", "b"), "Y": ("c", "d"), "Z": ("e", "f") }</code>, 
                  some example lookup expressions are as follows. Note that because maps are unordered,
                  the results are not necessarily in the order shown.</p>
               
               <table width="100%">
                  <caption>Example Lookup Expressions on a Map</caption>
                  <thead>
                     <tr>
                        <th>Expression</th>
                        <th>Result</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td><code>$M?*</code> (or <code>$M?items::*)</code></td>
                        <td><eg>("a", "b", "c", "d", "e", "f")</eg></td>
                     </tr>
                     <tr>
                        <td><code>$M?pairs::*</code></td>
                        <td><eg>({ "key": "X", "value": ("a", "b") }, 
 { "key": "Y", "value": ("c", "d") }, 
 { "key": "Z", "value": ("e", "f") })</eg></td>
                     </tr>
                     <tr>
                        <td><code>$M?values::*</code></td>
                        <td><eg>([ "a", "b" ], [ "c", "d" ], [ "e", "f" ])</eg></td>
                     </tr>
                     <tr>
                        <td><code>$M?keys::*</code></td>
                        <td><eg>("X", "Y", "Z")</eg></td>
                     </tr>
                     <tr>
                        <td><code>$M?Y</code> (or <code>$M?items::Y)</code></td>
                        <td><eg>("c", "d")</eg></td>
                     </tr>
                     <tr>
                        <td><code>$M?pairs::Y</code></td>
                        <td><eg>({ "key": "Y", "value":("c", "d") })</eg></td>
                     </tr>
                     <tr>
                        <td><code>$M?values::Y</code></td>
                        <td><eg>([ "c", "d" ])</eg></td>
                     </tr>
                     <tr>
                        <td><code>$M?keys::Y</code></td>
                        <td><eg>("Y")</eg></td>
                     </tr>
                     <tr>
                        <td><code>$M?("Z", "X")</code> (or <code>$A?items::("Z", "X"))</code></td>
                        <td><eg>("e", "f", "a", "b")</eg></td>
                     </tr>
                     <tr>
                        <td><code>$M?pairs::("Z", "X")</code></td>
                        <td><eg>({ "key": "Z", "value": ("e", "f") }, 
 { "key": "X", "value": ("a", "b") })</eg></td>
                     </tr>
                     <tr>
                        <td><code>$M?values::("Z", "X")</code></td>
                        <td><eg>([ "e", "f" ][ "a", "b" ])</eg></td>
                     </tr>
                     <tr>
                        <td><code>$M?keys::("Z", "X")</code></td>
                        <td><eg>("Z", "X")</eg></td>
                     </tr>
                  </tbody>
               </table>
 
               
               <p>The semantics of a postfix lookup expression <code>E?pairs::KS</code> are defined as follows.
               The results with other modifiers can be derived from this result, as explained below.</p>
               
               <olist>
                  <item><p><var>E</var> is evaluated to produce a value <code>$V</code>.</p></item>
                  <item><p>If <code>$V</code> is not a <termref def="dt-singleton"/> 
                     (that is if <code>count($V) ne 1</code>),
                  then the result (by recursive application of these rules) is the value of
                  <code>for $v in $V return $v?pairs::KS</code>.</p></item>
                  <item><p>If <code>$V</code> is a <termref def="dt-singleton"/> array item (that is, 
                     if <code>$V instance of array(*)</code>) then:</p>
                  <olist>
                     <item><p>If <code>KS</code> is a <code>ParenthesizedExpr</code>,
                        then it is evaluated to produce a value <code>$K</code>
                        and the result is:</p> 
                        <eg><![CDATA[data($K) ! { "key": ., "value": array:get($V, .) }]]></eg>
                        <note>
                           <p>The focus for evaluating the key specifier expression is the 
                              same as the focus for the <code>Lookup</code> expression itself.</p>
                        </note></item>
                     <item>
                        <p>If the  <nt def="KeySpecifier">KeySpecifier</nt> is an <nt
                           def="IntegerLiteral">IntegerLiteral</nt> with value <code>$i</code>, 
                        the result is the same as <code>$V?pairs::($i)</code>.</p>
                     </item>
                     
                     <item>
                        <p>If the <nt def="KeySpecifier">KeySpecifier</nt> is an <code>NCName</code>
                           <phrase diff="add" at="A">or <code>StringLiteral</code></phrase>, 
                           the expression raises a type error <errorref class="TY" code="0004"/>.</p>
                     </item>
                     <item>
                        <p diff="chg" at="2023-11-15">If <code>KS</code> is a wildcard
                           (<code>*</code>), 
                           the result is the same as <code>$V?pairs::(1 to array:size($V))</code>:</p>

                        <note>
                           <p>Note that array items are returned in order.</p>
                        </note>
                     </item>
                     <!--<item>
                        <p>If <code>KS</code> is a <nt def="TypeQualifier">TypeQualifier</nt> <code>~T</code>,
                           the result is the same as <code>$V?pairs::*[?value instance of T]</code>.</p>
                     </item>-->
                  </olist>
                  </item>
                  <item><p>If <var>$V</var> is a <termref def="dt-singleton"/> 
                     map item (that is, if <code>$V instance of map(*)</code>)
                     then:</p>
                     <olist>
                        <item><p>If <code>KS</code> is a <code>ParenthesizedExpr</code>,
                           then it is evaluated to produce a value <code>$K</code>
                           and the result is:</p>
                           <eg><![CDATA[data($K) ! { "key": ., "value": map:get($V, .) }]]></eg>
                           <note>
                              <p>The focus for evaluating the key specifier expression is the 
                                 same as the focus for the <code>Lookup</code> expression itself.</p>
                           </note>
                        </item>
                        <item>
                           <p>If <code>KS</code> is an <code>NCName</code>
                              or a <code>StringLiteral</code>, with value <code>$S</code>, 
                              the result is the same as <code>$V?pairs::($S)</code></p>
                        </item>
                        <item>
                           <p>If <code>KS</code> is an <code>IntegerLiteral</code>
                              with value <code>$N</code>, 
                              the result is the same as <code>$V?pairs::($N)</code>.</p>
                        </item>
                        <item>
                           <p>If <code>KS</code> is a wildcard (<code>*</code>), 
                              the result is the same as <code>$V?pairs::(map:keys($V))</code>.</p>
                          <note>
                              <p>The order of entries in the result sequence 
                                 reflects the <xtermref spec="DM40" ref="dt-entry-order">entry order</xtermref>
                                 of the map.</p>
                           </note>
                        </item>
                        <!--<item>
                           <p>If <code>KS</code> is a <nt def="TypeQualifier">TypeQualifier</nt> <code>~T</code>,
                              the result is the same as <code>$V?pairs::*[?value instance of T]</code>.</p>
                        </item>-->
                     </olist>
                  </item>
                  <item><p>Otherwise (that is, if <code>$V</code> is neither a map nor an array)
                     a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY"
                           code="0004"/>.</p></item>
               </olist>

               <p>If the modifier is <code>items</code> (explicitly or by default), the result of
                  <code>$V?items::KS</code> is the same as the result of 
                  <code>$V?pairs::KS ! map:get(., "value")</code>; that is,
               it is the <termref def="dt-sequence-concatenation"/> of the value parts.</p>
               
               <p>If the modifier is <code>values</code>, the result of
                  <code>$V?values::KS</code> is the same as the result of 
                  <code>$V?pairs::KS ! array { map:get(., "value") }</code>.</p>
               
               <p>If the modifier is <code>keys</code>, the result of
                  <code>$V?keys::KS</code> is the same as the result of 
                  <code>$V?pairs::KS ! map:get(., "key")</code>.</p>


               <p>Examples:</p>


               <ulist>
                  <item>
                     <p>
                        <code>{ "first" : "Jenna", "last" : "Scott" }?first</code> evaluates to <code>"Jenna"</code>
                     </p>
                  </item>
                  <item diff="add" at="A">
                     <p>
                        <code>{ "first name" : "Jenna", "last name" : "Scott" }?"first name"</code> evaluates to <code>"Jenna"</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>[ 4, 5, 6 ]?2</code> evaluates to <code>5</code>.</p>
                  </item>
                  <item>
                     <p>
                        <code>({ "first": "Tom" }, { "first": "Dick" }, { "first": "Harry" })?first</code> evaluates to the sequence <code>("Tom", "Dick", "Harry")</code>.</p>
                  </item>
                  <item>
                     <p>
                        <code>([ 1, 2, 3 ], [ 4, 5, 6 ])?2</code> evaluates to the sequence <code>(2, 5)</code>.</p>
                  </item>
                  <item>
                     <p>
                        <code>([ 1, [ "a", "b" ], [ 4, 5, [ "c", "d"] ])?value::*[. instance of array(xs:string)]</code> evaluates to 
                        the sequence <code>([ "a", "b" ], [ "c", "d" ])</code>.</p>
                  </item>
                  <item>
                     <p>
                        <code>[ "a", "b" ]?3</code> raises a dynamic error <xerrorref spec="FO40"
                           class="AY" code="0001"/>
                     </p>
                  </item>
               </ulist>
            </div4>
            
            <div4 id="id-unary-lookup">
               <head>Unary Lookup</head>
               
               <scrap>
                  <prodrecap ref="UnaryLookup"/>
               </scrap>
               
               
               
               <p>Unary lookup is most commonly used in predicates (for example, <code>$map[?name = 'Mike']</code>)
                  or with the simple map operator (for example, <code>avg($maps ! (?price - ?discount))</code>).</p>
               
               <p>The unary lookup expression <code>?modifier::KS</code> is defined to be equivalent to the postfix lookup
                  expression <code>.?modifier::KS</code> which has the context value (<code>.</code>) as the implicit first operand.
                  See <specref ref="id-postfix-lookup"/> for the postfix lookup operator.</p>
               
               
               <p>Examples:</p>
               
               <ulist>
                  <item>
                     <p>
                        <code>?name</code> is equivalent to <code>.("name")</code>, an appropriate lookup for a map.</p>
                  </item>
                  <item>
                     <p>
                        <code>?2</code> is equivalent to <code>.(2)</code>, an appropriate lookup for an array or an integer-valued map.</p>
                  </item>
                  <item>
                     <p>If the context item is the result of parsing the JSON input:</p>
                     <eg>{
  "name": "John Smith",
  "address": { "street": "18 Acacia Avenue", "postcode": "MK12 2EX" },
  "previous-address": { "street": "12 Seaview Road", "postcode": "EX8 9AA" }
}</eg>

                     <p>then <code>?*[. instance of record(street, postcode)]?postcode</code>
                        returns <code>("MK12 2EX", "EX8 9AA")</code> (reflecting the 
                        <xtermref spec="DM40" ref="dt-entry-order"/> of the map).</p>
                     <note><p>Writing <code>?*?postcode</code> would raise a type error, because the result of the initial
                        step <code>?*</code> includes an item (the string <code>"John Smith"</code>) that is neither
                        a map nor an array.</p></note>
                  </item>
                  <item diff="add" at="A">
                     <p><code>?"first name"</code> is equivalent to <code>.("first name")</code></p>
                  </item>
                  
                  <item role="xquery">
                     <p>
                        <code>?("$funky / &lt;looking @string")</code> is equivalent to
                        <code>.("$funky / &lt;looking @string")</code>, an appropriate lookup for a map with rather odd conventions for keys.</p>
                  </item>
                  <item>
                     <p>
                        <code>?($a)</code> <phrase diff="add" at="A">and <code>?$a</code> are</phrase> 
                        equivalent to <code>for $k in $a return .($k)</code>, allowing keys for an array or map to be passed using a variable.</p>
                  </item>
                  <item>
                     <p>
                        <code>?(2 to 4)</code> is equivalent to <code>for $k in (2, 3, 4) return .($k)</code>, a convenient way to return a range of values from an array.</p>
                  </item>
                  <item>
                     <p>
                        <code>?(3.5)</code> raises a type error if the context value is an array because the parameter must be an integer.</p>
                  </item>
                  
                  <item role="xquery">
                     <p>If the context value is an array, <code>let $x:= &lt;node i="3"/&gt; return ?($x/@i)</code> does not raise a type error because the attribute is untyped.</p>
                     <p>But <code>let $x:= &lt;node i="3"/&gt; return ?($x/@i+1)</code> does raise a type error
                        because the <code>+</code> operator with an untyped operand returns a double.</p>
                  </item>
                  <item>
                     <p>
                        <code>([ 1, 2, 3 ], [ 1, 2, 5 ], [ 1, 2 ])[?3 = 5]</code> raises an error because <code>?3</code> on one of the
                        items in the sequence fails.</p>
                  </item>
                  <item>
                     <p>If <code>$m</code> is bound to the weekdays map described in <specref
                        ref="id-maps"
                     />, then <code>$m?*</code> returns the values <code>("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday")</code>, in <termref
                        def="dt-implementation-dependent"
                        >implementation-dependent</termref> order.</p>
                  </item>
                  <item>
                     <p>
                        <code>[ 1, 2, 5, 7 ]?*</code> evaluates to <code>(1, 2, 5, 7)</code>.</p>
                  </item>
                  <item>
                     <p>
                        <code>[ [ 1, 2, 3 ], [ 4, 5, 6 ] ]?*</code> evaluates to <code>([ 1, 2, 3 ], [ 4, 5, 6 ])</code>
                     </p>
                  </item>
                  <item>
                     <p>

                        <code>[ [1, 2, 3], 4, 5 ]?*[. instance of array(xs:integer)]</code> evaluates to <code>([1, 2, 3])</code>
                        </p>
                  </item>
                  <item>
                     <p>
                        <code>[ [ 1, 2, 3 ], [ 4, 5, 6 ], 7 ]?*[. instance of array(*)]?2</code> evaluates to <code>(2, 5)</code>
                     </p>
                  </item>
                  <item>
                     <p>
                        <code>[ [ 1, 2, 3 ], 4, 5 ]?*[. instance of xs:integer]</code> 
                        evaluates to <code>(4, 5)</code>.
                     </p>
                  </item>
               </ulist>
               
            </div4>
            
            <div4 id="id-deep-lookup" diff="add" at="2023-11-15">
               <head>Deep Lookup</head>
               
               <p>The deep lookup operator <code>??</code> has both unary and postfix forms. The unary form <code>??modifier::KS</code>
               (where <var>KS</var> is any <code>KeySpecifier</code>) has the same effect as the binary form <code>.??modifier::KS</code>.
               </p>
               
               <p>The semantics are defined as follows.</p>
               
               <p>First we define the <term>recursive content</term> of an item as follows:</p>
               
               <eg><![CDATA[declare function immediate-content($item as item()) as record(key, value)* {
  if ($item instance of map(*)) {
    map:pairs($item)
  } else if ($item instance of array(*)) {
    for member $m at $p in $item
    return { "key": $p, "value": $m }
  }
};    

declare function recursive-content($item as item()) as record(key, value)* {
  immediate-content($item) ! (., ?items::value =!> recursive-content())
};]]>
               </eg>
               
               <note><p>Explanation: the immediate content of a map is obtained by splitting it
               into a sequence of key-value pairs, each representing one entry. The immediate
               content of an array is obtained by constructing a sequence of key-value pairs,
               one for each array member, where the key is the array index and the
               value is the corresponding member. Each key-value pair is of type
               <code>record(key as xs:anyAtomicType, value as item()*)</code>.
                  The recursive content of an item contains
               the key-value pairs in its immediate content, each followed by the recursive
               content obtained by expanding any maps or arrays in the immediate content.
               </p></note>
               

               <p>It is then useful to represent the recursive content as a sequence of
               <xtermref spec="DM40" ref="dt-single-entry-map">single-entry-maps</xtermref>: 
                  so each pair <code>{ "key": $K, "value": $V }</code>
               is converted to the form <code>{ $K: $V }</code>. This can be achieved
               using the expression <code>recursive-content($V) ! { ?key: ?value }</code>.</p>
               
               <p>In addition we define the function <code>array-or-map</code> as follows:</p>
               
               <eg><![CDATA[declare function array-or-map($item as item()) {
  typeswitch ($item) {
    case array(*) | map(*) return $item
    default return error(xs:QName("err:XPTY0004"))
  }
}]]></eg>

               
               <p>The result of the expression <code>E??pairs::KS</code>, where <code>E</code> is any expression
               and <code>KS</code> is any <code>KeySpecifier</code>, is then:</p>

               <eg>(
  (<var>E</var> =!> array-or-map() => recursive-content()) 
  ! { ?key: ?value }
) ? pairs::<var>KS</var>.</eg>

               
               <note>
                  <p>This is best explained by considering examples.</p>

                  <p>Consider the expression <code>let $V := [ { "first": "John", "last": "Smith" }, { "first": "Mary", "last": "Evans" } ]</code>.</p>
                  <p>The recursive content of this array is the sequence of six maps:</p>
                  <olist>
                     <item><p><code>{ "key": 1, "value": { "first": "John", "last": "Smith" } }</code></p></item>
                     <item><p><code>{ "key": 2, "value": { "first": "Mary", "last": "Evans" } }</code></p></item>
                     <item><p><code>{ "key": "first", "value": "John" }</code></p></item>
                     <item><p><code>{ "key": "last", "value": "Smith" }</code></p></item>
                     <item><p><code>{ "key": "first", "value": "Mary" }</code></p></item>
                     <item><p><code>{ "key": "last", "value": "Evans" }</code></p></item>
                  </olist>
                  <p>The expression <code>$V??pairs::*</code> returns this sequence.</p>
                  <p>With some other <code>KeySpecifier</code> <code>KS</code>, <code>$V??pairs::KS</code> returns
                     selected items from this sequence that match <code>KS</code>.
                     Formally this is achieved by converting the key-value pairs to 
                     <xtermref spec="DM40" ref="dt-single-entry-map">single-entry maps</xtermref>,
                     applying the <code>KeySpecifier</code> to the sequence of single-entry maps,
                     and then converting the result back into a sequence of key-value pairs.</p>
                  <p>For example, given the expression <code>$V??pairs::first</code>, the selection from
                     the converted sequence will include the two <xtermref spec="DM40" ref="dt-single-entry-map">single
                     entry maps</xtermref>
                     <code>{ "first" : "John" }</code> and <code>{ "first" : "Mary" }</code>,
                  which will be delivered in key-value pair form as 
                     <code>{ "key": "first", "value": "John" }, { "key": "first", "value": "Mary" }</code>.</p>
               </note>
               
               <p>The effect of using modifiers other than <code>pairs</code> is the same as with
                  shallow lookup expressions:</p>
               
               <ulist>
                  <item><p>If the modifier is <code>items</code> (explicitly or by default), the result of
                     <code>$V??items::KS</code> is the same as the result of 
                     <code>$V??pairs::KS ! map:get(., "value")</code>; that is,
                  it is the <termref def="dt-sequence-concatenation"/> of the value parts.</p></item>
                  
                  <item><p>If the modifier is <code>values</code>, the result of
                     <code>$V??values::KS</code> is the same as the result of 
                     <code>$V??pairs::KS ! array { map:get(., "value") }</code>.</p></item>
                  
                  <item><p>If the modifier is <code>keys</code>, the result of
                     <code>$V??keys::KS</code> is the same as the result of 
                     <code>$V??pairs::KS ! map:get(., "key")</code>.</p></item>
               </ulist>
               
               <note>
                  <p>This means that with the example given earlier:</p>
                  <ulist>
                     <item><p>The expression <code>$V ?? first</code> 
                        returns the sequence <code>"John", "Mary"</code>.</p></item>
                     <item><p>The expression <code>$V ?? last</code> 
                        returns the sequence <code>"Smith", "Evans"</code>.</p></item>
                     <item><p>The expression <code>$V ?? 1</code> 
                        returns the sequence <code>{ "first": "John", "last": "Smith" }</code>.</p></item>
                     <item><p>The expression <code>$V ?? *[. instance of record(first, last)] ! `{ ?first } { ?last }`</code> 
                        returns the sequence <code>"John Smith", "Mary Evans"</code>.</p></item>
                 </ulist>
               </note>
               <note>
                  <p>The effect of evaluating all shallow lookups on maps rather than arrays is that no error arises
                  if an array subscript is out of bounds. In the above example, <code>$value??3</code> would
                  return an empty sequence, it would not raise an error.</p>
                  <p>This also affects the way an <code>xs:untypedAtomic</code> key value is handled. 
                     Given the shallow lookup
                     expression <code>$A?$x</code>, if <code>$A</code> is an array and <code>$x</code>
                     (after atomization) is <code>xs:untypedAtomic</code> then the value of <code>$x</code>
                     is converted to an integer (by virtue of the coercion rules applying to a call
                     on <function>array:get</function>). With a deep lookup expression <code>$A??$x</code>, by
                     contrast, the semantics are defined in terms of a map lookup, in which 
                     <code>xs:untypedAtomic</code> items are always treated as strings.
                  </p>
               </note>
               <note>
                  <p>The definition of the <code>recursive-content</code> function is such that items
                  in the top-level value that are not maps or arrays are ignored, whereas items that
                  are not themselves maps or arrays, but which appear in the content of a map or array
                  at the top level, are included. This means that <code>E??X</code> mirrors the
                  behavior of <code>E//X</code>, in that it includes all items that are one-or-more levels
                  deep in the tree.</p>
               </note>
               <note>
                  <p>The result of the deep lookup operator retains order when processing sequences and
                  arrays, but not when processing maps.</p>
               </note>
               <note>
                  <p>An expression involving multiple deep lookup operators may return duplicates.
                     For example, the result of the expression 
                     <code>[ [ [ "a" ], [ "b" ] ], [ [ "c" ], [ "d" ] ] ] ?? 1 ?? 1</code>
                     is <code>([ "a" ], "a", "b", "a", "c")</code>. This is because the first <code>??</code> operator
                     selects members in position 1 at all three levels, that is it selects the arrays
                     <code>[ [ "a" ], [ "b" ] ]</code>, <code>[ "a" ]</code>, and <code>[ "c" ]</code> as well
                     as each of the four string values. The second <code>??</code> operator 
                  selects members in position 1 within each of these values, which results in the string
                  <code>"a"</code> being selected twice.</p>
               </note>
               <note>
                  <p>A type error is raised if the value of the left-hand expression includes an item
                  that is neither a map nor an array.</p>
               </note>
               
 
               
               <example id="ex-deep-lookup">
                  <head>Examples of Deep Lookup Expressions</head>
                  <p>Consider the tree <code>$tree</code> of maps and arrays that results from applying the <function>fn:parse-json</function>
                  function to the following input:</p>
                  <eg><![CDATA[
{
  "desc"    : "Distances between several cities, in kilometers.",
  "updated" : "2014-02-04T18:50:45",
  "uptodate": true,
  "author"  : null,
  "cities"  : {
    "Brussels": [
      { "to": "London",    "distance": 322 },
      { "to": "Paris",     "distance": 265 },
      { "to": "Amsterdam", "distance": 173 }
    ],
    "London": [
      { "to": "Brussels",  "distance": 322 },
      { "to": "Paris",     "distance": 344 },
      { "to": "Amsterdam", "distance": 358 }
    ],
    "Paris": [
      { "to": "Brussels",  "distance": 265 },
      { "to": "London",    "distance": 344 },
      { "to": "Amsterdam", "distance": 431 }
     ],
    "Amsterdam": [
      { "to": "Brussels",  "distance": 173 },
      { "to": "London",    "distance": 358 },
      { "to": "Paris",     "distance": 431 }
    ]
  }
}]]></eg>
                  
                  <p>Given two variables <code>$from</code> and <code>$to</code> containing the
                  names of two cities that are present in this table, the distance between the
                  two cities can be obtained with the expression:</p> 
                     

                     <eg>$tree ?? $from ?? *[. instance of record(to, distance)][?to = $to] ? distance</eg>
                 
                  <p>The names of all pairs of cities whose distance is represented in the data
                  can be obtained with the expression:</p>
                  
                  <eg>$tree ?? $cities
=> map:for-each(fn($key, $val) { $val ?? to ! ($key || "-" || .) })</eg>
               </example>
               <example>
                  <head>Comparison with JSONPath</head>
                  <p>This example provides XPath equivalents to some examples given in the
                  JSONPath specification. [TODO: add a reference].</p>
                  <p>The examples query the result of parsing the following JSON value, representing
                     a store whose stock consists of four books and a bicycle:</p>
                  <eg><![CDATA[{
  "store": {
    "book": [
      {
        "category": "reference",
        "author": "Nigel Rees",
        "title": "Sayings of the Century",
        "price": 8.95
      },
      {
        "category": "fiction",
        "author": "Evelyn Waugh",
        "title": "Sword of Honour",
        "price": 12.99
      },
      {
        "category": "fiction",
        "author": "Herman Melville",
        "title": "Moby Dick",
        "isbn": "0-553-21311-3",
        "price": 8.99
      },
      {
        "category": "fiction",
        "author": "J. R. R. Tolkien",
        "title": "The Lord of the Rings",
        "isbn": "0-395-19395-8",
        "price": 22.99
      }
    ],
    "bicycle": {
      "color": "red",
      "price": 399
    }
  }
}]]></eg>
                  <p>The following table illustrates some queries on this data, expressed
                  both in JSONPath and in &language;.</p>
                  <table role="small" width="100%">
                     <caption>JSONPath vs &language; Comparison</caption>
                     <thead>
                        <tr>
                           <th>Query</th>
                           <th>JSONPath</th>
                           <th>&language;</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td>The authors of all books in the store</td>
                           <td><code>$.store.book[*].author</code></td>
                           <td><code>$m?store?book??author</code></td>
                        </tr>
                        <tr>
                           <td>All authors</td>
                           <td><code>$..author</code></td>
                           <td><code>$m??author</code></td>
                        </tr>
                        <tr>
                           <td>All things in store (four books and a red bicycle)</td>
                           <td><code>$.store.*  </code></td>
                           <td><code>$m?store?*</code></td>
                        </tr>
                        <tr>
                           <td>The prices of everything in the store</td>
                           <td><code>$.store..price</code></td>
                           <td><code>$m?store??price</code></td>
                        </tr>
                        <tr>
                           <td>The third book</td>
                           <td><code>$..book[2]  </code></td>
                           <td><code>$m??book?3</code></td>
                        </tr>
                        <tr>
                           <td>The third book's author</td>
                           <td><code>$..book[2].author</code></td>
                           <td><code>$m??book?3?author</code></td>
                        </tr>
                        <tr>
                           <td>The third book's publisher (empty result)</td>
                           <td><code>$..book[2].publisher</code></td>
                           <td><code>$m??book?3?publisher</code></td>
                        </tr>
                        <tr>
                           <td>The last book (in order)</td>
                           <td><code>$..book[-1]</code></td>
                           <td><code>$m??book => array:foot()</code></td>
                        </tr>
                        <tr>
                           <td>The first two books</td>
                           <td><code>$..book[0,1]</code></td>
                           <td><code>$m??book?(1, 2)</code></td>
                        </tr>
                        <tr>
                           <td>All books with an ISBN</td>
                           <td><code>$..book[?@.isbn]</code></td>
                           <td><code>$m??book[?isbn]</code></td>
                        </tr>
                        <tr>
                           <td>All books cheaper than 10</td>
                           <td><code>$..book[?@.price&lt;10]</code></td>
                           <td><code>$m??book[?price lt 10]</code></td>
                        </tr>
                        <tr>
                           <td>All member values and array elements contained in the input value</td>
                           <td><code>$..*</code></td>
                           <td><code>$m??*</code></td>
                        </tr>
                     </tbody>
                  </table>
               </example>
            </div4>
            
            <div4 id="id-implausible-lookup-expressions" diff="add" at="Issue602">
               <head>Implausible Lookup Expressions</head>
               <p>Under certain conditions a lookup expression that will never select anything
                  is classified as <termref def="dt-implausible"/>. During the static analysis
                  phase, a processor <rfc2119>may</rfc2119> (subject to the rules in
                  <specref ref="id-implausible-expressions"/>) report a static error
                  when such lookup expressions are encountered: <errorref class="TY" code="0145"/>.</p>
               <p>More specifically, a shallow unary or postfix lookup is classified as 
                  <termref def="dt-implausible"/> if any of the following conditions applies:</p>
               <olist>
                  <item><p>The inferred type of the left-hand operand (or the context value, in the case
                  of a unary expression) is a record type (see <specref ref="id-record-test"/>),
                  and the <code>KeySpecifier</code> is an <code>IntegerLiteral</code>.
                  </p></item>
                  <item><p>The inferred type of the left-hand operand (or the context value, in the case
                     of a unary expression) is a record type (see <specref ref="id-record-test"/>),
                     and the <code>KeySpecifier</code> is an <code>NCName</code> or <code>StringLiteral</code>
                     that cannot validly appear as a field name in the record.
                  </p></item>
                  <item><p>The inferred type of the left-hand operand (or the context value, in the case
                     of a unary expression) is a map type,
                     and the inferred type of the <code>KeySpecifier</code>, after coercion, is a type that
                     is disjoint with the key type of the map.
                  </p></item>
                  <item><p>The inferred type of the left-hand operand (or the context value, in the case
                     of a unary expression) is an array type,
                     and the <code>KeySpecifier</code> is the <code>IntegerLiteral</code> <code>0</code> (zero).
                  </p></item>
               </olist>
               <note><p>Other errors, such as using an <code>NCName</code> <code>KeySpecifier</code>
               for an array lookup, are handled under the general provisions for type errors.</p></note>
               
               <p>Examples of implausible lookup expressions include the following:</p>
               
               <ulist>
                  <item><p><code>parse-uri($uri)?3</code>: the declared result type of <code>parse-uri</code> is a record
                  test, so the selector <code>3</code> will never select anything.</p></item>
                  <item><p><code>in-scope-namespaces($node)(current-date())</code>: the result type of
                  <code>in-scope-namespaces</code> is a map with <code>xs:string</code> keys, so the selector
                  <code>current-date()</code> will never select anything.</p></item>
                  <item><p><code>array:subarray($a, 2, 5)?0</code>: the integer zero cannot select any member
                  of an array, because numbering starts at 1.</p></item>
               </ulist>
            </div4>
         </div3>
         
         <div3 id="id-filter-maps-and-arrays">
            <head>Filter Expressions for Maps and Arrays</head>
            
            <changes>
               <change issue="1159" PR="1163" date="2024-04-20">
                  Filter expressions for maps and arrays are introduced.
               </change>
               <change issue="1207" PR="tba" date="2024-05-15">
                  Predicates in filter expressions for maps and arrays can now be numeric.
               </change>
            </changes>

               <scrap>
                  <prodrecap ref="FilterExprAM"/>
               </scrap>
            
            <p>Maps and arrays can be filtered using the construct <code><var>INPUT</var>?[<var>FILTER</var>]</code>.
            For example, <code>$array?[count(.)=1]</code> filters an array to retain only those members that 
            are single items.</p>
            
            <note><p>The character-pair <code>?[</code> forms a single token; no intervening whitespace
            or comment is allowed.</p></note>
            
            <p>The required type of the left-hand operand <code><var>INPUT</var></code> is
               <code>(map(*)|array(*))?</code>: that is, it must be either an empty sequence, a single
            map, or a single array <errorref class="TY" code="0004"/>. If it is an empty sequence, 
               the result of the expression is an empty sequence.</p>
            
           
            <p>If the value of <code><var>INPUT</var></code> is an array, then the 
               <code><var>FILTER</var></code> expression is evaluated
            for each member of the array, with that member as the context value, with its position in the
            array as the context position, and with the size of the array as the context size. The result
            of the expression is an array containing those members of the input array for which
               the <termref def="dt-predicate-truth-value"/> of the 
               <code><var>FILTER</var></code> expression is true. The order
            of retained members is preserved.</p>
            
            <p>For example, the following expression:</p>
            
            <eg>let $array := [ (), 1, (2, 3), (4, 5, 6) ]
return $array?[count(.) ge 2]</eg>
            
            <p>returns:</p>
            
            <eg>[ (2, 3), (4, 5, 6) ]</eg>
            
            <note><p>Numeric predicates are handled in the same way as with filter expressions for 
               sequences. However, the result is always an array, even if only one member
            is selected. For example, given the <code>$array</code> shown above, the result
            of <code>$array?[3]</code> is the <xtermref spec="DM40" ref="dt-single-member-array"/> <code>[ (2, 3) ]</code>.
            Contrast this with <code>$array?3</code> which delivers the sequence <code>2, 3</code>.</p>
            
            
            </note>
            
            <p>If the value of <code><var>INPUT</var></code> is a map, then the 
               <code><var>FILTER</var></code> expression is evaluated
               for each entry in the map, with the context value set to an item of type
               <code>record(key as xs:anyAtomicType, value as item()*)</code>, in which the <code>key</code>
               and <code>value</code> fields represent the key and value of the map entry. 
               The context position is the position of the entry in the map 
               (in <xtermref spec="DM40" ref="dt-entry-order"/>),
               and the context size is the number of entries in the map. The result
               of the expression is a map containing those entries of the input map for which
               the <termref def="dt-predicate-truth-value"/> of the <code><var>FILTER</var></code> expression is true.
               The relative order of entries in the result retains the relative order of entries in the input.
            </p>
            
            <p>For example, the following expression:</p>
            
            <eg>let map := { 1: "alpha", 2: "beta", 3: "gamma" }
return $map?[?key ge 2]</eg>
            
            <p>returns:</p>
            
            <eg>{ 2: "beta", 3: "gamma" }</eg>
            
            <note>
               <p>A filter expression such as <code>$map?[last()-1, last()]</code>
                  might be used to return the last two entries of a map in
                  <xtermref spec="DM40" ref="dt-entry-order"/>.</p>
            </note>
         </div3>
         
         <div3 id="id-pinned-maps-and-arrays">
            <head>Pinned Maps and Arrays</head>
            <p>Unlike navigation within node trees derived from XML, navigation within a tree of maps and
               arrays derived from JSON is normally “downwards only”: there is no equivalent of the parent
            or ancestor axis. This means, for example, that having selected leav nodes in the tree
            with an expression such as <code>??name</code>, there is no way of navigating from 
               the items in the result to any related items. 
               Pinned maps and arrays provide a solution to this problem; if a map or array
            is pinned (by calling the <function>fn:pin</function> function), then values found by navigating
            within the map or array are <term>labeled</term>, which provides supplementary information
            about their location within the containing tree structure.</p>
            
            <p>For further information about pinned and labeled values 
               see <xspecref spec="DM40" ref="id-LabeledItems"/>. </p>
           
            
            <p>More specifically, if a map <code>$M</code> or an array <code>$A</code> is pinned,
            then any value returned by <code>map:get($M, $key)</code> or <code>array:get($A, $index)</code>
            will be a sequence of labeled items. The label can be obtained by calling the function
            <function>fn:label</function>, and the result will be a map having the following properties:</p>
            
            <ulist>
               <item><p><code>pinned</code>: set to <code>true</code>. This means that any
               further selections from this value (if it is itself a map or array) will
               also deliver labeled items.</p></item>
               <item><p><code>parent</code>: the containing map (<code>$M</code>) or array
               (<code>$A</code>).</p></item>
               <item><p><code>key</code>: the key (<code>$key</code>) or index (<code>$index</code>)
               that was used to select the item.</p></item>
               <item><p><code>position</code>: in the general case the value returned by
               <function>map:get</function> or <function>array:get</function> is a sequence, and each item in the
                  sequence is labeled with its 1-based position in that sequence.</p></item>
               <item><p><code>ancestors</code>: a zero-arity function that delivers the item's parent (its
               containing map or array), that item's parent, and so on, recursively, up to
               the map or array that was the root of the selection. The sequence is in upwards
               navigation order (the immediate parent comes first).</p></item>
               <item><p><code>path</code>: a zero-arity function that delivers the sequence of
               keys (in the case of maps) or integer indexes (in the case of arrays) by which the
               item was reached. The sequence is in downwards navigation order (the immediate
               key or index of the item comes last).</p></item>
            </ulist>
            
            <p>The formal model for the <function>fn:pin</function> is that it returns a deep copy of the 
               supplied map or array in which all items in the recursive content have been labeled.
            This is a useful model because it avoids the need to specify the effect of each individual
            function and operator on the structure. For example, the rule has the consequence that the result of
            <code>pin([ 11, 12, 13, 14 ]) => array:remove(3) => array:for-each(fn { label(.)?key })</code> is
            <code>[ 1, 2, 4 ]</code>. In a practical implementation, however, it is likely that labels
            will be attached to items lazily, at the time they are retrieved. Such an implementation will need
            to recognize pinned maps and arrays and treat them specially when operations such as
            <function>array:get</function>, <function>array:remove</function>, <function>array:for-each</function>,
            <function>array:subarray</function>, and their map counterparts, are evaluated.</p>
            
           
            <p>Because maps and arrays selected from a pinned map or array are themselves pinned,
            deep lookup operations (whether conducted using the deep lookup operator <code>??</code>,
            or the <function>map:find</function> function, or by user-written recursive code) will deliver
            a labeled value whose <code>parent</code> or <code>ancestor</code> properties can 
               be used to navigate back up through the tree.</p>
            
            <p>For example, given the example map shown in <specref ref="id-map-constructors"/>,
            the expression <code>$map??last[. = "Suciu"]</code> selects the map entry with key 
            <code>"last"</code> and value <code>"Suciu"</code>, but by itself gives no information
            about where this entry was found. By first pinning the map, this extra information
            can be made available through the label on the result. For example you can select
            all co-authors of "Suciu" by writing:</p>
            
            <eg>pin($map)??last[. = "Suciu"] => label()?ancestors()?author??last</eg>
            
            <note><p>When an entry in a map, or a member of an array, has the empty sequence
            as its value, the value contains no items and is therefore unchanged in the pinned
            version of the containing structure. In addition, the lookup operators <code>?</code>
            and <code>??</code> flatten their result to a single sequence, so any empty values
            are effectively discarded from the result. For this reason, pinned arrays and maps
            work best when all values in arrays and maps are <termref def="dt-singleton"/> 
               items. An option is therefore provided
            on the <function>fn:parse-json</function> and <function>fn:json-doc</function> functions to change
            the representation of JSON <code>null</code> values (whose default is an empty
            sequence, <code>()</code>) to a user-supplied value.</p></note>
            
            <ednote><edtext>That note is anticipating a proposal in a separate PR.</edtext></ednote>
            
         </div3>
      
         
      </div2>
      <div2 role="xquery" id="id-unordered-expressions">
         <head>Ordered and Unordered Expressions</head>
         
         <changes>
            <change issue="1339">
               The <code>ordered { E }</code> and <code>unordered { E }</code> expressions are retained for
               backwards compatibility reasons, but in XQuery 4.0 they are deprecated and have no useful effect.
            </change>
         </changes>
         <scrap>
            <prodrecap ref="OrderedExpr"/>
         </scrap>

         
         <p>This syntax is retained from earlier versions of XQuery; in XQuery 4.0 it is deprecated and has
         no effect.</p>
         
         <p>The constructs <code>ordered { E }</code> and <code>unordered { E }</code> both return the result
         of evaluating the expression <code>E</code>.</p>
         
         <note><p>In addition to <code>ordered</code> and <code>unordered</code> expressions, 
            XQuery provides a function named <function>fn:unordered</function> that operates on any sequence 
            of items and returns the same sequence in an <termref

               def="dt-implementation-defined"
               >implementation-defined</termref> order. A call to the <function>fn:unordered</function> 
            function may be thought of as giving permission for the argument expression to be 
            materialized in whatever order the system finds most efficient. The <function>fn:unordered</function> 
            function relaxes ordering only for the sequence that is its immediate operand, whereas the <code>unordered</code> 
            expression in earlier XQuery versions sets the ordering mode for its operand expression and 
            all nested expressions.</p></note>
      </div2>

      <div2 id="id-conditionals">
         <head>Conditional Expressions</head>
         
         <changes>
            <change issue="234" PR="284" date="2023-01-23">
               Alternative syntax for conditional expressions is available: <code>if (condition) { X } else { Y }</code>,
               with the <code>else</code> part being optional.
            </change>
         </changes>
         
         <p diff="chg" at="2022-12-07">&language; allows conditional expressions to be written in several different ways.</p>
         <scrap>
            <prodrecap ref="IfExpr"/>
         </scrap>
         
         <p>The braced expression <code>if (<var>C</var>) then {<var>T</var>}</code> is equivalent to the
         unbraced expression <code>if (<var>C</var>) then <var>T</var> else ()</code>.</p>
         
         <p>The value <var>V</var> of a conditional expression in the form <code>if (<var>C</var>) then <var>T</var>
         else <var>E</var></code> is obtained as follows:</p>
         

              <olist>
                 <item><p>Let <var>B</var> be the <termref
                       def="dt-ebv">effective boolean value</termref> of the test expression
                       <var>C</var>, as defined in <specref
                          ref="id-ebv"/>.</p>
                 </item>
                 <item><p>If <var>B</var> is true, <var>V</var> is the
                    result of evaluating <var>T</var>.</p>
                 </item>
                 <item><p>Otherwise, <var>V</var> is the
                    result of evaluating <var>E</var>.</p>
                 </item>
                 
             </olist>
                 
  
     
    
         
         
         <p>Conditional expressions have a special rule for propagating <termref
               def="dt-dynamic-error"
               >dynamic errors</termref>: <phrase diff="chg" at="2023-01-10">expressions whose value is not needed for
                  computing the result are
            <termref def="dt-guarded"/>, as described in <specref ref="id-guarded-expressions"/>, to prevent
                  spurious dynamic errors.</phrase></p>
         <p>Here are some examples of conditional expressions:</p>

         <ulist>




            <item>
               <p>In this example, the test expression is a comparison expression:</p>
               <eg role="parse-test">if ($widget1/unit-cost &lt; $widget2/unit-cost)
then $widget1
else $widget2</eg>
            </item>




            <item>
               <p>In this example, the test expression tests for the existence of an attribute
named <code>discounted</code>, independently of its value:</p>
               <eg role="parse-test"><![CDATA[if ($part/@discounted)
then $part/wholesale
else $part/retail]]></eg>
            </item>
            

            
            <item diff="add" at="2022-12-07">
               <p>The following example returns the attribute node <code>@discount</code> provided the value of <code>@price</code>
                  is greater than 100; otherwise it returns the empty sequence:</p>
               <eg role="parse-test">if (@price gt 100) { @discount }</eg>
               
            </item>
            <item diff="add" at="2023-01-10">
               <p>The following example tests a number of conditions:</p>
               <eg role="parse-test"><![CDATA[if (@code = 1) then
  "food"
else if (@code = 2) then
  "fashion"
else if (@code = 3) then
  "household"
else 
  "general"
]]></eg>
            </item>
         </ulist>
         <note diff="add" at="2023-01-10">
            <p>The “dangling else ambiguity” found in many other languages cannot arise:</p>
            <ulist>
               <item><p>In the unbraced format, both the <code>then</code> and <code>else</code> clauses
                  are mandatory.</p></item>
               <item><p>In the braced format, the expression terminates unambiguously with the closing
                  brace.</p></item>
            </ulist>
         </note>
      </div2>

      <div2 id="id-otherwise" diff="add" at="A">
         <head>Otherwise Expressions</head>
         
         <changes>
            <change issue="1024" PR="1031" date="2024-02-27">
               An <code>otherwise</code> operator is introduced: <code>A otherwise B</code> returns the
               value of <code>A</code>, unless it is an empty sequence, in which case it returns the value of <code>B</code>.
            </change>
         </changes>
         
         <scrap>
            <prodrecap ref="OtherwiseExpr"/>
         </scrap>

         <p>The <code>otherwise</code> expression returns the value of its first operand, unless this is an empty
         sequence, in which case it returns the value of its second operand.</p>

         <p>For example, <code>@price - (@discount otherwise 0)</code> returns the value of <code>@price - @discount</code>,
         if the attribute <code>@discount</code> exists, or the value of <code>@price</code> if the <code>@discount</code>
            attribute is absent.</p>

         <p>To prevent spurious errors, the right hand operand is <termref def="dt-guarded"/>: it cannot throw any
            dynamic error unless the left-hand operand returns an empty sequence.</p>

         <note>
            <p>The operator is associative (even under error conditions): <code>A otherwise (B otherwise C)</code> returns
         the same result as <code>(A otherwise B) otherwise C</code>.</p>
            <p>The <code>otherwise</code> operator binds more tightly than comparison operators such as
            <code>=</code>, but less tightly than string concatenation (<code>||</code>) or arithemetic
            operators. The expression <code>$a = @x otherwise @y + 1</code> parses as 
               <code>$a = (@x otherwise (@y + 1))</code>.</p>
         </note>

         
      </div2>
      <div2 id="id-switch" role="xquery">
         <head>Switch Expressions</head>
         
         <changes>
            <change issue="328" PR="364" date="2023-03-07">
               Switch expressions now allow a <code>case</code> clause to match multiple atomic items.
            </change>
            <change issue="365" PR="587" date="2023-11-07">
               Switch and typeswitch expressions can now be written with curly brackets,
                  to improve readability.
            </change>
            <change issue="671" PR="678" date="2023-09-12">
               The comparand expression in a switch expression can be omitted, allowing
               the switch cases to be provided as arbitrary boolean expressions.
            </change>
         </changes>
         <scrap>
            <prodrecap ref="SwitchExpr"/>
         </scrap>
         <p>
The <term>switch expression</term> chooses one of several expressions to evaluate based on the
input value.
</p>
         <p>
In a <code>switch</code> expression, the <code>switch</code> keyword is followed by an expression enclosed
in parentheses, called the <term>switch comparand</term>. This is the expression whose value is
being compared. <phrase diff="add" at="issue671">This expression is optional, and defaults to <code>true()</code>.</phrase>
            The remainder of the <code>switch</code> expression consists of one or more
<code>case</code> clauses, with one or more <code>case operand
expressions</code> each, and a <code>default</code> clause. </p>


         <p>The first step in evaluating a switch expression is to apply
atomization to the value of the switch comparand. <phrase diff="chg" at="2023-02-20">Call the result the <term>switch value</term>.
            If the <term>switch value</term></phrase> is a sequence of length greater than one, a type error is
raised <errorref class="TY" code="0004"/>. In the absence of a switch comparand, the switch value is the
         <code>xs:boolean</code> value <code>true</code>.</p>

         <p>The <phrase diff="chg" at="2023-02-20"><term>switch value</term> is compared to</phrase> 
            each <nt def="SwitchCaseOperand">SwitchCaseOperand</nt> in turn until a
            match is found or the list is exhausted. The matching is performed as follows:</p>

         <olist>
            <item>
               <p>The <nt def="SwitchCaseOperand">SwitchCaseOperand</nt> is evaluated.</p>
            </item>
            <item>
               <p>The resulting value is atomized: call this the <term>case value</term>.</p>
            </item>
            <item>
               <p diff="chg" at="2023-02-20">If the <term>case value</term> is an empty sequence, then a match occurs if and only if
               the <term>switch value</term> is an empty sequence.</p>
            </item>
            <item>
               <p>Otherwise, the <termref def="dt-singleton"/> <term>switch value</term> is compared individually
               with each item in the <term>case value</term> in turn, and a match
               occurs if and only if these two atomic items compare equal under the rules of
               the <function>fn:deep-equal</function> function with default options, using the default 
               collation in the static context.</p>
            </item>
         </olist>

         <p>
            <termdef id="id-effective-case-switch-expression" term="effective case"
                  > The <term>effective case</term> of a switch expression is the
first case clause that matches, using the rules given above, or the
default clause if no such case clause exists.</termdef> The value of
the switch expression is the value of the return expression in the
effective case.</p>

         <p>Switch expressions have rules regarding the propagation of dynamic
errors: <phrase diff="chg" at="B">see <specref ref="id-guarded-expressions"/>. These rules mean that</phrase>
the return clauses of a switch expression must not raise any dynamic
errors except in the effective case.  Dynamic errors raised in the
operand expressions of the switch or the case clauses are propagated;
however, an implementation must not raise dynamic errors in the
operand expressions of case clauses that occur after the effective
case. An implementation is permitted to raise dynamic errors in the
operand expressions of case clauses that occur before the effective
case, but not required to do so.</p>

         <p>The following example shows how a switch expression might be used:</p>

         <eg role="parse-test" diff="chg" at="2023-07-01"><![CDATA[
switch ($animal) {
  case "Cow" return "Moo"
  case "Cat" return "Meow"
  case "Duck", "Goose" return "Quack"
  default return "What's that odd noise?"
}]]></eg>
         
         <p diff="add" at="2023-07-01">The curly brackets in a switch expression are optional. The above example can equally
         be written:</p>
         
         <eg role="parse-test"><![CDATA[
switch ($animal) 
  case "Cow" return "Moo"
  case "Cat" return "Meow"
  case "Duck", "Goose" return "Quack"
  default return "What's that odd noise?"
]]></eg>
         
         <p diff="add" at="issue671">The following example illustrates a switch expression where the comparand is defaulted to
            <code>true</code>:</p>
         
         <eg role="parse-test" diff="add" at="issue671"><![CDATA[
switch () {
  case ($a le $b) return "lesser"
  case ($a ge $b) return "greater"
  case ($a eq $b) return "equal"
  default return "not comparable"
}]]></eg>
         
         <note diff="add" at="issue671"><p>The comparisons are performed using the <function>fn:deep-equal</function>
         function, after atomization. This means that a case expression such as <code>@married</code>
            tests <code>fn:data(@married)</code> rather than <code>fn:boolean(@married)</code>. 
         If the effective boolean value of the expression is wanted,
         this can be achieved with an explicit call of <function>fn:boolean</function>.</p></note>
      </div2>

      <div2 id="id-quantified-expressions">
         <head>Quantified Expressions</head>
         <changes>
            <change issue="1316" PR="1384" date="2024-08-13">
               If a type declaration is present, the supplied values in the input sequence are now
               coerced to the required type. Type declarations are now permitted in XPath as well as XQuery.
            </change>
         </changes>
         <p>Quantified expressions support existential and universal quantification. The
value of a quantified expression is always <code>true</code> or <code>false</code>.</p>
         
         <scrap>
            <prodrecap ref="QuantifiedExpr"/>
         </scrap>
         
         <p>A <term>quantified expression</term> begins with
a <term>quantifier</term>, which is the keyword <code>some</code> or <code>every</code>, 
followed by one or more in-clauses that are used to bind variables,
followed by the keyword <code>satisfies</code> and a test expression. Each in-clause associates a variable with an
expression that returns a sequence of items, called the binding sequence for that variable. 
The value of the quantified expression is defined by the following rules:</p>


         <olist>

            <item><p>If the <nt def="QuantifiedExpr">QuantifiedExpr</nt> contains
               more than one <nt def="QuantifierBinding">QuantifierBinding</nt>, then it is equivalent
            to the expression obtained by replacing each comma with <code>satisfies some</code> or <code>satisfies every</code>
            respectively. For example, the expression <code>some $x in X, $y in Y satisfies $x = $y</code>
               is equivalent to <code>some $x in X satisfies some $y in Y satisfies $x = $y</code>,
               while the expression <code>every $x in X, $y in Y satisfies $x lt $y</code> is equivalent to
               <code>every $x in X satisfies every $y in Y satisfies $x lt $y</code></p></item>


            <item>
               <p>If the quantifier is <code>some</code>, the <nt def="QuantifiedExpr">QuantifiedExpr</nt> returns <code>true</code> 
                  if at least one evaluation of the test expression has the <termref
                     def="dt-ebv">effective boolean value</termref>
                  <code>true</code>; otherwise it returns <code>false</code>. In consequence, if the binding sequence is empty, 
                  the result of the <nt def="QuantifiedExpr">QuantifiedExpr</nt> is <code>false</code>.</p>
            </item>

            <item>
               <p>If the quantifier is <code>every</code>, the <nt def="QuantifiedExpr">QuantifiedExpr</nt> returns <code>true</code> 
                  if every evaluation of the test expression has the <termref
                     def="dt-ebv">effective boolean value</termref>
                  <code>true</code>; otherwise it returns <code>false</code>. In consequence, if the binding sequence is empty, 
                  the result of the <nt def="QuantifiedExpr">QuantifiedExpr</nt> is <code>true</code>.</p>
            </item>
         </olist>


         <p>The scope of a variable bound in a quantified expression comprises all
subexpressions of the quantified expression that appear after the variable binding. The scope does not include the expression to which the variable is bound.
</p>
         <p>Each variable binding may be accompanied by a <term>type declaration</term>, 
            which consists of the keyword <code>as</code> followed by the static type of 
            the variable, declared using the syntax in  <specref ref="id-sequencetype-syntax"/>. 
            The type declaration defines a required type for the
            value. At run-time, the supplied value for the variable is converted to the required type
            by applying the <termref def="dt-coercion-rules"/>. If conversion is not possible,                     
            a <termref def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0004"/>.</p>
         
         
         <p diff="chg" at="issue845">The order in which test expressions are evaluated 
            for the various items in the binding sequence is <termref
               def="dt-implementation-dependent"
               >implementation-dependent</termref>. If the quantifier
               is <code>some</code>, an implementation may
               return <code>true</code> as soon as it finds one item for which the test expression has
               an <termref def="dt-ebv">effective boolean value</termref> of <code>true</code>, and it may raise a <termref
               def="dt-dynamic-error">dynamic error</termref> as soon as it finds one item for
            which the test expression raises an error. Similarly, if the quantifier is <code>every</code>, an 
            implementation may return <code>false</code> as soon as it finds one item for which the test expression has
            an <termref def="dt-ebv"
               >effective boolean value</termref> of <code>false</code>, and it may raise a <termref
               def="dt-dynamic-error">dynamic error</termref> as soon as it finds one item for
            which the test expression raises an error. As a result of these rules, the
            value of a quantified expression is not deterministic in the presence of
            errors, as illustrated in the examples below.</p>
         
         <p>Here are some examples of quantified expressions:</p>

         <ulist>




            <item>
               <p>This expression is <code>true</code> if every <code>part</code> element has a <code>discounted</code> attribute (regardless of the values of these attributes):</p>
               <eg role="parse-test"
                  ><![CDATA[every $part in /parts/part satisfies $part/@discounted]]></eg>
            </item>




            <item>
               <p>This expression is <code>true</code> if at least
one <code>employee</code> element satisfies the given comparison expression:</p>
               <eg role="parse-test">some $emp in /emps/employee satisfies
  $emp/bonus &gt; 0.25 * $emp/salary</eg>
            </item>
            
            <item>
               <p>This expression is <code>true</code> if every
                  <code>employee</code> element has at least one <code>salary</code> child with the attribute <code>current="true"</code>:</p>
               <eg role="parse-test"><![CDATA[every $emp in /emps/employee satisfies
  some $sal in $emp/salary satisfies $sal/@current = 'true']]></eg>
               <note diff="add" at="A"><p>Like many quantified expressions, this can be simplified. This example can be written
                  <code>every $emp in /emps/employee satisfies $emp/salary[@current = 'true']</code>, or even
                  more concisely as <code>empty(/emps/employee[not(salary/@current = 'true')]</code>.</p>
               <p>Another alternative in &language; is to use the higher-order functions <function>fn:some</function> and <function>fn:every</function>.
               This example can be written <code diff="chg" at="2023-04-25">fn:every(/emps/employee, fn { salary/@current = 'true' })</code></p>
               </note>
            </item>




            <item>
               <p>In the following examples, each quantified expression evaluates its test
expression over nine pairs of items, formed from the Cartesian
product of the sequences <code>(1, 2, 3)</code> and <code>(2, 3, 4)</code>. 
                  The expression beginning with <code>some</code> evaluates to <code>true</code>, 
                  and the expression beginning with <code>every</code> evaluates to <code>false</code>.</p>
               <eg role="parse-test"><![CDATA[some $x in (1, 2, 3), $y in (2, 3, 4) satisfies $x + $y = 4]]></eg>

               <eg role="parse-test"><![CDATA[every $x in (1, 2, 3), $y in (2, 3, 4) satisfies $x + $y = 4]]></eg>
            </item>

            <item>
               <p>This quantified expression may either return  <code>true</code> or raise a <termref
                     def="dt-type-error"
                     >type error</termref>, since its test expression returns <code>true</code> for one item
and raises a <termref
                     def="dt-type-error">type error</termref> for another:</p>
               <eg role="parse-test"><![CDATA[some $x in (1, 2, "cat") satisfies $x * 2 = 4]]></eg>
            </item>




            <item>
               <p>This quantified expression may either return <code>false</code> or raise a <termref
                     def="dt-type-error"
                     >type error</termref>, since its test expression returns <code>false</code> for one item and raises a <termref
                     def="dt-type-error">type error</termref> for another:</p>
               <eg role="parse-test"><![CDATA[every $x in (1, 2, "cat") satisfies $x * 2 = 4]]></eg>
            </item>
            
            <item>
               <p>This quantified expression returns <code>true</code>, because the binding sequence
                  is empty, despite the fact that the condition can never be satisfied:</p>
               <eg role="parse-test"><![CDATA[every $x in () satisfies ($x lt 0 and $x gt 0)]]></eg>
            </item>
            
            <item>
               <p>This quantified expression is <termref def="dt-implausible"/> because
                  it will always fail with a type error except in the case where <code>$input</code>
                  is an empty sequence. If <code>$input</code> contains one or more <code>xs:date</code>
                  values, a processor <rfc2119>must</rfc2119> raise a type error on the grounds that an <code>xs:date</code>
                  cannot be compared to an <code>xs:integer</code>. If <code>$input</code> is empty, the
                  processor <rfc2119>may</rfc2119> (or may not) report this error:</p>
               <eg role="parse-test"><![CDATA[every $x as xs:date in $input satisfies ($x lt 0)]]></eg>
            </item>




            <item>
               <p>This quantified expression  contains a <nt def="TypeDeclaration"
                     >type declaration</nt> that is not satisfied by every item in the  test expression. 
                  The expression may either return <code>true</code> or raise a <termref

                     def="dt-type-error">type error</termref>.</p>

               <eg role="parse-test"
                  ><![CDATA[some $x as xs:integer in (1, 2, "cat") satisfies $x * 2 = 4]]></eg>
            </item>
         </ulist>
      </div2>
      <div2 id="id-try-catch" role="xquery">
         <head>Try/Catch Expressions</head>
         
         <changes>
            <change issue="32" date="2023-05-23">
               <code>$err:map</code> contains entries for all values that are bound to the
                  single variables.
            </change>
            <change issue="32" PR="493" date="2023-05-16">
               A new variable <code>err:map</code> is available, capturing all error information in one place.
            </change>
            <change issue="689" date="2024-10-01">
               <code>$err:stack-trace</code> provides information about the current state of execution.
            </change>
         </changes>
           
         <p>The try/catch expression provides error handling for dynamic errors
and type errors raised during dynamic evaluation, including errors
raised by the XQuery implementation and errors explicitly raised in a
query using the <code>fn:error()</code> function.</p>

         <scrap>
            <prodrecap ref="TryCatchExpr"/>
         </scrap>



         <p>A try/catch expression catches <termref def="dt-dynamic-error"
               >dynamic errors</termref> and
                <termref def="dt-type-error"
               >type errors</termref>
                raised by the evaluation of the target expression of
		the <code>try</code>  clause. If the 
                the <termref
               def="dt-content-expression"
            >content expression</termref> of the try clause does not raise a
                dynamic error or a type error, the result of the
                try/catch expression is the result of the content
                expression.</p>

         <p>If the target expression raises a dynamic error or
                a type error, the result of the try/catch expression
                is obtained by evaluating the first <code>catch</code>
                clause that “matches” the error value, as described
                below.  

		If no catch clause “matches” the
		error value, then the try/catch expression raises the
		error that was raised by the target
		expression.

		A <code>catch</code> clause with one or more
                NameTests matches any error whose error code matches
                one of these NameTests. For instance, if the error
                code is <code>err:FOER0000</code>, then it matches a
                <code>catch</code> clause whose ErrorList is
                <code>err:FOER0000 | err:FOER0001</code>. Wildcards
                may be used in NameTests; thus, the error code
                <code>err:FOER0000</code> also matches a
                <code>catch</code> clause whose ErrorList is
                <code>err:*</code> or <code>*:FOER0000</code> or
                <code>*</code>.</p>


         <p>Within the scope of the <code>catch</code> clause, a
            number of variables are implicitly declared, giving
            information about the error that occurred.  These
            variables are initialized as described in the following
            table:</p>

         <table role="medium">
            <thead>
               <tr>
                  <th align="left">Variable</th>
                  <th align="left">Type</th>
                  <th align="left">Value</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <td valign="top"><code>$err:code</code></td>
                  <td valign="top"><code>xs:QName</code></td>
                  <td valign="top">The error code</td>
               </tr>
               <tr>
                  <td valign="top"><code>$err:description</code></td>
                  <td valign="top"><code>xs:string?</code></td>
                  <td valign="top"
                        >A description of the error condition; an empty sequence
                     if no description is available (for example, if the <function>error</function>
                     function was called with one argument).</td>
               </tr>
               <tr>
                  <td valign="top"><code>$err:value</code></td>
                  <td valign="top"><code>item()*</code></td>
                  <td valign="top"
                        >Value associated with the error. For an error raised by
                        calling the <function>error</function> function, this is the value of the
                        third argument (if supplied).</td>
               </tr>
               <tr>
                  <td valign="top"><code>$err:module</code></td>
                  <td valign="top"><code>xs:string?</code></td>
                  <td valign="top"
                     >The URI (or system ID) of the module containing the
                        expression where the error occurred, or an empty sequence if the information
                        is not available.</td>
               </tr>
               <tr>
                  <td valign="top"><code>$err:line-number</code></td>
                  <td valign="top"><code>xs:integer?</code></td>
                  <td valign="top"
                        >The line number within the module
                        where the error occurred, or an empty sequence if the information
                        is not available. The value <rfc2119>may</rfc2119> be approximate.</td>
               </tr>
               <tr>
                  <td valign="top"><code>$err:column-number</code></td>
                  <td valign="top"><code>xs:integer?</code></td>
                  <td valign="top"
                        >The column number within the module
                        where the error occurred, or an empty sequence if the information
                        is not available. The value <rfc2119>may</rfc2119> be approximate.</td>
               </tr>
               <tr>
                  <td valign="top"><code>$err:stack-trace</code></td>
                  <td valign="top"><code>xs:string?</code></td>
                  <td valign="top"
                     ><termref def="dt-implementation-dependent"
                     >Implementation-dependent</termref> information about the current state of
                     execution, or an empty sequence if no stack trace is available.
                     The variable must be bound so that a query can reference it without
                     raising an error.</td>
               </tr>
               <tr>
                  <td valign="top"><code>$err:additional</code></td>
                  <td valign="top"><code>item()*</code></td>
                  <td valign="top"
                     ><termref def="dt-implementation-defined">Implementation-defined</termref>.
                     Allows implementations to provide any additional information that might be useful.
                     The variable must be bound so that a query can reference it without
                     raising an error.</td>
               </tr>
               <tr>
                  <td valign="top"><code>$err:map</code></td>
                  <td valign="top"><code>map(*)</code></td>
                  <td valign="top"
                        >A map with entries for all values that are bound to the variables above.
                        The local names of the variables are assigned as keys.
                        No map entries are created for those values that are empty sequences.
                        The variable can be used to pass on all error information to another
                        function.</td>
               </tr>
            </tbody>
         </table>


         <p>Try/catch expressions have a special rule for
                propagating dynamic errors. The try/catch expression
                ignores any dynamic errors encountered in catch
                clauses other than the first catch clause that matches
                an error raised by the try clause, and these catch
                clause expressions need not be evaluated.</p>

         <p>Static errors are not caught by the try/catch
                expression.</p>


         <p>If a function call occurs within a <code>try</code> clause,
                errors raised by evaluating the corresponding function are caught by the try/catch
                expression. If a variable reference is used in a <code>try</code>
                clause, errors raised by binding a value to the variable are not
                caught unless the binding expression occurs within the <code>try</code>
                clause.</p>


         <note>
            <p>The presence of a try/catch expression does not
                  prevent an implementation from using a lazy
                  evaluation strategy, nor does it prevent an
                  optimizer performing expression rewrites. However,
                  if the evaluation of an expression inside a
                  try/catch is rewritten or deferred in this way, it
                  must take its try/catch context with it. Similarly,
                  expressions that were written outside the try/catch
                  expression may be evaluated inside the try/catch,
                  but only if they retain their original try/catch
                  behavior. The presence of a try/catch does not
                  change the rules that allow the processor to
                  evaluate expressions in such a way that may avoid
                  the detection of some errors. </p>
         </note>


         <p>Here are some examples of try/catch expressions.</p>


         <ulist>




            <item>
               <p>A try/catch expression without name tests catches any error:</p>

               <eg role="parse-test"><![CDATA[try {
  $x cast as xs:integer
} catch * {
  0
}]]></eg>
            </item>





            <item>
               <p>With the following catch clause, only <code>err:FORG0001</code> is caught:</p>

               <eg role="parse-test"><![CDATA[try {
  $x cast as xs:integer
} catch err:FORG0001 {
  0
}]]></eg>
            </item>




            <item>
               <p>This try/catch expression specifies that errors <code>err:FORG0001</code> and <code>err:XPTY0004</code> are caught:</p>


               <eg role="parse-test"><![CDATA[try {
  $x cast as xs:integer
} catch err:FORG0001 | err:XPTY0004 {
  0
}]]></eg>
               <note>
                  <p>In some implementations, <code>err:XPTY0004</code> is detected during static
	evaluation; it can only be caught if it is raised during dynamic evaluation.</p>
               </note>

            </item>



            <item>
               <p>This try/catch expression shows how to return information about the error using implicitly defined error variables:</p>

               <eg role="parse-test"><![CDATA[try {
  error(QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))
} catch * {
  $err:code, $err:value, " module: ",
  $err:module, "(", $err:line-number, ",", $err:column-number, ")"
}]]></eg>
            </item>



            <item>
               <p>Errors raised by using the result of a try/catch expression are not caught, since they are outside the scope of the <code>try</code> expression.</p>

               <eg role="parse-test"><![CDATA[
declare function local:thrice($x as xs:integer) as xs:integer {
  3 * $x
};

local:thrice(try { "oops" } catch * { 3 } )
]]></eg>
               <p>In this example, the try block succeeds, returning the string <code>"oops"</code>, which is not a valid argument to the function.</p>
            </item>

            <item>
               <p>All available information about the error is serialized:</p>

               <eg role="parse-test"><![CDATA[try {
  1 + <empty/>
} catch * {
  serialize($err:map, {'method':'adaptive'})
}]]></eg>
            </item>


         </ulist>

      </div2>
      <div2 id="id-expressions-on-datatypes">
         <head>Expressions on SequenceTypes</head>

         <p>
The <code>instance
of</code>, <code>cast</code>, <code>castable</code>,
and <code>treat</code> expressions are used to test whether a value
conforms to a given type or to convert it to an instance of a given
type.
</p>



         <div3 id="id-instance-of">
            <head>Instance Of</head>
            <scrap>
               <prodrecap ref="InstanceofExpr"/>
            </scrap>
            <p>The boolean
operator <code>instance of</code>
returns <code>true</code> if the value of its first operand matches
the <nt
                  def="SequenceType"
                  >SequenceType</nt> in its second
operand, according to the rules for <termref
                  def="dt-sequencetype-matching"
                  >SequenceType
matching</termref>; otherwise it returns <code>false</code>. For example:</p>

            <ulist>



               <item>
                  <p>
                     <code role="parse-test">5 instance of xs:integer</code>
                  </p>
                  <p>This example returns <code>true</code> because the given value is an instance of the given type.</p>
               </item>



               <item>
                  <p>
                     <code>5 instance of xs:decimal</code>
                  </p>
                  <p>This example returns <code>true</code> because the given value is an integer literal, and <code>xs:integer</code> is derived by restriction from <code>xs:decimal</code>.</p>
               </item>



               <item role="xquery">
                  <p>
                     <code role="parse-test">&lt;a&gt;{ 5 }&lt;/a&gt; instance of xs:integer</code>
                  </p>
                  <p>This example returns <code>false</code> because the given value is an element rather than an integer.</p>
               </item>



               <item>
                  <p>
                     <code role="parse-test">(5, 6) instance of xs:integer+</code>
                  </p>
                  <p>This example returns <code>true</code> because the given sequence contains two integers, and is a valid instance of the specified type.</p>
               </item>



               <item>
                  <p>
                     <code role="parse-test">. instance of element()</code>
                  </p>
                  <p>This example returns <code>true</code> if the context value is a
                     single element node or <code>false</code> if the context value is defined 
                     but is not a single element node. If the context value is <xtermref
                        spec="DM40" ref="dt-absent"/>, a <termref def="dt-type-error"/>
                        is raised <errorref class="DY" code="0002"/>.</p>
               </item>
            </ulist>
            
            <note><p>An <code>instance of</code> test does not allow any kind of casting or coercion.
            The results may therefore be counterintuitive. For example, the expression
            <code>3 instance of xs:positiveInteger</code> returns <code>false</code>, because
            the expression <code>3</code> evaluates to an instance of <code>xs:integer</code>,
            not <code>xs:positiveInteger</code>. For similar reasons, <code>"red" instance of
            enum("red", "green", "blue")</code> returns false.</p>
            
            <p>On such occasions, a <code>castable as</code> test may be more appropriate:
            see <specref ref="id-castable"/></p></note>
         </div3>

         <div3 id="id-typeswitch" role="xquery">
            <head>Typeswitch</head>
            
            <changes>
               <change issue="365" PR="587" date="2023-11-07">
                  Switch and typeswitch expressions can now be written with curly brackets,
                  to improve readability.
               </change>
            </changes>
            
            <scrap>
               <prodrecap ref="TypeswitchExpr"/>
            </scrap>
            <p role="xquery"
                  >The <term>typeswitch</term> expression chooses one of
several expressions to evaluate based on the <termref
                  def="dt-dynamic-type">dynamic type</termref> of an input value.</p>

            <p role="xquery"
                  >In a <code>typeswitch</code> expression, the
<code>typeswitch</code> keyword is followed by an expression enclosed
in parentheses, called the <term>operand expression</term>. This is
the expression whose type is being tested. The remainder of the
<code>typeswitch</code> expression consists of one or more
<code>case</code> clauses and a <code>default</code> clause.</p>

            <p role="xquery">Each <code>case</code> clause specifies one or more
<nt
                  def="SequenceType"
                  >SequenceType</nt>s followed by a
<code>return</code> expression. <termdef
                  term="effective case" id="dt-effective-case"
                     >The <term>effective case</term> in a
<code>typeswitch</code> expression is the first <code>case</code>
clause in which the value of the operand expression matches a <nt
                     def="SequenceType">SequenceType</nt> in the <nt def="SequenceType"
                     >SequenceTypeUnion</nt> of the <code>case</code>
clause, using the rules of <termref
                     def="dt-sequencetype-matching"
                  >SequenceType matching</termref>.
</termdef>

The value of the <code>typeswitch</code> expression is the value of
the <code>return</code> expression in the effective case. If the value
of the operand expression does not match any <nt
                  def="SequenceType"
                  >SequenceType</nt> named in a <code>case</code>
clause, the value of the <code>typeswitch</code> expression is the
value of the <code>return</code> expression in the
<code>default</code> clause.</p>
            <p>In a <code>case</code> or
<code>default</code> clause, if the value to be returned depends on
the value of the operand expression, the clause must specify a
variable name. Within the <code>return</code> expression of the
<code>case</code> or <code>default</code> clause, this variable name
is bound to the value of the operand expression.

Inside a <code>case</code> clause, the <termref
                  def="dt-static-type">static type</termref> of the variable is the
union of the <nt
                  def="SequenceType">SequenceType</nt>s named in the
<nt def="SequenceType"
                  >SequenceTypeUnion</nt>.  Inside a
<code>default</code> clause, the static type of the variable is the
same as the static type of the operand expression.

If the value to be returned by a <code>case</code> or
<code>default</code> clause does not depend on the value of the
operand expression, the clause need not specify a variable.</p>
            <p>The
scope of a variable binding in a <code>case</code> or
<code>default</code> clause comprises that clause. It is not an error
for more than one <code>case</code> or <code>default</code> clause in
the same <code>typeswitch</code> expression to bind variables with the
same name.
</p>

            <p>Typeswitch expressions have rules regarding the propagation of dynamic
               errors: <phrase diff="chg" at="B">see <specref ref="id-guarded-expressions"/>.
               These rules mean that</phrase> a <code>typeswitch</code> expression ignores (does not raise) any dynamic errors encountered in <code>case</code> clauses other than the <termref
                  def="dt-effective-case"
                  >effective case</termref>. Dynamic errors encountered in the <code>default</code> clause are raised only if there is no <termref
                  def="dt-effective-case"
                  >effective case</termref>.
An implementation is permitted to raise dynamic errors in the
operand expressions of case clauses that occur before the  <termref
                  def="dt-effective-case">effective
case</termref>, but not required to do so.</p>

            <p role="xquery"
                  >The following example shows how a <code>typeswitch</code> expression might
be used to process an expression in a way that depends on its <termref
                  def="dt-dynamic-type">dynamic type</termref>.</p>
            <eg role="parse-test" diff="chg" at="2023-07-01"><![CDATA[typeswitch($customer/billing-address) {
  case $a as element(*, USAddress)     return $a/state
  case $a as element(*, CanadaAddress) return $a/province
  case $a as element(*, JapanAddress)  return $a/prefecture
  default return "unknown"
}]]></eg>
            
            <p diff="add" at="2023-07-01">The curly brackets in a <code>typeswitch</code> expression are optional. The
            above example can equally be written:</p>
            
            <eg role="parse-test"><![CDATA[typeswitch($customer/billing-address)
  case $a as element(*, USAddress)     return $a/state
  case $a as element(*, CanadaAddress) return $a/province
  case $a as element(*, JapanAddress)  return $a/prefecture
  default return "unknown"
]]></eg>

            <p>The following example shows a union of sequence types in a single case:</p>

            <eg role="parse-test"><![CDATA[typeswitch($customer/billing-address) {
  case $a as element(*, USAddress) | element(*, MexicoAddress)
    return $a/state
  case $a as element(*, CanadaAddress)
    return $a/province
  case $a as element(*, JapanAddress)
    return $a/prefecture
  default
    return "unknown"
}]]></eg>

         </div3>
         <div3 id="id-cast">
            <head>Cast</head>
            <scrap>
               <prodrecap ref="CastExpr"/>
            </scrap>
            <p>Sometimes
it is necessary to convert a value to a specific datatype. For this
purpose, &language; provides a <code>cast</code> expression that
creates a new value of a specific type based on an existing value. A
<code>cast</code> expression takes two operands: an <term>input
expression</term> and a <term>target type</term>. The type of the
atomized value of the input expression is called the <term>input type</term>. 
The target type must be a <termref def="dt-generalized-atomic-type"/>. In practice
               this means it may be any of:</p>
            <ulist>
               <item diff="add" at="issue688"><p>The name of an <termref def="dt-named-item-type">named item type</termref>
               defined in the <termref def="dt-static-context"/>, which in turn must refer to an item
               type in one of the following categories.</p></item>
               <item><p>The name of a type defined in the  <termref def="dt-is-types">in-scope schema types</termref>, 
                  which must be a simple type (of variety atomic, list or union) <errorref class="ST" code="0052"/> .
                  In addition, the target type cannot be <code>xs:NOTATION</code>, <code>xs:anySimpleType</code>,
                  or <code>xs:anyAtomicType</code></p></item>
               <item diff="add" at="A"><p>A <code>ChoiceItemType</code> representing a 
                  <termref def="dt-generalized-atomic-type"/> (such as <code>(xs:date | xs:dateTime)</code>).</p></item>
               <item diff="add" at="issue688"><p>An <code>EnumerationType</code> such as <code>enum("red", "green", "blue")</code>.</p></item>
            </ulist>
               <p>Otherwise, a static error is raised <errorref class="ST" code="0080"/>.</p> 
            <p>The optional occurrence indicator <code>?</code> denotes that an empty
sequence is permitted.</p> 
            

            <p>Casting a node to <code>xs:QName</code> can cause surprises because it uses the static context of the cast expression to provide the namespace bindings for this operation. 
Instead of casting to <code>xs:QName</code>, it is generally preferable to use the <function>fn:QName</function> function, which allows the namespace context to be taken from the document containing the QName.</p>


            <p>The semantics of the <code>cast</code> expression
are as follows:</p>

            <olist>

               <item>
                  <p>The input expression is evaluated.</p>
               </item>

               <item>
                  <p>The result of the first step is <termref def="dt-atomization"
                        >atomized</termref>.</p>
               </item>


               <item>
                  <p> If the result of atomization is a
sequence of more than one atomic item, a <termref
                        def="dt-type-error">type error</termref> is raised <errorref class="TY"
                        code="0004"/>.</p>
               </item>



               <item>
                  <p>If the result
of atomization is an empty sequence:</p>

                  <olist>



                     <item>
                        <p>If
<code>?</code> is specified after the target type, the result of the
<code>cast</code> expression is an empty sequence.</p>
                     </item>



                     <item>
                        <p>
If <code>?</code> is not specified after the target type, a <termref
                              def="dt-type-error">type error</termref> is raised <errorref
                              class="TY" code="0004"/>.</p>
                     </item>
                  </olist>
               </item>



               <item>
                  <p>If the result of atomization is a single
atomic item, the result of the cast expression is determined by
casting to the target type as described in <xspecref
                        spec="FO40" ref="casting"
                        />. When casting, an
implementation may need to determine whether one type is derived by
restriction from another. An implementation can determine this either
by examining the <termref
                        def="dt-issd"
                        >in-scope schema
definitions</termref> or by using an alternative, <termref
                        def="dt-implementation-dependent">implementation-dependent</termref>
mechanism such as a data dictionary.

The result of a cast expression is one of the following: 

<olist>
                        <item>
                           <p> 
    A value of the target type (or, in the case of list types,
    a sequence of values that are instances of the item type of the
    list type).
  </p>
                        </item>
                        <item>
                           <p> 
    A type error, if casting from the source type to the
    target type is not supported (for example attempting to convert an
    integer to a date).
  </p>
                        </item>
                        <item>
                           <p> 
    A dynamic error, if the particular input value cannot be
    converted to the target type (for example, attempting to convert
    the string <code>"three"</code> to an integer).
  </p>
                        </item>
                     </olist>
                  </p>

                  <note diff="add" at="issue688"><p>Casting to an enumeration type relies on the fact that an enumeration type
                  is a generalized atomic type. So <code>cast $x as enum("red")</code> is equivalent
                  to casting to an anonymous atomic type derived from <code>xs:string</code>
                  whose enumeration facet restricts the value space to the single string <code>"red"</code>,
                     while <code>cast $x as enum("red", "green")</code> is equivalent to casting
                  to <code>(enum("red") | enum("green"))</code>.</p></note>


               </item>
            </olist>
         </div3>
         <div3 id="id-castable">
            <head>Castable</head>
            
            <scrap>
               <prodrecap ref="CastableExpr"/>
            </scrap>
            
            <p>&language;
provides an expression that tests whether a given value
is castable into a given target type. 

The <phrase diff="chg" at="A">target type</phrase> is subject to the same
               rules as the target type of a <code>cast</code> expression.</p>

            <p>The expression <code role="parse-test"
                  >E castable as T</code> returns <code>true</code> 
if the result of evaluating <code>E</code>  
can be successfully cast into the target type <code>T</code> by using a <code>cast</code> expression; 
otherwise it returns <code>false</code>. 
If evaluation of <code>E</code> fails with a dynamic error or if the value of <code>E</code> cannot be atomized, 
the <code>castable</code> expression as a whole fails.</p> 

<p>The <code>castable</code> expression can be used as a <termref
                  def="dt-predicate"
               >predicate</termref>  to
avoid errors at evaluation time. 
It can also be used to select an appropriate type for processing of a given value, as illustrated in
the following example:</p>

            <eg role="parse-test"><![CDATA[
if ($x castable as hatsize)
then $x cast as hatsize
else if ($x castable as IQ)
then $x cast as IQ
else $x cast as xs:string]]></eg>
            
            <note diff="add" at="issue688">
               <p>The expression <code>$x castable as enum("red", "green", "blue")</code>
               is for most practical purposes equivalent to <code>$x = ("red", "green", "blue")</code>;
            the main difference is that it uses the Unicode codepoint collation for comparing strings,
            not the default collation from the static context.</p>
            </note>
         </div3>
         <div3 id="id-constructor-functions">
            <head>Constructor Functions</head>
            <p>For every simple type in the <termref def="dt-is-types"
                  >in-scope schema types</termref>  (except <code>xs:NOTATION</code> and 
               <code>xs:anyAtomicType</code>, and <code>xs:anySimpleType</code>, which 
               are not instantiable), a <term>constructor function</term> is implicitly defined. 
               In each case, the name of the constructor function is the same as the name of 
               its target type (including namespace). The signature of the constructor 
               function for  a given type depends on the type that is being constructed, 
               and can be found in <xspecref spec="FO40" ref="constructor-functions"/>.</p>
            
            
               <p>There is also a constructor function for every <termref def="dt-named-item-type"/> 
               in the <termref def="dt-static-context"/>
            that expands either to a <termref def="dt-generalized-atomic-type"/> 
            <phrase diff="add" at="issue617">or to
            a <nt def="RecordType">RecordType</nt></phrase>.</p> 
            
               <p>All such constructor functions are classified as
               <termref def="dt-system-function">system functions</termref>.</p>

            <note diff="add" at="issue617"><p>The constructor function is present in the static
            context if and only if the corresponding type is present in the static context.</p>
            <p>For XSLT, this means that a constructor function corresponding to an imported
            schema type is private to the stylesheet package, and a constructor function
            corresponding to an <code>xsl:item-type</code> declaration has the same visibility
               as the <code>xsl:item-type</code> declaration.</p>
               <p>For XQuery, this means that a constructor function corresponding to an imported
                  schema type is private to the query module, and a constructor function
                  corresponding to a named item type declaration is <code>%public</code>
                  or <code>%private</code> according to the annotations on the item type declaration.</p></note>

            <p>
               <termdef term="constructor function" id="dt-constructor-function"
                     >The <term>constructor function</term> for a given simple type is used to convert instances of other  simple types into the given type. 
                  The semantics of the constructor function call <code>T($arg)</code> are defined to be equivalent to the expression <code
                     role="parse-test">$arg cast as T?</code>.</termdef>
            </p>
            <p>The following examples illustrate the use of constructor functions:</p>
            <ulist>



               <item>
                  <p>This
example is equivalent to <code role="parse-test"
                        >"2000-01-01" cast as
xs:date?</code>.</p>

                  <eg role="parse-test"><![CDATA[xs:date("2000-01-01")]]></eg>
               </item>



               <item>
                  <p>This
example is equivalent to

<code role="parse-test"
                        >($floatvalue * 0.2E-5) cast as xs:decimal?</code>.</p>
                  <eg role="parse-test"><![CDATA[xs:decimal($floatvalue * 0.2E-5)]]></eg>
               </item>



               <item>
                  <p>This example returns an
<code>xs:dayTimeDuration</code> value equal to 21 days. It is
equivalent to <code
                        role="parse-test">"P21D" cast as xs:dayTimeDuration?</code>.</p>
                  <eg role="parse-test"><![CDATA[xs:dayTimeDuration("P21D")]]></eg>
               </item>



               <item diff="add" at="issue688">
                  <p>If
                     <code>usa:zipcode</code> is a user-defined <termref def="dt-atomic-type"/>
in the <termref
                        def="dt-is-types"
                        >in-scope schema types</termref>, then the
following expression is equivalent to the
expression <code
                        role="parse-test">("12345" cast as
usa:zipcode?)</code>.</p>
                  <eg role="parse-test"><![CDATA[usa:zipcode("12345")]]></eg>
               </item>
               <item>
                  <p>If <code>my:chrono</code> is a named item type that expands to
                     <code>(xs:date | xs:time | xs:dateTime)</code>, then the result
                     of <code>my:chrono("12:00:00Z")</code> is the <code>xs:time</code>
                     value <code>12:00:00Z</code>.</p>
               </item>
               <item diff="add" at="issue617">
                  <p>If <code>my:location</code> is a named item type that expands
                  to <code>record(latitude as xs:double, longitude as xs:double)</code>,
                  then the result of <code>my:location(50.52, -3.02)</code> is
                  the map <code>{ 'latitude': 50.52e0, 'longitude': -3.02e0 }</code>.</p>
               </item>
            </ulist>

            <note>
               <p>
                  An instance of an <termref def="dt-atomic-type"/> whose name is in no namespace can be
  constructed by using a <nt def="URIQualifiedName">URIQualifiedName</nt> 
  in either a cast expression or a constructor function call.  Examples:
  </p>
               <eg role="parse-test"><![CDATA[17 cast as Q{}apple]]></eg>
               <eg role="parse-test"><![CDATA[Q{}apple(17)]]></eg>
               <p diff="chg" at="A">In either context, using an unqualified NCName might not work:
                  in a cast expression, an unqualified name is it is interpreted
                  according to the <termref def="dt-default-namespace-elements-and-types"/>,
                  while an unqualified name in a constructor function call is resolved using the
                  <termref def="dt-default-function-namespace"/> which will often be inappropriate.
               </p>
  
            </note>
         </div3>

         <div3 id="id-treat">
            <head>Treat</head>
            
            <scrap>
               <prodrecap ref="TreatExpr"/>
            </scrap>
            
            <p>&language; provides an
expression called <code>treat</code> that can be used to modify the
<termref
                  def="dt-static-type">static type</termref> of its
operand.</p>
            <p>Like <code>cast</code>, the <code>treat</code>
expression takes two operands: an expression and a <nt
                  def="SequenceType"
                  >SequenceType</nt>. Unlike
<code>cast</code>, however, <code>treat</code> does not change the
<termref
                  def="dt-dynamic-type"
                  >dynamic type</termref> or value of its operand. Instead, the purpose of
<code>treat</code> is to ensure that an expression has an expected
dynamic type at evaluation time.</p>
            <p>The semantics of <emph>
                  <code>expr1</code>
               </emph>
               <code> treat as </code>
               <emph>
                  <code>type1</code>
               </emph> are as
follows:</p>
            <ulist>



               <item>
                  <p>During static analysis:</p>
                  <p> The
<termref def="dt-static-type"
                        >static type</termref> of the
<code>treat</code> expression is <emph>
                        <code>type1</code>
                     </emph>. This enables the
expression to be used as an argument of a function that requires a
parameter of <emph>
                        <code>type1</code>
                     </emph>.</p>
               </item>



               <item>
                  <p>During expression
evaluation:</p>
                  <p>If <emph>
                        <code>expr1</code>
                     </emph> matches <emph>
                        <code>type1</code>
                     </emph>,
using the rules for <termref def="dt-sequencetype-matching"
                        >SequenceType
matching</termref>,
the <code>treat</code> expression returns the value of
<emph>
                        <code>expr1</code>
                     </emph>; otherwise, it raises a <termref def="dt-dynamic-error"
                        >dynamic error</termref>
                     <errorref class="DY" code="0050"/>.
If the value of <emph>
                        <code>expr1</code>
                     </emph> is returned, the identity of any nodes in the value is
preserved. The <code>treat</code> expression ensures that the value of
its expression operand conforms to the expected type at
run-time.</p>
               </item>



               <item>
                  <p>Example:</p>
                  <eg role="parse-test"><![CDATA[$myaddress treat as element(*, USAddress)]]></eg>
                  <p>The
<termref def="dt-static-type"
                        >static type</termref> of
<code>$myaddress</code> may be <code>element(*, Address)</code>, a
less specific type than <code>element(*, USAddress)</code>. However,
at run-time, the value of <code>$myaddress</code> must match the type
<code>element(*, USAddress)</code> using rules for <termref
                        def="dt-sequencetype-matching"
                        >SequenceType
matching</termref>;
otherwise a <termref
                        def="dt-dynamic-error">dynamic error</termref> is
raised <errorref
                        class="DY" code="0050"/>.</p>
               </item>
            </ulist>
            
            <note><p>Earlier releases of XPath and XQuery defined a mode of operation,
               sometimes called strict static typing, in which it was required that the static
               type of every expression should conform to the required type of the context
               in which it appeared. In this situation it was often necessary to define
               a more precise static type for an expression by the use of <code>treat as</code>.
               In the absence of this feature, the <code>treat as</code> expression is
               rarely necessary, though it can be useful for documentation, and might in
               some cases (depending on the processor) have performance benefits.
          </p></note>
         </div3>
      </div2>

      <div2 id="id-pipeline-operator">
         <head>Pipeline operator</head>

         <changes>
            <change issue="1685" PR="1686" date="2025-01-09">
               With the pipeline operator <code>-></code>, the result of an expression
               can be bound to the context value before evaluating another expression.
            </change>
         </changes>
        
         <scrap>
            <head/>
            <prodrecap id="PipelineExpr" ref="PipelineExpr"/>
         </scrap>
         
         <p diff="add" at="A"><termdef term="pipeline operator" id="dt-pipeline-operator">
            The <term>pipeline operator</term> <code>-></code> evaluates an expression and
            binds the result to the context value before evaluating another expression.</termdef></p>

         <p>Each operation <code><var>E1</var> -> <var>E2</var></code> is evaluated as follows: 
            Expression <var>E1</var> is evaluated to a sequence <code>S</code>. 
            <var>S</var> then serves in turn to provide an inner <termref def="dt-fixed-focus"/>
            (with the context value set to <var>S</var>) for an evaluation of <var>E2</var> in the
            <termref def="dt-dynamic-context">dynamic context</termref>.
            Unlike the <specref ref="id-map-operator"/>, the result of <var>E1</var> is bound
            just once and as a whole to the context value.
         </p>

         <p>The following examples illustrate the use of pipeline operators:</p>
         <example>
            <ulist>
               <item>
                  <p>Tokenizes a string, counts the tokens, creates a concatenated string and returns
                     <code>count=3</code>:</p>
                  <eg role="parse-test">'a b c' -> tokenize(.) -> count(.) -> concat('count=', .)
</eg>
                  <p>An equivalent expression is:
                     <eg role="parse-test">
let $string := 'a b c'
let $tokens := tokenize($string)
let $count := count($tokens)
return concat('count=', $count)
                     </eg>
                  </p>
               </item>
               <item>
                  <p>Calculates the sum of powers of <code>2</code> and returns
                     <code>2046</code>.</p>
                  <eg role="parse-test">(1 to 10) ! math:pow(2, .) -> sum(.)</eg>
                  <p>An equivalent expression is:
                     <eg role="parse-test">
let $powers := (
  for $exp in 1 to 10
  return math:pow(2, $exp)
)
return sum($powers)
                     </eg>
                  </p>
               </item>
               <item>
                  <p>Doubles the values of a sequence, compares the values pairwise with another
                     sequence, checks if some comparisons were successful, and returns
                     <code>true</code>.</p>
                  <eg role="parse-test">
(1 to 4)
-> for-each(., op('+'))
-> for-each-pair(4 to 7, ., op('>'))
-> some(.)
                  </eg>
                  <p>An equivalent expression is:
                     <eg role="parse-test">
let $data := 1 to 4
let $data := for-each($data, op('+'))
let $data := for-each-pair(4 to 7, $data, op('>'))
return some($data)
                     </eg>
                  </p>
               </item>
               <item>
                  <p>Reduces a long sequence to at most 9 elements, with dots appended,
                  and returns a single string.</p>
                  <eg role="parse-test">
$dictionary/word
-> (if(count(.) &lt; 10) then . else (.[1 to 9], '…'))
-> string-join(., '; ')
                  </eg>
                  <p>An equivalent expression is:
                     <eg role="parse-test">
let $words := $dictionary/word
let $chopped := (if(count($words) &lt; 10) then $words else ($words[1 to 9], '…'))
return string-join($chopped, '; ')
                     </eg>
                  </p>
               </item>
            </ulist>
         </example>
      </div2>

      <div2 id="id-map-operator">
         <head>Simple map operator (<code>!</code>)</head>


         <scrap>
            <prodrecap ref="SimpleMapExpr"/>
         </scrap>

         <p>
    A mapping expression <code><var>S</var>!<var>E</var></code> evaluates the
    expression <var>E</var> once for every item in the sequence
    obtained by evaluating <var>S</var>. The simple mapping operator
    <code>!</code> can be applied to any sequence, regardless of the
    types of its items, and it can deliver a mixed sequence of nodes,
    atomic items, and functions. Unlike the similar <code>/</code>
    operator, it does not sort nodes into document order or eliminate
    duplicates.
  </p>

         <p>Each operation <code><var>E1</var>!<var>E2</var></code> is evaluated as follows: 
            Expression <var>E1</var> is evaluated to a sequence <code>S</code>. 
            Each item in <var>S</var> then serves in turn to provide an inner focus 
            (the item as the context value, its position in <var>S</var> as the 
            context position, the length of <var>S</var> as the context size) 
            for an evaluation of <var>E2</var> in the <termref
               def="dt-dynamic-context"
               >dynamic context</termref>. The sequences resulting from all the 
            evaluations of <var>E2</var> are combined as follows: Every evaluation 
            of <var>E2</var> returns a (possibly empty) sequence of items. 
            The final result is the <termref def="dt-sequence-concatenation"/> of these sequences.
            The returned sequence preserves the orderings within and among the subsequences 
            generated by the evaluations of <var>E2</var>.
         </p>

         <p>Simple map operators have functionality similar to <specref ref="id-path-operator"
            />.
  The following table summarizes the differences between these two operators</p>

         <table role="medium" width="100%">
            <thead>
               <tr>
                  <th>Operator</th>
                  <th>Path operator (<code>E1 / E2</code>)</th>
                  <th>Simple map operator (<code>E1 ! E2</code>)</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <th>E1</th>
                  <td>Any sequence of nodes</td>
                  <td>Any sequence of items</td>
               </tr>
               <tr>
                  <th>E2</th>
                  <td>Either a sequence of nodes or a sequence of non-node items</td>
                  <td>A sequence of items</td>
               </tr>
               <tr>
                  <th>Additional processing</th>
                  <td>Duplicate elimination and document ordering</td>
                  <td>Simple <termref def="dt-sequence-concatenation"/></td>
               </tr>
            </tbody>
         </table>

         <p>The following examples illustrate the use of simple map operators combined with path expressions.</p>

         <example>
            <ulist>
               <item>
                  <p>
                     <code role="parse-test"
                        >child::div1 / child::para / string() ! concat("id-", .)</code>
                  </p>
                  <p>Selects the <code>para</code> element children of the <code>div1</code> element children of the context node; that is, the <code>para</code> element grandchildren of the context node that have <code>div1</code> parents. It then outputs the strings obtained by prepending <code>"id-"</code> to each of the string values of these grandchildren.</p>
               </item>
               <item>
                  <p>
                     <code role="parse-test">$emp ! (@first, @middle, @last)</code>
                  </p>
                  <p>Returns the values of the attributes <code>first</code>, <code>middle</code>, and <code>last</code> for each element in <code>$emp</code>, in the order given. (The <code>/</code> operator, if used here, would return the attributes in an unpredictable order.)</p>
               </item>
               <item>
                  <p>
                     <code role="parse-test">$docs ! ( //employee)</code>
                  </p>
                  <p>Returns all the <code>employee</code> elements within all the documents identified by the variable <code>$docs</code>, in document order within each document, but retaining the order of documents.</p>
               </item>
               <item>
                  <p>
                     <code role="parse-test"
                        >avg( //employee / salary ! translate(., '$', '') ! number(.))</code>
                  </p>
                  <p>Returns the average salary of the employees, having converted the salary to a number by removing any <code>$</code> sign and then converting to a number. (The second occurrence of <code>!</code> could not be written as <code>/</code> because the left-hand operand of <code>/</code> cannot be an atomic item.)</p>
               </item>
               <item>
                  <p>
                     <code role="parse-test">string-join((1 to $n) ! "*")</code>
                  </p>
                  <p>Returns a string containing <code>$n</code> asterisks.</p>
               </item>
               <item>
                  <p>
                     <code role="parse-test">$values ! (.*.) =&gt; sum()</code>
                  </p>
                  <p>Returns the sum of the squares of a sequence of numbers.</p>
               </item>
               <item>
                  <p>
                     <code role="parse-test">string-join(ancestor::* ! name(), '/')</code>
                  </p>
                  <p>Returns the names of ancestor elements, joined by <code>/</code> characters, i.e., the path to the parent of the context.</p>
               </item>
            </ulist>
         </example>

      </div2>

      <div2 id="id-arrow-operator">
         <head>Arrow Expressions</head>
         
         <changes>
            <change issue="1716">An arrow operator may now be followed by any dynamic function
            call; the dynamic function call no longer needs to start with a variable reference
            or a parenthesized expression.</change>
         </changes>
         
         <p>Arrow expressions apply a function to a value, using the value of the
         left-hand expression as the first argument to the function.</p>

         <scrap>
            <prodrecap ref="ArrowExpr"/>
         </scrap>
         
         <p>The arrow syntax is particularly helpful when applying multiple
            functions to a value in turn. For example, the following
            expression invites syntax errors due to misplaced parentheses:
         </p>
         
         <eg role="parsetest"
            ><![CDATA[tokenize((normalize-unicode(upper-case($string))),"\s+")]]></eg>
         
         <p>In the following reformulation, it is easier to see that the parentheses are balanced:</p>
         
         <eg role="parse-test"
            ><![CDATA[$string => upper-case() => normalize-unicode() => tokenize("\s+")]]></eg>
         
         <p diff="add" at="A">When the operator is written as <code>=!></code>, the function
            is applied to each item in the sequence in turn. 
            Assuming that <code>$string</code> is a single string, the above example could
            equally be written:</p>
         
         <eg role="parse-test"
            ><![CDATA[$string =!> upper-case() =!> normalize-unicode() =!> tokenize("\s+")]]></eg>
         
         <p diff="add" at="A">The difference between the two operators is seen when the left-hand
            operand evaluates to a sequence:</p>
         
         <eg role="parse-test"><![CDATA[(1, 2, 3) => avg()]]></eg>
         
         <p diff="add" at="2023-07-24">returns a value of only one item, <code>2</code>, the average of all three items, whereas </p>
         
         <eg role="parse-test"><![CDATA[(1, 2, 3) =!> avg()]]></eg>
         
         <p diff="add" at="2023-07-24">returns the original sequence of three items, <code>(1, 2, 3)</code>, 
            each item being the average of itself. The following example:</p>
         
         <eg role="parse-test"
            ><![CDATA["The cat sat on the mat"
=> tokenize()
=!> concat(".")
=!> upper-case()
=> string-join(" ")]]></eg>
         

         <p>returns <code>"THE. CAT. SAT. ON. THE. MAT."</code>. The first arrow
            could be written either as <code>=></code> or <code>=!></code> because the operand is a 
            <termref def="dt-singleton"/>; the next two

            arrows have to be <code>=!></code> because the function is applied to each item in the tokenized
            sequence individually; the final arrow must be <code>=></code> because the <code>string-join</code>
            function applies to the sequence as a whole.</p>
         
         <note><p>It may be useful to think of this as a map/reduce pipeline. The functions
            introduced by <code>=!></code> are mapping operations; the function introduced by <code>=></code>
            is a reduce operation.</p></note>
         
         <p>The following example introduces an inline function to the pipeline:</p>
         <eg role="parse-test" diff="add" at="A"
            ><![CDATA[(1 to 5) =!> xs:double() =!> math:sqrt() =!> fn($a) { $a + 1 }() => sum()]]></eg>
         
         <p>This is equivalent to <code>sum((1 to 5) ! (math:sqrt(xs:double(.)) + 1))</code>.</p>
         
         <p>The same effect can be achieved using a <termref def="dt-focus-function"/>:</p>
         
         <eg role="parse-test"
            ><![CDATA[(1 to 5) =!> xs:double() =!> math:sqrt() =!> fn { . + 1 }() => sum()]]></eg>
         
         <p>It could also be expressed using the mapping operator <code>!</code>:</p>
         
         <eg role="parse-test"
            ><![CDATA[(1 to 5) ! xs:double(.) ! math:sqrt(.) ! (. + 1) => sum()]]></eg>
         
         <p>Where the value of an expression is a map containing functions, simulating the behavior
         of objects in object-oriented languages, then the <term>lookup arrow operator</term> <code>=?></code>
         can be used to retrieve a function from the map and to invoke the function with the map as its
         first argument. For example, if <code>my:rectangle</code> returns a map with entries <code>width</code>,
         <code>height</code>, <code>expand</code>, and <code>area</code>, then it becomes possible to
         write:</p>
         
         <eg role="parse-test" diff="add" at="A"
            ><![CDATA[my:rectangle(3, 5) =?> expand(2) =?> area()]]></eg>
         
         <note diff="add" at="A"><p>The <code>ArgumentList</code> of the function call 
            may include <code>PlaceHolders</code>,
            though this is not especially useful. For example, the expression <code>"$" => concat(?)</code> is equivalent
            to <code>concat("$", ?)</code>: its value is a function that prepends a supplied string with
            a <code>$</code> symbol.</p></note>
         
         <note diff="add" at="A"><p>The <code>ArgumentList</code> may include keyword arguments if the
            function is identified statically (that is, by name). For example,
            the following is valid: <code>$xml => xml-to-json(indent := true()) => parse-json(escape := false())</code>.</p></note>
         
         <p diff="add" at="A">The sequence arrow operator thus applies the supplied function to 
            the left-hand operand as a whole, while the mapping arrow operator applies the function to
            each item in the value of the left-hand operand individually. In the case where the result
            of the left-hand operand is a single item, the two operators have the same effect.</p>
         
         <note><p>The mapping arrow symbol <code>=!></code> is intended to suggest a combination of
            function application (<code>=></code>) and sequence mapping
            (<code>!</code>) combined in a single operation.</p>
            <p>Similarly, the lookup arrow symbol <code>=?></code> is intended to suggest a combination
               of function application (<code>=></code>) and map lookup (<code>?</code>) in a single
            operation.</p>
         </note>
         
         <note><p>The expression <code><var>U</var> => $V(<var>X</var>)(<var>Y</var>)</code> 
         satisfies the grammar, but its meaning
         might not be obvious. It is interpreted as being equivalent to 
         <code>$V(<var>X</var>)(<var>U</var>, <var>Y</var>)</code>.
         The same applies to the mapping arrow operator: 
         <code><var>U</var> =!> $V(<var>X</var>)(<var>Y</var>)</code> is
         interpreted as <code>for $u in <var>U</var> return $V(<var>X</var>)($u, <var>Y</var>)</code>. 
         This follows from the way that the syntax of a <nt def="DynamicFunctionCall">DynamicFunctionCall</nt>
         is defined.</p></note>
         
         
         

        
         
         <div3 id="id-sequence-arrow-expression">
            <head>Sequence Arrow Expressions</head>
            
            <p diff="add" at="2023-04-18"><termdef term="sequence arrow operator" id="dt-sequence-arrow-operator">
               The <term>sequence arrow operator</term> <code>=></code> applies a function to a
               supplied sequence.</termdef> It is defined as follows:</p>
       
         
            <ulist>
               <item>
                  <p>If the arrow is followed by a static <nt def="FunctionCall">FunctionCall</nt>:</p>
                  <p>Given a  <nt def="UnaryExpr">UnaryExpr</nt>
                  <var>U</var> and a <nt def="FunctionCall">FunctionCall</nt>
                  <code><var>F</var>(<var>A</var>, <var>B</var>, <var>C</var>...)</code>, 
                  the expression <code><var>U</var> => <var>F</var>(<var>A</var>, <var>B</var>, <var>C</var>...)</code> 
                  is equivalent to the expression 
                  <code><var>F</var>(<var>U</var>, <var>A</var>, <var>B</var>, <var>C</var>...)</code>.</p></item>
               <item>
                  <p>If the arrow is followed by a <nt def="DynamicFunctionCall">DynamicFunctionCall</nt>:</p>
                  <p>Given a  <nt def="UnaryExpr">UnaryExpr</nt>
                  <var>U</var>, and a <nt def="DynamicFunctionCall">DynamicFunctionCall</nt>
                  <code><var>E</var>(<var>A</var>, <var>B</var>, <var>C</var>...)</code>, the expression 
                  <code><var>U</var> => <var>E</var>(<var>A</var>, <var>B</var>, <var>C</var>...)</code> is equivalent to the
                  expression <code><var>E</var>(<var>U</var>, <var>A</var>, <var>B</var>, <var>C</var>...)</code>.</p></item>
            </ulist>
            
            <note><p>Although the syntax of an arrow expression makes use of the grammatical productions
            <nt def="FunctionCall">FunctionCall</nt> and <nt def="DynamicFunctionCall">DynamicFunctionCall</nt>,
            these are not evaluated in the same way as a function call that appears as a 
            free-standing expression.</p></note>
            
         </div3>
         
         
         <div3 id="id-mapping-arrow-expression">
            <head>Mapping Arrow Expressions</head>
         
         <changes>
            <change>
               The arrow operator <code>=></code> is now complemented by a “mapping arrow” operator <code>=!></code>
               which applies the supplied function to each item in the input sequence independently.
            </change>
         </changes>
        
         
         <p><termdef term="mapping arrow operator" id="dt-mapping-arrow-operator">
            The <term>mapping arrow operator</term> <code>=!></code> applies a function to each
            item in a sequence.</termdef> It is defined as follows:</p>
            
         <ulist>
            
            <item>
               <p>If the arrow is followed by a static <nt def="FunctionCall">FunctionCall</nt>:</p>
               <p>Given a <nt def="UnaryExpr">UnaryExpr</nt>
                  <var>U</var> and a <nt def="FunctionCall">FunctionCall</nt>
                  <code><var>F</var>(<var>A</var>, <var>B</var>, <var>C</var>...)</code>, 
                  the expression <code><var>U</var> =!> <var>F</var>(<var>A</var>, <var>B</var>, <var>C</var>...)</code> 
                  is equivalent to the expression 
                  <code>for $u in <var>U</var> return 
                     <var>F</var>(<var>$u</var>, <var>A</var>, <var>B</var>, <var>C</var>...)</code>.</p></item>
            <item>
               <p>If the arrow is followed by a <nt def="DynamicFunctionCall">DynamicFunctionCall</nt>:</p>
            <p>Given a  <nt def="UnaryExpr">UnaryExpr</nt>
               <var>U</var>, and a <nt def="DynamicFunctionCall">DynamicFunctionCall</nt>
               <code><var>E</var>(<var>A</var>, <var>B</var>, <var>C</var>...)</code>, the expression 
               <code><var>U</var> => <var>E</var>(<var>A</var>, <var>B</var>, <var>C</var>...)</code> is equivalent to the
               expression <code>for $u in U return <var>E</var>(<var>$u</var>, <var>A</var>, <var>B</var>, <var>C</var>...)</code>.</p></item>
       
     
            
         </ulist>
         
         </div3>
         
         <div3 id="lookup-arrow-expression">
            <head>Lookup Arrow Expressions</head>
         
         <changes>
            <change PR="985" date="2024-02-13">
               With the lookup arrow expression and the <code>=?></code> operator, a function
               in a map can be looked up and called with the map as first argument.
            </change>
         </changes>
        
         
         <p>The lookup arrow expression simulates the behavior of method invocations in object-oriented
         languages. It is useful for invoking functions that are contained as entries in maps.</p>
         
         <p>For example, the expression</p>
         
         <eg>let $rectangle := {
  "width": 20,
  "height": 12,
  "area": fn($this) { $this?width * $this?height }
} 
return $rectangle =?> area()</eg>
         
         <p>returns the value <code>240</code>.</p>
         
         <p>An expression such as <code>M =?> N(A, B, C)</code> is evaluated as follows:</p>
         
         <olist>
            <item><p>The left-hand expression <var>M</var> is evaluated. If the value is an
               empty sequence, then the result of the expression is an empty
               sequence. If it is non-empty then it must be a single map: call it <code>$m</code>.</p></item>
            <item><p>The lookup expression <code>$m?N</code> is evaluated. The result must be a single
            function item: call it <code>$f</code>.</p></item>
            <item><p>The dynamic function call <code>$f($m, A, B, C)</code> is evaluated, and the
            result is returned.</p></item>
         </olist>
         
         <p>Any of the above steps can lead to errors:</p>
         
         <olist>
            <item><p>A type error <errorref class="TY" code="0004"/> is raised if the value of the left hand 
               expression does not match the type <code>map(*)?</code>.</p></item>
            <item><p>A type error <errorref class="TY" code="0004"/> is raised if the value of the lookup 
               expression <code>$m?N</code> does not match the type <code>function(*)</code>, or if the
               arity of the function is not equal to the number of arguments in the argument list
            plus one.</p></item>
            <item><p>An error may occur in evaluating the dynamic function call, for example if the
            function does not expect a map to be supplied as the first argument.</p></item>
         </olist>
         
          
         </div3>    
            
            
      </div2>
      
      <div2 id="id-validate" role="xquery">
         <head>Validate Expressions</head>
         
         <changes>
            <change issue="729" PR="1254" date="2024-06-08">
                  The rules concerning the interpretation of <code>xsi:schemaLocation</code>
                  and <code>xsi:noNamespaceSchemaLocation</code> attributes have been tightened up.
               </change>
         </changes>

         <scrap>
            <prodrecap ref="ValidateExpr"/>
         </scrap>

         <p>A <code>validate</code> expression can be used to validate a
        document node or an element node with respect to the <termref
               def="dt-issd"
               >in-scope schema definitions</termref>, using the schema
        validation process defined in <bibref
               ref="XMLSchema10"/> or <bibref ref="XMLSchema11"
               />. If the
        operand of a <code>validate</code> expression does not evaluate to
        exactly one document or element node, a <termref
               def="dt-type-error">type error</termref> is raised <errorref class="TY" code="0030"
               />. In this specification, the node that is the
        operand of a <code>validate</code> expression is called the
        <term>operand node</term>.</p>


         <p>A <code>validate</code> expression returns a new node with its own identity and with no parent.
        The new node and its descendants are given <termref
               def="dt-type-annotation"
            >type annotation</termref>
        that are generated by applying a validation process to the operand node. In some cases, default values
        may also be generated by the validation process.</p>

         <p>A <code>validate</code> expression may optionally specify a <nt def="ValidationMode"
               >validation mode</nt>. The default
        <nt def="ValidationMode"
               >validation mode</nt>
        (applicable when no type name is provided)

        is <code>strict</code>.</p>

         <p>A <code>validate</code> expression may optionally specify a <nt def="TypeName"
               >TypeName</nt>. This type name must be found in the <termref def="dt-issd"
               >in-scope
            schema definitions</termref>; if it is not, a <termref
               def="dt-static-error">static error</termref> is raised <errorref class="ST"
               code="0104"
            />.  If the type name is unprefixed, it is
        interpreted according to the <termref def="dt-default-namespace-elements-and-types"/>.
    </p>


         <p>The result of a <code>validate</code> expression is defined by the following rules.</p>

         <olist>


            <item>
               <p> If the operand node is a document node, its children must
            consist of exactly one element node and zero or more comment and
            processing instruction nodes, in any order; otherwise, a <termref
                     def="dt-dynamic-error">dynamic error</termref>
                  <errorref class="DY" code="0061"/> is raised.</p>
            </item>



            <item>
               <p>The operand node is converted to an XML Information Set
            (<bibref
                     ref="XINFO"
                     />) according to the “Infoset Mapping” rules
            defined in <bibref
                     ref="xpath-datamodel-40"
                     />. Note that this process
            discards any existing <termref
                     def="dt-type-annotation"
                     >type
            annotations</termref>.
            Validity assessment is carried out on the root element
                    information item of the resulting Infoset, using the <termref
                     def="dt-issd"
                  >in-scope schema definitions</termref> as the effective
                    schema.  The process of validation applies recursively to contained
                    elements and attributes to the extent required by the effective
                    schema. </p>
            </item>


            <item>
               <p>If a type name is provided, and the type name is <code>xs:untyped</code>, all elements receive the type annotation <code>xs:untyped</code>,
        and all attributes receive the type annotation <code>xs:untypedAtomic</code>. 
        If the type name is <code>xs:untypedAtomic</code>, the node receives the type annotation xs:untypedAtomic;
        a type error <errorref
                     class="TY" code="0004"
                     /> is raised if the node has element children. 

	    Otherwise, schema-validity assessment is
            carried out according to the rules defined in <bibref
                     ref="XMLSchema10"/> or <bibref ref="XMLSchema11"
                     /> Part 1, section 3.3.4 "Element
            Declaration Validation Rules", “Validation Rule: Schema-Validity Assessment (Element)”, clauses 1.2 and 2, using this type definition as the
            <quote>processor-stipulated type definition</quote> for validation.</p>

               <p>If the instance being validated contains an xml:id attribute, both lax and strict validation cause this attribute to be subjected to [xml:id] processing: that is, the attribute is checked for uniqueness, and is typed as xs:ID, and the containing element is therefore eligible as a target for the id() function.</p>

            </item>
            
            <item>
               <p>It is <termref def="dt-implementation-defined"/> whether the validity assessment
                  process takes account of any <code>xsi:schemaLocation</code> or <code>xsi:noNamespaceSchemaLocation</code>
                  attributes in the tree being validated. If it does so, then it <rfc2119>should</rfc2119>
                  adhere to the following rules:</p>
                  
                  <olist>
                     <item><p>Any schema loaded using these attributes must be 
                        <xtermref spec="DM40" ref="dt-schema-compatible">compatible</xtermref> 
                     with the schema in the static context from which validation is invoked.</p></item>
                     <item><p>Any schema loaded using these attributes must not override
                     or redefine any schema components in the static context.</p></item>
                     <item><p>Any schema components loaded using this mechanism must be
                     used for this validity assessment only, and must not 
                     affect the outcome of any subsequent validity assessments of other documents.</p>
                     <note><p>A processor may choose to cache such schema components but the existence
                     of such a cache should only affect performance, not the validation outcome.</p></note></item>
                  </olist>
                  <p>A consequence of validating a document using schema components that are not 
                  in the static context is that nodes may be annotated with types 
                  that are not in the static context. But the rules for
                  <xtermref spec="DM40" ref="dt-schema-compatible">schema compatibility</xtermref>
                  mean that this is not a problem.</p>
                  
            </item>

            <item>
               <p>When no type name is provided:</p>

               <olist>

                  <item>
                     <p>If <nt def="ValidationMode"
                           >validation mode</nt> is <code>strict</code>, then there must be a
                    top-level element declaration in the <termref
                           def="dt-is-elems"
                           >in-scope element declarations</termref>
                    that matches the root element information
                    item in the Infoset, and schema-validity assessment is
                    carried out using that declaration in accordance with
                     <bibref
                           ref="XMLSchema10"
                           /> Part 1, section 5.2, “Assessing Schema-Validity”, item
                    2, or  <bibref
                           ref="XMLSchema11"
                           /> Part 1, section 5.2, “Assessing Schema-Validity”,
                    “element-driven validation”.

                    If there is no such element declaration, a <termref
                           def="dt-dynamic-error"
                           >dynamic error</termref> is
                    raised <errorref
                           code="0084" class="DY"/>.</p>
                  </item>



                  <item>
                     <p>If <nt def="ValidationMode"
                           >validation mode</nt> is <code>lax</code>, then schema-validity
                    assessment is carried out in accordance with <bibref
                           ref="XMLSchema10"
                           /> Part 1, section 5.2, “Assessing Schema-Validity”,
                    item 3, or <bibref
                           ref="XMLSchema11"
                        /> Part 1, section 5.2, “Assessing Schema-Validity”, “lax wildcard validation”.</p>

                     <p>If <nt def="ValidationMode"
                           >validation mode</nt> is <code>lax</code> and the root element
                        information item has neither a top-level element
                        declaration nor an <code>xsi:type</code> attribute, <bibref
                           ref="XMLSchema10"
                           />  defines the recursive checking of children
                        and attributes as optional. During processing of an XQuery <code>validate</code> expression, this
                        recursive checking is required.</p>
                  </item>

                  <item>
                     <p at="XQ.E7"
                        >If the operand node is an element node, the validation rules named
                “Validation Root Valid (ID/IDREF)” are not applied. This means that document-level constraints
                relating to uniqueness and referential integrity are not enforced.</p>
                  </item>

                  <item>
                     <p>There is no check that the document contains unparsed entities whose names match the
                values of nodes of type <code>xs:ENTITY</code> or <code>xs:ENTITIES</code>.</p>
                  </item>

               </olist>


               <note>
                  <p>Validity assessment is affected by the presence or absence of <code>xsi:type</code> attributes
            on the elements being validated, and may generate new information items such as default attributes.</p>
               </note>
            </item>



            <item>
               <p>The outcome of the validation expression depends on the
            <code>validity</code> property of the root element information item in the PSVI that results
            from the validation process.</p>


               <olist>


                  <item>
                     <p>If the <code>validity</code> property of the root element
                    information item is <code>valid</code>,

                    or if <nt
                           def="ValidationMode"
                           >validation mode</nt> is
                    <code>lax</code> and the <code>validity</code> property of the root
                    element information item is <code>notKnown</code>,

                    the PSVI is converted back into an <termref
                           def="dt-data-model-instance"
                           >XDM instance</termref>


                    as described in <bibref
                           ref="xpath-datamodel-40"
                           /> Section
                    3.3, “Construction from a PSVI”.

                    The resulting node (a new node of the same kind as the operand node)
                    is returned as the result of the <code>validate</code>
                    expression.</p>
                  </item>



                  <item>
                     <p>Otherwise, a <termref def="dt-dynamic-error"
                           >dynamic
                error</termref> is raised  <errorref class="DY"
                           code="0027"/>.</p>
                  </item>
               </olist>

            </item>
         </olist>

         <note>
            <p>The effect of these rules is as follows, where the <emph>validated element</emph> means
            either the operand node or (if the operand node is a document node) its element child:
        <ulist>
                  <item>
                     <p>If <nt def="ValidationMode"
                        >validation mode</nt> is <code>strict</code>,
            the validated element must have a top-level element declaration in the effective schema, and must conform to this
            declaration.</p>
                  </item> <item>
                     <p>If <nt def="ValidationMode"
                           >validation mode</nt> is <code>lax</code>, the validated element must conform
            to its top-level element declaration if such a declaration exists in the effective schema. If
            <nt
                           def="ValidationMode"
                           >validation mode</nt>
                        is <code>lax</code> and there is no top-level element declaration for the
                        element, and the element has an <code>xsi:type</code> attribute, then the
                        <code>xsi:type</code> attribute must name a top-level type definition in the
                        effective schema, and the element must conform to that type.</p>
                  </item> <item>
                     <p>If a type name is specified in the validate expression, no attempt is
                made to locate an element declaration matching the name of the validated
                element; the element can have any name, and its content is validated against
                the named type.
</p>
                  </item> </ulist>
            </p>
         </note>

         <note>
            <p>During conversion of the PSVI into an <termref def="dt-data-model-instance"
                  >XDM instance</termref>
        after validation, any element information items whose validity property is <code>notKnown</code> are
        converted into element nodes with <termref
                  def="dt-type-annotation">type annotation</termref>
               <code>xs:anyType</code>, and any attribute information items whose validity property is
        <code>notKnown</code> are converted into attribute nodes with <termref
                  def="dt-type-annotation">type annotation</termref>
               <code>xs:untypedAtomic</code>, as described in <xspecref spec="DM40"
                  ref="PSVI2NodeTypes"/>.
    </p>
         </note>
         
         <note diff="add" at="Issue451">
            <p>A query might take as its primary input a document conforming to schema <var>X</var>,
            and produce as its primary output a document conforming to schema <var>Y</var>.
            To be sure that the output is indeed valid against schema <var>Y</var>, the safest
            course of action is to evaluate a <code>validate</code> expression within
            a query module that imports schema <var>Y</var> and nothing else. Otherwise,
               if the validation occurs within a module that imports both <var>X</var>
            and <code>Y</code>, the outcome of validation might differ because of the
            differences between the two schemas.</p>
         </note>

      </div2>


      <div2 id="id-extension-expressions" role="xquery">
         <head>Extension Expressions</head>
         <p>
            <termdef id="dt-extension-expression" term="extension expression"
                  >An <term>extension expression</term> is an expression whose semantics are
<termref
                  def="dt-implementation-defined"
            >implementation-defined</termref>.</termdef> Typically a particular extension will be recognized
by some implementations and not by others. The syntax is designed so that
extension expressions can be successfully parsed by all implementations, and
so that fallback behavior can be defined for implementations that do not
recognize a particular extension.</p>

         <scrap>
            <prodrecap ref="ExtensionExpr"/>
         </scrap>

         <p>An extension expression consists of one or more <term>pragmas</term>, followed by an optional expression (the <term>associated expression</term>). <termdef
               term="pragma" id="dt-pragma"
                  >A <term>pragma</term> is denoted by the delimiters <code>(#</code> and <code>#)</code>, and consists of an identifying EQName followed by <termref
                  def="dt-implementation-defined"
               >implementation-defined</termref> content.</termdef> The content of a pragma may consist of any string of characters that does not contain the ending delimiter <code>#)</code>.  If the EQName of a
pragma is a  <termref
               def="dt-qname"
               >lexical QName</termref>, it must resolve to a namespace URI and local name, using the <termref
               def="dt-static-namespaces">statically known namespaces</termref>
            <errorref class="ST" code="0081"
            />. If the EQName is an unprefixed NCName, it is interpreted as a name in no namespace (and the pragma is therefore ignored).</p>



         <p>Each implementation recognizes an <termref def="dt-implementation-defined"
               >implementation-defined</termref> set
of namespace URIs used to denote pragmas.</p>

         <p>If the namespace URI of a pragma’s <termref def="dt-expanded-qname"
               >expanded QName</termref> 
is not recognized by the implementation as a pragma namespace, 
 or if the name is in no namespace, 
then the pragma is ignored. If all the pragmas in an <nt
               def="ExtensionExpr">ExtensionExpr</nt> are ignored, then the
value of the <nt
               def="ExtensionExpr"
               >ExtensionExpr</nt> is the value of the 
 

associated expression; if no associated expression is provided,  a <termref
               def="dt-static-error">static error</termref> is raised <errorref class="ST"
               code="0079"/>.
</p>

         <p>If an implementation recognizes the namespace of one or more
pragmas in an <nt
               def="ExtensionExpr">ExtensionExpr</nt>, then the
value of the <nt def="ExtensionExpr"
               >ExtensionExpr</nt>, including its
error behavior, is <termref
               def="dt-implementation-defined"
               >implementation-defined</termref>. For
example, an implementation that recognizes the namespace of a pragma’s
<termref
               def="dt-expanded-qname"
            >expanded QName</termref>, but does
not recognize the local part of the name, might choose either to raise
an error or to ignore the pragma.</p>
         <p>It is a <termref def="dt-static-error">static error</termref>
            <errorref code="0013" class="ST"
            /> if an implementation recognizes a pragma but determines
that its content is invalid.</p>
         <p>If an implementation recognizes a
pragma, it must report any static errors in the following expression
even if it will not evaluate that expression.</p>
         <note>
            <p>The following examples illustrate three ways in
which extension expressions might be used.</p>
            <ulist>



               <item>
                  <p>A pragma can be used to furnish a hint for how to evaluate the
following expression, without actually changing the result.
For example:</p>
                  <eg role="parse-test"><![CDATA[declare namespace exq = "http://example.org/XQueryImplementation";
(# exq:use-index #) {
  $bib/book/author[name = 'Berners-Lee']
}
]]></eg>
                  <p>An implementation that recognizes the <code>exq:use-index</code> pragma might use an
index to evaluate the  expression that follows. An implementation that
does not recognize this pragma would evaluate the expression in its normal
way.</p>
               </item>



               <item>
                  <p>A pragma might be used to modify the semantics of the following
expression in ways that would not (in the absence of the pragma) be
conformant with this specification. For example, a pragma might be used to
permit comparison of <code>xs:duration</code> values using implementation-defined
semantics (this would normally be an error). Such changes to the language
semantics must be scoped to the <termref
                        def="dt-enclosed-expression"
                     >enclosed expression</termref> following the pragma.</p>
               </item>



               <item>
                  <p>A pragma might contain syntactic constructs that are
evaluated in place of the following expression. In this case, the
following expression itself (if it is present) provides a fallback for use by
implementations that do not recognize the pragma. For example:</p>
                  <eg role="parse-test"><![CDATA[declare namespace exq = "http://example.org/XQueryImplementation";

for $x in (# exq:distinct //city by @country #) {
  //city[not(@country = preceding::city/@country)]
}
return f:show-city($x)
]]></eg>
                  <p>Here an implementation that recognizes the pragma will return the result of
evaluating the proprietary syntax <code>exq:distinct //city by
@country</code>,
while an implementation that does not recognize the pragma will instead
return the result of the expression <code
                        role="parse-test"
                        >//city[not(@country =
preceding::city/@country)]</code>. If no fallback expression is required, or
if none is feasible, then the expression between the curly brackets may be
omitted, in which case implementations that do not recognize the pragma will
raise a <termref
                        def="dt-static-error">static error</termref>.</p>
               </item>
            </ulist>
         </note>
      </div2>
   </div1>

