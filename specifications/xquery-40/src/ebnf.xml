<?xml version="1.0" encoding="utf-8"?>
<div1 id="nt-bnf">
  <head>&language; Grammar</head>
  <div2 id="id-grammar">
    <head>EBNF</head>
    <changes>
      <change issue="1366" PR="1498">The EBNF operators <code>++</code> and <code>**</code>
      have been introduced, for more concise representation of sequences using a character
      such as <code>","</code> as a separator. The notation is borrowed from Invisible XML.</change>
    </changes>
    <p>The grammar of &language; uses the same simple Extended Backus-Naur Form (EBNF) notation as
        <bibref ref="XML"/> with the following differences.</p>
    <ulist>
      <item>
        <p>The notation <code>XYZ ** ","</code> indicates a sequence of zero or more occurrences of
        <code>XYZ</code>, with a single comma between adjacent occurrences.</p>
      </item>
      <item>
        <p>The notation <code>XYZ ++ ","</code> indicates a sequence of one or more occurrences of
        <code>XYZ</code>, with a single comma between adjacent occurrences.</p>
      </item>
      <item>
        <p>All named symbols have a name that begins with an uppercase letter.</p>
      </item>
      <item>
        <p>It adds a notation for referring to productions in external specifications.</p>
      </item>
      <item>
        <p>Comments or extra-grammatical constraints on grammar productions are between '/*' and
          '*/' symbols.</p>
        <ulist>
          <item>
            <p>A 'xgc:' prefix is an extra-grammatical constraint, the details of which are
              explained in <specref ref="extra-grammatical-constraints"/></p>
          </item>
          <item>
            <p>A 'ws:' prefix explains the whitespace rules for the production, the details of which
              are explained in <specref ref="whitespace-rules"/></p>
          </item>
          <item>
            <p>A 'gn:' prefix means a 'Grammar Note', and is meant as a clarification for parsing
              rules, and is explained in <specref ref="notes-on-parsing"/>. These notes are not
              normative.</p>
          </item>
        </ulist>
      </item>
    </ulist>
    <p>The terminal symbols for this grammar include the quoted strings used in the production rules
      below, and the terminal symbols defined in section <specref ref="terminal-symbols"/>.
    <phrase diff="add" at="2023-05-22">The grammar is a little unusual in that parsing and tokenization
    are somewhat intertwined: for more details see <specref ref="lexical-structure"/>.</phrase></p>
    <p>The EBNF notation is described in more detail in <specref ref="EBNFNotation"/>.</p>
    
    <scrap id="BNF-Grammar" role="non-terminal-structure-expand">
      <head/>
      <prodgroup>
        <prodrecap id="BNF-Grammar-prods" ref="BNF-Grammar-prods"/>
      </prodgroup>
    </scrap>
    <div3 id="EBNFNotation">
      <head>Notation</head>
      <changes>
        <change issue="1366" PR="1498">The EBNF operators <code>++</code> and <code>**</code>
        have been introduced, for more concise representation of sequences using a character
        such as <code>","</code> as a separator. The notation is borrowed from Invisible XML.</change>
      </changes>
      <p>
        <termdef id="symbol" term="symbol">Each rule in the grammar defines one <term>symbol</term>,
          using the following format: <eg>symbol ::= expression</eg></termdef>
      </p>
      <p>
        <termdef term="terminal" id="terminal">A <term>terminal</term> is a symbol or string or
          pattern that can appear in the right-hand side of a rule, but never appears on the
          left-hand side in the main grammar, although it may appear on the left-hand side of a rule
          in the grammar for terminals.</termdef> The following constructs are used to match strings
        of one or more characters in a terminal:</p>
      <glist>
        <gitem>
          <label>[a-zA-Z]</label>
          <def>
            <p>matches any <nt def="Char" id="Char">Char</nt> with a value in the range(s) indicated
              (inclusive).</p>
          </def>
        </gitem>
        <gitem>
          <label>[abc]</label>
          <def>
            <p>matches any <nt def="Char">Char</nt> with a value among the characters enumerated.
            </p>
          </def>
        </gitem>
        <gitem>
          <label>[^abc]</label>
          <def>
            <p>matches any <nt def="Char">Char</nt> with a value not among the characters given.</p>
          </def>
        </gitem>
        <gitem>
          <label>"string" or 'string'</label>
          <def>
            <p>matches the sequence of characters that appear inside the double or single quotation marks.</p>
          </def>
        </gitem>
        <gitem>
          <label> [http://www.w3.org/TR/REC-example/#NT-Example]</label>
          <def>
            <p>matches any string matched by the production defined in the external specification as
              per the provided reference.</p>
          </def>
        </gitem>
      </glist>
      <p>Patterns (including the above constructs) can be combined with grammatical operators to
        form more complex patterns, matching more complex sets of character strings. In the examples
        that follow, <var>A</var> and <var>B</var> represent (sub-)patterns.</p>
      <glist>
        <gitem>
          <label>(A)</label>
          <def>
            <p>
              <code>A</code> is treated as a unit and may be combined as described in this list.</p>
          </def>
        </gitem>
        <gitem>
          <label>A?</label>
          <def>
            <p>matches <code>A</code> or nothing; optional <code>A</code>.</p>
          </def>
        </gitem>
        <gitem>
          <label>A B</label>
          <def>
            <p>matches <code>A</code> followed by <code>B</code>. This implicit operator has higher
              precedence than the choice operator <code>|</code>; thus <code>A B | C D</code> is 
              interpreted as <code>(A B) | (C D)</code>.</p>
          </def>
        </gitem>
        <gitem>
          <label>A | B</label>
          <def>
            <p>matches <code>A</code> or <code>B</code> but not both.</p>
          </def>
        </gitem>
        <gitem>
          <label>A - B</label>
          <def>
            <p>matches any string that matches <code>A</code> but does not match <code>B</code>.</p>
          </def>
        </gitem>
        <gitem>
          <label>A+</label>
          <def>
            <p>matches one or more occurrences of <code>A</code>. Concatenation has higher
              precedence than choice; thus <code>A+ | B+</code> is identical to <code>(A+) |
                (B+)</code>.</p>
          </def>
        </gitem>
        <gitem>
          <label>A*</label>
          <def>
            <p>matches zero or more occurrences of <code>A</code>. Concatenation has higher
              precedence than choice; thus <code>A* | B*</code> is identical to <code>(A*) |
                (B*)</code></p>
          </def>
        </gitem>
        <gitem>
          <label>(A ++ B)</label>
          <def>
            <p>matches one or more occurrences of <code>A</code>, with one occurrence of <code>B</code>
              between adjacent occurrences of <code>A</code>. 
              The notation <code>A ++ B</code> is a shorthand for <code>A (B A)*</code>. The construct
              is always parenthesized to avoid ambiguity, and although in principle
              <code>B</code> could be any pattern, in practice the notation is used only when it is a simple string literal
              (typically but not invariably <code>","</code>).</p>
            <p>For example, <code>(Digit ++ ".")</code> matches <code>1</code> or <code>1.2</code>
            or <code>1.2.3</code>.</p>
          </def>
        </gitem>
        <gitem>
          <label>(A ** B)</label>
          <def>
            <p>matches zero or more occurrences of <code>A</code>, with one occurrence of <code>B</code>
              between adjacent occurrences of <code>A</code>.  
              The notation <code>A ** B</code> is a shorthand for <code>(A (B A)*)?</code>. The construct
              is always parenthesized to avoid ambiguity, and although in principle
              <code>B</code> could be any pattern, in practice the notation is used only when it is a simple string literal
              (typically but not invariably <code>","</code>).</p>
            <p>For example, <code>"[" (Digit ** "|") "]"</code> matches <code>[]</code> or <code>[1]</code> or <code>[1|2]</code>
            or <code>[1|2|3]</code>.</p>
          </def>
        </gitem>
      </glist>
    </div3>
    <div3 id="extra-grammatical-constraints">
      <head>Extra-grammatical Constraints</head>
      <p>This section contains constraints on the EBNF productions, which are required to parse
        syntactically valid sentences. The notes below are referenced from the right side of the
        production, with the notation: <emph>/* xgc: &lt;id&gt; */</emph>.</p>
      <constraintnote id="parse-note-leading-lone-slash" type="xgc">
        <head>leading-lone-slash</head>
        <p>A single slash may appear either as a complete path expression or as the first part of a
          path expression in which it is followed by a <nt def="RelativePathExpr"
            >RelativePathExpr</nt>. In some cases, the next terminal after the slash is insufficient to
          allow a parser to distinguish these two possibilities: a <code>*</code> symbol or a
          keyword like <code>union</code> could be either an operator or a <nt def="NameTest"
            >NameTest</nt>. For example, the expression <code>/union/*</code> could be parsed
          either as <code>(/) union (/*)</code> or as <code>/child::union/child::*</code> (the
          second interpretation is the one chosen).</p>
        
        
        <p>The situation where <code>/</code> is followed by <code>&lt;</code> is a little more
          complicated. In XPath, this is unambiguous: the <code>&lt;</code> can only indicate
          one of the operators <code>&lt;</code>, <code>&lt;=</code>, or <code>&lt;&lt;</code>.
          In XQuery, however, it can also be the start of a direct constructor: specifically,
          a direct constructor for an element node, processing instruction node, or comment node.
          These constructs are identified by the tokenizer, independently of their syntactic
          context, as described in <specref ref="lexical-structure"/>.</p>         
          
        <p>The rule adopted is as follows: if the terminal immediately following a slash
          can form the start of a <nt def="RelativePathExpr">RelativePathExpr</nt>, then the slash
          must be the beginning of a <nt def="PathExpr">PathExpr</nt>, not the entirety of it.</p>
        
        <p>The terminals that can form the start of a <nt def="RelativePathExpr">RelativePathExpr</nt>
        are: <code>NCName</code>, <code>QName</code>, <code>URIQualifiedName</code>,
          <code>StringLiteral</code>, <code>NumericLiteral</code>, 
          <code>Wildcard</code>, and <code>StringTemplate</code>; 
        plus <code>@</code> <code>.</code> <code>..</code> <code>*</code>
          <code>$</code> <code>?</code> <code>??</code> <code>%</code>
          <code>(</code> <code>[</code>; and in XQuery <code>StringConstructor</code> and <code>DirectConstructor</code>.
        </p>
        
        <!-- The above list was obtained by running the stylesheet leading-tokens.xsl against xpath-grammar.xml -->
        
        <p>A single slash may be used as the left-hand argument of an operator by parenthesizing it:
            <code role="parse-test">(/) * 5</code>. The expression <code role="parse-test">5 *
            /</code>, on the other hand, is syntactically valid without parentheses.</p>
      </constraintnote>
      
      <constraintnote id="parse-note-unreserved-name" type="xgc" role="xquery">
        <head>unreserved-name</head>
        <p>In a computed node constructor of the form
        <code>element <var>NNN</var> {}</code>, <code>attribute <var>NNN</var> {}</code>,
          <code>processing-instruction <var>NNN</var> {}</code>, or <code>namespace <var>NNN</var> {}</code>,
          XQuery 4.0 allows the name <var>NNN</var>
        to be written as a plain <code>NCName</code> only if it is not a language keyword: more specifically, if it
        is not one of the <termref def="dt-literal-terminal">literal terminals</termref> taking the form of
        an <code>NCName</code> that are listed in <specref ref="lexical-structure"/>. If such names (for example
        <code>div</code> or <code>value</code>) are to be used as element or attribute names in a computed
        node constructor, they must be written as a string literal in quotation marks.</p>
        
        <p>This rule is new in XQuery 4.0, and represents a backwards incompatibility. To ease transition, implementations
        may provide an option to allow such names to be accepted with a warning that the construct is deprecated.
        The reason for the change is that the construct has proved an obstacle to extending the language without
        introducing ambiguity or extensive lookahead; it also makes syntax errors difficult to diagnose.</p>
      </constraintnote> 
      
      <constraintnote id="parse-note-xml-version" type="xgc">
        <head>xml-version</head>
        <p>The version of XML and XML Names (e.g. <bibref ref="XML"/> and <bibref ref="XMLNAMES"/>,
          or <bibref ref="XML1.1"/> and <bibref ref="XMLNAMES11"/>) is <termref
            def="dt-implementation-defined">implementation-defined</termref>. It is recommended that
          the latest applicable version be used (even if it is published later than this
          specification). The EBNF in this specification links only to the 1.0 versions. Note also
          that these external productions follow the whitespace rules of their respective
          specifications, and not the rules of this specification, in particular <specref
            ref="DefaultWhitespaceHandling"/>. Thus <code>prefix : localname</code> is not a
          syntactically valid <termref def="dt-qname">lexical QName</termref> for purposes of this
          specification, just as it is not permitted in a XML document. Also, comments are not
          permissible on either side of the colon. Also extra-grammatical constraints such as
          well-formedness constraints must be taken into account.</p>


        <p role="xquery">XML 1.0 and XML 1.1 differ in their handling of C0 control characters
          (specifically #x1 through #x1F, excluding #x9, #xA, and #xD) and C1 control characters
          (#x7F through #x9F). In XML 1.0, these C0 characters are prohibited, and the C1 characters
          are permitted. In XML 1.1, both sets of control characters are permitted, but only if
          written as character references. It is RECOMMENDED that implementations should follow the
          XML 1.1 rules in this respect; however, for backwards compatibility with <phrase
            role="xquery">XQuery 1.0</phrase>
          <phrase role="xpath">XPath 2.0</phrase>, implementations MAY allow C1 control characters
          to be used directly. <note><p>Direct use of C1 control characters often suggests a
              character encoding error, such as using encoding CP-1252 and mislabeling it as
              iso-8859-1.</p></note></p>

        

      </constraintnote>

      <constraintnote id="parse-note-reserved-function-names" type="xgc">
        <head>reserved-function-names</head>
        <p>Unprefixed function names spelled the same way as language keywords could make the
          language impossible to parse. For instance, <code>element(foo)</code> could be taken either as
          a <nt def="FunctionCall">FunctionCall</nt> or as an <nt def="ElementTest"
            >ElementTest</nt>. Therefore, an unprefixed function name must not be any of the names in
            <specref ref="id-reserved-fn-names"/>.</p>

        <p>A function named <code>if</code> can be called by binding its namespace to a prefix and using the
          prefixed form: <code>library:if(foo)</code> instead of <code>if(foo)</code>.</p>
      </constraintnote>
      <constraintnote id="parse-note-occurrence-indicators" type="xgc">
        <head>occurrence-indicators</head>
        <p diff="chg" at="2023-05-22">As written, the grammar in <specref ref="nt-bnf"/> is ambiguous for some forms using the
          <code>"+"</code>, <code>"?"</code> and <code>"*"</code> <nt def="OccurrenceIndicator">OccurrenceIndicators</nt>. 
          The ambiguity is resolved as follows: these operators are
          tightly bound to the <nt def="SequenceType">SequenceType</nt> expression, and have higher
          precedence than other uses of these symbols. Any occurrence of <code>"+"</code>, 
          <code>"?"</code> or <code>"*"</code>, that follows a sequence type is assumed to be an occurrence indicator, which binds to
          the last <nt def="ItemType">ItemType</nt> in the <nt def="SequenceType"
          >SequenceType</nt>.</p>

        <p>Thus, <code role="parse-test">4 treat as item() + - 5</code> must be interpreted as <code
            role="parse-test">(4 treat as item()+) - 5</code>, taking the '+' as an
          occurrence indicator and the '-' as a subtraction operator. To force the interpretation of
          "+" as an addition operator (and the corresponding interpretation of the "-" as a unary
          minus), parentheses may be used: the form <code role="parse-test">(4 treat as item()) +
            -5</code> surrounds the <nt def="SequenceType">SequenceType</nt> expression with
          parentheses and leads to the desired interpretation.</p>

        <p>
          <code>function () as xs:string *</code> is interpreted as <code>function () as (xs:string
            *)</code>, not as <code>(function () as xs:string) *</code>. Parentheses can be used as
          shown to force the latter interpretation.</p>

        <p>This rule has as a consequence that certain forms which would otherwise be syntactically
          valid and unambiguous are not recognized: in <code>4 treat as item() + 5</code>, the <code>"+"</code> is taken as
          an <nt def="OccurrenceIndicator">OccurrenceIndicator</nt>, and not as an operator, which
          means this is not a syntactically valid expression.</p>
      </constraintnote>
      
      <!--<constraintnote id="constructor-op-brace" type="xgc">
        
        <head>constructor-op-brace</head>
        
        <p>In XQuery, there are two ways that the expression <code>element otherwise {}</code> could be parsed:
        it could be treated as a computed element constructor creating an element named <code>otherwise</code>
        with empty content, or it could be treated as an attempt to select a child node named <code>element</code>,
        returning an empty map if no such node exists.</p>
        
        <p>This ambiguity has been introduced in 4.0 as a consequence of allowing map constructors to be
        written without the leading <code>map</code> keyword. The ambiguity is therefore resolved to retain
        the XQuery 3.1 interpretation, constructing an element named <code>otherwise</code>.</p>
        
        <p>More generally, if an expression starts with the three tokens (<var>K</var> <var>N</var> "{"), 
          where <var>K</var> is one of <code>element</code>, <code>attribute</code>, 
          <code>processing-instruction</code>, or <code>namespace</code>, and <var>N</var> is an
          <code>NCName</code> that could be interpreted as a binary operator (for example <code>div</code> or
          <code>otherwise</code>) then the expression is parsed as a node construction expression,
          creating a node of kind <var>K</var> whose name is <var>N</var>.</p>
        
        <p>This ambiguity does not arise in XPath, which does not recognize computed node constructor
        expressions. However, in the interests of compatibility between XPath and XQuery, and to retain
        the option of adding computed node constructors to XPath in the future, XPath processors
        <code>should</code> reject such expressions as invalid.</p>
        
      </constraintnote>-->
      
    </div3>
    <div3 id="notes-on-parsing">
      <head>Grammar Notes</head>
      <p>This section contains general notes on the EBNF productions, which may be helpful in
        understanding how to interpret and implement the EBNF. These notes are not normative. The
        notes below are referenced from the right side of the production, with the notation:
          <emph>/* gn: &lt;id&gt; */</emph>.</p>
      <note>
        <glist>
          <gitem id="parse-note-parens">
            <label>grammar-note: parens</label>
            <def>
              <p>Lookahead is required to distinguish a <nt def="FunctionCall">FunctionCall</nt> from
                an EQName or keyword followed by a <phrase role="xquery">
                  <nt def="Pragma">Pragma</nt> or </phrase>
                <nt def="Comment">Comment</nt>. For example: <code role="parse-test">address (: this
                  may be empty :)</code> may be mistaken for a call to a function named "address"
                unless this lookahead is employed. Another example is <code role="parse-test">for (:
                  whom the bell :) $tolls in 3 return $tolls</code>, where the keyword "for" must
                not be mistaken for a function name.</p>
            </def>
          </gitem>
          <gitem id="parse-note-comments">
            <label>grammar-note: comments</label>
            <def>
              <p>Comments are allowed everywhere that <termref def="IgnorableWhitespace">ignorable
                  whitespace</termref> is allowed, and the <nt def="Comment">Comment</nt> symbol
                does not explicitly appear on the right-hand side of the grammar (except in its own
                production). See <specref ref="DefaultWhitespaceHandling"/>. <phrase role="xquery"
                  >Note that comments are not allowed in direct constructor content, though they are
                  allowed in nested <nt def="EnclosedExpr"> EnclosedExprs</nt>.</phrase></p>
              <p>A comment can contain nested comments, as long as all <code>"(:"</code> and <code>":)"</code> patterns are
                balanced, no matter where they occur within the outer comment.</p>
              <note>
                <p>Lexical analysis may typically handle nested comments by incrementing a counter
                  for each <code>"(:"</code> pattern, and decrementing the counter for each <code>":)"</code> pattern. The
                  comment does not terminate until the counter is back to zero.</p>
              </note>
              <p>Some illustrative examples:</p>
              <ulist>
                <item>
                  <p>
                    <code>(: commenting out a (: comment :) may be confusing, but often helpful
                      :)</code> is a syntactically valid <nt def="Comment">Comment</nt>, since balanced nesting of comments
                    is allowed.</p>
                </item>
                <item>
                  <p>
                    <code role="parse-test">"this is just a string :)"</code> is a syntactically
                    valid expression. However, <code>(: "this is just a string :)" :)</code> will
                    cause a syntax error. Likewise, <code role="parse-test">"this is another string
                      (:"</code> is a syntactically valid expression, but <code>(: "this is another
                      string (:" :)</code> will cause a syntax error. It is a limitation of nested
                    comments that literal content can cause unbalanced nesting of comments.</p>
                </item>
                <item>
                  <p>
                    <code role="parse-test">for (: set up loop :) $i in $x return $i</code> is
                    syntactically valid, ignoring the comment.</p>
                </item>
                <item>
                  <p>
                    <code role="parse-test">5 instance (: strange place for a comment :) of
                      xs:integer</code> is also syntactically valid.</p>
                </item>
                <item role="xquery">
                  <p>
                    <code>
                      <![CDATA[<eg (: an example:)>{$i//title}</eg>]]>
                    </code> is not syntactically valid.</p>
                </item>
                <item role="xquery">
                  <p>
                    <code role="parse-test">
                      <![CDATA[<eg> (: an example:) </eg>]]>
                    </code> is syntactically valid, but the characters that look like a comment are
                    in fact literal element content.</p>
                </item>
              </ulist>
            </def>
          </gitem>
        </glist>
      </note>
    </div3>
  </div2>
  <div2 id="productions-derived-from-XML">
    <head>Productions Derived from XML</head>
    <p>Some productions are defined by reference to the XML and XML Names specifications (e.g.
      <bibref ref="XML"/> and <bibref ref="XMLNAMES"/>, or <bibref ref="XML1.1"/> and <bibref
        ref="XMLNAMES11"/>. <phrase role="xpath">A host language may choose</phrase><phrase
          role="xquery">It is implementation-defined</phrase> which version of these specifications is
      used; it is recommended that the latest applicable version be used (even if it is published
      later than this specification).</p>
    
    <p role="xpath">A <term>host language</term> may choose whether the lexical rules of <bibref
      ref="XML"/> and <bibref ref="XMLNAMES"/> are followed, or alternatively, the lexical rules
      of <bibref ref="XML1.1"/> and <bibref ref="XMLNAMES11"/> are followed.</p>
    
    <p role="xquery">It is <termref def="dt-implementation-defined">
      implementation-defined</termref> whether the lexical rules of <bibref ref="XML"/> and
      <bibref ref="XMLNAMES"/> are followed, or alternatively, the lexical rules of <bibref
        ref="XML1.1"/> and <bibref ref="XMLNAMES11"/> are followed. Implementations that support the
      full <bibref ref="XML1.1"/> character set <termref def="should">SHOULD</termref>, for purposes
      of interoperability, provide a mode that follows only the <bibref ref="XML"/> and <bibref
        ref="XMLNAMES"/> lexical rules.</p>
    
  </div2>
  <div2 id="lexical-structure">
    <head>Lexical structure</head>
    
    <changes>
      <change issue="327" PR="519" date="2023-05-30">
        The rules for tokenization have been largely rewritten. In some cases the revised specification may
        affect edge cases that were handled in different ways by different 3.1 processors, which could lead
        to incompatible behavior.
      </change>
    </changes>
    
    
    
    <p diff="add" at="2023-05-22">This section describes how an &language; text is tokenized prior to parsing.</p>
    
    <p>All keywords are case sensitive. Keywords are not reserved&#8212;that is, any <termref
      def="dt-qname">lexical QName</termref> may duplicate a keyword except as noted in <specref
        ref="id-reserved-fn-names"/>.</p>
    
    <p diff="add" at="2023-05-22">Tokenizing an input string is a process that follows the following rules:</p>
    
    <ulist diff="add" at="2023-05-22">
      <item><p><termdef id="dt-ordinary-production-rule" term="ordinary production rule">An <term>ordinary production rule</term> 
        is a production rule in <specref ref="id-grammar"/> that is not annotated <code>ws:explicit</code>.</termdef></p></item>
      <item><p><termdef id="dt-literal-terminal" term="literal terminal">A <term>literal terminal</term> is a token appearing as a string 
        in quotation marks on the right-hand side of an <termref def="dt-ordinary-production-rule"/>.</termdef>
      </p>
        <note><p>Strings that appear in other production rules do not qualify.
        <phrase role="xquery">For example, <code>"]]&gt;"</code> is not a literal terminal, because it appears only in the rule
        <nt def="CDataSection">CDataSection</nt>, which is not an ordinary production rule; similarly <nt def="BracedURILiteral">BracedURILiteral</nt>
          does not qualify because it appears only in <nt def="URIQualifiedName">URIQualifiedName</nt>, and <code>"0x"</code> does not qualify
        because it appears only in <nt def="HexIntegerLiteral">HexIntegerLiteral</nt>.</phrase>
          <phrase role="xpath">For example, <nt def="BracedURILiteral">BracedURILiteral</nt>
            does not quality because it appears only in <nt def="URIQualifiedName">URIQualifiedName</nt>, and <code>"0x"</code> does not qualify
            because it appears only in <nt def="HexIntegerLiteral">HexIntegerLiteral</nt>.</phrase></p></note>
      
        <p>
          The <termref def="dt-literal-terminal">literal terminals</termref>  in &language; are: <phrase role="literal-terminals">[This section to
              be filled in by assemble-spec.xsl]</phrase>
        </p>
      
      </item>
      <item><p><termdef id="dt-variable-terminal" term="variable terminal">A <term>variable terminal</term> is an instance
        of a production rule that is not itself an <termref def="dt-ordinary-production-rule"/> but that is named (directly) on the right-hand
        side of an <termref def="dt-ordinary-production-rule"/>.</termdef></p>
        <p>
          The <termref def="dt-variable-terminal">variable terminals</termref> in &language; are: <phrase role="variable-terminals">[This section to
            be filled in by assemble-spec.xsl]</phrase>
        </p>
      </item>
      <item><p><termdef id="dt-complex-terminal" term="complex terminal">A <term>complex terminal</term> is
        a <termref def="dt-variable-terminal"/> whose production rule references, directly or indirectly, an 
        <termref def="dt-ordinary-production-rule"/>.</termdef></p>
        <p>
          The <termref def="dt-complex-terminal">complex terminals</termref>  in &language; are: <phrase role="complex-terminals">[This section to
            be filled in by assemble-spec.xsl]</phrase>
        </p>
      <note><p>The significance of complex terminals is that at one level, a complex terminal is treated as a single
      token, but internally it may contain arbitrary expressions that must be parsed using the full EBNF grammar.</p></note>
      </item>
      <item><p>Tokenization is the process of splitting the supplied input string into a sequence of terminals, where each
      terminal is either a <termref def="dt-literal-terminal"/> or a <termref def="dt-variable-terminal"/> (which may itself
      be a <termref def="dt-complex-terminal"/>). Tokenization is done by repeating the following steps:</p>
      <olist>
        <item><p>Starting at the current position, skip any whitespace and comments.</p></item>
        <item><p>If the current position is not the end of the input, then
          return the longest <termref def="dt-literal-terminal"/> or <termref def="dt-variable-terminal"/> 
        that can be matched starting at the current position, regardless whether this terminal is valid at this point
        in the grammar. If no such terminal can be identified starting at the current position, or if the terminal that
        is identified is not a valid continuation of the grammar rules, then a syntax error is reported.</p>
        <note><p>Here are some examples showing the effect of the longest token rule:</p>
          <ulist>
            <item><p>The expression <code>map{a:b}</code> is a syntax error. Although there is a 
              tokenization of this string that satisfies the grammar (by treating <code>a</code> and <code>b</code>
              as separate expressions), this tokenization does not satisfy the longest token rule,
              which requires that <code>a:b</code> is interpreted as a single <code>QName</code>.</p></item>
            
            <item><p>The expression <code>10 div3</code> is a syntax error. The longest token rule requires that this
              be interpreted as two tokens (<code>"10"</code> and <code>"div3"</code>) even though it would
              be a valid expression if treated as three tokens (<code>"10"</code>, <code>"div"</code>, and <code>"3"</code>).</p></item>
            
            <item><p>The expression <code>$x-$y</code> is a syntax error. This is interpreted as four tokens,
              (<code>"$"</code>, <code>"x-"</code>, <code>"$"</code>, and <code>"y"</code>).</p></item>
          </ulist>
        </note>
        <note><p>The lexical production rules for <termref def="dt-variable-terminal">variable terminals</termref>
        have been designed so that there is minimal need for backtracking. For example, if the next terminal
        starts with <code>"0x"</code>, then it can only be either a <nt def="HexIntegerLiteral">HexIntegerLiteral</nt> or an error;
        if it starts with <code>"`"</code> (and not with <code>"```"</code>) then it can only be a
          <nt def="StringTemplate">StringTemplate</nt> or an error. <phrase role="xquery">Direct element constructors
          in XQuery, however, need special treatment, described below.</phrase></p>
        <p>This convention, together with the rules for whitespace separation of tokens (see <specref ref="id-terminal-delimitation"/>) 
          means that the longest-token rule does not normally result in any need for backtracking. For example, suppose 
          that a <termref def="dt-variable-terminal"/> has been identified as a <nt def="StringTemplate">StringTemplate</nt> by examining
          its first few characters. If the construct turns out not to be a valid <nt def="StringTemplate">StringTemplate</nt>, 
          an error can be reported without first considering whether there is some shorter token that might be returned instead.</p>
        </note></item>
      </olist>
      </item>
      <item role="xquery"><p>Tokenization requires special care when the current character is
      <char>U+003C</char>:</p>
        <ulist>
          <item><p>If the following character is <char>U+003D</char> then the token can be identified
          unambiguously as the operator <code>&lt;=</code>.</p></item>
          <item><p>If the following character is <char>U+003C</char> then the token can be identified
          unambiguously as the operator <code>&lt;&lt;</code>.</p></item>
          <item><p>If the following character is <char>U+0021</char> then the token can be identified
          unambiguously as being a <nt def="DirCommentConstructor">DirCommentConstructor</nt> (a
            <nt def="CDataSection">CDataSection</nt>, which also starts with <code>&lt;!</code> can appear
            only within a direct element constructor, not as a free-standing token).</p></item>
          <item><p>If the following character is <char>U+003F</char>, then the token is identified
          as a <nt def="DirPIConstructor">DirPIConstructor</nt> if and only if a match for the
          relevant production (<code>"&lt;?" PITarget (S DirPIContents)? "?>"</code>) is found. If there
          is no such match, then the string <code>"&lt;?"</code> is identified as a less-than operator
            followed by a lookup operator.</p></item>
          <item><p>If the following character is a <xnt href="http://www.w3.org/TR/REC-xml/#NameStartChar">NameStartChar</xnt>
          then the token is identified as a <nt def="DirElemConstructor">DirElemConstructor</nt> if and only
          if a match for the leading part of a <nt def="DirElemConstructor">DirElemConstructor</nt> is
          found: specifically if a substring starting at the <char>U+003C</char> character matches one of
          the following regular expressions:</p>
            <slist>
              <sitem><code><![CDATA[^<\i\c*\s*>]]></code> (as in <code>&lt;element>...</code>)</sitem>
              <sitem><code><![CDATA[^<\i\c*\s*/>]]></code>(as in <code>&lt;element/></code>)</sitem>
              <sitem><code><![CDATA[^<\i\c*\s+\i\c*\s*=]]></code>(as in <code>&lt;element att=...</code>)</sitem>
            </slist>
            <p>If the content matches one of these regular expressions but further analysis shows that the subsequent
            content does not satisfy the <nt def="DirElemConstructor">DirElemConstructor</nt> production,
            then a static error is reported.</p>
            <p>If the content does not match any of these regular expressions then the token is identified
              as the less-than operator <code>&lt;</code>.</p>
          </item>
          <item><p>If the following character is any other character then the token can be identified
          unambiguously as the less-than operator <code>&lt;</code>.</p></item>
        </ulist>
        <p>This analysis is done without regard to the syntactic context of the <char>U+003C</char> character.
        However, a tokenizer <rfc2119>may</rfc2119> avoid looking for a <nt def="DirPIConstructor">DirPIConstructor</nt>
        or <nt def="DirElemConstructor">DirElemConstructor</nt> if it knows that such a constructor cannot appear
        in the current syntactic context.</p>
        <note><p>The rules here are described much more precisely than in XQuery 3.1, and the results
        in edge cases might be incompatible with some XQuery 3.1 processors.</p></note>
        <note><p>To avoid potential confusion, simply add whitespace after any less-than operator.</p></note>
      </item>
      <item><p>Tokenization unambiguously identifies the boundaries of the terminals in the input, and this
        can be achieved without backtracking or lookahead. However, tokenization does
      not unambiguously classify each terminal. For example, it might identify the string <code>"div"</code> as a terminal, but it does not
      resolve whether this is the operator symbol <code>div</code>, or an <code>NCName</code> 
        or <code>QName</code> used as a 
      node test or as a variable or function name. Classification of terminals generally requires information about the
      grammatical context, and in some cases requires lookahead.</p>
      <note><p>Operationally, classification of terminals may be done either in the tokenizer or the parser, or
      in some combination of the two. For example, according to the EBNF, the expression 
        <code>"parent::x"</code> is made up of three
      tokens, <code>"parent"</code>, <code>"::"</code>, and <code>"x"</code>. The name <code>"parent"</code>
        can be classified as an axis name as soon as the following token <code>"::"</code> is recognized, and this
      might be done either in the tokenizer or in the parser. (Note that whitespace and comments are allowed
      both before and after <code>"::"</code>.)</p></note></item>
      <item><p>In the case of a <termref def="dt-complex-terminal"/>, identifying the end of the complex terminal
      typically involves invoking the parser to process any embedded expressions. Tokenization, as described
      here, is therefore a recursive process. But other implementations are possible.</p></item>
    </ulist>
    
    <note><p>Previous versions of this specification included the statement: 
      <emph>When tokenizing, the longest possible match that is consistent with the EBNF is used.</emph> </p>
    
      <p>Different processors are known to have interpreted this in different ways. One interpretation,
      for example, was that the expression <code>10 div-3</code> should be split into four tokens (<code>10</code>,
      <code>div</code>, <code>-</code>, <code>3</code>) on the grounds that any other tokenization would give a
      result that was inconsistent with the EBNF grammar. Other processors report a syntax error on this example.</p>
      
      <p>This rule has therefore been rewritten in version 4.0. Tokenization is now entirely insensitive to the
      grammatical context; <code>div-3</code> is recognized as a single token even though this results in a syntax
      error. For some implementations this may mean that expressions that were accepted in earlier releases
      are no longer accepted in 4.0.</p>
      
      <p role="xquery">A more subtle example is: <code><![CDATA[(. <?b ) cast as xs:integer?> 0)]]></code>
      in which <code><![CDATA[<?b ) cast as xs:integer?>]]></code> is recognized as a single token (a direct
      processing instruction constructor) even though such a token cannot validly appear in this
      grammatical context.</p>
    </note>
    

    <div3 id="terminal-symbols">
      <head>Terminal Symbols</head>
      <scrap headstyle="show">
        <head/>
        <prodrecap id="DefinedLexemes" ref="DefinedLexemes"/>
      </scrap>
      <p>The following symbols are used only in the definition of terminal symbols; they are not
        terminal symbols in the grammar of <specref ref="id-grammar"/>.</p>
      <scrap headstyle="show">
        <head/>
        <prodrecap id="LocalTerminalSymbols" ref="LocalTerminalSymbols"/>
      </scrap>
    </div3>
    <div3 id="id-terminal-delimitation">
      <head>Terminal Delimitation</head>
      <p>&language; expressions consist of <loc href="#terminal-symbols">terminal symbols</loc> and
          <termref def="symbolseparators">symbol separators</termref>.</p>
      <p><phrase diff="add" at="2023-05-22"><termref def="dt-literal-terminal">Literal</termref> 
        and <termref def="dt-variable-terminal">variable</termref> </phrase>
        terminal symbols are of two kinds: delimiting and non-delimiting.</p>
      <!-- The next paragraph is "filled in" by various stylesheets used to generate the "assembled" source files. -->
      <p>
        <termdef id="delimiting-token" term="delimiting terminal symbol">The <term>delimiting
            terminal symbols</term> are: <phrase role="defined-tokens-delimiting">[This section to
            be filled in by assemble-spec.xsl]</phrase></termdef>
      </p>
      <!-- The next paragraph is "filled in" by various stylesheets used to generate the "assembled" source files. -->
      <p>
        <termdef id="non-delimiting-token" term="non-delimiting terminal symbol">The
            <term>non-delimiting terminal symbols</term> are: <phrase
            role="defined-tokens-nondelimiting">[This section to be filled in by
            assemble-spec.xsl]</phrase></termdef>
      </p>
      <p>
        <termdef id="symbolseparators" term="symbol separators">
          <termref def="Whitespace">Whitespace</termref> and <nt def="Comment">Comments</nt>
          function as <term>symbol separators</term>. For the most part, they are not mentioned in
          the grammar, and may occur between any two terminal symbols mentioned in the grammar,
          except where that is forbidden by the <loc href="#ws-explicit">/* ws: explicit */</loc>
          annotation in the EBNF, or by the <loc href="#parse-note-xml-version">/* xgc: xml-version
            */</loc> annotation.</termdef>
      </p>
      
      <p>
        <phrase diff="add" at="2023-05-22">As a consequence of the longest token rule (see <specref ref="lexical-structure"/>), </phrase>
        one or more <termref def="symbolseparators">symbol separators</termref>
        are required between two consecutive terminal symbols
        <var>T</var> and <var>U</var> (where <var>T</var> precedes <var>U</var>) when any of the following is true:
      </p>
      <ulist>
        <item><p><var>T</var> and <var>U</var> are both <termref def="non-delimiting-token">non-delimiting terminal symbols</termref>.</p></item>
        <item><p><var>T</var> is a QName or an NCName and <var>U</var> is <code>"."</code> or <code>"-"</code>.</p></item>
        <item><p><var>T</var> is a numeric literal and <var>U</var> is <code>"."</code>, or vice versa.</p></item>
      </ulist>
    </div3>
    <div3 id="id-lt-and-gt-characters" diff="add" at="2023-05-02">
      <head>Less-Than and Greater-Than Characters</head>
      
      <p>The operator symbols <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, 
        <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>=&gt;</code>, <code>-&gt;</code>, <code>=!&gt;</code>, and <code>=?&gt;</code>
        have alternative representations using the characters <char>U+FF1C</char> and
        <char>U+FF1E</char> in place of <char>U+003C</char> 
        and <char>U+003E</char>. The alternative tokens are respectively
        <code>&#xff1c;</code>, <code>&#xff1c;=</code>, <code>&#xff1e;</code>, <code>&#xff1e;=</code>, 
        <code>&#xff1c;&#xff1c;</code>, <code>&#xff1e;&#xff1e;</code>, <code>=&#xff1e;</code>, <code>-&#xff1e;</code>, 
        <code>=!&#xff1e;</code>, and <code>=?&#xff1e;</code>.
        In order to avoid visual confusion these alternatives are not shown explicitly in the grammar.</p>
      
      <p>This option is provided to improve the readability of XPath expressions embedded in XML-based host languages such as XSLT; it
      enables these operators to be depicted using characters that do not require escaping as XML entities or character references.</p>
      
      <p role="xquery">This rule does not apply to the <code>&lt;</code> and <code>&gt;</code> symbols used to delimit node constructor
        expressions, which (because they mimic XML syntax) must use <char>U+003C</char> and <char>U+003E</char> respectively.</p>
    </div3>
    <div3 id="id-eol-handling">
      <head>End-of-Line Handling</head>

      <p role="xpath">The host language must specify whether the &language; processor normalizes all
        line breaks on input, before parsing, and if it does so, whether it uses the rules of
          <bibref ref="XML"/> or <bibref ref="XML1.1"/>. </p>
      
      <note role="xpath" diff="add" at="2023-05-22"><p>XML-based host languages such as XSLT and XSD
      do not normalize line breaks at the XPath level, because it will already have been done by the host XML parser. 
      Use of character or entity references suppresses normalization of line breaks, so
      the string literal <code>&amp;#x0D;</code> written within an XSLT-hosted XPath expression
      represents a string containing a single <char>U+000D</char> character.</p></note>

      <p role="xquery">Prior to parsing, the &language; processor must normalize all line breaks.
        The rules for line breaking follow the rules of <bibref ref="XML"/> or <bibref ref="XML1.1"
        />. It is implementation-defined which version is used.</p>

      <div4 id="id-xml10-eol-handling">
        <head>XML 1.0 End-of-Line Handling</head>
        <p>For <bibref ref="XML"/> processing, all of the following must be translated to a single
          <char>U+000A</char>:</p>
        <olist>
          <item>
            <p>the two-character sequence <char>U+000D</char>, <char>U+000A</char>;</p>
          </item>
          <item>
            <p>any <char>U+000D</char> character that is not immediately followed by <char>U+000A</char>.</p>
          </item>
        </olist>
      </div4>
      <div4 id="id-xml11-eol-handling">
        <head>XML 1.1 End-of-Line Handling</head>
        <p>For <bibref ref="XML1.1"/> processing, all of the following must be translated to a
          single <char>U+000A</char> character:</p>
        <olist>
          <item>
            <p>the two-character sequence <char>U+000D</char>, <char>U+000A</char>;</p>
          </item>
          <item>
            <p>the two-character sequence <char>U+000D</char>, <char>U+0085</char>;</p>
          </item>
          <item>
            <p>the single character <char>U+0085</char>;</p>
          </item>
          <item>
            <p>the single character <char>U+2028</char>;</p>
          </item>
          <item>
            <p>any <char>U+000D</char> character that is not immediately followed by <char>U+000A</char> or <char>U+0085</char>.</p>
          </item>
        </olist>
        <p role="xquery">The characters <char>U+0085</char> and <char>U+2028</char> cannot be reliably recognized and translated
          until the <nt def="VersionDecl">VersionDecl</nt> declaration (if present) has been
          read.</p>
      </div4>
    </div3>
    <div3 id="whitespace-rules">
      <head>Whitespace Rules</head>
      <div4 id="DefaultWhitespaceHandling">
        <head>Default Whitespace Handling</head>
        <p>
          <termdef id="Whitespace" term="whitespace">A <term>whitespace</term> character is any of
            the characters defined by <xnt href="http://www.w3.org/TR/REC-xml/#NT-S">
              [http://www.w3.org/TR/REC-xml/#NT-S]</xnt>.</termdef>
        </p>
        <p>
          <termdef term="ignorable whitespace" id="IgnorableWhitespace">
            <term>Ignorable whitespace</term> consists of any <termref def="Whitespace"
              >whitespace</termref> characters that may occur between <termref def="terminal"
              >terminals</termref>, unless these characters occur in the context of a production
            marked with a <loc href="#ExplicitWhitespaceHandling"> ws:explicit</loc> annotation, in
            which case they can occur only where explicitly specified (see <specref
              ref="ExplicitWhitespaceHandling"/>).</termdef> Ignorable whitespace characters are not
          significant to the semantics of an expression. Whitespace is allowed before the first
          terminal and after the last terminal <phrase role="xquery">of a module</phrase><phrase
            role="xpath">of an XPath expression</phrase>. Whitespace is allowed between any two <termref
            def="terminal">terminals</termref>. <nt def="Comment">Comments</nt> may also act as
          "whitespace" to prevent two adjacent terminals from being recognized as one. Some
          illustrative examples are as follows:</p>
        <ulist>
          <item>
            <p>
              <code>foo- foo</code> results in a syntax error. "foo-" would be recognized as a
              QName.</p>
          </item>
          <item>
            <p>
              <code role="parse-test">foo -foo</code> is syntactically equivalent to <code
                role="parse-test">foo - foo</code>, two QNames separated by a subtraction
              operator.</p>
          </item>
          <item>
            <p>
              <code role="parse-test">foo(: This is a comment :)- foo</code> is syntactically
              equivalent to <code>foo - foo</code>. This is because the comment prevents the two
              adjacent terminals from being recognized as one.</p>
          </item>
          <item>
            <p>
              <code role="parse-test">foo-foo</code> is syntactically equivalent to single QName.
              This is because "-" is a valid character in a QName. When used as an operator after
              the characters of a name, the "-" must be separated from the name, e.g. by using
              whitespace or parentheses.</p>
          </item>
          <item>
            <p>
              <code>10div 3</code> results in a syntax error.</p>
          </item>
          <item>
            <p>
              <code>10 div3</code> also results in a syntax error.</p>
          </item>
          <item>
            <p>
              <code>10div3</code> also results in a syntax error.</p>
          </item>
        </ulist>
      </div4>
      <div4 id="ExplicitWhitespaceHandling">
        <head>Explicit Whitespace Handling</head>
        <p>Explicit whitespace notation is specified with the EBNF productions, when it is different
          from the default rules, using the notation shown below. This notation is not inherited. In
          other words, if an EBNF rule is marked as /* ws: explicit */, the notation does not
          automatically apply to all the 'child' EBNF productions of that rule.</p>
        <glist>
          <gitem id="ws-explicit">
            <label>ws: explicit</label>
            <def>
              <p>/* ws: explicit */ means that the EBNF notation explicitly notates, with
                  <code>S</code> or otherwise, where <termref def="Whitespace">whitespace
                  characters</termref> are allowed. In productions with the /* ws: explicit */
                  annotation, <specref ref="DefaultWhitespaceHandling"/> does not apply.
		  Comments are not allowed in these productions except where the <nt def="Comment">Comment</nt> non-terminal appears.
	      </p>
            </def>
          </gitem>
        </glist>
        <p role="xquery" id="ws-explicit-lex-states">For example, whitespace is not freely allowed
          by the direct constructor productions, but is specified explicitly in the grammar, in
          order to be more consistent with XML.</p>
      </div4>
    </div3>
  </div2>
  <div2 id="id-reserved-fn-names">
    <head>Reserved Function Names</head>
    
    <changes>
      <change issue="1208" PR="1212" date="2024-05-15">
          &language-tech; 3.0 included <code>empty-sequence</code> and <code>item</code>
            as reserved function names, and &language-tech; 3.1 added <code>map</code> and <code>array</code>.
            This was unnecessary since these names never appear followed by a left parenthesis
            at the start of an expression. They have therefore been removed from the list.
            New keywords introducing item types, such as <code>record</code> and <code>enum</code>,
            have not been included in the list.
      </change>
    </changes>
    <p>The following names are not allowed as function names in an unprefixed form, because they
    can appear, followed by a left parenthesis, at the start of an XPath or XQuery expression that
    is not a function call.</p>
    
    <p>Names used in <nt def="KindTest">KindTests</nt>:</p>
      
      <slist>
        <sitem>attribute</sitem>
        <sitem>comment</sitem>
        <sitem>document-node</sitem>
        <sitem>element</sitem>
        <sitem>namespace-node</sitem>
        <sitem>node</sitem>
        <sitem>schema-attribute</sitem>
        <sitem>schema-element</sitem>
        <sitem>processing-instruction</sitem>
        <sitem>text</sitem>       
      </slist>
    
    <p>Names used as syntactic keywords:</p>
    
    <slist>
      <sitem>fn</sitem>
      <sitem>function</sitem>
      <sitem>if</sitem>
      <sitem>switch</sitem>
      <sitem>typeswitch</sitem>
    </slist>
      
 
    <note role="xpath">
      <p> Although the keywords <code>switch</code> and <code>typeswitch</code> are not used in
        XPath, they are considered reserved function names for compatibility with XQuery. </p>
    </note>
    
    
    
    <note>
      <p>As the language evolves in the future, it may become necessary to reserve additional
      names. Furthermore, use of common programming terms like <code>return</code> and
      <code>while</code> as function names may cause confusion even though they are not reserved. 
        The easiest way to avoid problems is to use an explicit namespace prefix in all calls 
        to user-defined functions.</p>
    </note>
  </div2>
  <div2 id="id-precedence-order">
    <head>Precedence Order (Non-Normative)</head>
    <p>The grammar in <specref ref="id-grammar"/> normatively defines built-in precedence among the
      operators of <phrase role="xquery">XQuery</phrase><phrase role="xpath">XPath</phrase>. These operators are summarized here to make clear the order of their
      precedence from lowest to highest. The associativity column indicates the order in which
      operators of equal precedence in an expression are applied.</p>
    <table role="medium">
      <tbody>
        <tr>
          <th>#</th>
          <th>Operator</th>
          <th>Associativity</th>
        </tr>
        <tr>
          <td>1</td>
          <td>
            <nt def="Expr">, (comma)</nt>
          </td>
          <td>either</td>
        </tr>
        <tr>
          <td>2</td>
          <td>
            <phrase role="xpath"><nt def="ForExpr">for</nt>,</phrase>
            <phrase role="xpath"><nt def="LetExpr">let</nt>,</phrase>
            <phrase role="xquery"><nt def="FLWORExpr">FLWOR</nt>,</phrase>
            <nt def="QuantifiedExpr">some, every</nt>, <phrase role="xquery"><nt def="SwitchExpr"
                >switch</nt>,</phrase>
            <phrase role="xquery"><nt def="TypeswitchExpr">typeswitch</nt>,</phrase>
            <phrase role="xquery"><nt def="TryCatchExpr">try</nt>,</phrase>
            <nt def="IfExpr">if</nt>
          </td>
          <td>NA</td>
        </tr>
        <tr>
          <td>3</td>
          <td>
            <nt def="OrExpr">or</nt>
          </td>
          <td>either</td>
        </tr>
        <tr>
          <td>4</td>
          <td>
            <nt def="AndExpr">and</nt>
          </td>
          <td>either</td>
        </tr>
        <tr>
          <td>5</td>
          <td>
            <nt def="ValueComp">eq, ne, lt, le, gt, ge</nt>, <nt def="GeneralComp">=, !=, &lt;,
              &lt;=, &gt;, &gt;=</nt>, <nt def="NodeComp">is, &lt;&lt;, &gt;&gt;</nt>
          </td>
          <td>NA</td>
        </tr>
        <tr>
          <td>6</td>
          <td>
            <nt def="OtherwiseExpr">otherwise</nt>
          </td>
          <td>either</td>
        </tr>
        <tr>
          <td>7</td>
          <td>
            <nt def="StringConcatExpr">||</nt>
          </td>
          <td>left-to-right</td>
        </tr>
        <tr>
          <td>8</td>
          <td>
            <nt def="RangeExpr">to</nt>
          </td>
          <td>NA</td>
        </tr>
        <tr>
          <td>9</td>
          <td>
            <nt def="AdditiveExpr">+, - (binary)</nt>
          </td>
          <td>left-to-right</td>
        </tr>
        <tr>
          <td>10</td>
          <td>
            <nt def="MultiplicativeExpr">*, div, idiv, mod</nt>
          </td>
          <td>left-to-right</td>
        </tr>
        <tr>
          <td>11</td>
          <td>
            <nt def="UnionExpr">union, |</nt>
          </td>
          <td>either</td>
        </tr>
        <tr>
          <td>12</td>
          <td>
            <nt def="IntersectExceptExpr">intersect, except</nt>
          </td>
          <td>left-to-right</td>
        </tr>
        <tr>
          <td>13</td>
          <td>
            <nt def="InstanceofExpr">instance of</nt>
          </td>
          <td>NA</td>
        </tr>
        <tr>
          <td>14</td>
          <td>
            <nt def="TreatExpr">treat as</nt>
          </td>
          <td>NA</td>
        </tr>
        <tr>
          <td>15</td>
          <td>
            <nt def="CastableExpr">castable as</nt>
          </td>
          <td>NA</td>
        </tr>
        <tr>
          <td>16</td>
          <td>
            <nt def="CastExpr">cast as</nt>
          </td>
          <td>NA</td>
        </tr>
        <tr>
          <td>17</td>
          <td>
            <nt def="ArrowExpr">=>, =!>, =?></nt>
          </td>
          <td>left-to-right</td>
        </tr>
        <tr>
          <td>18</td>
          <td>
            <nt def="UnaryExpr">-, + (unary)</nt>
          </td>
          <td>right-to-left</td>
        </tr>
        <tr>
          <td>19</td>
          <td>
            <nt def="SimpleMapExpr">!</nt>
          </td>
          <td>left-to-right</td>
        </tr>
        <tr>
          <td>20</td>
          <td>
            <nt def="PathExpr">/, //</nt>
          </td>
          <td>left-to-right</td>
        </tr>
        <tr>
          <td>21</td>
          <td>
            <nt def="Predicate">[ ]</nt>, <nt def="Lookup">?, ??</nt>
          </td>
          <td>left-to-right</td>
        </tr>
        <tr>
          <td>22</td>
          <td>
            <nt def="UnaryLookup">? (unary)</nt>
          </td>
          <td>NA</td>
        </tr>
      </tbody>
    </table>

    <p> In the "Associativity" column, "either" indicates that all the operators at that level have
      the associative property (i.e., <code>(A op B) op C</code> is equivalent to <code>A op (B op
        C)</code>), so their associativity is inconsequential. "NA" (not applicable) indicates that
      the EBNF does not allow an expression that directly contains multiple operators from that
      precedence level, so the question of their associativity does not arise. </p>

    <note>
      <p>Parentheses can be used to override the operator precedence in the usual way. Square
        brackets in an expression such as A[B] serve two roles: they act as an operator causing B to
        be evaluated once for each item in the value of A, and they act as parentheses enclosing the
        expression B.</p>
      <p role="xquery">Curly braces in an expression such as validate { E } or ordered { E } perform a
        similar bracketing role to the parentheses in a function call, but with the difference in
        most cases that E is an Expr rather than ExprSingle, meaning that it can use the comma
        operator.</p>
    </note>
  </div2>
</div1>
