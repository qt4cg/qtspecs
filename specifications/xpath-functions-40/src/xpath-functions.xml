<?xml version="1.0" encoding='utf-8'?>
<!-- Changes for maps and JSON labeled at="MAP" and commented out -->
<!-- Current changes labeled at="A": first 4.0 Working Draft -->

<!DOCTYPE spec SYSTEM "../../../schema/xsl-query.dtd" [ 

<!-- Things to update in these ENTITY definitions before publishing this document:
* Relationships between doc.stage, w3c-doctype, and doc.w3c-doctype-full
* doc.stage  w3c-doctype  doc.w3c-doctype-full
* FPWD       wd           First Public Working Draft
  WD         wd           Working Draft
  WD         wd           Last Call Working Draft
  CR         cr           Candidate Recommendation
  PR         pr           Proposed Recommendation
  PER        per          Proposed Edited Recommendation
  REC        rec          Recommendation
  WGNOTE     note         Working Group Note
* date.day, date.DD, date.month, date.monthnum, and date.year must represent the date of publication of the document
* doc.w3c-prevdesignation must properly represent the stage and shortname of the immediately preceding publication of the document
* Various status section generation ENTITY definitions below must be properly updated
-->

<!ENTITY doc.version "4.0">
<!ENTITY doc.major-version "4">
<!ENTITY doc.version-code "40">
<!ENTITY doc.stage "REC">
<!ENTITY doc.w3c-doctype "rec">
<!ENTITY doc.w3c-doctype-full "Editor's Draft">

<!-- N.B. The date 2000-01-01 is magic, it means "today". -->
<!ENTITY date.day "01">
<!ENTITY date.DD "01">
<!ENTITY date.month "January"> 
<!ENTITY date.monthnum "01">
<!ENTITY date.year "2000">
<!ENTITY doc.date "&date.year;&date.monthnum;&date.DD;">

<!ENTITY w3c.tr "https://www.w3.org/TR">
<!ENTITY doc.generic-shortname "xpath-functions">
<!ENTITY doc.shortname "&doc.generic-shortname;-&doc.version-code;">
<!ENTITY doc.w3c-designation "&doc.stage;-&doc.shortname;">
<!ENTITY doc.w3c-prev-designation "REC-&doc.shortname;">

<!ENTITY doc.publoc "https://qt4cg.org/specifications/&doc.shortname;/">
<!ENTITY doc.publoc "&w3c.tr;/&date.year;/&doc.w3c-designation;-&doc.date;/">

<!ENTITY doc.latestloc "&doc.publoc;">
<!ENTITY doc.latestloc "&w3c.tr;/&doc.shortname;/">

<!ENTITY doc.latestloc-major "&w3c.tr;/&doc.generic-shortname;-&doc.major-version;/">
<!ENTITY doc.latestloc-tech "&w3c.tr;/&doc.generic-shortname;/">
<!ENTITY doc.nsname "&doc.shortname;">
<!ENTITY doc.generic-language "XPath and XQuery Functions and Operators">
<!ENTITY language-tech "&doc.generic-language;">
<!ENTITY language "&doc.generic-language; &doc.version;">
<!ENTITY language-major "&doc.generic-language; &doc.major-version;">
<!-- ************************ THIS MUST BE EITHER 'WG Review Draft' OR '' **************** -->
<!ENTITY version "">
<!-- ************************************************************************************* -->

<!ENTITY xdt-schema-app SYSTEM "../../xpath-datamodel-31/src/xdt-schema-app.xml">
<!ENTITY codepoint.collation "http://www.w3.org/2005/xpath-functions/collation/codepoint">

<!ENTITY currency "&#x00A4;">
<!ENTITY divide "&#x00F7;">
<!ENTITY times "&#x00D7;">
<!ENTITY ne "&#x2260;">
<!ENTITY eacute "&#x00E9;">
<!ENTITY ocircumflex "&#x00F4;">
<!ENTITY Aumlaut "&#x00C4;">
<!ENTITY aumlaut "&#x00E4;">
<!ENTITY uumlaut "&#x00FC;">
<!ENTITY eszet "&#x00DF;">

<!ENTITY pi "&#x3C0;">
<!ENTITY theta "&#x3B8;">

<!ENTITY t1 "&#x0905;">
<!ENTITY t2 "&#x0936;">
<!ENTITY t3 "&#x094A;">
<!ENTITY t4 "&#x0915;">

<!ENTITY e1 "&#x00E8;">
<!ENTITY e2 "&#x00E9;">

<!ENTITY le "&#x2264;">
<!ENTITY ge "&#x2265;">

<!ENTITY egrave "&#x00E8;">
<!ENTITY Egrave "&#x00C8;">

<!ENTITY % status-entities SYSTEM "../../../etc/status-entities.dtd">
%status-entities;

<!ENTITY doc.WD-pubdate "24 April 2014">
<!ENTITY doc.LC-pubdate "7 October 2014">
<!ENTITY doc.LC-comments-due "7 November 2014">
<!ENTITY doc.CR-pubdate "13 December 2016">
<!ENTITY doc.CR-comments-due "10 January 2017">
<!ENTITY doc.PR-expected "10 January 2017">
<!ENTITY doc.PR-pubdate "17 January 2017">
<!ENTITY doc.PR-comments-due "28 February 2017">
<!ENTITY doc.REC-pubdate "21 March 2017">

<!ENTITY doc.pubdate "&doc.REC-pubdate;">
<!ENTITY doc.comments-due "&doc.PR-comments-due;">


<!ENTITY status-section-id "status">
<!ENTITY spec-devby    "&devby.joint1;">
<!ENTITY changelog-id  "changelog">
<!ENTITY changes-para  "&post.PR.changes;">
<!ENTITY implementation-report '&no-implementation-report-exists;'>
<!ENTITY implementation-report-location "https://dev.w3.org/2011/QT3-test-suite/ReportingResults31/">
<!ENTITY implementation-report-availability "&report-public;">
<!ENTITY test-suite-location "https://dev.w3.org/2011/QT3-test-suite/">
<!ENTITY Bugzilla-key "FO40">
<!ENTITY patent-policy-paragraph "&ppp-two;">
<!ENTITY documents-and-relationships "&set-of-documents-30-preREC;">
<!ENTITY advancement.statement "&advance.2WGs;">
<!ENTITY document-stage "&doc-stage-REC;">
<!ENTITY doc-stability "&doc-stability-REC;">

<!ENTITY PR-entrance-criteria '<p>This document will be
considered ready for transition to Proposed Recommendation
at the same time that the XQuery 3.1 specification is ready
for transition to Proposed Recommendation. </p>'>
<!ENTITY features-at-risk-para "&no-features-at-risk;">
<!ENTITY features-at-risk ''>

<!ENTITY customized-paragraph '<p>This &doc.w3c-doctype-full; specifies XSLT and XQuery Functions and Operators (F&amp;O)
                              version 4.0, a fully compatible extension of <loc href="https://www.w3.org/TR/xpath-functions-31/">F&amp;O version 3.1</loc>.
                              This publication differs from its version 3.1 primarily by the addition of a number of new functions. There are numerous
                              smaller differences as well, all documented in the change log. </p>'>

<!ENTITY status-section SYSTEM "../../../etc/status-general.xml">
<!ENTITY common-item-types.xml SYSTEM "../../image-sources/item-types.xml">
<!ENTITY common-anyType.xml SYSTEM "../../image-sources/anyType.xml">
<!ENTITY common-anyAtomicType.xml SYSTEM "../../image-sources/anyAtomicType.xml">
<!ENTITY common-numeric-types.xml SYSTEM "../../image-sources/numeric-types.xml">
<!ENTITY common-string-types.xml SYSTEM "../../image-sources/string-types.xml">
]>

<!--
<head><?xml-stylesheet type="text/xsl" href="E:\XMLdocs\XML Query Language (XQuery)\Functions and Operators\Current Functions and Operators Build Files\xquery-operators.xsl"?></head> -->
<spec id="spec-top" w3c-doctype="&doc.w3c-doctype;" status="ext-review">
    <header>
        <title>&language;</title>
        <version>&version;</version>
        <w3c-designation>&doc.w3c-designation;</w3c-designation>
        <w3c-doctype>W3C &doc.w3c-doctype-full;</w3c-doctype>
        <pubdate>
            <day>&date.day;</day>
            <month>&date.month;</month>
            <year>&date.year;</year>
        </pubdate>
        <publoc>
            <loc href="&doc.publoc;">&doc.publoc;</loc>
        </publoc>
<!-- These altlocs URIs are computed from the concatenation of doc.public, doc.shortname, and either '.xml' or
     '-diff-from-yyyymmdd.html', where 'yyyymmdd' is the earlier version of the spec from which a diff has been produced -->
  <altlocs>
    <loc href="&doc.shortname;.xml">Specification in XML format</loc>
    <loc href="function-catalog.xml">XML function catalog</loc>
  </altlocs>

<!-- The latestloc URI is computed from doc.latestloc -->
        <latestloc doc="&language;">
            <loc href="&doc.latestloc;">&doc.latestloc;</loc>
        </latestloc>

<!-- These prevlocs URIs are always hard-coded and are never computed from entities -->
<!--
        <prevlocs doc="&language;">
           <loc href="https://www.w3.org/TR/xpath-functions-31/"/>
        </prevlocs>
  <latestloc-major doc="&language-major;">
    <loc href="&doc.latestloc-major;">&doc.latestloc-major;</loc>
  </latestloc-major>
  <latestloc-tech doc="&language-tech;">
    <loc href="&doc.latestloc-tech;">&doc.latestloc-tech;</loc>
  </latestloc-tech>
-->
  <prevrec doc="&language-tech;">
    <loc href="https://www.w3.org/TR/2017/REC-xpath-functions-31-20170321/">https://www.w3.org/TR/2017/REC-xpath-functions-31-20170321/</loc>
  </prevrec>
        <authlist>
          <author role="4.0">
            <name>Michael Kay</name>
            <affiliation>Saxonica</affiliation>
            <email href="http://www.saxonica.com/">http://www.saxonica.com/</email>
          </author>
        </authlist>

  <errataloc href="https://www.w3.org/XML/2017/qt-errata/xpath-functions-31-errata.html"/>

        <translationloc
          href="https://www.w3.org/2003/03/Translations/byTechnology?technology=xpath-functions-40"/> 

        <abstract>
           <p>This document defines constructor functions, operators, and functions on the datatypes defined in
                    <bibref ref="xmlschema-2"/> and the datatypes defined in <bibref ref="xpath-datamodel-31"/>.  It also defines
                functions and operators on nodes and node sequences as defined in the <bibref
                ref="xpath-datamodel-31"/>.  These functions and operators are defined for use in <bibref ref="xpath-40"/> and <bibref ref="xquery-40"/> and
                    <bibref ref="xslt-40"/> and other related XML standards.  The signatures and summaries of functions defined in this document are available at:
<loc href="http://www.w3.org/2005/xpath-functions/">http://www.w3.org/2005/xpath-functions/</loc>.</p>
           

           <p>A summary of changes since version 3.1 is provided at <specref ref="changelog"/>.</p>
</abstract>

<!--&status-section;-->
       <status>
          <p>This version of the specification is work in progress. It is produced by the QT4 Working Group, officially
             the W3C XSLT 4.0 Extensions Community Group. Individual functions specified in the document may be at
             different stages of review, reflected in their <term>History</term> notes. Comments are invited,
             in the form of GitHub issues at <loc href="https://github.com/qt4cg/qtspecs">https://github.com/qt4cg/qtspecs</loc>.</p>

<note role="dedication" id="dedication">
<p>The publications of this community group 
<loc href="../xquery-40/xpath-40.html#dedication">are dedicated</loc> to our co-chair,
Michael Sperberg-McQueen (1954–2024).</p>
</note>
       </status>

        <langusage>
            <language id="EN">English</language>
        </langusage>
        <revisiondesc>
           <p></p>
        </revisiondesc>
    </header>
   <body>
      <div1 id="intro">
         <head>Introduction</head>
         
         <changes>
            <change>Use the arrows to browse significant changes since the 3.1 version of this specification.</change>
            <change>Sections with significant changes are marked Δ in the table of contents.
            New functions introduced in this version are marked ➕ in the table of contents.</change>
          </changes>
          
                
         <p>The purpose of this document is to define functions and operators for inclusion in
                XPath 4.0, XQuery 4.0, and XSLT 4.0. 
                The exact syntax used to call these
                functions and operators is specified in <bibref ref="xpath-40"/>, <bibref ref="xquery-40"/> and 
            <bibref ref="xslt-40"/>. </p>
         <p>This document defines three classes of functions:</p>
         <ulist>
            <item><p>General purpose functions, available for direct use in user-written queries, stylesheets, and XPath expressions,
               whose arguments and results are values defined by the <bibref ref="xpath-datamodel-31"/>.</p></item>
            <item><p>Constructor functions, used for creating instances of a datatype from values of (in general) a different
            datatype. These functions are also available for general use; they are named after the datatype that they return,
            and they always take a single argument.</p></item>
            <item><p>Functions that specify the semantics of operators defined in <bibref ref="xpath-40"/> and <bibref ref="xquery-40"/>.
            These exist for specification purposes only, and are not intended for direct calling from user-written code.</p></item>
         </ulist>
         
         <p>
                <bibref ref="xmlschema-2"/> defines a number of primitive and derived datatypes,
                collectively known as built-in datatypes. This document defines functions and
                operations on these datatypes as well as the other types 
                (for example, nodes and sequences of nodes) defined in <xspecref spec="DM31" ref="types"/> of 
            the <bibref ref="xpath-datamodel-31"/>.
                These functions and operations are available for use in <bibref ref="xpath-40"/>,
                    <bibref ref="xquery-40"/> and any other host language that chooses to reference them.
                In particular, they may be referenced in future versions of XSLT and related XML standards. </p>
         
         <p><bibref ref="xmlschema11-2"/> adds to the datatypes defined
            in <bibref ref="xmlschema-2"/>. It introduces a new derived type <code>xs:dateTimeStamp</code>, and it
         incorporates as built-in types the two types <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code>
         which were previously XDM additions to the type system. In addition, XSD 1.1 clarifies and updates many
         aspects of the definitions of the existing datatypes: for example, it extends the value space of
         <code>xs:double</code> to allow both positive and negative zero, and extends the lexical space to allow <code>+INF</code>;
            it modifies the value space of <code>xs:Name</code>
         to permit additional Unicode characters; it allows year zero and disallows leap seconds in <code>xs:dateTime</code>
         values; and it allows any character string to appear as the value of an <code>xs:anyURI</code> item.
         Implementations of this specification <rfc2119>may</rfc2119> support either XSD 1.0 or XSD 1.1 or both.</p>
         
         <p>In some cases, this specification references XSD for the semantics of operations such as the effect of matching
         using regular expressions, or conversion of atomic items to strings. In most such cases there is no intended
         technical difference between the XSD 1.0 and XSD 1.1 specifications, but the 1.1 version often provides clearer
         explanations and sometimes also corrects technical errors. In such cases this specification
         often chooses to reference the XSD 1.1 specification. This should not be taken as implying that it is necessary
         to invoke an XSD 1.1 processor.</p>
         
         <p>References to specific sections of some of the above documents are indicated by
                cross-document links in this document. Each such link consists of a pointer to a
                specific section followed a superscript specifying the linked document. The
                superscripts have the following meanings: XQ <bibref ref="xquery-40"/>, XT <bibref ref="xslt-40"/>,
            XP <bibref ref="xpath-40"/>, and DM <bibref ref="xpath-datamodel-40"/>.</p>
         
         <div2 id="operators" diff="add" at="2022-12-20">
            <head>Operators</head>
            <p>Despite its title, this document does not attempt to define the semantics of all the operators available
               in the <bibref ref="xpath-40"/> language; indeed, in the interests of avoiding duplication, the majority of
               operators (including all higher-order operators such as <code>x/y</code>, <code>x!y</code>, and <code>x[y]</code>,
               as well simple operators such as <code>x,y</code>, <code>x and y</code>, <code>x or y</code>,            
            <code>x&lt;&lt;y</code>, <code>x>>y</code>, <code>x is y</code>, <code>x||y</code>, <code>x|y</code>,
            <code>x union y</code>, <code>x except y</code>, <code>x intersect y</code>, <code>x to y</code>
            and <code>x otherwise y</code>) are now defined entirely within <bibref ref="xpath-40"/>.</p>
            
            <p>The remaining operators that are described in this publication are those where the semantics of the operator
            depend on the types of the arguments. For these operators, the language specification describes rules for selecting
            an internal function defined in this specification to underpin the operator. For example, when the operator <code>x+y</code>
            is applied to two operands of type <code>xs:double</code>, the function <code>op:numeric-add</code> is selected.</p>
            
            <p>XPath defines a range of comparison operators <code>x=y</code>, <code>x!=y</code>, <code>x&lt;y</code>, 
               <code>x>y</code>, <code>x&lt;=y</code>, <code>x>=y</code>, <code>x eq y</code>, <code>x ne y</code>, <code>x lt y</code>, 
               <code>x gt y</code>, <code>x le y</code>, <code>x ge y</code>, which apply to a variety of operand types including
            for example numeric values, strings, dates and times, and durations. For each relevant data type, two functions
            are defined in this specification, for example <code>op:date-equal</code> and <code>op:date-less-than</code>.
            These define the semantics of the <code>eq</code> and <code>lt</code> operators applied to operands of that data type. The operators
               <code>x ne y</code>, <code>x gt y</code>, <code>x le y</code>, and <code>x ge y</code> are defined by reference to
               these two; and the <term>general comparison</term> operators <code>=</code>, <code>!=</code>, <code>&lt;</code>, 
               <code>></code>, <code>&lt;=</code>, and <code>>=</code> are defined by reference to 
               <code>eq</code>, <code>ne</code>, <code>lt</code>, 
               <code>gt</code>, <code>le</code>, and <code>ge</code> respectively.</p>
            
            <note><p>Previous versions of this specification also defined a third comparison function of the form
            <code role="example">op:date-greater-than</code>. This has been dropped, as it is always the inverse of the <code>-less-than</code>
            form.</p></note>
         </div2>
         
         <div2 id="conformance">
            <head>Conformance</head>
            <changes>
               <change issue="205" PR="326" date="2023-02-01">Higher-order functions are no longer an optional feature.</change>
            </changes>
            <p>
               This recommendation contains a set of function specifications. 
               It defines conformance at the level of individual functions. An implementation of a function conforms to a function specification 
               in this recommendation if all the following conditions are satisfied:</p>
            
            <ulist>
               <item><p>For all combinations of valid inputs to the function (both explicit arguments and implicit context dependencies), 
                  the result of the function meets the mandatory requirements of this specification.
               </p></item>
               <item><p>For all invalid inputs to the function, the implementation raises (in some way appropriate to the calling environment) a dynamic error.
               </p></item>
               <item><p>For a sequence of calls within the same <termref def="execution-scope">execution scope</termref>, the requirements of this recommendation 
                  regarding the <termref def="dt-deterministic">determinism</termref> of results are satisfied (see <specref ref="properties-of-functions"/>).
               </p></item>
            </ulist>

               <p>Other recommendations (“host languages”) that reference this document may dictate:</p>
            
            <ulist>
               <item><p>Subsets or supersets of this set of functions to be available in particular environments;</p></item>
               <item><p>Mechanisms for invoking functions, supplying arguments, initializing the static and dynamic context, receiving results, and handling errors;
               </p></item>
               <item><p>A concrete realization of concepts such as <termref def="execution-scope">execution scope</termref>;</p></item>
               <item><p>Which versions of other specifications referenced herein (for example, XML, XSD, or Unicode) are to be used.</p></item>
            </ulist>
               
            <p>Any behavior that is discretionary (implementation-defined or implementation-dependent) in this specification may be constrained by a host language.</p>
               
            <note><p>Adding such constraints in a host language, however, is discouraged because it makes it difficult to reuse implementations of 
               the function library across host languages.</p></note>
               
               
 
            <p>This specification allows flexibility in the choice of versions of specifications on which it depends:</p>
            <ulist>
               <item>
                  <p>It is <termref def="implementation-defined"/> which version of Unicode is supported, 
                     but it is recommended that the most recent version of Unicode be used.  </p>
               </item>
               <item>
                  <p>It is <termref def="implementation-defined"/> whether the type system is based
                     on XML Schema 1.0 or XML Schema 1.1.  </p>
               </item>
               <item>
                  <p>It is <termref def="implementation-defined"/> whether definitions that rely on
                     XML (for example, the set of valid XML characters) should use the definitions in XML 1.0 or XML 1.1.</p>
               </item>
            </ulist>
            <note>
               <p>The XML Schema 1.1 recommendation
                  introduces one new concrete datatype: <code>xs:dateTimeStamp</code>; it also incorporates
                  the types <code>xs:dayTimeDuration</code>, <code>xs:yearMonthDuration</code>,
                  and <code>xs:anyAtomicType</code> which were previously defined in earlier versions of <bibref ref="xpath-datamodel-31"/>.
                  Furthermore, XSD 1.1
                  includes the option of supporting revised definitions of types such as <code>xs:NCName</code>
                  based on the rules in XML 1.1 rather than 1.0.</p>
            </note>

            <p diff="add" at="2023-06-12">The <bibref ref="xpath-datamodel-40"/> allows flexibility in the
            repertoire of characters permitted during processing that goes beyond even what
            version of XML is supported. A processor
            <rfc2119>may</rfc2119> allow the user to construct nodes
            and atomic items that contain characters not allowed by any version of
            XML.
            <termdef id="dt-permitted-character" term="permitted character">A <term>permitted character</term>
            is one within the repertoire accepted by the implementation.</termdef></p>

            <p>In this document, text labeled as an example or as a note is
            provided for explanatory purposes and is not normative.</p>
         </div2>
         <div2 id="namespace-prefixes">
            <head>Namespaces and prefixes</head>
            <p>The functions and operators defined in this document are contained in one of
                    several namespaces (see <bibref ref="xml-names"/>) and referenced using an
                    <code>xs:QName</code>.</p>
            <p>This document uses conventional prefixes to refer to these namespaces. User-written
               applications can choose a different prefix to refer to the namespace, so long as it is
               bound to the correct URI. The host language may also define a default namespace for
               function calls, in which case function names in that namespace need not be prefixed
               at all. In many cases the default namespace will be 
               <code>http://www.w3.org/2005/xpath-functions</code>, allowing a call on the <function>fn:name</function>
               function (for example) to be written as <code>name()</code> rather than <code>fn:name()</code>; 
               in this document, however, all example function calls are explicitly prefixed.</p>
            
 
            <p>The URIs of the namespaces and the conventional prefixes associated with them are:</p>
            <ulist>
               <item>
                  <p><code>http://www.w3.org/2001/XMLSchema</code> for constructors &#x2014;
                            associated with <code>xs</code>.
                  </p>
                  <p>The section <specref ref="constructor-functions"/> defines 
                     constructor functions for the built-in datatypes defined
                     in <bibref ref="xmlschema-2"/> and in <xspecref spec="DM31" ref="types"/>
                     of <bibref ref="xpath-datamodel-31"/>. These datatypes and the corresponding constructor functions  
                     are in the XML Schema namespace, <code>http://www.w3.org/2001/XMLSchema</code>,
                     and are named in this document using the <code>xs</code> prefix. </p>
               </item>
               <item>
                  <p><code>http://www.w3.org/2005/xpath-functions</code>
                     for functions &#x2014; associated with <code>fn</code>. </p>
                  <p>The namespace
                     prefix used in this document for most functions that are available to users is
                     <code>fn</code>.</p>
               </item>
               <item>
                  <p><code>http://www.w3.org/2005/xpath-functions/math</code>
                     for functions &#x2014; associated with <code>math</code>. </p>
                  <p>This namespace is used for some mathematical functions. The namespace
                     prefix used in this document for these functions is <code>math</code>.
                     These functions are available to users in exactly the same way as those in the
                     <code>fn</code> namespace.</p>
               </item>
               <item>
                  <p><code>http://www.w3.org/2005/xpath-functions/map</code>
                     for functions &#x2014; associated with <code>map</code>. </p>
                  <p>This namespace is used for some functions that manipulate maps (see
                     <specref ref="map-functions"/>). The namespace
                     prefix used in this document for these functions is <code>map</code>.
                     These functions are available to users in exactly the same way as those in the
                     <code>fn</code> namespace.</p>
               </item>
               <item>
                  <p><code>http://www.w3.org/2005/xpath-functions/array</code>
                     for functions &#x2014; associated with <code>array</code>. </p>
                  <p>This namespace is used for some functions that manipulate maps (see
                     <specref ref="array-functions"/>). The namespace
                     prefix used in this document for these functions is <code>array</code>.
                     These functions are available to users in exactly the same way as those in the
                     <code>fn</code> namespace.</p>
               </item>                 
               <item>
                  <p><code>http://www.w3.org/2005/xqt-errors</code> &#x2014; associated with
                            <code>err</code>. </p>
                  <p>There are no functions in this namespace; it is used for error codes.</p>
                  <p>This document uses the prefix <code>err</code> to represent the namespace URI 
                     <code>http://www.w3.org/2005/xqt-errors</code>, which is the namespace for all XPath 
                     and XQuery error codes and messages. This namespace prefix is not predeclared and 
                     its use in this document is not normative.</p>
                  
               </item>
               <item>
                  <p><code>http://www.w3.org/2010/xslt-xquery-serialization</code> &#x2014; associated with
                     <code>output</code>. </p>
                  <p>There are no functions in this namespace: it is
                     used for serialization parameters, as described in <bibref ref="xslt-xquery-serialization-31"/></p>
               </item>
               <item>
                  <p>
                     Functions defined with the <code>op</code> prefix are described here to
                     underpin the definitions of the operators in <bibref ref="xpath-40"/>, <bibref ref="xquery-40"/> 
                     and <bibref ref="xslt-40"/>. These functions are not available
                     directly to users, and there is no requirement that implementations should
                     actually provide these functions. For this reason, no namespace is associated
                     with the <code>op</code> prefix. For example, multiplication is generally
                     associated with the <code>*</code> operator, but it is described as a function
                     in this document:</p>
                  <example role="signature">
                     <proto role="example" name="numeric-multiply" return-type="xs:numeric" isOp="yes" prefix="op">
                        <arg name="arg1" type="xs:numeric"/>
                        <arg name="arg2" type="xs:numeric"/>
                     </proto>
                  </example>
                  
                  <p diff="add" at="2022-12-20">Sometimes there is a need to use an operator as a function.
                  To meet this requirement, the function <function>fn:op</function> takes any simple binary operator as its argument,
                  and returns a corresponding function. So for example <code>fn:for-each-pair($seq1, $seq2, op("+"))</code>
                  performs a pairwise addition of the values in two input sequences.</p>
                  
               </item>
            </ulist>
            
            <note>
               <p>The above namespace URIs are not expected to change from one version of this 
                  document to another. The contents of these namespaces may be extended to allow 
                  additional functions (and errors, and serialization parameters) to be defined.</p>
            </note>
            
                   
         </div2>
         <div2 id="func-overloading">
            <head>Function overloading</head>
            <p>A function is uniquely defined by its name and arity (number of arguments); it is therefore
            not possible to have two different functions that have the same name and arity, but different
            types in their signature. That is, function overloading in this sense of the term is not permitted.
            Consequently, functions such as <function>fn:string</function> which accept arguments of many different
            types have a signature that defines a very general argument type, in this case <code>item()?</code>
            which accepts any single item; supplying an inappropriate item (such as a function item) causes
            a dynamic error.</p>
			
            <p>Some functions on numeric types include the type <code>xs:numeric</code> in their signature
               as an argument or result type. In this version of the specification, <code>xs:numeric</code>
               has been redefined as a built-in union type representing the union of 
               <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code> (and thus automatically
               accepting types derived from these, including <code>xs:integer</code>).</p>
            
            <p>Operators such as <code>+</code> may be overloaded: they map to different underlying functions depending
            on the dynamic types of the supplied operands.</p>
            
            <p>It is possible for two functions to have the same name provided they have different arity (number of arguments).
               For the functions defined in this specification, where two functions have the same name and different arity,
               they also have closely related behavior, so they are defined in the same section of this document.</p>
            
              
         </div2>
         <div2 id="func-signatures">
            <head>Function signatures and descriptions</head>
            <p>Each function (or group of functions having the same name) is defined in this specification using
            a standard proforma. This has the following sections:</p>
            
            <div3 id="id-function-signatures-name">
               <head>Function name</head>
           
               <p>The function name is a <code>QName</code> as defined in <bibref ref="xmlschema-2"/>
                  and must adhere to its syntactic conventions. Following the precedent set by <bibref ref="xpath"/>,
                  function names are generally composed of English words separated by hyphens: 
                  specifically <char>U+002D</char>. Abbreviations are
                  used only where there is a strong precedent in other programming languages (as with <code>math:sin</code> and 
                  <code>math:cos</code> for sine and cosine). If a
                  function name contains a <bibref ref="xmlschema-2"/> datatype name, it may have
                  intercapitalized spelling and is used in the function name as such. An example is <function>fn:timezone-from-dateTime</function>.</p>
            </div3>
            <div3 id="id-function-signatures-summary">
               <head>Function summary</head>
            
                <p>The first section in the proforma is a short summary of what the function does. This is intended
                to be informative rather than normative.</p>
            </div3>
            <div3 id="id-function-signatures-signature">
               <head>Function signature</head>
            
               <p>Each function is then defined by specifying its signature(s), which define the
                  types of the parameters and of the result value.</p>
               <p diff="add" at="2022-11-29">Where functions take a variable number of arguments, two conventions are used:</p>
               <ulist diff="add" at="2022-11-29">
                  <item><p>Wherever possible, a single function signature is used giving default values
                  for those parameters that can be omitted.</p></item>
                  <item><p>If this is not possible, because the effect of omitting a parameter cannot
                  be specified by giving a default value, multiple signatures are given for the function.</p></item>
               </ulist>
               <p>Each function signature is presented in a form like this:</p>
               <example role="signature">
                  <proto role="example" name="function-name" return-type="return-type">
                     <arg name="parameter-name" type="parameter-type"/>
                     <arg name="..." type=""/>
                  </proto>
               </example>
               <p>In this notation, <term>function-name</term>, in bold-face, is the 
                  <phrase diff="add" at="2023-01-17">local</phrase> name of the
                       function whose signature is being specified. <phrase>The prefix <term>fn</term>
                       indicates that the function is in the namespace <code>http://www.w3.org/2005/xpath-functions</code>:
                          this is one of the conventional prefixes listed in <specref ref="namespace-prefixes"/>.</phrase>
                       If the function takes no
                       parameters, then the name is followed by an empty parameter list:
                       <code>()</code>; otherwise, the name is followed by a parenthesized list of
                       parameter declarations. Each parameter declaration includes:</p>
               <ulist diff="add" at="2022-11-29">
                  <item><p>The name of the parameter (which in 4.0 is significant because it can be used
                  as a keyword in a function call)</p></item>
                  <item><p>The static type of the parameter (in italics)</p></item>
                  <!--<item><p>If this is the last parameter of a <termref def="dt-variadic"/> function,
                     an ellipsis (<code>...</code>)</p></item>-->
                  <item><p>If the parameter is optional, then an expression giving the default value 
                     (preceded by the symbol <code>:=</code>).</p>
                        <p diff="add" at="2023-12-04">The default value expression is evaluated using the static and
                        dynamic context of the function caller (or of a named function reference). For example, 
                        if the default value is given as <code>.</code>, then it evaluates to the context value 
                        from the dynamic context of the function caller; if it is given as <code>default-collation</code>,
                        then its value is the default collation from the static context of the function caller;
                        if it is given as <code>deep-equal#2</code>, then the third argument supplied to <code>deep-equal</code>
                        is the default collation from the static context of the caller.</p></item>
               </ulist>
               <p>If there are two or more parameter declarations, they are separated by a comma.</p> 
               <p>The <emph> <code>return-type</code></emph>, also in italics, specifies the static type of the value returned by the
                       function. The dynamic type of the value returned by the function is the same as its static
                       type or derived from the static type. All parameter types and return types are
                       specified using the SequenceType notation defined in <xspecref spec="XP31" ref="id-sequencetype-syntax"/>.</p>
               
               <!--<p>If a function is <termref def="dt-variadic"/>, it has a variable number of arguments
               (zero or more). More strictly, there is an infinite set of functions having the same name
               and different arities.</p>-->
            </div3>
            
            <div3 id="id-function-signatures-rules">
               <head>Function rules</head>
               
            
               <p>The next section in the proforma defines the semantics of the function as a set of rules. 
                  The order in which the rules appear is significant; they are to be applied in the order in which
                  they are written. Error conditions, however, are generally listed in a separate section that follows
               the main rules, and take precedence over non-error rules except where otherwise stated. The principles outlined
               in <xspecref spec="XP31" ref="id-errors-and-opt"/> apply by default: to paraphrase, if the result of the function
               can be determined without evaluating all its arguments, then it is not necessary to evaluate the remaining arguments
               merely in order to determine whether any error conditions apply.</p>
            </div3>
            
            <div3 id="id-function-signatures-formal-specification">
               <head>Formal Equivalents</head>
               
               <p>Some functions supplement the prose rules with a more formal specification that describes the effect
               of the function in terms of an equivalent XPath or XQuery implementation. This is intended to take
               precedence over the prose rules in the event of any conflict; however, both sections are intended
               to be complete and not to rely on each other.</p>
               
               <p>In writing the formal equivalents, a number of guidelines have been followed:</p>
               
               <olist>
                  <item><p>Where the equivalent code calls other functions, these should either be primitives
                  defined in the data model specification (see <bibref ref="xpath-datamodel-31"/>), or
                  functions that themselves have a formal equivalent; and the dependencies should not
                  be circular.</p></item>
                  <item><p>There should be minimal reliance on XPath or XQuery language features.
                  Although no attempt has been made to precisely define a core set of language constructs,
                  the specifications try to avoid relying on features other than function calls
                  and a few basic operators including the comma operator, equality testing, and
                  simple integer arithmetic.</p></item>
                  <item><p>There is no suggestion that the formal equivalent is a practical
                     implementation; in many cases it might have very poor performance.</p></item>
                  <item><p>In some cases the formal equivalent does not attempt to replicate
                     correct behavior in error cases; if so, this is always clearly stated.</p></item>
                  <item><p>The formal equivalent will always produce a conformant result for the
                     function, but in some cases this will not be the only possible conformant result.</p></item>
               </olist>
               
               <ednote><edtext>This worthy intent is not yet fully achieved; for example there are
               formal specifications that invoke fn:atomic-equal.</edtext></ednote>
               
               <p>There is no attempt to write formal equivalents for functions that have complex logic
               (such as <function>fn:format-number</function>) or dependencies (such as <function>fn:doc</function>); the aim
               of the formal equivalents is to define as rigorously as possible a platform of basic
               functionality that can be used as a solid foundation for more complex features.</p>
               
               
               
            </div3>
            
            <div3 id="id-function-signatures-notes">
               <head>Notes</head>
               
               <p>Where the proforma includes a section headed <emph>Notes</emph>, these are non-normative.</p>
               
            </div3>
            
            <div3 id="id-function-signatures-examples">
               <head>Examples</head>
               
               <p>Where the proforma includes a section headed <emph>Examples</emph>, these are non-normative.</p>
               
               <p>Many of the examples are given in structured form, showing example expressions and their expected results.
               These published examples are derived from executable test cases, so they follow a standard format. In general,
               the actual result of the expression is expected to be deep-equal to the presented result, under the
               rules of the <function>fn:deep-equal</function> function with default options. In some cases the result is qualified
               to indicate that the order of items in the result is implementation-dependent, or that numeric results
               are approximate.</p>
               
               <p>For more complex functions, examples may be given using informal narrative prose.</p>
               
            </div3>
               
         </div2>
         <div2 id="id-function-calls">
            <head>Function calls</head>
            
            <p>Rules for evaluating the operands of operators are described in the relevant sections
                    of <bibref ref="xquery-40"/> and <bibref ref="xpath-40"/>. For example, the rules for
                    evaluating the operands of arithmetic operators are described in <xspecref spec="XP31" ref="id-arithmetic"/>. 
               Specifically, rules for parameters of
                    type <code>xs:untypedAtomic</code> and the empty sequence are specified in this section.</p>
            <p>For function calls, the required type of an argument is defined in the function
               signature of each function, and the way in which a supplied value is converted to the
               required type (or rejected if it cannot be converted) is defined by the
               <xtermref spec="XP40" ref="dt-coercion-rules"/>.</p>
               
               
                
            <p>Some functions accept a single value or the empty sequence as an argument and
                    some may return a single value or the empty sequence. This is indicated in the
                    function signature by following the parameter or return type name with a
                    question mark: <code>?</code>, indicating that either a single value or the
                    empty sequence must appear. See below.</p>
            <example role="signature">
               <proto role="example" name="function-name" return-type="return-type"
                      returnEmptyOk="yes">
                  <arg name="parameter-name" type="parameter-type" emptyOk="yes"/>
               </proto>
            </example>
            <p>Note that this function signature is different from a signature in which the
                    parameter is omitted. See, for example, the two signatures
                    for <function>fn:string</function>. In the first signature, the parameter is omitted
                    and the argument defaults to the context value, referred to as <code>.</code>.
                    In the second signature, the argument must be present but may be the empty
                    sequence, written as <code>()</code>.
                </p>
            <p>Some functions accept a sequence of zero or more values as an argument. This is
                    indicated by following the name of the type of the items in the sequence with
                    <code>*</code>. The sequence may contain zero or more items of the named type.
                    For example, the function below accepts a sequence of <code>xs:double</code> and
                    returns a <code>xs:double</code> or the empty sequence.</p>
            <example role="signature">
               <proto role="example" name="median" return-type="xs:double" returnEmptyOk="yes">
                  <arg name="arg" type="xs:double*" emptyOk="no"/>
               </proto>
            </example>
            
            <p diff="add" at="A">In XPath 4.0, the arguments in a function call can be supplied by
            keyword as an alternative to supplying them positionally. For example the call
            <code>resolve-uri(@href, static-base-uri())</code> can now be written 
               <code>resolve-uri(base: static-base-uri(), relative: @href)</code>. The order in which
            arguments are supplied can therefore differ from the order in which they are declared.
            The specification, however, continues to use phrases such as “the second argument” as a 
            convenient shorthand for "the value of the argument that is bound to the second parameter 
            declaration".</p>
         </div2>
         
         <div2 id="options">
            <head>Options</head>
            <changes>
               <change issue="1019" PR="1059" date="2024-03-26">
                  Use of an option keyword that is not defined in the specification and is not known to the
                  implementation now results in a dynamic error; previously it was ignored.
               </change>
            </changes>
            <p>As a matter of convention, a number of functions defined in this document take
            a parameter whose value is a map, defining options controlling the detail of how
            the function is evaluated. Maps are a new datatype introduced in XPath 3.1.</p>
            <p>For example, the function <function>fn:xml-to-json</function> has an options parameter
            allowing specification of whether the output is to be indented. A call might be written:</p>
            <eg><![CDATA[xml-to-json($input, { 'indent': true() })]]></eg>
            <p><termdef id="option-parameter-conventions" term="option parameter conventions">Functions
            that take an options parameter adopt common conventions on how the
            options are used. These are referred to as the <term>option parameter conventions</term>. These
            rules apply only to functions that explicitly refer to them.</termdef></p>
            <p>Where a function adopts the <termref def="option-parameter-conventions"/>, the following rules
            apply:</p>
            <olist>
               <item><p>The value of the relevant argument must be a map. The entries in the map are
                  referred to as options: the key of the entry is called the option name, and the
                  associated value is the option value. Option names defined in this specification
               are always strings (single <code>xs:string</code> values). Option values may
               be of any type.</p></item>
               <item><p>The type of the options parameter in the function signature is always
               given as <code>map(*)</code>.</p></item>
               <item><p>Although option names are described above as strings, the actual key may be
                  any value that is the <termref def="dt-same-key"/> as the required string. 
                  For example, instances of <code>xs:untypedAtomic</code>
                  or <code>xs:anyURI</code> are equally acceptable.</p>
                  <note><p>This means that the implementation of the function can check for the
               presence and value of particular options using the functions <function>map:contains</function>
               and/or <function>map:get</function>.</p></note></item>
               <item><p>Implementations <rfc2119>may</rfc2119> attach an 
                  <termref def="implementation-defined">implementation-defined</termref> meaning to
                  options in the map that are not described in this specification. These options
                  <rfc2119>should</rfc2119> use values of type <code>xs:QName</code> as the option
                  names, using an appropriate namespace.</p></item>
               <item><p>If an option is present whose key is not described in the specification, 
                  then a type error <xerrorref spec="XP" class="TY" code="0004"/> <rfc2119>must</rfc2119> 
                  be raised unless either (a) the key is recognized by the implementation, 
                  or (b) the key is a value of type
                  <code>xs:QName</code> with a non-absent namespace.</p></item>
               
               <item><p>All entries in the options map are optional, and supplying an empty map has the same
               effect as omitting the relevant argument in the function call, assuming this is permitted.</p></item>
               <item><p>The ordering of the options map is immaterial.</p></item>
               <item><p>For each named option, the function
               specification defines a required type for the option value. The value that is actually
               supplied in the map is converted to this required type using the 
                  <xtermref spec="XP40" ref="dt-coercion-rules">coercion rules</xtermref>.
                  This will result in an error (typically 
                     <xerrorref spec="XP" class="TY" code="0004" type="type"/> or
                     <xerrorref spec="FO" class="RG" code="0001" type="type"/>)
                  if conversion of the supplied value to the required type is not possible. 
                  A type error also occurs if this conversion
                  delivers a coerced function whose invocation fails with a type error.
                  A dynamic error occurs if the supplied value 
               after conversion is not one of the permitted values for the option in question: the error codes
               for this error are defined in the specification of each function.</p>
                  
               <note><p>It is the responsibility of each function implementation to invoke this conversion; it
               does not happen automatically as a consequence of the function-calling rules.</p></note></item>

               <item><p>In cases where the value of an option is itself a map, the specification
               of the particular function must indicate whether or not these rules apply recursively 
               to the contents of that map.</p></item>
            </olist>
         </div2>

<!-- Jim: New text to correspond to new graphics, analogous to new material in XDM 3.0, 2009-10-24 -->         
<div2 id="datatypes">
<head>Type System</head>

<p>The diagrams in this section show how nodes, functions,
primitive simple types,
and user defined types fit together into a type system.
This type system comprises two distinct subsystems that both include
the primitive atomic types. 
In the diagrams, connecting lines represent relationships between derived types
and the types from which they are derived;
the former are always below and to the right of the latter.
</p>

<p>The <code>xs:IDREFS</code>, <code>xs:NMTOKENS</code>,
<code>xs:ENTITIES</code> types, and <code>xs:numeric</code> and both the
<code>user-defined list types</code> and
<code>user-defined union types</code>
are special types in that these types are lists or unions
rather than types derived by extension or restriction.</p>
   
   <div3 id="item-type-hierarchy">
      <head>Item Types</head>
   

<p>The first diagram illustrates
the relationship of various item types.</p>
      
      <p>Item types are used to characterize the various types of item that can appear
      in a sequence (nodes, atomic items, and functions), and they are therefore used
      in declaring the types of variables or the argument types and result types of functions.</p>
      
      
<p>In XDM, item types include node types,
function types, and built-in atomic types. 
Item types form a directed graph, rather than a
hierarchy or lattice: in the relationship defined by the
<code>derived-from(A, B)</code> function, some types are derived from
more than one other type. Examples include functions
(<code>function(xs:string) as xs:int</code> is substitutable for
<code>function(xs:NCName) as xs:int</code> and also for
<code>function(xs:string) as xs:decimal</code>), and choice types
(<code>A</code> is substitutable for the choice type <code>(A | B)</code> and also
for <code>(A | C)</code>. Record types provide an alternative way of categorizing
   maps: the instances of <code>record(longitude, latitude)</code> overlap with
   the instances of <code>map(xs:string, xs:double)</code>. The diagram, which shows
only hierarchic relationships, is therefore a simplification of the
full model.</p>

&common-item-types.xml;
      
</div3>
<div3 id="schema-type-hierarchy">
   <head>Schema Type Hierarchy</head>
  

<p>The next diagram illustrate the schema type subsystem, in which
all types are derived from <code>xs:anyType</code>. </p>
      
      <p>Schema types include built-in types defined in the XML Schema specification, and user-defined
      types defined using mechanisms described in the XML Schema specification. Schema types define the
      permitted contents of nodes. The main categories are complex types, which define the permitted content
      of elements, and simple types, which can be used to constrain the values of both elements and attributes.</p>

&common-anyType.xml;

   </div3>
   <div3 id="atomic-type-hierarchy">
      <head>Atomic Type Hierarchy</head>
  

<p id="hier_anyAtomicType">The final diagram shows all of the atomic types, including the primitive simple types and the
built-in types derived from the primitive simple types. 
This includes all the built-in datatypes defined in <bibref ref="xmlschema-2"/>.</p>
      
      <p>Atomic types are both item types and schema types, so the root type <code>xs:anyAtomicType</code> may be found
      in both the previous diagrams.</p>

&common-anyAtomicType.xml;

   </div3>
         </div2>


         <div2 id="terminology">
            <head>Terminology</head>
            
            <changes>
               <change issue="1337" PR="1361" date="2024-08-02">
                  The term <term>atomic value</term> has been replaced by <term>atomic item</term>.
               </change>
            </changes>

            <p>The terminology used to describe the functions and operators on types defined in <bibref ref="xmlschema-2"/> is defined in the body of this specification. The terms defined
            in this section are used in building those definitions.</p>
            <note><p>Following in the tradition of <bibref ref="xmlschema-2"/>, the terms <term>type</term>
            and <term>datatype</term> are used interchangeably.</p></note>
            
            <div3 id="atomic-terminology">
               <head>Atomic items</head>
               
               <p>The following definitions are adopted from <bibref ref="xpath-datamodel-40"/>.</p>
          <ulist>
             <item><p><termdef id="dt-atomic-item" term="atomic item">An
               <term>atomic item</term> is a pair (<var>T</var>, <var>D</var>) where <var>T</var> 
                (the <termref def="dt-type-annotation"/>)
                 is an atomic type, and <var>D</var> (the <termref def="dt-datum"/>)
                 is a point in the value space of <var>T</var>.</termdef></p></item>
             <item><p><termdef id="dt-primitive-type" term="primitive type">A <term>primitive type</term> 
                is one of the 19 <term>primitive atomic</term> types defined in
                <xspecref spec="XS2" ref="built-in-primitive-datatypes"/>
                of <bibref ref="xmlschema-2"/>, or the type <code>xs:untypedAtomic</code>
                defined in <bibref ref="xpath-datamodel-40"/>.</termdef></p></item>
             <item><p><termdef id="dt-datum" term="datum">The <term>datum</term> of an <termref def="dt-atomic-item"/>
               is a point in the value space of its type, which is also a point in the value space of
               the primitive type from which that type is derived.</termdef> There are 20 primitive atomic types (19 defined
               in XSD, plus <code>xs:untypedAtomic</code>), and these have non-overlapping value spaces, so each
               datum belongs to exactly one primitive atomic type.</p></item>
             <item><p diff="chg" at="2022-11-05"><termdef id="dt-type-annotation" term="type annotation">The 
                <term>type annotation</term> of an atomic item
               is the most specific atomic type that it is an instance of 
                (it is also an instance of every type from which that
               type is derived).</termdef></p>  </item>
          </ulist>
               
               
          
    
    
    
    <note diff="chg" at="2022-11-05"><p>The term <term>value space</term> is defined in <bibref ref="xmlschema11-2"/>
      as a set of <emph>values</emph>. The term <term>datum</term> is used here in preference to <emph>value</emph>,
      because <term>value</term> has a different meaning in this data model.</p></note>
          
            </div3>
            <div3 id="character-terminology"><!-- bug 10870 -->
               <head>Strings, characters, and codepoints</head>
               <p>This document uses the terms <code>string</code>, <code>character</code>, and <code>codepoint</code>
               with meanings that are normatively defined in <bibref ref="xpath-datamodel-31"/>, and which are paraphrased here
                  for ease of reference:</p>
               <p><termdef id="character" term="character">A <term>character</term> is an instance of the 
                  <xnt spec="XML" ref="NT-Char">Char</xnt> production of <bibref ref="xml"/>.</termdef></p>
               <note><p>This
               definition excludes Unicode characters in the surrogate blocks as well as <char>U+FFFE</char> and <char>U+FFFF</char>, while
                  including characters with codepoints greater than <char>U+FFFF</char> which some programming languages treat
               as two characters. The valid characters are defined by their codepoints, and include some
               whose codepoints have not been assigned by the Unicode consortium to any character.</p></note>
               <p><termdef id="string" term="string">A <term>string</term> is a sequence of zero or more 
                  <termref def="character">characters</termref>, or equivalently,
               a value in the value space of the <code>xs:string</code> datatype.</termdef></p>
               <p><termdef id="codepoint" term="codepoint">A <term>codepoint</term> is an integer
               assigned to a <termref def="character">character</termref> by the Unicode consortium, 
               or reserved for future assignment to a character.</termdef>
               </p>
               <note><p>The set of codepoints is thus wider than the set of characters.</p>
                  <p>This specification spells “codepoint” as one word; the Unicode specification spells
                     it as “code point”.
                  Equivalent terms found in other specifications are
                  “character number” or “code position”. See <bibref ref="charmod"/></p></note>
               <p>Because these terms appear so frequently, they are hyperlinked to the definition only when there
                  is a particular desire to draw the reader’s attention to the definition; the absence of a hyperlink
                  does not mean that the term is being used in some other sense.</p>
               
               <p>It is <termref def="implementation-defined"/> which version of <bibref ref="Unicode"/> is supported, but it is recommended that the most recent version of Unicode be used.</p>
               
               <p>This specification adopts the Unicode notation <code>U+xxxx</code> to refer to a codepoint
               by its hexadecimal value (always four to six hexadecimal digits). This is followed where appropriate
               by the official Unicode character name and its graphical representation: for example <char>U+20AC</char>.</p>
               
               <p diff="chg" at="2023-01-17">Unless explicitly stated, the functions in this document do not ensure that any 
                  returned <code>xs:string</code> values are normalized in the sense of <bibref ref="charmod"/>.</p>
               <note>
                  <p>In functions that involve character counting such
                     as <function>fn:substring</function>, <function>fn:string-length</function> and
                     <function>fn:translate</function>, what is counted is the number of XML <termref def="character">characters</termref>
                     in the string (or equivalently, the number of Unicode codepoints). Some
                     implementations may represent a codepoint above <char>U+FFFF</char> using two 16-bit
                     values known as a surrogate pair. A surrogate pair counts as one character, not two.</p>
               </note>
            </div3>
            <div3 id="namespace-terminology">
               <head>Namespaces and URIs</head>
               <p>This document uses the phrase “namespace URI” to identify the concept identified
                  in <bibref ref="xml-names"/> as “namespace name”, and the phrase “local name”
                  to identify the concept identified in <bibref ref="xml-names"/> as “local part”.</p>
               <p>It also uses the term <quote>expanded-QName</quote> defined below.</p>
               <p><termdef id="expanded-name" term="expanded-QName"> An <term>expanded-QName</term> 
                  is a value in the value space of the <code>xs:QName</code> datatype as defined in the XDM data model 
                  (see <bibref ref="xpath-datamodel-40"/>): that is, a triple containing namespace prefix (optional), namespace URI (optional), 
                  and local name. Two expanded QNames are equal if the namespace URIs are the same (or both absent) 
                  and the local names are the same. The prefix plays no part in the comparison, but is used only 
                  if the expanded QName needs to be converted back to a string.</termdef></p>
                  
               <p>The term URI is used as follows:</p>
               
               <p><termdef id="dt-uri" term="URI">Within this specification, the term <term>URI</term> refers to Universal Resource Identifiers as
                  defined in <bibref ref="rfc3986"/> and extended in <bibref ref="rfc3987"/> with a new name <term>IRI</term>.  The term <term>URI   
                     Reference</term>, unless otherwise stated, refers to a string in the lexical space of the <code>xs:anyURI</code> datatype 
                  as defined in <bibref ref="xmlschema-2"/>.</termdef></p>
               <note>
                  <p>
                     This means, in practice, that where this 
                     specification requires a “URI Reference”, an IRI as defined in <bibref ref="rfc3987"/> will be 
                     accepted, provided that other relevant specifications also permit an IRI. The term URI has been 
                     retained in preference to IRI to avoid introducing new names for concepts such as “Base URI” that 
                     are defined or referenced across the whole family of XML specifications.  Note also that the 
                     definition of <code>xs:anyURI</code> is a wider definition than the definition in <bibref ref="rfc3987"/>; 
                     for example it does not require non-ASCII characters to be escaped.
                  </p>
               </note>
               
            </div3>
            <div3 id="conformance-terminology">
               <head>Conformance terminology</head>
               
               <p>In this specification:</p>
               
               <ulist>
                  <item><p>The auxiliary verb <rfc2119>must</rfc2119>, when rendered in small capitals, indicates a precondition for conformance.</p>
                  <ulist>
                     <item><p>When the sentence relates to an implementation of a function (for example "All implementations <rfc2119>must</rfc2119> 
                        recognize URIs of the form ...") then an implementation is not conformant unless it behaves as stated.
                     </p></item>
                     <item><p>When the sentence relates to the result of a function (for example "The result <rfc2119>must</rfc2119> have the same type as 
                        <code>$arg</code>") then the implementation is not conformant unless it delivers a result as stated.
                     </p></item>
                     <item><p>When the sentence relates to the arguments to a function (for example "The value of <code>$arg</code> <rfc2119>must</rfc2119> 
                        be a valid regular expression") then the implementation is not conformant unless it enforces the condition by raising a dynamic error 
                        whenever the condition is not satisfied. 
                     </p></item>
                  </ulist>
                  
                  </item>
                  <item><p>The auxiliary verb <rfc2119>may</rfc2119>, when rendered in small capitals, indicates optional or discretionary behavior. 
                     The statement “An implementation <rfc2119>may</rfc2119> do X” implies that it is implementation-dependent whether or not it does X.</p></item>
                  
                  <item><p>The auxiliary verb <rfc2119>should</rfc2119>, when rendered in small capitals, indicates desirable or recommended behavior. 
                     The statement “An implementation <rfc2119>should</rfc2119> do X” implies that it is desirable to do X, but implementations may choose
                     to do otherwise if this is judged appropriate.</p></item>
                  
               </ulist>
               
               <p><termdef id="implementation-defined" term="implementation-defined">Where behavior is described as 
               <term>implementation-defined</term>, variations between processors are permitted, but a 
                  conformant implementation <rfc2119>must</rfc2119> document the choices it has made.</termdef></p>
               
               <p><termdef id="implementation-dependent" term="implementation-dependent">Where behavior is described as 
                  <term>implementation-dependent</term>, variations between processors are permitted, and  
                  conformant implementations are not required to document the choices they have made.</termdef></p>
                            
               
               <note><p>Where this specification states that something is implementation-defined or implementation-dependent, it is
               open to host languages to place further constraints on the behavior.</p></note>
               
               
            </div3>
            <div3 id="properties-of-functions">
               <head>Properties of functions</head>
               
               <p>This section is concerned with the question of whether two calls on a function, with the same arguments, may
               produce different results.</p>
               
               <p diff="add" at="2023-03-12">In this section the term <term>function</term>, unless otherwise specified,
               applies equally to <xtermref spec="XP40" ref="dt-function-definition">function definitions</xtermref>
               (which can be the target of a static function call) and <xtermref spec="DM40" ref="dt-function-item">function items</xtermref>
               (which can be the target of a dynamic function call).</p>
               
               <p><termdef id="execution-scope" term="execution scope">An <term>execution scope</term> is a sequence of
                  calls to the function library during which certain aspects of the state are required to remain invariant.
                  For example, two calls to <function>fn:current-dateTime</function> within the same execution scope will return the same result.
                  The execution scope is defined by the host language that invokes the function library.</termdef>
                  In XSLT, for example, any two function calls executed during
                  the same transformation are in the same execution scope (except that static expressions, such as those used in
                  <code>use-when</code> attributes, are in a separate execution scope).
                  </p>
               
               <p>The following definition explains more precisely what it means for two function calls to return the same result:</p>
               
               <p><termdef id="dt-identical" term="identical" diff="chg" at="2023-05-25">Two values <code>$V1</code> and <code>$V2</code> are
                  defined to be <term>identical</term> if they contain the same number of items and the items are pairwise identical. Two items are identical
                  if and only if one of the following conditions applies:</termdef></p>
                  
              
               
               <olist>
                  <item><p>Both items are atomic items, of precisely the same type, and the values are equal as defined using the <code>eq</code> operator,
                     using the Unicode codepoint collation when comparing strings.</p></item>
                  <item><p>Both items are nodes, and represent the same node.</p></item>
                  <item><p>Both items are maps, both maps have the same number of entries, 
                     and for every entry <var>E1</var> in the first map there is an entry <var>E2</var> in the second map such 
                     that the keys of <var>E1</var> and <var>E2</var> are <termref def="dt-same-key">the same key</termref>, 
                     and the corresponding values <var>V1</var> and <var>V2</var> are <termref def="dt-identical"/>.</p></item>
                  <item><p>Both items are arrays, both arrays have the same number of members, and the members
                     are pairwise <termref def="dt-identical"/>.</p></item>
                  <item><p>Both items are function items, 
                     neither item is a map or array, and the two function items have the same function identity.
                  The concept of function identity is explained in <xspecref spec="DM40" ref="function-items"/>.</p>
                  </item>
               </olist>
  
               
               <p>Some functions produce results that depend not only on their explicit arguments, 
                  but also on the static and dynamic context.</p>
               
               <p><termdef id="dt-context-dependent" term="context-dependent">A 
                  <phrase diff="chg" at="2023-03-12"><xtermref spec="XP40" ref="dt-function-definition">function definition</xtermref></phrase> 
                  may have  the property of being <term>context-dependent</term>: the result of such a
               function depends on the values of properties in the static and dynamic
               evaluation context <phrase diff="add" at="2023-03-12">of the caller</phrase>
                  as well as on the actual supplied arguments (if any). A function definition may
               be context-dependent for some arities in its arity range, and context-independent
               for others: for example <function>fn:name#0</function> is context-dependent
                  while <function>fn:name#1</function> is context-independent.</termdef></p>
               
               <p><termdef id="dt-context-independent" term="context-independent">A 
                  <phrase diff="chg" at="2023-03-12"><xtermref spec="XP40" ref="dt-function-definition">function definition</xtermref></phrase> 
                  that is not <termref def="dt-context-dependent">context-dependent</termref> is called 
                  <term>context-independent</term>.</termdef></p>
               
               <p diff="add" at="2023-03-12">The main categories of context-dependent functions are:</p>
               
               <ulist diff="add" at="2023-03-12">
                  <item><p>Functions that explicitly deliver the value of a component of the static or dynamic context,
                  for example <function>fn:static-base-uri</function>, <function>fn:default-collation</function>,
                  <function>fn:position</function>, or <function>fn:last</function>.</p></item>
                  <item><p>Functions with an optional parameter whose default value is taken from the static
                     or dynamic context of the caller, usually either the context value (for example, <function>fn:node-name</function>)
                     or the default collation (for example, <function>fn:index-of</function>).</p></item>
                  <item><p>Functions that use the static context of the caller to expand or disambiguate
                  the values of supplied arguments: for example <function>fn:doc</function> expands its first
                  argument using the static base URI of the caller, and <code>xs:QName</code> expands its first argument
                  using the in-scope namespaces of the caller.</p></item>
               </ulist>
               
               <p><termdef id="dt-focus-dependent" term="focus-dependent">A function is <term>focus-dependent</term>
                  if its result depends on the <xtermref ref="dt-focus" spec="XP31">focus</xtermref>
                  (that is, the context item, position, or size) 
                  <phrase diff="add" at="2023-03-12">of the caller</phrase>.</termdef></p>
               <p><termdef id="dt-focus-independent" term="focus-dependent">A function that
                  is not <termref def="dt-focus-dependent">focus-dependent</termref> is called
                  <term>focus-independent</term>.</termdef></p>

           
               <note diff="add" at="2023-03-12">
                  <p>Some functions depend on aspects of the dynamic context that remain invariant
                  within an <termref def="execution-scope"/>, such as the implicit timezone.
                  Formally this is treated in the same way as any other context dependency, but
                  internally, the implementation may be able to take advantage of the fact that the
                  value is invariant.</p>
               </note>
               
               <note diff="add" at="2023-03-12">
                  <p>User-defined functions in XQuery and XSLT may depend on the static context
                     of the function definition (for example, the in-scope namespaces) and also in a limited
                     way on the dynamic context (for example, the values of global variables).
                     However, the only way they can depend on the static or dynamic context
                     of the caller — which is what concerns us here — is by defining optional
                     parameters whose default values are context-dependent.</p>
               </note>
                  
               <note diff="add" at="2023-09-05">
               <p>Because the focus is a specific part of the dynamic context, all 
                  <termref def="dt-focus-dependent">focus-dependent</termref> functions are also
                  <termref def="dt-context-dependent">context-dependent</termref>. A
                  <termref def="dt-context-dependent">context-dependent</termref> function, however,
                  may be either <termref def="dt-focus-dependent">focus-dependent</termref> or
                     <termref def="dt-focus-independent">focus-independent</termref>.</p>
               </note>
               

               
               <p>A <phrase diff="chg" at="2023-03-12">function definition</phrase> that is context-dependent 
                  can be used as <phrase diff="add" at="2023-03-12">the target of</phrase> a named
               function reference, can be partially applied, and can be found using <function>fn:function-lookup</function>. 
               The principle in such cases is that the static context used for the function evaluation
               is taken from the static context of the named function reference, partial function application, or the call
               on <function>fn:function-lookup</function>; and the dynamic context for the function evaluation is taken from the dynamic
               context of the evaluation of the named function reference, partial function application, or the call
               of <function>fn:function-lookup</function>. <phrase diff="add" at="2023-03-12">These constructs all deliver a 
                  <xtermref spec="DM40" ref="dt-function-item">function item</xtermref>
                  having a <term>captured context</term> based on the static and dynamic
                  context of the construct that created the function item. This captured context forms 
               part of the closure of the function item.</phrase></p>
               
               <p diff="add" at="2023-03-12">The result of a dynamic call to a function item never 
                  depends on the static or dynamic context of the dynamic function call, only (where relevant) 
                  on the the captured context held within the function item itself.</p>
              
               
               <p diff="del" at="2023-03-12">Context-dependent functions fall into a number of categories:</p>
               
               <olist diff="del" at="2023-03-12">
               
               <item><p>The functions <function>fn:current-date</function>, <function>fn:current-dateTime</function>, <function>fn:current-time</function>, 
                  <function>fn:default-language</function>, <function>fn:implicit-timezone</function>,
               <function>fn:adjust-date-to-timezone</function>, <function>fn:adjust-dateTime-to-timezone</function>, and
               <function>fn:adjust-time-to-timezone</function> depend on properties of the dynamic context that are
               fixed within the <termref def="execution-scope">execution scope</termref>. The same applies to a
               number of functions in the <code>op:</code> namespace that manipulate dates and times and
               that make use of the implicit timezone. These functions will return the same
               result if called repeatedly during a single <termref def="execution-scope">execution scope</termref>.</p></item>
               
                  <item><p>A number of functions including <function>fn:base-uri#0</function>, <function>fn:data#0</function>, 
                     <function>fn:document-uri#0</function>, <function>fn:element-with-id#1</function>, <function>fn:id#1</function>, 
                     <function>fn:idref#1</function>, <function>fn:lang#1</function>, <function>fn:last#0</function>, <function>fn:local-name#0</function>,
                     <function>fn:name#0</function>, <function>fn:namespace-uri#0</function>, <function>fn:normalize-space#0</function>, 
                     <function>fn:number#0</function>, <function>fn:path#0</function>, <function>fn:position#0</function>, 
                     <function>fn:root#0</function>, <function>fn:string#0</function>, and
               <function>fn:string-length#0</function> depend on the <xtermref ref="dt-focus" spec="XP31">focus</xtermref>. 
                     These functions will in general return
               different results on different calls if the focus is different.</p>
                  <p>A function is <term>focus-dependent</term>
                     if its result depends on the <xtermref ref="dt-focus" spec="XP31">focus</xtermref>
                     (that is, the context value, position, or size).</p>
                     <p>A function that
                        is not <termref def="dt-focus-dependent">focus-dependent</termref> is called
                        <term>focus-independent</term></p></item>
                        
 
               
                  <item><p>The function <function>fn:default-collation</function> and many 
                     string-handling operators and functions depend
               on the default collation and the in-scope collations, which are both properties
               of the static context. If a particular call of one of these functions is
               evaluated twice with the same arguments then it will return the same result
               each time (because the static context, by definition, does not change at run
               time). However, two distinct calls (that is, two calls on the function
               appearing in different places in the source code) may produce different results
               even if the explicit arguments are the same.</p></item>
               
                  <item><p>Functions such as <function>fn:static-base-uri</function>, <function>fn:doc</function>, and <function>fn:collection</function> depend on
               other aspects of the static context. As with functions that depend on
               collations, a single call will produce the same results on each call if the
               explicit arguments are the same, but two calls appearing in different places in
               the source code may produce different results.</p></item>
               
               </olist>
               
               <p>The <function>fn:function-lookup</function> function is a special case because it is
               potentially dependent on everything in the static and dynamic context. This is because the static and dynamic
               context of the call to <function>fn:function-lookup</function> 
                  <phrase diff="chg" at="2023-03-12">form the captured context of the
               function item</phrase> that <function>fn:function-lookup</function> returns.</p>
               
               <p diff="del" at="2023-03-12"><termdef id="dt-implicit-arguments" term="implicit argument">For a
                  <termref def="dt-context-dependent">context-dependent</termref> function, 
                  the parts of the context on which it depends are
               referred to as <term>implicit arguments</term>.</termdef></p>
               
               
               
               <p><termdef id="dt-deterministic" term="deterministic">A function that is guaranteed to produce <termref def="dt-identical">identical</termref> results 
                  from repeated calls within a single <termref def="execution-scope">execution scope</termref>
               if the explicit and <termref def="dt-implicit-arguments">implicit</termref> arguments are identical is referred to as
               <term>deterministic</term>.</termdef></p>
               
               <p><termdef id="dt-nondeterministic" term="nondeterministic">A function that is not
                  <termref def="dt-deterministic">deterministic</termref> is referred to as <term>nondeterministic</term>.</termdef></p>
               
               <p>All functions defined in this specification are <termref def="dt-deterministic">deterministic</termref> unless otherwise stated.
               Exceptions include the following:</p>
               
               <ulist>
               <item><p><termdef id="dt-nondeterministic-wrt-ordering" term="nondeterministic with respect to ordering">Some 
                  functions (such as <function>fn:distinct-values</function>, <function>fn:unordered</function>, <function>map:keys</function>,
                  and <function>map:for-each</function>) produce results in an
                  <termref def="implementation-defined">implementation-defined</termref> or 
                  <termref def="implementation-dependent">implementation-dependent</termref> order. 
                  In such cases two calls with the same arguments are not guaranteed to produce the results in the same order. These functions are
               said to be <term>nondeterministic with respect to ordering</term>.</termdef></p></item>
               
               <item><p>Some functions (such as <function>fn:analyze-string</function>,
                  <function>fn:parse-xml</function>, <function>fn:parse-xml-fragment</function>, 
                  <function>fn:parse-html</function>, and <function>fn:json-to-xml</function>) 
                  construct a tree of nodes to
               represent their results. There is no guarantee that repeated calls with the same
               arguments will return the same identical node (in the sense of the <code>is</code>
               operator). However, if non-identical nodes are returned, their content will be the
               same in the sense of the <function>fn:deep-equal</function> function. Such a function is said 
               to be <term>nondeterministic with respect to node identity</term>.</p></item>
               
               <item><p>Some functions (such as <function>fn:doc</function> and <function>fn:collection</function>) create new nodes by reading external
               documents. Such functions are guaranteed to be <termref def="dt-deterministic">deterministic</termref> with the exception that
               an implementation is allowed to make them nondeterministic as a user option.</p></item>
               
               </ulist>
               
               <p>Where the results of a function are described as being (to a greater or lesser
                  extent) <termref def="implementation-defined">implementation-defined</termref> or 
                  <termref def="implementation-dependent">implementation-dependent</termref>, this does not by
               itself remove the requirement that the results should be deterministic: that is, that
               repeated calls with the same explicit and implicit arguments <rfc2119>must</rfc2119> return
               identical results.</p>
               
               <p><termdef id="dt-variadic" term="variadic">The function <function>fn:concat</function>
                  is defined to be variadic: it accepts any number of arguments. No other function
                  has this property.</termdef></p>
            </div3>           
         </div2>
      </div1>
      
      <div1 id="node-functions">
         <head>Processing nodes</head>
         <div2 id="accessors">
            <head>Accessors</head>
            <p>Accessors and their semantics are described in <bibref ref="xpath-datamodel-31"/>. Some of
                   these accessors are exposed to the user through the functions described below.</p>
            <p>Each of these functions has an arity-zero signature which is equivalent to the arity-one
            form, with the context value supplied as the implicit first argument. In addition, each of the
            arity-one functions accepts an empty sequence as the argument, in which case it generally delivers
            an empty sequence as the result: the exception is <function>fn:string</function>, which delivers
            a zero-length string.</p>
            <table role="data">
               <col width="25%" span="1"/>
               <col width="25%" span="1"/>
               <col width="25%" span="1"/>
               <col width="25%" span="1"/>
               <thead>
                  <tr>
                     <th>Function</th>
                     <th>Accessor</th>
                     <th>Accepts</th>
                     <th>Returns</th>
                  </tr>
               </thead>
               <tbody><tr>
                     <td>
                               <function>fn:node-name</function>
                           </td>
                     <td>
                               <code>node-name</code>
                           </td>
                     <td>node (optional)</td>
                     <td><code>xs:QName</code> (optional)
                           </td>
                  </tr>
                  <tr>
                     <td>
                               <function>fn:nilled</function>
                           </td>
                     <td>
                               <code>nilled</code>
                           </td>
                     <td>node (optional)</td>
                     <td><code>xs:boolean</code> (optional)
                           </td>
                  </tr>
                  <tr>
                     <td>
                               <function>fn:string</function>
                           </td>
                     <td>
                               <code>string-value</code>
                           </td>
                     <td>item (optional)</td>
                     <td>
                               <code>xs:string</code>
                           </td>
                  </tr>
                  <tr>
                     <td>
                               <function>fn:data</function>
                           </td>
                     <td>
                               <code>typed-value</code>
                           </td>
                     <td>zero or more items</td>
                     <td>a sequence of atomic items</td>
                  </tr>
                  <tr>
                     <td>
                               <function>fn:base-uri</function>
                           </td>
                     <td>
                               <code>base-uri</code>
                           </td>
                     <td>node (optional)</td>
                     <td><code>xs:anyURI</code> (optional)
                           </td>
                  </tr>
                  <tr>
                     <td>
                               <function>fn:document-uri</function>
                           </td>
                     <td>
                               <code>document-uri</code>
                           </td>
                     <td>node (optional)</td>
                     <td><code>xs:anyURI</code> (optional)
                           </td>
                  </tr>
               </tbody>
            </table>
            <?local-function-index?>
            
            <div3 id="func-node-name">
               <head><?function fn:node-name?></head>
            </div3>
            <div3 id="func-nilled">
               <head><?function fn:nilled?></head>
            </div3>
            <div3 id="func-string">
               <head><?function fn:string?></head>
            </div3>
            <div3 id="func-data">
               <head><?function fn:data?></head>
            </div3>
            <div3 id="func-base-uri">
               <head><?function fn:base-uri?></head>
            </div3>
            <div3 id="func-document-uri">
               <head><?function fn:document-uri?></head>
   		   </div3>
         </div2>
         <div2 id="other-node-functions">
            <head>Other functions on nodes</head>
            <p>This section specifies further functions on nodes. Nodes are formally defined
               in <xspecref spec="DM31" ref="Node"/>.</p>
            <?local-function-index?>
            
            <div3 id="func-name">
               <head><?function fn:name?></head>
            </div3>
            <div3 id="func-local-name">
               <head><?function fn:local-name?></head>
            </div3>
            <div3 id="func-namespace-uri">
               <head><?function fn:namespace-uri?></head>
            </div3>
            
            <div3 id="func-lang">
               <head><?function fn:lang?></head>
            </div3>
            <div3 id="func-root">
               <head><?function fn:root?></head>
            </div3>
            <div3 id="func-path">
               <head><?function fn:path?></head>
            </div3>
            <div3 id="func-has-children">
               <head><?function fn:has-children?></head>
            </div3>
            <div3 id="func-siblings">
               <head><?function fn:siblings?></head>
            </div3>
            
         </div2>
         <div2 id="functions-on-node-sequences">
            <head>Functions on sequences of nodes</head>
            <p>This section specifies functions on sequences of nodes.</p>
            <?local-function-index?>
            <div3 id="func-distinct-ordered-nodes">
               <head><?function fn:distinct-ordered-nodes?></head>
            </div3>
            <div3 id="func-innermost">
               <head><?function fn:innermost?></head>
            </div3>
            <div3 id="func-outermost">
               <head><?function fn:outermost?></head>
            </div3>
         </div2>
      </div1>
	  <div1 id="errors-and-diagnostics">
	    <head>Errors and diagnostics</head>
        <div2 id="errors">
		  	<head>Raising errors</head>
	
	         <p>In this document, as well as in <bibref ref="xquery-40"/> and <bibref ref="xpath-40"/>,
	            the phrase <quote>an error is raised</quote>
	                is used. Raising an error is equivalent to calling the <function>fn:error</function>
	                function defined in this section with the provided error code. Except where otherwise
	                specified, errors defined in this specification are dynamic errors. Some errors,
	                however, are classified as type errors. Type errors are typically used where the presence
	         of the error can be inferred from knowledge of the type of the actual arguments to a function, for
	         example with a call such as <code>fn:string(fn:abs#1)</code>. Host languages may allow type errors
	         to be reported statically if they are discovered during static analysis.</p>
	         <p> When function specifications indicate that an error is to be raised, the notation 
	            <quote>[<emph>error code</emph>]</quote> is used to specify an error code. Each error defined
	                in this document is identified by an <code>xs:QName</code> that is in the
	                <code>http://www.w3.org/2005/xqt-errors</code> namespace, represented in this document by the <code>err</code> prefix. It is this
	                <code>xs:QName</code> that is actually passed as an argument to the
	                <function>fn:error</function> function. Calling this function raises an error.  For a
	                more detailed treatment of error handing, see <xspecref spec="XP31" ref="id-handling-dynamic"/>.</p>
	         <p>The <function>fn:error</function> function is a general function that may be called as above
	                but may also be called from <bibref ref="xquery-40"/> or <bibref ref="xpath-40"/>
	                applications with, for example, an <code>xs:QName</code> argument. </p>
	         <div3 id="func-error">
	         	<head><?function fn:error?></head>        
			 </div3>
		 </div2>
	     <div2 id="diagnostics">
		  	<head>Diagnostic tracing</head>
	      	<div3 id="func-trace">
				  <head><?function fn:trace?></head>
			   </div3>
	      	<div3 id="func-message">
				  <head><?function fn:message?></head>
			   </div3>
	     </div2>
      </div1>
      <div1 id="numeric-functions">
         <head>Processing numerics</head>
         <p>This section specifies arithmetic operators on the numeric datatypes defined in
                    <bibref ref="xmlschema-2"/>.</p>
         <div2 id="numeric-types">
            <head>Numeric types</head>
            <p>The operators described in this section are defined on the following atomic
                    types.</p>

            &common-numeric-types.xml;

            <p>They also apply to types derived by restriction from the above types. </p>
            <p>The type <code>xs:numeric</code> is defined as a union type whose member types are
            (in order) <code>xs:double</code>, <code>xs:float</code>, and <code>xs:decimal</code>. This type is implicitly imported
            into the static context, so it can also be used in defining the signature of user-written functions. Apart from the fact that
            it is implicitly imported, it behaves exactly like a user-defined type with the same definition. This means, for example:</p>
            
            <ulist>
               <item><p>If the expected type of a function parameter is given as <code>xs:numeric</code>, the actual value supplied
               can be an instance of any of these three types, or any type derived from these three by restriction (this includes the built-in
               type <code>xs:integer</code>, which is derived from <code>xs:decimal</code>).</p></item>
               <item><p>If the expected type of a function parameter is given as <code>xs:numeric</code>, and the actual value supplied
                  is <code>xs:untypedAtomic</code> (or a node whose atomized value is <code>xs:untypedAtomic</code>), then it will
                  be cast to the union type <code>xs:numeric</code> using the rules in <specref ref="casting-to-union"/>.
               Because the lexical space of <code>xs:double</code> subsumes the lexical space of the other member types, and
               <code>xs:double</code> is listed first, the effect is that if the untyped atomic item is in the lexical space of
               <code>xs:double</code>, it will be converted to an <code>xs:double</code>, and if not, a dynamic error occurs.</p></item>
               <item><p>When the return type of a function is given as <code>xs:numeric</code>, the actual value returned will be
               an instance of one of the three member types (and perhaps also of types derived from these by restriction). The rules
               for the particular function will specify how the type of the result depends on the values supplied as arguments.
               In many cases, for the functions in this specification, the result is defined to be the same type as the first
               argument.</p></item>
            </ulist>
            <note>
               <p>
This specification uses  <bibref ref="ieee754-2019"/> arithmetic for <code>xs:float</code> and <code>xs:double</code> values.
One consequence of this is that some operations result in the value <code>NaN</code> (not a number), which
has the unusual property that it is not equal to itself. Another consequence is that some operations return the value negative zero.
This differs from <bibref ref="xmlschema-2"/>, which defines
<code>NaN</code> as being equal to itself and defines only a single zero in the value space.
 The text accompanying several functions defines behavior for both positive and negative zero inputs and outputs 
 in the interest of alignment with <bibref ref="ieee754-2019"/>. A conformant implementation must
 respect these semantics. In consequence, the expression <code>-0.0e0</code> (which is actually a unary minus operator 
    applied to an <code>xs:double</code> value) will always return negative zero: see <specref ref="func-numeric-unary-minus"/>. 
    As a concession to implementations that rely on implementations of XSD 1.0, however, when casting from string to double
 the lexical form <code>-0</code> <rfc2119>may</rfc2119> be converted to positive zero, though negative zero
 is <rfc2119>recommended</rfc2119>.
</p>
               <p>XML Schema 1.1 introduces support for positive and negative zero as distinct values, and also uses the <bibref ref="ieee754-2019"/>
               semantics for comparisons involving <code>NaN</code>.</p>
            </note>
         </div2>
         <div2 id="op.numeric">
            <head>Arithmetic operators on numeric values</head>
            <p>The following functions define the semantics of arithmetic operators defined in 
			<bibref ref="xquery-40"/> and <bibref ref="xpath-40"/> on these numeric types. </p>
            <table role="no-code-break data">
               <thead>
                  <tr>
                     <th>Operator</th>
                     <th>Meaning</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>
                                <code>op:numeric-add</code>
                            </td>
                     <td>Addition</td>
                  </tr>
                  <tr>
                     <td>
                                <code>op:numeric-subtract</code>
                            </td>
                     <td>Subtraction</td>
                  </tr>
                  <tr>
                     <td>
                                <code>op:numeric-multiply</code>
                            </td>
                     <td>Multiplication</td>
                  </tr>
                  <tr>
                     <td>
                                <code>op:numeric-divide</code>
                            </td>
                     <td>Division</td>
                  </tr>
                  <tr>
                     <td>
                                <code>op:numeric-integer-divide</code>
                            </td>
                     <td>Integer division</td>
                  </tr>
                  <tr>
                     <td>
                                <code>op:numeric-mod</code>
                            </td>
                     <td>Modulus</td>
                  </tr>
                  <tr>
                     <td>
                                <code>op:numeric-unary-plus</code>
                            </td>
                     <td>Unary plus</td>
                  </tr>
                  <tr>
                     <td>
                                <code>op:numeric-unary-minus</code>
                            </td>
                     <td>Unary minus (negation)</td>
                  </tr>
               </tbody>
            </table>
            <p>The parameters and return types for the above operators are in most cases declared to be of type
               <code>xs:numeric</code>, which permits the basic numeric
                    types: <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>
                    and <code>xs:double</code>, and types derived from them.
               In general the two-argument functions require that both arguments are of the same primitive type,
            and they return a value of this same type.
               The exceptions are <code>op:numeric-divide</code>, which returns
                    an <code>xs:decimal</code> if called with two <code>xs:integer</code> operands,
                    and <code>op:numeric-integer-divide</code> which always returns an <code>xs:integer</code>.</p>
            <p>If the two operands of an arithmetic expression are not of the same type, they
               may be converted to a common type as described in <xspecref spec="XP40" ref="id-arithmetic-expressions"/>. </p>
            <p>The result type of operations depends on their argument datatypes and is defined
                    in the following table:</p>
            <table role="no-code-break data">
               <thead>
                  <tr>
                     <th>Operator</th>
                     <th>Returns</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>
                                <code>op:operation(xs:integer, xs:integer)</code>
                            </td>
                     <td>
                                <code>xs:integer</code> (except for <code>op:numeric-divide(integer,
                                integer)</code>, which returns <code>xs:decimal</code>)</td>
                  </tr>
                  <tr>
                     <td>
                                <code>op:operation(xs:decimal, xs:decimal)</code>
                            </td>
                     <td>
                                <code>xs:decimal</code>
                            </td>
                  </tr>
                  <tr>
                     <td>
                                <code>op:operation(xs:float, xs:float)</code>
                            </td>
                     <td>
                                <code>xs:float</code>
                            </td>
                  </tr>
                  <tr>
                     <td>
                                <code>op:operation(xs:double, xs:double)</code>
                            </td>
                     <td>
                                <code>xs:double</code>
                            </td>
                  </tr>
                  <tr>
                     <td>
                                <code>op:operation(xs:integer)</code>
                            </td>
                     <td>
                                <code>xs:integer</code>
                            </td>
                  </tr>
                  <tr>
                     <td>
                                <code>op:operation(xs:decimal)</code>
                            </td>
                     <td>
                                <code>xs:decimal</code>
                            </td>
                  </tr>
                  <tr>
                     <td>
                                <code>op:operation(xs:float)</code>
                            </td>
                     <td>
                                <code>xs:float</code>
                            </td>
                  </tr>
                  <tr>
                     <td>
                                <code>op:operation(xs:double)</code>
                            </td>
                     <td>
                                <code>xs:double</code>
                            </td>
                  </tr>
               </tbody>
            </table>
            <!--<p>These rules define any operation on any pair of arithmetic types. Consider the
                    following example:</p>
            <eg xml:space="preserve"><![CDATA[op:operation(xs:int, xs:double) => op:operation(xs:double, xs:double)]]></eg>
            <p>For this operation, <code>xs:int</code> must be converted to
                    <code>xs:double</code>. This can be done, since by the rules above:
                    <code>xs:int</code> can be substituted for <code>xs:integer</code>,
                    <code>xs:integer</code> can be substituted for <code>xs:decimal</code>,
                    <code>xs:decimal</code> can be promoted to <code>xs:double</code>. As far as possible, the promotions should be done in a
                    single step. Specifically, when an <code>xs:decimal</code> is promoted to an
                    <code>xs:double</code>, it should not be converted to an <code>xs:float</code>
                    and then to <code>xs:double</code>, as this risks loss of precision.</p>
            <p>As another example, a user may define <code>height</code> as a derived type of
                    <code>xs:integer</code> with a minimum value of 20 and a maximum value of 100.
                    They may then derive <code>fenceHeight</code> using an enumeration to restrict the
                    permitted set of values to, say, 36, 48 and 60.</p>
            <eg xml:space="preserve"><![CDATA[op:operation(fenceHeight, xs:integer) => op:operation(xs:integer, xs:integer)]]></eg>
            <p>
                    <code>fenceHeight</code> can be substituted for its base type
                    <code>height</code> and <code>height</code> can be substituted for its base type
                    <code>xs:integer</code>. </p>
-->
            <p>The basic rules for addition, subtraction, and multiplication
			of ordinary numbers are not set out in this specification; they are taken as given. In the case of <code>xs:double</code>
			and <code>xs:float</code> the rules are as defined in <bibref ref="ieee754-2019"/>. The rules for handling
			division and modulus operations, as well as the rules for handling special values such as infinity and <code>NaN</code>,
			and exception conditions such as overflow and underflow, are described more explicitly since they are not necessarily obvious.</p>

            <p>On overflow and underflow situations during arithmetic operations, conforming
                    implementations <rfc2119>must</rfc2119> behave as follows:</p>
            <ulist>
               <item>
                  <p>For <code>xs:float</code> and <code>xs:double</code> operations, overflow
                            behavior <rfc2119>must</rfc2119> be conformant with <bibref ref="ieee754-2019"/>. This specification allows the following options:</p>
                  <ulist>
                     <item>
                        <p>Raising a dynamic error <errorref class="AR" code="0002"/> via an
                                    overflow trap.</p>
                     </item>
                     <item>
                        <p>Returning <code>INF</code> or <code>-INF</code>.</p>
                     </item>
                     <item>
                        <p>Returning the largest (positive or negative) non-infinite number.</p>
                     </item>
                  </ulist>
               </item>
               <item>
                  <p>For <code>xs:float</code> and <code>xs:double</code> operations,
                            underflow behavior <rfc2119>must</rfc2119> be conformant with <bibref ref="ieee754-2019"/>. This specification allows the following options:</p>
                  <ulist>
                     <item>
                        <p>Raising a dynamic error <errorref class="AR" code="0002"/> via an
                                    underflow trap.</p>
                     </item>
                     <item>
                        <p>Returning <code>0.0E0</code> or <code>+/- 2**Emin</code> or a
                                    denormalized value; where <code>Emin</code> is the smallest
                                    possible <code>xs:float</code> or <code>xs:double</code> exponent.</p>
                     </item>
                  </ulist>
               </item>
               <item>
                  <p>For <code>xs:decimal</code> operations, overflow behavior <rfc2119>must</rfc2119> 
                     raise a dynamic error <errorref class="AR" code="0002"/>. On
                            underflow, <code>0.0</code> must be returned.</p>
               </item>
               <item>
                  <p>For <code>xs:integer</code> operations, implementations that support
                            limited-precision integer operations <rfc2119>must</rfc2119> select from
                            the following options:</p>
                  <ulist>
                     <item>
                        <p> They <rfc2119>may</rfc2119> choose to always raise a dynamic
                                        error <errorref class="AR" code="0002"/>.</p>
                     </item>
                     <item>
                        <p> They <rfc2119>may</rfc2119> provide an <termref def="implementation-defined"/> mechanism that allows users to
                                    choose between raising an error and returning a result that is
                                    modulo the largest representable integer value. See <bibref ref="ISO10967"/>.</p>
                     </item>
                  </ulist>
               </item>
            </ulist>
            <p>The functions <code>op:numeric-add</code>, <code>op:numeric-subtract</code>,
                    <code>op:numeric-multiply</code>, <code>op:numeric-divide</code>,
                    <code>op:numeric-integer-divide</code> and <code>op:numeric-mod</code> are each
                    defined for pairs of numeric operands, each of which has the same
                    type:<code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:float</code>, or
                    <code>xs:double</code>. The functions <code>op:numeric-unary-plus</code> and
                    <code>op:numeric-unary-minus</code> are defined for a single operand whose type
                    is one of those same numeric types.</p>
            <p> For <code>xs:float</code> and <code>xs:double</code> arguments, if either
                    argument is <code>NaN</code>, the result is <code>NaN</code>.</p>
            <p>For <code>xs:decimal</code> values, let <var>N</var> be the number of digits
            of precision supported by the implementation, and let <var>M</var> (<code>M &lt;= N</code>) be the minimum limit on the number of digits
            required for conformance (18 digits for XSD 1.0, 16 digits for XSD 1.1). Then for addition, subtraction, and multiplication
               operations, the returned result <rfc2119>should</rfc2119> be accurate to <var>N</var> digits of precision, and for division and modulus operations,
               the returned result <rfc2119>should</rfc2119> be accurate to at least <var>M</var> digits of precision. 
               The actual precision is <termref def="implementation-defined"/>. If the number
                    of digits in the mathematical result exceeds the number of digits that the implementation
                    retains for that operation, the result is truncated or rounded in an <termref def="implementation-defined"/> manner.</p>
            
            <note><p>This specification does not determine whether <code>xs:decimal</code> operations are fixed point or floating point.
            In an implementation using floating point it is possible for very simple operations to require more digits of precision than
            are available; for example, adding <code>1e100</code> to <code>1e-100</code> requires 200 digits of precision for an
               accurate representation of the result.</p></note>
            
        
            
            <p>The <bibref ref="ieee754-2019"/> specification also describes handling of
            two exception conditions called <code>divideByZero</code> and <code>invalidOperation</code>. The 
            IEEE <code>divideByZero</code> exception is raised not only by a direct attempt to divide by zero, but also by
            operations such as <code>log(0)</code>. The IEEE <code>invalidOperation</code> exception is raised by
            attempts to call a function with an argument that is outside the function’s domain (for example,
            <code>sqrt(-1)</code> or <code>log(-1)</code>). 
               Although IEEE defines these as exceptions, it also defines “default non-stop exception handling” in 
                  which the operation returns a defined result, typically positive or negative infinity, or <code>NaN</code>. With this 
                  function library,
               these IEEE exceptions do not cause a dynamic error
            at the application level; rather they result in the relevant function or operator returning
            the defined non-error result. 
               The underlying IEEE exception <rfc2119>may</rfc2119> be notified to the application
            or to the user by some <termref def="implementation-defined">implementation-defined</termref>
               warning condition, but the observable effect on an application 
               using the functions and operators defined in this specification is simply to return
               the defined result (typically <code>-INF</code>, <code>+INF</code>, or <code>NaN</code>) with no error.</p>
            <p>The <bibref ref="ieee754-2019"/> specification distinguishes two <code>NaN</code> values:
               a quiet <code>NaN</code> and a signaling <code>NaN</code>. These two values are not distinguishable in the XDM model:
               the value spaces of <code>xs:float</code> and <code>xs:double</code> each include only a single
               <code>NaN</code> value. This does not prevent the implementation distinguishing them internally,
               and triggering different <termref def="implementation-defined">implementation-defined</termref>
               warning conditions, but such distinctions do not affect the observable behavior of an application 
               using the functions and operators defined in this specification.</p>
            <div3 id="func-numeric-add">
               <head><?function op:numeric-add?></head>
            </div3>
            <div3 id="func-numeric-subtract">
               <head><?function op:numeric-subtract?></head>
            </div3>
            <div3 id="func-numeric-multiply">
               <head><?function op:numeric-multiply?></head>
            </div3>
            <div3 id="func-numeric-divide">
               <head><?function op:numeric-divide?></head>
            </div3>
            <div3 id="func-numeric-integer-divide">
               <head><?function op:numeric-integer-divide?></head>
            </div3>
            <div3 id="func-numeric-mod">
               <head><?function op:numeric-mod?></head>
            </div3>
            <div3 id="func-numeric-unary-plus">
               <head><?function op:numeric-unary-plus?></head>
 			</div3>
            <div3 id="func-numeric-unary-minus">
               <head><?function op:numeric-unary-minus?></head>
            </div3>
         </div2>
         <div2 id="comp.numeric" diff="chg" at="A">
            <head>Comparison operators on numeric values</head>
            <changes>
               <change issue="473" PR="482">Deleted an inaccurate statement concerning the behavior of NaN.</change>
            </changes>
            <p diff="chg" at="A">The six value comparison operators <code>eq</code>, <code>ne</code>, <code>lt</code>,
               <code>le</code>, <code>gt</code>, and <code>ge</code> are defined in terms of two
               underlying functions: <code>op:numeric-equal</code> and <code>op:numeric-less-than</code>.
               These functions are defined to operate on values of the same type.</p>
            <p>If the arguments are of different types, one argument is promoted to the type of the other
               as described above in <specref ref="op.numeric"/>. Each comparison operator returns a
               boolean value.</p>
            <note><p diff="add" at="2023-12-05">For a description of the different ways of comparing numeric
               values using the operators <code>=</code> and <code>eq</code> and the functions
               <function>fn:deep-equal</function> and <function>fn:atomic-equal</function>, 
               see <xspecref spec="XP40" ref="id-atomic-comparisons"/>.</p></note>
            <note><p diff="add" at="2023-12-18">See also the function <function>fn:compare</function>.</p></note>
            <?local-function-index?>
            <div3 id="func-numeric-equal">
               <head><?function op:numeric-equal?></head>
            </div3>
            <div3 id="func-numeric-less-than">
               <head><?function op:numeric-less-than?></head>
            </div3>
         </div2>
         <div2 id="numeric-value-functions">
            <head>Functions on numeric values</head>
            <p>The following functions are defined on numeric types. Each function returns a
                    value of the same type as the type of its argument.</p>
            <ulist>
               <item>
                  <p>If the argument is the empty sequence, the empty sequence is returned.</p>
               </item>
               <item>
                  <p>For <code>xs:float</code> and <code>xs:double</code> arguments, if the
                            argument is <code>NaN</code>, <code>NaN</code> is returned.</p>
               </item>
               <item>
                  <p>With the exception of <function>fn:abs</function>, functions with arguments of 
                     type <code>xs:float</code> and <code>xs:double</code> that are positive or
                            negative infinity return positive or negative infinity.</p>
               </item>
            </ulist>
            <?local-function-index?>
            
            <note>
               <p>The <function>fn:round</function> function has been extended with a third argument
               in version 4.0 of this specification; this means that the <function>fn:ceiling</function>,
               <function>fn:floor</function>, and <function>fn:round-half-to-even</function> functions are now
               technically redundant. They are retained, however, both for backwards compatibility
               and for convenience.</p>             
            </note>
            
            <div3 id="func-abs">
               <head><?function fn:abs?></head>
            </div3>
            <div3 id="func-ceiling">
               <head><?function fn:ceiling?></head>
            </div3>
            <div3 id="func-floor">
               <head><?function fn:floor?></head>
            </div3>
            <div3 id="func-round">
               <head><?function fn:round?></head>
            </div3>
            <div3 id="func-round-half-to-even">
               <head><?function fn:round-half-to-even?></head>
            </div3>
            <div3 id="func-divide-decimals">
               <head><?function fn:divide-decimals?></head>
            </div3>
            <div3 id="func-is-NaN" diff="add" at="A">
               <head><?function fn:is-NaN?></head>
            </div3>
         </div2 >
         
         <div2 id="parsing-numbers">
            <head>Parsing numbers</head>
            <p>It is possible to convert strings to values of type <code>xs:integer</code>,
            <code>xs:float</code>, <code>xs:decimal</code>, or <code>xs:double</code>
            using the constructor functions described in <specref ref="constructor-functions"/>
            or using <code>cast</code> expressions as described in <specref ref="casting"/>.</p>
            <p>In addition the <function>fn:number</function> function is available to convert strings
            to values of type <code>xs:double</code>. It differs from the <code>xs:double</code>
            constructor function in that any value outside the lexical space of the <code>xs:double</code>
            datatype is converted to the <code>xs:double</code> value <code>NaN</code>.</p>
            <?local-function-index?>
            <div3 id="func-number">
               <head><?function fn:number?></head>
            </div3>
            <div3 id="func-parse-integer" diff="add" at="2023-04-07">
               <head><?function fn:parse-integer?></head>
            </div3>
         </div2>
		 <div2 id="formatting-integers">
	       <head>Formatting integers</head>
		    
		    <?local-function-index?>
				
		   <div3 id="func-format-integer">
               <head><?function fn:format-integer?></head>
           </div3>
		</div2>




		<div2 id="formatting-numbers">
            <head>Formatting numbers</head>
			
			   
         <p>This section defines a function for formatting decimal and floating point numbers.</p>
		   
		   <?local-function-index?>
		   
		   <note>
		      <p>This function can be used to format any numeric quantity, including an integer. For integers, however,
		         the <function>fn:format-integer</function> function offers additional possibilities. Note also that the picture
		         strings used by the two functions are not 100% compatible, though they share some options in common.</p>
		   </note>
	
            <div3 id="defining-decimal-format">
               <head>Defining a decimal format</head>

<p>Decimal formats are defined in the static context, and the way they are defined is therefore outside the scope
of this specification. XSLT and XQuery both provide custom syntax for creating a decimal format.</p>

<p>The static context provides a set of decimal formats. One of the decimal formats is unnamed, the others (if any)
   are identified by a QName. There is always an unnamed decimal format available, but its contents are 
   <termref def="implementation-defined"/>.</p>

<p>Each decimal format provides a set of named properties.</p>

               
<note><p>A phrase such as "The <xtermref spec="XP31" ref="id-static-decimal-format-minus-sign">minus-sign</xtermref> character" is to be read as 
   “the character assigned to the <xtermref spec="XP31" ref="id-static-decimal-format-minus-sign">minus-sign</xtermref>
property in the relevant decimal format”.</p></note>               

<p><termdef id="dt-decimal-digit-family" term="digit family">The <term>decimal digit family</term> of a decimal format 
is the sequence of ten digits with
consecutive Unicode <termref def="codepoint">codepoints</termref> starting with the character that is the value of the 
   <xtermref spec="XP31" ref="id-static-decimal-format-zero-digit">zero-digit</xtermref> property.</termdef></p>
               
               <p><termdef id="dt-optional-digit-character" term="optional digit character">The <term>optional digit character</term> is
                  the character that is the value of the 
                  <xtermref spec="XP31" ref="id-static-decimal-format-digit">digit</xtermref> property.</termdef></p>               

<p>For any decimal format, the properties
representing characters used in a <termref def="dt-picture-string">picture string</termref>
   must have distinct values. These properties are <xtermref spec="XP31" ref="id-static-decimal-format-decimal-separator">decimal-separator</xtermref> ,
   <xtermref spec="XP31" ref="id-static-decimal-format-grouping-separator">grouping-separator</xtermref>, 
   <xtermref spec="XP31" ref="id-static-decimal-format-exponent-separator">exponent-separator</xtermref>,
   <xtermref spec="XP31" ref="id-static-decimal-format-percent">percent</xtermref>, <xtermref spec="XP31" ref="id-static-decimal-format-per-mille">per-mille</xtermref>,
<xtermref spec="XP31" ref="id-static-decimal-format-digit">digit</xtermref>, and <xtermref spec="XP31" ref="id-static-decimal-format-pattern-separator">pattern-separator</xtermref>.
   Furthermore, none of these properties may be equal to any <termref def="character">character</termref> in the 
<termref def="dt-decimal-digit-family">decimal digit family</termref>.

</p>

            </div3>
		   
		   <div3 id="func-format-number">
		      <head><?function fn:format-number?></head>
		   </div3>
		   
            <div3 id="syntax-of-picture-string">
               <head>Syntax of the picture string</head>
			   <note><p>This differs from the <code>format-number</code> function previously defined in XSLT 2.0 in that
			   any digit can be used in the picture string to represent a mandatory digit: for example the picture
			   strings <code>"000"</code>, <code>"001"</code>, and <code>"999"</code> are equivalent.
			   The digits will all be from the same decimal digit family,
			   specifically, the sequence of ten consecutive digits starting with the digit assigned to the <var>zero-digit</var> property.
			      This change is to align <code>format-number</code> 
			   (which previously used <code>"000"</code>) with <code>format-dateTime</code> (which used <code>001</code>).</p></note>
               <p>
                  <termdef id="dt-picture-string" term="picture string">The formatting of a 
number is controlled by a <term>picture string</term>. The
                     picture string is a sequence of <termref def="character">characters</termref>, in which the characters
                     assigned to the properties <xtermref spec="XP31" ref="id-static-decimal-format-decimal-separator">decimal-separator</xtermref> , 
                     <xtermref spec="XP31" ref="id-static-decimal-format-exponent-separator">exponent-separator</xtermref>, 
                     <xtermref spec="XP31" ref="id-static-decimal-format-grouping-separator">grouping-separator</xtermref>, 
                     <xtermref spec="XP31" ref="id-static-decimal-format-digit">digit</xtermref>, 
                     and <xtermref spec="XP31" ref="id-static-decimal-format-pattern-separator">pattern-separator</xtermref> 
                     and the members of the <termref def="dt-decimal-digit-family">decimal digit family</termref>, are classified as
active characters, and all other characters (including the values of the properties <xtermref spec="XP31" ref="id-static-decimal-format-percent">percent</xtermref> and 
<xtermref spec="XP31" ref="id-static-decimal-format-per-mille">per-mille</xtermref>) are classified as passive characters.</termdef> 

               </p>
               
               <p>A dynamic error is raised <errorref class="DF" code="1310"/> if the
 <termref def="dt-picture-string">picture string</termref> does not conform to the following rules. 
               Note that in these
rules the words "preceded" and "followed" refer to characters anywhere in the string; they
are not to be read as "immediately preceded" and "immediately followed".</p>
               <ulist>
                  <item>
                     <p>A picture-string consists either of a sub-picture, or of
        two sub-pictures separated by the <xtermref spec="XP31" ref="id-static-decimal-format-pattern-separator">pattern-separator</xtermref> character. A picture-string
        <rfc2119>must not</rfc2119> contain more than one instance of the <xtermref spec="XP31" ref="id-static-decimal-format-pattern-separator">pattern-separator</xtermref> character. 
                        If the picture-string contains two
        sub-pictures, the first is used for positive and unsigned zero values and the second for negative values.</p>
                  </item>
                  <item>
                     <p>A sub-picture <rfc2119>must not</rfc2119> contain more than one instance of the 
                        <xtermref spec="XP31" ref="id-static-decimal-format-decimal-separator">decimal-separator</xtermref> character.</p>
                  </item>
                  <item>
                     <p>A sub-picture <rfc2119>must not</rfc2119> contain more than one instance of the 
                        <xtermref spec="XP31" ref="id-static-decimal-format-percent">percent</xtermref> or
        <xtermref spec="XP31" ref="id-static-decimal-format-per-mille">per-mille</xtermref> characters, and it <rfc2119>must not</rfc2119> contain one of each.</p>
                  </item>
                  <item>
                     <p>The <var>mantissa part</var> of a
                        sub-picture (defined below) <rfc2119>must</rfc2119> contain at least one character that is either 
                        an <termref def="dt-optional-digit-character">optional digit character</termref>
                        or a member of the <termref def="dt-decimal-digit-family">decimal digit family</termref>.</p>
                  </item>
                  <item>
                     <p>A sub-picture <rfc2119>must not</rfc2119> contain a passive character that is preceded by
        an active character and that is followed by another active character.</p>
                  </item>
                  <item>
                     <p>A sub-picture <rfc2119>must not</rfc2119> contain a <xtermref spec="XP31" ref="id-static-decimal-format-grouping-separator">grouping-separator</xtermref> 
                        character that appears adjacent to                        
                         a <xtermref spec="XP31" ref="id-static-decimal-format-decimal-separator">decimal-separator</xtermref>  character, 
                         or in the absence of a 
                           <xtermref spec="XP31" ref="id-static-decimal-format-decimal-separator">decimal-separator</xtermref>  character, 
                           at the end of the <var>integer part</var>.</p>
                  </item>
                  <item>
                     <p>A sub-picture <rfc2119>must not</rfc2119> contain two adjacent instances of the <xtermref spec="XP31" ref="id-static-decimal-format-grouping-separator">grouping-separator</xtermref> character.</p>
                  </item>
                  <item>
                     <p>The <var>integer part</var> of a sub-picture (defined below) <rfc2119>must not</rfc2119> contain 
                        a member of the <termref def="dt-decimal-digit-family">decimal digit family</termref> 
					 that is followed by
					 an instance of the <termref def="dt-optional-digit-character">optional digit character</termref>. 
                        The <var>fractional part</var> of a sub-picture (defined below) <rfc2119>must not</rfc2119> contain an instance of the 
                        <termref def="dt-optional-digit-character">optional digit character</termref>
                        that is followed by a member of the <termref def="dt-decimal-digit-family">decimal digit family</termref>.</p>
                  </item>
                  <item><p>A character that matches the <xtermref spec="XP31" ref="id-static-decimal-format-exponent-separator">exponent-separator</xtermref> property
                  is treated as an <var>exponent-separator-sign</var> if it is both preceded and followed
                  within the sub-picture by an active character. Otherwise, it is treated as a passive character. 
                  A sub-picture <rfc2119>must not</rfc2119> contain more than one character that is treated as an <var>exponent-separator-sign</var>.
                  </p></item>
                  <item><p>A sub-picture that contains a <xtermref spec="XP31" ref="id-static-decimal-format-percent">percent</xtermref> or
                     <xtermref spec="XP31" ref="id-static-decimal-format-per-mille">per-mille</xtermref> character <rfc2119>must not</rfc2119> contain a character treated as an
                     <var>exponent-separator-sign</var>.</p>
                  </item>
                  <item><p>If a sub-picture contains a character treated as an
                     <var>exponent-separator-sign</var> then this <rfc2119>must</rfc2119> be followed by
                     one or more characters that are members of the <termref def="dt-decimal-digit-family">decimal digit family</termref>,
                     and it <rfc2119>must not</rfc2119> be followed by any active character
                     that is not a member of the <termref def="dt-decimal-digit-family">decimal digit family</termref>.</p></item>
                     
               </ulist>
               
               <p>The <var>mantissa part</var> of the sub-picture is defined as the part that appears
               to the left of the <var>exponent-separator-sign</var> if there is one, or the entire
               sub-picture otherwise. The <var>exponent part</var> of the subpicture is defined as
                  the part that appears to the right of the <var>exponent-separator-sign</var>;
                  if there is no <var>exponent-separator-sign</var> then the <var>exponent part</var>
               is absent.</p>
               
               <p>The <var>integer part</var> of the sub-picture is defined as the part that
                  appears to the left of the <xtermref spec="XP31" ref="id-static-decimal-format-decimal-separator">decimal-separator</xtermref>  character if there is one, or the entire
                  <var>mantissa part</var> otherwise.</p> 
               
               <p>The <var>fractional part</var> of the sub-picture is defined as that
                  part of the <var>mantissa part</var> that
                  appears to the right of the <xtermref spec="XP31" ref="id-static-decimal-format-decimal-separator">decimal-separator</xtermref>  character if there is one, or the part that appears
                  to the right of the rightmost active character otherwise. The fractional part may be zero-length.</p>

            </div3>
            <div3 id="analyzing-picture-string">
               <head>Analyzing the picture string</head>
               <p>This phase of the algorithm analyzes 
                  the <termref def="dt-picture-string">picture string</termref> and the properties from the selected
decimal format in the static context, and it has the effect
of setting the values of various variables, which are used in the
subsequent formatting phase. These variables are listed below.
Each is shown with its initial setting and its datatype.
					</p>
               <p>Several variables are associated with each sub-picture. If there are
two sub-pictures, then these rules are applied to one sub-picture to obtain the values
that apply to positive and unsigned zero numbers, and to the other to obtain the values that apply
to negative numbers. If there is only one sub-picture, then the values for both cases
are derived from this sub-picture.</p>
               <p>The variables are as follows:</p>
               <ulist>
                  <item>
                     <p>The <var>integer-part-grouping-positions</var> is a sequence of integers
representing the positions of grouping separators within the integer part of the
sub-picture. For each <xtermref spec="XP31" ref="id-static-decimal-format-grouping-separator">grouping-separator</xtermref> character that appears within the
integer part of the sub-picture, this sequence contains an integer that is equal
to the total number of <termref def="dt-optional-digit-character">optional digit character</termref> and <termref def="dt-decimal-digit-family">decimal digit family</termref>
characters that appear within the integer part of the sub-picture and to the right of the 
<xtermref spec="XP31" ref="id-static-decimal-format-grouping-separator">grouping-separator</xtermref> character.</p>
                     <p>The grouping is defined to be <term>regular</term> if the following conditions apply:</p>
                     <olist>
                        <item><p>There is an least one grouping-separator in the integer part of the sub-picture.</p></item>
                        <item><p>There is a positive integer <var>G</var> (the grouping size) such that the position of every grouping-separator
                        in the integer part of the sub-picture is a positive integer multiple of <var>G</var>.</p></item>
                        <item><p>Every position in the integer part of the sub-picture that is a positive integer multiple of <var>G</var>
                        is occupied by a grouping-separator.</p></item>
                     </olist>
                     <p>If the grouping is regular, then the <var>integer-part-grouping-positions</var> sequence contains all
integer multiples of <var>G</var> as far as necessary to accommodate the largest 
possible number.</p>
                  </item>
                  <item>
                     <p>The <var>minimum-integer-part-size</var> is an integer indicating the minimum number of digits that will
 appear to the left of the <var>decimal-separator</var> character. It is initially set to 
 the number of <termref def="dt-decimal-digit-family">decimal digit family</termref> characters found in the integer part of the sub-picture,
                        but may be adjusted as described below. </p>
                     <note>
                        <p>There is no maximum integer part size. All significant digits in the integer part of the
                           number will be displayed, even if this exceeds the number of <termref def="dt-optional-digit-character">optional digit character</termref> and
 <termref def="dt-decimal-digit-family">decimal digit family</termref> characters in the subpicture.</p>
                     </note>
                  </item>
                  <item>
                     <p>The <var>scaling factor</var> is a non-negative integer used to determine the scaling of the mantissa
                        in exponential notation. It is set to the number of <termref def="dt-decimal-digit-family">decimal digit family</termref> 
                        characters found in the integer part of the sub-picture.</p>
                  </item>
                  <item>
                     <p>The <var>prefix</var> is set to contain all passive characters
in the sub-picture to the left of the leftmost active character.
If the picture string contains only one sub-picture, 
the <var>prefix</var> 
for the negative sub-picture is set by concatenating the <xtermref spec="XP31" ref="id-static-decimal-format-minus-sign">minus-sign</xtermref> 
character and the <var>prefix</var> for the positive sub-picture (if any),
in that order.</p>
                  </item>
                  <item>
                     <p>The <var>fractional-part-grouping-positions</var> is a sequence of integers
representing the positions of grouping separators within the fractional part of the
sub-picture. For each <xtermref spec="XP31" ref="id-static-decimal-format-grouping-separator">grouping-separator</xtermref> character that appears within the
fractional part of the sub-picture, this sequence contains an integer that is equal
to the total number of <termref def="dt-optional-digit-character">optional digit character</termref> and <termref def="dt-decimal-digit-family">decimal digit family</termref> 
characters that appear within the fractional part of the sub-picture and to the left of the 
<xtermref spec="XP31" ref="id-static-decimal-format-grouping-separator">grouping-separator</xtermref> character.</p>
                     <note><p>There is no need to extrapolate grouping positions on the fractional side,
                     because the number of digits in the output will never exceed the number of 
                        <termref def="dt-optional-digit-character">optional digit character</termref> and <termref def="dt-decimal-digit-family">decimal digit family</termref> characters
                     in the fractional part of the sub-picture.</p></note>
                  </item>
                  <item>
                     <p>The <var>minimum-fractional-part-size</var> is set to the number of 
<termref def="dt-decimal-digit-family">decimal digit family</termref> characters found in the fractional part of the sub-picture.</p>
                  </item>
                  <item>
                     <p>The <var>maximum-fractional-part-size</var> is set to the total number of 
                        <termref def="dt-optional-digit-character">optional digit character</termref> and 
                        <termref def="dt-decimal-digit-family">decimal digit family</termref> characters found 
                        in the fractional part of the sub-picture.</p>
                  </item>
                  <item>
                     <p>If the effect of the above rules is that <var>minimum-integer-part-size</var> and 
                        <var>maximum-fractional-part-size</var> are both zero, then an adjustment is applied as follows:</p>
                     <ulist>
                        <item><p>If an exponent separator is present then:</p>
                          <ulist>
                           <item><p><var>minimum-fractional-part-size</var> is changed to 1 (one).</p></item>
                           <item><p><var>maximum-fractional-part-size</var> is changed to 1 (one).</p></item>
                          </ulist>
                           <note><p>This has the effect that with the picture <code>#.e9</code>, the value <code>0.123</code> is formatted as <code>0.1e0</code></p></note>
                        </item>
                        <item><p>Otherwise:</p>
                          <ulist>
                           <item><p><var>minimum-integer-part-size</var> is changed to 1 (one).</p></item>
                          </ulist>
                           <note><p>This has the effect that with the picture <code>#</code>, the value <code>0.23</code> is formatted
                              as <code>0</code></p></note>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p>If all the following conditions are true:</p>
                     <ulist>
                        <item><p>An exponent separator is present</p></item>
                        <item><p>The <var>minimum-integer-part-size</var> is zero</p></item>
                        <item><p>There is at least one <termref def="dt-optional-digit-character">optional digit character</termref> 
                           in the integer part of the sub-picture</p></item>
                     </ulist>
                     <p>then the <var>minimum-integer-part-size</var> is changed to 1 (one).</p>
                     <note><p>This has the effect that with the picture <code>.9e9</code>, the value <code>0.1</code> is formatted
                        as <code>.1e0</code>, while with the picture <code>#.9e9</code>, it is formatted as <code>0.1e0</code></p></note>
                  </item>
                  <item>
                     <p>If (after making the above adjustments) the <var>minimum-integer-part-size</var> and the 
                        <var>minimum-fractional-part-size</var> are both zero, then the <var>minimum-fractional-part-size</var> is set to 1 (one).</p>
                  </item>
                  <item>
                     <p>The <var>minimum-exponent-size</var> is set to the number of 
                        <termref def="dt-decimal-digit-family">decimal digit family</termref> characters found in the exponent part of the sub-picture
                     if present, or zero otherwise.</p>
                     <note><p>The rules for the syntax of the picture string ensure that if an exponent
                        separator is present, then the <var>minimum-exponent-size</var> will always be greater than zero.</p></note>
                  </item>
                  <item>
                     <p>The <var>suffix</var> is set to contain all passive characters to the right of the rightmost
active character in the sub-picture.</p>
                  </item>
               </ulist>
               <note>
                  <p>If there is only one sub-picture, then all variables
for positive numbers and negative numbers will be the same, except for  
<var>prefix</var>: the prefix for negative numbers will 
be preceded by the <xtermref spec="XP31" ref="id-static-decimal-format-minus-sign">minus-sign</xtermref> character.</p>
               </note>
            </div3>
            <div3 id="formatting-the-number">
               <head>Formatting the number</head>
               <p>This section describes the second phase of processing of the
<function>fn:format-number</function> function. This phase takes as input a number to be formatted
(referred to as the <emph>input number</emph>), and the variables set up by
analyzing the decimal format in the static context and the
<termref def="dt-picture-string">picture string</termref>, as described above.
 The result of this phase is a string, which forms the return value of 
the <function>fn:format-number</function> function.</p>
               <p>The algorithm for this second stage of processing is as follows:</p>
               <olist>
                  <item>
                     <p>If the input number is <code>NaN</code> (not a number), the result is the 
							 value of the <xtermref spec="XP31" ref="id-static-decimal-format-NaN">pattern separator</xtermref> property (with no
<var>prefix</var> or <var>suffix</var>).</p>
                  </item>
                  <item>
                     <p>In the rules below, the positive sub-picture and its associated variables are used 
							 if the input number is positive, and the negative sub-picture and its associated
                      variables are used if it is negative. For <code>xs:double</code> and <code>xs:float</code>,
                      negative zero is taken as negative, positive zero as positive. For <code>xs:decimal</code>
                     and <code>xs:integer</code>, the positive sub-picture is used for zero.</p>
                  </item>
                  
                  <item>
                     <p>The <var>adjusted number</var> is determined as follows:</p>
                     <ulist>
                        <item><p>If the sub-picture contains a <xtermref spec="XP31" ref="id-static-decimal-format-percent">percent</xtermref> character, 
                           the <var>adjusted number</var> is the input number multiplied by 100.</p></item>
                        <item><p>If the sub-picture contains a <xtermref spec="XP31" ref="id-static-decimal-format-per-mille">per-mille</xtermref> character, 
                           the <var>adjusted number</var> is the input number multiplied by 1000.</p></item>
                        <item><p>Otherwise, the <var>adjusted number</var> is the input number.</p></item>
                     </ulist>
                     <p>If the multiplication causes numeric overflow, no error occurs, and the 
                        <var>adjusted number</var> is positive or negative infinity as appropriate.</p>
                         
                  </item>
                  
                  <item>
                     <p>If the <var>adjusted number</var> is positive or negative infinity, the result is the 
                        concatenation of the appropriate <var>prefix</var>, the value of the <xtermref spec="XP31" ref="id-static-decimal-format-infinity">infinity</xtermref> property,
                        and the appropriate <var>suffix</var>.</p>
                  </item>
                  <item>
                     <p>If the <var>minimum exponent size</var> is non-zero, 
                        <phrase diff="add" at="A">and the <var>adjusted number</var> is non-zero,</phrase> 
                        then the <var>adjusted number</var> is scaled to establish a 
                        <var>mantissa</var> and an integer <var>exponent</var>. The <var>mantissa</var> and <var>exponent</var> are chosen 
                        such that all the following conditions are true:</p>
                     <ulist>
                        <item><p>The primitive type of the <var>mantissa</var> is the same as the primitive type of the <var>adjusted number</var> (integer, decimal, float, or double).</p></item>
                        <item><p>The <var>mantissa</var> multiplied by ten to the power of the exp<var></var>onent is equal to the <var>adjusted number</var>.</p></item>
                        <item><p>The <var>mantissa</var> <phrase diff="add" at="B"><!--https://github.com/w3c/qtspecs/issues/22-->(unless it is zero)</phrase> 
                           is less than 10<sup>N</sup>, and at least 10<sup>N-1</sup>, where <var>N</var> is the <var>scaling factor</var>.</p></item>
                     </ulist>
                     <p>If the <var>minimum exponent size</var> is zero, then the <var>mantissa</var> is the <var>adjusted number</var> 
                        and there is no <var>exponent</var>.</p>
                     <p diff="add" at="A">If the <var>minimum exponent size</var> is non-zero and the <var>adjusted number</var> is zero,
                        then the <var>mantissa</var> is the <var>adjusted number</var> and the <var>exponent</var> is zero.</p>
                    
                  </item>
                  <item>
                     <p>The <var>mantissa</var> is converted (if necessary) to
 an <code>xs:decimal</code> value,
using an implementation of <code>xs:decimal</code> that imposes no limits on the
<code>totalDigits</code> or <code>fractionDigits</code> facets. If there are several 
such values that
are numerically equal to the <var>mantissa</var> (bearing in mind that if the
<var>mantissa</var> is an <code>xs:double</code> or <code>xs:float</code>, the comparison will be done by
converting the decimal value back to an <code>xs:double</code> or <code>xs:float</code>), the one that
is chosen <rfc2119>should</rfc2119> be one with the smallest possible number of digits
not counting leading or trailing zeroes (whether significant or insignificant). 
For example, 1.0 is preferred to
0.9999999999, and 100000000 is preferred to 100000001. This value is then
rounded so that it uses no more than <code>maximum-fractional-part-size</code> digits in
its fractional part. The <var>rounded number</var> is defined to be the result of
converting the <var>mantissa</var> to an <code>xs:decimal</code> value, as described above,
and then calling the function <function>fn:round-half-to-even</function> with this converted number
as the first argument and the <code>maximum-fractional-part-size</code> as the second
argument, again with no limits on the <code>totalDigits</code> or <code>fractionDigits</code> in the
result.</p>
                  </item>
                  <item>                    
                     <p>The absolute value of the <var>rounded number</var> is converted to a string in decimal notation, 
                        using the digits in the <termref def="dt-decimal-digit-family">decimal digit family</termref> to 
                        represent the ten decimal digits, and the <xtermref spec="XP31" ref="id-static-decimal-format-decimal-separator">decimal-separator</xtermref> 
                        character to separate the integer part and the fractional part. This string must always contain a 
                        <xtermref spec="XP31" ref="id-static-decimal-format-decimal-separator">decimal-separator</xtermref>, 
                        and it must contain no leading zeroes and no trailing zeroes. The value zero will at this stage be 
                        represented by a <xtermref spec="XP31" ref="id-static-decimal-format-decimal-separator">decimal-separator</xtermref> 
                        on its own.</p>
                  </item>
                  <item>
                     <p>If the number of digits to the left of the <xtermref spec="XP31" ref="id-static-decimal-format-decimal-separator">decimal-separator</xtermref>  character is less than
<var>minimum-integer-part-size</var>, leading <xtermref spec="XP31" ref="id-static-decimal-format-zero-digit">zero digit</xtermref> 
characters are added to pad out to that size.</p>
                  </item>
                  <item>
                     <p>If the number of digits to the right of the <xtermref spec="XP31" ref="id-static-decimal-format-decimal-separator">decimal-separator</xtermref>  character is less than
<var>minimum-fractional-part-size</var>, trailing <xtermref spec="XP31" ref="id-static-decimal-format-zero-digit">zero digit</xtermref> 
characters are added to pad out to that size.</p>
                  </item>
                  <item>
                     <p>For each integer <var>N</var> in the <var>integer-part-grouping-positions</var> list,  
a <xtermref spec="XP31" ref="id-static-decimal-format-grouping-separator">grouping-separator</xtermref> character is inserted into the string immediately
after that digit that appears in the integer part of the number and has <var>N</var> digits
between it and the <xtermref spec="XP31" ref="id-static-decimal-format-decimal-separator">decimal-separator</xtermref>  character, if there is such a digit.</p>
                  </item>
                  <item>
                     <p>For each integer <var>N</var> in the <var>fractional-part-grouping-positions</var> list,  
a <xtermref spec="XP31" ref="id-static-decimal-format-grouping-separator">grouping-separator</xtermref> character is inserted into the string immediately
before that digit that appears in the fractional part of the number and has <var>N</var> digits
between it and the <xtermref spec="XP31" ref="id-static-decimal-format-decimal-separator">decimal-separator</xtermref>  character, if there is such a digit.</p>
                  </item>
                  <item>
                     <p>If there is no <xtermref spec="XP31" ref="id-static-decimal-format-decimal-separator">decimal-separator</xtermref>  character in the sub-picture, 
or if there are no digits to the right of the 
<var>decimal-separator</var> character in the string, then the
<var>decimal-separator</var> character is removed from the string (it will be the rightmost 
character in the string).</p>
                  </item>
                  <item><p>If an <var>exponent</var> exists, then the string
                  produced from the <var>mantissa</var> as described above is extended with
                     the following, in order:
                  (a) the <xtermref spec="XP31" ref="id-static-decimal-format-exponent-separator">exponent-separator</xtermref> character; (b) if the <var>exponent</var> is negative,
                  the <xtermref spec="XP31" ref="id-static-decimal-format-minus-sign">minus-sign</xtermref> character; (c) the value of the <var>exponent</var> represented
                  as a decimal integer, extended if necessary with leading zeroes to make it up to
                  the <var>minimum exponent size</var>, using digits taken from the
                  <termref def="dt-decimal-digit-family">decimal digit family</termref>.</p></item>
                  <item>
                     <p>The result of the function is the concatenation of the appropriate <var>prefix</var>, the 
string conversion of the number as obtained above, and the appropriate <var>suffix</var>.</p>
                  </item>
               </olist>
            </div3>
         </div2>
		 <div2 id="trigonometry">
            <head>Trigonometric and exponential functions</head>
			

			<p>The functions in this section perform trigonometric and other mathematical calculations on <code>xs:double</code> values. They
			are provided primarily for use in applications performing geometrical computation, for example when generating 
			SVG graphics.</p>

			<p>Functions are provided to support the six most commonly used trigonometric calculations: sine, cosine and tangent, 
			and their inverses arc sine, arc cosine, and arc tangent. Other functions such as secant, cosecant, and cotangent are
			not provided because they are easily computed in terms of these six.</p>
		    
		   <p>The functions in this section (with the exception of <code>math:pi</code>) 
		      are specified by reference to <bibref ref="ieee754-2019"/>, where
		   they appear as <emph>Recommended operations</emph> in section 9. IEEE defines
		   these functions for a variety of floating point formats; this specification
		   defines them only for <code>xs:double</code> values. The IEEE specification
		   applies with the following caveats:</p>
		    
		    <olist>
		       <item><p>IEEE states that the preferred quantum is language-defined. In this
		       specification, it is <termref def="implementation-defined"/>.</p></item>
		       
		       <item><p>IEEE states that certain functions should raise the inexact exception if the
		          result is inexact. 
		          In this specification, this exception if it occurs does not
		          result in an error. Any diagnostic information is outside the scope of this
		          specification.</p></item>
		       <item><p>IEEE defines various rounding algorithms for inexact results, and states
		          that the choice of rounding direction, and the mechanisms for influencing this choice,
		          are language-defined. In this specification, the rounding direction and any mechanisms for
		          influencing it are <termref def="implementation-defined"/>.</p></item>
		       <item><p>Certain operations (such as taking the square root of a negative number)
		          are defined in IEEE to signal the invalid operation exception and return a
		          quiet <code>NaN</code>. In this specification, such operations return <code>NaN</code>
		          and do not raise an error. The same policy applies to operations (such as taking
		          the logarithm of zero) that raise a divide-by-zero exception. Any diagnostic 
		          information is outside the scope of this specification. </p></item>
		       <item><p>Operations whose mathematical result is greater than the largest finite <code>xs:double</code>
		          value are defined in IEEE to signal the overflow exception; operations whose mathematical
		          result is closer to zero than the smallest non-zero <code>xs:double</code> value are similarly
		       defined in IEEE to signal the underflow exception. The treatment of these exceptions in
		       this specification is defined in <specref ref="op.numeric"/>.</p></item>
		    </olist>
		       

		    <?local-function-index?>
			
		    <p></p>
    
    
			   <div3 id="func-math-pi">
               <head><?function math:pi?></head>
			   </div3>
			   <div3 id="func-math-e">
               <head><?function math:e?></head>
			   </div3>
		    <div3 id="func-math-exp">
		         <head><?function math:exp?></head>
		      </div3>
		    <div3 id="func-math-exp10">
		       <head><?function math:exp10?></head>
		    </div3>
		    <div3 id="func-math-log">
		       <head><?function math:log?></head>
		    </div3>
		    <div3 id="func-math-log10">
		       <head><?function math:log10?></head>
		    </div3>
		    <div3 id="func-math-pow">
		       <head><?function math:pow?></head>
		    </div3>
		    <div3 id="func-math-sqrt">
               <head><?function math:sqrt?></head>
		      </div3>
		    <div3 id="func-math-sin">
              <head><?function math:sin?></head>
		      </div3>
		    <div3 id="func-math-cos">
              <head><?function math:cos?></head>
		      </div3>
		    <div3 id="func-math-tan">
              <head><?function math:tan?></head>
		      </div3>
		    <div3 id="func-math-asin">
              <head><?function math:asin?></head>
            </div3>
		    <div3 id="func-math-acos">
              <head><?function math:acos?></head>
		      </div3>
		    <div3 id="func-math-atan">
              <head><?function math:atan?></head>
            </div3>
		    <div3 id="func-math-atan2">
		       <head><?function math:atan2?></head>
		    </div3>
		    <div3 id="func-math-sinh">
              <head><?function math:sinh?></head>
		      </div3>
		    <div3 id="func-math-cosh">
              <head><?function math:cosh?></head>
		      </div3>
		    <div3 id="func-math-tanh">
              <head><?function math:tanh?></head>
		      </div3>
		   </div2>
         <div2 id="random-numbers">
            <head>Random Numbers</head>
            <?local-function-index?>
            
            <p>The function makes use of the record structure defined in the next section.</p>
            <div3 id="random-number-generator-record">
               <head><?record-description random-number-generator-record?></head>
            </div3>
            <div3 id="func-random-number-generator">
               <head><?function fn:random-number-generator?></head>
            </div3>
         </div2>
      </div1>
      <div1 id="string-functions">
         <head>Processing strings</head>
         <p>This section specifies functions and operators on the <bibref ref="xmlschema-2"/>
                <code>xs:string</code> datatype and the datatypes derived from it.</p>
         <div2 id="string-types">
            <head>String types</head>
            <p>The operators described in this section are defined on the following types.</p>

            &common-string-types.xml;

            <p>They also apply to user-defined types derived by restriction from the above types. </p>
            
         </div2>
         <div2 id="func-assemble-disassemble-string">
            <head>Functions to assemble and disassemble strings</head>
            <?local-function-index?>
            <div3 id="func-codepoints-to-string">
               <head><?function fn:codepoints-to-string?></head>
            </div3>
            <div3 id="func-string-to-codepoints">
				<head><?function fn:string-to-codepoints?></head>
            </div3>
         </div2>
         <div2 id="string-compare">
            <head>Comparison of strings</head>
            <?local-function-index?>
            <div3 id="collations">
               <head>Collations</head>
               <p><termdef id="dt-collation" term="collation"> A <term>collation</term> 
                  is an algorithm that determines, for any two given strings
                  <var>S1</var> and <var>S2</var>, whether <var>S1</var> is less than,
                  equal to, or greater than <var>S2</var>. In this specification,
                  a collation is identified by an absolute URI.</termdef></p>
               
               <p>The <bibref ref="charmod"/> observes that
                        different applications may require different comparison and ordering behaviors. 
                        Similarly, different users with different linguistic
                        expectations may require different behaviors. Consequently,
                        the collation must be taken into account when comparing strings.</p>
               
               <p>Collations can indicate that two different codepoints are to be considered equal
                        for comparison purposes (for example, “v” and “w” are considered equivalent in
                        some Swedish collations). Strings can be compared codepoint-by-codepoint or in a
                        linguistically appropriate manner.</p>
               <note>
                  <p>Some sources, for example <bibref ref="UNICODE-TR10"/> use the term <term>collation</term>
                     to refer more generically to a set of sorting rules that can be further parameterized
                     or “tailored”. In this specification the term is always used for a specific algorithm
                     in which all such parameters have defined values.</p>
               </note>
               
               <p>This specification defines some collation URIs that provide interoperable
               sorting behavior across applications. Other collation URIs are defined only
               partially (leaving some aspects implementation-defined). Implementations may
               define further collation URIs, or may allow users or third parties to define them.</p>
               
               <p>The <termref def="dt-codepoint-collation">Unicode codepoint collation</termref> is 
                  available in every implementation. This collation sorts based on codepoint values. For further details
                  see <specref ref="codepoint-collation"/>.</p>

               
               <p>Collations may or may not perform Unicode normalization on strings before comparing them.</p>
               
               <p>This specification allows a collation
                        name to be provided as an argument to many string functions. Although
                        collations are defined to be URIs, they are supplied as instances of
                        <code>xs:string</code>.</p>
               
               <p>The XQuery/XPath static context supplies a default collation
               for use when the collation argument is not specified.
               (see <xspecref spec="XP31" ref="static_context"/>). 
					If the default collation is not specified by the
               user or the system, the default collation is the 
               <termref def="dt-codepoint-collation">Unicode codepoint collation</termref>.</p>
             
               
               <p>If the collation is specified using a relative URI reference, 
                  it is resolved relative to an <termref def="impl-def">implementation-defined</termref> base URI.</p>
               <note><p>Previous versions of this specification stated that it must
               be resolved against the <xtermref spec="XP40" ref="dt-static-base-uri"/>, but this is not always
               operationally convenient. It is <rfc2119>recommended</rfc2119> that processors should provide
               a means of setting the base URI for resolving collation URIs independently of the 
                  <xtermref spec="XP40" ref="dt-static-base-uri"/>, though for backwards compatibility, 
                  the <xtermref spec="XP40" ref="dt-static-base-uri">Static Base URI</xtermref> or 
                  <xtermref spec="XP40" ref="dt-executable-base-uri">Executable Base URI</xtermref> 
                  should be used as a default.</p></note>
               
               <p>This specification does not define whether or not the collation URI is
					dereferenced. The collation URI may be an abstract identifier, or it may
					refer to an actual resource describing the collation. If it refers to a
					resource, this specification does not define the nature of that resource.
					One possible candidate is that the resource is a locale description
					expressed using the Locale Data Markup Language: see <bibref ref="UNICODE-TR35"/>.
					</p>
               <!--<p>Functions such as <function>fn:compare</function> and <function>fn:max</function> that
                        compare <code>xs:string</code> values use a single collation URI to identify
                        all aspects of the collation rules. This means that any parameters such as
                        the strength of the collation must be specified as part of the collation
                        URI. For example, suppose there is a collation 
                            <code>http://www.example.com/collations/French</code>
                         that refers to a French collation that compares on the basis of
                        base characters. Collations that use the same basic rules, but with higher
                        strengths, for example, base characters and accents, or base characters,
                        accents and case, would need to be given different names, say 
                            <code>http://www.example.com/collations/French1</code>
                         and 
                            <code>http://www.example.com/collations/French2</code>. 
                  Note that some specifications use the term collation to refer to
                        an algorithm that can be parameterized, but in this specification, each
                        possible parameterization is considered to be a distinct collation.</p>-->
               <note>
                  <p>XML allows elements to specify the <code>xml:lang</code> attribute to
                     indicate the language associated with the content of such an element.
                     This specification does not use <code>xml:lang</code> to identify the
                     default collation because using
                     <code>xml:lang</code> does not produce desired effects when the two
                     strings to be compared have different <code>xml:lang</code> values or
                     when a string is multilingual. </p>
               </note> 
            </div3>
            <div3 id="collation-capabilities">
               <head>Collation Capabilities</head>
               <p>All collations support the ability to compare two strings to decide
               whether they are equal, and if not, which one should sort first. This
               must always define a total ordering, which implies that the comparison
               is transitive.</p>
               <p>A collation may (or may not) support the ability to derive a <term>collation key</term>
                  for a given string. A collation key is a binary value obtained as a function
                  of a string <var>S</var> and a collation <var>C</var>, 
                  such that the collation keys for two strings <var>S1</var> and <var>S2</var>
                  have the same ordering relationship (less than, equal, or greater than) as
                  the two strings themselves, when compared under the relevant collation.
                  Collation keys are useful for operations such as indexing, because they
                  can be used as keys in maps. They are available using the 
                  <function>fn:collation-key</function> function.</p>
               <p>Furthermore, a collation may (or may not) support the ability to determine whether
               one string is a substring of another under that collation. The use of collations
               in substring matching is described in <specref ref="substring.functions"/>.</p>
               <p>The capabilities of a collation may be determined using the 
               <function>fn:collation-available</function> function.</p>
            </div3>
            <div3 id="codepoint-collation">
               <head>The Unicode Codepoint Collation</head>
               <p><termdef id="dt-codepoint-collation" term="Unicode codepoint collation">The collation URI
                  <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code> identifies
               a collation which must be recognized by every implementation: it is referred to as
               the <term>Unicode codepoint collation</term> (not to be confused with the Unicode collation algorithm).</termdef></p>
               
               <p>The Unicode codepoint collation does not perform any normalization on the
               supplied strings.</p> 
               
               <p>The collation is defined as follows. Each of the two strings is
               converted to a sequence of integers using the <function>fn:string-to-codepoints</function>
               function. These two sequences <code>$A</code> and <code>$B</code> are then compared as follows: </p>
               
               <olist>
                  <item><p>If both sequences are empty, the strings are equal.</p></item>                
                  <item><p>If one sequence is empty and the other is not, then the string
                     corresponding to the empty sequence is less than the other string.</p></item>
                  <item><p>If the first integer in <code>$A</code> is less than the first integer in <code>$B</code>, then
                     the string corresponding to <code>$A</code> is less than the string corresponding to
                     <code>$B</code>.
                  </p></item>
                  <item><p>If the first integer in <code>$A</code> is greater than the first integer in <code>$B</code>, then
                     the string corresponding to <code>$A</code> is greater than the string corresponding to
                     <code>$B</code>.</p></item>
                  <item><p>Otherwise (the first pair of integers are equal), the result is obtained
                    by applying the same rules recursively to <code>fn:tail($A)</code> and
                    <code>fn:tail($B)</code></p></item>
               </olist>
               
               <note><p>While the Unicode codepoint collation does not produce results suitable for quality publishing of
               printed indexes or directories, it is adequate for many purposes where a restricted alphabet
               is used, such as sorting of vehicle registrations.</p></note>
               
               <note><p>The Unicode codepoint collation differs from the
               default sort order used in programming languages that sort strings
               based on UTF-16 code units, which may include surrogate pairs.</p></note>
            </div3>
            <div3 id="uca-collations">
               <head>The Unicode Collation Algorithm</head>
               
               <p>This specification defines a family of collation URIs representing tailorings of the Unicode Collation
                  Algorithm (UCA) as defined in <bibref ref="UNICODE-TR10"/>. The parameters used for tailoring the UCA
                  are based on the parameters defined in the Locale Data Markup Language (LDML), defined in <bibref ref="UNICODE-TR35"/>.</p>
               
               <p>This family of URIs use the scheme and path <code>http://www.w3.org/2013/collation/UCA</code>
                  followed by an optional query part. The query part, if present, consists of a question mark followed
                  by a sequence of zero or more semicolon-separated parameters. Each parameter is a keyword-value pair, the
                  keyword and value being separated by an equals sign.</p>
               
               <p>All implementations must recognize URIs in this family in the <code>collation</code> argument of functions that
                  take a collation argument.</p> 
                  
               <p>If the <code>fallback</code> parameter is
                  present with the value <code>no</code>, then the implementation <rfc2119>must</rfc2119> either use a collation that conforms with
                  the rules in the Unicode specifications for the requested tailoring, or fail with a static or dynamic error indicating that it
                  does not provide the collation (the error code should be the same as if the collation URI were not recognized). 
                  If the <code>fallback</code> parameter
                  is omitted or takes the value <code>yes</code>, and if the collation URI is well-formed according to the rules in this section,
                  then the implementation <rfc2119>must</rfc2119> accept the collation URI, and <rfc2119>should</rfc2119> use the available
                  collation that most closely reflects the user’s intentions. For example, if the collation URI requested is
                  <code>http://www.w3.org/2013/collation/UCA?lang=se;fallback=yes</code> and the implementation does not include a fully
                  conformant version of the UCA tailored for Swedish, then it <rfc2119>may</rfc2119> choose to use a Swedish collation that is known to differ
                  from the UCA definition, or one whose conformance has not been established. It might even, as a last resort, fall back to using
                  codepoint collation.</p>
               <p>If two query parameters use the same keyword then the last one wins. If a query parameter uses a keyword or value which is not
                  defined in this specification then the meaning is <termref def="implementation-defined"/>. If the implementation recognizes
                  the meaning of the keyword and value then it <rfc2119>should</rfc2119> interpret it accordingly; if it does not recognize
                  the keyword or value then if the <code>fallback</code> parameter is present with the value <code>no</code> it should reject
                  the collation as unsupported, otherwise it should ignore the unrecognized parameter.</p>
               
               <p>The following query parameters are defined. If any parameter is absent, the default is <termref def="implementation-defined"/>
                  except where otherwise stated.
                  The meaning given for each parameter is non-normative; the normative specification is found in <bibref ref="UNICODE-TR35"/>.</p>
               
               <table role="longlastcol data">
                  <thead>
                     <tr><th>Keyword</th><th>Values</th><th>Meaning</th></tr>
                  </thead>
                  <tbody>
                     <tr><td>fallback</td><td>yes | no (default yes)</td><td>Determines whether the processor uses a fallback collation if a conformant collation is not available.</td></tr>
                     <tr><td>lang</td><td>language code: a string in the lexical space of <code>xs:language</code>.</td><td>The language whose collation conventions are to be used.</td></tr>
                     <tr><td>version</td><td>string</td><td>The version number of the UCA to be used.</td></tr>
                     <tr><td>strength</td><td>primary | secondary | tertiary | quaternary | identical, or 
                        1|2|3|4|5 as synonyms (default tertiary / 3)</td><td>The collation strength as defined in UCA. Primary 
                           strength takes only the base form of the character into account (so A=a=&Aumlaut;=&aumlaut;); secondary strength ignores case but considers accents
                           and diacritics as significant (so A=a and &Aumlaut;=&aumlaut; but &aumlaut;&ne;a); tertiary considers case as significant (A&ne;a&ne;&Aumlaut;&ne;&aumlaut;); quaternary strength always considers as significant spaces and punctuation 
                           (data-base≠database; if <code>maxVariable</code> is <code>punct</code> or higher and 
                           <code>alternate</code> is not <code>non-ignorable</code>, lower strengths will treat data-base=database).</td></tr>
                     <tr><td>maxVariable</td><td>space | punct | symbol | currency (default punct)</td><td>
                        Given the sequence <code>space</code>, <code>punct</code>, <code>symbol</code>, <code>currency</code>, 
                        all characters in the specified group and earlier groups are treated as “noise” characters 
                        to be handled as defined by the <code>alternate</code> parameter. For example, <code>maxVariable=punct</code> indicates 
                        that characters classified as whitespace or punctuation get this treatment.</td></tr>
                     <tr><td>alternate</td><td>non-ignorable | shifted | blanked (default non-ignorable)</td><td>Controls the handling of characters such as spaces and hyphens;
                     specifically, the "noise" characters in the groups selected by the <code>maxVariable</code> parameter. The value <code>non-ignorable</code>
                     indicates that such characters are treated as distinct at the primary level (so <code>data base</code> sorts before <code>database</code>);
                     <code>shifted</code> indicates that they are used to differentiate two strings only at the <code>quaternary</code> level,
                     and <code>blanked</code> indicates that they are taken into account only at the <code>identical</code> level.</td></tr>
                     <tr><td>backwards</td><td>yes | no (default no)</td><td>The value <code>backwards=yes</code> indicates that the last accent in the 
                           string is the most significant.</td></tr>
                     <tr><td>normalization</td><td>yes | no (default no)</td><td>Indicates whether strings 
                           are converted to normalization form D.</td></tr>
                     <tr><td>caseLevel</td><td>yes | no (default no)</td><td>When used with primary strength, setting <code>caseLevel=yes</code> has the effect of ignoring accents
                        while taking account of case.</td></tr>
                     <tr><td>caseFirst</td><td>upper | lower (default lower)</td><td>Indicates whether upper-case precedes lower-case or vice versa.</td></tr>
                     <tr><td>numeric</td><td>yes | no (default no)</td><td>When <code>numeric=yes</code> is specified, a sequence of consecutive digits is interpreted as a number,
                        for example <code>chap2</code> sorts before <code>chap12</code>.</td></tr>
                     <tr><td>reorder</td><td>a comma-separated sequence of reorder codes, where a reorder code is one of <code>space</code>, <code>punct</code>,
                        <code>symbol</code>, <code>currency</code>, <code>digit</code>, or a four-letter script code defined in <bibref ref="ISO15924_register"/>, the register
                        of scripts maintained by the Unicode Consortium in its capacity as registration authority for <bibref ref="ISO15924"/>.</td>
                        <td>Determines the relative ordering of text in different scripts; for example the value <code>digit,Grek,Latn</code> indicates
                           that digits precede Greek letters, which precede Latin letters.</td></tr>
                     
                     
                  </tbody>
               </table>
               
               <note><p>This list excludes parameters that are inconvenient to express in a URI, 
                  or that are applicable only to substring matching.</p></note>
               
               <p>UCA collation URIs can be conveniently generated using the
                  <function>fn:collation</function> function.</p>
            </div3>
            <div3 id="html-ascii-case-insensitive-collation" diff="chg" at="issue668">
               <head>The HTML ASCII Case-Insensitive Collation</head>
               
               <changes>
                  <change issue="668" PR="680" date="2023-09-05">
                     The case-insensitive collation is now defined normatively within this specification, rather than
                     by reference to the HTML "living specification", which is subject to change. The collation can now
                     be used for ordering comparisons as well as equality comparisons.
                  </change>
               </changes>
              
               <p>The collation URI <code>http://www.w3.org/2005/xpath-functions/collation/html-ascii-case-insensitive</code> must be recognized
                  by every implementation. It is <phrase diff="chg" at="issue668">designed to be compatible with</phrase> 
               the HTML ASCII case-insensitive collation as defined in <bibref ref="html5"/> (section 4.6, <emph>Strings</emph>), 
                  which is used, for example, when matching HTML <code>class</code> attribute values.</p>
               
               <p>The collation is defined as follows:</p>
               
               <ulist>
                  <item><p>Let <code>$HACI</code> be the collation URI 
                     <code>"http://www.w3.org/2005/xpath-functions/collation/html-ascii-case-insensitive"</code>.</p></item>
                  <item><p>Let <code>$UCC</code> be the Unicode Codepoint Collation URI
                     <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>.</p></item>
                  <item><p>Let <code>$lc</code> be the function <code>
                  fn:translate(?, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz")</code>.</p></item>
                  <item><p>Then for any two strings <code>$A</code> and <code>$B</code>, the result
                     of the comparison <code>fn:compare($A, $B, $HACI)</code> is defined to be the same as
                  the result of <code>fn:compare($lc($A), $lc($B), $UCC)</code>.</p></item>
               </ulist>
   
               
               <note><p>HTML5 defines the semantics of equality matching using this collation; <phrase diff="add" at="issue668">this
                  specification additionally defines ordering rules. </phrase>
                  The collation supports collation units and can therefore
               be used with functions such as <function>fn:contains</function>; each Unicode codepoint is a single collation unit.</p>
               
                  <p>The corresponding HTML5 definition is: A string <var>A</var> is an ASCII case-insensitive match 
                     for a string <var>B</var>, if the ASCII lowercase of <var>A</var> is the ASCII lowercase of <var>B</var>.</p></note>
            </div3>
			<div3 id="choosing-a-collation">
				<head>Choosing a collation</head>
			   <p diff="chg" at="2023-07-04">Many functions have a signature that includes a <code>$collation</code>
			   argument, which is generally optional and takes <code>default-collation()</code>
			      as its default value.</p>

               <p>The collation to use for these functions is determined by the following rules:</p>
               <olist>
                  <item>
                     <p>If the function specifies an explicit collation, CollationA (e.g., if
                                the optional collation argument is specified in a call of the
                                <function>fn:compare</function> function), then:</p>
                     <ulist>
                        <item>
                           <p>If CollationA is supported by the implementation, then
                                        CollationA is used. </p>
                        </item>
                        <item>
                           <p>Otherwise, a dynamic error is raised <errorref class="CH" code="0002"/>. </p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p>If no collation is explicitly specified for the function 
                        <phrase diff="add" at="2023-07-04">(that is,
                        if the <code>$collation</code> argument is omitted or is set to an
                        empty sequence)</phrase>, and the
                        default collation in the XQuery/XPath static context is CollationB, then:</p>
                     <ulist>
                        <item>
                           <p>If CollationB is supported by the implementation, then
                                        CollationB is used. </p>
                        </item>
                        <item>
                           <p>Otherwise, a dynamic error is raised <errorref class="CH" code="0002"/>. </p>
                        </item>
                     </ulist>
                  </item>
               </olist>
			   
			   <note><p>Because the set of collations that are supported is <termref def="implementation-defined">implementation-defined</termref>,
			   an implementation has the option to support all collation URIs, in which case it will never raise this error.</p></note>
            
			   <p>If the value of the collation argument is a relative URI reference, it is resolved against the base-URI from the
			      static context. If it is a relative URI reference and cannot be resolved, perhaps because the base-URI property in the static context
			      is absent, a dynamic error is raised <errorref class="CH" code="0002"/>.</p>
			   
			   <note><p>There is no explicit requirement that the string used as a collation URI be a valid URI.
			   Implementations will in many cases reject such strings on the grounds that do not identify a supported collation; they
			   may also cause an error if they cannot be resolved against the <phrase diff="chg" at="2023-05-19">relevant</phrase> base URI.</p></note>
            
            </div3>
            <div3 id="func-codepoint-equal">
               <head><?function fn:codepoint-equal?></head>
            </div3>
            <div3 id="func-collation">
               <head><?function fn:collation?></head>
            </div3>
            <div3 id="func-collation-available">
               <head><?function fn:collation-available?></head>
            </div3>
            <div3 id="func-collation-key">
               <head><?function fn:collation-key?></head>
            </div3>
            <div3 id="func-contains-token">
               <head><?function fn:contains-token?></head>
            </div3>
         </div2>
         <div2 id="string-value-functions">
            <head>Functions on string values</head>
            <p>The following functions are defined on values of type <code>xs:string</code> and
                    types derived from it.</p>
            <?local-function-index?>
            <notes>
               <p>When the above operators and functions are applied to datatypes derived from
                        <code>xs:string</code>, they are guaranteed to return values that are instances of
                        <code>xs:string</code>, but the value might or might not be an instance of the
                        particular subtype of <code>xs:string</code> to which they were applied. </p>
               <p>The strings returned by <function>fn:concat</function> and <function>fn:string-join</function> are not guaranteed to be normalized.  
			   But see note in <function>fn:concat</function>.
                </p>
            </notes>
            <div3 id="func-char" diff="add" at="2022-11-19">
               <head><?function fn:char?></head>
            </div3>
            <div3 id="func-characters" diff="add" at="A">
               <head><?function fn:characters?></head>
            </div3>
            <div3 id="func-graphemes" diff="add" at="A">
               <head><?function fn:graphemes?></head>
            </div3>
            <div3 id="func-concat">
               <head><?function fn:concat?></head>
            </div3>
            <div3 id="func-string-join">
               <head><?function fn:string-join?></head>
            </div3>
            <div3 id="func-substring">
			   <head><?function fn:substring?></head>
            </div3>
            <div3 id="func-string-length">
               <head><?function fn:string-length?></head>              
            </div3>
            <div3 id="func-normalize-space">
               <head><?function fn:normalize-space?></head>
            </div3>
            <div3 id="func-normalize-unicode">
               <head><?function fn:normalize-unicode?></head>
            </div3>
            <div3 id="func-upper-case">
               <head><?function fn:upper-case?></head>
            </div3>
            <div3 id="func-lower-case">
               <head><?function fn:lower-case?></head>
            </div3>
            <div3 id="func-translate">
               <head><?function fn:translate?></head>
            </div3>
            <div3 id="func-hash">
               <head><?function fn:hash?></head>
            </div3>
         </div2>
         <div2 id="substring.functions">
            <head>Functions based on substring matching</head>
            <p>The functions described in this section examine a string <code>$arg1</code> to see
                    whether it contains another string <code>$arg2</code> as a substring. The result
                    depends on whether <code>$arg2</code> is a substring of <code>$arg1</code>, and
               if so, on the range of <termref def="character">characters</termref> in <code>$arg1</code> which <code>$arg2</code> matches.</p>
            <p>When the <termref def="dt-codepoint-collation">Unicode codepoint collation</termref>
                    is used, this simply involves determining whether <code>$arg1</code> contains a
               contiguous sequence of characters whose <termref def="codepoint">codepoints</termref> are the same, one for one,
                    with the codepoints of the characters in <code>$arg2</code>.</p>
            <p>When a collation is specified, the rules are more complex.</p>
            <p>All collations support the capability of deciding whether two <termref def="string">strings</termref> are
                    considered equal, and if not, which of the strings should be regarded as
                    preceding the other. For functions such as <function>fn:compare</function>, this is
                    all that is required. For other functions, such as <function>fn:contains</function>,
                    the collation needs to support an additional property: it must be able to
                    decompose the string into a sequence of collation units, each unit consisting of
                    one or more characters, such that two strings can be compared by pairwise
                    comparison of these units. (“collation unit” is equivalent to "collation
                    element" as defined in <bibref ref="UNICODE-TR10"/>.) The string
                    <code>$arg1</code> is then considered to contain <code>$arg2</code> as a
                    substring if the sequence of collation units corresponding to <code>$arg2</code>
                    is a subsequence of the sequence of the collation units corresponding to
                    <code>$arg1</code>. The characters in <code>$arg1</code> that match are the
                    characters corresponding to these collation units.</p>
            <p>This rule may occasionally lead to surprises. For example, consider a collation
                    that treats <code>"Jaeger"</code> and <code>"J&aumlaut;ger"</code>
                    as equal. It might do this by treating <code>"&aumlaut;"</code> as representing
                    two collation units, in which case the
                    expression <code>fn:contains("J&aumlaut;ger", "eg")</code> will return
                    <code>true</code>. Alternatively, a collation might treat "ae" as a single
                    collation unit, in which case the expression <code>fn:contains("Jaeger",
                    "eg")</code> will return <code>false</code>. The results of these functions thus
                    depend strongly on the properties of the collation that is used.</p>
				<p>In addition,
                    collations may specify that some collation units should be ignored during matching. If hyphen is an ignored
					collation unit, then <code>fn:contains("code-point", "codepoint")</code> will be <code>true</code>, 
					and <code>fn:contains("codepoint", "-")</code> will also be <code>true</code>.</p>
            <p> In the definitions below, we refer to the terms <term>match</term> and
                    <term>minimal match</term> as defined in definitions DS2 and DS4 of 
                    <bibref ref="UNICODE-TR10"/>. In applying these definitions:</p>
            <ulist>
               <item>
                  <p>
                     <var>C</var> is the collation; that is, the value of the <code>$collation</code>
                    argument if specified, otherwise the default collation.</p>
               </item>
               <item>
                  <p>
                     <var>P</var> is the (candidate) substring <code>$arg2</code>
                  </p>
               </item>
               <item>
                  <p>
                     <var>Q</var> is the (candidate) containing string <code>$arg1</code>
                  </p>
               </item>
               <item>
                  <p>The boundary condition <var>B</var> is satisfied at the start and end of a
                    string, and between any two characters that belong to different collation units
                    (“collation elements” in the language of <bibref ref="UNICODE-TR10"/>). It
                    is not satisfied between two characters that belong to the same collation unit.</p>
               </item>
            </ulist>
            <p>It is possible to define collations that do not have the ability to decompose a
                    string into units suitable for substring matching. An argument to a function
                    defined in this section may be a URI that identifies a collation that is able to
                    compare two strings, but that does not have the capability to split the string
                    into collation units. Such a collation may cause the function to fail, or to
                    give unexpected results, or it may be rejected as an unsuitable argument. The
                    ability to decompose strings into collation units is an 
               <termref def="implementation-defined"/> property of the collation.
            The <function>fn:collation-available</function> function can be used to ask
            whether a particular collation has this property.</p>
            <?local-function-index?>
            <div3 id="func-contains">
               <head><?function fn:contains?></head>
            </div3>
            <div3 id="func-starts-with">
               <head><?function fn:starts-with?></head>
            </div3>
            <div3 id="func-ends-with">
               <head><?function fn:ends-with?></head>
            </div3>
            <div3 id="func-substring-before">
               <head><?function fn:substring-before?></head>
            </div3>
            <div3 id="func-substring-after">
               <head><?function fn:substring-after?></head>
            </div3>
         </div2>
      </div1>
         <div1 id="string.match">
            <head>Regular expressions</head>
            <p>The functions described in this section make use of a regular expression
                    syntax for pattern matching. The syntax and semantics of regular
                    expressions are defined in this section.</p>
            
            <div2 id="regex-syntax">
               <head>Regular expression syntax</head>
               <changes>
                  <change issue="999" PR="1022" date="2024-02-20">
                     Regular expressions can include comments (starting and ending with <code>#</code>)
                     if the <code>c</code> flag is set.
                  </change>
                  <change issue="998 1006" PR="1856">
                     Word boundaries can be matched. Lookahead and lookbehind assertions are supported.
                     Assertions (including <code>^</code> and <code>$</code>) can no longer be followed
                     by a quantifier.
                  </change>
               </changes>
               <p>The regular expression syntax used by these functions is defined in terms of
                        the regular expression syntax specified in XSD 1.1 (see <bibref ref="xmlschema11-2"/>), 
                  which in turn is based on the established conventions of
                        languages such as Perl. However, because XML Schema uses regular expressions
                        only for validity checking, it omits some facilities that are widely used
                        with other languages. XPath, therefore, extends
                        the XML Schema regular expression syntax to reinstate some of these capabilities.</p>
               <note>
                  <p>
                   Implementers should consult <bibref ref="UNICODE-TR18"/> for information on using 
                     regular expression processing on Unicode characters.</p>
               </note>
               <p>The regular expression syntax and semantics are identical to those
                            defined in <bibref ref="xmlschema11-2"/> with the additions described in the 
                  following subsections.</p>
               
               <note><p>In <bibref ref="xmlschema11-2"/> there are no substantive technical changes
                  to the syntax or semantics of regular expressions relative to <bibref ref="xmlschema-2"/>, but a number
                  of errors and ambiguities have been resolved. For example, the rules for the 
                  interpretation of hyphens within square brackets in a regular expression have been 
                  clarified; and the semantics of regular expressions are no longer tied to a specific 
                  version of Unicode.</p>
                  <p>XSD 1.1 is therefore used as the specification baseline, 
                     even for processors that only support XSD 1.0.</p>
               
               </note>
               
               <div3 id="id-regex-processing-model">
                  <head>Processing model for regular expressions</head>
                  
                  <p>As well as extending the XSD 1.1 syntax for regular expressions, this specification
                  also extends the processing model.</p>
                  
                  <p>In XSD, a regular expression is defined to denote a set of strings, and the
                  only functionality offered is to test whether a string matches a regular expression:
                  that is, whether it is a member of the set of strings denoted by the regular expression.</p>
               
                  <p>In this specification, matching a string <var>S</var> against a regular expression delivers a more
                  complex outcome.</p>
                     
                  <p>First some terminology:</p>
                     
                  <ulist>
                     <item><p><termdef id="dt-character-position" term="character position">A string of
                     length <var>N</var> has <var>N+1</var> <term>character positions</term>: one immediately before
                     each character in the string, and one after the last character. In interfaces where
                     character positions are exposed, they are numbered from 1 to <var>N+1</var>.</termdef></p></item>
                     <item><p><termdef id="dt-segment" term="segment">A <term>segment</term> of a string <var>S</var> is
                     a sequence of zero or more contiguous characters starting at a given 
                     <termref def="dt-character-position"/> within <var>S</var>.</termdef> 
                        Segments of a string are uniquely identified by 
                     their start position and length. The sequence of characters making up a segment
                     is referred to as the <term>string value</term> of the segment.</p></item>
                     
                  </ulist>   
                  
                  <p>The operation of matching a string <var>S</var> against a regular expression delivers:</p>
                  
                  <ulist>
                     <item><p>A set of matching <termref def="dt-segment">segments</termref>. 
                        The string <var>S</var> as a whole is said to match the regular
                     expression if the set of matching segments is non-empty.</p></item>
                     <item><p>For each matching <termref def="dt-segment"/> <var>M</var>, a collection
                        of <term>captured groups</term>. This is a mapping from positive integers to segments. 
                        The integer is called the group number, and corresponds to the ordinal sequence
                        of opening parentheses of capturing subexpressions within the regular
                        expression, as explained below. The corresponding segment is always a segment of <var>S</var>,
                        but in the case of capturing expressions within lookahead assertions, it is
                        not necessarily a segment of <var>M</var>.</p></item>
                  </ulist>
                     
                  <p>The semantics of particular constructs in a regular expression are affected by
                  a set of flags. The available flags and their effect are defined in <specref ref="flags"/>.</p>   
                     
                  <p>The different functions available, such as <function>fn:replace</function>
                  and <code>fn:tokenize</code>, are defined in terms of this outcome. For example:</p>
                     
                  <ulist>
                     <item><p>The function <function>fn:matches</function> returns true if
                     the set of matching segments is non-empty.</p></item>
                     <item><p>The function <function>fn:replace</function> replaces matching
                     segments of the input string with a replacement string.</p></item>
                     <item><p>The function <function>fn:tokenize</function> returns the
                     segments of the input string that appear between the matching segments.</p></item>
                  </ulist>   
                  
                  <p>In principle the set of segments that match a regular expression can be determined
                  by enumerating all the segments of the input string and examining each one independently to establish whether
                  it matches. In practice, however:</p>
                     
                  <ulist>
                     <item>
                        <p>If several matching segments have the same starting position, then only one of them
                        is returned. This is chosen as follows:</p>
                        <ulist>
                           <item><p>In the case of a choice (operator <code>"|"</code>) the first matching
                           branch is chosen.</p></item>
                           <item><p>In the case of a repetition with a greedy quantifier (for example <code>"+"</code>
                           or <code>"*"</code>) the longest matching segment is chosen.</p></item>
                           <item><p>In the case of a repetition with a reluctant quantifier (for example <code>"+?"</code>
                           or <code>"*?"</code>) the shortest matching segment is chosen.</p></item>
                        </ulist>
                     </item>
                     <item><p>A matching segment is not included in the result if it overlaps an earlier matching
                     segment: specifically, a segment with start position <var>S1</var> is excluded if there
                     is a segment that has start position <var>S0</var> and length <var>L0</var>, where
                     <code><var>S0</var> &lt; <var>S1</var> &lt; <var>S0</var>+<var>L0</var></code>.</p></item>
                  </ulist>
                     
                  <p><termdef id="dt-disjoint-matching-segments" term="disjoint matching segments">The
                  <term>disjoint matching segments</term> obtained by applying a regular expression <var>R</var>
                  to a string <var>S</var> in the presence of a set of flags <var>F</var> are the
                  <termref def="dt-segment">segments</termref> of <var>S</var> that match <var>R</var>
                  (using flags <var>F</var>), after elimination of overlapping segments.</termdef></p>   
                     
                  <p>The semantics of a regular expression are thus defined by stating which segments
                  of an input string it matches, and what the captured groups corresponding to this match are.
                  This is defined recursively for each construct that may appear within a regular expression,
                  in terms of the outcome of applying its subexpressions.</p>                    
                 
                  <p>For constructs defined in XSD 1.1 (<code>branch</code>, <code>piece</code>,
                  <code>NormalChar</code>, <code>charClass</code>), XSD defines a set of strings
                  denoted by the construct. The corresponding semantics for this specification
                  are that the segments matched by such a construct are the segments whose string value
                  is contained in this set.</p>
                  
                  <p>For constructs added to the XSD 1.1 baseline by this specification, the semantics
                  are defined in the sections that follow.</p>
               </div3>
               
               <div3 id="regex-comments">
                  <head>Comments</head>
                  <p>Comments are enabled in regular expressions if the <code>c</code> flag is present.</p>
                  <p>A comment starts with a <code>#</code> character that is not escaped with an immediately
                  preceding backslash, and that is not contained in a <code>CharClassExpr</code> (that is,
                  in square brackets). It ends with the following <code>#</code> character, or with the
                  end of the string containing the regular expression.</p>
                  <p>Whether or not the <code>c</code> flag is present, the production for
                     <code>SingleCharEsc</code> allows the <code>#</code> character 
                     to be escaped.
                  </p>
                  
               </div3>
               
               <div3 id="id-regex-grammar">
                  <head>Regular expression grammar</head>
                  
                  <p>The grammar for regular expressions is summarized here. Rules that 
                  differ from their definition in XSD 1.1 are marked with the character <code>§</code>
                     against their names.</p>
                  
                  <p>In these rules the notation<code>【abc】</code>matches
                     any of the characters <code>'a'</code>, <code>'b'</code>, or <code>'c'</code>,
                     while <code>【0➜9】</code> matches any character whose Unicode codepoint is within a given range, 
                     and <code>¬【abc】</code> matches any character other than <code>'a'</code>, <code>'b'</code>, or <code>'c'</code>.
                     These symbols are used in place of the more conventional notation to allow special characters
                     such as square brackets and hyphens to appear directly without escaping. Within
                     the lenticular brackets, all characters other than <code>➜</code> (including hyphen and backslash)
                     represent themselves.</p>
                  
                  <eg><![CDATA[
regExp              ::= branch ( '|' branch )*
branch              ::= piece*
piece               ::= (atom quantifier?) | assertion
§quantifier         ::= ( 【?*+】 | ( '{' quantity '}' ) ) '?'?
quantity            ::= quantRange | quantMin | QuantExact
quantRange          ::= QuantExact ',' QuantExact
quantMin            ::= QuantExact ','
QuantExact          ::= 【0➜9】+
§atom               ::= NormalChar | charClass | ( '(' regExp ')' ) | backReference 
NormalChar          ::= ¬【.\?*+{}()|[]】	
charClass           ::= SingleCharEsc | charClassEsc | charClassExpr | WildcardEsc
charClassExpr       ::= '[' charGroup ']'
charGroup           ::= ( posCharGroup | negCharGroup ) ( '-' charClassExpr )?
posCharGroup        ::= ( charGroupPart )+
negCharGroup        ::= '^' posCharGroup  
charGroupPart       ::= singleChar | charRange | charClassEsc
singleChar          ::= SingleCharEsc | SingleCharNoEsc
charRange           ::= singleChar '-' singleChar
SingleCharNoEsc     ::= ¬【\[]】
charClassEsc        ::= ( MultiCharEsc | catEsc | complEsc )
§SingleCharEsc      ::= '\' 【nrt\|.?*+(){}$-[]^#】	
catEsc              ::= '\p{' charProp '}'
complEsc            ::= '\P{' charProp '}'
charProp            ::= IsCategory | IsBlock
IsCategory          ::= Letters | Marks | Numbers | Punctuation 
                        | Separators | Symbols | Others
Letters             ::= 'L' 【ultmo】?
Marks               ::= 'M' 【nce】?
Numbers             ::= 'N' 【dlo】?
Punctuation         ::= 'P' 【cdseifo】?
Separators          ::= 'Z' 【slp】?
Symbols             ::= 'S' 【mcko】?
Others              ::= 'C' 【cfon】?
IsBlock             ::= 'Is' 【a➜zA➜Z0➜9-】+
MultiCharEsc        ::= '\' 【sSiIcCdDwW】
WildcardEsc         ::= '.'
§assertion          ::= startOfString | endOfString | wordBoundary 
                        | positiveLookahead | negativeLookahead 
                        | positiveLookbehind | negativeLookbehind
§startOfString      ::= '^'
§endOfString        ::= '$'
§wordBoundary       ::= '\b' | '\B'
§backReference      ::= '\' 【1➜9】【0➜9】*
§positiveLookahead  ::= '(?=' regExp ')' 
                        | '(*positive_lookahead:' regExp ')'
§negativeLookahead  ::= '(?!' regExp ')' 
                        | '(*negative_lookahead:' regExp ')'
§positiveLookbehind ::= '(?<=' simpleRegExp ')' 
                        | '(*positive_lookbehind:' simpleRegExp ')'
§negativeLookbehind ::= '(?<!' simpleRegExp ')' 
                        | '(*negative_lookbehind:' simpleRegExp ')'
§simpleRegExp       ::= simplePiece ( '|' simplePiece )*
§simplePiece        ::= (NormalChar | charClass)*
                     ]]></eg>
                  
                 <p>This grammar applies to the regular expression after removal of whitespace and comments
                 if enabled by the <code>x</code> and <code>c</code> flags respectively: see
                 <specref ref="flags"/>.</p>
                  
                  <p>XSD 1.1 defines additional rules to disambiguate this grammar.</p> 
                  
               </div3>
               
               <div3 id="reluctant-quantifiers">
                  <head>Reluctant Quantifiers</head>
               
                     <p><emph>Reluctant quantifiers</emph> are supported. They are
                                    indicated by a  <code>?</code>
                                     following a quantifier. Specifically:</p>
                     <ulist>
                        <item>
                           <p><code>X??</code> matches X, once or not at all</p>
                        </item>
                        <item>
                           <p><code>X*?</code> matches X, zero or more times</p>
                        </item>
                        <item>
                           <p><code>X+?</code> matches X, one or more times</p>
                        </item>
                        <item>
                           <p><code>X{n}?</code> matches X, exactly n times</p>
                        </item>
                        <item>
                           <p><code>X{n,}?</code> matches X, at least n times</p>
                        </item>
                        <item>
                           <p><code>X{n,m}?</code> matches X, at least n times, but
                                            not more than m times</p>
                        </item>
                     </ulist>
                  
                     <p>Quantifiers that are not <term>reluctant</term> are referred to
                     as <term>greedy</term>.</p>
                  
                     <p>When a quantifier appears at the outermost level of a regular
                     expression, the distinction between greedy and reluctant quantifiers
                     affects the set of matching segments delivered by the matching operation.
                     With a greedy quantifier, the longest matching segment at a given start position is
                     returned; with a reluctant quantifier, the shortest matching segment at
                     a given start position is returned.</p>
                  
                     <p>When a quantifier appears within a subexpression, the quantified subexpression
                        matches the <emph>shortest</emph> possible substring consistent
                                    with the match as a whole succeeding if the quantifier is
                                    reluctant, or the <emph>longest</emph> possible substring consistent
                                    with the match as a whole succeeding if the quantifier is
                                    greedy.</p>
                    
                     
                     <note>
                        <p>Reluctant quantifiers have no effect on the results of the
                            boolean <function>fn:matches</function> function, since this
                            function is only interested in discovering whether a matching segment
                            exists, regardless of its start position and length.</p>
                     </note>
               </div3>
 
 
               
               <div3 id="captured-subexpressions">
                  <head>Captured Groups</head>
               
               <p>The regular expression syntax defined by <bibref ref="xmlschema-2"/> 
						      allows a regular expression to contain parenthesized subexpressions, but attaches no special
                        significance to them. Some operations associated with regular expressions (for example,
                           back-references, and the <function>fn:replace</function> function) allow access to the parts of the
                           input string that matched a parenthesized subexpression (called captured groups).</p>
                     
                     <p><termdef id="dt-capturing-subexpression" term="capturing subexpression">A 
                        left parenthesis is recognized as a capturing left parenthesis provided 
                        it is not immediately followed by <code>?</code> or <code>*</code> (see below), 
                        is not within a character group (square brackets), 
                        and is not escaped with a backslash. The sub-expression enclosed by a capturing left 
                        parenthesis and its matching right parenthesis is referred to as a <term>capturing subexpression</term>.</termdef></p>
                     
                     <p>More specifically, the <termref def="dt-capturing-subexpression"/> 
                        enclosed by the <var>N</var>th capturing left parenthesis within the regular expression (determined by
                        its character position in left-to-right order, and
                        counting from one) is referred to as the <var>N</var>th capturing subexpression.
                     </p>
                     
                     <p>For example, in the regular expression <code>A(BC(?:D(EF(GH[()]))))</code>, the 
                        subexpression <code>BC(?:D(EF(GH[()])))</code> is capturing subexpression 1, the string
                        subexpression <code>EF(GH[()])</code> is capturing subexpression 2, and the subexpression
                        <code>GH[()]</code> is capturing subexpression 3.
                     </p>
                  
                     
                     
                     <p>When, in the course of evaluating a regular expression, a particular <termref def="dt-segment"/> of the input
                     matches a capturing subexpression, that segment becomes available as a <term>captured group</term>.
                        The segment matched by the <var>N</var>th capturing subexpression is referred to as the 
                        <var>N</var>th captured group. By convention, the segment captured by the entire
                        regular expression is treated as captured group 0 (zero).</p>
                     
                     
                     
                     <p>When a <termref def="dt-capturing-subexpression"/> is matched
                        more than once (because it is within a construct that allows repetition), then
                        only the last substring that it matched will be captured. Note that this rule
                        is not sufficient in all cases to ensure an unambiguous result, especially in
                        cases where (a) the regular expression contains nested repeating constructs,
                        and/or (b) the repeating construct matches a zero-length string. In such cases
                        it is implementation-dependent which substring is captured. For example given
                        the regular expression <code>(a*)+</code> and the input string <code>"aaaa"</code>, an implementation
                        might legitimately capture either <code>"aaaa"</code> or a zero length string as the content
                        of the captured subgroup.</p><!-- bug 17160 -->
                     
                     
                     <p>Parentheses that are required to group terms within the regular expression, but which are
                        not required for capturing of substrings, can be represented using
                        the syntax <code>(?:xxxx)</code>.</p>
                     
                     
                     <p>In the absence of back-references (see below), 
                        the presence of the optional <code>?:</code> has no effect on the set of strings
                     that match the regular expression, but causes the left parenthesis not to be counted
                     by operations (such as <function>fn:replace</function> and back-references) that number the capturing sub-expressions 
                        within a regular expression.</p>
                  </div3>
               <div3 id="back-references">
                  <head>Back-References</head>
               <!--Text replaced by erratum E24 change 1"--><p> Back-references are allowed 
			    outside a character class expression. 
				A back-reference is an additional kind of atom.
				The construct <code>\N</code> where
                <code>N</code> is a single digit is always recognized as a
                back-reference; if this is followed by further digits, these
                digits are taken to be part of the back-reference if and only if
                the resulting number <var>NN</var> is such that
				    the back-reference is preceded by the opening parenthesis of the <var>NN</var>th 
                capturing left parenthesis.
				The regular expression is invalid if a back-reference refers to a
				capturing sub-expression that does not exist or whose
                closing right parenthesis occurs after the back-reference.
                     </p>
                     <p>A back-reference with number <var>N</var> matches a string that is the same as
                        the value of the <code>N</code>th captured substring.</p>
				 
                <p>For example, the regular expression
                <code>('|").*\1</code> matches a sequence of characters
                delimited either by an apostrophe at the start and end, or by a
                quotation mark at the start and end. </p>
                     <p>If no string has been matched by the <code>N</code>th capturing 
               sub-expression, the back-reference is interpreted as matching 
               a zero-length string.</p>
                     
                     <note>
                        <p>
                           Within a character class expression, 
                              <code>\</code> followed by a digit is invalid.
			 Some other regular expression languages interpret this as an octal character reference.
                        </p>
                     </note>
                     <!--End of text replaced by erratum E24-->
               </div3>
                 <div3 id="unicode-block-names">
                    <head>Unicode Block Names</head>
                 
              
                     <p>A regular expression that uses a Unicode block name that is not defined in the version(s) of Unicode
                     supported by the processor (for example <code>\p{IsBadBlockName}</code>) is deemed to be invalid
                        <errorref class="RX" code="0002"/>.</p>
                     <note><p>XSD 1.0 does not say how this situation should be handled; XSD 1.1
                        says that it should be handled by treating all characters as matching.</p></note>
                 </div3>
               
               
               <div3 id="id-assertions">
                  <head>Assertions</head>
                  
                  <p>Assertions (sometimes called <emph>zero-width assertions</emph>) test whether a particular
                  condition applies at the current position in the input string (resulting in either a match or a no-match),
                  but they do not cause any change to the current position.</p>
                  
                  <p>Assertions fall into the following categories:</p>
                  
                  <ulist>
                     <item><p>The <code>startOfString</code> assertion <code>^</code> tests whether the current
                        position is at the start of the string.</p></item>
                     <item><p>The <code>endOfString</code> assertion <code>$</code> tests whether the current position
                        is at the end of the string.</p></item>
                     <item><p>The <code>boundary</code> assertions <code>\b</code> and <code>\B</code> test 
                     whether the current position is at the start or end of a word.</p></item>
                     <item><p>The positive and negative lookahead assertions test whether there is (or is not) a substring
                     starting at the current position that matches a given regular expression.</p></item>
                     <item><p>The positive and negative lookbehind assertions test whether there is (or is not) a substring
                     ending at the current position that matches a given regular expression.</p></item>
                  </ulist>
                  
                  <p>An assertion <rfc2119>must not</rfc2119> be followed by a quantifier.</p>
                  
                  <note>
                     <p>Previous versions of this specification allowed a quantifier to follow the 
                     <code>startOfString</code> and <code>endOfString</code> assertions, though this
                     served no practical purpose. Processors <rfc2119>may</rfc2119> provide an option to allow quantifiers
                     to be used in this situation in order to preserve backward compatibility.</p>
                  </note>
                  
                  
                  <div4 id="matching-start-and-end">
                     <head>Matching the Start and End of the String</head>
 
               
                     <p>Two meta-characters, <code>^</code> and <code>$</code> are
                        added. By default, the meta-character <code>^</code> matches if the current position is the
                        start of the entire string, while <code>$</code> matches if the current position is the end
                        of the entire string. In multi-line mode, <code>^</code> matches
                        the start of any line (that is, the start of the entire string,
                        and the position immediately after a newline character), while
                        <code>$</code> matches the end of any line (that is, the end of
                        the entire string, and the position immediately before a newline
                        character). Newline here means the character <char>U+000A</char> only.</p>
                     
                     <p>Single character escapes are extended to allow the
                        <code>$</code> character to be escaped.</p>
 </div4>
              
              <div4 diff="add" at="issue1006" id="regex-boundary-assertions">
		    <head>Boundary Assertions</head>
                 
          <p>The assertion <code>\b</code> matches at any position where one of the following conditions is true:</p>
                 
                 <ulist>
                    <item><p>The current position is the start of the string, the string is not empty, and the first
                       character in the string matches <code>\w</code>.</p></item>
                    <item><p>The current position is the end of the string, the string is not empty, and the
                       last character in the string matches <code>\w</code>.</p></item>
                    <item><p>The character before the current position matches <code>\w</code> and the character
                    after the current position matches <code>\W</code>.</p></item>
                    <item><p>The character before the current position matches <code>\W</code> and the character
                    after the current position matches <code>\w</code>.</p></item>
                 </ulist>
                 
                 <p>Informally, <code>\b</code> matches if the current position is the start or end
                 of a word, where a word is defined as a sequence of consecutive characters other than
                 codepoints in Unicode groups <code>P</code> (punctuation), <code>Z</code> (separator),
                 or <code>C</code> (other).</p>
                 
          <p>The assertion <code>\B</code> matches at any position where <code>\b</code> does not match.</p>

		    
		    

		    <note><p><code>\b</code> can be rewritten to an equivalent form in terms of lookbehind and lookahead assertions:</p>
		    <p><code> ( (*positive_lookbehind:\w)(*positive_lookahead:\W) ) |
			( (*positive_lookbehind:\W)(*positive_lookahead:\w) )</code></p>
		       
		    <p>A similar rewrite is possible for <code>\B</code>.</p></note>

		   
		    
		    
		</div4>
                  
             
         <!--      <div4 diff="add" at="issue998" id="regex-look-assertions">
                  <head>Lookahead and Lookbehind Assertions</head>
               

		   <p>A lookahead assertion allows matching of a pattern only when followed by a match to the assertion.
		   Similarly, a lookbehind assertion matches something only when it comes immediately after another item.
		   The input matches by an assertion is not included in the match, and for this reason in some systems
		   these are considered examples of zero-width assertions.</p>

		   <p>It is conventional in regular expression languages to provide multiple forms of assertions.
		   One form uses an abbreviated syntax, and another a longer more readable version.  Some languages
		   provide additional forms not included here. The short forms, although most widely supported and described
		   elsewhere, use the <code>&lt;</code> character, which can be inconvenient in XML-based
		   host languages such as XML where those characters must be escaped. In those cases, the longer forms are
		   likely to be more convenient; in all cases the abbreviated form and the long form are identical in function
		   and entirely interchangable.</p>

		   <p>There are some restrictions on lookbehind assertions. Lookbehind assertions must not contain capture groups.
		   Implementations MAY firther restrict the pattern, forbidding occurrence indicators
		   such as <code>*</code>, <code>?</code>, <code>+</code>, or <code>{...}</code>,
		   and may limit the length of what is matched by a lookbehind assertion to, for example, 100 characters.
		   A positive lookbehind that matches a single character, such as <code>\s</code>, MUST be supported.
		   See also <code>\K</code> for a way to avoid these restrictions.</p>
-->
		   

		   <div4 id="regex-positive-lookahead">
		       <head>Positive Lookahead Assertions</head>
		      
		       <p>There are two equivalent ways of writing a positive lookahead assertion:</p>

		       <p><code>(?=<var>xyz</var>)</code></p>
		       <p><code>(*positive_lookahead:<var>xyz</var>)</code></p>

		       <p>In both cases, the assertion matches at a particular position in the input string
		          only if there is a substring starting at that position that matches the regular
		          expression <var>xyz</var>.</p>
		      
		       <p>As with all assertions, evaluation of the assertion does not cause the current position
		          to advance.</p>
		      
		       <p>For example, <code>Chapter(?=\s+[1-9])</code> will match <code>"Chapter"</code> only if 
		       followed by a number, with intervening whitespace.</p>
		         
		       <p>A parenthesized expression within a lookahead assertion 
		          can capture a substring in the normal way. There are some minor complications, however:</p>
		          
	          <ulist>
	             <item><p>Substrings captured while evaluating a lookahead assertion are represented
      	          differently in the result of the <function>fn:analyze-string</function>
      	          function, because they can overlap other substrings in arbitrary ways.</p></item>
	             <item><p>If an assertion is satisfied, then any substrings that are captured are
	                based on the first evaluation of the assertion that matches; alternative
	                evaluations of the assertion that also match, but which capture different substrings,
	                are not considered.</p></item>
	          </ulist>
		      
		      <p>A positive lookahead assertion that matches a zero-length string is permitted but pointless,
		          since it will always match, and thus cause the assertion to succeed.</p>

		       <!--<p><code>replace("high school antics", "high(?=\s*school)", "low")</code> results
		       in <code>low school antics</code>.</p>

		       <p><code>replace("crawl, crawling, crawled", "(crawl|fly)(*positive_lookahead:ing)", "leap")</code>
		       produces <code>crawl, leaping, crawled</code>.</p>

		       <p><code>replace("very high towers sway", "high(?=\s+towers)", "tall")</code></p>
		       <p>This results in <code>very tall towers sway</code>. The pattern matches “high” when it is
		       followed by one or more space characters and then the word “towers”, but
		       only “high” is replaced because the remainder, which part of the lookahead
		       assertion, is not captured.</p>

		       <p><code>replace("very high buildings sway", "high(?=\s+towers)", "tall")</code></p>
		       <p>This will not replace anything because although <code>high</code> is matched,
		       the lookahead portion does not match, which means that the pattern as a whole fails to match.</p>

		       <p><code>replace("very high towers", "high\s(?=(a-z][a-z+)", "tall $1-$1-")</code></p>
		       <p>This results in <code>very tall t-t-towers</code>, replacing only the word <code>high</code> and
		       the following space.</p>

		       <note><p>Note: a positive lookahead assertion can be thought of as a generalization of <code>$</code> at
		       the end of a regular expression: assertions can occur anywhere,
		       not only at the end, and can match arbitrary content.</p></note>-->
		    </div4>
                  
          <div4 id="regex-negative-lookahead-assertion">
		       <head>Negative Lookahead Assertion</head>
             
             <p>There are two equivalent ways of writing a negative lookahead assertion:</p>

		       <p><code>(?!<var>xyz</var>)</code></p>
		       <p><code>(*negative_lookahead:<var>xyz</var>)</code></p>

		       <p>In both cases, the assertion matches at a particular position in the input string
		          only if there is no substring starting at that position that matches the regular
		          expression <var>xyz</var>.</p>
		      
		       <p>As with all assertions, evaluation of the assertion does not cause the current position
		          to advance.</p>
             
             <p>For example, <code>Chapter(?!\s*[1-9])</code> will match <code>"Chapter"</code> only if 
		       it is not followed by a number, with optional intervening whitespace.</p>

		         
		       <p>Any capturing parentheses within a negative lookahead assertion are counted
		       for the purpose of numbering captured groups,
		       but they cannot capture any result because the pattern in the assertion must fail to match.</p>
             
             
             <p>A negative lookahead assertion that matches a zero-length string is permitted but pointless,
		          since it will always match, and thus cause the assertion to fail.</p>
             
             
		       
		    </div4>
		    <div4 id="regex-positive-lookbehind">
		       <head>Positive Lookbehind Assertions</head>
		       
		       <p>There are two equivalent ways of writing a positive lookbehind assertion:</p>

		       <p><code>(?&lt;=<var>xyz</var>)</code></p>
		       <p><code>(*positive_lookbehind:<var>xyz</var>)</code></p>
		       
		       <p>The second form may be more convenient when the expression appears within an XML-based
		          host language such as XSLT, where the angle bracket would need to be escaped.</p>

		       <p>In both cases, the assertion matches at a particular position in the input string
		          only if there is a substring ending at that position that matches the regular
		          expression <var>xyz</var>.</p>
		       
		       <p>For efficiency and ease of implementation, the regular expression contained
		       within a lookbehind assertion is constrained. It must consist of one or more
		       alternatives separated by <code>"|"</code>, and each alternative must be fixed-length,
		       consisting only of the following constructs, each of which matches a single character:</p>
		       
		       <ulist>
		          <item><p><code>NormalChar</code> (for example <code>"A"</code>, <code>"3"</code>)</p></item>
		          <item><p><code>SingleCharEsc</code> (for example <code>"\("</code>, <code>"\["</code>)</p></item>
		          <item><p><code>charClassEsc</code> (for example <code>"\s"</code>, <code>"\p{Lu}"</code>)</p></item>
		          <item><p><code>charClassExpr</code> (for example <code>"[a-z]"</code>)</p></item>
		          <item><p><code>WildcardEsc</code> (<code>"."</code>)</p></item>
		       </ulist>
		      
		       <p>As with all assertions, evaluation of the assertion does not cause the current position
		          to advance.</p>
		         
		       <p>Parenthesized expressions cannot appear within lookbehind assertions.</p>  

		       <p>For example, <code>(?&lt;=\[)[0-9+](?=\])</code> matches a sequence of digits immediately
		       preceded by an opening square bracket and followed by a closing square bracket, without
		       matching the brackets.</p>
		       
		    </div4>
		    
		    
		    <div4 id="regex-negative-lookbehind">
		       <head>Negative Lookbehind Assertion</head>
		       
		       <p>There are two equivalent ways of writing a negative lookbehind assertion:</p>

		       <p><code>(?&lt;!<var>xyz</var>)</code></p>
		       <p><code>(*negative_lookbehind:<var>xyz</var>)</code></p>
		       
		       <p>The second form may be more convenient when the expression appears within an XML-based
		          host language such as XSLT, where the angle bracket would need to be escaped.</p>

		       <p>In both cases, the assertion matches at a particular position in the input string
		          only if there is no substring ending at that position that matches the regular
		          expression <var>xyz</var>.</p>

		       <p>The regular expression within a negative lookbehind assertion is subject to the
		       same restrictions as for a positive lookbehind assertion: see <specref ref="regex-positive-lookbehind"/>.</p>
		       
		       <p>For example, <code>(?&lt;!\$)[0-9]+</code> matches any sequence of digits that
		       is not immediately preceded by a dollar sign.</p>
		       
		       
		    </div4>

		
            </div3>
            </div2>
               
               <div2 id="flags">
                  <head>Flags</head>
                  <changes>
                  <change issue="999" PR="1022" date="2024-02-20">
                     Regular expressions can include comments (starting and ending with <code>#</code>)
                     if the <code>c</code> flag is set.
                  </change>
               </changes>
                  <p>All these functions provide an optional parameter, <code>$flags</code>,
                    to set options for the interpretation of the regular expression. The
                    parameter accepts a <code>xs:string</code>, in which individual letters
                    are used to set options. The presence of a letter within the string
                    indicates that the option is on; its absence indicates that the option
                    is off. Letters may appear in any order and may be repeated. They are case-sensitive. If there
                    are characters present that are not defined here as flags, then a dynamic error
                    is raised <errorref class="RX" code="0001"/>.</p>
                  <p>The following options are defined:</p>
                  <ulist>
                     <item>
                        <p><code>s</code>: If present, the match operates in “dot-all”
                        mode. (Perl calls this the single-line mode.) If the
                        <code>s</code> flag is not specified, the meta-character
                        <code>.</code> matches any character except a newline
                        (<code>#x0A</code>) or carriage return (<code>#x0D</code>) 
                        character. In dot-all mode, the
                        meta-character <code>.</code> matches any character whatsoever.
                        Suppose the input contains the strings <code>"hello"</code> and
                        <code>"world"</code> on two lines.
                        This will not be matched by the regular expression
                        <code>"hello.*world"</code> unless dot-all mode is enabled.</p>
                     </item>
                     <item><!--Text replaced by erratum E7 change 1"--><p>
                           <code>m</code>: If present, the match operates in multi-line
			            mode. By default, the meta-character <code>^</code> matches the
			            start of the entire string, while $ matches the end of the
			            entire string. In multi-line mode, <code>^</code> matches the
			            start of any line (that is, the start of the entire string, and
			            the position immediately after a newline character
						other than a newline
			            that appears as the last character in the string), while
			            <code>$</code> matches the end of any line 
						(that is, the position immediately
			            before a newline character, and the end of the entire string if there is no
			            newline character at the end of the string).
			            Newline here means the character <code>#x0A</code> only.</p>
                        <!--End of text replaced by erratum E7--></item>
                     <item>
                        <p><code>i</code>: If present, the match operates in
                        case-insensitive mode. The detailed rules are as follows. 
                        In these
                        rules, a character C2 is considered to be a <emph>case-variant</emph> of 
                        another character C1 if the following XPath expression returns 
                        <code>true</code> when the two characters
                           are considered as strings of length one, and the 
                           <termref def="dt-codepoint-collation">Unicode codepoint collation</termref> is used:</p>
                        <p>
                           <code>fn:lower-case(C1) eq fn:lower-case(C2) or
                        fn:upper-case(C1) eq fn:upper-case(C2)</code>
                        </p>
                        <p>
                                     Note that the case-variants of a character under this definition 
                                     are always single characters.</p>
                        <olist>
                           <item>
                              <p>
                                    When a normal character (<code>Char</code>) is used as an atom, 
                                    it represents 
                                    the set containing that character and all its case-variants. 
                                    For example, the regular expression <code>"z"</code> will
                                    match both <code>"z"</code> and <code>"Z"</code>.</p>
                           </item>
                           <item>
                              <p>
                                    A character range (production <code>charRange</code>
                                    in the XSD 1.0 grammar, replaced by productions <code>charRange</code> and <code>singleChar</code>
                                    in XSD 1.1) represents the set 
                                    containing all the characters that it would match in the absence 
                                    of the <code>i</code> flag, together with their case-variants. 
                                    For example, 
                                    the regular expression <code>"[A-Z]"</code> will match all
                                    the letters <code>A</code> to <code>Z</code> and all the letters
                                    <code>a</code> to <code>z</code>. It will also match 
                                    certain other characters such as <code>#x212A</code> (KELVIN SIGN), since 
                                    <code>fn:lower-case("#x212A")</code> is <code>k</code>.</p>
                              <p>
                                    This rule applies also to a character range used in a character 
                                    class subtraction (<code>charClassSub</code>): thus [A-Z-[IO]] will match 
                                    characters such as <code>A</code>, <code>B</code>, <code>a</code>, and <code>b</code>, but will not match 
                                    <code>I</code>, <code>O</code>, <code>i</code>, or <code>o</code>.</p>
                              <p>
                                    The rule also applies to a character range used as part of a 
                                    negative character group: thus <code>"[^Q]"</code> will match every character 
                                    except <code>Q</code> and <code>q</code> (these being the only case-variants of <code>Q</code> in 
                                    Unicode).</p>
                           </item>
                           <item>
                              <p>
                                    A back-reference is compared using case-blind comparison: 
                                    that is, each character must either be the same as the 
                                    corresponding character of the previously matched string, or must 
                                    be a case-variant of that character. For example, the strings 
                                    <code>"Mum"</code>, <code>"mom"</code>, <code>"Dad"</code>,
                                    and <code>"DUD"</code> all match the regular
                                    expression <code>"([md])[aeiou]\1"</code> when the <code>i</code> flag is used.</p>
                           </item>
                           <item>
                              <p>
                                    All other constructs are unaffected by the <code>i</code> flag. 
                                    For example, 
                                    <code>"\p{Lu}"</code> continues to match upper-case letters only.</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p><code>x</code>: If present, whitespace characters 
                                    (that is, <char>U+0009</char>, <char>U+000A</char>, <char>U+000D</char> and <char>U+000D</char>)
                                    in the regular expression are removed prior to matching with one exception:  
                                    whitespace characters within character class expressions 
                                    (<code>charClassExpr</code>) are not removed. This flag can be used, 
                                    for example, to break up long regular expressions into readable lines.</p>
                        <p> Examples:</p>
                        <p> 
                           <code>fn:matches("helloworld", "hello world", "x")</code> returns <code>true()</code>
                        </p>
                        <p> 
                           <code>fn:matches("helloworld", "hello[ ]world", "x")</code> returns <code>false()</code>
                        </p>
                        <p> 
                           <code>fn:matches("hello world", "hello\ sworld", "x")</code> returns <code>true()</code>
                        </p>
                        <p> 
                           <code>fn:matches("hello world", "hello world", "x")</code> returns <code>false()</code>
                        </p>
                        <note><p>Whitespace is treated as a lexical construct to be removed before the
                        regular expression is parsed; it is therefore not explicit in the regular expression grammar.</p></note>
                     </item>
                     <item><p><code>q</code>: if present, all characters in the regular expression
                     are treated as representing themselves, not as metacharacters. In effect, every
                     character that would normally have a special meaning in a regular expression is implicitly escaped
                     by preceding it with a backslash.</p>
                         <p>Furthermore, when this flag is present, the characters <code>$</code> and
                         <code>\</code> have no special significance when used in the replacement string
                         supplied to the <function>fn:replace</function> function.</p>
                        <p>This flag can be used in conjunction with the <code>i</code> flag. If it is used
                           together with the <code>m</code>, <code>s</code>, <code>x</code>, 
                           <phrase diff="add" at="issue999">or <code>c</code></phrase> flag, that flag
                           has no effect.</p>
                        <p>Examples:</p>
                        <p><code>tokenize("12.3.5.6", ".", "q")</code> returns <code>("12", "3", "5", "6")</code></p>
                        <p><code>replace("a\b\c", "\", "\\", "q")</code> returns <code>"a\\b\\c"</code></p>
                        <p><code>replace("a/b/c", "/", "$", "q")</code> returns <code>"a$b$c"</code></p>
                        <p><code>matches("abcd", ".*", "q")</code> returns <code>false()</code></p>
                        <p><code>matches("Mr. B. Obama", "B. OBAMA", "iq")</code> returns <code>true()</code></p>
                     </item>
                     <item diff="add" at="issue999"><p><code>c</code>: if present, comments are enabled
                        in the regular expression. This flag has no effect if the <code>q</code> flag is
                        present. A comment is recognized by the presence of a <code>#</code> character that
                        is not escaped by a backslash or contained in a character class expression
                        (<code>charClassExpr</code>), and it is terminated by the following <code>#</code>
                        character or by the end of the regular expression string.</p>
                        <p>For example:</p>
                        <p><code>replace("03/24/2025", "(..#month#)/(..#day#)/(....#year#)", "$3-$1-$2", "c")</code></p>
                        <note><p>Comments are treated as a lexical construct to be removed before the
                           regular expression is parsed; they are therefore not explicit in the regular 
                           expression grammar.</p></note>
                     </item>
                  </ulist>
               </div2>
          <div2 id="regex-functions">
             <head>Functions using regular expressions</head>
         <?local-function-index?>
            <div3 id="func-matches">
               <head><?function fn:matches?></head>
            </div3>
            <div3 id="func-replace">
               <head><?function fn:replace?></head>
            </div3>
			   <div3 id="func-tokenize">
               <head><?function fn:tokenize?></head>
			   </div3>
            <div3 id="func-analyze-string">
               <head><?function fn:analyze-string?></head>
            </div3>
 

          </div2>
         
      </div1>
      <div1 id="anyURI-functions">
         <head>Processing URIs</head>
         <p>This section specifies functions that manipulate URI values, either as instances
            of <code>xs:anyURI</code> or as strings.</p>
         <?local-function-index?>
         <div2 id="func-resolve-uri">
            <head><?function fn:resolve-uri?></head>
         </div2>
         <div2 id="func-encode-for-uri">
            <head><?function fn:encode-for-uri?></head>
         </div2>
         <div2 id="func-decode-from-uri">
            <head><?function fn:decode-from-uri?></head>
         </div2>
         <div2 id="func-iri-to-uri">
            <head><?function fn:iri-to-uri?></head>
         </div2>
         <div2 id="func-escape-html-uri">
            <head><?function fn:escape-html-uri?></head>
         </div2>
         <div2 id="parse-build">
           <head>Parsing and building URIs</head>

         <p>This section specifies functions that parse strings as
         URIs, to identify their structure, and construct URI strings
         from their structured representation.</p>

         <p>Some URI schemes are hierarchical and some are non-hierarchical.
         Implementations must treat the following schemes as non-hierarchical:
         <code>jar</code>, <code>mailto</code>, <code>news</code>, <code>tag</code>,
         <code>tel</code>, and <code>urn</code>. Whether additional schemes
         are known to be non-hierarchical
         <termref def="implementation-defined">implementation-defined</termref>.
         If a scheme is not known to be non-hierarchical, it must be
         treated as hierarchical.</p>

         <?local-function-index?>

           <p>Both functions use a structured representation of a URI as defined in the next section.</p>
            
            
           <div3 id="uri-structure-record">
              <head><?record-description uri-structure-record?></head>
              
           <p>The segmented forms of the path and query parameters provide
           convenient access to commonly used information.</p>

           <p>The path, if there is one, is tokenized on “/” characters and
           each segment is unescaped (as per the <function>fn:decode-from-uri</function> function). Consider the URI
           <code>http://example.com/path/to/a%2fb</code>.
           The path portion has to be returned as <code>/path/to/a%2fb</code> because
           decoding the <code>%2f</code> would change the nature of the path.
           The unescaped form is easily accessible from <code>path-segments</code>:</p>

           <eg>("", "path", "to", "a/b")</eg>

           <p>Note that the presence or absence of a leading slash on the path
           will affect whether or not the sequence begins with an empty string.</p>

           <p>The query parameters are decoded into a map. Consider the URI:
           <code>http://example.com/path?a=1&amp;b=2%264&amp;a=3</code>.
           The decoded form in the query-parameters is the following map:</p>
           <eg>{ "a": ("1", "3"), "b": "2&amp;4" }</eg>

           <p>Note that both keys and values are unescaped. If a key
           is repeated in the query string, the map will contain a
           sequence of values for that key, as seen for <code>a</code>
           in this example.</p>
           </div3>

           <div3 id="func-parse-uri">
             <head><?function fn:parse-uri?></head>
           </div3>
           <div3 id="func-build-uri">
             <head><?function fn:build-uri?></head>
           </div3>
         </div2>
      </div1>
      <div1 id="boolean-functions">
         <head>Processing booleans</head>
         <p>This section defines functions and operators on the <code>xs:boolean</code> datatype.</p>
         <div2 id="boolean-constructors">
            <head>Boolean constant functions</head>
            <p>Since no literals are defined in XPath to reference the constant boolean values <code>true</code> and <code>false</code>,
			two functions are provided for the purpose.</p>
            <?local-function-index?>
            <div3 id="func-true">
               <head><?function fn:true?></head>
            </div3>
            <div3 id="func-false">
               <head><?function fn:false?></head>
            </div3>
         </div2>
         <div2 id="op.boolean">
            <head>Operators on Boolean values</head>
            <p>The following functions define the semantics of operators on boolean values in
                        <bibref ref="xquery-40"/> and <bibref ref="xpath-40"/>:</p>
            <?local-function-index?>
            <p>The ordering operator <code>op:boolean-less-than</code> is provided for application purposes
                    and for compatibility with <bibref ref="xpath"/>. The <bibref ref="xmlschema-2"/>
                    datatype <code>xs:boolean</code> is not ordered.</p>
            <div3 id="func-boolean-equal">
               <head><?function op:boolean-equal?></head>
            </div3>
            <div3 id="func-boolean-less-than">
               <head><?function op:boolean-less-than?></head>
            </div3>
         </div2>
         <div2 id="boolean-value-functions">
            <head>Functions on Boolean values</head>
            <p>The following functions are defined on boolean values:</p>
            <?local-function-index?>
			<div3 id="func-boolean">
               <head><?function fn:boolean?></head>
            </div3>
            <div3 id="func-not">
               <head><?function fn:not?></head>
            </div3>
         </div2>
      </div1>
	  <div1 id="durations">
	  	<head>Processing durations</head>
            <p>Operators are defined on the following type:</p>
            <ulist>
               <item>
                  <p>xs:duration</p>
               </item>
            </ulist>
            <p>and on the two defined subtypes (see <specref ref="duration-subtypes"/>):</p>
            <ulist>
               <item>
                  <p>xs:yearMonthDuration</p>
               </item>
               <item>
                  <p>xs:dayTimeDuration</p>
               </item>
            </ulist>
            <p>No ordering relation is defined on <code>xs:duration</code> values.
			Two <code>xs:duration</code> values may however be compared for equality.</p>
	     
	     <div2 id="duration-data-types">
	        <head>Duration data types</head>
	        <p>A value of type <code>xs:duration</code> is considered to comprise two parts:</p>
	        <ulist>
	           <item><p>The total number of months, represented as a signed integer.</p></item>
	           <item><p>The total number of seconds, represented as a signed decimal number.</p></item>
	        </ulist>
	        <p>If one of these values is negative (less than zero), the other must not be positive
	        (greater than zero).</p>
	     
		 
			<p>In effect this means that operations on durations (including equality comparison, 
			   casting to string, and extraction of components) 
			   all treat the duration as normalized. The duration <code>PT1M30S</code> (one minute and
			   thirty seconds), for example,
			   is precisely equivalent to the duration <code>PT90S</code> (ninety seconds); these are
			   different representations of the same value, and the result of any operation will be
			   the same regardless which representation is used. For example, the function
			   <function>fn:seconds-from-duration</function> returns 30 in both cases.</p>
	     
	      <!--<p>Conditions such as underflow and overflow may occur with arithmetic on
	         durations: see <specref ref="duration-limits"/> </p>-->

			<note><p>The information content of an <code>xs:duration</code>
			value can be reduced to an <code>xs:integer</code> number of months, and an <code>xs:decimal</code>
			number of seconds. For the two defined subtypes this is further simplified so that one of these two
			components is fixed at zero. Operations such as comparison of durations and arithmetic on durations
			can be expressed in terms of numeric operations applied to these two components.</p></note>

           
         <div3 id="duration-subtypes">
            <head>Subtypes of duration</head>
            
            <p>Two subtypes of <code>xs:duration</code>, namely <code>xs:yearMonthDuration</code>
               and <code>xs:dayTimeDuration</code>, are defined in <bibref ref="xmlschema11-2"/>. These types <rfc2119>must</rfc2119>
            be available in the data model whether or not the implementation supports other aspects of XSD 1.1.</p>
            
            <p>The significance of these subtypes is that arithmetic and ordering become well defined; this is not the
            case for <code>xs:duration</code> values in general, because of the variable number of days in a month. For this reason, many of the functions
            and operators on durations require the arguments/operands to belong to these two subtypes.</p>
            
            <p>In an <code>xs:yearMonthDuration</code>, the seconds component is always zero. 
            In an <code>xs:dayTimeDuration</code>, the months component is always zero.</p>
            
         </div3>
	     
	     <div3 id="duration-conformance" diff="add" at="issue931">
	        <head>Limits and precision</head>
	        
	        <changes>
	           <change issue="931" PR="932" date="2024-01-16">
	              The specification now prescribes a minimum precision and range for durations.
	           </change>
	        </changes>
	        
	        <p>All conforming processors
	           <rfc2119>must</rfc2119>  support duration values in which:</p>
	        <ulist>
	           <item><p>The total number of months can be represented as a signed <code>xs:int</code> value;</p></item>
	           <item><p>The total number of seconds can be represented as a signed <code>xs:decimal</code>
	           value with facets <code>totalDigits=18</code> and <code>fractionalDigits=3</code>. That is,
	           durations must be supported to millisecond precision.</p></item>
	        </ulist>
	        
	        <p>Processors <rfc2119>may</rfc2119> support a greater range and/or precision.
	           The limits are <termref def="implementation-defined"/>.</p>

	        <p>A processor that limits the range or precision of duration values
	           may encounter overflow and underflow conditions when it
	           tries to evaluate operations on durations. In
	           these situations, the processor <rfc2119>must</rfc2119> return a zero-length duration 
	           in case of duration underflow, and <rfc2119>must</rfc2119> raise a dynamic 
	           error <errorref class="DT" code="0001"/> in case of overflow.</p>
	        
	        <p>Similarly, a processor may be unable accurately to represent the result of dividing a duration
	        by 2, or multiplying a duration by 0.5. A processor that limits the precision of the seconds component
	        of duration values <rfc2119>must</rfc2119> deliver a result
	        that is as close as possible to the mathematically precise result, given these limits; 
	        if two values are equally close, the one that is chosen is <termref def="implementation-defined"/>.</p>
	        
	        
	        
	     </div3>
	     </div2>
	     
	     
		 <div2 id="comp.duration">
		 <head>Comparison operators on durations</head>
		    <?local-function-index?>
			            <p>The following comparison operators are defined on the <bibref ref="xmlschema-2"/>
                    duration datatypes. Each operator takes two operands of the same
                    type and returns an <code>xs:boolean</code> result. As discussed in <bibref ref="xmlschema-2"/>, the
                    order relation on <code>xs:duration</code> is a partial order rather than 
                    a total order. For this reason, only equality is defined on <code>xs:duration</code>. 
					A full complement of comparison and
                    arithmetic functions are defined on the two subtypes of duration described in
                        <specref ref="duration-subtypes"/> which do have a total order.</p>

	
            
		 	<div3 id="func-yearMonthDuration-less-than">
               <head><?function op:yearMonthDuration-less-than?></head>
            </div3>
            <div3 id="func-dayTimeDuration-less-than">
               <head><?function op:dayTimeDuration-less-than?></head>
            </div3>
		    <div3 id="func-duration-equal">
               <head><?function op:duration-equal?></head>
            </div3>
		 </div2>
        <div2 id="component-extraction-durations">
            <head>Component extraction functions on durations</head>
            <p>The duration datatype may be considered to be a composite datatype
                    in that it contains distinct properties or components. The extraction functions specified
                    below extract a single component from a duration value. 
For <code>xs:duration</code> and its subtypes, including the two subtypes <code>xs:yearMonthDuration</code> and
 <code>xs:dayTimeDuration</code>, the components are normalized: this means that the seconds and minutes 
 components will always be less than 60, the hours component less than 24, and the months component less than 12.
</p>
           <?local-function-index?>
            <div3 id="func-years-from-duration">
				<head><?function fn:years-from-duration?></head>
            </div3>
            <div3 id="func-months-from-duration">
               <head><?function fn:months-from-duration?></head>
            </div3>
            <div3 id="func-days-from-duration">
               <head><?function fn:days-from-duration?></head>
            </div3>
            <div3 id="func-hours-from-duration">
               <head><?function fn:hours-from-duration?></head>
            </div3>
            <div3 id="func-minutes-from-duration">
			   <head><?function fn:minutes-from-duration?></head>
			</div3>
			<div3 id="func-seconds-from-duration">
			   <head><?function fn:seconds-from-duration?></head>
			</div3>
        </div2>
	     <div2 id="duration-construction">
	        <head>Constructing durations</head>	        
	        <p>This section decribes the <function>fn:seconds</function> function, which constructs
	        an <code>xs:dayTimeDuration</code> value representing a decimal number of seconds.</p>
	        <?local-function-index?>
	        <div3 id="func-seconds">
	           <head><?function fn:seconds?></head>
	        </div3>
	     </div2>
        <div2 id="duration-arithmetic">
            <head>Arithmetic operators on durations</head>
           <?local-function-index?>
			<p>For operators that combine a duration and a date/time value, see <specref ref="dateTime-arithmetic"/>.</p>
            <div3 id="func-add-yearMonthDurations">
               <head><?function op:add-yearMonthDurations?></head>
             </div3>
            <div3 id="func-subtract-yearMonthDurations">
               <head><?function op:subtract-yearMonthDurations?></head>
            </div3>
            <div3 id="func-multiply-yearMonthDuration">
               <head><?function op:multiply-yearMonthDuration?></head>
            </div3>
            <div3 id="func-divide-yearMonthDuration">
               <head><?function op:divide-yearMonthDuration?></head>
            </div3>
            <div3 id="func-divide-yearMonthDuration-by-yearMonthDuration">
               <head><?function op:divide-yearMonthDuration-by-yearMonthDuration?></head>
            </div3>
            <div3 id="func-add-dayTimeDurations">
               <head><?function op:add-dayTimeDurations?></head>
            </div3>
            <div3 id="func-subtract-dayTimeDurations">
               <head><?function op:subtract-dayTimeDurations?></head>
            </div3>
            <div3 id="func-multiply-dayTimeDuration">
               <head><?function op:multiply-dayTimeDuration?></head>
            </div3>
            <div3 id="func-divide-dayTimeDuration">
               <head><?function op:divide-dayTimeDuration?></head>
            </div3>
            <div3 id="func-divide-dayTimeDuration-by-dayTimeDuration">
               <head><?function op:divide-dayTimeDuration-by-dayTimeDuration?></head>
            </div3>
         </div2>
	  </div1>
	  	


      <div1 id="dates-times">
         <head>Processing dates and times</head>
         <p>This section defines operations on the <bibref ref="xmlschema-2"/> date and time types.</p>
         <p>
See <bibref ref="Working-With-Timezones"/> for a disquisition on working with date and time values with and without timezones.
</p>
         <div2 id="date-time-types">
            <head>Date and time types</head>
            
            <p><termdef id="dt-gregorian" term="Gregorian">The eight primitive types 
            <code>xs:dateTime</code>, <code>xs:date</code>, <code>xs:time</code>, <code>xs:gYearMonth</code>, 
               <code>xs:gYear</code>, <code>xs:gMonthDay</code>, <code>xs:gMonth</code>, <code>xs:gDay</code>
            are referred to collectively as the <term>Gregorian</term> types.</termdef></p>
            
            <p>This section describes operations on atomic items of these types.</p>
            
            <p>Values of these types are modeled as comprising one or more of the seven components
            year, month, day, hour, minute, second, and timezone.</p>
            
            
            <p>The only operations defined on					
                    <code>xs:gYearMonth</code>, <code>xs:gYear</code>,
                    <code>xs:gMonthDay</code>, <code>xs:gMonth</code> and <code>xs:gDay</code> values are 
               equality comparison and component extraction.
               For other types, further operations are provided, including  
               order comparisons, arithmetic, formatted display, and timezone
					adjustment.</p>

            <div3 id="date-time-duration-conformance">
               <head>Limits and precision</head>
               
               <p>All conforming processors
                        <rfc2119>must</rfc2119> support year values in the range 1 to 9999,
                        and a minimum fractional second precision of 1 millisecond or three
                        digits (i.e., s.sss). However, processors
                        <rfc2119>may</rfc2119>  set larger <termref def="implementation-defined"/> limits
                        on the maximum number of digits they support in these two situations.  
                        Processors <rfc2119>may</rfc2119> also choose to support the year 0 and 
                        years with negative values.  The results of operations on dates that cross the year 
                        0 are <termref def="implementation-defined"/>.</p>
               <p>A processor that limits the number of digits in date and time datatype
                        representations may encounter overflow and underflow conditions when it
                        tries to execute the functions in <specref ref="dateTime-arithmetic"/>. In
                        these situations, the processor <rfc2119>must</rfc2119> return 00:00:00 in case of time underflow.
                  It <rfc2119>must</rfc2119> raise a dynamic 
                  error <errorref class="DT" code="0001"/> in case of overflow.</p>
               
               <p>Similarly, a processor that limits the precision of the seconds component
                  of date and time or duration values may need to deliver a rounded result for arithmetic operations.  
                  Such a processor <rfc2119>must</rfc2119> deliver a result
                  that is as close as possible to the mathematically precise result, given these limits: 
                  if two values are equally close, the one that is chosen is 
                  <termref def="implementation-defined"/>.</p>
               


 
            </div3>
         </div2>
         <div2 id="date-time-values">
            <head>Date/time datatype values</head>
            <p>As defined in <xspecref spec="DM31" ref="dates-and-times"/>, <code>xs:dateTime</code>, 
			<code>xs:date</code>, <code>xs:time</code>,  <code>xs:gYearMonth</code>, <code>xs:gYear</code>, 
			<code>xs:gMonthDay</code>, <code>xs:gMonth</code>, <code>xs:gDay</code> values, 
			referred to collectively as date/time values, are represented as seven components or properties: 
			<code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, 
			<code>second</code> and <code>timezone</code>.  The first five components are 
			<code>xs:integer</code> values.  The value of the <code>second</code> component is an <code>xs:decimal</code> 
			and the value of the <code>timezone</code> component is an <code>xs:dayTimeDuration</code>.  
			For all the primitive date/time datatypes, the <code>timezone</code> property is optional and may or may not 
			be present. Depending on the datatype, some of the remaining six properties must be present and 
			some must be <xtermref ref="dt-absent" spec="DM31">absent</xtermref>.   
               Absent, or missing, properties are represented by the empty sequence.  
			This value is referred to as the <emph>local</emph> value in that the value retains its original timezone.  
			Before comparing or subtracting <code>xs:dateTime</code> values, this local value <rfc2119>must</rfc2119>  
			be translated or <emph>normalized</emph> to UTC.</p>

            <p>For <code>xs:time</code>, <code>00:00:00</code> and <code>24:00:00</code> are alternate lexical forms 
			for the same value, whose canonical representation is <code>00:00:00</code>.  For <code>xs:dateTime</code>,
		    a time component <code>24:00:00</code> translates to <code>00:00:00</code> of the following day.</p>

            <div3 id="date-time-lexical-mapping">
               <head>Examples</head>
               <ulist>
                  <item>
                     <p>An <code>xs:dateTime</code> with lexical
                        representation <code>1999-05-31T05:00:00</code>
						is represented in the datamodel by <code>{ 1999, 5, 31, 5, 0, 0.0, () }</code>.</p>
                  </item>
                  <item>
                     <p>An <code>xs:dateTime</code> with lexical
                        representation <code>1999-05-31T13:20:00-05:00</code> 
                  is represented by <code>{ 1999, 5, 31, 13, 20, 0.0, xs:dayTimeDuration("-PT5H") }</code>.</p>
                  </item>
                  <item>
                     <p>An <code>xs:dateTime</code> with lexical
                        representation <code>1999-12-31T24:00:00</code> 
						is represented by <code>{ 2000, 1, 1, 0, 0, 0.0, () }</code>.</p>
                  </item>
                  <item>
                     <p>An <code>xs:date</code> with lexical
                        representation <code>2005-02-28+8:00</code> 
						is represented by <code>{ 2005, 2, 28, (), (), (), xs:dayTimeDuration("PT8H") }</code>.</p>
                  </item>
                  <item>
                     <p>An <code>xs:time</code> with lexical
                        representation <code>24:00:00</code> 
						is represented by <code>{ (), (), (), 0, 0, 0, () }</code>.</p>
                  </item>
               </ulist>
            </div3>
         </div2>

		 <div2 id="constructing-dateTime">
        <head>Constructing a dateTime</head>
		    <?local-function-index?>
            <div3 id="func-dateTime">
              <head><?function fn:dateTime?></head>
            </div3>
            <div3 id="func-unix-dateTime">
              <head><?function fn:unix-dateTime?></head>
			</div3>
         </div2>


         <div2 id="comp.datetime">
            <head>Comparison operators on duration, date and time values</head>
            <?local-function-index?>
            <p>The following comparison operators are defined on the <bibref ref="xmlschema-2"/>
                    date/time datatypes. Each operator takes two operands of the same
                    type and returns an <code>xs:boolean</code> result.</p>
            <p>
               <bibref ref="xmlschema-2"/> also states that the
                    order relation on date and time datatypes is
                    not a total order but a partial order because these
datatypes may or may not have a timezone.  This is handled as follows.
If either operand to a comparison function on date or time values does not have
                    an (explicit) timezone then, for the purpose of the operation, an implicit
                    timezone, provided by the dynamic context <xspecref spec="XP31" ref="id-xp-evaluation-context-components"/>, is assumed to be present as part of
                    the value. This creates a total order for all date and time values.</p>

					
            
			<p>An <code>xs:dateTime</code> can be considered to consist of seven components:
<code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, 
<code>second</code> and <code>timezone</code>.  For <code>xs:dateTime</code> six components (<code>year</code>, 
<code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code> and <code>second</code>) are required  
and  <code>timezone</code> is optional.   For other date/time values, of the first six components, some are required 
			   and others must be <xtermref ref="dt-absent" spec="DM31">absent</xtermref>.  
			   <code>Timezone</code> is always optional.  For example, for <code>xs:date</code>, 
the <code>year</code>, <code>month</code> and <code>day</code> components are required and <code>hour</code>, 
<code>minute</code> and <code>second</code> components must be absent;  for <code>xs:time</code> the <code>hour</code>, 
<code>minute</code> and <code>second</code> components are required and <code>year</code>, <code>month</code> and 
<code>day</code> are missing;  for <code>xs:gDay</code>, <code>day</code> is required and <code>year</code>, 
<code>month</code>, <code>hour</code>, <code>minute</code> and <code>second</code> are missing.</p>
            
            <note><p>In <bibref ref="xmlschema11-2"/>, a new <code>explicitTimezone</code> facet is available with values
            <code>optional</code>, <code>required</code>, or <code>prohibited</code> to 
            enable the timezone to be defined as mandatory or disallowed.</p></note>

            <p>Values of the date/time datatypes <code>xs:time</code>, <code>xs:gMonthDay</code>, <code>xs:gMonth</code>, 
			and <code>xs:gDay</code>, can be considered to represent a sequence of recurring time instants or time periods.  
			An <code>xs:time</code> occurs every day.  An <code>xs:gMonth</code> occurs every year.  Comparison operators 
			on these datatypes compare the starting instants of equivalent occurrences in the recurring series.  
			These <code>xs:dateTime</code> values are calculated  as described below.</p>

            <p>Comparison operators on <code>xs:date</code>, <code>xs:gYearMonth</code> and <code>xs:gYear</code> compare 
			their starting instants. These <code>xs:dateTime</code> values are calculated  as described below.</p>

          <p>The starting instant of an occurrence of a date/time value is an <code>xs:dateTime</code> 
             calculated by filling 
			in the missing components of the local value from a reference <code>xs:dateTime</code>.  An example of a suitable
         reference <code>xs:dateTime</code> is <code>1972-01-01T00:00:00</code>. Then, for example, the starting
             instant corresponding to the <code>xs:date</code> value <code>2009-03-12</code> is 
             <code>2009-03-12T00:00:00</code>; the starting instant corresponding to the <code>xs:time</code> value
             <code>13:30:02</code> is <code>1972-01-01T13:30:02</code>; and the starting instant corresponding to the
             <code>gMonthDay</code> value <code>--02-29</code> is <code>1972-02-29T00:00:00</code> (which explains
             why a leap year was chosen for the reference).</p>
         
         <note><p>In the previous version of this specification, the reference date/time chosen was
         <code>1972-12-31T00:00:00</code>. While this gives the same results, it produces a "starting instant" for 
         a <code>gMonth</code> or <code>gMonthDay</code> that bears no
         relation to the ordinary meaning of the term, and it also required special handling of short months. 
         The original choice was made to allow for leap seconds; but since leap seconds are not recognized 
         in date/time arithmetic, this is not actually necessary.</p></note>
             
             <!--If the value filled 
			in for a missing day component exceeds the maximum day value for the month, the last day of the month is used. 
			Suppose, for example, that the reference <code>xs:dateTime</code> is <code>1972-01-01T00:00:00</code> and the 
			<code>xs:date</code> value to be compared is <code>1993-03-31</code>.  Filling in the time components from the 
			reference <code>xs:dateTime</code> we get <code>1993-03-31T00:00:00</code> which is the starting instant of that 
			day.  Similarly, if the <code>xs:time</code> value <code>12:30:00</code> is to be compared, we fill in the 
			missing components from the reference <code>xs:dateTime</code> and we get <code>1972-12-31T12:30:00</code> 
			which is the time on that day.  For an <code>xs:gYearMonth</code> value of <code>1976-02</code> we fill in 
			the missing components, adjust for the last day in the month and get <code>1976-02-29T00:00:00</code>.</p>-->

            <p>If the <code>xs:time</code> value written as
			<code>24:00:00</code> is to be compared, filling in the missing components gives <code>1972-01-01T00:00:00</code>, 
			because <code>24:00:00</code> is an alternative representation of <code>00:00:00</code> (the lexical value 
			<code>"24:00:00"</code> is
			converted to the time components { 0, 0, 0 } before the missing components are filled
			in). This has the consequence that when ordering <code>xs:time</code> values, 
			<code>24:00:00</code> is
			considered to be earlier than <code>23:59:59</code>. However, when ordering 
			<code>xs:dateTime</code>
			values, a time component of <code>24:00:00</code> is considered equivalent to <code>00:00:00</code> on the
			following day.</p>

            <p>Note that the reference <code>xs:dateTime</code> does not have a timezone.  The <code>timezone</code> component 
			is never filled in from the reference <code>xs:dateTime</code>.  In some cases, if the date/time value does not 
			have a timezone, the implicit timezone from the dynamic context is used as the timezone.</p>

            <note>
               <p>This specification uses the reference <code>xs:dateTime 1972-01-01T00:00:00</code> in the description of the 
			   comparison operators.  Implementations may use other reference <code>xs:dateTime</code> values 
			   as long as they yield the same results.  The reference <code>xs:dateTime</code> used must meet the following 
			   constraints:  when it is used to supply components into <code>xs:gMonthDay</code> values, the year must allow 
			   for February 29 and so must be a leap year; when it is used to supply missing components into <code>xs:gDay</code> 
			   values, the month must allow for 31 days.  Different reference <code>xs:dateTime</code> values may be used for 
			   different operators.</p>

			   <!--<p>Historically, the choice of <code>1972-12-31</code> was made because the year was a leap year, the month had 31 days,
			   and the day contained a leap second. Subsequently, the decision was made not to support leap seconds in date/time comparisons
			   or arithmetic, which makes the choice of reference date less critical.-->
            </note>

            <div3 id="func-dateTime-equal">
               <head><?function op:dateTime-equal?></head>
            </div3>
            <div3 id="func-dateTime-less-than">
               <head><?function op:dateTime-less-than?></head>
            </div3>
            <div3 id="func-date-equal">
               <head><?function op:date-equal?></head>
            </div3>
            <div3 id="func-date-less-than">
               <head><?function op:date-less-than?></head>
            </div3>
            <div3 id="func-time-equal">
               <head><?function op:time-equal?></head>
            </div3>
            <div3 id="func-time-less-than">
               <head><?function op:time-less-than?></head>
            </div3>
            <div3 id="func-gYearMonth-equal">
               <head><?function op:gYearMonth-equal?></head>
            </div3>
            <div3 id="func-gYear-equal">
               <head><?function op:gYear-equal?></head>
             </div3>
            <div3 id="func-gMonthDay-equal">
               <head><?function op:gMonthDay-equal?></head>
            </div3>
            <div3 id="func-gMonth-equal">
               <head><?function op:gMonth-equal?></head>
            </div3>
            <div3 id="func-gDay-equal">
               <head><?function op:gDay-equal?></head>
            </div3>
         </div2>
         <div2 id="component-extraction-dateTime">
            <head>Component extraction functions on dates and times</head>
            <p>The date and time datatypes may be considered to be composite datatypes
                    in that they contain distinct properties or components. The extraction functions specified
                    below extract a single component from a date or time value. In all cases 
					the local value (that is, the original value as written, 
					without any timezone adjustment) is used. </p>
			<note>
			<p>A time written as <code>24:00:00</code> is treated as <code>00:00:00</code> on the
			following day.</p>
			</note>

            <?local-function-index?>
 
 
            <div3 id="func-year-from-dateTime">
               <head><?function fn:year-from-dateTime?></head>
            </div3>
            <div3 id="func-month-from-dateTime">
               <head><?function fn:month-from-dateTime?></head>
            </div3>
            <div3 id="func-day-from-dateTime">
               <head><?function fn:day-from-dateTime?></head>
            </div3>
            <div3 id="func-hours-from-dateTime">
               <head><?function fn:hours-from-dateTime?></head>
            </div3>
            <div3 id="func-minutes-from-dateTime">
               <head><?function fn:minutes-from-dateTime?></head>
            </div3>
            <div3 id="func-seconds-from-dateTime">
               <head><?function fn:seconds-from-dateTime?></head>
            </div3>
            <div3 id="func-timezone-from-dateTime">
               <head><?function fn:timezone-from-dateTime?></head>
            </div3>
            <div3 id="func-year-from-date">
               <head><?function fn:year-from-date?></head>
            </div3>
            <div3 id="func-month-from-date">
               <head><?function fn:month-from-date?></head>
            </div3>
            <div3 id="func-day-from-date">
               <head><?function fn:day-from-date?></head>
            </div3>
            <div3 id="func-timezone-from-date">
               <head><?function fn:timezone-from-date?></head>
            </div3>
            <div3 id="func-hours-from-time">
               <head><?function fn:hours-from-time?></head>
            </div3>
            <div3 id="func-minutes-from-time">
               <head><?function fn:minutes-from-time?></head>
            </div3>
            <div3 id="func-seconds-from-time">
               <head><?function fn:seconds-from-time?></head>
			</div3>
            <div3 id="func-timezone-from-time">
               <head><?function fn:timezone-from-time?></head>
            </div3>
         </div2>
 
         <div2 id="timezone.functions">
            <head>Timezone adjustment functions on dates and time values</head>
            <?local-function-index?>
            <p>These functions adjust the timezone component of an <code>xs:dateTime</code>, <code>xs:date</code> or
                    <code>xs:time</code> value.  The <code>$timezone</code> argument to these functions is defined as an 
					<code>xs:dayTimeDuration</code> but must be a valid timezone value.</p>
            <div3 id="func-adjust-dateTime-to-timezone">
               <head><?function fn:adjust-dateTime-to-timezone?></head>
   			</div3>
   			<div3 id="func-adjust-date-to-timezone">
                  <head><?function fn:adjust-date-to-timezone?></head>
   			</div3>
   			<div3 id="func-adjust-time-to-timezone">
                  <head><?function fn:adjust-time-to-timezone?></head>
   			</div3>
            <div3 id="func-civil-timezone">
                  <head><?function fn:civil-timezone?></head>
   			</div3>
         </div2>
         <div2 id="dateTime-arithmetic">
            <head>Arithmetic operators on durations, dates and times</head>
            <p>These functions support adding or subtracting a duration value to or from an
                    <code>xs:dateTime</code>, an <code>xs:date</code> or an <code>xs:time</code>
                    value. Appendix E of <bibref ref="xmlschema-2"/> describes an algorithm for
                    performing such operations.</p>
            <?local-function-index?>
            <div3 id="duration-limits">
               <head>Limits and precision</head>
               
              
               <p>A processor that limits the number of digits in date and time datatype
                  representations may encounter overflow and underflow conditions when it
                  tries to execute the functions in this section. In
                  these situations, the processor <rfc2119>must</rfc2119> return P0M or PT0S in
                  case of duration underflow and 00:00:00 in case of time underflow.
                  It <rfc2119>must</rfc2119> raise a dynamic error
                  <errorref class="DT" code="0001"/> in case of overflow.</p>
               <p>The value spaces of the two totally ordered subtypes of
                  <code>xs:duration</code> described in <specref ref="duration-subtypes"/> are
                  <code>xs:integer</code> months for <code>xs:yearMonthDuration</code>
                  and <code>xs:decimal</code> seconds for <code>xs:dayTimeDuration</code>. If
                  a processor limits the number of digits allowed in the representation of
                  <code>xs:integer</code> and <code>xs:decimal</code> then overflow and
                  underflow situations can arise when it tries to execute the functions in
                  <specref ref="duration-arithmetic"/>. In these situations the processor
                  <rfc2119>must</rfc2119> return zero in case of numeric underflow and P0M
                  or PT0S in case of duration underflow. It <rfc2119>must</rfc2119> raise a
                  dynamic error <errorref class="DT" code="0002"/> in case of overflow.</p>
            </div3>
            
            <div3 id="func-subtract-dateTimes">
               <head><?function op:subtract-dateTimes?></head>
            </div3>
            <div3 id="func-subtract-dates">
               <head><?function op:subtract-dates?></head>
            </div3>
            <div3 id="func-subtract-times">
               <head><?function op:subtract-times?></head>
            </div3>
            <div3 id="func-add-yearMonthDuration-to-dateTime">
               <head><?function op:add-yearMonthDuration-to-dateTime?></head>
            </div3>
            <div3 id="func-add-dayTimeDuration-to-dateTime">
               <head><?function op:add-dayTimeDuration-to-dateTime?></head>
            </div3>
            <div3 id="func-subtract-yearMonthDuration-from-dateTime">
               <head><?function op:subtract-yearMonthDuration-from-dateTime?></head>
            </div3>
            <div3 id="func-subtract-dayTimeDuration-from-dateTime">
               <head><?function op:subtract-dayTimeDuration-from-dateTime?></head>
            </div3>
            <div3 id="func-add-yearMonthDuration-to-date">
               <head><?function op:add-yearMonthDuration-to-date?></head>
            </div3>
            <div3 id="func-add-dayTimeDuration-to-date">
               <head><?function op:add-dayTimeDuration-to-date?></head>
            </div3>
            <div3 id="func-subtract-yearMonthDuration-from-date">
               <head><?function op:subtract-yearMonthDuration-from-date?></head>
            </div3>      
		    <div3 id="func-subtract-dayTimeDuration-from-date">
               <head><?function op:subtract-dayTimeDuration-from-date?></head>
            </div3>
            <div3 id="func-add-dayTimeDuration-to-time">
               <head><?function op:add-dayTimeDuration-to-time?></head>
            </div3>
            <div3 id="func-subtract-dayTimeDuration-from-time">
               <head><?function op:subtract-dayTimeDuration-from-time?></head>
            </div3>
         </div2>
         <div2 id="formatting-dates-and-times">
            <head>Formatting dates and times</head>
			

            <?local-function-index?>

            <p>Three functions are provided to represent dates and times as a string, using the conventions of a selected calendar,
 language, and country. The functions are presented in their customary fashion, 
 except for the rules and examples, which are described en bloc at <specref ref="rules-for-datetime-formatting"/>
               and <specref ref="date-time-examples"/>.</p>

       		<div3 id="func-format-dateTime">
      			<head><?function fn:format-dateTime?></head>
      		</div3>
      		<div3 id="func-format-date">
      			<head><?function fn:format-date?></head>
      		</div3>
      		<div3 id="func-format-time">
      			<head><?function fn:format-time?></head>
      		</div3>

		<div3 id="rules-for-datetime-formatting">
		<head>The date/time formatting functions</head>
            <p>The <function>fn:format-dateTime</function>, <function>fn:format-date</function>, 
and <function>fn:format-time</function> 
functions format <code>$value</code> as a string using 
the picture string specified by the <code>$picture</code> argument,
the calendar specified by the <code>$calendar</code> argument,
the language specified by the <code>$language</code> argument, 
and the country or other place name specified by the <code>$place</code> argument.
The result of the function is the formatted string representation of the supplied
  <code>xs:dateTime</code>, <code>xs:date</code>, or <code>xs:time</code> value.</p>
            <p>
               <termdef id="dt-date-formatting-function" term="date formatting function">The three 
                  functions <function>fn:format-dateTime</function>, <function>fn:format-date</function>, 
                  and <function>fn:format-time</function> are referred to collectively as the
                   <term>date formatting functions</term>.</termdef>
            </p>
            <p>If <code>$value</code> is the empty sequence, the function returns the empty sequence.</p>
            <p>Calling the two-argument form of each of the three functions is equivalent
to calling the five-argument form with each of the last three arguments set to an empty sequence.</p>
            <p>For details of the <code>$language</code>, <code>$calendar</code>, and
<code>$place</code> arguments, see <specref ref="lang-cal-place"/>.</p>
            <p>In general, the use of an invalid <code>$picture</code>, 
<code>$language</code>, <code>$calendar</code>, or
               <code>$place</code> argument results in a dynamic error <errorref class="FD" code="1340"/>. By contrast,
use of an option in any of these arguments that is valid but not supported by the implementation is
not an error, and in these cases the implementation is required to output the value in a fallback
representation. More detailed rules are given below.</p>
            <div4 id="date-picture-string">
               <head>The picture string</head>
               <p>The picture consists of a sequence of variable markers and literal substrings.
A substring enclosed in square brackets is interpreted as a variable marker; substrings
not enclosed in square brackets are taken as literal substrings. 
The literal substrings are optional and if present are rendered unchanged, including any whitespace. 
If an opening or closing square bracket 
is required within a literal substring, it <rfc2119>must</rfc2119> be doubled.
The variable markers are replaced in the result by strings representing 
aspects of the date and/or time to be formatted. These are described in detail below.</p>
               <p>A variable marker consists of a component specifier followed optionally 
by one or two presentation modifiers and/or optionally by a width modifier.
Whitespace within a variable marker is ignored.</p>
               <p>The variable marker may be separated into its components
               by applying the following rules:</p>
               <olist><!-- bug 12280 -->
                  <item><p>The component specifier is always present and is always a
                  single letter.</p></item>
                  <item><p>The width modifier may be recognized by the presence of a comma.</p></item>
                  <item><p>The substring between the component specifier and the comma (if present)
                     or the end of the string (if there is no comma) contains the first and
                     second presentation modifiers, both of which are optional. If this substring
                  contains a single character, this is interpreted as the first presentation modifier.
                  If it contains more than one character, the last character is examined: if it is valid
                  as a second presentation modifier then it is treated as such, and the preceding part
                  of the substring constitutes the first presentation modifier. Otherwise, the second
                  presentation modifier is presumed absent and the whole substring is interpreted as the
                  first presentation modifier.</p></item>
               </olist>
               <p>The <emph>component specifier</emph> indicates the component of the date or
time that is required, and takes the following values:</p>
               <table role="data">
                  <thead>
                     <tr>
                        <th align="left">Specifier</th>
                        <th align="left">Meaning</th>
                        <th align="left">Default Presentation Modifier</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td>Y</td>
                        <td>year (absolute value)</td>
                        <td>1</td>
                     </tr>
                     <tr>
                        <td>M</td>
                        <td>month in year</td>
                        <td>1</td>
                     </tr>
                     <tr>
                        <td>D</td>
                        <td>day in month</td>
                        <td>1</td>
                     </tr>
                     <tr>
                        <td>d</td>
                        <td>day in year</td>
                        <td>1</td>
                     </tr>
                     <tr>
                        <td>F</td>
                        <td>day of week</td>
                        <td>n</td>
                     </tr>
                     <tr>
                        <td>W</td>
                        <td>week in year</td>
                        <td>1</td>
                     </tr>
                     <tr>
                        <td>w</td>
                        <td>week in month</td>
                        <td>1</td>
                     </tr>
                     <tr>
                        <td>H</td>
                        <td>hour in day (24 hours)</td>
                        <td>1</td>
                     </tr>
                     <tr>
                        <td>h</td>
                        <td>hour in half-day (12 hours)</td>
                        <td>1</td>
                     </tr>
                     <tr>
                        <td>P</td>
                        <td>am/pm marker</td>
                        <td>n</td>
                     </tr>
                     <tr>
                        <td>m</td>
                        <td>minute in hour</td>
                        <td>01</td>
                     </tr>
                     <tr>
                        <td>s</td>
                        <td>second in minute</td>
                        <td>01</td>
                     </tr>
                     <tr>
                        <td>f</td>
                        <td>fractional seconds</td>
                        <td>1</td>
                     </tr>
                     <tr>
                        <td>Z</td>
                        <td>timezone</td>
                        <td>01:01</td>
                     </tr>
                     <tr>
                        <td>z</td>
                        <td>timezone (Same as Z, but modified where appropriate to include a prefix
                           as a time offset using GMT, for example GMT+1 or GMT-05:00. For this component there is a fixed
prefix of <code>GMT</code>, or a localized
variation thereof for the chosen language, and the remainder of the value is formatted as for specifier <code>Z</code>.)
                        </td>
                        <td>01:01</td>
                     </tr>
                     <tr>
                        <td>C</td>
                        <td>calendar: the name or abbreviation of a calendar name</td>
                        <td>n</td>
                     </tr>
                     <tr>
                        <td>E</td>
                        <td>era: the name of a baseline for the numbering of years, for example
                  the reign of a monarch</td>
                        <td>n</td>
                     </tr>
                  </tbody>
               </table>
	
               <p>A dynamic error is reported <errorref class="FD" code="1340"/>
 if the syntax of the picture is incorrect.</p>
               
               <p>A dynamic error is reported <errorref class="FD" code="1350"/>
 if a component specifier within the picture 
 refers to components that are not available in the given type of <code>$value</code>,
 for example if the picture supplied to the <function>fn:format-time</function> refers
 to the year, month, or day component.</p>
               <p>It is not an error to include a timezone component when the supplied
 value has no timezone. In these circumstances the timezone component will be ignored.</p>
               <p>The first <emph>presentation modifier</emph> indicates the style in which the
value of a component is to be represented. Its value may be
either:</p>
               <ulist>
                  <item>
                     <p>any format token permitted as a primary format token in the second argument 
of the <function>fn:format-integer</function> function, indicating
that the value of the component is to be output numerically using the specified number format (for example,
<code>1</code>, <code>01</code>, <code>i</code>, <code>I</code>, <code>w</code>, <code>W</code>,
or <code>Ww</code>) or </p>
                  </item>
                  <item>
                     <p>the format token <code>n</code>, <code>N</code>,
or <code>Nn</code>, indicating that the value of the component is to be output by name,
in lower-case, upper-case, or title-case respectively. Components that can be output by name
include (but are not limited to) months, days of the week, timezones, and eras. 
If the processor cannot output these components by name for the chosen calendar and language 
then it must use an <termref def="implementation-defined"/> fallback representation.</p>
                  </item>
               </ulist>
			   <p>If a comma is to be used as a grouping separator within the format token, then there must be a width
			   specifier. More specifically: if a variable marker
			   contains one or more commas, then the last comma is treated as introducing the width modifier, and all others
			   are treated as grouping separators. So <code>[Y9,999,*]</code> will output the year as <code>2,008</code>.</p>
               
               <p>It is not possible to use a closing square bracket as a grouping separator within the format token.</p>
			    
               <p>If the implementation does not support the use of the requested format token, it <rfc2119>must</rfc2119>
use the default presentation modifier for that component.</p>
               <p>If the first presentation modifier is present, then it may optionally be followed by
a second presentation modifier as follows:</p>
               <table role="longlastcol">
                  <thead>
                     <tr>
                        <th align="left">Modifier</th>
                        <th align="left">Meaning</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td>either <code>a</code> or <code>t</code></td>
                        <td>indicates alphabetic or traditional numbering respectively,
                           the default being <termref def="implementation-defined"/>. 
                           This has the same meaning as in the second argument of <function>fn:format-integer</function>.</td>
                     </tr>
                     <tr>
                        <td>either <code>c</code> or <code>o</code></td>
                        <td>indicates cardinal or ordinal numbering respectively, for example
                           <code>7</code> or <code>seven</code> for a cardinal number, or <code>7th</code>,
                           <code>seventh</code>, or <code>7º</code>
                           for an ordinal number.
						This has the same meaning as
in the second argument of <function>fn:format-integer</function>. 
The actual representation of the ordinal form of a number
may depend not only on the language, but also on the grammatical context (for example,
in some languages it must agree in gender).</td>
                     </tr>
                  </tbody>
               </table>
			   
               <note>
                  <p>Although the formatting rules are expressed in terms of the rules
for format tokens in <function>fn:format-integer</function>, the formats actually used may be specialized
to the numbering of date components where appropriate. For example, in Italian, it is conventional to
use an ordinal number (<code>primo</code>) for the first day of the month, and cardinal numbers
(<code>due, tre, quattro ...</code>) for the remaining days. A processor may therefore use
this convention to number days of the month, ignoring the presence or absence of the ordinal
presentation modifier.</p>
               </note>
               
            </div4>
		   <div4 id="width-modifier">
		      <head>The Width Modifier</head>

		   <p>Whether or not a presentation modifier is included, a width modifier may be supplied. This
indicates the number of characters to be included in the representation of the value.</p>
               <p>The width modifier, if present, is introduced by a comma. It takes the form:</p>
               <p>
                  <code>&#xa0;&#xa0;&#xa0;","&#xa0;&#xa0;min-width ("-" max-width)?</code>
               </p>
               <p>where <code>min-width</code> is either an unsigned integer indicating the minimum number of characters to
be output, or <code>*</code> indicating that there is no explicit minimum, and 
<code>max-width</code> is either an unsigned integer indicating the maximum number of characters to
be output, or <code>*</code> indicating that there is no explicit maximum; if <code>max-width</code>
is omitted then <code>*</code> is assumed.</p>
   
		      <p>A dynamic error (<errorref  class="FD" code="1340"/>) is raised if 
      <code>min-width</code> is present and less than one, or if
      <code>max-width</code> is present and less than one or less than <code>min-width</code>. 
   </p>

               <p>A format token containing more than one digit, such as <code>001</code> or <code>9999</code>, sets the
minimum and maximum width to the number of digits appearing in the format token; if a width
modifier is also present, then the width modifier takes precedence.</p>
		      
		      
		   </div4>
		   <div4 id="formatting-integer-valued-components">
		      <head>Formatting Integer-Valued Date/Time Components</head>
		      
		      <p>The rules in this section apply to the majority of integer-valued components: specifically <code>M D d F W w H h m s</code>.</p>
		      
		      <p>In the rules below, the term <term>decimal digit pattern</term> has the meaning given in <specref ref="func-format-integer"/>.</p>
		      
		         
		         <olist>
		            <item>
		               <p>If the first presentation modifier takes the form of a <term>decimal digit pattern</term>:</p>
		                <olist>
		                   <item><p>If there is no width modifier, then the value is formatted according to 
		                      the rules of the <code>format-integer</code> function.</p></item>
		                   <item><p>If there is a width modifier, then the first presentation modifier 
		                      is adjusted as follows:</p>
		                   <olist>
		                      <item><p>If the decimal digit pattern includes a grouping separator, the output is 
		                         implementation-defined (but this is not an error).
		                      </p>
		                         <note><p>Use of a width modifier together with grouping separators is inadvisable 
		                            for this reason. It is never necessary to use a width modifier with a decimal 
		                            digit pattern, since the same effect can be achieved by use of optional digit signs.</p></note>
		                      </item>
		                      <item><p>Otherwise, the number of mandatory-digit-sign characters in the presentation 
		                         modifier is increased if necessary. This is done first by replacing optional-digit-signs 
		                         with mandatory-digit-signs, starting from the right, and then prepending mandatory-digit-signs 
		                         to the presentation modifier, until the number of mandatory-digit-signs is equal to the 
		                         minimum width. Any mandatory-digit-signs that are added by this process must use the 
		                         same decimal digit family as existing mandatory-digit-signs in the presentation modifier 
		                         if there are any, or ASCII digits otherwise.
		                      </p></item>
		                      <item><p>The maximum width, if specified, is ignored.
		                      </p></item>
		                      <item><p>The output is then as defined using the <code>format-integer</code> function with this adjusted decimal digit pattern.
		                      </p></item>
		                   </olist></item>
		                </olist>
		            
		            </item>
		            <item>
		               <p>If the first presentation modifiers is one of <code>N</code>, <code>n</code>, or <code>Nn</code>:</p>
		               <olist>
		                  <item><p>Let <var>FN</var> be the full name of the component, that is, the form of the name 
		                     that would be used in the absence of any width modifier.</p></item>
		                  <item><p>If <var>FN</var> is shorter than the minimum width, then it is padded by appending spaces to the end of the name.
		                  </p></item>
		                  <item><p>If <var>FN</var> is longer than the maximum width, then it is abbreviated, either 
		                     by choosing a conventional abbreviation that fits within the maximum width (for example, 
		                     “Wednesday” might be abbreviated to “Weds”), or by removing characters from the end 
		                     of <var>FN</var> until it fits within the maximum width.
		                  </p></item>
		               </olist>
		            </item>
		            <item><p>For other presentation modifiers:</p>
		               <olist>
		                  <item><p>Any adjustment of the value to fit within the requested width range is implementation-defined. </p></item>
		                  <item><p>The value should not be truncated if this results in output that will not be meaningful to users (for example, 
		                     there is no sensible way to truncate Roman numerals).</p></item>
		                  <item><p>If shorter than the minimum width, the value should be padded to the minimum width, either by appending spaces, 
		                     or in some other way appropriate to the numbering scheme.</p></item>
		               </olist>
		            </item>
		            
		         </olist>
		   </div4>
		   <div4 id="formatting-year-component">
		      <head>Formatting the Year Component</head>
		
		   
		         <p>The rules for the year component (Y) are the same as those in <specref ref="formatting-integer-valued-components"/>, 
		            except that the value of the year as output is the value of the year component of the supplied value modulo ten to the power 
		            <var>N</var> where <var>N</var> is determined as follows: 
		         </p>
		         <olist>
		            <item><p>If the width modifier is present and defines a finite maximum width, then that maximum width.
		            </p></item>
		            <item><p>Otherwise, if the first presentation modifier takes the form of a decimal-digit-pattern, 
		               then:</p>
		               <olist>
		                  <item><p>Let <var>W</var> be the number of optional-digit-signs and mandatory-digit-signs in that decimal-digit-pattern.</p></item>
		                  <item><p>If <var>W</var> is 2 or more, then <var>W</var>.</p></item> 
		               </olist>
		            </item>
		            <item><p>Otherwise, <var>N</var> is infinity (that is, the year is output in full).</p></item>
		         </olist>
		   </div4>
		   <div4 id="formatting-fractional-seconds">
		      <head>Formatting Fractional Seconds</head>
		   
		      <p>The output for the fractional seconds component (<code>f</code>) is equivalent to the result of the following algorithm: </p>
		         <olist>
		            <item><p>If the first presentation modifier contains no Unicode digit, then the output is implementation-defined.
		            </p>
		            </item>
		            <item><p>Otherwise, the value of the fractional seconds is output as follows:</p>
		            <olist>
		               <item><p>If there is no width modifier and the first presentation modifier comprises in its
		                  entirety a single mandatory-digit-sign (for example the default <code>1</code>), then
		                  the presentation modifier is extended on the right with as many optional-digit-signs as
		                  are needed to accommodate the actual fractional seconds precision encountered in the
		                  value to be formatted.
		               </p></item>
		               <item><p>If there is a width modifier, then the first presentation modifier 
		                  is adjusted as follows:</p>
		                  <olist>
		                     
		                     <item><p>If a minimum width is specified, and if this exceeds the number of mandatory-digit-sign characters 
		                        in the first presentation modifier, then the first presentation modifier is adjusted. 
		                        This is done first by replacing optional-digit-signs 
		                        with mandatory-digit-signs, starting from the left, and then appending mandatory-digit-signs 
		                        to the presentation modifier, until the number of mandatory-digit-signs is equal to the 
		                        minimum width. Any mandatory-digit-signs that are added by this process must use the 
		                        same decimal digit family as existing mandatory-digit-signs in the presentation modifier.
		                     </p></item>
		                     <item><p>If a maximum width is specified, the first presentation modifier is extended on the right
		                        with as many optional-digit-signs as are needed to ensure that the number of mandatory-digit-signs
		                        and optional-digit-signs is at least equal to the maximum width.
		                     </p></item>
		            
		                  </olist>
		               </item>
		               <item><p>The sequence of characters in the (adjusted) first presentation modifier is reversed (for example, 
		                  <code>999'###</code> becomes <code>###'999</code>). 
		                  If the result is not a valid <term>decimal digit pattern</term>, then the output is 
		                  <termref def="implementation-defined">implementation-defined</termref>.
		               </p></item>
		               <item><p>The sequence of digits in the conventional decimal representation of the fractional seconds component 
		                  is reversed, with insignificant zeroes removed, and the result is treated as an integer. For example, if the 
		                  seconds value is <code>25.8235</code>, the reversed fractional seconds value is <code>5328</code>.
		               </p></item>
		               <item><p>The reversed fractional seconds value is formatted using the reversed decimal digit pattern according to the 
		                  rules of the <function>fn:format-integer</function> function. Given the examples above, the result is <code>5'328</code>
		               </p></item>
		               <item><p>The resulting string is reversed. In our example, the result is <code>823'5</code>.</p></item>
		               <item><p>If the result contains more digits than the number of mandatory-digit-signs and optional-digit-signs in the 
		                  decimal digit pattern, then excess digits 
		                  are removed from the right hand end (that is, the value is truncated towards zero rather than being rounded). 
		                  Any grouping separator that immediately precedes a removed digit 
		                  is also removed.</p></item>
		            </olist>
		            </item>
		         </olist>
		      <note>
		         <p>The reason for presenting the algorithm in this way is that it enables maximum reuse of the rules defined for
		            <function>fn:format-integer</function>. Since the fractional seconds value is not properly an integer, the rules do not
		            work if used directly: for example, the positions of grouping separators need to be counted from the left rather
		            than from the right. Implementations, as always, are free to use a different algorithm that yields the same result.</p>
		      </note>
		      <note>
		         <p>A format token consisting of a single digit,
		            such as <code>1</code>, does not constrain the number of digits in the output. 
		            In the case of fractional seconds in particular, <code>[f001]</code> requests three decimal digits,
		            <code>[f01]</code> requests two digits, but <code>[f1]</code> will retain all digits in the
		            supplied date/time value (the maximum number of digits is implementation-defined). 
		            If exactly one digit is required, this can be achieved using the component specifier 
		            <code>[f1,1-1]</code>.</p>
		      </note>

             
            </div4>
		   <div4 id="formatting-timezones">
		      <head>Formatting timezones</head>
		      <p>Special rules apply to the formatting of timezones. When the component specifiers <code>Z</code>
		      or <code>z</code> are used, the rules in this section override any rules given elsewhere in the case of
		      discrepancies.</p>
		      <p>If the date/time value to be formatted does not include a timezone offset, then the timezone component
		      specifier is generally ignored (results in no output). The exception is where military timezones are used
		      (format <code>ZZ</code>) in which case the string <code>"J"</code> is output, indicating local time.</p>
		      <ulist>
		      <item><p>When the component specifier is <code>z</code>, the output is the same as for component specifier
		      <code>Z</code>, except that it is prefixed by the characters <code>GMT</code> or some localized
		      equivalent. The prefix is omitted, however, in cases where the timezone is identified by name rather than by
		      a numeric offset from UTC.</p></item>
		      <item><p>If the first <var>presentation modifier</var> is numeric and comprises one or two digits 
		         with no <var>grouping-separator</var> (for example <code>1</code>
		      or <code>01</code>), then the timezone is formatted as a displacement from UTC in hours, preceded by a plus or minus
		      sign: for example <code>-5</code> or <code>+03</code>. If the actual timezone offset is not an integral number of hours,
		      then the minutes part of the offset is appended, separated by a colon: for example <code>+10:30</code> or 
		         <code>-1:15</code>.</p></item>
		      <item><p>If the first <var>presentation modifier</var> is numeric with a <var>grouping-separator</var> (for example <code>1:01</code>
		         or <code>01.01</code>), then the timezone offset is output in hours and minutes, separated by the grouping separator,
		      even if the number of minutes is zero: for example <code>+5:00</code> or <code>+10.30</code>.</p>
		      </item><item><p>If the first <var>presentation modifier</var> is numeric and comprises three or four digits with no
		      <var>grouping-separator</var>, for example <code>001</code> or <code>0001</code>, then the timezone offset
		      is shown in hours and minutes with no separator, for example <code>-0500</code> or <code>+1030</code>.
		      </p></item>
		      <item><p>If the first <var>presentation modifier</var> is numeric, in any of the above formats, and the second
		      <var>presentation modifier</var> is <code>t</code>, then a zero timezone offset (that is, UTC) is output as <code>Z</code> instead
		      of a signed numeric value. In this presentation modifier is absent or if the timezone offset is non-zero, 
		      then the displayed timezone offset is preceded by a <code>-</code> sign for negative offsets
		      or a <code>+</code> sign for non-negative offsets.</p></item>
		         <item><p>If the first <var>presentation modifier</var> is <code>Z</code>, then the timezone is formatted
		         as a military timezone letter, using the convention Z = +00:00, A = +01:00, B = +02:00, ..., M = +12:00, 
		         N = -01:00, O = -02:00, ... Y = -12:00. The letter J (meaning local time) is used in the case of a 
		         value that does not specify a timezone offset. Timezone offsets that have no representation in this system
		         (for example Indian Standard Time, +05:30) are output as if the format <code>01:01</code> had been requested.</p></item>
		      <item><p>If the first <var>presentation modifier</var> is <code>N</code>, then the timezone is output
		      (where possible) as a timezone name, for example <code>EST</code> or <code>CET</code>. The same timezone
		      offset has different names in different places; it is therefore <rfc2119>recommended</rfc2119> that this option
		      should be used only if a country code (see <bibref ref="ISO3166"/>) or IANA timezone name (see <bibref ref="olson"/>) is supplied in the <code>$place</code> argument.
		      In the absence of this information, the implementation may apply a default, for example by using the timezone
		      names that are conventional in North America. If no timezone name can be identified, the timezone offset is
		      output using the fallback format <phrase diff="chg" at="2023-04-24"><code>01:01</code></phrase>.</p></item></ulist>
		      <p>The following examples illustrate options for timezone formatting.</p>
		      <table role="small complex data">
		         <thead>
		            <tr>
		               <th>Variable marker</th>
		               <th><code>$place</code></th>
		               <th colspan="5">Timezone offsets (with time = 12:00:00)</th>
		            </tr>
		            <tr>
		               <th>&#xa0;</th>
		               <th>&#xa0;</th>
		               <th>-10:00</th>
		               <th>-05:00</th>
		               <th>+00:00</th>
		               <th>+05:30</th>
		               <th>+13:00</th>          
		            </tr>
		         </thead>
		         <tbody>
		            <tr>
    		            <td>[Z]</td>
    		            <td>()</td>
    		            <td>-10:00</td>
    		            <td>-05:00</td>
    		            <td>+00:00</td>
    		            <td>+05:30</td>
    		            <td>+13:00</td>
		            </tr>
		            <tr>
		               <td>[Z0]</td>
		               <td>()</td>
		               <td>-10</td>
		               <td>-5</td>
		               <td>+0</td>
		               <td>+5:30</td>
		               <td>+13</td>
		            </tr>
		            <tr>
		               <td>[Z0:00]</td>
		               <td>()</td>
		               <td>-10:00</td>
		               <td>-5:00</td>
		               <td>+0:00</td>
		               <td>+5:30</td>
		               <td>+13:00</td>
		            </tr>
		            <tr>
		               <td>[Z00:00]</td>
		               <td>()</td>
		               <td>-10:00</td>
		               <td>-05:00</td>
		               <td>+00:00</td>
		               <td>+05:30</td>
		               <td>+13:00</td>
		            </tr>
		            <tr>
		               <td>[Z0000]</td>
		               <td>()</td>
		               <td>-1000</td>
		               <td>-0500</td>
		               <td>+0000</td>
		               <td>+0530</td>
		               <td>+1300</td>
		            </tr>
		            <tr>
		               <td>[Z00:00t]</td>
		               <td>()</td>
		               <td>-10:00</td>
		               <td>-05:00</td>
		               <td>Z</td>
		               <td>+05:30</td>
		               <td>+13:00</td>
		            </tr>
		            <tr>
		               <td>[z]</td>
		               <td>()</td>
		               <td>GMT&#x2011;10:00</td>
		               <td>GMT&#x2011;05:00</td>
		               <td>GMT+00:00</td>
		               <td>GMT+05:30</td>
		               <td>GMT+13:00</td>
		            </tr>
		            <tr>
		               <td>[ZZ]</td>
		               <td>()</td>
		               <td>W</td>
		               <td>R</td>
		               <td>Z</td>
		               <td>+05:30</td>
		               <td>+13:00</td>
		            </tr>
		            <tr>
		               <td>[ZN]</td>
		               <td>"us"</td>
		               <td>HST</td>
		               <td>EST</td>
		               <td>GMT</td>
		               <td>IST</td>
		               <td>+13:00</td>
		            </tr>
		            <tr>
		               <td>[H00]:[M00] [ZN]</td>
		               <td>"America/New_York"</td>
		               <td>06:00 EST</td>
		               <td>12:00 EST</td>
		               <td>07:00 EST</td>
		               <td>01:30 EST</td>
		               <td>18:00 EST</td>
		            </tr>
		         </tbody>
		      </table>
		      <p>If a width specifier is present when formatting a timezone, then the representation as defined in this section is padded to the minimum
		      width as described in <specref ref="width-modifier"/>, but it is never shortened.</p>
		   </div4>
		   <div4 id="formatting-other-components">
		      <head>Formatting Other Components</head>
		      <p>This section applies to the remaining components: <code>P</code> (am/pm marker), <code>C</code> (calendar),
		      and <code>E</code> (era).</p>
		      <p>The output for these components is entirely <termref def="implementation-defined">implementation-defined</termref>.
		      The default presentation modifier for these components is <code>n</code>, indicating that they are output as names (or
		      conventional abbreviations), and the chosen names will in many cases depend on the chosen language: see <specref ref="lang-cal-place"/>.</p>
		   </div4>
            <div4 id="lang-cal-place">
               <head>The language, calendar, and place arguments</head>
               <p>The set of languages, calendars, and places that are supported in the 
<termref def="dt-date-formatting-function">date formatting functions</termref> is
<termref def="implementation-defined">implementation-defined</termref>. When
any of these arguments is omitted or is an empty sequence, an <termref def="implementation-defined">implementation-defined</termref>
default value is used.</p>
               <imp-def-feature>The set of languages, calendars, and places that are supported in the 
<termref def="dt-date-formatting-function">date formatting functions</termref> is
implementation-defined. If any of these arguments is omitted or set to an empty sequence, 
the default is implementation-defined.</imp-def-feature>
               <p>If the fallback representation uses a different calendar from that requested,
the output string <rfc2119>must</rfc2119> identify the calendar actually used, for example by
prefixing the string with <code>[Calendar: X]</code> (where X is the calendar actually used),
localized as appropriate to the
requested language. If the fallback representation uses a different language
from that requested, the output string <rfc2119>must</rfc2119> identify the language actually
used, for example by prefixing the string with <code>[Language: Y]</code> (where Y is the language
actually used) localized in an
implementation-dependent way. If a particular component of the value cannot be output in
the requested format, it <rfc2119>should</rfc2119> be output in the default format for
that component.</p>
               <p>The <code>$language</code> argument specifies the language to be used for the result string 
of the function. The value of the argument <rfc2119>should</rfc2119> be either the empty sequence
or a value that would be valid for the <code>xml:lang</code> attribute (see <bibref ref="xml"/>).
Note that this permits the identification of sublanguages
based on country codes (from <bibref ref="ISO3166"/>) as well as identification of dialects
and of regions within a country.</p>
               <p>If the <code>$language</code> 
argument is omitted or is set to an empty sequence, or if it is set to an invalid value or a
value that the implementation does not recognize, 
then the processor uses the default language defined in the dynamic context.</p>
               <p>The language is used to select the appropriate language-dependent forms of:</p>
               <ulist>
                  <item><p>names (for example, of months)</p></item>
                  <item><p>numbers expressed as words or as ordinals (<code>twenty, 20th, twentieth</code>)</p></item>
                  <item><p>hour convention (0-23 vs 1-24, 0-11 vs 1-12)</p></item>
                  <item><p>first day of week, first week of year</p></item>
               </ulist>
               <p>Where appropriate this choice may also take into account the value of the
<code>$place</code> argument, though this <rfc2119>should</rfc2119> not be used to override the
language or any sublanguage that is specified as part of the <code>language</code>
argument.</p>
               <p>The choice of the names and abbreviations used in any given language is 
<termref def="implementation-defined">implementation-defined</termref>. For example,
one implementation might abbreviate July as <code>Jul</code> while another uses <code>Jly</code>. In German,
one implementation might represent Saturday as <code>Samstag</code> while another
uses <code>Sonnabend</code>. Implementations <rfc2119>may</rfc2119> provide mechanisms allowing users to
control such choices.</p>
               <imp-def-feature>The choice of the names and abbreviations used in any given language for
calendar units such as days of the week and months of the year is 
<termref def="implementation-defined">implementation-defined</termref>.</imp-def-feature>
               <p>Where ordinal numbers are used, the selection of the correct representation of the 
ordinal (for example, the grammatical gender) <rfc2119>may</rfc2119> depend on the component being formatted and on its
textual context in the picture string.</p>
               <p>The <code>calendar</code> attribute specifies that the <code>dateTime</code>, <code>date</code>,
or <code>time</code> supplied in the <code>$value</code> argument <rfc2119>must</rfc2119> be 
converted to a value in the specified calendar and then converted to a string using the 
conventions of that calendar.</p>
               <p>The calendar value if present <rfc2119>must</rfc2119> be a valid <code>EQName</code> 
                  (dynamic error: <errorref  class="FD" code="1340"/>).
                  If it is a lexical <code>QName</code> then it is expanded into an expanded QName 
                     using the statically known namespaces; if it has no prefix then it represents an expanded-QName in no namespace.
                  If the expanded QName is in no namespace, 
                  then it <rfc2119>must</rfc2119> identify a calendar with a designator specified below 
                  (dynamic error: <errorref  class="FD" code="1340"/>). 
If the expanded QName is in a namespace then it identifies the calendar in an <termref def="implementation-defined">implementation-defined</termref> way.</p>
               <p>If the <code>$calendar</code> argument is omitted or is set to an empty sequence
                  then the default calendar defined in the dynamic context is used.</p>
               <note>
                  <p>The calendars listed below were known to be in use during the 
last hundred years. Many other calendars have been used in the past.</p>
                  <p>This specification does not define any of these calendars, nor the way that they
map to the value space of the <code>xs:date</code> datatype in <bibref ref="xmlschema-2"/>.
There may be ambiguities when dates are recorded using different calendars. 
For example, the start of a new day is not simultaneous in different calendars, 
and may also vary geographically (for example, based on the time of sunrise or sunset).
Translation of dates is therefore more reliable when the time of day is also known, and
when the geographic location is known. 
When translating dates between
one calendar and another, the processor may take account of the values
of the <code>$place</code> and/or <code>$language</code> arguments, with the 
                     <code>$place</code>
argument taking precedence.</p>
                  <p>Information about some of these calendars, and algorithms for converting between them, may
be found in <bibref ref="CALCALC"/>.</p>
               </note>
               <table role="data">
                  <thead>
                     <tr>
                        <th>Designator</th>
                        <th>Calendar</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td>AD</td>
                        <td>Anno Domini (Christian Era)</td>
                     </tr>
                     <tr>
                        <td>AH</td>
                        <td>Anno Hegirae (Islamic Era)</td>
                     </tr>
                     <tr>
                        <td>AME</td>
                        <td>Mauludi Era (solar years since Muhammad’s birth)</td>
                     </tr>
                     <tr>
                        <td>AM</td>
                        <td>Anno Mundi (Jewish Calendar)</td>
                     </tr>
                     <tr>
                        <td>AP</td>
                        <td>Anno Persici</td>
                     </tr>
                     <tr>
                        <td>AS</td>
                        <td>Aji Saka Era (Java)</td>
                     </tr>
                     <tr>
                        <td>BE</td>
                        <td>Buddhist Era</td>
                     </tr>
                     <tr>
                        <td>CB</td>
                        <td>Cooch Behar Era</td>
                     </tr>
                     <tr>
                        <td>CE</td>
                        <td>Common Era</td>
                     </tr>
                     <tr>
                        <td>CL</td>
                        <td>Chinese Lunar Era</td>
                     </tr>
                     <tr>
                        <td>CS</td>
                        <td>Chula Sakarat Era</td>
                     </tr>
                     <tr>
                        <td>EE</td>
                        <td>Ethiopian Era</td>
                     </tr>
                     <tr>
                        <td>FE</td>
                        <td>Fasli Era</td>
                     </tr>
                     <tr>
                        <td>ISO</td>
                        <td>ISO 8601 calendar</td>
                     </tr>
                     <tr>
                        <td>JE</td>
                        <td>Japanese Calendar</td>
                     </tr>
                     <tr>
                        <td>KE</td>
                        <td>Khalsa Era (Sikh calendar)</td>
                     </tr>
                     <tr>
                        <td>KY</td>
                        <td>Kali Yuga</td>
                     </tr>
                     <tr>
                        <td>ME</td>
                        <td>Malabar Era</td>
                     </tr>
                     <tr>
                        <td>MS</td>
                        <td>Monarchic Solar Era</td>
                     </tr>
                     <tr>
                        <td>NS</td>
                        <td>Nepal Samwat Era</td>
                     </tr>
                     <tr>
                        <td>OS</td>
                        <td>Old Style (Julian Calendar)</td>
                     </tr>
                     <tr>
                        <td>RS</td>
                        <td>Rattanakosin (Bangkok) Era</td>
                     </tr>
                     <tr>
                        <td>SE</td>
                        <td>Saka Era</td>
                     </tr>
                     <tr>
                        <td>SH</td>
                        <td>Solar Hijri (Islamic Era, used in Iran and Afghanistan)</td>
                     </tr>
                     <tr>
                        <td>SS</td>
                        <td>Saka Samvat</td>
                     </tr>
                     <tr>
                        <td>TE</td>
                        <td>Tripurabda Era</td>
                     </tr>
                     <tr>
                        <td>VE</td>
                        <td>Vikrama Era</td>
                     </tr>
                     <tr>
                        <td>VS</td>
                        <td>Vikrama Samvat Era</td>
                     </tr>
                  </tbody>
               </table>
               <p>At least one of the above calendars <rfc2119>must</rfc2119> be supported. It is 
<termref def="implementation-defined">implementation-defined</termref> which
calendars are supported.</p>
               <p>The ISO 8601 calendar (<bibref ref="ISO8601"/>), 
which is included in the above list and designated <code>ISO</code>, 
is very similar to the Gregorian calendar designated <code>AD</code>, but it
differs in several ways. The ISO calendar
    is intended to ensure that date and time formats can be read
    easily by other software, as well as being legible for human
    users. The ISO calendar
prescribes the use of particular numbering conventions as defined in
ISO 8601, rather than allowing these to be localized on a per-language basis. 
In particular it
    provides a numeric “week date” format which identifies dates by
    year, week of the year, and day in the week; 
in the ISO calendar the days of the week are numbered from 1 (Monday) to 7 (Sunday), and
week 1 in any calendar year is the week (from Monday to Sunday) that includes the first Thursday
of that year. The numeric values of the components year, month, day, hour, minute, and second
are the same in the ISO calendar as the values used in the lexical representation of the date and
time as defined in <bibref ref="xmlschema-2"/>. The era (<code>E</code> component)
with this calendar is either a minus sign (for negative years) or a zero-length string (for positive years).
For dates before 1 January, AD 1, year numbers in
    the ISO and AD calendars are off by one from each other: ISO year
    0000 is 1 BC, -0001 is 2 BC, etc.</p>
               <p>ISO 8601 does not define a numbering for weeks within a month. When the <code>w</code>
               component is used, the convention to be adopted is that each Monday-to-Sunday week is considered to
               fall within a particular month if its Thursday occurs in that month; the weeks that fall in a particular
               month under this definition are numbered starting from 1. Thus, for example, 
               29 January 2013 falls in week 5 because the Thursday of the week (31 January 2013) is the fifth Thursday
               in January, and 1 February 2013 is also in week 5 for the same reason.</p>
               <note>
                  <p>The value space of the date and time datatypes, as defined in XML Schema, is based on
absolute points in time. The lexical space of these datatypes defines a 
representation of these absolute points in time using the proleptic Gregorian calendar,
that is, the modern Western calendar extrapolated into the past and the future; but the value space
is calendar-neutral. The
<termref def="dt-date-formatting-function">date formatting functions</termref> produce a representation
of this absolute point in time, but denoted in a possibly different calendar. So,
for example, the date whose lexical representation in XML Schema is <code>1502-01-11</code> 
(the day on which Pope Gregory XIII was born) might be
formatted using the Old Style (Julian) calendar as <code>1 January 1502</code>. This reflects the fact
that there was at that time a ten-day difference between the two calendars. It would be
incorrect, and would produce incorrect results, to represent this date in an element or attribute 
of type <code>xs:date</code> as <code>1502-01-01</code>, even though this might reflect the way 
the date was recorded in contemporary documents.</p>
                  <p>When referring to years occurring in antiquity, modern historians generally
use a numbering system in which there is no year zero (the year before 1 CE
is thus 1 BCE). This is the convention that <rfc2119>should</rfc2119> be used when the
requested calendar is OS (Julian) or AD (Gregorian). When the requested
calendar is ISO, however, the conventions of ISO 8601 <rfc2119>should</rfc2119> be followed:
here the year before +0001 is numbered zero. In <bibref ref="xmlschema-2"/> (version 1.0), 
the value space for <code>xs:date</code> and <code>xs:dateTime</code>
does not include a year zero: however, XSD 1.1 endorses the ISO 8601 convention. This means that the date on
which Julius Caesar was assassinated has the ISO 8601 lexical representation
-0043-03-13, but will be formatted as 15 March 44 BCE in the Julian calendar
or 13 March 44 BCE in the Gregorian calendar (dependent on the chosen
localization of the names of months and eras).</p>
               </note>
               <p>The intended use of the <code>$place</code> argument is to identify
 the place where an event
represented by the <code>dateTime</code>, <code>date</code>,
or <code>time</code> supplied in the <code>$value</code> argument took place or will take place.
                  If the <code>$place</code> argument is omitted or is set
                  to an empty sequence, then the default place defined in the dynamic context is used.
If the value is supplied, and is not the empty sequence, then it <rfc2119>should</rfc2119> 
                  either be a country code or an IANA timezone name.
               If the value does not take this form, or if its value is not recognized
               by the implementation, then the default place defined in the dynamic context is used.</p>
             
               <ulist>
   <item><p>Country codes are defined in <bibref ref="ISO3166"/>. Examples are <code>"de"</code> for Germany
      and <code>"jp"</code> for Japan. Implementations <rfc2119>may</rfc2119> also allow the use
of codes representing subdivisions of a country from ISO 3166-2, or codes representing formerly used names of
countries from ISO 3166-3</p></item>
                  <item><p>IANA timezone names are defined in the IANA timezone database <bibref ref="olson"/>.
   Examples are <code>"America/New_York"</code> and <code>"Europe/Rome"</code>.</p></item>
</ulist>             
<p>This argument is not intended to identify the location of the user 
for whom the date or time is being formatted;
that should be done by means of the <code>$language</code> attribute. 
This information 
<rfc2119>may</rfc2119> be used to provide additional information when converting dates between
calendars or when deciding how individual components of the date and time are to be formatted. 
For example, different countries using the Old Style (Julian) calendar started the new year on different
days, and some countries used variants of the calendar that were out of synchronization as a result of
differences in calculating leap years.</p>
               <p>The geographical area identified by a country code is defined by the
  boundaries as they existed at the time of the date to be formatted,
  or the present-day boundaries for dates in the future.</p>
               <p>If the <code>$place</code> argument is supplied in the form
                  of an IANA timezone name that is recognized by the implementation, then the date or
               time being formatted is adjusted to the timezone offset applicable in that timezone.
               For example, if the <code>xs:dateTime</code> value <code>2010-02-15T12:00:00Z</code>
                  is formatted with the <code>$place</code> argument set to
                  <code>America/New_York</code>, then the output will be as if the value
                  <code>2010-02-15T07:00:00-05:00</code> had been supplied. This adjustment takes daylight
                  savings time into account where possible; if the date in question falls during
                  daylight savings time in New York, then it is adjusted to timezone offset <code>-PT4H</code>
                  rather than <code>-PT5H</code>. Adjustment using daylight savings time is only possible
                  where the value includes a date, and where the date is within the range covered
                  by the timezone database.</p>
            </div4>
			</div3>
            <div3 id="date-time-examples">
               <head>Examples of date and time formatting</head>
               
                  <p>The following examples show a selection of dates and times and the way they might
be formatted. These examples assume the use of the Gregorian calendar as the default calendar.</p>
                  <table role="data">
                     <thead>
                        <tr>
                           <th>Required Output</th>
                           <th>Expression</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td>
                              <code>2002-12-31</code>
                           </td>
                           <td>
                              <code>format-date($d, "[Y0001]-[M01]-[D01]")</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>12-31-2002</code>
                           </td>
                           <td>
                              <code>format-date($d, "[M]-[D]-[Y]")</code>
                           </td>
                        </tr>
                        <tr>
                           <td> 
                              <code>31-12-2002</code>
                           </td>
                           <td>
                              <code>format-date($d, "[D]-[M]-[Y]")</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>31 XII 2002</code>
                           </td>
                           <td>
                              <code>format-date($d, "[D1] [MI] [Y]")</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>31st December, 2002</code>
                           </td>
                           <td>
                              <code>format-date($d, "[D1o] [MNn], [Y]", "en", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>31 DEC 2002</code>
                           </td>
                           <td>
                              <code>format-date($d, "[D01] [MN,*-3] [Y0001]", "en", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>December 31, 2002</code>
                           </td>
                           <td>
                              <code>format-date($d, "[MNn] [D], [Y]", "en", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>31 Dezember, 2002</code>
                           </td>
                           <td>
                              <code>format-date($d, "[D] [MNn], [Y]", "de", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>Tisdag 31 December 2002</code>
                           </td>
                           <td>
                              <code>format-date($d, "[FNn] [D] [MNn] [Y]", "sv", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>[2002-12-31]</code>
                           </td>
                           <td>
                              <code>format-date($d, "[[[Y0001]-[M01]-[D01]]]")</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>Two Thousand and Three</code>
                           </td>
                           <td>
                              <code>format-date($d, "[YWw]", "en", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>einunddrei&eszet;igste Dezember</code>
                           </td>
                           <td>
                              <code>format-date($d, "[Dwo] [MNn]", "de", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>3:58 PM</code>
                           </td>
                           <td>
                              <code>format-time($t, "[h]:[m01] [PN]", "en", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>3:58:45 pm</code>
                           </td>
                           <td>
                              <code>format-time($t, "[h]:[m01]:[s01] [Pn]", "en", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>3:58:45 PM PDT</code>
                           </td>
                           <td>
                              <code>format-time($t, "[h]:[m01]:[s01] [PN] [ZN,*-3]", "en", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>3:58:45 o'clock PM PDT</code>
                           </td>
                           <!--Text replaced by erratum E22 change 1"--><td>
                              <code>format-time($t, "[h]:[m01]:[s01] o'clock [PN] [ZN,*-3]", "en", (), ())</code>
                           </td>
                           <!--End of text replaced by erratum E22--></tr>
                        <tr>
                           <td>
                              <code>15:58</code>
                           </td>
                           <td>
                              <code>format-time($t, "[H01]:[m01]")</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>15:58:45.762</code>
                           </td>
                           <td>
                              <code>format-time($t, "[H01]:[m01]:[s01].[f001]")</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>15:58:45 GMT+02:00</code>
                           </td>
                           <!--Text replaced by erratum E24 change 4"--><td>
                              <code>format-time($t, "[H01]:[m01]:[s01] [z,6-6]", "en", (), ())</code>
                           </td>
                           <!--End of text replaced by erratum E24--></tr>
                        <tr><!--Text replaced by erratum E24 change 5"--><td>
                              <code>15.58 Uhr GMT+2</code>
                           </td>
                           <!--End of text replaced by erratum E24--><td>
                              <code>format-time($t, "[H01]:[m01] Uhr [z]", "de", (), ())</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>3.58pm on Tuesday, 31st December</code>
                           </td>
                           <td>
                              <code>format-dateTime($dt, "[h].[m01][Pn] on [FNn], [D1o] [MNn]")</code>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <code>12/31/2002 at 15:58:45</code>
                           </td>
                           <td>
                              <code>format-dateTime($dt, "[M01]/[D01]/[Y0001] at [H01]:[m01]:[s01]")</code>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               
                  <p>The following examples use calendars other than the Gregorian calendar.</p>
                  <!--<p><emph>These examples use non-Latin characters which might not display
correctly in all browsers, depending on the system configuration.</emph></p>-->
                  <table role="data">
                     <thead>
                        <tr>
                           <th>Description</th>
                           <th>Request</th>
                           <th>Result</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td>Islamic</td>
                           <!--Text replaced by erratum E23 change 1"--><td>
                              <code>format-date($d, "[D&amp;#x0661;] [Mn] [Y&amp;#x0661;]", "ar", "AH", ())</code>
                           </td>
                           <!--End of text replaced by erratum E23--><td>&#x662;&#x666; &#xfeb8;&#xfeed;&#x651;&#xfe8d;&#xfedd; &#x661;&#x664;&#x662;&#x663;</td>
                        </tr>
                        <tr>
                           <td>Jewish (with Western numbering)</td>
                           <td>
                              <code>format-date($d, "[D] [Mn] [Y]", "he", "AM", ())</code>
                           </td>
                           <td>&#x200f;26 &#x5d8;&#x5d1;&#x5ea; 5763</td>
                        </tr>
                        <tr>
                           <td>Jewish (with traditional numbering)</td>
                           <td>
                              <code>format-date($d, "[D&amp;#x05D0;t] [Mn] [Y&amp;#x05D0;t]", "he", "AM", ())</code>
                           </td>
                           <td>&#x5db;&#x5f4;&#x5d5; &#x5d8;&#x5d1;&#x5ea; &#x5ea;&#x5e9;&#x5e1;&#x5f4;&#x5d2;</td>
                        </tr>
                        <tr>
                           <td>Julian (Old Style)</td>
                           <td>
                              <code>format-date($d, "[D] [MNn] [Y]", "en", "OS", ())</code>
                           </td>
                           <td>18 December 2002</td>
                        </tr>
                        <tr>
                           <td>Thai</td>
                           <td>
                              <code>format-date($d, "[D&amp;#x0E51;] [Mn] [Y&amp;#x0E51;]", "th", "BE", ())</code>
                           </td>
                           <td>&#xe53;&#xe51; &#xe18;&#xe31;&#xe19;&#xe27;&#xe32;&#xe04;&#xe21; 
&#xe52;&#xe55;&#xe54;&#xe55;</td>
                        </tr>
                     </tbody>
                  </table>
            </div3>
         </div2>
         <div2 id="parsing-dates-and-times">
            <head>Parsing dates and times</head>
            
            
            <?local-function-index?>
            
            <p>A function is provided to parse dates and times expressed using syntax that is commonly encountered
            in internet protocols.</p>
            
            <div3 id="func-parse-ietf-date">
               <head><?function fn:parse-ietf-date?></head>
            </div3>
         </div2>
	
      </div1>
      <div1 id="QName-funcs">
         <head>Processing QNames</head>
         <div2 id="QName-constructors">
            <head>Functions to create a QName</head>
            <p>In addition to the <code>xs:QName</code> constructor function, QName values can
               be constructed by combining a namespace URI, prefix, and local name, or by resolving
               a lexical QName against the in-scope namespaces of an element node. This section
                    defines functions that perform these operations. 
					Leading and trailing whitespace, if present, is stripped from
                    string arguments before the result is constructed.</p>
            <?local-function-index?>
            
            <div3 id="func-QName">
               <head><?function fn:QName?></head>
            </div3>
            <div3 id="func-parse-QName" diff="add" at="B">
               <head><?function fn:parse-QName?></head>
            </div3>
            <div3 id="func-resolve-QName">
               <head><?function fn:resolve-QName?></head>
            </div3>
         </div2>
         <div2 id="QName-functions">
            <head>Functions and operators on QNames</head>
            <p>This section specifies functions and an operator on QNames as defined in <bibref ref="xmlschema-2"/>.</p>
            <?local-function-index?>
            <div3 id="func-QName-equal">
               <head><?function op:QName-equal?></head>
            </div3>
            <div3 id="func-prefix-from-QName">
               <head><?function fn:prefix-from-QName?></head>
            </div3>
            <div3 id="func-local-name-from-QName">
               <head><?function fn:local-name-from-QName?></head>
            </div3>
            <div3 id="func-namespace-uri-from-QName">
               <head><?function fn:namespace-uri-from-QName?></head>
            </div3>
            <div3 id="func-expanded-QName" diff="add" at="B">
               <head><?function fn:expanded-QName?></head>
            </div3>
            <div3 id="func-in-scope-namespaces" diff="add" at="A">
            <head><?function fn:in-scope-namespaces?></head>
            </div3>	           
			   <div3 id="func-in-scope-prefixes">
               <head><?function fn:in-scope-prefixes?></head>
            </div3>
            <div3 id="func-namespace-uri-for-prefix">
               <head><?function fn:namespace-uri-for-prefix?></head>
            </div3>	
         </div2>
      </div1>
      <div1 id="binary-functions">
         <head>Processing binary values</head>
         <div2 id="binary-value-comparisons">
            <head>Comparisons of base64Binary and hexBinary values</head>
            <p diff="chg" at="2023-11-03">The following comparison operators on 
               <code>xs:hexBinary</code> and <code>xs:base64Binary</code> values are defined. 
               Each returns a boolean value.</p>
            <p diff="chg" at="2023-11-03">These
               functions can be used to compare any <code>xs:hexBinary</code> or <code>xs:base64Binary</code>
               value with any other <code>xs:hexBinary</code> or <code>xs:base64Binary</code> value:
               both types have the same value space, namely a sequence of octets which are treated as integers
               in the range 0 to 255.</p>
            <?local-function-index?>
            <div3 id="func-binary-equal">
               <head><?function op:binary-equal?></head>
            </div3>
            <div3 id="func-binary-less-than">
               <head><?function op:binary-less-than?></head>
            </div3>
         </div2>
      </div1>
      <div1 id="NOTATION-functions">
         <head>Processing NOTATIONs</head>
            <p>This section specifies operators that take <code>xs:NOTATION</code> values as arguments.</p>
            <?local-function-index?>
            <div2 id="func-NOTATION-equal">
               <head><?function op:NOTATION-equal?></head>
            </div2>
      </div1>
      

      <div1 id="sequence-functions">
         <head>Processing sequences</head>
         <p>A <code>sequence</code> is an ordered collection of zero or more <code>items</code>.
                An <code>item</code> is a node, an atomic item, or a function, such as a map or an array. The terms
                <code>sequence</code> and <code>item</code> are defined formally in <bibref ref="xquery-40"/> and <bibref ref="xpath-40"/>. </p>
         <div2 id="general-seq-funcs">
            <head>General functions and operators on sequences</head>
            <p>The following functions are defined on sequences. These functions work on any sequence, without performing
            any operations that are sensitive to the individual items in the sequence.</p>
            <?local-function-index?>
            <p>As in the previous section, for the illustrative examples below, assume an XQuery
                    or transformation operating on a non-empty Purchase Order document containing a
                    number of line-item elements. The variable <code>$seq</code> is bound to the
                    sequence of line-item nodes in document order. The variables
                    <code>$item1</code>, <code>$item2</code>, etc. are bound to separate, individual
                    line-item nodes in the sequence.</p>
            
            
            <div3 id="func-empty">
               <head><?function fn:empty?></head>
            </div3>
            <div3 id="func-exists">
               <head><?function fn:exists?></head>
            </div3>
            <div3 id="func-foot" diff="add" at="2022-11-16">
               <head><?function fn:foot?></head>
            </div3>
            <div3 id="func-head">
               <head><?function fn:head?></head>
            </div3>
            <div3 id="func-identity" diff="add" at="A">
               <head><?function fn:identity?></head>
            </div3>
            <div3 id="func-insert-before">
               <head><?function fn:insert-before?></head>
            </div3>
            <div3 id="func-items-at" diff="add" at="2022-11-16">
               <head><?function fn:items-at?></head>
            </div3>
            <div3 id="func-remove">
               <head><?function fn:remove?></head>
            </div3>
            <div3 id="func-replicate" diff="add" at="A">
               <head><?function fn:replicate?></head>
            </div3>
            <div3 id="func-reverse">
               <head><?function fn:reverse?></head>
            </div3>
            <div3 id="func-sequence-join" diff="add" at="A">
               <head><?function fn:sequence-join?></head>
            </div3>
            <div3 id="func-slice" diff="add" at="A">
               <head><?function fn:slice?></head>
            </div3>
            <div3 id="func-subsequence">
               <head><?function fn:subsequence?></head>
            </div3>
            
            <div3 id="func-tail">
               <head><?function fn:tail?></head>
            </div3>
            <div3 id="func-trunk" diff="add" at="2022-11-16">
               <head><?function fn:trunk?></head>
            </div3>
            <div3 id="func-unordered">
               <head><?function fn:unordered?></head>
            </div3>
            <div3 id="func-void">
               <head><?function fn:void?></head>
            </div3>
            
         </div2>
         <div2 id="comparing-sequences">
            <head>Comparison functions</head>
            <p>The functions in this section perform comparisons between the items in one or more
            sequences.</p>
            <?local-function-index?>
            <div3 id="func-atomic-equal">
               <head><?function fn:atomic-equal?></head>
            </div3>
            <div3 id="func-deep-equal">
               <head><?function fn:deep-equal?></head>
            </div3>
            <div3 id="func-compare">
               <head><?function fn:compare?></head>
            </div3>
            <div3 id="func-distinct-values">
               <head><?function fn:distinct-values?></head>
            </div3>  
            <div3 id="func-duplicate-values">
               <head><?function fn:duplicate-values?></head>
            </div3>  
            <div3 id="func-index-of">
               <head><?function fn:index-of?></head>
            </div3>
            <div3 id="func-starts-with-subsequence" diff="add" at="B">
               <head><?function fn:starts-with-subsequence?></head>
            </div3>  
            <div3 id="func-ends-with-subsequence" diff="add" at="B">
               <head><?function fn:ends-with-subsequence?></head>
            </div3>  
            <div3 id="func-contains-subsequence" diff="add" at="B">
               <head><?function fn:contains-subsequence?></head>
            </div3>  
         </div2>
         <div2 id="cardinality-functions">
            <head>Functions that test the cardinality of sequences</head>
            <p>The following functions test the cardinality of their sequence arguments.</p>
            <?local-function-index?>
            <p>The functions <function>fn:zero-or-one</function>, <function>fn:one-or-more</function>, and
                    <function>fn:exactly-one</function> defined in this section, check that the cardinality
                    of a sequence is in the expected range. They are particularly useful with regard
                    to static typing. For example, the function call <code>fn:remove($seq, fn:index-of($seq2, 'abc'))</code>
                    requires the result of the call on <function>fn:index-of</function> to be a singleton integer, 
                    but the static type system cannot infer this; writing the expression as 
                    <code>fn:remove($seq, fn:exactly-one(fn:index-of($seq2, 'abc')))</code> 
                    will provide a suitable static type at query analysis time, and ensures that the length of the sequence is
                    correct with a dynamic check at query execution time.</p>
            <p>The type signatures for these functions deliberately declare the argument type as
                    <code>item()*</code>, permitting a sequence of any length. A more restrictive
                    signature would defeat the purpose of the function, which is to defer
                    cardinality checking until query execution time.</p>
            <div3 id="func-zero-or-one">
               <head><?function fn:zero-or-one?></head>
            </div3>
            <div3 id="func-one-or-more">
               <head><?function fn:one-or-more?></head>
            </div3>
            <div3 id="func-exactly-one">
               <head><?function fn:exactly-one?></head>
            </div3>
         </div2>
         <!--<div2 id="union-intersection-except">
            <head>Union, intersection and difference</head>
            <?local-function-index?>
            <p>As in the previous sections, for the illustrative examples below, assume an
                    XQuery or transformation operating on a Purchase Order document containing a
                    number of line-item elements. The variables <code>$item1</code>,
                    <code>$item2</code>, etc. are bound to individual line-item nodes in the
                    sequence. We use sequences of these nodes in some of the examples below.</p>
            
            <div3 id="func-union">
               <head><?function op:union?></head>
            </div3>
            <div3 id="func-intersect">
               <head><?function op:intersect?></head>
            </div3>
            <div3 id="func-except">
               <head><?function op:except?></head>
            </div3>
         </div2>-->
         <div2 id="aggregate-functions">
            <head>Aggregate functions</head>
            <p>Aggregate functions take a sequence as argument and return a single value
                    computed from values in the sequence. Except for <function>fn:count</function>, the
                    sequence must consist of values of a single type or one if its subtypes, or they
                    must be numeric. <code>xs:untypedAtomic</code> values are permitted in the
                    input sequence and handled by special conversion rules. The type of the items in
                    the sequence must also support certain operations.</p>
            <?local-function-index?>
            <div3 id="func-count">
               <head><?function fn:count?></head>
            </div3>
            <div3 id="func-avg">
               <head><?function fn:avg?></head>
            </div3>
            <div3 id="func-max">
               <head><?function fn:max?></head>
            </div3>
            <div3 id="func-min">
               <head><?function fn:min?></head>
            </div3>
            <div3 id="func-sum">
               <head><?function fn:sum?></head>
			   </div3>
            <div3 id="func-all-equal" diff="add" at="B">
               <head><?function fn:all-equal?></head>
            </div3>
            <div3 id="func-all-different" diff="add" at="B">
               <head><?function fn:all-different?></head>
            </div3>
		 </div2>
         <!--<div2 id="fns-that-generate-sequences">
            <head>Functions and operators that generate sequences</head>
            <?local-function-index?>
            <div3 id="func-to">
               <head><?function op:to?></head>
            </div3>
         </div2>-->
         <div2 id="fns-on-identifiers">
            <head>Functions on node identifiers</head>
            <p>This section defines a number of functions used to find elements by <code>ID</code> or <code>IDREF</code> value, 
            or to generate identifiers.</p>
            <?local-function-index?>
            <div3 id="func-id">
               <head><?function fn:id?></head>
            </div3>
            <div3 id="func-element-with-id">
               <head><?function fn:element-with-id?></head>
            </div3>
            <div3 id="func-idref">
               <head><?function fn:idref?></head>
            </div3>
            <div3 id="func-generate-id">
               <head><?function fn:generate-id?></head>
            </div3>
           
         </div2>
         <div2 id="fns-on-docs">
            <head>Functions giving access to external information</head>
            <p>The functions in this section provide access to resources (such as files) in the external environment.</p>
            <?local-function-index?>
            <div3 id="func-doc">
               <head><?function fn:doc?></head>
            </div3>
            <div3 id="func-doc-available">
               <head><?function fn:doc-available?></head>
            </div3>
            <div3 id="func-collection">
               <head><?function fn:collection?></head>
            </div3>
            <div3 id="func-uri-collection">
               <head><?function fn:uri-collection?></head>
            </div3>
            <div3 id="func-unparsed-text">
               <head><?function fn:unparsed-text?></head>
            </div3>
            <div3 id="func-unparsed-text-lines">
               <head><?function fn:unparsed-text-lines?></head>
            </div3>
            <div3 id="func-unparsed-text-available">
               <head><?function fn:unparsed-text-available?></head>
            </div3>
            <div3 id="func-environment-variable">
               <head><?function fn:environment-variable?></head>
            </div3>
            <div3 id="func-available-environment-variables">
               <head><?function fn:available-environment-variables?></head>
            </div3>
         </div2>
      </div1>
      <div1 id="parsing-and-serializing">
         <head>Parsing and serializing</head>
         <p>These functions convert between the lexical representation and XPath and XQuery data model representation of various file formats.</p>
         <div2 id="xml-functions">
            <head>Functions on XML Data</head>
            <p>These functions convert between the lexical representation of XML and the tree representation.</p>
            <p>(The <function>fn:serialize</function> function also handles HTML and JSON output, but is included in this section
            for editorial convenience.)</p>
            <?local-function-index?>
            <div3 id="func-parse-xml">
               <head><?function fn:parse-xml?></head>
            </div3>
            <div3 id="func-parse-xml-fragment">
               <head><?function fn:parse-xml-fragment?></head>
            </div3>
            <div3 id="func-serialize">
               <head><?function fn:serialize?></head>
            </div3>
         </div2>
         
         <div2 id="html-functions">
            <head>Functions on HTML Data</head>
            <changes>
               <change>
                  A new function is available for processing input data in HTML format.
               </change>
            </changes>
            <p>These functions convert between the lexical representation of HTML and the tree representation.</p>
            <?local-function-index?>
            <div3 id="html-xdm-mapping">
               <head>XDM Mapping from HTML DOM Nodes</head>
               
               <p>The <function>fn:parse-html</function> function conceptually works in two phases:</p>
               
               <olist>
                  <item><p>The lexical HTML (supplied as a string) is parsed into an HTML DOM
                     as defined by the HTML5 specification: see <bibref ref="html5"/> and
                     <bibref ref="dom-ls"/>.
                  </p></item>
                  <item><p>The resulting DOM is converted to an XDM tree as described in this
                  section. This is described by defining the actions of the accessor functions
                  defined in <xspecref spec="DM40" ref="accessors"/>.</p></item>
               </olist>
   
   
            
   
               <note>
                  <p>Because the <bibref ref="dom-ls"/> and <bibref ref="html5"/> are not fixed, it is
                     <termref def="implementation-defined">implementation-defined</termref> which versions are used.</p>
               </note>
   
               <p>An implementation must match the semantics of the mapping described in this section, but
                  the specific way it achieves that is <termref def="implementation-dependent">implementation-dependent</termref>.</p>
   
               <note>
                  <p>Some possible implementation strategies are:</p>
                  <olist>
                     <item><p>Parse the HTML to an HTML DOM and then convert the HTML DOM to an XDM node tree.</p></item>
                     <item><p>Parse the HTML to an HTML DOM and then implement a wrapper or facade that presents
                     an XDM interface to the HTML DOM.</p></item>
                     <item><p>Parse the lexical HTML directly to an XDM node tree, bypassing the HTML DOM.</p></item>
                  </olist>
               </note>
   
               <p>The <bibref ref="dom-ls"/> defines parsing algorithms for two different formats, which it refers to
                  as the HTML and XML serializations. The XML serialization is an XML document which typically
                  uses the namespace <code>http://www.w3.org/1999/xhtml</code> and the content type
                  <code>application/xhtml+xml</code>, and is popularly referred to as <code>XHTML</code>.
                  The HTML parsing algorithm constructs
                  an HTML DOM <code>HTMLDocument</code> document object for the HTML document. The XHTML parsing
                  algorithm constructs an HTML DOM <code>XMLDocument</code> object for the HTML document, following
                  XML parsing rules. This mapping supports both of these document types.</p>
   
               <p>The <bibref ref="dom-ls"/> specification defines HTML DOM nodes that are mapped to XDM
                  nodes as follows:</p>
               <olist>
                  <item>
                     <p>The HTML DOM <code>Document</code> interface maps to <xspecref spec="DM40" ref="DocumentNode"/>.</p>
                  </item>
                  <item>
                     <p>The HTML DOM <code>Element</code> interface maps to <xspecref spec="DM40" ref="ElementNode"/>.</p>
                  </item>
                  <item>
                     <p>The HTML DOM <code>Attr</code> interface maps to <xspecref spec="DM40" ref="AttributeNode"/>.</p>
                     <note><p>Any HTML DOM <code>Attr</code> instances in an HTML DOM <code>HTMLDocument</code> that represent
                        namespace declarations will have been filtered out: see <specref ref="html-attributes-accessor"/>.</p></note>
                     
                  </item>
                  <item>
                     <p>The HTML DOM <code>ProcessingInstruction</code> interface maps to
                        <xspecref spec="DM40" ref="ProcessingInstructionNode"/>.</p>
   
                     <note>
                        <p>The HTML parsing algorithm does not generate processing instruction nodes. If encountered
                           they are parsed as comment nodes. The HTML DOM <code>ProcessingInstruction</code>
                           interface is relevant only when the XHTML parsing algorithm is used.</p>
                     </note>
                  </item>
                  <item>
                     <p>The HTML DOM <code>Comment</code> interface maps to <xspecref spec="DM40" ref="CommentNode"/>.</p>
                  </item>
                  <item>
                     <p>The HTML DOM <code>Text</code> interface maps to <xspecref spec="DM40" ref="TextNode"/>.
                        Adjacent HTML DOM <code>Text</code> nodes are combined into a single
                        <xspecref spec="DM40" ref="TextNode"/>.</p>
   
                     <note>
                        <p>The HTML DOM <code>CDATASection</code> interface is an instance of HTML DOM
                           <code>Text</code>, so CDATA sections also map to <xspecref spec="DM40" ref="TextNode"/>.</p>
                        <p>The use of CDATA sections can result in the HTML DOM containing adjacent text nodes,
                        which the mapping to XDM will merge into a single node.</p>
                     </note>
                  </item>
               </olist>
   
               <note>
                  <p>The HTML DOM <code>DocumentFragment</code> interface is not supported as an XML node.
                     There are two places in the HTML DOM where this is used:</p>
                  <olist>
                     <item>
                        <p>The HTML DOM <code>ShadowRoot</code> interface is not present in the main HTML DOM
                           tree. It is only accessible via JavaScript.</p>
                     </item>
                     <item>
                        <p>The <code>template</code> element’s <code>content</code> property contains
                           the child nodes of the <code>template</code> element. The behaviour of this
                           is defined by the <code>include-template-content</code> key in the
                           <specref ref="html-parser-options"/> map.</p>
                     </item>
                  </olist>
                  <p>If an implementation allows these nodes to be passed in via an API or similar mechanism,
                     their behaviour is <termref def="implementation-defined">implementation-defined</termref>.</p>
               </note>

            <div4 id="html-attributes-accessor">
               <head>attributes Accessor</head>


               <p>The result of the <xspecref spec="DM40" ref="dm-attributes"/>
                  <code>dm:attributes($node)</code> for an HTML DOM <code>Node</code> is as follows:</p>
               <olist>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Element</code> then the result
                        is the value of the <code>Element.attributes</code> property mapped to a
                        sequence as described below;</p>
                  </item>
                  <item>
                     <p>Otherwise, the result is an empty sequence.</p>
                  </item>
               </olist>

               <p>An HTML DOM <code>NamedNodeMap</code> is mapped to a sequence as follows:</p>
               <olist>
                  <item>
                     <p><code>NamedNodeMap.length</code> is the length of the sequence, where a length
                        of <code>0</code> results in an empty sequence;</p>
                  </item>
                  <item>
                     <p><code>NamedNodeMap.item(n)</code> is the n<sup>th</sup> element of the sequence.</p>
                  </item>
               </olist>

               <p>That sequence is then filtered as follows:</p>
               <olist>
                  <item>
                     <p>If the <code>Attr.namespaceURI</code> property is
                        <code>"http://www.w3.org/2000/xmlns/"</code>, the attribute is not included in
                        this sequence;</p>
                  </item>
                  <item>
                     <p>If the <code>Attr.localName</code> property is <code>"xmlns"</code>, the attribute
                        is not included in this sequence;</p>
                  </item>
                  <item>
                     <p>If the <code>Attr.localName</code> property starts with <code>"xmlns:"</code>,
                        the attribute is not included in this sequence;</p>
                  </item>
                  <item>
                     <p>Otherwise, the attribute is included in this sequence using the XDM mapping rules
                        described in this section.</p>
                  </item>
               </olist>

               <note>
                  <p>The HTML DOM <code>Element.attributes</code> property includes namespace and non-namespace
                     attributes in the list when the HTML or XML parser is used. As such, the namespace attributes
                     have to be filtered from the resulting XDM attribute sequence.</p>
               </note>

               <note>
                  <p>When the resulting document is an HTML DOM <code>HTMLDocument</code>, the
                     <code>Attr.localName</code> and <code>Attr.name</code> properties of HTML DOM
                     <code>Attr</code> nodes are both set to the qualified name. This includes
                     namespace declarations which are filtered out by the logic in this section.</p>
               </note>

               <note>
                  <p>The <code>Attr.localName</code> property will be ASCII lowercase. The
                     <bibref ref="html5"/> section 13.2.5.33, <emph>Attribute name state</emph> specifies that
                     ASCII upper alpha characters are appended to the attribute’s name in lowercase.</p>
               </note>
            </div4>
            <div4 id="html-base-uri-accessor">
               <head>base-uri Accessor</head>


               <p>The result of the <xspecref spec="DM40" ref="dm-base-uri"/>
                  <code>dm:base-uri($node)</code> for an HTML DOM <code>Node</code> is the value of the
                  <code>Node.baseURI</code> property mapped as follows:</p>
               <olist>
                  <item>
                     <p>If the value is null or an empty string, then the result is an empty sequence;</p>
                  </item>
                  <item>
                     <p>Otherwise, the string value is cast to an <code>xs:anyURI</code>.</p>
                  </item>
               </olist>
            </div4>
            <div4 id="html-children-accessor">
               <head>children Accessor</head>


               <p>The result of the <xspecref spec="DM40" ref="dm-children"/>
                  <code>dm:children($node)</code> for an HTML DOM <code>Node</code> is as follows:</p>
               <olist>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Document</code> then the result
                        is the value of the <code>Node.childNodes</code> property mapped to a sequence;</p>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>HTMLTemplateElement</code> then the
                        result is determined as follows:</p>
                     <olist>
                        <item>
                           <p>If the <code>include-template-content</code> key of the
                              <code>parse-html-options</code> map is <code>false()</code>, the result is
                              an empty sequence;</p>
                        </item>
                        <item>
                           <p>Select the HTML DOM <code>DocumentFragment</code> from the
                              <code>HTMLTemplateElement.content</code> property;</p>
                        </item>
                        <item>
                           <p>The HTML DOM <code>DocumentFragment</code>’s <code>Node.childNodes</code>
                              property is mapped to a sequence;</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Element</code> then the result the
                        value of the <code>Node.childNodes</code> property mapped to a sequence;</p>
                  </item>
                  <item>
                     <p>Otherwise, the result is an empty sequence.</p>
                  </item>
               </olist>

               <p>An HTML DOM <code>NodeList</code> is mapped to a sequence as follows:</p>
               <olist>
                  <item>
                     <p><code>NodeList.length</code> is the length of the sequence, where a length
                        of <code>0</code> results in an empty sequence;</p>
                  </item>
                  <item>
                     <p><code>NodeList.item(n)</code> is the n<sup>th</sup> element of the sequence.</p>
                  </item>
               </olist>

               <p>That sequence is then filtered as follows:</p>
               <olist>
                  <item>
                     <p>If the child is an instance of HTML DOM <code>DocumentType</code>, that child
                        is not included in this sequence;</p>
                  </item>
                  <item>
                     <p>A sequence of consecutive HTML DOM <code>Text</code> nodes is combined into a
                        single XDM <code>text</code> node;</p>
                  </item>
                  <item>
                     <p>Otherwise, the HTML DOM <code>Node</code> nodes are mapped to XDM according to
                        the rules in this section.</p>
                  </item>
               </olist>

            </div4>
            <div4 id="html-document-uri-accessor">
               <head>document-uri Accessor</head>


               <p>The result of the <xspecref spec="DM40" ref="dm-document-uri"/>
                  <code>dm:document-uri($node)</code> for an HTML DOM <code>Node</code> is as follows:</p>
               <olist>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Document</code> then the value
                        of the <code>Document.documentURI</code> property mapped as follows:</p>
                     <olist>
                        <item>
                           <p>If the value is null or an empty string, then the result is an empty sequence;</p>
                        </item>
                        <item>
                           <p>Otherwise, the string value is cast to an <code>xs:anyURI</code>.</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>Otherwise, the result is an empty sequence.</p>
                  </item>
               </olist>
            </div4>
            <div4 id="html-is-id-accessor">
               <head>is-id Accessor</head>


               <p>The result of the <xspecref spec="DM40" ref="dm-is-id"/>
                  <code>dm:is-id($node)</code> for an HTML DOM <code>Node</code> is as follows:</p>
               <olist>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Attr</code> then:</p>
                     <olist>
                        <item>
                           <p>If the <code>Attr.name</code> property (its qualified name) is
                              <code>"id"</code>, then:</p>
                           <olist>
                              <item>
                                 <p>If the <code>Attr.value</code> is castable to an <code>xs:NCName</code>,
                                    the result is <code>true</code>;</p>
                              </item>
                              <item>
                                 <p>Otherwise, the result is <code>false</code>;</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>Otherwise, the result is <code>false</code>;</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>Otherwise, the result is <code>false</code>.</p>
                  </item>
               </olist>

               <note>
                  <p>In <bibref ref="html5"/> section 3.2.5, <emph>Global attributes</emph>, the
                     <code>id</code> attribute is defined as being unique in the element’s tree,
                     containing at least one character, and not having any ASCII whitespace
                     characters. This means that an HTML <code>id</code> attribute may not
                     conform to an <code>xs:NCName</code>.</p>
                  <p>If an HTML <code>id</code> is not a valid <code>xs:NCName</code> then that
                     attribute is not an XML ID.</p>
               </note>
            </div4>
            <div4 id="html-is-idrefs-accessor">
               <head>is-idrefs Accessor</head>


               <p>The result of the <xspecref spec="DM40" ref="dm-is-idrefs"/>
                  <code>dm:is-idrefs($node)</code> for an HTML DOM <code>Node</code> is an empty sequence.</p>
            </div4>
            <div4 id="html-namespace-nodes-accessor">
               <head>namespace-nodes Accessor</head>

               <p>The result of the <xspecref spec="DM40" ref="dm-namespace-nodes"/>
                  <code>dm:namespace-nodes($node)</code> for an HTML DOM <code>Node</code> is as follows:</p>
               <olist>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Element</code> then an
                        <termref def="implementation-dependent">implementation-dependent</termref> sequence
                        of namespace nodes that is sufficient to define the namespace context of the node.</p>
                  </item>
                  <item>
                     <p>Otherwise, the result is the empty sequence.</p>
                  </item>
               </olist>

               <p>For the XHTML parsing algorithm, this will be equivalent to constructing the namespace
                  nodes from an XML infoset, PSVI, or similar mapping.</p>
               <p>For the HTML parsing algorithm, the <bibref ref="html5"/> specification defines the
                  namespace context in various places:</p>
               <olist>
                  <item>
                     <p>Section 2.1.3 <emph>XML compatibility</emph> defines the default element namespace
                        to be <code>http://www.w3.org/1999/xhtml</code>.</p>
                  </item>
                  <item>
                     <p>Section 4.8.15 <emph>MathML</emph> defines rules for embedded MathML content in HTML
                        documents. Section 13.1.2 <emph>Elements</emph> defines these elements as foreign
                        elements, placing them in the MathML namespace (<code>http://www.w3.org/1998/Math/MathML</code>).
                        The default element namespace for these elements is the MathML namespace.</p>
                  </item>
                  <item>
                     <p>Section 4.8.16 <emph>SVG</emph> defines rules for embedded SVG content in HTML
                        documents. Section 13.1.2 <emph>Elements</emph> defines these elements as foreign
                        elements, placing them in the SVG namespace (<code>http://www.w3.org/2000/svg</code>).
                        The default element namespace for these elements is the SVG namespace.</p>
                  </item>
                  <item>
                     <p>Section 13.1.2.3 <emph>Attributes</emph> defines several namespaced attributes
                        available on foreign elements. If any of these namespaced attributes are present,
                        a namespace node for that namespace must be present on the element.</p>
                     <p>The supported namespace prefixes are:</p>
                     <olist>
                        <item>
                           <p><code>xlink</code> in the <code>http://www.w3.org/1999/xlink</code> namespace;</p>
                        </item>
                        <item>
                           <p><code>xml</code> in the <code>http://www.w3.org/XML/1998/namespace</code> namespace; and</p>
                        </item>
                        <item>
                           <p><code>xmlns</code> in the <code>http://www.w3.org/2000/xmlns/</code> namespace.</p>
                        </item>
                     </olist>
                  </item>
               </olist>
               <p>No other namespaces are supported by the HTML parser.</p>
               <note><p>Section number references to <bibref ref="html5"/> may change over time.</p></note>
            </div4>
            <div4 id="html-nilled-accessor">
               <head>nilled Accessor</head>


               <p>The result of the <xspecref spec="DM40" ref="dm-nilled"/>
                  <code>dm:nilled($node)</code> for an HTML DOM <code>Node</code> is <code>false()</code>.</p>
            </div4>
            <div4 id="html-node-kind-accessor">
               <head>node-kind Accessor</head>


               <p>The result of the <xspecref spec="DM40" ref="dm-node-kind"/>
                  <code>dm:node-kind($node)</code> for an HTML DOM <code>Node</code> is as follows:</p>
               <olist>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Document</code> then the result is
                        <code>"document"</code>.</p>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Element</code> then the result is
                        <code>"element"</code>.</p>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Attr</code> then the result is
                        <code>"attribute"</code>.</p>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>ProcessingInstruction</code> then
                        the result is <code>"processing-instruction"</code>.</p>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Comment</code> then the result is
                        <code>"comment"</code>.</p>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Text</code> then the result is
                        <code>"text"</code>.</p>
                  </item>
               </olist>
            </div4>
            <div4 id="html-node-name-accessor">
               <head>node-name Accessor</head>


               <p>The result of the <xspecref spec="DM40" ref="dm-node-name"/>
                  <code>dm:node-name($node)</code> for an HTML DOM <code>Node</code> is as follows:</p>
               <olist>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Element</code> then the result is
                        determined as follows:</p>
                     <olist>
                        <item>
                           <p>The <emph>local name</emph> is the value of the
                              <code>Element.localName</code> property. This is derived as follows:</p>
                           <olist>
                              <item>
                                 <p>The local name is initially set to the ASCII lowercase tag name. The
                                    <bibref ref="html5"/> section 13.2.5.8, <emph>Tag name state</emph>
                                    specifies that ASCII upper alpha characters are appended to the element’s
                                    name in lowercase.</p>
                              </item>
                              <item>
                                 <p>If the local name is an SVG element name, the case-sensitive name is used.
                                    <bibref ref="html5"/> section 13.2.6.5,
                                    <emph>The rules for parsing tokens in foreign content</emph>
                                    has a table mapping the lowercase element names to their SVG names.</p>
                              </item>
                              <item>
                                 <p>If the local name contains a character that is not a valid XML
                                    <code>NameStartChar</code> or <code>NameChar</code>, then an
                                    <termref def="implementation-defined">implementation-defined</termref>
                                    replacement string is used. The result must be a valid <code>NCName</code>.</p>
                                 <note>
                                    <p><bibref ref="html5"/> section 13.2.9
                                       <emph>Coercing an HTML DOM into an infoset</emph> uses a
                                       <code>Unnnnnn</code> escape sequence. That would map <code>:</code>
                                       to <code>U00003A</code>.</p>
                                    <p>This local name escaping applies only to the HTML parsing algorithm.
                                       If the XHTML parsing algorithm is used, the <code>localName</code> and
                                       <code>prefix</code> will be correctly set for QName-based
                                       node names.</p>
                                 </note>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>The <emph>namespace prefix</emph> is the value of the
                              <code>Element.prefix</code> property, or empty if the value is null;</p>
                        </item>
                        <item>
                           <p>The <emph>namespace URI</emph> is the value of the
                              <code>Element.namespaceURI</code> property, or empty if the value
                              is null.</p>
                           <olist>
                              <item>
                                 <p>If the element is an HTML element, the namespace URI is
                                    <code>"http://www.w3.org/1999/xhtml"</code>.</p>
                              </item>
                              <item>
                                 <p>If the element is an SVG element, the namespace URI is
                                    <code>"http://www.w3.org/2000/svg"</code>.</p>
                              </item>
                              <item>
                                 <p>If the element is a MathML element, the namespace URI is
                                    <code>"http://www.w3.org/1998/Math/MathML"</code>.</p>
                              </item>
                           </olist>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Attr</code> then the result is
                        determined as follows:</p>
                     <olist>
                        <item>
                           <p>The <emph>attribute name</emph> is the tokenized attribute name. The
                              <bibref ref="html5"/> section 13.2.5.33, <emph>Attribute name state</emph>
                              specifies that ASCII upper alpha characters are appended to the attribute’s
                              name in lowercase.</p>
                        </item>
                        <item>
                           <p>The <emph>local name</emph> is the value of the
                              <code>Attr.localName</code> property. This is derived as follows:</p>
                           <olist>
                              <item>
                                 <p>The local name is initially set to the <emph>attribute name</emph>.</p>
                              </item>
                              <item>
                                 <p>If the local name is an SVG or MathML attribute name, the case-sensitive name
                                    is used. <bibref ref="html5"/> section 13.2.6.1,
                                    <emph>Creating and inserting nodes</emph>
                                    has a table mapping the lowercase attribute names to their SVG/MathML names.</p>
                              </item>
                              <item>
                                 <p>If the local name is an allowed <code>xlink</code>, <code>xml</code>, or
                                    <code>xmlns</code> attribute name the local name is the value of the local name
                                    column of the attribute name mapping table in <bibref ref="html5"/> section
                                    13.2.6.1, <emph>Creating and inserting nodes</emph>.</p>
                              </item>
                              <item>
                                 <p>If the local name contains a character that is not a valid XML
                                    <code>NameStartChar</code> or <code>NameChar</code>, then an
                                    <termref def="implementation-defined">implementation-defined</termref>
                                    replacement string is used. The result must be a valid <code>NCName</code>.</p>
                                 <note>
                                    <p><bibref ref="dom-ls"/> section 13.2.9
                                       <emph>Coercing an HTML DOM into an infoset</emph> uses a
                                       <code>Unnnnnn</code> escape sequence. That would map <code>:</code>
                                       to <code>U00003A</code>.</p>
                                    <p>This local name escaping applies only to the HTML parsing algorithm.
                                       If the XHTML parsing algorithm is used, the <code>localName</code> and
                                       <code>prefix</code> will be correctly set for QName-based
                                       node names.</p>
                                 </note>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>The <emph>namespace prefix</emph> is the value of the
                              <code>Attr.prefix</code> property, or empty if the value is null.</p>
                           <olist>
                              <item>
                                 <p>If the attribute name is an allowed <code>xlink</code>, <code>xml</code>, or
                                    <code>xmlns</code> attribute name the namespace prefix is the value of the
                                    prefix column of the attribute name mapping table in <bibref ref="html5"/>
                                    section 13.2.6.1, <emph>Creating and inserting nodes</emph>.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>The <emph>namespace URI</emph> is the value of the
                              <code>Attr.namespaceURI</code> property, or empty if the value is null;</p>
                           <olist>
                              <item>
                                 <p>If the attribute name is an allowed <code>xlink</code>, <code>xml</code>, or
                                    <code>xmlns</code> attribute name the namespace URI is the value of the
                                    namespace column of the attribute name mapping table in <bibref ref="html5"/>
                                    section 13.2.6.1, <emph>Creating and inserting nodes</emph>.</p>
                              </item>
                           </olist>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>ProcessingInstruction</code> then
                        the result is an <code>xs:QName</code> constructed as follows:</p>
                     <olist>
                        <item>
                           <p>The <emph>local name</emph> is the value of the
                              <code>ProcessingInstruction.target</code> property;</p>
                        </item>
                        <item>
                           <p>The <emph>namespace prefix</emph> is empty;</p>
                        </item>
                        <item>
                           <p>The <emph>namespace URI</emph> is empty;</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>Otherwise, the result is an empty sequence.</p>
                  </item>
               </olist>

               <note>
                  <p>When the resulting document is an HTML DOM <code>HTMLDocument</code>, the
                     <code>Element.localName</code> and <code>Element.name</code> properties of
                     HTML DOM <code>Element</code> nodes are both set to the qualified name.</p>
               </note>

               <note>
                  <p>When the resulting document is an HTML DOM <code>HTMLDocument</code>, the
                     <code>Attr.localName</code> and <code>Attr.name</code> properties of HTML DOM
                     <code>Attr</code> nodes are both set to the qualified name.</p>
               </note>
            </div4>
            <div4 id="html-parent-accessor">
               <head>parent Accessor</head>


               <p>The result of the <xspecref spec="DM40" ref="dm-parent"/>
                  <code>dm:parent($node)</code> for an HTML DOM <code>Node</code> is as follows:</p>
               <olist>
                  <item>
                     <p>Let <code>$parent</code> be the <code>Node.parentNode</code> property of the
                        node;</p>
                  </item>
                  <item>
                     <p>If <code>$parent</code> is an instance of HTML DOM <code>DocumentFragment</code>,
                        then for each HTML DOM <code>HTMLTemplateElement</code> <code>$template</code> in
                        the parsed DOM tree:</p>
                     <olist>
                        <item>
                           <p>Let <code>$content</code> be the value of the
                              <code>HTMLTemplateElement.content</code> property of <code>$template</code>;</p>
                        </item>
                        <item>
                           <p>If <code>$content</code> is the same node as <code>$parent</code>, then the
                              result is <code>$template</code> using the XDM mapping rules described in
                              this section;</p>
                        </item>
                        <item>
                           <p>If there are no more <code>$template</code> nodes, then the result is an
                              empty sequence;</p>
                        </item>
                     </olist>
                  </item>
                  <item>
                     <p>If <code>$parent</code> is null, then the result is an empty sequence;</p>
                  </item>
                  <item>
                     <p>Otherwise, the result is <code>$parent</code> using the XDM mapping rules
                        described in this section.</p>
                  </item>
               </olist>

               <note>
                  <p>The current node can have a HTML DOM <code>DocumentFragment</code> parent node only
                     if the <code>include-template-content</code> key of the <code>html-parser-options</code>
                     is <code>true()</code>.</p>
               </note>

               <note>
                  <p>The HTML DOM <code>DocumentFragment</code>’s <code>Node.parentNode</code> property
                     is null, and a <code>DocumentFragment</code> attached to <code>HTMLTemplateElement.content</code>
                     property does not have a <code>host</code> property connecting the fragment back to
                     the template element.</p>
                  <p>If a future version of <bibref ref="dom-ls"/> adds a <code>DocumentFragment.host</code>
                     property that references the node’s <code>template</code> element, or the implementation
                     has access to that internal property, the implementation may choose to use that
                     instead of traversing the parsed HTML tree.</p>
               </note>
            </div4>
            <div4 id="html-string-value-accessor">
               <head>string-value Accessor</head>


               <p>The result of the <xspecref spec="DM40" ref="dm-string-value"/>
                  <code>dm:string-value($node)</code> for an HTML DOM <code>Node</code> is as follows:</p>
               <olist>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Document</code>, then use the
                        algorithm described in <specref ref="html-tree-string-construction"/>;</p>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Element</code>, then use the
                        algorithm described in <specref ref="html-tree-string-construction"/>;</p>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Text</code>, then use the
                        algorithm described in <specref ref="html-text-node-string-construction"/>;</p>
                  </item>
                  <item>
                     <p>Otherwise, the result is the value of the <code>Node.nodeValue</code> property.</p>
                  </item>
               </olist>

               <div5 id="html-tree-string-construction">
                  <head>Tree string construction</head>


                  <p>The following algorithm is used to construct the concatenated string value of a
                     node in the HTML DOM tree:</p>
                  <olist>
                     <item>
                        <p>Let <code>$text</code> be the string value <code>""</code>;</p>
                     </item>
                     <item>
                        <p>For each descendant node <code>$node</code> in document order:</p>
                        <olist>
                           <item>
                              <p>If <code>$node</code> is not an instance of HTML DOM
                                 <code>Text</code>, process the next node in document order;</p>
                           </item>
                           <item>
                              <p>Append the value of the <code>Node.nodeValue</code> property for
                                 <code>$node</code> to <code>$text</code>;</p>
                           </item>
                        </olist>
                     </item>
                     <item>
                        <p>The result is <code>$text</code>.</p>
                     </item>
                  </olist>
               </div5>
               <div5 id="html-text-node-string-construction">
                  <head>Text node string construction</head>


                  <p>The following algorithm is used to construct the maximal sequence of adjacent
                     <emph>character information items</emph> for text node children of an element:</p>
                  <olist>
                     <item>
                        <p>Let <code>$text</code> be the string value <code>""</code>;</p>
                     </item>
                     <item>
                        <p>Append the value of the <code>Node.nodeValue</code> property for
                           <code>$node</code> to <code>$text</code>;</p>
                     </item>
                     <item>
                        <p>Let <code>$next</code> be the value of <code>Node.nextSibling</code>;</p>
                     </item>
                     <item>
                        <p>Let <code>$next</code> is null, or not an instance of HTML DOM
                           <code>Text</code>, the result is <code>$text</code>;</p>
                     </item>
                     <item>
                        <p>Otherwise, repeat from step 2 using <code>$next</code> as <code>$node</code>.</p>
                     </item>
                  </olist>

                  <note>
                     <p>Adjacent text nodes in the HTML DOM are treated as a single XDM text node by only
                        including the first text node and providing logic to ensure that the text content
                        is merged into a single text block.</p>
                  </note>
               </div5>
            </div4>
            <div4 id="html-type-name-accessor">
               <head>type-name Accessor</head>


               <p>The result of the <xspecref spec="DM40" ref="dm-type-name"/>
                  <code>dm:type-name($node)</code> for an HTML DOM <code>Node</code> is as follows:</p>
               <olist>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Element</code> then the result is
                        <code>xs:untyped</code>.</p>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Attr</code> then the result is
                        <code>xs:untypedAtomic</code>.</p>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Text</code> then the result is
                        <code>xs:untypedAtomic</code>.</p>
                  </item>
                  <item>
                     <p>Otherwise, the result is an empty sequence.</p>
                  </item>
               </olist>
            </div4>
            <div4 id="html-typed-value-accessor">
               <head>typed-value Accessor</head>


               <p>The result of the <xspecref spec="DM40" ref="dm-typed-value"/>
                  <code>dm:typed-value($node)</code> for an HTML DOM <code>Node</code> is as follows:</p>
               <olist>
                  <item>
                     <p>Let <code>$string-value</code> be the <specref ref="html-string-value-accessor"/>
                        for the node;</p>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Document</code> then the result is
                        <code>$string-value</code> as an <code>xs:untypedAtomic</code>;</p>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Element</code> then the result is
                        <code>$string-value</code> as an <code>xs:untypedAtomic</code>;</p>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Attr</code> then the result is
                        <code>$string-value</code> as an <code>xs:untypedAtomic</code>;</p>
                  </item>
                  <item>
                     <p>If the node is an instance of HTML DOM <code>Text</code> then the result is
                        <code>$string-value</code> as an <code>xs:untypedAtomic</code>;</p>
                  </item>
                  <item>
                     <p>Otherwise, the result is <code>$string-value</code>.</p>
                  </item>
               </olist>
            </div4>
            <div4 id="html-unparsed-entity-public-id-accessor">
               <head>unparsed-entity-public-id Accessor</head>


               <p>The result of the <xspecref spec="DM40" ref="dm-unparsed-entity-public-id"/>
                  <code>dm:unparsed-entity-public-id($node)</code> for an HTML DOM <code>Node</code>
                  is an empty sequence.</p>
            </div4>
            <div4 id="html-unparsed-entity-system-id-accessor">
               <head>unparsed-entity-system-id Accessor</head>


               <p>The result of the <xspecref spec="DM40" ref="dm-unparsed-entity-system-id"/>
                  <code>dm:unparsed-entity-system-id($node)</code> for an HTML DOM <code>Node</code>
                  is an empty sequence.</p>
            </div4>
         </div3>
            <div3 id="html-parser-options">
               <head>HTML parser options</head>
               <p>This section describes the record structure used to pass options to the
               <function>fn:parse-html</function> function.</p>



   <p>Additional <termref def="implementation-defined"/> parser options are allowed.</p>
                           <example>
                              <head>Example:</head>
                              <p>An implementation may provide keys for options to the <emph>tidy</emph>
                                 HTML parser, allowing a user to configure the behaviour of that parser.</p>
                           </example>

            </div3>
            <div3 id="func-parse-html">
               <head><?function fn:parse-html?></head>
            </div3>
         </div2>
         <div2 id="json-functions">
            <head>Functions on JSON Data</head>
            <p>The functions listed in this section parse or serialize JSON data.</p>
            
            <p>JSON is a popular format for exchange of structured data on the web: it is specified in <bibref ref="rfc7159"/>.
               This section describes facilities
               allowing JSON data to be converted to and from XDM values.</p>
            
            <p>This specification describes two ways of representing JSON data losslessly
               using XDM constructs. The first method uses XDM maps to represent JSON objects, and XDM arrays to
               represent JSON arrays. The second method represents all JSON constructs using XDM element and attribute nodes.</p>
            
            
            <?local-function-index?>
            
            <p>Note also:</p>
            <ulist>
               <item><p>The function <function>fn:serialize</function> has an option to generate
                  JSON output from a structure of maps and arrays.</p>
               </item>
               <item><p>The function <function>fn:elements-to-maps</function> enables
                  arbitrary XML node trees to be converted to trees of maps and arrays
                  suitable for serializing as JSON.</p>
               </item>
            </ulist>
            
  
               
               <div3 id="json-to-maps-and-arrays">
                  <head>Representing JSON using maps and arrays</head>
                  
                  
                  <p>This section defines a mapping from JSON data to XDM maps and arrays. Two functions are available
                     to support this mapping: <function>fn:parse-json</function> and <function>fn:serialize</function> (with options
                     selecting JSON as the output method).
                     The <function>fn:parse-json</function> function will accept any JSON text as input, and converts it
                     to XDM data values. The <function>fn:serialize</function> function (with JSON as the output method) will accept any XDM
                     value produced using <function>fn:parse-json</function> and convert it back to the original JSON text
                     (subject to insignificant variations such as reordering the properties in a JSON object). </p>
                  
                  <note><p>The conversion is lossless if recommended JSON good practice is followed. Information may however be lost if
                     (a) JSON numbers are not exactly representable as double-precision floating point, or (b) duplicate key
                     values appear within a JSON object.</p></note>
                  
                  <p>The representation of JSON data produced by the <function>fn:parse-json</function> function
                     has been chosen with ease of manipulation as a design aim. For example, a simple JSON object
                     such as <code>{ "Sun": 1, "Mon": 2, "Tue": 3, ... }</code> produces a simple map, so if the result
                     of parsing is held in <code>$weekdays</code>, the number for a given weekday can be extracted
                     using an expression such as <code>$weekdays?Tue</code>. Similarly, a simple array such as
                     <code>[ "Sun", "Mon", "Tue", ... ]</code> produces an array that can be addressed as, for example,
                     <code>$weekdays(3)</code>. A more deeply nested structure can be addressed in a similar way:
                     for example if the JSON text is an array of person objects, each of which has a property named
                     <code>phones</code> which is an array of strings containing phone numbers, then the first phone number of
                     each person in the data can be addressed as <code>$data?phones(1)</code>.</p>
               </div3>
               
               
               <div3 id="json-to-xml-mapping">
                  <head>XML Representation of JSON</head>
                  
                  
                  <p>This section defines a mapping from JSON data to XML (specifically, to XDM element and attribute nodes). A
                     function <function>fn:json-to-xml</function> is provided to take a JSON string as input and convert it
                     to the XML representation, and a second function <function>fn:xml-to-json</function> performs the reverse operation.</p>
                  
                  <p>The XML representation is designed to be capable of representing any valid JSON text including
                     one that uses characters which are not valid in XML. The transformation is normally lossless: that is,
                     distinct JSON texts convert to distinct XML representations. When converting JSON to XML, options are provided
                     to reject unsupported characters, to replace them with a substitute character, or to leave them in
                     backslash-escaped form.</p>
                  
                  <note><p>The conversion is lossless if recommended JSON good practice is followed. Information may however be lost if
                     (a) JSON numbers are not exactly representable as double-precision floating point, or (b) duplicate key
                     values appear within a JSON object.</p></note>
                  
                  <p>The following example demonstrates the correspondence of a JSON text and the corresponding XML
                     representation. </p>
                  
                  <example>
                     <head>A JSON Text and its XML Representation</head>
                     <p>Consider the following JSON text:</p>
                     <eg><![CDATA[
{
  "desc"    : "Distances between several cities, in kilometers.",
  "updated" : "2014-02-04T18:50:45",
  "uptodate": true,
  "author"  : null,
  "cities"  : {
    "Brussels": [
      { "to": "London",    "distance": 322 },
      { "to": "Paris",     "distance": 265 },
      { "to": "Amsterdam", "distance": 173 }
    ],
    "London": [
      { "to": "Brussels",  "distance": 322 },
      { "to": "Paris",     "distance": 344 },
      { "to": "Amsterdam", "distance": 358 }
    ],
    "Paris": [
      { "to": "Brussels",  "distance": 265 },
      { "to": "London",    "distance": 344 },
      { "to": "Amsterdam", "distance": 431 }
    ],
    "Amsterdam": [
      { "to": "Brussels",  "distance": 173 },
      { "to": "London",    "distance": 358 },
      { "to": "Paris",     "distance": 431 }
    ]
  }
}]]></eg>
                     <p>The XML representation of this text is as follows. Whitespace is included in the XML representation for purposes of illustration,
                        but it will not necessarily be present in the output of the
                        <function>json-to-xml</function> function.</p>
                     <eg><![CDATA[
<map xmlns="http://www.w3.org/2005/xpath-functions">
  <string key="desc">Distances between several cities, in kilometers.</string>
  <string key="updated">2014-02-04T18:50:45</string>
  <boolean key="uptodate">true</boolean>
  <null key="author"/>
  <map key="cities">
    <array key="Brussels">
      <map>
        <string key="to">London</string>
        <number key="distance">322</number>
      </map>
      <map>
        <string key="to">Paris</string>
        <number key="distance">265</number>
      </map>
      <map>
        <string key="to">Amsterdam</string>
        <number key="distance">173</number>
      </map>
    </array>
    <array key="London">
      <map>
        <string key="to">Brussels</string>
        <number key="distance">322</number>
      </map>
      <map>
        <string key="to">Paris</string>
        <number key="distance">344</number>
      </map>
      <map>
        <string key="to">Amsterdam</string>
        <number key="distance">358</number>
      </map>
    </array>
    <array key="Paris">
      <map>
        <string key="to">Brussels</string>
        <number key="distance">265</number>
      </map>
      <map>
        <string key="to">London</string>
        <number key="distance">344</number>
      </map>
      <map>
        <string key="to">Amsterdam</string>
        <number key="distance">431</number>
      </map>
    </array>
    <array key="Amsterdam">
      <map>
        <string key="to">Brussels</string>
        <number key="distance">173</number>
      </map>
      <map>
        <string key="to">London</string>
        <number key="distance">358</number>
      </map>
      <map>
        <string key="to">Paris</string>
        <number key="distance">431</number>
      </map>
    </array>
  </map>
</map>]]></eg>
                  </example>
                  
                  <p>An XSD 1.0 schema for the XML representation is provided in <specref ref="schema-for-json"/>.
                     It is not necessary to import this schema into the static context unless the stylesheet or query
                     makes explicit reference to the components defined in the schema. If the stylesheet or query does import a schema
                     for the namespace <code>http://www.w3.org/2005/xpath-functions</code>, then:</p>
                  
                  <olist>
                     <item><p>Unless the host language specifies otherwise, the processor (if it is schema-aware)
                        <rfc2119>must</rfc2119> recognize an import declaration for
                        this namespace, whether or not a schema location is supplied.</p></item>
                     <item><p>If a schema location is provided, then the schema document at that location <rfc2119>must</rfc2119>
                        be equivalent to the schema document at <specref ref="schema-for-json"/>; the effect if it is not equivalent is
                        <termref def="implementation-dependent"/></p></item>
                  </olist>
                  
                  <p>The rules governing the mapping from JSON to XML are as follows. In these rules, the phrase
                     “an element named N” is to be interpreted as meaning “an element node whose local name is N and whose
                     namespace URI is <code>http://www.w3.org/2005/xpath-functions</code>”.</p>
                  
                  <olist>
                     <item><p>The JSON value <code>null</code> is represented by an element named <code>null</code>, with empty content.</p></item>
                     <item><p>The JSON values <code>true</code> and <code>false</code> are represented by an element named <code>boolean</code>,
                        with content conforming to the type <code>xs:boolean</code>. When the element is created by the
                        <function>fn:json-to-xml</function> function, the string value of the element will be <code>true</code> or <code>false</code>.
                        The <function>fn:xml-to-json</function> function also recognizes other strings that validate as <code>xs:boolean</code>,
                        for example <code>1</code> and <code>0</code>. Leading and trailing whitespace is accepted.
                     </p></item>
                     <item><p>A JSON number is represented by an element named <code>number</code>,
                        with content conforming to the type <code>xs:double</code>, with the additional restriction that the value
                        must not be positive or negative infinity, nor <code>NaN</code>. The
                        <function>fn:json-to-xml</function> function creates an element whose string value is lexically the same as the JSON representation
                        of the number. The <function>fn:xml-to-json</function> function generates a JSON representation that is the result of casting the
                        (typed or untyped) value of the node to <code>xs:double</code> and then casting the result to <code>xs:string</code>.
                        Leading and trailing whitespace is accepted.
                        Since JSON does not impose limits on the range or precision
                        of numbers, these rules mean that conversion from JSON to XML will always succeed, and will retain full precision
                        in the lexical representation unless the data model implementation is one that reconstructs the string value from
                        the typed value. In the reverse direction, conversion from XML to JSON may fail if the value is infinity or <code>NaN</code>,
                        or if the string value is such that casting to <code>xs:double</code> produces positive or negative infinity.
                     </p>
                     </item>
                     <item><p>A JSON string is represented by an element named <code>string</code>, with
                        content conforming to the type <code>xs:string</code>. The <code>string</code> element has two
                        alternative representations: escaped form, and unescaped form.</p></item>
                     <item><p>A JSON array is represented by an element named <code>array</code>. The content is a sequence of
                        child elements representing the members of the array in order, each such element being the representation
                        of the array member obtained by applying these rules recursively.</p></item>
                     <item><p>A JSON object is represented by an element named <code>map</code>. The content is a sequence
                        of child elements each of which represents one of the name/value pairs in the object. The representation of the
                        name/value pair <var>N:V</var> is obtained by taking the element that represents the value <var>V</var> (by applying these
                        rules recursively) and adding an attribute with name <code>key</code> (in no namespace), whose
                        value is <var>N</var> as an instance of <code>xs:string</code>. The functions <function>fn:json-to-xml</function> and
                        <function>fn:xml-to-json</function> both retain the order of entries, subject to rules about how duplicate keys are handled. The
                        key may be represented in escaped or unescaped form.</p></item>
                     
                  </olist>
                  
                  <p>The attribute <code>escaped="true"</code> may be specified on a <code>string</code> element to indicate
                     that the string value contains backslash-escaped characters that are to be interpreted according to the JSON
                     rules. The attribute <code>escaped-key="true"</code> may be specified on any element with a <code>key</code> attribute to indicate
                     that the key contains backslash-escaped characters that are to be interpreted according to the JSON
                     rules. Both attributes have the default value <code>false</code>, signifying that the relevant value is in unescaped form.
                     In unescaped form, the backslash character has no special significance (it represents itself).</p>
                  
                  <p>The JSON grammar for <code>number</code> is a subset of the lexical space of
                     the XSD type <code>xs:double</code>. The mapping from JSON <code>number</code> values to <code>xs:double</code>
                     values is defined by the XPath rules for casting from <code>xs:string</code> to <code>xs:double</code>. Note that
                     these rules will never generate an error for out-of-range values; instead very large or very small values will be
                     converted to <code>+INF</code> or <code>-INF</code>. Since JSON does not impose limits on the range or precision
                     of numbers, the conversion is not guaranteed to retain full precision.</p>
                  
                  <p>Although the order of entries in a JSON object is generally considered to have no significance, the functions
                     <code>json-to-xml</code> and <code>xml-to-json</code> both retain order.</p>
                  
                  <p>The XDM representation of a JSON value may either be untyped (all elements annotated as <code>xs:untyped</code>, attributes
                     as <code>xs:untypedAtomic</code>), or it may be typed. If it is typed, then it <rfc2119>must</rfc2119> have the type
                     annotations obtained by validating the untyped representation against the schema given in <specref ref="schema-for-json"/>.
                     If it is untyped, then it <rfc2119>must</rfc2119> be an XDM instance such that validation against this schema would succeed;
                     with the proviso that all attributes other than those in no namespace or in namespace <code>http://www.w3.org/2005/xpath-functions</code>
                     are ignored, including attributes such as <code>xsi:type</code> and <code>xsi:nil</code> that would normally influence the process
                     of schema validation.</p>
                  
                  <p>The namespace prefix associated with the namespace <code>http://www.w3.org/2005/xpath-functions</code> (if any) is immaterial.
                     The effect of the <function>fn:xml-to-json</function> function does not depend on the choice of prefix, and the prefix (if any) generated by the
                     <function>fn:json-to-xml</function> function is <termref def="implementation-dependent">implementation-dependent</termref>.</p>
               </div3>
            
            <div3 id="json-character-repertoire">
                  <head>JSON character repertoire</head>
               <changes>
                  <change issue="414" PR="546" date="2023-07-25">
                     The rules regarding use of non-XML characters in JSON texts have been relaxed.
                  </change>
               </changes>
               <p>The set of characters that may appear in JSON texts is not the same as
               the set of characters allowed in XML. Specifically:</p>
               
               <ulist>
                  <item><p>As plain unescaped characters, JSON allows any codepoint in the
                  numeric range 0x20 to 0x10FFFF, with the exception of <char>U+0022</char>
                  and <char>U+005C</char>.</p></item>
                  <item><p>As a backslash-escaped character, JSON allows any codepoint in the
                  numeric range 0x00 to 0xFFFF.</p></item>
                  <item><p>Whether escaped or not, the JSON grammar allows codepoints in the surrogate
                  range to appear, and does not explicitly require that they be properly paired.
                  However, the JSON specifications recognize that unpaired surrogates are likely to lead
                  to interoperability problems.</p></item>
               </ulist>
               
               <p>Ignoring unpaired surrogates, this means that JSON allows codepoints that are not
                  allowed by XML:</p>
               <ulist>
                  <item><p>Not allowed by XML 1.0: 0x00 to 0x1F (other than 0x09, 0x0A, and 0x0D); 0xFFFE; 0xFFFF.</p></item>
                  <item><p>Not allowed by XML 1.1: 0x00; 0xFFFE; 0xFFFF.</p></item>
               </ulist>
               
               <p>The XDM data model (see <xspecref spec="DM40" ref="xml-and-xsd-versions"/>) allows
               an implementation to define the set of <termref def="dt-permitted-character">permitted characters</termref>
               in the <code>xs:string</code> data type in such a way that any
               Unicode codepoint assigned to a character (which excludes surrogates) 
               is allowed. However, this
               is not required: a conformant implementation <rfc2119>may</rfc2119> restrict the set of
               codepoints to those permitted by XML 1.0 or XML 1.1.</p>
               
               <p>In consequence, parsing of conformant JSON texts may fail if they contain codepoints
               that the implementation does not support. However, if such codepoints are represented
               in the input using JSON escape sequences, these specifications define 
               mechanisms for dealing with them, for example by substituting a replacement character.</p>
               
            </div3>
            
            <div3 id="func-parse-json">
               <head><?function fn:parse-json?></head>
            </div3>
            <div3 id="func-json-doc">
               <head><?function fn:json-doc?></head>
            </div3>
            <div3 id="func-json-to-xml">
               <head><?function fn:json-to-xml?></head>
            </div3>
            <div3 id="func-xml-to-json">
               <head><?function fn:xml-to-json?></head>
            </div3>
            
            <div3 id="func-pin" diff="add" at="A">
               <head><?function fn:pin?></head>
            </div3>
            <div3 id="func-label" diff="add" at="A">
               <head><?function fn:label?></head>
            </div3>
         </div2>
         <div2 id="csv-functions">
            <head>Functions on CSV Data</head>
            <changes>
               <change issue="413" PR="533 719 834">
                  New functions are available for processing input data in CSV (comma separated values) format.
               </change>
            </changes>
            <p>This section describes functions that parse CSV data.</p>
            
  

            <p><termdef id="dt-csv" term="CSV"> The term <term>comma separated values</term> or 
               <term>CSV</term> refers to a wide variety of plain-text tabular data formats with
               fields and records separated by standard character delimiters 
               (often, but not invariably, commas).</termdef></p>
            
            <p>A CSV is a 2-dimensional tabular data structure consisting of multiple <term>rows</term> 
               (also known as <term>records</term>). Each
               row contains multiple <term>fields</term>. Fields occupying the same position in
               successive rows constitute a <term>column</term>. Columns are identified by position and
               optionally by name. Column names can be
               assigned within a CSV using an optional <term>header row</term>.</p>
            
            <p>CSV has developed informally for decades, and many variations are found. 
               This specification refers to <bibref ref="rfc4180"/>,
               which provides a standardized grammar. This specification extends the
               grammar defined in <bibref ref="rfc4180"/> as follows:</p>
            
            <ulist>
               <item><p>This specification uses the term <term>row</term> where RFC 4180 uses
               <term>record</term>.</p></item>
               <item><p>Line endings are normalized: specifically, the character sequences
               <char>U+000D</char>, or <char>U+000D</char> followed by <char>U+000A</char>, are converted
                  to a single <char>U+000A</char> character. This applies whether or not the line ending
               appears within a quoted string, and whether or not <char>U+000A</char> is the chosen
               row delimiter.</p></item>
               <item><p>Row delimiters other than newline are recognized.</p></item>
               <item><p>Field delimiters other than <char>U+002C</char> are recognized.</p></item>
               <item><p>Quote characters other than <char>U+0022</char> are recognized.</p></item>
               <item><p>Non-ASCII characters are recognized.</p></item>
            </ulist>
            
            
            <p>This specification defines a 
               mapping from this extended grammar
               to constructs in the XDM model, and provides illustrative examples of how these
               constructs can be combined with other language features to process CSV data.</p>

            
            
            <?local-function-index?>
            
            <p>The most basic function for parsing CSV is <function>fn:csv-to-arrays</function>
            which recognizes the delimiters for rows and fields and returns a sequence
            of arrays each corresponding to one row. The fields within each array are
            represented as instances of <code>xs:string</code>.</p>
            
            <p>The other two functions recognize column names, and make it easier to address
            individual fields using these names. The <code>parse-csv</code> function
            delivers this capability using XDM maps and functions, while <code>csv-to-xml</code>
            function represents the information using XDM element nodes.</p>
            
            <div3 id="csv-delimiters">
               <head>CSV delimiters</head>
               
               <p>The delimiters used for rows, columns, and quoting are configurable. An error
                  is raised if the same delimiter string is used in multiple roles 
                  <errorref class="CV" code="0003"/>.</p>

                  <p>Rows in CSV files are typically delimited with CRLF (<char>U+000D</char>, <char>U+000A</char>), 
                     LF (<char>U+000A</char>), or CR (<char>U+000D</char>) line endings, 
                     although RFC 4180 specifies CRLF. The CSV parsing functions 
                     normalize these line endings to LF (<char>U+000A</char>).
                     They therefore use LF as the default row delimiter.
                  </p>
               
                 
               
                  <p>The last row in the file may or may not be followed by a row delimiter.
                  An empty file is treated as containing zero rows, while a file consisting solely
                  of a row delimiter is treated as containing one empty row. In all other cases,
                  a file that does not end with a row delimiter is treated as if a row delimiter were
                  added at the end.</p>

                  <p>Fields in CSV are frequently delimited with a comma. Other field
                     delimiters are useful, for
                     example when numeric data uses comma as a decimal separator. The
                     chosen field delimiter is then often <char>U+003B</char>
                     or <char>U+0009</char>.</p>

               <p>The column delimiter thus defaults to <char>U+002C</char>. 
                     The value may be
                     any single Unicode character. An error is raised if the 
                     <code>column-delimiter</code> option is set to a multi-character string.</p>
            </div3>

            <div3 id="csv-field-quoting">
               <head>Field quoting</head>

               <p>CSVs, as specified in <bibref ref="rfc4180"/>, require that fields be wrapped 
                  with a quote character if they
                  contain either the row or column delimiter. For example:</p>

               <eg>"A single field, containing a comma","another field containing CRLF
                  within it"</eg>

               <p>If a field is to contain the quote character, the character must be escaped by doubling it, 
                  as with escaping of quotes in XPath string literals (see <xspecref
                     ref="id-literals" spec="XP40"/>). An error is raised
                  <errorref class="CV" code="0001"/> if a quote character appears within a field
                  incorrectly escaped, for example:</p>

               <eg>incorrectly escaped " quote character</eg>

               <p>The quotes surrounding quoted fields are not included in the result. The
                  following input string, when parsed, produces a sequence of strings, as shown
                  below:</p>

               <eg>'"Field 1","Field 2","Field ""with quotes"" 3"'</eg>

               <eg>('Field 1', 'Field 2', 'Field "with quotes" 3')</eg>

               <p>The quote character defaults to <char>U+0022</char>.</p>


                  <p>No space is allowed between the column delimiter and a quote. An error is raised
                     <errorref class="CV" code="0001"/> if
                     whitespace or other characters occur between a quote character and the nearest
                     column delimiter.</p>

                  <p>The following example is therefore invalid and parsing it will raise an error.</p>

                  <eg>'"Field 1", "Field 2", "Field 3"'</eg>

            </div3>

            <div3 id="basic-csv-to-xdm-mapping">
               <head>Basic parsing of CSV to arrays</head>

               <p>The result of <function>fn:csv-to-arrays</function> is a sequence of rows, where
                  each row is represented as an array of <code>xs:string</code> values.</p>

               <p>The first row of the CSV is returned in the same way as all the other rows.
                  <function>fn:csv-to-arrays</function> does not distinguish between a header row and data
                  rows, and returns all of them.</p>

<example>
   <head>A CSV with fixed-width rows</head>
   <p>For example, given the input:</p>

               <eg>
'Column 1,Column 2,Column 3
Field 1A,Field 1B,Field 1C
Field 2A,Field 2B,Field 2C'
               </eg>

               <p>the <function>fn:csv-to-arrays</function> function produces</p>

               <eg>
(
  [ "Column 1", "Column 2", "Column 3" ],
  [ "Field 1A", "Field 1B", "Field 1C" ],
  [ "Field 2A", "Field 2B", "Field 2C" ]
)
               </eg>
   </example>
               <example>
                  <head>A CSV with variable-width rows</head>
               

               <p>It is common practice for all rows in a CSV to
                  have the same number of columns, but this is not required.</p>

               <eg>
'Column 1,Column 2,Column 3
Field 1A,Field 1B,Field 1C
Field 2A,Field 2B,Field 2C,Field 2D'
               </eg>

               <p>produces</p>

               <eg>
(
  [ "Column 1", "Column 2", "Column 3" ],
  [ "Field 1A", "Field 1B", "Field 1C" ],
  [ "Field 2A", "Field 2B", "Field 2C", "Field 2D" ]
)
               </eg>

               <p><bibref ref="rfc4180"/> states that CSVs <rfc2119>should</rfc2119> contain the
                  same number of fields in each row, so that there are a uniform number of columns.
                  However, the reality is that CSVs can, and sometimes do, contain a variable number
                  of fields in a row. As a result, this function does
                  not truncate or pad the number of fields in each row for any reason.
                  The <function>fn:csv-to-xml</function> and <function>fn:parse-csv</function> functions provide
                  facilities to enforce uniformity and an expected number of
                  columns.</p>
               </example>
            </div3>
            
            <div3 id="func-csv-to-arrays">
               <head><?function fn:csv-to-arrays?></head>
            </div3>

            <div3 id="csv-to-xdm-mapping">
               <head>Enhanced parsing of CSV data to maps and arrays</head>


               <p>While <function>fn:csv-to-arrays</function> simply delivers the CSV content
                  as a sequence of arrays, the <function>fn:parse-csv</function> function goes a step
                  further and enables access to the data using column names. The column
                  names may be taken either from the first row of the CSV data, or from
                  data supplied by the caller in the <code>options</code> parameter.</p>
                  
                 
               

            </div3>
            <div3 id="parsed-csv-structure-record">
               <head><?record-description parsed-csv-structure-record?></head>
            </div3>
            <div3 id="func-parse-csv">
               <head><?function fn:parse-csv?></head>
            </div3>
            <div3 id="csv-represent-as-xml">
               <head>Representing CSV data as XML</head>

               <p>The <function>fn:csv-to-xml</function> function returns an XDM node tree representing the CSV data.
                  Following is a CSV text and the XML serialization of the corresponding node tree.</p>

               <eg>Name,Date,Amount
Alice,2023-07-14,1.23
Bob,2023-07-14,2.34
               </eg>

               <eg><![CDATA[
<csv xmlns="http://www.w3.org/2005/xpath-functions">
  <columns>
    <column>Name</column>
    <column>Date</column>
    <column>Amount</column>
  </columns>
  <rows>
    <row>
      <field column="Name">Alice</field>
      <field column="Date">2023-07-14</field>
      <field column="Amount">1.23</field>
    </row>
    <row>
      <field column="Name">Bob</field>
      <field column="Date">2023-07-14</field>
      <field column="Amount">2.34</field>
    </row>
  </rows>
</csv>
]]></eg>

               <p>If no non-empty column names are available, then the <code>columns</code> 
                  element and all <code>column</code> attributes are absent. 
                  If non-empty column names are available for some columns but not for others,
                  then (a) an empty <code>column</code> element is included
                  within the <code>columns</code> element if and only if there is a subsequent
                  column with a non-empty name, and (b) the <code>column</code> attribute 
                  for the corresponding <code>field</code> elements is absent.</p>
               
               <p>For example (when no column names are available):</p>

               <eg><![CDATA[
<csv xmlns="http://www.w3.org/2005/xpath-functions">
  <rows>
    <row>
      <field>Name</field>
      <field>Date</field>
      <field>Amount</field>
    </row>
    <row>
      <field>Alice</field>
      <field>2023-07-14</field>
      <field>1.23</field>
    </row>
    <row>
      <field>Bob</field>
      <field>2023-07-14</field>
      <field>2.34</field>
    </row>
  </rows>
</csv>
]]></eg>

               <p>An XSD 1.0 schema for the XML representation is provided in 
                  <specref ref="schema-for-csv"/>.</p>
            </div3>
            
            
            <div3 id="func-csv-to-xml">
               <head><?function fn:csv-to-xml?></head>
            </div3>
            
            <div3 id="illustrative-csv-examples">
               <head>Illustrative examples of processing CSV data</head>


               <p>The following examples illustrate more complex applications making use of CSV parsing functions.</p>

               <p>A variable <code>$crlf</code> is assumed to be in scope representing the CRLF string:</p>

               <eg>let $crlf := fn:char(0x0D)||fn:char(0x0A)</eg>

               <example id="csv-to-html-table">
                  <head>Converting a CSV into an HTML-style table using <function>fn:parse-csv</function></head>

                  <p>Direct conversion is a matter of iterating across the records and fields to
                     generate <code>&lt;tr&gt;</code> and <code>&lt;td&gt;</code> elements.</p>

                  <p>Using XQuery:</p>
                  <eg><![CDATA[
let $csv := fn:parse-csv(`name,city{ $crlf }Bob,Berlin`)
return <table>
  <thead>{
    for $column in $csv?columns?fields
    return <th>{ $column }</th>
  }</thead>
  <tbody>{
    for $row in $csv?rows
    return <tr>{ for $field in $row?fields return <td>{ $field }</td> }</tr>
  }</tbody>
</table>]]></eg>

                  <p>Using XSLT:</p>
                  <eg><![CDATA[
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:eg="http://example.org/eg"
  xmlns:array="http://www.w3.org/2005/xpath-functions/array"
  exclude-result-prefixes="eg array"
  version="4.0">
  <xsl:output method="xml" indent="true"/>

  <xsl:template match="." mode="csv-th" expand-text="true">
    <th>{ . }</th>
  </xsl:template>

  <xsl:template match="." mode="csv-td" expand-text="true">
    <td>{ . }</td>
  </xsl:template>

  <xsl:template match="." mode="csv-tr">
    <tr>
      <xsl:apply-templates select=".?fields" mode="csv-td"/>
    </tr>
  </xsl:function>

  <xsl:template name="xsl:initial-template">
    <xsl:variable name="csv" select="parse-csv(`name,city{ $crlf }Bob,Berlin`)"/>
    <table>
      <thead>
        <tr>
          <xsl:apply-templates select="$csv?columns?fields" mode="csv-th"/>
        </tr>
      </thead>
      <tbody>
        <xsl:apply-templates select="$csv?rows" mode="csv-tr"/>
      </tbody>
    </table>
  </xsl:template>
</xsl:stylesheet>
                  ]]></eg>
               </example>
               <example id="csv-to-html-table-csv-to-xml">
                  <head>Converting a CSV into an HTML-style table using <function>fn:csv-to-xml</function></head>

                  <p>The <function>fn:csv-to-xml</function> function makes these kinds of
                     conversion-to-XML-table tasks simpler by providing a simple XML represenation of the data. Here, in XQuery:</p>

                  <eg><![CDATA[
let $csv := csv-to-xml(`name,city{ $crlf }Bob,Berlin`)
return <table>
  <thead>{
    for $column in $csv/csv/columns/column
    return <th>{ $column }</th>
  }</thead>
  <tbody>{
    for $row in $csv/csv/rows/row
    return <tr>{ for $field in $row/field return <td>{ $field }</td> }</tr>
  }</tbody>
</table>
                  ]]></eg>

                  <p>And in XSLT:</p>

                  <eg><![CDATA[
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fn="http://www.w3.org/2005/xpath-functions"
  exclude-result-prefixes="fn"
  version="4.0">
  <xsl:output method="xml" indent="true"/>

  <xsl:template match="fn:column" expand-text="true">
    <th>{ . }</th>
  </xsl:template>

  <xsl:template match="fn:field" expand-text="true">
    <td>{ . }</td>
  </xsl:template>

  <xsl:template match="fn:row">
    <tr>
      <xsl:apply-templates/>
    </tr>
  </xsl:function>

  <xsl:template match="fn:columns">
    <thead>
      <tr>
        <xsl:apply-templates/>
      </tr>
    </thead>
  </xsl:function>

  <xsl:template match="fn:rows">
    <tbody>
      <xsl:apply-templates/>
    </tbody>
  </xsl:function>

  <xsl:template match="fn:csv">
    <table>
      <xsl:apply-templates/>
    </table>
  </xsl:template>

  <xsl:template name="xsl:initial-template">
    <xsl:apply-templates select="fn:csv-to-xml(`name,city{ $crlf }Bob,Berlin`)"/>
  </xsl:template>
</xsl:stylesheet>
                  ]]></eg>
               </example>
            </div3>
     
         
            
         </div2>

         <div2 id="ixml-functions">
            <head>Functions on Invisible XML</head>
            <p>This section describes functions that support
            <bibref ref="invisible-xml"/> parsing.</p>
            <p>Invisible XML defines a BNF-like language for specifying grammars, together with 
            a mapping from sentences in that grammar to an XML representation. By defining an
            Invisible XML grammar, a great variety of non-XML data formats can be manipulated
            as if they were XML. The function <function>fn:invisible-xml</function> takes a grammar
            as input, and returns a function which can be used for parsing data instances
            and converting them to XML node trees.</p>
            <div3 id="func-invisible-xml">
               <head><?function fn:invisible-xml?></head>
            </div3>
         </div2>

          </div1>
      <div1 id="context">
         <head>Context functions</head>
         <p>The following functions are defined to obtain information from the 
            static or dynamic context.</p>
         <?local-function-index?>
         <div2 id="func-position">
            <head><?function fn:position?></head>
         </div2>
         <div2 id="func-last">
            <head><?function fn:last?></head>
         </div2>
         <div2 id="func-current-dateTime">
            <head><?function fn:current-dateTime?></head>
         </div2>
         <div2 id="func-current-date">
            <head><?function fn:current-date?></head>
         </div2>
         <div2 id="func-current-time">
            <head><?function fn:current-time?></head>
         </div2>
         <div2 id="func-implicit-timezone">
            <head><?function fn:implicit-timezone?></head>
         </div2>
         <div2 id="func-default-collation">
            <head><?function fn:default-collation?></head>
         </div2>
         <div2 id="func-default-language">
            <head><?function fn:default-language?></head>
         </div2>
         <div2 id="func-static-base-uri">
            <head><?function fn:static-base-uri?></head>
		 </div2>
      </div1>
      <div1 id="higher-order-functions">
         <head>Higher-order functions</head>
         <div2 id="functions-on-functions">
            <head>Processing function items</head>
            <p>The functions included in this section operate on function items, that is, values referring to a function.</p>
            
            <p><termdef id="dt-higher-order" term="higher-order">Functions that accept functions among their arguments,
               or that return functions in their result, are described in this specification as <term>higher-order</term>
               functions.</termdef> 
               <phrase diff="del" at="2023-01-29">Some host languages may exclude higher-order functions from the set of functions
            that they support, or may include such functions in an optional conformance feature.</phrase></p>
            
            <note><p>Some functions such as <function>fn:parse-json</function> allow the option of supplying a callback function
            for example to define exception behavior. Where this is not essential to the use of the function,
            the function has not been classified as higher-order for this purpose; in applications where function items
            cannot be created, these particular options will not be available.</p></note>
            
            <?local-function-index?>
            <div3 id="func-function-lookup">
               <head><?function fn:function-lookup?></head>
            </div3>
            <div3 id="func-function-name">
               <head><?function fn:function-name?></head>
            </div3>
            <div3 id="func-function-arity">
               <head><?function fn:function-arity?></head>
            </div3>
            <div3 id="func-function-identity">
               <head><?function fn:function-identity?></head>
            </div3>
            <div3 id="func-function-annotations">
               <head><?function fn:function-annotations?></head>
            </div3>
            
         </div2>
         <div2 id="basic-hofs">
            <head>Basic higher-order functions</head>
            <p>The following functions take function items as an argument.</p>
            <?local-function-index?>
            
            <p>With all these functions, if the caller-supplied function fails with a dynamic error,
            this error is propagated as an error from the higher-order function itself.</p>
            
            <div3 id="func-apply">
               <head><?function fn:apply?></head>
            </div3>
            <div3 id="func-chain" diff="add" at="A">
               <head>
                  <?function fn:chain?>
               </head>
            </div3>
            <div3 id="func-do-until">
               <head><?function fn:do-until?></head>
            </div3>
            <div3 id="func-every" diff="add" at="A">
               <head>
                  <?function fn:every?>
               </head>
            </div3>
            <div3 id="func-filter">
               <head><?function fn:filter?></head>
            </div3>
            <div3 id="func-fold-left">
               <head><?function fn:fold-left?></head>
            </div3>
            <div3 id="func-fold-right">
               <head><?function fn:fold-right?></head>
            </div3>
            <div3 id="func-for-each">
               <head><?function fn:for-each?></head>
            </div3>
            <div3 id="func-for-each-pair">
               <head><?function fn:for-each-pair?></head>
            </div3>
            <div3 id="func-highest" diff="add" at="A">
               <head><?function fn:highest?></head>
            </div3>
            <div3 id="func-index-where" diff="add" at="A">
               <head><?function fn:index-where?></head>
            </div3>
            <div3 id="func-lowest" diff="add" at="A">
               <head><?function fn:lowest?></head>
            </div3>
            <div3 id="func-partial-apply">
               <head><?function fn:partial-apply?></head>
            </div3>
            <div3 id="func-partition" diff="add" at="A">
               <head><?function fn:partition?></head>
            </div3>
            <div3 id="func-scan-left" diff="add" at="A">
               <head><?function fn:scan-left?></head>
            </div3>
            <div3 id="func-scan-right" diff="add" at="A">
               <head><?function fn:scan-right?></head>
            </div3>
            <div3 id="func-some" diff="add" at="A">
               <head><?function fn:some?></head>
            </div3>
            <div3 id="func-sort">
               <head><?function fn:sort?></head>
            </div3>
            <div3 id="func-sort-with" diff="add" at="A">
               <head><?function fn:sort-with?></head>
            </div3>
            <div3 id="func-subsequence-where" diff="add" at="2024-01-10">
               <head><?function fn:subsequence-where?></head>
            </div3>
            <div3 id="func-take-while" diff="add" at="2024-02-07">
               <head><?function fn:take-while?></head>
            </div3>
            <div3 id="func-transitive-closure">
               <head><?function fn:transitive-closure?></head>
            </div3>
            <div3 id="func-while-do">
               <head><?function fn:while-do?></head>
            </div3>
         </div2>
         <div2 id="dynamic-loading">
            <head>Dynamic Evaluation</head>
            <p>The following functions allow dynamic loading and evaluation of XQuery queries, XSLT stylesheets,
               and XPath binary operators.</p>
            <?local-function-index?>
            <div3 id="load-xquery-module-record">
              <head><?record-description load-xquery-module-record?></head>
            </div3>
            <div3 id="func-load-xquery-module">
               <head><?function fn:load-xquery-module?></head>
            </div3>
            <div3 id="func-transform">
               <head><?function fn:transform?></head>
            </div3>
            <div3 id="func-op">
               <head><?function fn:op?></head>
            </div3>
         </div2>
      </div1>

      <div1 id="maps">
         <head>Processing maps</head>
         
         
         <p>Maps were introduced as a new datatype in XDM 3.1. This section describes functions that
         operate on maps.</p>
         
         <p>A map is a kind of item.</p>
         
         <p><termdef id="dt-map" term="map">A <term>map</term> consists of a sequence of entries, also known
            as key-value pairs. Each entry comprises a key 
            which is an arbitrary atomic item, and an arbitrary sequence called the associated value.</termdef></p>
         
         <p><termdef id="dt-same-key" term="same key">Within a map, no two entries have the <term>same key</term>. 
            Two atomic items <code>K1</code> and <code>K2</code> are the <term>same key</term>
            for this purpose if the <phrase diff="chg" at="2023-01-25">function call <code>fn:atomic-equal($K1, $K2)</code></phrase>
            returns <code>true</code>.</termdef></p>
         
         <p>It is not necessary that all the keys in a map should be
            of the same type (for example, they can include a mixture of integers and strings).</p>
         
         <p>Maps are immutable, and have no identity separate from their content. 
            For example, the <function>map:remove</function> function returns a map that differs
            from the supplied map by the omission (typically) of one entry, but the supplied map is not changed by the operation.
            Two calls on <function>map:remove</function> with the same arguments return maps that are
            indistinguishable from each other; there is no way of asking whether these are “the same map”.</p>
         
         <p>A map can also be viewed as a function from keys to associated values. To achieve this, a map is also a 
            function item. The function corresponding to the map has the signature 
            <code>function($key as xs:anyAtomicValue) as item()*</code>. Calling the function has the same effect as calling
            the <function>map:get</function> function: the expression
            <code>$map($key)</code> returns the same result as <code>get($map, $key)</code>. For example, if <code>$books-by-isbn</code>
            is a map whose keys are ISBNs and whose assocated values are <code>book</code> elements, then the expression
            <code>$books-by-isbn("0470192747")</code> returns the <code>book</code> element with the given ISBN.
            The fact that a map is a function item allows it to be passed as an argument to higher-order functions 
            that expect a function item as one of their arguments.</p>
         
         <div2 id="map-ordering">
            <head>Ordering of Maps</head>
            
            <changes>
               <change issue="1651" PR="1703" date="2025-01-14">Ordered maps are introduced.</change>
            </changes>
            
            <p>In 4.0, the entries in a map are ordered. The <xtermref spec="DM40" ref="dt-entry-order">entry order</xtermref> of a map
            is referred to as <term>entry order</term>.</p>
            <p>The entry order of the entries in a map is defined by the function or expression
               that creates the map, and affects the result of functions and expressions
               that process multiple entries in a map, for example the function <function>map:keys</function>
               and the expression 
               <code>for key $k value $v return <var>EXPR</var></code>. The ordering
               is also reflected in the output
            of the <code>json</code> and <code>adaptive</code> serialization methods.</p>
            
            <note>
               <p>Order is maintained in maps for two main reasons:</p>
               <ulist>
                  <item><p>To make the representation of a map (such as its JSON
                     serialization) easier for human readers to process: for example when
                  visually inspecting the result of a JSON transformation;</p></item>
                  <item><p>To make the result of different implementations interoperable.</p></item>
               </ulist>
               <p>Although it is possible to use the ordering of a map to capture
               semantic information, the design of functions such as <function>fn:deep-equal</function>
               discourages this: maps are compared with each other, and matched against map types,
               without regard to the order of entries.</p>
            </note>
            
             
            
         </div2>
         
         <div2 id="map-composition-decomposition" diff="add" at="2023-04-19">
            <head>Composing and Decomposing Maps</head>

         
         <p>It is often useful to decompose a map into a sequence of entries, or key-value pairs 
            (in which the key is an atomic item and the value is an arbitrary sequence). Subsequently it may be necessary
            to reconstruct a map from these components, typically after modification.</p>
            
            <p>There are two conventional ways of representing key-value pairs,
            each with its own advantages and disadvantages. Both approaches are supported by functions in this library.
            These are described below:</p>
         
         <olist diff="add" at="2023-04-03">
            <item><p><termdef id="dt-single-entry-map" term="single-entry map">A <term>single-entry map</term> is a map containing a single
               entry.</termdef></p>
               <p>It is possible to decompose any map into a sequence of <termref def="dt-single-entry-map">single-entry maps</termref>,
                  and to construct a map from a sequence of singleton maps.</p>
               <p>For example the map
               <code>{ "x": 1, "y": 2 }</code> can be decomposed to the sequence <code>({ "x": 1 }, { "y": 2 })</code>.</p></item>
            
            <item><p><termdef id="dt-key-value-pair-map" term="key-value pair map">A <term>key-value pair map</term> is a map containing two
            entries, one (with the key <code>"key"</code>) containing the key part of a key value pair, the other (with the key <code>"value"</code>)
            containing the value part of a key value pair.</termdef></p>
               <p>The record type for a <termref def="dt-key-value-pair-map"/> is defined in <specref ref="key-value-pair"/>.</p>
               <p>For example
                  the map <code>{ "x": 1, "y": 2 }</code> can be decomposed as 
                  <code>({ "key": "x", "value": 1 }, { "key": "y", "value": 2 })</code></p>
               <p>A <termref def="dt-key-value-pair-map"/> is an instance of the type 
                  <code>record(key as xs:anyAtomicType, value as item()*)</code>.</p> </item>
         </olist>
         
         <p diff="add" at="2023-04-03">The following table summarizes the way in which these two representations 
            can be used to compose and decompose maps:</p>
         
         <table role="data" diff="add" at="2023-04-03">
            <thead>
               <tr>
                  <th>Operation</th>
                  <th>Singleton Maps</th>
                  <th>Key-Value Pair Maps</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <td><p>Decompose a map</p></td>
                  <td><p><code>map:entries($map)</code></p></td>
                  <td><p><code>map:pairs($map)</code></p></td>
               </tr>
               <tr>
                  <td><p>Compose a map</p></td>
                  <td><p><code>map:merge($entries)</code></p></td>
                  <td><p><code>map:of-pairs($key-value-pairs)</code></p></td>
               </tr>
               <tr>
                  <td><p>Create a single entry</p></td>
                  <td><p><code>map:entry($key, $value)</code></p></td>
                  <td><p><code>map:pair($key, $value)</code></p></td>
               </tr>
               <tr>
                  <td><p>Extract the key part of a single entry</p></td>
                  <td><p><code>map:keys($entry)</code></p></td>
                  <td><p><code>$key-value-pair?key</code></p></td>
               </tr>
               <tr>
                  <td><p>Extract the value part of a single entry</p></td>
                  <td><p><code>map:items($entry)</code></p></td>
                  <td><p><code>$key-value-pair?value</code></p></td>
               </tr>
            </tbody>
         </table>
            
            <div3 id="key-value-pair">
               <head><?record-description key-value-pair?></head>
            </div3>
         
         </div2>
         
         <div2 id="formal-specification-of-maps">
            <head>Formal Specification of Maps</head>
            <p>The XDM data model (<bibref ref="xpath-datamodel-40"/>) defines three primitive operations on maps:</p>
            <ulist>
               <item><p><code>dm:empty-map</code> constructs an empty map.</p></item>
               <item><p><code>dm:map-put</code> adds or replaces an entry in a map.</p></item>
               <item><p><code>dm:iterate-map</code> applies a supplied function to every entry in a map.</p></item>
            </ulist>
            
            <p>The functions in this section are all specified by means of equivalent expressions that either call
            these primitives directly, or invoke other functions that rely on these primitives. The specifications
            avoid relying on XPath language constructs that manipulate maps, such as map constructor syntax, lookup
            expressions, or FLWOR expressions. This is done to allow these language constructs
            to be specified by reference to this function library, without risk of circularity.</p>
            
            <p>There is one exception to this rule: for convenience, the notation <code>{}</code> is used to represent
            an empty map, in preference to a call on <code>dm:empty-map()</code>.</p>
            
            <p>The formal equivalents are not intended to provide a realistic way of implementating the
            functions (in particular, any real implementation might be expected to implement <function>map:get</function>
            and <function>map:put</function> much more efficiently). They do, however, provide a framework that allows
            the correctness of a practical implementation to be verified.</p>
            
            <ednote><edtext>TODO: as yet there is no formal equivalent for <code>map:find()</code>.</edtext></ednote>
         </div2>
         
         <div2 id="map-functions">
            <head>Functions that Operate on Maps</head>
            
            <p>The functions defined in this section use a conventional namespace prefix <code>map</code>, which
               is assumed to be bound to the namespace URI <code>http://www.w3.org/2005/xpath-functions/map</code>.</p>
            
            
            
            
            <p>The function call <code>map:get($map, $key)</code> can be used to retrieve the value associated with a given key.</p>
            
            
            
            <p>There is no operation to atomize a map or convert it to a string. The function <function>fn:serialize</function> can in some cases
            be used to produce a JSON representation of a map.</p>
            
            
            
            <?local-function-index?>
            
            
            <div3 id="func-map-build" diff="add" at="A">
               <head><?function map:build?></head>
            </div3>
            <div3 id="func-map-contains">
               <head><?function map:contains?></head>
            </div3>
            <div3 id="func-map-empty">
               <head><?function map:empty?></head>
            </div3>
            <div3 id="func-map-entries" diff="add" at="2023-04-19">
               <head><?function map:entries?></head>
            </div3>
            <div3 id="func-map-entry">
               <head><?function map:entry?></head>
            </div3>
            <div3 id="func-map-filter" diff="add" at="A">
               <head><?function map:filter?></head>
            </div3>
            <div3 id="func-map-find">
               <head><?function map:find?></head>
            </div3>
            <div3 id="func-map-for-each">
               <head><?function map:for-each?></head>
            </div3>
            <div3 id="func-map-get">
               <head><?function map:get?></head>
            </div3>
            <div3 id="func-map-items" diff="add" at="2023-04-19">
               <head><?function map:items?></head>
            </div3>
            <div3 id="func-map-keys">
               <head><?function map:keys?></head>
            </div3>
            <div3 id="func-map-keys-where">
               <head><?function map:keys-where?></head>
            </div3>
            <div3 id="func-map-merge">
               <head><?function map:merge?></head>
            </div3>
            <div3 id="func-map-of-pairs" diff="add" at="2023-04-03">
               <head><?function map:of-pairs?></head>
            </div3>
            <div3 id="func-map-pair">
               <head><?function map:pair?></head>
            </div3>
            <div3 id="func-map-pairs" diff="add" at="2023-04-03">
               <head><?function map:pairs?></head>
            </div3>
            <div3 id="func-map-put">
               <head><?function map:put?></head>
            </div3>
            <div3 id="func-map-remove">
               <head><?function map:remove?></head>
            </div3>
            <div3 id="func-map-size">
               <head><?function map:size?></head>
            </div3>
            
            
         </div2>
         
         <div2 id="xml-to-json-mappings">
            <head>Converting Elements to Maps</head>
            <changes>
               <change issue="528">
                  A new function <function>fn:elements-to-maps</function> is provided for converting XDM trees
                  to maps suitable for serialization as JSON. Unlike the <function>fn:xml-to-json</function> function
                  retained from 3.1, this can handle arbitrary XML as input.
               </change>
            </changes>
            <p>The <function>fn:elements-to-maps</function> function converts XML element nodes to maps, in a form
               suitable for serialization as JSON. This section describes the mappings used by this function.</p>
            
            <p>This mapping is designed with three objectives:</p>
            <ulist>
               <item><p>It should be possible to represent any XML element as a map suitable for JSON serialization.</p></item>
               <item><p>The resulting JSON should be intuitive and easy to use.</p></item>
               <item><p>The JSON should be consistent and stable: small changes in the input should not result
               in large changes in the output.</p></item>
            </ulist>
            
            <p>Achieving all three objectives requires design compromises. It also requires sacrificing some other
            desiderata. In consequence:</p>
            <ulist>
               <item><p>The conversion is not lossless (see <specref ref="id-loss-of-xdm-information"/> for details).</p></item>
               <item><p>The conversion is not streamable.</p></item>
               <item><p>The results are not necessarily compatible with those produced by other popular libraries.</p></item>
            </ulist>
            
            <p>The requirement for consistency and stability is particularly challenging. An element such as 
            <code><![CDATA[<name>John</name>]]></code> maps naturally to the map <code>{ "name": "John" }</code>;
               but adding an attribute (so it becomes <code><![CDATA[<name role="first">John</name>]]></code>)
            then requires an incompatible change in the JSON representation. The format could be made extensible
            by converting <code><![CDATA[<name>John</name>]]></code> to <code>{ "name": {"#content":"John"} }</code>
               and <code><![CDATA[<name role="first">John</name>]]></code> to 
               <code>{ "name": { "@role":"first", "#content":"John" } }</code>,
               but this imposes unwanted complexity on the simplest cases. The solution adopted is threefold:</p>
            
            <ulist>
               <item><p>The function makes use of schema information where available, so it considers
               not just the structure of an individual element instance, but the rules governing the element type.</p></item>
               <item><p>It is possible to request <code>uniform</code> layout for all elements sharing the same name,
               so the decision is based on the structure of all elements with a given name, not just an individual
               element.</p></item>
               <item><p>It is possible to override the choice made by the system, and explicitly specify a layout
               to be used for elements having a given name.</p></item>
            </ulist>
            
            
            <div3 id="id-element-layouts">
               <head>Element Layouts</head>
           
            
               <p>The key challenge in mapping XML to JSON is in deciding how element content is to be represented. To 
                  illustrate the variety of mappings that are possible, the following table
               lists some examples of typical XML elements and their JSON equivalents:</p>
               
               <table role="data" >
                  <thead>
                     <tr>
                        <th>XML element</th>
                        <th>JSON equivalent</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td><eg><![CDATA[<hr/>]]></eg></td>
                        <td><eg><![CDATA["hr": ""]]></eg></td>
                     </tr>
                     <tr>
                        <td><eg><![CDATA[<date-of-birth>2023-05-18</date-of-birth>]]></eg></td>
                        <td><eg><![CDATA["date-of-birth": "2023-05-18"]]></eg></td>
                     </tr>
                     <tr>
                        <td><eg><![CDATA[<box width="5" height="10"/>]]></eg></td>
                        <td><eg><![CDATA["box": { "@width": "5", "@height": "10" }]]></eg></td>                    
                     </tr>
                     <tr>
                        <td><eg><![CDATA[<label id="t41">Warning!</label>]]></eg></td>
                        <td><eg><![CDATA["label": { "@id": "t41", "#content": "Warning!" }]]></eg></td>
                     </tr>
                     <tr>
                        <td><eg><![CDATA[<box>
    <width>5</width>
    <height>10</height>
</box>]]></eg></td>
                        <td><eg><![CDATA["box": {
    "width": 5, 
    "height": 10
}]]></eg></td>                    
                     </tr>
                     <tr>
                        <td><eg><![CDATA[<polygon>
    <point x="0" y="0"/>
    <point x="1" y="0"/>
    <point x="1" y="1"/>
    <point x="0" y="1"/>
</polygon>]]></eg></td>
                        <td><eg><![CDATA["polygon": [
    { "x": 0, "y": 0 }, 
    { "x": 1, "y": 0 }, 
    { "x": 1, "y": 1 }, 
    { "x": 0, "y": 1 }
]    ]]></eg></td>                    
                     </tr>
                  </tbody>
               </table>

               
             
               <p>This specification defines a
               number of named mappings, called <term>layouts</term>, and allows the layout for a particular
               element to be selected in four different ways:</p>
               
               <ulist>
                  <item><p>The layout to be used for a specific element name can be explicitly selected in the options
                  to the <function>fn:elements-to-maps</function> function.</p></item>
                  <item><p>In the absence of an explicit selection, if the data has been schema-validated, the layout is 
                     inferred from the content model for the element type as defined in the schema.</p></item>
                  <item>
                     <p>When the data is untyped and no specific layout has been selected, 
                     a default layout is chosen based on the properties of the individual element instance.</p>
                  </item>
                  <item>                    
                     <p>If the <code>uniform</code> option is set to <code>true</code>, then the same layout
                     will be used for all elements with a given name. This means that all elements need to be
                     examined before any element is converted.</p>
                  </item>              
               </ulist>
               
               <p>It is possible to disable some of the layouts so they will never be chosen by the automatic rules,
               but only when explicitly selected.</p>
               
               <p>The advantage of using schema information is that it gives a consistent representation for all
               elements of a particular type, even if they vary in content: for example if an element type allows optional
               attributes, the JSON representation will be consistent between those elements that have attributes and those
               without. In the absence of a schema, consistency can be achieved either by using the <code>uniform</code>
               option, or by selecting a layout explicitly in the <code>layouts</code> option.</p>
               
               <p>The different layouts available are defined in the following sections. For each layout
               there is a table showing:</p>
               
               <ulist>
                  <item><p><term>Layout name</term>: the name to be used to select this layout in
                  the <code>$options</code> parameter of the <function>fn:elements-to-maps</function> function.</p></item>
                  <item><p><term>Usage</term>: the situations for which this layout is designed.</p></item>
                  <item><p><term>Example input</term>: an example of a typical element for which this layout is appropriate,
                     shown as serialized XML.</p></item>
                  <item><p><term>Example output</term>: the result of converting this example, shown as serialized JSON. The 
                  result is always shown as a singleton map, which is how it will appear when the layout is used
                  for the top-level elements supplied in the <code>$elements</code> argument; when used to convert
                     a descendant element, the corresponding key-value pair may appear as part of a larger map, depending
                     on the layout chosen for its parent element..</p>
                  <note><p>The <function>fn:elements-to-maps</function> function produces maps as its result, but it is convenient
                  to illustrate the form of the map by showing the effect of serializing the map as JSON.</p></note></item>
                  
                  <item><p><term>Mapping rules</term>: The rules for mapping the XML element to an XDM map
                  representation.</p></item>
                  <item><p><term>Mapping for nilled elements</term>: special rules that apply to an
                  element having the attribute <code>xsi:nil="true"</code>. These rules only apply if the
                  element has been schema-validated.</p></item>
                  <item><p><term>Notes</term>: General observations, especially concerning what information is retained
                  by this mapping and what information is lost.</p></item>
               </ulist>
               
               <p>The rules for selecting the layout for a particular element are given later, 
                  in <specref ref="id-selecting-element-layout"/>.</p>
               
               <p>Note that it is possible to use any layout for any element. Use of an inappropriate layout
               may result in information being discarded; but in some cases, discarding information may be the 
               desired outcome.</p>
               
               <note><p>Acknowledgements for this categorization: see <bibref ref="Goessner"/>. Although
               Goessner's categories have been used, the actual mappings vary from his proposal.</p></note>
               
               
               <div4 id="id-empty-layout">
                  <head>Layout: Empty Content</head>
                  
                  <table role="data" >
                     <tbody>
                        <tr>
                           <th>Layout name</th>
                           <td><p><code>empty</code></p></td>
                        </tr>
                        <tr>
                           <th>Usage</th>
                           <td><p>Intended for XML elements that have no content and no attributes.</p></td>
                        </tr>
                        <tr>
                           <th>Example input</th>
                           <td><eg><![CDATA[<hr/>]]></eg></td>
                        </tr>
                        <tr>
                           <th>Example output</th>
                           <td><eg>{ "hr": "" }</eg></td>
                        </tr>
                        <!--<tr>
                           <th>XSD conditions</th>
                           <td><p>The element has a complex type with {variety} <code>empty</code>, 
                              or a simple type with
                              {variety} <code>list</code> and <code>maxLength="0"</code>, or a type 
                              derived from <code>xs:string</code>
                              with an <code>enumeration</code> or <code>length</code> or <code>maxLength</code>
                              facet that restricts it to be zero-length; and the type does not allow 
                              any attributes.</p></td>
                        </tr>
                        <tr>
                           <th>Match predicate</th>
                           <td><p><code>empty( * | text() | @* )</code></p></td>
                        </tr>-->
                        <tr>
                           <th>Mapping rules</th>
                           <td><p>The content is represented by the zero-length <code>xs:string</code>
                              value <code>""</code>.</p></td>
                        </tr>
                        <tr>
                           <th>Mapping for nilled elements</th>
                           <td><p>The content is represented by the QName 
                              <code>fn:QName("http://www.w3.org/2005/xpath-functions", "null")</code>, 
                              which the JSON serialization method serializes as
                              <code>null</code>. For example the result of converting the element
                              <code>&lt;hr xsi:nil="true"/></code> becomes 
                              <code>{ "hr": xs:QName("fn:null") }</code>, which is serialized in JSON
                               as <code>{ "hr": null }</code>.</p></td>
                        </tr>
                        <tr>
                           <th>Notes</th>
                           <td><p>If any child nodes or attributes are present, they are discarded. (This can happen
                           when this layout is explicitly selected for elements that are not actually empty.)</p></td>
                        </tr>
                     </tbody>
                  </table>
               </div4>
               <div4 id="id-empty-plus-layout">
                  <head>Layout: Empty Content with Attributes</head>
                  
                  <table role="data" >
                     <tbody>
                        <tr>
                           <th>Layout name</th>
                           <td><p><code>empty-plus</code></p></td>
                        </tr>
                        <tr>
                           <th>Usage</th>
                           <td><p>Intended for XML elements that have no content but may have attributes.</p></td>
                        </tr>
                        <tr>
                           <th>Example input</th>
                           <td><eg><![CDATA[<hr class="ccc" id="zzz"/>]]></eg></td>
                        </tr>
                        <tr>
                           <th>Example output</th>
                           <td><eg>{ "hr": { "@class": "ccc", "@id": "zzz" } }</eg></td>
                        </tr>
                        <!--<tr>
                           <th>XSD conditions</th>
                           <td><p>The element has a complex type with {variety} <code>empty</code>, or a simple type with
                              {variety} <code>list</code> and <code>maxLength="0"</code>, 
                              or a type derived from <code>xs:string</code>
                              with an <code>enumeration</code> or <code>length</code> or <code>maxLength</code>
                              facet that restricts it to be zero-length; 
                              and the type allows attributes to appear.</p></td>
                        </tr>
                        <tr>
                           <th>Match predicate</th>
                           <td><p><code>exists(@*) and empty(*|text())</code></p></td>
                        </tr>-->
                        <tr>
                           <th>Mapping rules</th>
                           <td><p>The content is represented by a map containing one entry for each
                              attribute in the XML element; if there are no attributes, the content
                              is represented as an empty map. 
                              The rules for attribute names are
                           defined in <specref ref="element-and-attribute-names"/>, and the
                              rules for attribute content in <specref ref="element-and-attribute-content"/>.</p></td>
                        </tr>
                        <tr>
                           <th>Mapping for nilled elements</th>
                           <td><p>An additional key-value pair <code>"#content": xs:QName("fn:null")</code> is added, which
                              serializes in JSON as <code>"#content": null</code>. For example
                              <code>&lt;hr id="x" xsi:nil="true"/></code> becomes 
                              <code>{ "hr": { "@id": "x", "#content": xs:QName("fn:null") } }</code>.</p></td>
                        </tr>
                        <tr>
                           <th>Notes</th>
                           <td><p>If any child nodes are present in the element, they are discarded.
                              (This can happen
                              when this layout is explicitly selected for elements that are not actually empty.)</p></td>
                        </tr>
                     </tbody>
                  </table>
               </div4>
               <div4 id="id-simple-layout">
                  <head>Layout: Simple Content</head>
                  
                  <table role="data" >
                     <tbody>
                        <tr>
                           <th>Layout name</th>
                           <td><p><code>simple</code></p></td>
                        </tr>
                        <tr>
                           <th>Usage</th>
                           <td><p>Intended for XML elements that have simple content and no attributes.</p></td>
                        </tr>
                        <tr>
                           <th>Example input</th>
                           <td><eg><![CDATA[<date>2023-05-30</date>]]></eg></td>
                        </tr>
                        <tr>
                           <th>Example output</th>
                           <td><eg>{ "date": "2023-05-30" }</eg></td>
                        </tr>
                        <!--<tr>
                           <th>XSD conditions</th>
                           <td><p>The element has a simple type.</p></td>
                        </tr>
                        <tr>
                           <th>Match predicate</th>
                           <td><p><code>empty( * | @* )</code></p></td>
                        </tr>-->
                        <tr>
                           <th>Mapping rules</th>
                           <td><p>The element is atomized and the resulting atomized value is handled
                              as described in <specref ref="element-and-attribute-content"/>.</p>
                              
                              <note>
                                 <p>If the element is untyped, the atomized value will always 
                                    appear in the result as an instance of <code>xs:untypedAtomic</code>.</p>
                              </note>
                          </td>
                        </tr>
                        <tr>
                           <th>Mapping for nilled elements</th>
                           <td><p>The content is represented by the value <code>xs:QName("fn:null")</code>, 
                              which is serialized as the JSON value <code>null</code>. For example.
                              <code>&lt;name xsi:nil="true"/></code> becomes <code>{ "name": xs:QName("fn:null") }</code>.</p></td>
                        </tr>
                        <tr>
                           <th>Notes</th>
                           <td><p>If any attributes are present, they are discarded. If the element has a type
                           annotation that is a complex type with element-only content, atomization will fail and
                           the string value is used in its place. In the case of mixed content, 
                           atomization produces essentially the same result as the string value, which
                           means that the internal structure is lost.</p>
                           <p>Comments and processing instructions in the content are discarded. Whitespace is
                           retained.</p></td>
                        </tr>
                     </tbody>
                  </table>
               </div4>
               <div4 id="id-simple-plus-layout">
                  <head>Layout: Simple Content with Attributes</head>
                  
                  <table role="data" >
                     <tbody>
                        <tr>
                           <th>Layout name</th>
                           <td><p><code>simple-plus</code></p></td>
                        </tr>
                        <tr>
                           <th>Usage</th>
                           <td><p>Intended for XML elements that have simple content and (optionally) attributes.</p></td>
                        </tr>
                        <tr>
                           <th>Example input</th>
                           <td><eg><![CDATA[<price currency="USD">23.50</date>]]></eg></td>
                        </tr>
                        <tr>
                           <th>Example output</th>
                           <td><eg>{ "price": { "@currency": "USD", "#content": 23.50 } }</eg></td>
                        </tr>
                        <!--<tr>
                           <th>XSD conditions</th>
                           <td><p>The element has a complex type with simple content.</p></td>
                        </tr>
                        <tr>
                           <th>Match predicate</th>
                           <td><p><code>empty(*)</code></p></td>
                        </tr>-->
                        <tr>
                           <th>Mapping rules</th>
                           <td><p>The element is represented by a map containing one entry for each
                              of its attributes, plus an entry with key <code>"#content"</code>
                              representing the result of atomizing the element. The atomized value is handled
                              as described in <specref ref="element-and-attribute-content"/>.</p>
                              <p>The rules for attribute names are
                           defined in <specref ref="element-and-attribute-names"/>, and the
                              rules for attribute content in <specref ref="element-and-attribute-content"/>.</p>
                              <note>
                                 <p>If the element is untyped, the value of each attribute, and of <code>"#content"</code>,
                                    will always be an instance of <code>xs:untypedAtomic</code>.</p>
                                 <p>If the element has been schema-validated, the types of the items in the atomized
                                    value are retained.</p>
                              </note>
                           </td>
                           
                        </tr>
                        <tr>
                           <th>Mapping for nilled elements</th>
                           <td><p>The <code>"#content"</code> property is represented by the value <code>xs:QName("fn:null")</code>, 
                              which is serialized in JSON as <code>null</code>.</p></td>
                        </tr>
                        <tr>
                           <th>Notes</th>
                           <td><p>In the case of mixed content, 
                           atomization produces essentially the same result as the string value, which
                           means that the internal structure is lost.</p>
                              <p>Comments and processing instructions in the content are discarded. Whitespace is
                                 retained.</p></td>
                        </tr>
                     </tbody>
                  </table>
               </div4>
               <div4 id="id-list-layout">
                  <head>Layout: Simple List</head>
                  
                  <table role="data" >
                     <tbody>
                        <tr>
                           <th>Layout name</th>
                           <td><p><code>list</code></p></td>
                        </tr>
                        <tr>
                           <th>Usage</th>
                           <td><p>Intended for XML elements that act as wrappers for a list of child elements,
                              all having the same element name. 
                              The name of the child elements is not retained in the output.</p></td>
                        </tr>
                        <tr>
                           <th>Example input (1)</th>
                           <td><eg><![CDATA[<dates>
  <date>2023-03-20</date>
  <date>2023-04-12</date>
  <date>2023-05-30</date>
</dates>]]></eg></td>
                        </tr>
                        <tr>
                           <th>Example output (1)</th>
                           <td><eg>{ "dates": [ "2023-03-20", "2023-04-12", "2023-05-30" ] }</eg></td>
                        </tr>
                        <tr>
                           <th>Example input (2)</th>
                           <td><eg><![CDATA[<dates>
  <date><year>2023</year><month>03</month><day>20</day></date>
  <date><year>2023</year><month>04</month><day>12</day></date>
  <date><year>2023</year><month>05</month><day>30</day></date>
</dates>]]></eg></td>
                        </tr>
                        <tr>
                           <th>Example output (2)</th>
                           <td><eg>{ "dates": [ 
    { "year": "2023", "month": "03", "day": "20" },
    { "year": "2023", "month": "04", "day": "12" },
    { "year": "2023", "month": "05", "day": "30" }
  ] }</eg></td>
                        </tr>
                        <!--<tr>
                           <th>XSD conditions</th>
                           <td><p>The element has a complex type with element-only content, containing a single
                              element particle, whose <code>maxOccurs</code> value is greater than one (including
                              <code>maxOccurs="unbounded"</code>); attributes are not allowed either on 
                              the outer element or on the inner elements.</p></td>
                        </tr>
                        <tr>
                           <th>Match predicate</th>
                           <td><p><code>count(*) gt 1 and all-equal(*!node-name()) and 
                              empty(text()[normalize-space()]) and empty(@*) and empty(*/@*)</code></p>
                           <p>That is, there are at least two child elements; all child elements have the same name; 
                           there are no text node children other than whitespace-only text nodes; and there
                           are no attributes either on the outer element or on the inner elements.</p></td>
                        </tr>-->
                        <tr>
                           <th>Mapping rules</th>
                           <td><p>If the element has element children with names that are not all equal, or
                              if it has non-whitespace text node children, then it is output
                              as if <code>mixed</code> layout were chosen (see <specref ref="id-mixed-layout"/>). 
                              This is fallback behavior for use
                              when this layout is chosen inappropriately.</p>
                              <p>In other cases, the content is represented by an array,
                                 whose members correspond one-to-one with the children of the element.
                                 Each child element is converted to a map as if it were a top-level element:
                                 the resulting map contains a single key-value pair. The key part is discarded,
                                 and the value part is used as a member in the resulting array.</p> 
                             
                              <p>If there are no children then the content is represented by an empty array.</p>
                              
                              </td>
                        </tr>
                        <tr>
                           <th>Mapping for nilled elements</th>
                           <td><p>The array is replaced by the value <code>xs:QName("fn:null")</code>, 
                              which serializes to the JSON value 
                              <code>null</code> (for example <code>{ "dates": xs:QName("fn:null") }</code>).</p></td>
                        </tr>
                        <tr>
                           <th>Notes</th>
                           <td><p>Comments and processing instructions in the content are discarded.</p></td>
                        </tr>
                     </tbody>
                  </table>
                  
                  <!--<example>
                     <head>Conversion of a list of elements with complex content</head>
                     <p>Consider the following XML:</p>
                     <eg><![CDATA[<items>
  <item nr="n1"><p>One</p></item>
  <item nr="n2"><p>Two</p></item>
</items>]]></eg>
                     <p>When this is converted using list layout and serialized as JSON, the result is:</p>
                     <eg><![CDATA[{"items":[
   {"@nr":"n1", "p":"One"},
   {"@nr":"n2", "p":"Two"}
]}   ]]></eg>
                  </example>-->
               </div4>
               <div4 id="id-list-plus-layout">
                  <head>Layout: List with Attributes</head>
                  
                  <table role="data">
                     <tbody>
                        <tr>
                           <th>Layout name</th>
                           <td><p><code>list-plus</code></p></td>
                        </tr>
                        <tr>
                           <th>Usage</th>
                           <td><p>Intended for XML elements that act as wrappers for a list of child elements,
                              all having the same element name. The wrapper element may have attributes,
                              and the name of the child elements is retained in the output.</p></td>
                        </tr>
                        <tr>
                           <th>Example input (1)</th>
                           <td><eg><![CDATA[<dates id="x">
  <date>2023-03-20</date>
  <date>2023-04-12</date>
  <date>2023-05-30</date>
</dates>]]></eg></td>
                        </tr>
                        <tr>
                           <th>Example output (1)</th>
                           <td><eg>"dates": { "@id": "x", "date": ["2023-03-20", "2023-04-12", "2023-05-30"]}</eg></td>
                        </tr>
                        <tr>
                           <th>Example input (2)</th>
                           <td><eg><![CDATA[<dates id="x">
  <date><year>2023</year><month>03</month><day>20</day></date>
  <date><year>2023</year><month>04</month><day>12</day></date>
  <date><year>2023</year><month>05</month><day>30</day></date>
</dates>]]></eg></td>
                        </tr>
                        <tr>
                           <th>Example output (2)</th>
                           <td><eg>{ "dates": {
   "@id": "x", 
   "date": [ 
    { "year": "2023", "month": "03", "day": "20" },
    { "year": "2023", "month": "04", "day": "12" },
    { "year": "2023", "month": "05", "day": "30" }
  ] } }</eg></td>
                        </tr>
                        <!--<tr>
                           <th>XSD conditions</th>
                           <td><p>The element has a complex type with element-only content, containing a single
                              element particle, whose <code>maxOccurs</code> value is greater than one (including
                              <code>maxOccurs="unbounded"</code>).</p></td>
                        </tr>
                        <tr>
                           <th>Match predicate</th>
                           <td><p><code>count(*) gt 1 and all-equal(*!node-name()) and empty(text()[normalize-space()])]</code></p>
                              <p>That is, there are at least two child elements; all child elements have the same name; and
                                 there are no text node children other than whitespace-only text nodes.</p></td>
                        </tr>-->
                        <tr>
                           <th>Mapping rules</th>
                           <td><p>If the element has element children with names that are not all equal, or
                              if it has non-whitespace text node children, then it is output
                              as if <code>mixed</code> layout were chosen (see <specref ref="id-mixed-layout"/>. 
                              This is fallback behavior for use
                              when this layout is chosen inappropriately.</p>
                              <p>In other cases,
                                 the content is represented by a map containing one entry for each
                                 attribute in the XML element, plus a property named after the 
                                 child elements (the <term>content property</term>), whose value is an array 
                                 containing the results of formatting the content in the same way as the 
                                 <code>list</code> layout.</p> 
                              
                              <p>If there are no children and the element is untyped (which can occur when 
                                 this layout is chosen explicitly via the options to <function>fn:elements-to-maps</function>)
                                 then the content property is omitted (since the child element name is unknown).
                                 But if the element is typed, then the content property is included and set to
                                 an empty array.</p>
                              
                           </td>
                        </tr>
                        <tr>
                           <th>Mapping for nilled elements</th>
                           <td><p>The array-valued entry in the result is replaced by the entry
                              <code>"#content": xs:QName("fn:null")</code>, 
                              which serializes to the JSON value <code>null</code>. 
                              For example the element <code><![CDATA[<dates id="x" xsi:nil="true"/>]]></code>
                              becomes <code>{"dates": { "@id": "x", "#content": xs:QName("fn:null") } }</code>.</p></td>
                        </tr>
                        <tr>
                           <th>Notes</th>
                           <td><p>Comments and processing instructions in the content are discarded.</p></td>
                        </tr>
                     </tbody>
                  </table>
 <!--                 <example>
                     <head>Conversion of a list of elements with complex content</head>
                     <p>Consider the following XML:</p>
                     <eg><![CDATA[<items format="bullets">
  <item nr="1"><p>One</p></item>
  <item nr="2"><p>Two</p></item>
</items>]]></eg>
                     <p>When this is converted using list layout, the result is:</p>
                     <eg><![CDATA["items": {"@format":"bullets", "item": [
   {"@nr":"1, "p":"One"},
   {"@nr":"2, "p":"Two"}
]   ]]></eg>
                  </example>-->
               </div4>
               <div4 id="id-record-layout">
                  <head>Layout: Record</head>
                  
                  <table role="data" >
                     <tbody>
                        <tr>
                           <th>Layout name</th>
                           <td><p><code>record</code></p></td>
                        </tr>
                        <tr>
                           <th>Usage</th>
                           <td><p>Intended primarily for XML elements that contain multiple child elements, with different
                              names, where the order of the child elements is not significant. Also used for elements
                              whose content is a single element node child.
                              The element may or may not have attributes.</p></td>
                        </tr>
                        <tr>
                           <th>Example input (1)</th>
                           <td><eg><![CDATA[<employee id="x">
  <date-of-birth>1984-03-20</date>
  <location>Germany</location>
  <position>Janitor</position>
</employee>]]></eg></td>
                        </tr>
                        <tr>
                           <th>Example output (1)</th>
                           <td><eg>
{ "employee": { "@id": "x", 
                "date-of-birth": "1984-03-20", 
                "location": "Germany", 
                "position": "Janitor"
              }
}</eg></td>
                        </tr>
                        <tr>
                           <th>Example input (2)</th>
                           <td><eg><![CDATA[<employee id="x">
  <date-of-birth>1984-03-20</date>
  <location>Germany</location>
  <position>Janitor</position>
  <position>Gardener</position>
</employee>]]></eg></td>
                        </tr>
                        <tr>
                           <th>Example output (2)</th>
                           <td><eg>
{ "employee": { "@id": "x", 
                "date-of-birth": "1984-03-20", 
                "location": "Germany", 
                "position": [ "Janitor", "Gardener" ]
              }
}</eg></td>
                        </tr>
                        <!--<tr>
                           <th>XSD conditions</th>
                           <td><p>The element has a complex type with element-only content, and either:</p>
                              <olist>
                                 <item><p>The content model contains
                                 a single term, whose compositor is <term>all</term> 
                                    (that is, the element is validated against a complex type 
                                    defined using <code>xs:all</code>); or</p></item>
                              <item><p>The content model allows at most one child element (it may allow a choice
                                 of child elements but must not allow multiple children).</p></item>
                              </olist>
                           </td>
                        </tr>
                        <tr>
                           <th>Match predicate</th>
                           <td><p><code>exists(*) and all-different(*!node-name()) and empty(text()[normalize-space()])]</code></p>
                              <p>That is, there is at least one child element; all child elements have different names; and
                                 there are no text node children other than whitespace-only text nodes.</p></td>
                        </tr>-->
                        <tr>
                           <th>Mapping rules</th>
                           <td><p>If the element has non-whitespace text node children, then it is output
                              as if <term>mixed</term> layout were chosen (see <specref ref="id-mixed-layout"/>). 
                              This is fallback behavior for use
                              when this layout is chosen inappropriately.</p>
                              <p>In other cases,
                                 the content is represented by a map containing one entry for each
                                 attribute in the XML element, plus one entry for each
                                 child element, whose value is formatted according to the rules for that element.</p>
                              
                              <p>If two or more child elements have the same name, or names that are represented by
                              the same string (taking into account the chosen <code>name-format</code> option),
                              then they are combined into a single entry containing all the corresponding values
                              as members of an array. For example, if there are two children 
                              <code><![CDATA[<author>Mills</author>]]></code> and <code><![CDATA[<author>Boon</author>]]></code>,
                              they are combined into a single entry <code>"author": ["Mills", "Boon"]</code>.</p>
                             
                              <p>The <xtermref spec="DM40" ref="dt-entry-order"/> of the resulting map
                                 first contains entries derived from attributes (in unpredictable order),
                                 then entries derived from child elements, in order of first appearance.</p>
                              
                              </td>
                        </tr>
                        <tr>
                           <th>Mapping for nilled elements</th>
                           <td><p>Alongside any attributes, the value includes the additional entry
                              <code>"#content": xs:QName("fn:null")</code>, which will be serialized 
                              in JSON as <code>"#content": null</code>.</p></td>
                        </tr>
                        <tr>
                           <th>Notes</th>
                           <td><p>Although this layout is intended primarily for elements whose children are unordered
                              and uniquely named, it is also viable to use it in cases where elements can repeat, so
                              long as order relative to other elements is not significant.</p>
                              <p>Comments and processing instructions in the content are discarded.</p></td>
                        </tr>
                     </tbody>
                  </table>
               </div4>
               <div4 id="id-sequence-layout">
                  <head>Layout: Sequence</head>
                  
                  <table role="data" >
                     <tbody>
                        <tr>
                           <th>layout name</th>
                           <td><p><code>sequence</code></p></td>
                        </tr>
                        <tr>
                           <th>Usage</th>
                           <td><p>Intended for XML elements that contain a sequence of element node children,
                              whose order is significant. 
                              The element may or may not have attributes.</p></td>
                        </tr>
                        <tr>
                           <th>Example input</th>
                           <td><eg><![CDATA[<section id="x">
   <head>Introduction</head>
   <p>Lorem ipsum.</p>
   <p>Dolor sit amet.</p>
</section>]]></eg></td>
                        </tr>
                        <tr>
                           <th>Example output</th>
                           <td><eg>{ "section": [
      { "@id": "x" },                        
      { "head": "Introduction" },
      { "p": "Lorem ipsum" },
      { "p": "Dolor sit amet" }
   ] }</eg></td>
                        </tr>
                        <!--<tr>
                           <th>XSD conditions</th>
                           <td><p>The element has a complex type with element-only content that does not meet
                              the criteria for the <code>list</code> or <code>record</code> layout.</p></td>
                        </tr>
                        <tr>
                           <th>Match predicate</th>
                           <td><p><code>empty(text()[normalize-space()])</code></p>
                           <p>That is, the element has no text node children other than whitespace nodes.</p></td>
                        </tr>-->
                        <tr>
                           <th>Mapping rules</th>
                           <td><p>The mapping rules are identical to the rules for the <code>mixed</code> layout (see 
                              <specref ref="id-mixed-layout"/>) except that whitespace-only text nodes
                              are discarded.</p>
                           </td>
                        </tr>
                        <tr>
                           <th>Mapping for nilled elements</th>
                           <td><p>A nilled element is indicated by including an additional map 
                              <code>{ "#content" : xs:QName("fn:null")}</code> in the array, after
                              any attributes.</p></td>
                        </tr>
                        <tr>
                           <th>Notes</th>
                           <td><p>Because whitespace text nodes are stripped, this layout should not normally be used
                              with mixed content.</p></td>
                        </tr>
                     </tbody>
                  </table>
               </div4>
               <div4 id="id-mixed-layout">
                  <head>Layout: Mixed</head>
                  
                  <table role="data" >
                     <tbody>
                        <tr>
                           <th>Layout name</th>
                           <td><p><code>mixed</code></p></td>
                        </tr>
                        <tr>
                           <th>Usage</th>
                           <td><p>Intended for XML elements that contain mixed content (that is, elements
                              that contain both child elements and child text nodes, intermingled). 
                              The element may or may not have attributes.</p></td>
                        </tr>
                        <tr>
                           <th>Example input</th>
                           <td><eg><![CDATA[<para id="x">This is a <i>fine</i> mess!</para>]]></eg></td>
                        </tr>
                        <tr>
                           <th>Example output</th>
                           <td><eg>{ "para": [
     { "@id": "x" },
     "This is a ",
     { "i": "fine" },
     "mess!"
   ] }</eg></td>
                        </tr>
                        <!--<tr>
                           <th>XSD conditions</th>
                           <td><p>The element has a complex type that does not satisfy the criteria for any other
                              layout to be used.</p></td>
                        </tr>
                        <tr>
                           <th>Match predicate</th>
                           <td><p><code>exists(*)</code></p></td>
                        </tr>-->
                        <tr>
                           <th>Mapping rules</th>
                           <td><p>The content is represented by an XDM array containing one entry for each
                                 attribute in the XML element, and one entry for each child node, 
                              in order. </p>
                              <p>Each attribute node is represented within this array by a single-entry
                              map: the rules for attribute names are
                           defined in <specref ref="element-and-attribute-names"/>, and the
                              rules for attribute content in <specref ref="element-and-attribute-content"/>.</p>
                              <p>Child nodes are represented within the array as follows:</p>
                              <ulist>
                                 <item><p>A text node child is represented as an atomic item of type 
                                    <code>xs:untypedAtomic</code>.</p></item>
                                 <item><p>An element node child is represented as a map containing a single
                                 entry, with the key representing the element name and the value representing the
                                 element's content, formatted according to the chosen layout for that element.</p></item>
                                 <item><p>A comment node is represented as a map containing a single
                                 entry whose key is the string <code>"#comment"</code>, and whose corresponding
                                 value is an atomic item of type <code>xs:string</code> containing the text of the comment.</p></item>
                                 <item><p>A processing instruction node is represented as a map containing 
                                    a single entry whose key is the string <code>"#processing-instruction"</code> 
                                    and whose value is a map with two entries: the first has the key <code>"#target"</code>
                                    with the value being the name of the processing instruction as an atomic item
                                    of type <code>xs:NCName</code>; the second has the key <code>"#data"</code> with
                                    the value being an atomic item of type <code>xs:string</code> containing the 
                                    string value of the processing instruction node.</p></item>
                              </ulist>
                              
                              <p>Whitespace text nodes are retained.</p>
                               
                            
                           </td>
                        </tr>
                        <tr>
                           <th>Mapping for nilled elements</th>
                           <td><p>A nilled element is indicated by including an additional map 
                              <code>{ "#content" : xs:QName("fn:null")}</code> in the array, after
                              any attributes.
                              For example, <code><![CDATA[<para id="p2" xsi:nil="true"/>]]></code>
                              becomes <code>{"para": [ { "id": "p2" }, { "#content": xs:QName("fn:null") } ] }</code>.
                           In JSON the value <code>xs:QName("fn:null")</code> 
                              is serialized as <code>null</code>.</p></td>
                        </tr>

                     </tbody>
                  </table>
               </div4>
               <div4 id="id-xml-layout">
                  <head>Layout: Serialized XML</head>
                  
                  <p>Serialized layout allows an element node to be represented as lexical XML, contained within a map.</p>
                  
                  <table role="data" >
                     <tbody>
                        <tr>
                           <th>Layout name</th>
                           <td><p><code>xml</code></p></td>
                        </tr>
                        <tr>
                           <th>Usage</th>
                           <td><p>This layout is useful when the input contains a mix of
                              structured data and marked-up textual content. It allows the
                              textual content to be output as serialized XML.</p></td>
                        </tr>
                        <tr>
                           <th>Example input</th>
                           <td><eg><![CDATA[<p>That was <i>awesome</i></p>]]></eg></td>
                        </tr>
                        <tr>
                           <th>Example output</th>
                           <td><eg><![CDATA[{ "p": "<p>That was <i>awesome</i></p>" }]]></eg></td>
                        </tr>
                        <!--<tr>
                           <th>XSD conditions</th>
                           <td><p>Not applicable. Serialized XML layout will only be used if 
                           explicitly selected in the options parameter.</p></td>
                        </tr>
                        <tr>
                           <th>Match predicate</th>
                           <td><p>Not applicable. Serialized XML layout will only be used if
                              explicitly selected in the options parameter.</p></td>
                        </tr>-->
                        <tr>
                           <th>Mapping rules</th>
                           <td><p>The element node is serialized as if by the <function>fn:serialize</function>
                              function, and the resulting content is output as an atomic item of type 
                              <code>xs:string</code>.</p>
                              <p>The serialization parameter <code>method</code> is set to
                              <code>"xml"</code>.</p>
                              <p>The serialization parameter <code>indent</code> is set to <code>false</code>.</p>
                              <p>The serialization parameter <code>omit-xml-declaration</code> is set
                                 to true.</p>
                              <p>Other serialization parameters take their default values.</p>
                              <note><p>The outermost element name will typically be repeated, for example
                              <code>"p": "&lt;p>Lorem ipsum&lt;/p>"</code>.</p></note>
                           </td>
                        </tr>
                        <tr>
                           <th>Mapping for nilled elements</th>
                           <td><p>A nilled element is represented using its normal XML serialization,
                              that is, the output serialization includes the attribute <code>xsi:nil="true"</code>,
                              together with a declaration of the <code>xsi</code> namespace prefix.</p></td>
                        </tr>
       
                     </tbody>
                  </table>
               </div4>
            </div3>
            
            
            
            <div3 id="id-selecting-element-layout">
               <head>Selecting an Element Layout</head>
               <p>The various layouts available for elements are described in <specref ref="id-element-layouts"/>.
               This section defines the rules for selecting an element layout for a given element <code>$E</code>.
               The rules are applied in order.</p>
               
               <olist>
                  <item><p>If an explicit layout is given for the element name of <code>$E</code> in the
                  options argument of the <function>fn:elements-to-maps</function> function call, then that layout is used.</p></item>
                  
                  <item><p>Let <code>$elements</code> be the value of the first argument to the
                  <function>fn:elements-to-maps</function> function call.</p></item>
                  
                  <item><p>A layout is said to be disabled if its name is listed in the <code>disable-layouts</code>
                  option.</p></item>
                  
                  <item><p>If the <code>uniform</code> option is true, then let <code>$EE</code> be
                  the set of all elements with the same name as <code>$E</code>, specifically
                  <code>$elements/descendant-or-self::*[node-name(.) eq node-name($E)]</code>.</p>
                  <p>If the <code>uniform</code> option is false, then let <code>$EE</code> be <code>$E</code>.</p></item>
                  
                  <item><p>Let <var>T</var> be the type identified by the type annotation of <code>$E</code>.</p></item>
                  
                  <item><p>If <var>T</var> is <code>xs:untyped</code> or <code>xs:anyType</code>, then:</p>
                     <olist>
                        <item>
                           <p>If <code>empty($EE/(* | text())</code> (that is, if there 
                              are no child elements or text nodes) then:</p>
                           <olist>
                              <item><p>If <code>empty($EE/@*)</code> (that is, if there 
                                 are no attributes) and if <code>empty</code> layout is not disabled,
                                 then <code>empty</code>: see <specref ref="id-empty-layout"/>.</p></item>
                              <item><p>Otherwise, if <code>empty-plus</code> layout is not disabled,
                                 then <code>empty-plus</code>: see <specref ref="id-empty-plus-layout"/>.</p></item>
                           </olist> 
                        </item>
                        <item>
                           <p>If <code>empty($EE/*)</code> (that is, if there are no child elements) then:</p>
                           <olist>
                              <item><p>If <code>empty($EE/@*)</code> (that is, if there 
                                 are no attributes), and if <code>simple</code> layout is not disabled,
                                 then <code>simple</code>: see <specref ref="id-simple-layout"/>.</p></item>
                              <item><p>Otherwise, if <code>simple-plus</code> layout is not disabled,
                                 then <code>simple-plus</code>: see <specref ref="id-simple-plus-layout"/>.</p></item>
                           </olist>
                        </item>
                        <item>
                           <p>If <code>empty($EE/text()[normalize-space()])</code> (that is, there are no text node
                           children other than whitespace), then:</p>
                           <olist>
                              <item>
                                 <p>If <code>all-equal($EE/*/node-name()) and exists($EE/*[2])</code>
                                 (that is, if all child elements have the same name, and at least one element has multiple child
                                 elements), then:</p>
                                 <olist>
                                    <item><p>If <code>empty($EE/@*)</code> (that is, if there 
                                       are no attributes), and if <code>list</code> layout is not disabled,
                                       then <code>list</code>: see <specref ref="id-list-layout"/>.</p></item>
                                    <item><p>Otherwise, if <code>list-plus</code> layout is not disabled,
                                       then <code>list-plus</code>: see <specref ref="id-list-plus-layout"/>.</p></item>
                                 </olist>
                              </item>
                              <item>
                                 <p>If <code>every $e in $EE satisfies all-different($e/*/node-name())</code>
                                 (that is, the child elements are uniquely named among their siblings),
                                 and if <code>record</code> layout is not disabled,
                                 then <code>record</code>: see <specref ref="id-record-layout"/>.</p>
                              </item>
                              <item>
                                 <p>Otherwise, if <code>sequence</code> layout is not disabled,
                                    then <code>sequence</code>: see <specref ref="id-sequence-layout"/>.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>Otherwise, <code>mixed</code>: see <specref ref="id-mixed-layout"/>.</p>
                        </item>
                     </olist>          
                  </item>
                  <item>
                     <p>Otherwise (for an element <code>$E</code> that is schema-validated with 
                        type annotation <var>T</var>):</p>
                     <note><p>This section uses the notation <code>{prop}</code> to refer to properties
                     of schema components, as defined in <bibref ref="xmlschema11-1"/>. The schema component model
                     from XSD 1.1 is used; when XSD 1.0 is used for validation, some properties
                     such as <code>{open content}</code> will inevitably be absent.</p></note>
                     <olist>
                        <item>
                           <p>Let <code>zeroLength(ST)</code> be true for a simple type <code>ST</code>
                           if any of the following conditions is true:</p>
                           <olist>
                              <item>
                                 <p><code>ST.{variety} = list</code>, and <code>ST.{facets}</code> includes
                                 a <code>length</code> or <code>maxLength</code> facet whose value is 0 (zero).</p>
                              </item>
                              <item>
                                 <p><code>ST.{variety} = atomic</code>, and <code>ST.{facets}</code> includes
                                 a <code>length</code> or <code>maxLength</code> facet whose value is 0 (zero).</p>
                              </item>
                              <item>
                                 <p><code>ST.{variety} = atomic</code>, and <code>ST.{facets}</code> includes
                                 an <code>enumeration</code> facet constraining the value to be zero-length.</p>
                              </item>
                              <item>
                                 <p><code>ST.{variety} = atomic</code>, and <code>ST.{facets}</code> includes
                                 a <code>pattern</code> facet with the value <code>""</code> (a zero-length string).</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>If <var>T</var> is a simple type:</p>
                           <olist>
                              <item>
                                 <p>If <code>zeroLength(T)</code>, and if <code>empty</code> layout is 
                                    not disabled, then <code>empty</code>: see <specref ref="id-empty-layout"/>.</p>
                              </item>
                              <item>
                                 <p>Otherwise, if <code>simple</code> layout is not disabled, then 
                                    <code>simple</code>: see <specref ref="id-simple-layout"/>.</p>
                              </item>
                              <item>
                                 <p>Otherwise, <code>mixed</code>: see <specref ref="id-mixed-layout"/>.</p>
                              </item>
                           </olist>
                        </item>
                        <item>
                           <p>Otherwise (if <var>T</var> is a complex type):</p>
                           <olist>
                              <item>
                                 <p>Let <code>$noAttributes</code> be true if 
                                 <code>T.{attribute uses}</code> is empty and <code>T.{attribute wildcard}</code>
                                 is absent.</p>
                              </item>
                              <item>
                                 <p>If <code>T.{content type}.{variety} = empty</code>, then:</p>
                                 <olist>
                                    <item><p>If <code>$noAttributes</code> and if <code>empty</code> layout is not disabled,
                                       then <code>empty</code>: see <specref ref="id-empty-layout"/>.</p></item>
                                    <item><p>Otherwise, if <code>empty-plus</code> layout is not disabled, 
                                       then <code>empty-plus</code>: see <specref ref="id-empty-plus-layout"/>.</p></item>
                                 </olist>
                              </item>
                              <item>
                                 <p>If <code>T.{content type}.{variety} = simple</code> 
                                    (a complex type with simple content), then:</p>
                                 <olist>
                                    <item><p>Let <code>ST</code> be <code>T.{content type}.{simple type definition}</code>
                                    (the corresponding simple type).</p>
                                    </item>
                                    <item>
                                       <p>If <code>zeroLength(ST)</code>, then:</p>
                                       <olist>
                                          <item><p>If <code>$noAttributes</code> and if <code>empty</code> layout is 
                                             not disabled, then <code>empty</code>: see <specref ref="id-empty-layout"/>.</p></item>
                                          <item><p>Otherwise, if <code>empty-plus</code> layout is not disabled,
                                             then <code>empty-plus</code>: see <specref ref="id-empty-plus-layout"/>.</p></item>
                                       </olist>
                                    </item>
                                    <item>
                                       <p>Otherwise:</p>
                                       <olist>
                                          <item><p>If <code>$noAttributes</code> and if <code>simple</code> layout 
                                             is not disabled, then <code>simple</code>: see <specref ref="id-simple-layout"/>.</p></item>
                                          <item><p>Otherwise, if <code>simple-plus</code> layout is not disabled,
                                             then <code>simple-plus</code>: see <specref ref="id-simple-plus-layout"/>.</p></item>
                                       </olist>
                                    </item>
                                 </olist>
                              </item>
                              <item>
                                 <p>If <code>T.{content type}.{variety} = element-only</code> (a complex type with
                                 an element-only content model):</p>
                                 <olist>
                                    <item><p>Let <code>$noWildcards</code> be true if <code>T.{content type}.{open content}</code>
                                    is absent, and <code>T.{content type}.{particle}</code>, expanded recursively, contains
                                    no wildcard term.</p></item>
                                    <item><p>Let <code>$childCardinalities</code> be a set of (<code>xs:QName</code>, 
                                       <code>xs:double</code>) pairs
                                    representing the expanded names of the element declaration terms within 
                                       <code>T.{content type}.{particle}</code>,
                                    expanded recursively, and for each one, the maximum number of occurrences of elements
                                    with that name, computed
                                    using the value of the <code>{maxOccurs}</code> property of the particles at each level, taking the value
                                    <code>unbounded</code> as positive infinity.</p></item>
                                    <item>
                                       <p>If <code>$noWildcards</code> is true, and if <code>$childCardinalities</code>
                                          contains a single entry, and that entry has a cardinality greater than one, then:</p>
                                       <olist>
                                          <item><p>If <code>$noAttributes</code>, and if <code>list</code> layout 
                                             is not disabled, then <code>list</code>: see <specref ref="id-list-layout"/>.</p></item>
                                          <item><p>Otherwise, if <code>list-plus</code> layout is not disabled, 
                                             then <code>list-plus</code>: see <specref ref="id-list-plus-layout"/>.</p></item>
                                       </olist>
                                    </item>
                                    <item>
                                       <p>If <code>$noWildcards</code> is true, and if every entry in <code>$childCardinalities</code>
                                          has a cardinality of one, and if <code>record</code> layout is not disabled,
                                          then <code>record</code>: see <specref ref="id-record-layout"/>.</p>
                                    </item>
                                    <item>
                                       <p>Otherwise, if <code>sequence</code> layout is not disabled,
                                          then <code>sequence</code>: see <specref ref="id-sequence-layout"/>.</p>
                                    </item>
                                 </olist>
                              </item>
                              <item>
                                 <p>Otherwise (that is, when <code>T.{content type}.{variety} = mixed</code>, or when all other
                                    applicable layouts have been disabled), then <code>mixed</code>: see <specref ref="id-mixed-layout"/>.</p>
                              </item>
                           </olist>
                        </item>
                     </olist>
                  </item>
               </olist>
            </div3>
            
             <div3 id="element-and-attribute-names">
               <head>Element and Attribute Names</head>
               
               <p>The <code>name-format</code> option gives control over how element and attribute names are formatted.
                  There are four options:</p>
               
               <ulist>
                  <item><p>The default option (which may be explicitly requested by specifying <code>"name-format": "default"</code>)
                  retains the namespace URI for any element that is either (a) the top-level element of a tree being
                  converted, or (b) has a name that is in a different namespace from its parent element. In such cases
                  the format <code>"Q{uri}local"</code> is used. For other elements, the name is output using the
                  local part of the element name alone. For attributes, the form <code>"Q{uri}local"</code> is used
                  for an attribute in a namespace, and the local name alone is used for a no-namespace name.
                  Namespace prefixes are not retained.</p></item>
                  <item><p>The option <code>eqname</code> uses the format <code>"Q{uri}local"</code> for all
                  element and attribute names that are in a namespace, or the local name alone for all names 
                  that are not in a namespace.</p></item>
                  <item><p>The option <code>local</code> discards all namespace information: all elements and attributes
                  are output using the local name alone.</p></item>
                  <item><p>The option <code>lexical</code> outputs element and attribute names in the form 
                     obtained by calling the function <function>fn:name</function>. If the name has a prefix,
                  the prefix is retained in the output. However, the output contains no information that enables the
                  prefix to be associated with a namespace URI, so this format is suitable only when prefixes 
                  in the input documents are used predictably.</p></item>
               </ulist>
              
               
               <p>Attribute names in the output are typically prefixed with the character <code>"@"</code>.
                  The option <code>attribute-marker</code> allows this to be changed to a different
                  prefix or none.</p>
               
               <p>Whichever format of names is chosen, if the rules for the selected layout would result in an output
               map having two entries with the same key, the conflict is resolved by combining these
               entries into an array. For example if <code>name-format</code> is set to <code>local</code>
               then the element <code><![CDATA[<data x:val="3" y:val="4"/>]]></code> becomes either
               <code>{ "data": { "@val": ["3", "4"] } }</code> or (because attribute order is unpredictable)
               <code>{ "data": { "@val": ["4", "3"] } }</code>.</p>
               
               <p>Regardless of the chosen <code>name-format</code>, and regardless of the above rules:</p>
               
               <ulist>
                  <item><p>Attributes in the <code>xsi</code> namespace (<code>http://www.w3.org/2001/XMLSchema-instance</code>)
                     are discarded.</p>
                     <note><p>This is because these attributes can appear even when the schema does not allow the element
                     to have attributes, which means that a layout might be chosen that does not accommodate attributes.</p></note>
                  </item>
                  <item><p>Attributes in the <code>xml</code> namespace (<code>http://www.w3.org/XML/1998/namespace</code>)
                  are output using a lexical QName, with the prefix <code>xml</code>.</p></item>
               </ulist>
               
               
  
            </div3>  
               
               
            
            <div3 id="element-and-attribute-content">
               <head>Element and Attribute Content</head>
               <p>If an input node is untyped, the atomized content of elements, attributes,
               and text nodes is always of type <code>xs:untypedAtomic</code>, and it is represented
               as such in the corresponding map entries in the result.</p>
               <p>Where the content is schema-validated, however:</p>
               <olist>
                  <item><p>Let <var>AV</var> be the typed value of the node (that is, the result
                  of atomization).</p></item>
                  <item><p>If, however, an element is annotated with a type that does not allow atomization
                  (specifically, a complex type with element-only content) then let <var>AV</var> be the string value
                  of the element, as an atomic item of type <code>xs:untypedAtomic</code>.</p></item>
                  <item><p>If an attribute is annotated as having a simple type of {variety} <code>list</code>,
                     or if an element using layout <code>simple</code> or <code>simple-plus</code>
                     is annotated as having either a simple type of {variety} <code>list</code>
                     or a complex type with simple content of {variety} <code>list</code>
                  then the atomized value <var>AV</var> is represented in the result as the array
                     represented by the XPath expression <code>array{<var>AV</var>}</code>. This applies whether or not the
                  atomized value actually contains multiple atomic items. The individual atomic items in the array retain their type,
                  for example items of type <code>xs:date</code> remain items of type <code>xs:date</code>
                  in the result.</p></item>
                  <item><p>In all other cases <var>AV</var> will be a single atomic item, and this value
                     is used <emph>as is</emph>, retaining its type.</p></item>
                  
               </olist>
               
               <note><p>Atomic items in the result of the <function>fn:elements-to-maps</function> function
                  may be of any atomic type. The type information is lost if the result is 
                  subsequently serialized as JSON.</p></note>
            </div3>
            
            <div3 id="id-loss-of-xdm-information">
               <head>Lost XDM Information</head>
               
               <p>This section is non-normative. Its purpose is to explain what information available
               in the XDM nodes supplied as input to the <function>fn:elements-to-maps</function> function
               is missing from the output.</p>
               
               <ulist>
                  <item><p><emph>Element and attribute names: </emph> If the chosen 
                  <code>name-format</code> is <code>default</code> or <code>eqname</code>,
                  then local names and namespace URIs of elements and attributes are retained,
                  but namespace prefixes are lost. If the chosen <code>name-format</code> is
                  <code>lexical</code>, then prefixes are retained but namespace URIs are lost.
                  If the chosen <code>name-format</code> is <code>local</code> then only
                  local names are retained; namespace URIs and prefixes are lost.</p>
                  
                  <p>In addition, element names are lost when the parent element is mapped
                  using <code>list</code> layout: see <specref ref="id-list-layout"/>.</p></item>
                  
                  <item><p><emph>In-scope namespaces: </emph> All information about in-scope namespaces
                  (and in particular, bindings for namespaces that are declared but not used in element
                  and attribute names) is lost.</p></item>
                  
                  <item><p><emph>The <code>xsi</code> namespace: </emph> All attributes in the <code>xsi</code>
                     namespace (<code>http://www.w3.org/2001/XMLSchema-instance</code>) are lost,
                  except when <code>xml</code> layout is selected.</p></item>
                  
                  <item><p><emph>Comments and processing instructions: </emph> Comments and processing instructions
                     are lost except when they appear as children of elements that are mapped using the
                     <code>mixed</code> or <code>xml</code> layouts.</p></item>
                  
                  <item><p><emph>Text nodes: </emph> Text nodes, both whitespace and non-whitespace,
                  are lost except when they appear as children of elements that are mapped using the
                     <code>simple</code>, <code>simple-plus</code>, <code>mixed</code>, or 
                     <code>xml</code> layouts, or when they appear as grandchildren of elements that are
                  mapped using the <code>list</code> or <code>list-plus</code> layouts.</p></item>
                  
                  <item><p><emph>Additional node properties: </emph> The values of the <code>is-id</code>,
                     <code>is-idref</code>, and <code>is-nilled</code> properties of a node are lost.</p></item>
                  
                  <item><p><emph>Type annotations: </emph> The values of type annotations on elements are lost.
                  Type annotations on atomized values of nodes, however, are retained.</p></item>
                  
                  <item><p><emph>Element and attribute nodes: </emph> The entire content of element and attribute nodes
                     is lost if their parent element is mapped using a layout unsuited to that kind of content,
                     for example if the layout <code>empty</code> or <code>simple</code> is selected for an element that
                     has attributes or element children.</p></item>
                  
                  <item><p><emph>Element order: </emph> The order of child elements is lost when
                  <code>record</code> layout is used.</p></item>
               </ulist>
            </div3>
            
            
            <div3 id="id-elements-to-maps-examples">
               <head>Examples</head>
               <p>The following examples show the effect of transforming some simple XML documents with default options,
               and then serializing the result as JSON with <code>indent</code> is set to <code>true</code>. 
                  The actual indentation is implementation dependent.</p>
               
               <table class="data">
                  <thead>
                     <tr>
                        <th>XDM element</th>
                        <th>JSON serialization of result</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td><eg><![CDATA[<a x='1' b='2'/>]]></eg></td>
                        <td><eg><![CDATA[{ "a":{
    "@x": "1",
    "@b": "2"
  } }]]></eg></td>
                     </tr>
                     <tr>
                        <td><eg><![CDATA[<a><x>1</x><y>2</y></a>]]></eg></td>
                        <td><eg><![CDATA[{ "a":{
    "x": "1",
    "y": "2"
  } }]]></eg></td>
                     </tr>
                     <tr>
                        <td><eg><![CDATA[<polygon> 
   <point x='0' y='0'/> 
   <point x='0' y='1'/> 
   <point x='1' y='1'/> 
   <point x='1' y='0'/>
</polygon>]]></eg></td>
                        <td><eg><![CDATA[{ "polygon":[
       {"@x": "0", "@y": "0"},
       {"@x": "0", "@y": "1"},
       {"@x": "1", "@y": "1"},
       {"@x": "1", "@y": "0"}
  ] ] }]]></eg></td>
                     </tr>
                     <tr>
                        <td><eg><![CDATA[<cities>
   <city id="LDN">
      <name>London</name>
      <size>18.2</size>
   </city>
   <city id="PRS">
      <name>Paris</name>
      <size>19.1</size>
   </city>
   <city id="BLN">
      <name>Berlin</name>
      <size>14.6</size>
   </city>
</cities>]]></eg></td>
                        <td><eg><![CDATA[{ "cities":[
    {
      "@id": "LDN",
      "name": "London",
      "size": "18.2"
    },
    {
      "@id": "PRS",
      "name": "Paris",
      "size": "19.1"
    },
    {
      "@id": "BLN",
      "name": "Berlin",
      "size": "14.6"
    }
  ] }]]></eg></td>
                     </tr>
                     <!--<tr>
                        <td><eg><![CDATA[]]></eg></td>
                        <td><eg><![CDATA[]]></eg></td>
                     </tr>
                     <tr>
                        <td><eg><![CDATA[]]></eg></td>
                        <td><eg><![CDATA[]]></eg></td>
                     </tr>
                     <tr>
                        <td><eg><![CDATA[]]></eg></td>
                        <td><eg><![CDATA[]]></eg></td>
                     </tr>-->
                  </tbody>
               </table>
               <p>The following more complex example demonstrates a case where the default conversion is
               inadequate (for example, it wrongly assumes that for the third production, the order of child
               elements is immaterial). A better result, shown below, can be achieved by
               using a schema-aware conversion.</p>
               <table class="data">
                  <thead>
                     <tr>
                        <th>XDM element</th>
                        <th>JSON serialization of result</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td><eg><![CDATA[<g:grammar language="xquery"
     xmlns:g="http://www.w3.org/XPath/grammar">
   <g:production name="FunctionBody">
      <g:ref name="EnclosedExpr"/>
      <g:ref name="Block"/>
   </g:production>
   
   <g:production name="EnclosedExpr">
      <g:ref name="Lbrace"/>
      <g:ref name="Expr"/>
      <g:optional>
         <g:ref name="Expr"/>
      </g:optional>
      <g:ref name="Rbrace"/>
   </g:production>
   
   <g:production name="SimpleReturnClause">
      <g:string>return</g:string>
      <g:ref name="ExprSingle"/>
   </g:production>
</g:grammar>]]></eg></td>
                        <td><eg><![CDATA[[{ "Q{http://www.w3.org/XPath/grammar}grammar":[
    { "@language":"xquery" },
    { "production":[
        { "@name":"FunctionBody" },
        { "ref":{"@name": "EnclosedExpr"} },
        { "ref":{"@name": "Block"} }
      ] },
    { "production":[
        { "@name":"EnclosedExpr" },
        { "ref":{"@name": "Lbrace"} },
        { "ref":{"@name": "Expr"} },
        { "optional":[
            { "ref":{"@name": "Expr"} }
          ] },
        { "ref":{"@name": "Rbrace"} }
      ] },
    { "production":[
        { "@name":"SimpleReturnClause" },
        { "string":"return" },
        { "ref":{"@name": "ExprSingle"} }
      ] }
  ] }]]]></eg></td>
                     </tr>
                  </tbody>
               </table>
               <note><p>In the above example, the schema used to validate the source document was simplified to eliminate
               options that do not actually arise in this input instance (such as the <code>g:string</code>
               element having attributes). This is a legitimate technique that may be useful when trying to obtain 
               the simplest possible JSON representation.</p>
               <p>Further improvements to the usability of the JSON output could be achieved by doing some
               simple transformation of the XML prior to conversion. For example, the <code>name</code>
               attribute of various productions could be converted to a child element, and 
                  <code>&lt;ref name="x"/&gt;</code> could be transformed to <code>&lt;ref&gt;x&lt;/ref&gt;</code>.</p></note>
            </div3>
            
            <!--<?local-function-index?>-->
            
            <div3 id="func-elements-to-maps">
               <head><?function fn:elements-to-maps?></head>
            </div3>
         </div2>
         
 
         <div2 id="map-operations">
            <head>Other Operations on Maps </head>
            
            <p><emph>This section is non-normative.</emph></p>

            <p>Because a map is a function item, functions that apply to functions also apply
               to maps. A map is an anonymous function, so <function>fn:function-name</function> returns the empty
               sequence; <function>fn:function-arity</function> always returns <code>1</code>.</p>
            
            <p>Maps may be compared using the <function>fn:deep-equal</function> function.</p>
            
            <p>There is no function or operator to atomize a map or convert it to a string (other than <function>fn:serialize</function>,
               which can be used to serialize some maps as JSON texts).</p>
            
            <p>XPath 4.0 defines a number of syntactic constructs that operate on maps. These all have equivalents
            in the function library:</p>
            
            <ulist>
               <item><p>The expression <code>{}</code> creates an empty map 
                  (see <xspecref spec="XP40" ref="id-map-constructors"/>). This is equivalent to the
               effect of the data model primitive <code>dm:empty-map()</code>. Using user-visible functions
               the same can be achieved by calling <function>map:build</function>, <function>map:of-pairs</function>, 
               or <function>map:merge</function>, supplying an empty sequence as the argument.</p></item>
               <item><p>The map constructor <code>{ <var>K1</var> : <var>V1</var>, <var>K2</var> : <var>V2</var>, 
                  ... , <var>K/n</var> : <var>V/n</var> }</code> is equivalent to 
                  <code>map:merge((map:entry(<var>K1</var>, <var>V1</var>), map:entry(<var>K1</var>, <var>V1</var>), ..., map:entry(<var>K/n</var>, <var>V/n</var>)), {"duplicates":"reject"})</code></p></item>
               <item><p>The lookup expression <code>$map?*</code> 
                  (see <xspecref spec="XP40" ref="id-lookup"/>) is equivalent to <code>map:items($map)</code>.</p></item>
               <item><p>The lookup expression <code>$map?K</code>, where <var>K</var> is a key value, is equivalent to
               <code>map:get($map, <var>K</var>)</code></p></item>
               <item><p>The expression <code>for key $k value $v in $map return <var>EXPR</var></code> 
                  (see <xspecref spec="XQ40" ref="id-xquery-for-clause"/> and 
                  <xspecref spec="XP40" ref="id-for-expressions"/>) 
                  is equivalent to the function
               call <code>map:for-each($map, fn($k, $v) { <var>EXPR</var> })</code>.</p></item>
               <item><p>Maps can be filtered using the construct <code>$map?[<var>predicate</var>]</code>
               (see <xspecref spec="XP40" ref="id-filter-maps-and-arrays"/>).</p></item>

            </ulist>
            
         </div2>
      </div1>
      <div1 id="arrays">
         <head>Processing arrays</head>
         
         <p>Arrays were introduced as a new datatype in XDM 3.1. This section describes functions that
            operate on arrays.</p>
         
         <p>An array is an additional kind of item. An array of size <var>N</var> is a mapping from the integers
            (1 to <var>N</var>) to a set of values, called the members of the array, each of which is an arbitrary
            sequence. Because an array is an item, and therefore a sequence, arrays can be nested.</p>
         
         <p>An array acts as a function from integer positions to associated values, so the
            function call <code>$array($index)</code> can be used to retrieve the array member at a given position.
            The function corresponding to the array has the signature 
            <code>function($index as xs:integer) as item()*</code>. 
            The fact that an array is a function item allows it to be passed as an argument to higher-order functions 
            that expect a function item as one of their arguments.</p>
         
         <div2 id="formal-specification-of-arrays">
            <head>Formal Specification of Arrays</head>
            <p>The XDM data model (<bibref ref="xpath-datamodel-40"/>) defines three primitive operations on arrays:</p>
            <ulist>
               <item><p><code>dm:empty-array</code> constructs an empty array.</p></item>
               <item><p><code>dm:array-append</code> adds a member to an array.</p></item>
               <item><p><code>dm:iterate-array</code> applies a supplied function to every member of an array, in order.</p></item>
            </ulist>
            
            <p>The functions in this section are all specified by means of equivalent expressions that either call
            these primitives directly, or invoke other functions that rely on these primitives. The specifications
            avoid relying on XPath language constructs that manipulate arrays, such as array constructor syntax, lookup
            expressions, or FLWOR expressions. This is done to allow these language constructs
            to be specified by reference to this function library, without risk of circularity.</p>
            
            <p>There is one exception to this rule: for convenience, the notation <code>[]</code> is used to represent
            an empty array, in preference to a call on <code>dm:empty-array()</code>.</p>
            
            <p>The formal equivalents are not intended to provide a realistic way of implementating the
            functions. They do, however, provide a framework that allows
            the correctness of a practical implementation to be verified.</p>
            
            
         </div2>
         
         
         <div2 id="array-functions">
            <head>Functions that Operate on Arrays</head>
            
            
            <p>The functions defined in this section use a conventional namespace prefix <code>array</code>, which
               is assumed to be bound to the namespace URI <code>http://www.w3.org/2005/xpath-functions/array</code>.</p>   
            
            <p>As with all other values, arrays are treated as immutable. 
               For example, the <function>array:reverse</function> function returns an array that differs from the supplied
               array in the order of its members, but the supplied array is not changed by the operation. Two calls
               on <function>array:reverse</function> with the same argument will return arrays that are indistinguishable from
               each other; there is no way of asking whether these are “the same array”. Like sequences, arrays have no identity. </p>
            
            
            
            <p diff="chg" at="2023-02-20">All functionality on arrays is defined in terms of two primitives:</p>
            
            <ulist diff="chg" at="2023-02-20">
               <item><p>The function <function>array:members</function> decomposes an array to a sequence of 
                  <term>value records</term>.</p></item>
               <item><p>The function <function>array:of-members</function> composes an array from a sequence of 
               <term>value records</term>.</p></item>
            </ulist>
            
            <p diff="chg" at="2023-02-20">A <term>value record</term> here is an item that encapsulates an arbitrary value; the representation
            chosen for a value record is <code>record(value as item()*)</code>, that is, a map containing a single
            entry whose key is the string <code>"value"</code> and whose value is the encapsulated sequence.</p>
 
            
     
            
            <?local-function-index?>
            
            <div3 id="func-array-append">
               <head><?function array:append?></head>
            </div3>
            <div3 id="func-array-build" diff="chg" at="2023-02-20">
               <head><?function array:build?></head>
            </div3>
            <div3 id="func-array-empty" diff="add" at="2022-12-06">
               <head><?function array:empty?></head>
            </div3>
            <div3 id="func-array-filter">
               <head><?function array:filter?></head>
            </div3>
            <div3 id="func-array-flatten">
               <head><?function array:flatten?></head>
            </div3>
            <div3 id="func-array-fold-left">
               <head><?function array:fold-left?></head>
            </div3>
            <div3 id="func-array-fold-right">
               <head><?function array:fold-right?></head>
            </div3>
            <div3 id="func-array-foot" diff="add" at="2022-11-16">
               <head><?function array:foot?></head>
            </div3>
            <div3 id="func-array-for-each">
               <head><?function array:for-each?></head>
            </div3>
            <div3 id="func-array-for-each-pair">
               <head><?function array:for-each-pair?></head>
            </div3>
            <div3 id="func-array-get">
               <head><?function array:get?></head>
            </div3>
            <div3 id="func-array-head">
               <head><?function array:head?></head>
            </div3>
            <div3 id="func-array-index-of">
               <head><?function array:index-of?></head>
            </div3>
            <div3 id="func-array-index-where" diff="add" at="2022-11-17">
               <head><?function array:index-where?></head>
            </div3>
            <div3 id="func-array-insert-before">
               <head><?function array:insert-before?></head>
            </div3>
            <div3 id="func-array-items" diff="add" at="2023-05-07">
               <head><?function array:items?></head>
            </div3>
            <div3 id="func-array-join">
               <head><?function array:join?></head>
            </div3>
            <div3 id="func-array-members" diff="add" at="2023-02-20">
               <head><?function array:members?></head>
            </div3>
            <div3 id="func-array-of-members" diff="add" at="2023-02-20">
               <head><?function array:of-members?></head>
            </div3>
            <div3 id="func-array-put">
               <head><?function array:put?></head>
            </div3>
            <div3 id="func-array-remove">
               <head><?function array:remove?></head>
            </div3>
            <div3 id="func-array-reverse">
               <head><?function array:reverse?></head>
            </div3>
            <div3 id="func-array-size">
               <head><?function array:size?></head>
            </div3>
            <div3 id="func-array-slice" diff="add" at="A">
               <head><?function array:slice?></head>
            </div3>
            <div3 id="func-array-sort">
               <head><?function array:sort?></head>
            </div3>
            <div3 id="func-array-split">
               <head><?function array:split?></head>
            </div3>
            <div3 id="func-array-subarray">
               <head><?function array:subarray?></head>
            </div3> 
            <div3 id="func-array-tail">
               <head><?function array:tail?></head>
            </div3>
            <div3 id="func-array-trunk" diff="add" at="2022-11-16">
               <head><?function array:trunk?></head>
            </div3>
         </div2> 
         <div2 id="additional-array-operations" diff="add" at="2023-02-20">
            <head>Other Operations on Arrays</head>
            <p><emph>This section is non-normative.</emph></p>
            
            <p>Arrays may be compared using the <function>fn:deep-equal</function> function.</p>
            
            <p>The XPath language provides explicit syntax for certain operations on arrays.
               These constructs can all be specified in terms of function primitives:</p>
            

            <ulist>
              <item><p>An empty array can be constructed using either of the expressions
              <code>[]</code> or <code>array{}</code>. The effect is the same as the data model primitive
              <code>dm:empty-array(())</code> (see <xspecref spec="XP40" ref="id-array-constructors"/>). 
                 Using user-visible functions it can be achieved
              by calling <code>array:build(())</code> or <code>array:of-members(())</code>.</p></item>
              <item><p>The expression <code>array { $sequence }</code> constructs an array whose members
                 are the items in <code>$sequence</code>. Every member of this array will
                 be a singleton item. The effect is the same as
                 <code>array:build($sequence)</code>.</p></item>
              <item><p>The expression <code>[<var>E1</var>, <var>E2</var>, <var>E3</var>, ..., <var>E/n</var>]</code> constructs an array in which
                 <code>E1</code> is the first member, <code>E2</code> is the second member,
                 and so on. The result is equivalent to the expression
                 <code>[] => array:append(<var>E1</var>) => array:append(<var>E2</var>) => ... => array:append(<var>E/n</var>))). </code></p></item>
              <item><p>The lookup expression <code>$array?*</code> returns the
                 <xtermref spec="XP40" ref="dt-sequence-concatenation">sequence concatenation</xtermref>
                 of the members of the array. It is equivalent to calling 
                 <code>array:fold-left($array, (), fn($result, $next){ $result, $next })</code>.</p></item>
              <item><p>The lookup expression <code>$array?$N</code>, where <code>$N</code>
                 is an integer within the bounds of the array, is equivalent to 
                 <code>array:get($array, $N)</code>.</p></item>
              <item><p>Similarly, applying the array as a function, <code>$array($N)</code>,
                 is also equivalent to <code>array:get($array, [$N])</code></p></item>
               <item><p>The expression <code>for member $m in $array return <var>EXPR</var></code>
               is equivalent to <code>array:for-each($array, fn($m){ <var>EXPR</var> })</code>
                  (see <xspecref spec="XQ40" ref="id-xquery-for-clause"/> and 
                  <xspecref spec="XP40" ref="id-for-expressions"/>).</p></item>
               
               <item><p>Arrays can be filtered using the construct <code>$array?[<var>predicate</var>]</code>
               (see <xspecref spec="XP40" ref="id-filter-maps-and-arrays"/>).</p></item>
           </ulist>

            
         </div2>
         
      </div1>
      
      <div1 id="functions-on-types">
         <head>Processing types</head>
         <changes>
              <change issue="148">
                 New functions are provided to obtain information about built-in types and types defined in an
                 imported schema.
              </change>
           </changes>
         
         <p>The functions in this section deliver information about schema types (including simple types and complex
         types). These may represent built-in types (such as <code>xs:dateTime</code>), 
            user-defined types found in the static context (typically because they appear in an imported schema),
         or types used as type annotations on schema-validated nodes.</p>
         
         <p>For more information on schema types, see <specref ref="schema-type-hierarchy"/>. The properties
         of a schema type are described in terms of the properties of a Simple Type Definition 
         or Complex Type Definition component as described in <xspecref spec="XS11-1" ref="Simple_Type_Definition_details"/>
         and <xspecref spec="XS11-1" ref="Complex_Type_Definition_details"/> respectively. Not all properties are exposed.</p>
         
         <p>The structured representation of a schema type is described in
           <specref ref="schema-type-record"/>.</p>
         
         <note>
            <p>Simple properties of a schema type that can be expressed as strings or booleans are
            represented in this record structure directly as atomic field values, while complex properties
            whose values are themselves types (for example, <code>base-type</code> and <code>primitive-type</code>)
            are represented as functions. This is done partly to make it easier for implementations to compute
            complex properties on demand rather than in advance, and partly to ensure that the overall
            structure is always acyclic. For example, the primitive type of <code>xs:decimal</code> is itself
            <code>xs:decimal</code>, and if this were represented as a field value without a guarding function,
            serialization of the map using the JSON output method would not terminate.</p>
         </note>
         
         <div2 id="functions-returning-type-information">
            <head>Functions returning type information</head>
        
         
         <?local-function-index?>
            
            <div3 id="schema-type-record">
              <head><?record-description schema-type-record?></head>
            </div3>
            
            <div3 id="func-schema-type">
               <head><?function fn:schema-type?></head>
            </div3>
            <div3 id="func-type-of">
               <head><?function fn:type-of?></head>
            </div3>
            <div3 id="func-atomic-type-annotation">
               <head><?function fn:atomic-type-annotation?></head>
            </div3>
            <div3 id="func-node-type-annotation">
               <head><?function fn:node-type-annotation?></head>
            </div3>
            
         </div2>
         
      </div1>

        <div1 id="constructor-functions">
            <head>Constructor functions</head>
           
           <changes>
              <change issue="658" PR="662" date="2023-08-29">
                 Constructor functions now have a zero-arity form; the first
                 argument defaults to the context item.
              </change>
           </changes>
           
           <p>
              Constructor functions are used to convert a supplied value to a given type,
              and the name of the function is the same as the name of the target type. 
              This section describes constructor functions corresponding to the following types:</p>
           
           <ulist>
              <item><p>Simple types (atomic types, union types, and list types as
                 defined in <bibref ref="xmlschema-2"/>), which are present in the
                 static context either because they appear in the 
                 <xtermref ref="dt-is-types" spec="XP40">in-scope schema types</xtermref>
                 or because they appear as
                 <xtermref spec="XP40" ref="dt-named-item-type">named item types</xtermref>.
              </p>
                 <p>These constructor functions always take a single argument.</p></item>
              <item><p>Record types defined as 
                 <xtermref spec="XP40" ref="dt-named-item-type">named item types</xtermref>.</p>
              <p>These take one argument for each named field of the record type.
              Constructor functions for record types are defined in 
                 <specref ref="id-constructors-for-record-tests"/>.
              </p></item>
           </ulist> 
            

            
           <p>
              Constructor functions are defined for all user-defined named simple types, and for most built-in atomic, list, 
              and union types. The only named simple types that have no constructor function are those that have no instances 
              other than instances of their derived types: specifically, <code>xs:anySimpleType</code>, <code>xs:anyAtomicType</code>, 
              and <code>xs:NOTATION</code>. 
           </p>
            <div2 id="constructor-functions-for-xsd-types">
                <head>Constructor functions for XML Schema built-in atomic types</head>
                
                <p>Every built-in atomic 
                   type that is defined in <bibref ref="xmlschema-2"/>,
                   except <code>xs:anyAtomicType</code> and <code>xs:NOTATION</code>, has an
                    associated constructor function. The type <code>xs:untypedAtomic</code>, defined
                    in <xspecref spec="DM31" ref="types"/> and the two derived types
                    <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code> defined
                    in <xspecref spec="DM31" ref="types"/> also have associated constructor functions.
                Implementations <rfc2119>may</rfc2119> additionally provide
                a constructor functions for the new datatype <code>xs:dateTimeStamp</code> introduced in <bibref ref="xmlschema11-2"/>.</p>
<p>
A constructor function is not defined for <code>xs:anyAtomicType</code> as there are no atomic items with type annotation <code>xs:anyAtomicType</code> at runtime, although this can be a statically inferred type.
A constructor function is not defined for <code>xs:NOTATION</code> since it is defined as an abstract type in <bibref ref="xmlschema-2"/>.  If the static context (See <xspecref spec="XP31" ref="static_context"/>) contains a type derived from
<code>xs:NOTATION</code> then a constructor function is defined for it.
See <specref ref = 'constructor-functions-for-user-defined-types'/>.
</p>
<p> 
The form of the constructor function for an atomic type
                    <emph>eg:TYPE</emph> is:</p>
                <example role="signature">
                    <proto name="TYPE" prefix="eg" return-type="eg:TYPE" role="example"
                        returnEmptyOk="yes" isSpecial="yes">
                        <arg name="value" type="xs:anyAtomicType?" default="."/>
                    </proto>
                </example>
                <p>If <code>$arg</code> is the empty sequence, the empty sequence is returned. For
                    example, the signature of the constructor function corresponding to the
                    <code>xs:unsignedInt</code> type defined in <bibref ref="xmlschema-2"/> is:</p>
                <example role="signature">
                    <proto name="unsignedInt" return-type="xs:unsignedInt" isSchema="yes" prefix="xs"
                        returnEmptyOk="yes" role="example">
                        <arg name="arg" type="xs:anyAtomicType?" default="."/>
                    </proto>
                </example>
                <p>Calling the constructor function <code>xs:unsignedInt(12)</code> returns
                    the <code> xs:unsignedInt</code> value 12. Another call of that constructor
                    function that returns the same <code>xs:unsignedInt</code> value is
                    <code>xs:unsignedInt("12")</code>. The same result would also be returned if the
                    constructor function were to be called with a node that had a typed value equal
                    to the <code>xs:unsignedInt</code> 12. The standard features described in
                        <xspecref spec="XP31" ref="id-atomization"/> would atomize the node to
                    extract its typed value and then call the constructor with that value. If the
                    value passed to a constructor is not in the lexical space of the datatype to be constructed, 
                    and cannot be converted to a value in the value space of the datatype under the rules in this
                    specification, then an
                   dynamic error is raised <errorref class="RG" code="0001"/>.</p>
                    <p>The semantics of the constructor function 
                        <code>xs:TYPE(arg)</code>
                     are identical to the semantics of 
                        <code>arg</code> cast as <code>xs:TYPE?</code>
                    . See <specref ref="casting"/>.</p>
  <p>If the argument to a constructor function is a literal, the result of the
                    function <rfc2119>may</rfc2119> be evaluated statically; if an error is found during such
                    evaluation, it may be reported as a static error. </p>
 <p>Special rules apply to constructor functions for <code>xs:QName</code> and types derived from <code>xs:QName</code> and <code>xs:NOTATION</code>. See 
<specref ref="constructor-qname-notation"/>.
</p>
               <p diff="add" at="Issue658">The argument is optional, and defaults to the context value (which
               will be atomized if necessary).</p>
               <p>The following constructor functions for the built-in atomic types are supported:</p>
                <ulist> 
                    <item>
                        <proto name="string" return-type="xs:string" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="boolean" return-type="xs:boolean" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="decimal" return-type="xs:decimal" returnEmptyOk="yes"
                           isSchema="yes" prefix="xs" role="example" >
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="float" return-type="xs:float" returnEmptyOk="yes"
                           isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                        <p>Implementations <rfc2119>should</rfc2119> return negative zero for <code>xs:float("-0.0E0")</code>.  
                           But because <bibref ref="xmlschema-2"/> does not distinguish between the values positive zero and negative zero,
                           implementations <rfc2119>may</rfc2119> return positive zero in this case.</p>
                       
                    </item>
                    <item>
                        <proto name="double" return-type="xs:double" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                       <p>Implementations <rfc2119>should</rfc2119> return negative zero for <code>xs:double("-0.0E0")</code>.  
                          But because <bibref ref="xmlschema-2"/> does not distinguish between the values positive zero and negative zero,
                          implementations <rfc2119>may</rfc2119> return positive zero in this case.</p> 
                    </item>
                    <item>
                        <proto name="duration" return-type="xs:duration" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="dateTime" return-type="xs:dateTime" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="time" return-type="xs:time" returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="date" return-type="xs:date" returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="gYearMonth" return-type="xs:gYearMonth" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="gYear" return-type="xs:gYear" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="gMonthDay" return-type="xs:gMonthDay" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="gDay" return-type="xs:gDay" returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="gMonth" return-type="xs:gMonth" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="hexBinary" return-type="xs:hexBinary" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="base64Binary" return-type="xs:base64Binary" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="anyURI" return-type="xs:anyURI" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="QName" return-type="xs:QName" returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                        <p>
                            See <specref ref='constructor-qname-notation'/> for special rules.</p>
                    </item>
                </ulist>
                <ulist>
                    <item>
                        <proto name="normalizedString" return-type="xs:normalizedString"
                            returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="token" return-type="xs:token" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="language" return-type="xs:language" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="NMTOKEN" return-type="xs:NMTOKEN" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
					<item>
                        <proto name="Name" return-type="xs:Name" returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="NCName" return-type="xs:NCName" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="ID" return-type="xs:ID" returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="IDREF" return-type="xs:IDREF" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="ENTITY" return-type="xs:ENTITY" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
 <p>See <specref ref='casting-to-ENTITY'/> for rules related to constructing values of type <code>xs:ENTITY</code> and types derived from it.</p>
                    </item>
					<item>
                        <proto name="integer" return-type="xs:integer" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="nonPositiveInteger" return-type="xs:nonPositiveInteger"
                            returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="negativeInteger" return-type="xs:negativeInteger"
                            returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="long" return-type="xs:long" returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="int" return-type="xs:int" returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="short" return-type="xs:short" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="byte" return-type="xs:byte" returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="nonNegativeInteger" return-type="xs:nonNegativeInteger"
                            returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="unsignedLong" return-type="xs:unsignedLong" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="unsignedInt" return-type="xs:unsignedInt" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="unsignedShort" return-type="xs:unsignedShort"
                            returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="unsignedByte" return-type="xs:unsignedByte" returnEmptyOk="yes"
                            isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="positiveInteger" return-type="xs:positiveInteger"
                            returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                </ulist>
                <ulist>
                    <item>
                        <proto name="yearMonthDuration" return-type="xs:yearMonthDuration"
                            returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="dayTimeDuration" return-type="xs:dayTimeDuration"
                            returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                    <item>
                        <proto name="untypedAtomic" return-type="xs:untypedAtomic?"
                            returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                            <arg name="value" default="." type="xs:anyAtomicType?"/>
                        </proto>
                    </item>
                </ulist>
               <ulist>
                  <item>
                     <proto name="dateTimeStamp" return-type="xs:dateTimeStamp"
                        returnEmptyOk="yes" isSchema="yes" prefix="xs" role="example">
                        <arg name="value" default="." type="xs:anyAtomicType?"/>
                     </proto>
                     <p><emph>Available only if the implementation supports XSD 1.1.</emph></p>
                  </item>
               </ulist>
            </div2>
 
           <div2 id="constructor-qname-notation">
                <head>Constructor functions for xs:QName and xs:NOTATION</head>
<p>Special rules apply to constructor functions for the types <code>xs:QName</code> and <code>xs:NOTATION</code>, for two reasons:</p>
<ulist><item><p>
Values cannot belong directly to the type <code>xs:NOTATION</code>, only to its subtypes.
</p></item>
<item><p>
The lexical representation of these types uses namespace prefixes, whose
meaning is context-dependent.</p></item>
</ulist>
              
<p>
These constraints result in the following rules:</p>
<olist>
<item><p>
There is no constructor function for <code>xs:NOTATION</code>. Constructors are defined, however, for <code>xs:QName</code>, 
   for types derived or constructed from <code>xs:QName</code>, and for types 
   derived or constructed from <code>xs:NOTATION</code>.
</p></item>
   <item><p>When converting from an <code>xs:string</code>, the prefix within the lexical 
      <code>xs:QName</code> supplied
      as the argument is resolved to a namespace URI using the statically known
      namespaces from the static context. If the lexical <code>xs:QName</code>
      has no prefix, the
      namespace URI of the resulting expanded-QName is the default namespace for elements and types,
      taken from the static context. Components of the static context are
      defined in <xspecref spec="XP31" ref="static_context"/>. A dynamic error is raised <errorref class="NS" code="0004"/>
      if the prefix is not bound in the static context. As described in
      <xspecref spec="DM31" ref="terminology"/>, the supplied prefix is retained as part of the
      expanded-QName value.</p></item>
   
</olist>
              
   <p>When a constructor function for a namespace-sensitive type is used as a literal function item
      or in a partial function application (for example, <code>xs:QName#1</code> or <code>xs:QName(?)</code>) the namespace
      bindings that are relevant are those from the static context of the literal function item or partial function application.
      When a constructor function for a namespace-sensitive type is obtained by means of the <function>fn:function-lookup</function>
      function, the relevant namespace bindings are those from the static context of the call on <function>fn:function-lookup</function>.</p>           
              
   <note><p>When the supplied argument to the <code>xs:QName</code> constructor
   function is a node, the node is atomized in the usual way, and if the result is <code>xs:untypedAtomic</code> it is then
   converted as if a string had been supplied. The effect might not be what is desired.
   For example, given the attribute <code>xsi:type="my:type"</code>, the expression 
   <code>xs:QName(@xsi:type)</code> might fail on the grounds that the prefix <code>my</code>
   is undeclared. This is because the namespace bindings are taken from the static context
   (that is, from the query or stylesheet), and not from the source document containing the
   <code>@xsi:type</code> attribute. The solution to this problem is to use the function call
   <code>resolve-QName(@xsi:type, .)</code> instead.</p></note>

           </div2>
           
           <div2 id="constructor-functions-for-xsd-list-types">
              <head>Constructor functions for XML Schema built-in list types</head>
              
              <p>Each of the three built-in list
                 types defined in <bibref ref="xmlschema-2"/>,
                 namely <code>xs:NMTOKENS</code>, <code>xs:ENTITIES</code>, and <code>xs:IDREFS</code>, has an
                 associated constructor function.</p>
              
              <p>The function signatures are as follows:</p>
              
              <ulist>
                 <item>
                    <proto name="NMTOKENS" return-type="xs:NMTOKEN*" 
                       isSchema="yes" prefix="xs" role="example">
                       <arg name="value" default="." type="xs:string?" />
                    </proto>
                 </item>
                 <item>
                    <proto name="ENTITIES" return-type="xs:ENTITY*" 
                       isSchema="yes" prefix="xs" role="example">
                       <arg name="value" default="." type="xs:string?"/>
                    </proto>
                 </item>
                 <item>
                    <proto name="IDREFS" return-type="xs:IDREF*" 
                       isSchema="yes" prefix="xs" role="example">
                       <arg name="value" default="." type="xs:string?"/>
                    </proto>
                 </item>
              </ulist>
              
              <p>The semantics are equivalent to casting to the corresponding types from <code>xs:string</code>.</p>
              
              <p>All three of these types have the facet <code>minLength = 1</code> meaning that there must
              always be at least one item in the list. The return type, however, allows for the fact that when the argument to
              the function is an empty sequence, the result is an empty sequence.</p>
              
              <note><p>In the case of atomic types, it is possible to use an expression such as 
                 <code>xs:date(@date-of-birth)</code> to convert an attribute value to an instance of <code>xs:date</code>,
                 knowing that this will work both in the case where the attribute is already annotated as <code>xs:date</code>,
                 and also in the case where it is <code>xs:untypedAtomic</code>. This approach does not work with list types,
                 because it is not permitted to use a value of type <code>xs:NMTOKEN*</code> as input to the constructor
                 function <code>xs:NMTOKENS</code>. Instead, it is necessary to use conditional logic that performs the conversion
                 only in the case where the input is untyped: 
                 <code>if (@x instance of attribute(*, xs:untypedAtomic)) then xs:NMTOKENS(@x) else data(@x)</code></p>
              </note>
           </div2>  
           
           <div2 id="constructor-functions-for-xsd-union-types">
              <head>Constructor functions for XML Schema built-in union types</head>
              
              <p>There is a constructor function for the union type <code>xs:numeric</code>
                 defined in <bibref ref="xpath-datamodel-31"/>. The function signature is:</p>
              
              <ulist>
                 <item>
                    <proto name="numeric" return-type="xs:numeric?" 
                       isSchema="yes" prefix="xs" role="example">
                       <arg  name="value" default="." type="xs:anyAtomicType?"/>
                    </proto>
                 </item>
              </ulist>
              
              <p>The semantics are determined by the rules in <specref ref="casting-to-union"/>. These rules have the effect that: </p>
              <olist>
                 <item><p>If the argument is an instance of <code>xs:double</code>, <code>xs:float</code>, or <code>xs:decimal</code>,
                 then the result is an instance of the same primitive type, with the same value;</p></item>
                 <item><p>If the argument is an instance of <code>xs:boolean</code>, the result is the <code>xs:double</code> value
                    <code>0.0e0</code> or <code>1.0e0</code>;</p></item>
                 <item><p>If the argument is an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>, then:</p>
                    <olist>
                       <item><p>If the value is in the lexical space of <code>xs:double</code>, the result will be the
                       corresponding <code>xs:double</code> value;</p></item>
                       <item><p>Otherwise, a dynamic error <errorref class="RG" code="0001"/> occurs;</p></item>
                    </olist>
                    <note><p>The result will never be an instance of <code>xs:float</code>, <code>xs:decimal</code>,
                    or <code>xs:integer</code>. This is because <code>xs:double</code> appears first in the list of member
                    types of <code>xs:numeric</code>, and its lexical space subsumes the lexical space of the other numeric
                    types. Thus, unlike XPath numeric literals, the result does not depend on the lexical form of the supplied
                    value. The reason for this design choice is to retain compatibility with the function conversion rules:
                    functions such as <function>fn:abs</function> and <function>fn:round</function> are declared to expect an instance
                    of <code>xs:numeric</code> as their first or only argument, and compatibility with the function conversion
                    rules defined in earlier versions of these specifications demands that when an untyped atomic item
                    (or untyped node) is supplied as the argument, it is converted to an <code>xs:double</code> value
                       even if its lexical form is that (say) of an integer.</p></note>
                 </item>
                 <item><p>In all other cases, a dynamic error <errorref class="RG" code="0001"/> occurs.</p></item>
              </olist>
              
              <p>In the case of an implementation that supports XSD 1.1, there is a constructor function
              associated with the built-in union type <code>xs:error</code>.</p>
              
              <p>The function signature is as follows:</p>
              
              <ulist>
                 <item>
                    <proto name="error" return-type="xs:error?" 
                       isSchema="yes" prefix="xs" role="example">
                       <arg name="value" default="." type="xs:anyAtomicType?"/>
                    </proto>
                 </item>
              </ulist>
              
              <p>The semantics are equivalent to casting to the corresponding union type (see <specref ref="casting-to-union"/>).</p>
              
              <note>
              <p>Because <code>xs:error</code> has no member types, and therefore has an empty value space, casting
              will always fail with a dynamic error except in the case where the supplied argument is an empty
              sequence, in which case the result is also an empty sequence.</p>
              </note>   
              
 
           </div2>  
              
            <div2 id="constructor-functions-for-user-defined-types">
                <head>Constructor functions for user-defined atomic and union types</head>
                <p>For every <phrase diff="add" at="issue687">named</phrase> 
                   user-defined simple type in the static context (See <xspecref spec="XP31"
                    ref="static_context"/>), there is a
                   constructor function whose name is the same as the name of the 
                   type<phrase diff="del" at="issue687">and whose
                    effect is to create a value of that type from the supplied argument. The rules
                    for constructing user-defined types are defined in the same way as the rules for
                    constructing built-in derived types defined in <specref
                    ref="constructor-functions-for-xsd-types"/></phrase>.</p>
               
               <p diff="add" at="issue687">For named atomic types, the rules
                  are the same as the rules for constructing built-in derived atomic types defined in <specref
                     ref="constructor-functions-for-xsd-types"/>. For a named atomic type <code>T</code>,
               the signature of the function takes the form <code>T($value as xs:anyAtomicType? := .) as T?</code>,
                  and the semantics are the same as casting to derived types: see <specref ref="casting-to-derived-types"/>..</p>
               
               <p diff="add" at="issue687">For named union types, the rules
                  follow the same principles as the rules for constructing built-in union types defined in <specref
                     ref="constructor-functions-for-xsd-union-types"/>. For a named union type <code>U</code>,
                  the signature of the function takes the form <code>U($value as xs:anyAtomicType? := .) as U?</code>,
                  and the semantics are the same as casting to union types: see <specref ref="casting-to-union"/>.</p>
               
               <p diff="add" at="issue687">For named list types, the rules
                  follow the same principles as the rules for constructing built-in list types defined in <specref
                     ref="constructor-functions-for-xsd-list-types"/>. For a named list type <code>L</code>,
                  where the item type of <code>L</code> is <code>I</code>,
                  the signature of the function takes the form <code>L($value as xs:string? := .) as I*</code>,
                  and the semantics are the same as casting to list types: see <specref ref="casting-to-list"/>.</p>
               
               <p diff="add" at="issue687">Constructor functions are available both for named types defined in an imported schema (that is,
                  named simple types in the <xtermref ref="dt-is-types" spec="XP40">in-scope schema types</xtermref>), 
                  and for types defined by means of <xtermref ref="dt-named-item-type" spec="XP40">named item types</xtermref>.
                  Specifically, named enumeration types follow the same rules as schema types derived by
                  restricting <code>xs:string</code>, and named local union types follow the same rules as
                  union types defined in a schema.</p>
               
 
               
               <p>Special rules apply to constructor functions for namespace-sensitive types, that is,
                            atomic types derived from <code>xs:QName</code> and <code>xs:NOTATION</code>, list types that have
   a namespace-sensitive item type, and union types that have a namespace-sensitive member type. See <specref ref='constructor-qname-notation'/>.</p>
                
               <example>
                  <head>Using a Constructor Function for a User-Defined Atomic Type</head>
               <p>Consider a situation where the static context contains an atomic type
                    called <code>hatSize</code> defined in a schema whose target namespace is bound
                    to the prefix <code>eg</code>. In such a case the following constructor function is available to users:</p>
                <example role="signature">
                    <proto prefix="eg" name="hatSize" return-type="my:hatSize" isSpecial="yes" returnEmptyOk='yes' role="example">
                        <arg name="value" type="xs:anyAtomicType" emptyOk='yes'/>
                    </proto>
                </example>
                  <p>The resulting function may be used in an expression such as <code>eg:hatSize("10½")</code>.</p>
               </example>
               
               <p diff="del" at="issue687">In the case of an atomic type <var>A</var>, the return type of the function is <code>A?</code>, reflecting
               the fact that the result will be an empty sequence if the input is an empty sequence. For a union or list type,
               the return type of the function is specified only as <code>xs:anyAtomicType*</code>. Implementations performing
               static type checking will often be able to compute a more specific result type. For example, if the target type
               is a list type whose item type is the atomic type <var>A</var>, the result will always be an instance of <var>A*</var>;
               if the target type is a pure union type <var>U</var> then the result will always be an instance of <var>U?</var>.
               In general, however, applications needing interoperable behavior on implementations that do strict static type
               checking will need to use a <code>treat as</code> expression to assert the specific type of the result.</p>
                
               <note><p> To construct an instance of a user-defined type 
                  that is not in a namespace, it is possible to use an
                  <code>EQName</code> (for example <code>Q{}hatsize(17)</code>). Alternatives are
                    to use a cast expression (<code>17 cast as hatsize</code>) or (if the host language allows it) 
                  to undeclare the default function namespace. </p></note>
            </div2>
           
           <div2 diff="add" at="issue617" id="id-constructors-for-record-tests">
              <head>Constructor functions for named record types</head>
              
              <changes>
                 <change issue="617" PR="953" date="2024-02-20">
                    Constructor functions for named record types have been introduced.
                 </change>
              </changes>
              
              <p>Both XQuery 4.0 and XSLT 4.0 provide syntax to declare named record types;
                 such a declaration implicitly adds a constructor function for values of that
                 type to the (See <xspecref spec="XP31"
                    ref="static_context"/>).</p>
              
              <p>For example, if there is a named item type with the XQuery definition:</p>
              
              <eg>declare record my:location (
  latitude  as xs:double,
  longitude as xs:double
)</eg>
 
              <p>then there will be a function definition equivalent to:</p>
              
              <eg>declare function my:location (
  $latitude  as xs:double,
  $longitude as xs:double
) as my:location {
  { 'latitude': $latitude, 'longitude': $longitude }
}</eg>
              <p>Equivalently using XSLT syntax, if there is a named item type with the
              XSLT definition:</p>
              
              <eg><![CDATA[<xsl:record name="my:location"
  as="record(latitude as xs:double, longitude as xs:double)"/>]]></eg>
              
              <p>then there will be a function definition equivalent to:</p>
              
              <eg><![CDATA[<xsl:function name="my:location" as="my:location">
  <xsl:param name="latitude" as="xs:double"/>
  <xsl:param name="longitude" as="xs:double"/>
  <xsl:map>
    <xsl:map-entry key="'latitude'" select="$latitude"/>
    <xsl:map-entry key="'longitude'" select="$longitude"/>
  </xsl:map>
</xsl:function>]]></eg>
              
              
              <p>The rules defining the relationship of the function definition to the
              record type are given for XQuery 4.0 in <xspecref spec="XQ40" ref="named-records-as-functions"/>.</p>
              
              <ednote><edtext>TODO: Add cross-reference to XSLT here. 
                 Anticipates resolution of issue #1485. </edtext></ednote>
              
              
           </div2>
        </div1>
      <div1 id="casting">
         <head>Casting</head>
         <p> Constructor functions and cast expressions accept an expression and return a value
                of a given type. They both convert a source value <var>SV</var>, of a source type,
                <var>ST</var> to a target value <var>TV</var>, of the given target type
                <var>TT</var>.</p>
         <p>Constructor functions and cast expressions have identical semantics 
                but different syntax. The name of the
                constructor function is the same as the name of the built-in <bibref ref="xmlschema-2"/> 
                datatype or the datatype defined in <xspecref spec="DM31" ref="types"/>
                   of <bibref ref="xpath-datamodel-31"/> (see <specref ref="constructor-functions-for-xsd-types"/>) or the user-derived datatype
                (see <specref ref="constructor-functions-for-user-defined-types"/>) that is the
                target for the conversion, and the semantics are exactly the same as for a cast
                expression; for example,
                    <code>xs:date("2003-01-01")</code>
                 means exactly the same as 
                    <code>"2003-01-01"</code> cast as <code>xs:date?</code>.</p>
         <p>The cast expression takes a type name to indicate the target type of the conversion.
                See <xspecref spec="XP31" ref="id-cast"/>. If the type name allows the empty sequence
                and the expression to be cast is the empty sequence, the empty sequence is returned.
                If the type name does not allow the empty sequence and the expression to be cast is
                the empty sequence, a type error is raised <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
         <p>Where the argument to a cast is a literal, the result of the function <rfc2119>may</rfc2119> be
                evaluated statically; if an error is encountered during such evaluation, it <rfc2119>may</rfc2119> be
                reported as a static error. </p>
         <p>The general rules for casting from primitive types to primitive types are defined in
            <specref ref="casting-from-primitive-to-primitive"/>, and subsections describe the rules
            for specific target types.
            The general rules for casting from <code>xs:string</code> (and <code>xs:untypedAtomic</code>)
            follow in <specref ref="casting-from-strings"/>.
            Casting to non-primitive types, including atomic types derived by restriction,
            union types, and list types, is described in <specref ref="casting-non-primitive-types"/>.  
            Casting from derived types is defined in <specref ref="casting-from-derived-to-parent"/>, 
            <specref ref="casting-within-branch"/> and <specref ref="casting-across-hierarchy"/>.</p>
         
         <p>Casting is not supported to or from <code>xs:anySimpleType</code>. 
                  Casting to <code>xs:anySimpleType</code> is not permitted and raises a static error:
                     <xerrorref spec="XP" class="ST" code="0080"/>.</p>
            <p>Similarly, casting is not supported to or from <code>xs:anyAtomicType</code> and will raise 
               a static error: <xerrorref spec="XP" class="ST" code="0080"/>. There are no atomic items 
               with the type annotation <code>xs:anyAtomicType</code>, although this can be a 
               statically inferred type.</p>
         
         <!--<p><termdef id="dt-primitive-type" term="primitive type">Throughout 
            this section (<specref ref="casting"/>), the term <term>primitive type</term> means either one of
            the 19 primitive types defined in <bibref ref="xmlschema-2"/>, or one of the types
            <code>xs:untypedAtomic</code>, <code>xs:integer</code>, <code>xs:yearMonthDuration</code>
            and <code>xs:dayTimeDuration</code>; and where the text refers to types derived from a particular
            primitive type <var>T</var>, the reference is to types for which <var>T</var> is the nearest
            ancestor-or-self primitive type in the type hierarchy.
         </termdef></p>-->
         
         
         
         
         <div2 id="casting-from-primitive-to-primitive">
           
            <head>Casting from primitive types to primitive types</head>
            
            <changes>
               <change issue="1401" PR="1409">
                  This section now uses the term <term>primitive type</term> strictly to refer to the 20 atomic types
                  that are not derived by restriction from another atomic type: that is, the 19 primitive atomic
                  types defined in XSD, plus <code>xs:untypedAtomic</code>. The three types <code>xs:integer</code>,
                  <code>xs:dayTimeDuration</code>, and <code>xs:yearMonthDuration</code>, which have custom
                  casting rules but are not strictly-speaking primitive, are now handled in other subsections.
               </change>
            </changes>
            <p>This section defines casting between <termref def="dt-primitive-type">primitive types</termref>
               (specifically, the 19 primitive types defined in <bibref ref="xmlschema-2"/> plus <code>xs:untypedAtomic</code>.
                    <!--<code>xs:integer</code> and the two derived types of
                    <code>xs:duration</code>: <code>xs:yearMonthDuration</code>
                    and <code>xs:dayTimeDuration</code> which are treated as primitive types in this section. -->
               The type conversions
                    that are supported between primitive atomic types are indicated in the table below;
                    casts between other (non-primitive) types are defined in terms of these primitives.</p>
            
            <p>Where the target type <var>TT</var> is a primitive type, the result <var>TV</var> will always
            be an instance of <var>TT</var>. The result <rfc2119>may</rfc2119> also be an instance of a type derived
            from <var>TT</var>: for example casting an <code>xs:NCName</code> <var>SV</var> 
               to <code>xs:string</code> <rfc2119>may</rfc2119> return <var>SV</var> unchanged, with its
            original type annotation.</p>
            
            
                    
            <p>In this table, there is a
               row for each <termref def="dt-primitive-type">primitive type</termref> acting as the source of the conversion and
               there is a column for each <termref def="dt-primitive-type">primitive type</termref> acting as the target of the conversion. The
                    intersections of rows and columns contain one of three characters:</p>
                    <ulist>
                       <item><p><code>Y</code> indicates that a conversion from values of the type to which
                        the row applies to the type to which the column applies is supported;</p></item>
                       <item><p><code>N</code> indicates that there are no supported conversions from values
                    of the type to which the row applies to the type to which the column applies;</p></item>
                       <item><p><code>M</code> indicates that a conversion from values of the type to
                    which the row applies to the type to which the column applies may succeed for
                    some values in the value space and fail for others.</p></item>
                    </ulist>
            <p>There is no row or column for <code>xs:untypedAtomic</code> because the casting rules are exactly the same
            as for <code>xs:string</code>. When casting from <code>xs:string</code> or <code>xs:untypedAtomic</code>
            the semantics in <specref ref="casting-from-strings"/> apply, regardless of target type.
         </p>
            <p>
               <bibref ref="xmlschema-2"/> defines <code>xs:NOTATION</code> as an abstract type. 
               Thus, casting to <code>xs:NOTATION</code> from any other type including <code>xs:NOTATION</code>
               is not permitted and raises a static error <xerrorref spec="XP" class="ST" code="0080"/>.  
               However, casting from one subtype of <code>xs:NOTATION</code> to another subtype of 
               <code>xs:NOTATION</code> is permitted.</p>

            <p>Casting is not supported to or from <code>xs:anySimpleType</code>. Thus, there is no row
               or column for this type in the table below. For any node that has not been validated or 
               has been validated as <code>xs:anySimpleType</code>, the typed value of the node is an 
               atomic item of type <code>xs:untypedAtomic</code>. There are no atomic items with the 
               type annotation <code>xs:anySimpleType</code> at runtime. 
                  Casting to
                     <code>xs:anySimpleType</code> is not permitted and raises a static error:
                     <xerrorref spec="XP" class="ST" code="0080"/>.</p>
            <p>Similarly, casting is not supported to or from <code>xs:anyAtomicType</code> and will raise 
               a static error: <xerrorref spec="XP" class="ST" code="0080"/>. There are no atomic items 
               with the type annotation <code>xs:anyAtomicType</code> at runtime, although this can be a 
               statically inferred type.</p>
            <p>If casting is attempted from an <emph>ST</emph> to a <emph>TT</emph> for which
                    casting is not supported, as defined in the table below, a type error is raised <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
            <p>In the following table, the columns and rows are identified by short codes that
                    identify simple types as follows:</p>
            <slist>
               <!--<sitem>uA = xs:untypedAtomic</sitem>-->
               <sitem>aURI = xs:anyURI</sitem>
               <sitem>b64 = xs:base64Binary</sitem>
               <sitem>bool = xs:boolean</sitem>
               <sitem>dat = xs:date</sitem>
               <sitem>gDay = xs:gDay</sitem>
               <sitem>dbl = xs:double</sitem>
               <sitem>dec = xs:decimal</sitem>
               <sitem>dT = xs:dateTime</sitem>
               <!--<sitem>dTD = xs:dayTimeDuration</sitem>-->
               <sitem>dur = xs:duration</sitem>
               <sitem>flt = xs:float</sitem>
               <sitem>hxB = xs:hexBinary</sitem>
               <sitem>gMD = xs:gMonthDay</sitem>
               <sitem>gMon = xs:gMonth</sitem>
               <!--<sitem>int = xs:integer</sitem>-->
               <sitem>NOT = xs:NOTATION</sitem>
               <sitem>QN = xs:QName</sitem>
               <sitem>str = xs:string</sitem>
               <sitem>tim = xs:time</sitem>
               <sitem>gYM = xs:gYearMonth</sitem>
               <!--<sitem>yMD = xs:yearMonthDuration</sitem>-->
               <sitem>gYr = xs:gYear</sitem>
            </slist>
            <p>In the following table, the notation <quote>S\T</quote> indicates that the source
                    (<quote>S</quote>) of the conversion is indicated in the column below the
                    notation and that the target (<quote>T</quote>) is indicated in the row to the
                    right of the notation.</p>
            <!-- The markup in the following table is perhaps a bit surprising, but it serves an important purpose: 
               to allow the resulting HTML to display “tool tips” and cell colors that make it much easier to 
               interpret the contents of the table.  The “special” aspects of the markup include: setting the 
               column widths so that all columns are the same width and marking up the first column in each 
               row as <code>th</code> instead of <code>td</code>.  Editors should be careful not to change these conventions without 
               changing the associated stylesheets. --><table border="1" cellpadding="1" role="casting" summary="Casting table"
                   id="casting-to-primitives-table">
               <col width="5%" span="1"/>
               <!--<col width="3%" span="1"/>-->
               <col width="3%" span="1"/>
               <col width="3%" span="1"/>
               <col width="3%" span="1"/>
               <col width="3%" span="1"/>
               <!--<col width="3%" span="1"/>-->
               <col width="3%" span="1"/>
               <!--<col width="3%" span="1"/>-->
               <!--<col width="3%" span="1"/>-->
               <col width="3%" span="1"/>
               <col width="3%" span="1"/>
               <col width="3%" span="1"/>
               <col width="3%" span="1"/>
               <col width="3%" span="1"/>
               <col width="3%" span="1"/>
               <col width="3%" span="1"/>
               <col width="3%" span="1"/>
               <col width="3%" span="1"/>
               <col width="3%" span="1"/>
               <col width="3%" span="1"/>
               <col width="3%" span="1"/>
               <col width="3%" span="1"/>
               <col width="3%" span="1"/>
               <thead>
                  <tr>
                     <th>S\T</th>
                     <!--<th>uA</th>-->
                     <th>str</th>
                     <th>flt</th>
                     <th>dbl</th>
                     <th>dec</th>
                     <!--<th>int</th>-->
                     <th>dur</th>
                     <!--<th>yMD</th>-->
                     <!--<th>dTD</th>-->
                     <th>dT</th>
                     <th>tim</th>
                     <th>dat</th>
                     <th>gYM</th>
                     <th>gYr</th>
                     <th>gMD</th>
                     <th>gDay</th>
                     <th>gMon</th>
                     <th>bool</th>
                     <th>b64</th>
                     <th>hxB</th>
                     <th>aURI</th>
                     <th>QN</th>
                     <th>NOT</th>
                  </tr>
               </thead>
               <tbody>
                  <!--<tr>
                     <th>uA</th>
                     <td>Y</td>
                     <td>Y</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                  </tr>-->
                  <tr>
                     <th>str</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <!--<td>M</td>-->
                     <td>M</td>
                     <!--<td>M</td>-->
                     <!--<td>M</td>-->
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                     <td>M</td>
                  </tr>
                  <tr>
                     <th>flt</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>M</td>
                     <!--<td>M</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>
                  <tr>
                     <th>dbl</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>M</td>
                     <!--<td>M</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>
                  <tr>
                     <th>dec</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <!--<td>Y</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>
                  <!--<tr>
                     <th>int</th>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>-->
                  <tr>
                     <th>dur</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <!--<td>N</td>-->
                     <td>Y</td>
                     <!--<td>Y</td>-->
                     <!--<td>Y</td>-->
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>
                  <!--<tr>
                     <th>yMD</th>
                     <td>Y</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>-->
                  <!--<tr>
                     <th>dTD</th>
                     <td>Y</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>-->
                  <tr>
                     <th>dT</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <!--<td>N</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>
                  <tr>
                     <th>tim</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <!--<td>N</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>N</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>
                  <tr>
                     <th>dat</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <!--<td>N</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>Y</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>
                  <tr>
                     <th>gYM</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <!--<td>N</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>
                  <tr>
                     <th>gYr</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <!--<td>N</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>
                  <tr>
                     <th>gMD</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <!--<td>N</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>
                  <tr>
                     <th>gDay</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <!--<td>N</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>
                  <tr>
                     <th>gMon</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <!--<td>N</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>
                  <tr>
                     <th>bool</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>Y</td>
                     <!--<td>Y</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>
                  <tr>
                     <th>b64</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <!--<td>N</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>
                  <tr>
                     <th>hxB</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <!--<td>N</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>
                  <tr>
                     <th>aURI</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <!--<td>N</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                  </tr>
                  <tr>
                     <th>QN</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <!--<td>N</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>M</td>
                  </tr>
                  <tr>
                     <th>NOT</th>
                     <!--<td>Y</td>-->
                     <td>Y</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <!--<td>N</td>-->
                     <td>N</td>
                     <!--<td>N</td>-->
                     <!--<td>N</td>-->
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>N</td>
                     <td>Y</td>
                     <td>M</td>
                  </tr>
               </tbody>
            </table>
            
            <div3 id="casting-to-untypedAtomic">
               <head>Casting to <code>xs:untypedAtomic</code></head>
               
               <p>Any atomic item <var>SV</var> can be cast to <code>xs:untypedAtomic</code>.</p>
               
               <p>The effect is the same as casting to <code>xs:string</code> (see <specref ref="casting-to-string"/>)
               and then returning the <code>xs:untypedAtomic</code> value comprising the same sequence of
               characters.</p>
            </div3>
            
            <div3 id="casting-to-string">
               <head>Casting to <code>xs:string</code></head>
               
               <p>Any atomic item <var>SV</var> can be cast to <code>xs:string</code>.</p>
               
               <p>The resulting <code>xs:string</code> value <var>TV</var> depends on
                        the source type <var>ST</var> as follows.</p>
               <ulist>
                  <item>
                     <p>If <var>SV</var> is an instance of <code>xs:string</code>,
                        <var>TV</var> is an instance of <code>xs:string</code> comprising
                        the same sequence of characters as <var>SV</var>.</p>
                     <note><p>The implementation is free to return <var>SV</var> unchanged,
                     including its original type annotation.</p></note>
                  </item>
                  <item>
                     <p>If <var>SV</var> is an instance of <code>xs:anyURI</code>, the result <var>TV</var> is an instance
                        of <code>xs:string</code> comprising the same sequence of characters
                        as <var>SV</var>, but with a type annotation of <code>xs:anyURI</code>.
                       No escaping of special characters takes place.</p>
                  </item>
                  <item>
                     <p>If <var>SV</var> is an instance of <code>xs:QName</code> or <code>xs:NOTATION</code>:</p>
                     <ulist>
                        <item><p>if the qualified name
                           has a prefix, then <var>TV</var> is the concatenation of the prefix of <var>SV</var>, 
                 		  a single colon (:), and the local name of <var>SV</var>.</p>
                           </item>
                        <item>
                           <p>otherwise <var>TV</var> is the local name of <var>SV</var>.</p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p>If <var>SV</var> is an instance of <code>xs:numeric</code>, 
                        the rules in <specref ref="casting-numeric-to-string"/> apply.</p>
                     
                  </item>
                  <item>
                     <p>If <var>SV</var> is an instance of <code>xs:dateTime</code>, <code>xs:date</code>
                                or <code>xs:time</code>, the rules in <specref ref="casting-date-time-to-string"/> apply.
                        
                     </p>
                  </item>
                  <item>
                     <p>If <var>ST</var> is <code>xs:duration</code>, or any subtype thereof including
                        <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code>, then the rules
                        in <specref ref="casting-duration-to-string"/> apply.</p>

                  </item>
                  
                  <item>
                     <p>In all other cases, <var>TV</var> is the <bibref ref="xmlschema-2"/>
                                canonical representation of <var>SV</var>. For datatypes that do
                                not have a canonical representation defined an <termref def="implementation-dependent"/> canonical representation may be used.</p>
                  </item>
                  </ulist>
               <p>To cast as <code>xs:untypedAtomic</code> the value is cast as
                        <code>xs:string</code>, as described above, and the type annotation changed
                        to <code>xs:untypedAtomic</code>.</p>
               
               
               <div4 id="casting-numeric-to-string">
                  <head>Casting numeric values to <code>xs:string</code></head>
                  <p>The following rules apply when the source type <var>ST</var> is <code>xs:decimal</code>,
                  <code>xs:double</code>, or <code>xs:float</code>, or any subtype of these including
                  <code>xs:integer</code>.</p>
                  <olist>
                        <item>
                           <p>If <var>SV</var> is an instance of <code>xs:decimal</code>,
                              then the canonical representation of
                              <var>SV</var> is returned, as defined in <bibref ref="xmlschema11-2"/>.
                                 Specifically, see <loc href="https://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/datatypes.html#f-decimalCanmap">decimalCanonicalMap</loc>.</p>
                           
                           <note>
                              <p>Unlike previous versions of this specification, no special
                              rule is given for the case where <var>SV</var> is an instance of
                              <code>xs:integer</code>. This is because the general rule for
                              <code>xs:decimal</code> gives the same result. The result 
                                 in this case will be a sequence of decimal digits in the range
                              <char>U+0030</char> to <char>U+0039</char>, optionally
                           preceded by a minus sign, with no leading zeroes. For example:
                              <code>42</code>, <code>-1</code>, <code>0</code>, or <code>1000000000</code>.</p>
                           </note>
                           
                           <note>
                              <p>An <code>xs:decimal</code> that is equal to an integer is converted
                              to a string as if it were first cast to an <code>xs:integer</code>.
                              Specifically, there will be no decimal point and no fractional part.</p>
                              <p>If the value is not equal to an integer, then there will be a decimal
                              point and a fractional part, which will be a sequence of decimal digits
                              with no trailing zeroes. For example: <code>42.3</code>, <code>-1.5</code>, 
                                 or <code>0.00001</code>.</p>
                           </note>
                        </item>     
                        <!--<item>
                           <p>If <var>SV</var> is an instance of <code>xs:integer</code>,
                                        <var>TV</var> is the canonical representation of
                                        <var>SV</var> as defined in <bibref ref="xmlschema11-2"/>.</p>
                           <note><p>The result will thus be a sequence of decimal digits in the range
                              <char>U+0030</char> to <char>U+0039</char>, optionally
                           preceded by a minus sign, with no leading zeroes.</p></note>
                        </item>-->
                        
                        <item>
                           <p> If <var>SV</var> is an instance of <code>xs:float</code> or
                                        <code>xs:double</code>, then:</p>
                           <olist>
                              <item>
                                 <p>
                                    <var>TV</var> will be an <code>xs:string</code> in the lexical space 
                                    of <code>xs:double</code> or <code>xs:float</code> that when
                                    converted to an <code>xs:double</code> or <code>xs:float</code> under 
                                    the rules of <specref ref="casting-from-strings"/> produces
                                    a value that is equal to <var>SV</var>, or is <code>NaN</code> 
                                    if <var>SV</var> is <code>NaN</code>.
                                    In addition, <var>TV</var> must satisfy the constraints in the
                                    following sub-bullets.
											</p>
                                 <olist>
                                    <item>
                                       <p>If <var>SV</var> has an absolute value that is
                                                greater than or equal to 0.000001 (one millionth)
                                                and less than 1000000 (one million), then the value
                                                is converted to an <code>xs:decimal</code> and the
                                                resulting <code>xs:decimal</code> is converted to an
                                                <code>xs:string</code> according to the rules above, as though using an 
                                                implementation of <code>xs:decimal</code> that imposes no limits on the
                                                <code>totalDigits</code> or
                                                <code>fractionDigits</code> facets.</p>
                                    </item>
                                    <item>
                                       <p>If <var>SV</var> has the value positive or negative zero, <var>TV</var> 
                                          is <code>"0"</code> or <code>"-0"</code> respectively.</p>
                                    </item>
                                    <item>
                                       <p>If <var>SV</var> is positive or negative infinity, 
                                          <var>TV</var> is the string <code>"INF"</code> or <code>"-INF"</code> respectively.
                                       </p>
                                    </item>
                                    <item>
                                       <p>In other cases, the result consists of a mantissa, which has the lexical form
                                       of an <code>xs:decimal</code>, followed by the letter "E", followed by an exponent which has
                                       the lexical form of an <code>xs:integer</code>. Leading zeroes and "+" signs are prohibited
                                       in the exponent. For the mantissa, there must be a decimal point, and there must
                                       be exactly one digit before the decimal point, which must be non-zero. The  "+"
                                       sign is prohibited. There must be at least one digit after the decimal point.
                                       Apart from this mandatory digit, trailing zero digits are prohibited. 
                                       </p>
                                    </item>
                                 </olist>
                              </item>
                           </olist>
                           <note>
                              <p>The above rules allow more than one representation of the same value. 
                                 For example, the <code>xs:float</code> value whose exact decimal representation is 1.26743223E15
                                 might be represented by any of the strings <code>"1.26743223E15"</code>,
                                 <code>"1.26743222E15"</code> or <code>"1.26743224E15"</code> (inter alia).
                                 It is implementation-dependent which of these representations is chosen.</p>
                           </note>
                        </item>
                     </olist>
                  
                  <note>
                    <p>The string representations of numeric values are backwards compatible
                            with XPath 1.0 except for the special values positive and negative
                            infinity, negative zero and values outside the range <code>1.0e-6</code> to <code>1.0e+6</code>.</p>
                  </note>
               </div4>
               <div4 id="casting-date-time-to-string">
                  <head>Casting date/time values to <code>xs:string</code></head>
                  
                  <changes>
                     <change issue="1401" PR="1409">
                        The rules for conversion of dates and times to strings are now defined entirely
                        in terms of XSD 1.1 canonical mappings, since these deliver
                        exactly the same result as the XPath 3.1 rules.
                     </change>
                  </changes>
                  
                  <p>If <var>SV</var> is an instance of <code>xs:dateTime</code>,
                     <code>xs:date</code>, <code>xs:time</code>, <code>xs:gYear</code>, 
                     <code>xs:gYearMonth</code>, <code>xs:gMonth</code>, <code>xs:gMonthDay</code>, or <code>xs:gDay</code>,
                     then <var>TV</var> is the 
                     canonical representation of <var>SV</var> as defined in <bibref ref="xmlschema11-2"/>.
                  </p>
                  
                  <note>
                     <p>The result <var>TV</var> includes the original timezone if a timezone is present.</p>
                     <p>All these data types contain different combinations of the components year, month, day,
                     hour, minute, second, and timezone; all the components relevant to the data type (with 
                     the exception of the timezone) are output, and the results are concatenated together 
                     with suitable punctuation. Specifically:</p>
                     <olist>
                     <item><p>The <code>year</code> component is 
                        represented as a <code>xs:string</code> of four digits, or more if needed. A leading minus 
                        sign is present for BCE years.</p></item>
                     <item><p>The <code>month</code>, <code>day</code>, <code>hour</code> and <code>minute</code> 
                        components are represented as two digits (with a leading zero if needed).
                       For example, February is represented as <code>02</code>.</p>
                     <p>The hours component will never be <code>"24"</code>: midnight 
                        is always represented as <code>"00:00:00"</code>.</p></item>
                     <item><p>The <code>second</code> component is output using as a two-digit integer
                        if it is a whole number (for example, <code>30</code>, <code>05</code>, or <code>00</code>),
                        or if it is fractional, as two digits followed by a decimal point followed by as many digits as
                        are necessary, with no trailing zeroes (for example <code>30.5</code> or <code>00.001</code>). </p></item>
                     <item><p>The timezone component, if present, is 
                        cast to <code>xs:string</code> by applying the function <code>eg:convertTZtoString</code>
                     given in <specref ref="casting-to-datetimes"/>. Examples are <code>Z</code>, <code>+01:00</code>,
                     <code>-05:00</code>, or <code>+05:30</code>.</p></item>
                  </olist>  
                      <p>.
                  </p>
                  </note>
                  
                          
                        
                    
                  
                 
               </div4>      
               <div4 id="casting-duration-to-string">
                  <head>Casting <code>xs:duration</code> values to <code>xs:string</code></head>
                  
                  <changes>
                     <change issue="1401" PR="1409">
                        The rules for conversion of durations to strings are now defined entirely
                        in terms of XSD 1.1 canonical mappings, since the XSD 1.1 rules deliver
                        exactly the same result as the XPath 3.1 rules.
                     </change>
                  </changes>
                  <p>If <var>SV</var> is an instance of <code>xs:duration</code> (including its subtypes
                     <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code>), then <var>TV</var> is the 
                     canonical representation of <var>SV</var> as defined in <bibref ref="xmlschema11-2"/>.
                     Specifically, see <loc href="https://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/datatypes.html#f-durationCanMap">durationCanonicalMap</loc>.</p>
                  
                  <note>
                     <p>The rules have the effect of normalizing the value so that the number of months is always
                     less than 12, the number of hours less than 24, and the number of minutes and seconds less 
                     than 60. Zero-valued components are omitted. Fractional seconds follow the same rules
                     as <code>xs:decimal</code>. For example, the duration <code>P15MT30H</code>
                     is represented as <code>P1Y3M1DT6H</code>. A zero-length duration is output as <code>PT0S</code>.</p>
                  </note>
                  
                  <note>
                     <p>At the time of writing, the published XSD 1.1 recommendation contains 
                        cut-and-paste errors in the definition
                     of the <code>dayTimeDuration</code> canonical mapping. The binding of variable <var>s</var>
                     should be to <var>dt</var>'s <code>·seconds·</code> (not <code>·months·</code>) component, and the return 
                        expression given as <code>sgn &amp; 'P' &amp; ·duYearMonthCanonicalFragmentMap·(|s|)</code>
                     should read <code>sgn &amp; 'P' &amp; ·duDayTimeCanonicalFragmentMap·(|s|)</code></p>
                     
                     <p>In reading these XSD formulations, be aware that <code>a &amp; b</code> represents
                        string concatenation, while <code>|s|</code> computes the absolute value of a number.</p>
                  </note>
               
                     
               </div4>
            </div3>
            <div3 id="casting-to-numerics">
               <head>Casting to numeric types</head>
               <p>This section defines the rules for casting to the primitive numeric types <code>xs:float</code>,
               <code>xs:double</code>, and <code>xs:decimal</code>. Rules for casting to the derived type
               <code>xs:integer</code> are given in <specref ref="casting-to-integer"/>.</p>
               <div4 id="casting-to-float">
                  <head>Casting to xs:float</head>
                  <p>When a value of any simple type is cast as <code>xs:float</code>, the <code>xs:float</code>
                            <var>TV</var> is derived from the <var>ST</var> and the
                            <var>SV</var> as follows:</p>
                  <ulist>
                     <item>
                        <p>If <var>ST</var> is <code>xs:float</code>, then <var>TV</var>
                                    is <var>SV</var> and the conversion is complete.</p>
                     </item>
                     <item>
                        <p>If <var>ST</var> is <code>xs:double</code>, then
                                    <var>TV</var> is obtained as follows: </p>
                        <ulist>
                           <item>
                              <p>if <var>SV</var> is the <code>xs:double</code> value
                                            <code>INF</code>, <code>-INF</code>, <code>NaN</code>,
                                            positive zero, or negative zero, then <var>TV</var> is
                                            the <code>xs:float</code> value <code>INF</code>,
                                            <code>-INF</code>, <code>NaN</code>, positive zero, or
                                            negative zero respectively.</p>
                           </item>
                           <item>
                              <p>otherwise, <var>SV</var> can be expressed in the form
                                                <code>m &times; 2^e</code> where the mantissa
                                            <code>m</code> and exponent <code>e</code> are signed
                                            <code>xs:integer</code>s whose value range is defined in
                                                <bibref ref="xmlschema-2"/>, and the following rules apply:</p>
                              <ulist>
                                 <item>
                                    <p>if <code>m</code> (the mantissa of
                                                  <var>SV</var>) is outside the permitted range
                                                  for the mantissa of an <code>xs:float</code>
                                                  value <code>(-2^24-1 to +2^24-1)</code>, then it
                                                  is divided by <code>2^N</code> where
                                                  <code>N</code> is the lowest positive
                                                  <code>xs:integer</code> that brings the result
                                                  of the division within the permitted range, and
                                                  the exponent <code>e</code> is increased by
                                                  <code>N</code>. This is integer division (in
                                                  effect, the binary value of the mantissa is
                                                  truncated on the right). Let <code>M</code> be
                                                  the mantissa and <code>E</code> the exponent
                                                  after this adjustment.</p>
                                 </item>
                                 <item>
                                    <p>if <code>E</code> exceeds <code>104</code> (the
                                                  maximum exponent value in the value space of
                                                  <code>xs:float</code>) then <var>TV</var> is
                                                  the <code>xs:float</code> value <code>INF</code>
                                                  or <code>-INF</code> depending on the sign of <code>M</code>.</p>
                                 </item>
                                 <item>
                                    <p>if <code>E</code> is less than <code>-149</code>
                                                  (the minimum exponent value in the value space
                                                  of <code>xs:float</code>) then <var>TV</var> is
                                                  the <code>xs:float</code> value positive or
                                                  negative zero depending on the sign of <code>M</code>
                                                </p>
                                 </item>
                                 <item>
                                    <p>otherwise, <var>TV</var> is the
                                                  <code>xs:float</code> value <code>M &times; 2^E</code>.</p>
                                 </item>
                              </ulist>
                           </item>
                        </ulist>
                     </item>
                     <item>
                        <p>If <var>ST</var> is <code>xs:decimal</code>, or
                                    <code>xs:integer</code>, then <var>TV</var> is <code>xs:float(</code>
                                    <var>SV</var>
                                    <code> cast as xs:string)</code> and the conversion is complete.</p>
                     </item>
                     <item>
                        <p>If <var>ST</var> is <code>xs:boolean</code>, <var>SV</var> is
                                    converted to <code>1.0E0</code> if <var>SV</var> is
                                    <code>true</code> and to <code>0.0E0</code> if <var>SV</var>
                                    is <code>false</code> and the conversion is complete.</p>
                     </item>
                     <item>
                        <p> If <var>ST</var> is <code>xs:untypedAtomic</code>
                                    or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>. 
                        </p>
                        <note><p>XSD 1.1 adds the value <code>+INF</code> to the lexical space,
                           as an alternative to <code>INF</code>. XSD 1.1 also adds negative zero
                           to the value space.</p></note>
                     </item>
                  </ulist>
                  <note>
                     <p>Implementations <rfc2119>should</rfc2119> return negative zero for <code>xs:float("-0.0E0")</code>.  
                        But because <bibref ref="xmlschema-2"/> does not distinguish between the values positive zero and negative zero.
                        Implementations <rfc2119>may</rfc2119> return positive zero in this case.</p>
                  </note>
               </div4>
               <div4 id="casting-to-double">
                  <head>Casting to xs:double</head>
                  <p>When a value of any simple type is cast as <code>xs:double</code>, the
                            <code>xs:double</code> value <var>TV</var> is derived from the
                            <var>ST</var> and the <var>SV</var> as follows:</p>
                  <ulist>
                     <item>
                        <p>If <var>ST</var> is <code>xs:double</code>, then
                                    <var>TV</var> is <var>SV</var> and the conversion is complete.</p>
                     </item>
                     <item>
                        <p>If <var>ST</var> is <code>xs:float</code> or a type derived
                                    from <code>xs:float</code>, then <var>TV</var> is obtained as follows:</p>
                        <ulist>
                           <item>
                              <p>if <var>SV</var> is the <code>xs:float</code> value
                                            <code>INF</code>, <code>-INF</code>, <code>NaN</code>,
                                            positive zero, or negative zero, then <var>TV</var> is
                                            the <code>xs:double</code> value <code>INF</code>,
                                            <code>-INF</code>, <code>NaN</code>, positive zero, or
                                            negative zero respectively. </p>
                           </item>
                           <item>
                              <p>otherwise, <var>SV</var> can be expressed in the form
                                                <code>m &times; 2^e</code> where the
                                            mantissa <code>m</code> and exponent <code>e</code> are
                                            signed <code>xs:integer</code> values whose value range
                                            is defined in <bibref ref="xmlschema-2"/>, and
                                            <var>TV</var> is the <code>xs:double</code> value
                                                <code>m &times; 2^e</code>. </p>
                           </item>
                        </ulist>
                     </item>
                     <item>
                        <p>If <var>ST</var> is <code>xs:decimal</code> or
                                    <code>xs:integer</code>, then <var>TV</var> is <code>xs:double(</code>
                                    <var>SV</var>
                                    <code> cast as xs:string)</code> and the conversion is complete.</p>
                     </item>
                     <item>
                        <p>If <var>ST</var> is <code>xs:boolean</code>, <var>SV</var> is
                                    converted to <code>1.0E0</code> if <var>SV</var> is
                                    <code>true</code> and to <code>0.0E0</code> if <var>SV</var>
                                    is <code>false</code> and the conversion is complete.</p>
                     </item>
                     <item>
                        <p> If <var>ST</var> is <code>xs:untypedAtomic</code>
                                    or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>.</p>
                        <note><p>XSD 1.1 adds the value <code>+INF</code> to the lexical space,
                        as an alternative to <code>INF</code>. XSD 1.1 also adds negative zero
                        to the value space.</p></note>
                     </item>
                  </ulist>
                  <note>
                     <p>Implementations <rfc2119>should</rfc2119> return negative zero for <code>xs:double("-0.0E0")</code>.  
                        But because <bibref ref="xmlschema-2"/> does not distinguish between the values positive zero and negative zero.
                        Implementations <rfc2119>may</rfc2119> return positive zero in this case.</p>  </note>
               </div4>
               <div4 id="casting-to-decimal">
                  <head>Casting to xs:decimal</head>
                  
                  <p>This section defines the rules for casting to the primitive type <code>xs:decimal</code>.
                     The rules are also invoked implicitly as part of the process of converting to types
                     derived from <code>xs:decimal</code>. There are special rules, however, if the
                     target type <var>TT</var> is <code>xs:integer</code>, or a type derived from
                     <code>xs:integer</code>: those rules are given in <specref ref="casting-to-integer"/>.</p>
                  
                  <p>When the target type <var>TT</var> is <code>xs:decimal</code>, the
                            resulting <code>xs:decimal</code> value <var>TV</var> is derived from
                            <var>ST</var> and <var>SV</var> as follows: </p>
                  <ulist>
                     <item>
                        <p>If <var>ST</var> is <code>xs:decimal</code> or a subtype thereof 
                           (including <code>xs:integer</code>), then
                                    the result <var>TV</var> has the same <termref def="dt-datum"/> as <var>SV</var>.
                           The type annotation <rfc2119>may</rfc2119> be <code>xs:decimal</code> or any
                           subtype of <code>xs:decimal</code> for which this is a valid instance, including
                           the original type <code>ST</code>.</p>
                     </item>
                     <item>
                        <p>If <var>ST</var> is <code>xs:float</code> or
                                    <code>xs:double</code>, then <var>TV</var> is the
                                    <code>xs:decimal</code> value, within the set of
                                    <code>xs:decimal</code> values that the implementation is
                                    capable of representing, that is numerically closest to
                                    <var>SV</var>. If two values are equally close, then the one
                                    that is closest to zero is chosen. If <var>SV</var> is too
                                    large to be accommodated as an <code>xs:decimal</code>, (see
                                        <bibref ref="xmlschema-2"/> for <termref def="implementation-defined"/> limits on
                           numeric values) a dynamic error is raised <errorref class="CA" code="0001"/>. If <var>SV</var> is one of the special
                                    <code>xs:float</code> or <code>xs:double</code> values
                           <code>NaN</code>, <code>INF</code>, or <code>-INF</code>, a dynamic
                                    error is raised <errorref class="CA" code="0002"/>.</p>
                     </item>
                     <item>
                        <p>If <var>ST</var> is <code>xs:boolean</code>, the result <var>TV</var> is
                                    <code>1.0</code> if <var>SV</var> is
                                    <code>1</code> or <code>true</code> and to <code>0.0</code> if
                                    <var>SV</var> is <code>0</code> or <code>false</code>.
                        The type annotation of the result may be any subtype of <code>xs:decimal</code>
                        whose value space includes the integer values <code>0</code> and <code>1</code>.</p>
                     </item>
                     <item>
                        <p>If <var>ST</var> is <code>xs:untypedAtomic</code>
                                    or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>.</p>
                     </item>
                  </ulist>
               </div4>
               
            </div3>
            <div3 id="casting-to-durations">
               <head>Casting to duration types</head>
               
               <p>This section defines the rules for casting to the primitive duration type <code>xs:duration</code>. 
                  Rules for casting to the derived types
               <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code> 
                  are given in <specref ref="casting-to-duration-subtypes"/>.</p>
               
               
               
               <ulist>
                  <item>
                     <p>If the source value <var>SV</var> is an instance of <code>xs:duration</code>
                        (including instances of subtypes such as <code>xs:yearMonthDuration</code>
                        and <code>xs:dayTimeDuration</code>, then the datum of the result 
                        <var>TV</var> is the same as the datum of <var>SV</var>, and the
                       type annotation is <code>xs:duration</code> or any subtype thereof that
                       includes this datum in its value space (in particular, it <rfc2119>may</rfc2119>
                        be the same as the type annotation of <var>SV</var>).</p>
                  </item>
                  <item>
                     <p>If <var>ST</var> is <code>xs:untypedAtomic</code>
                                or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>.</p>
                  </item>
               </ulist>
 
            </div3>
            <div3 id="casting-to-datetimes">
               <head>Casting to date and time types</head>
               <p>In several situations, casting to date and time types requires the extraction
                        of a component from <var>SV</var> or from the result of
                        <function>fn:current-dateTime</function> and converting it to an
                        <code>xs:string</code>. These conversions must follow certain rules. For
                        example, converting an <code>xs:integer</code> year value requires
                        converting to an <code>xs:string</code> with four or more characters, preceded
                        by a minus sign if the value is negative.</p>
               <p>This document defines four functions to perform these conversions. These
                        functions are for illustrative purposes only and make no recommendations as
                        to style or efficiency.  References to these functions from the following text are not normative.</p>
               <p>The arguments to these functions come from functions defined in this
                        document. Thus, the functions below assume that they are correct and do no
                        range checking on them.</p>
               <eg xml:space="preserve"><![CDATA[
declare function eg:convertYearToString($year as xs:integer) as xs:string {
  let $plusMinus := if ($year >= 0) then "" else "-"
  let $yearString := abs($year) cast as xs:string
  let $length := string-length($yearString)
  return if ($length = 1) then concat($plusMinus, "000", $yearString)
         else if ($length = 2) then concat($plusMinus, "00", $yearString)
         else if ($length = 3) then concat($plusMinus, "0", $yearString)
         else concat($plusMinus, $yearString)
};]]></eg>
               <eg xml:space="preserve"><![CDATA[
declare function eg:convertTo2CharString($value as xs:integer) as xs:string {
  let $string := $value cast as xs:string
  return if (string-length($string) = 1) then concat("0", $string)
         else $string
};]]></eg>
               <eg xml:space="preserve"><![CDATA[
declare function eg:convertSecondsToString($seconds as xs:decimal) as xs:string {
  let $string := $seconds cast as xs:string
  let $intLength := string-length(($seconds cast as xs:integer) cast as xs:string)
  return if ($intLength = 1) then concat("0", $string)
         else $string
};]]></eg>
               <!--Text replaced by erratum E6 change 1"--><eg><![CDATA[
declare function eg:convertTZtoString($tz as xs:dayTimeDuration?) as xs:string {
  if (empty($tz)) then ""
  else if ($tz eq xs:dayTimeDuration('PT0S')) then "Z"
  else let $tzh := hours-from-duration($tz)
       let $tzm := minutes-from-duration($tz)
       let $plusMinus := if ($tzh >= 0) then "+" else "-"
       let $tzhString := eg:convertTo2CharString(abs($tzh))
       let $tzmString := eg:convertTo2CharString(abs($tzm))
       return concat($plusMinus, $tzhString, ":", $tzmString)
};]]></eg>
               <!--End of text replaced by erratum E6--><p>Conversion from 
                  <termref def="dt-primitive-type">primitive types</termref> to date and time types follows the rules below.</p>
               <olist><!--    <item>
                            <p>When a value of any primitive type is cast as
                                <code>xs:dateTime</code>, <code>xs:time</code>,
                                <code>xs:date</code>, <code>xs:gYearMonth</code>,
                                <code>xs:gYear</code>, <code>xs:gMonthDay</code>,
                                <code>xs:gDay</code>, or <code>xs:gMonth</code>,</p>
                            <p> let <emph>CYR</emph> be <code>eg:convertYearToString(
                                    year-from-dateTime( current-dateTime() ))</code>,</p>
                            <p> let <emph>CMO</emph> be <code>eg:convertTo2CharString(
                                    month-from-dateTime( current-dateTime() ))</code>, </p>
                            <p> let <emph>CDA</emph> be <code>eg:convertTo2CharString(
                                    day-from-dateTime( current-dateTime() )) </code>.</p>
                            and </p>
<p>
let <emph>CTZ</emph> be <code>eg:convertTZtoString(
	    timezone-from-dateTime( current-dateTime()
	    )</code>. </p> 
                        </item> --><item>
                     <p>When a value of any primitive type is cast as
                                <code>xs:dateTime</code>, the <code>xs:dateTime</code> value
                                <var>TV</var> is derived from <var>ST</var> and <var>SV</var>
                                as follows:</p>
                     <ulist>
                        <item>
                           <p>If <var>ST</var> is <code>xs:dateTime</code>, then
                                        <var>TV</var> is <var>SV</var>. </p>
                        </item>
                        <!--		<item>
								<p>If <var>ST</var> is <code>xs:time</code>, then let <emph>SHR</emph> be <code>eg:convertTo2CharString( hours-from-time(</code>
									<var>SV</var>	<code>)) </code>, let <emph>SMI</emph> be <code>eg:convertTo2CharString( minutes-from-time(</code>
									<var>SV</var><code>))</code>, let <emph>SSE</emph> be <code>eg:convertSecondsToString( seconds-from-time(</code>
									<var>SV</var><code>))</code> and let <emph>STZ</emph> be <code>eg:convertTZtoString( timezone-from-time(</code><var>SV</var><code>))</code>
; <var>TV</var> is <code>xs:dateTime( concat(</code>
									<emph>CYR</emph>
									<code>, '-', </code>
									<emph>CMO</emph>
									<code>, '-', </code>
									<emph>CDA</emph>
									<code>, 'T', </code>
									<emph>SHR</emph>
									<code>, ':', </code>
									<emph>SMI</emph>
									<code>, ':', </code>
									<emph>SSE, STZ</emph> 
									<code>) )</code>. </p>
							</item> --><item>
                           <p>If <var>ST</var> is <code>xs:date</code>, then let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( year-from-date(</code>
                                        <var>SV</var>
                                        <code>))</code>, let <emph>SMO</emph> be
                                            <code>eg:convertTo2CharString( month-from-date(</code>
                                        <var>SV</var>
                                        <code>))</code>, let <emph>SDA</emph> be
                                            <code>eg:convertTo2CharString( day-from-date(</code>
                                        <var>SV</var>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( timezone-from-date(</code>
                                        <var>SV</var>
                                        <code>))</code>; <var>TV</var> is <code>xs:dateTime( concat(</code>
                                        <emph>SYR</emph>
                                        <code>, '-', </code>
                                        <emph>SMO</emph>
                                        <code>, '-', </code>
                                        <emph>SDA</emph>
                                        <code>, 'T00:00:00 '</code>, <emph>STZ</emph>
                                        <code>) )</code>. </p>
                        </item>
                        <item>
                           <p> If <var>ST</var> is <code>xs:untypedAtomic</code> or
                                        <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>.</p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p>When a value of any primitive type is cast as <code>xs:time</code>,
                                the <code>xs:time</code> value <var>TV</var> is derived from
                                <var>ST</var> and <var>SV</var> as follows:</p>
                     <ulist>
                        <item>
                           <p>If <var>ST</var> is <code>xs:time</code>, then
                                        <var>TV</var> is <var>SV</var>. </p>
                        </item>
                        <item>
                           <p>If <var>ST</var> is <code>xs:dateTime</code>, then
                                        <var>TV</var> is <code>xs:time( concat(
                                            eg:convertTo2CharString( hours-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>)), ':', eg:convertTo2CharString( minutes-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>)), ':', eg:convertSecondsToString( seconds-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>)), eg:convertTZtoString( timezone-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>)) ))</code>. </p>
                        </item>
                        <item>
                           <p> If <var>ST</var> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>. </p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p>When a value of any primitive type is cast as <code>xs:date</code>,
                                the <code>xs:date</code> value <var>TV</var> is derived from
                                <var>ST</var> and <var>SV</var> as follows:</p>
                     <ulist>
                        <item>
                           <p>If <var>ST</var> is <code>xs:date</code>, then
                                        <var>TV</var> is <var>SV</var>. </p>
                        </item>
                        <item>
                           <p>If <var>ST</var> is <code>xs:dateTime</code>, then let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( year-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>))</code>, let <emph>SMO</emph> be
                                            <code>eg:convertTo2CharString( month-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>))</code>, let <emph>SDA</emph> be
                                            <code>eg:convertTo2CharString( day-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>))</code> and let <emph>STZ</emph> be <code>eg:convertTZtoString(timezone-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>))</code>; <var>TV</var> is <code>xs:date( concat(</code>
                                        <emph>SYR</emph>
                                        <code>, '-', </code>
                                        <emph>SMO</emph>
                                        <code>, '-', </code>
                                        <emph>SDA</emph>, <emph>STZ</emph>
                                        <code>) )</code>. </p>
                        </item>
                        <item>
                           <p> If <var>ST</var> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>. </p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p>When a value of any primitive type is cast as
                                <code>xs:gYearMonth</code>, the <code>xs:gYearMonth</code> value
                                <var>TV</var> is derived from <var>ST</var> and <var>SV</var>
                                as follows:</p>
                     <ulist>
                        <item>
                           <p>If <var>ST</var> is <code>xs:gYearMonth</code>, then
                                        <var>TV</var> is <var>SV</var>. </p>
                        </item>
                        <item>
                           <p>If <var>ST</var> is <code>xs:dateTime</code>, then let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( year-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>))</code>, let <emph>SMO</emph> be
                                            <code>eg:convertTo2CharString( month-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( timezone-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>))</code>; <var>TV</var> is <code>xs:gYearMonth( concat(</code>
                                        <emph>SYR</emph>
                                        <code>, '-', </code>
                                        <emph>SMO</emph>, <emph>STZ</emph>
                                        <code>) )</code>. </p>
                        </item>
                        <item>
                           <p>If <var>ST</var> is <code>xs:date</code>, then let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( year-from-date(</code>
                                        <var>SV</var>
                                        <code>))</code>, let <emph>SMO</emph> be
                                            <code>eg:convertTo2CharString( month-from-date(</code>
                                        <var>SV</var>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( timezone-from-date(</code>
                                        <var>SV</var>
                                        <code>))</code>; <var>TV</var> is <code>xs:gYearMonth( concat(</code>
                                        <emph>SYR</emph>
                                        <code>, '-', </code>
                                        <emph>SMO</emph>, <emph>STZ</emph>
                                        <code>) )</code>. </p>
                        </item>
                        <item>
                           <p> If <var>ST</var> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>. </p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p>When a value of any primitive type is cast as <code>xs:gYear</code>,
                                the <code>xs:gYear</code> value <var>TV</var> is derived from
                                <var>ST</var> and <var>SV</var> as follows:</p>
                     <ulist>
                        <item>
                           <p>If <var>ST</var> is <code>xs:gYear</code>, then
                                        <var>TV</var> is <var>SV</var>. </p>
                        </item>
                        <item>
                           <p>If <var>ST</var> is <code>xs:dateTime</code>, let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( year-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( timezone-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>))</code>; <var>TV</var> is <code>xs:gYear(concat(</code>
                                        <emph>SYR</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p>
                        </item>
                        <item>
                           <p>If <var>ST</var> is <code>xs:date</code>, let
                                        <emph>SYR</emph> be <code>eg:convertYearToString( year-from-date(</code>
                                        <var>SV</var>
                                        <code>))</code>; and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( timezone-from-date(</code>
                                        <var>SV</var>
                                        <code>))</code>; <var>TV</var> is <code>xs:gYear(concat(</code>
                                        <emph>SYR</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p>
                        </item>
                        <item>
                           <p> If <var>ST</var> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>. </p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p>When a value of any primitive type is cast as
                                <code>xs:gMonthDay</code>, the <code>xs:gMonthDay</code> value
                                <var>TV</var> is derived from <var>ST</var> and <var>SV</var>
                                as follows:</p>
                     <ulist>
                        <item>
                           <p>If <var>ST</var> is <code>xs:gMonthDay</code>, then
                                        <var>TV</var> is <var>SV</var>. </p>
                        </item>
                        <item>
                           <p>If <var>ST</var> is <code>xs:dateTime</code>, then let
                                        <emph>SMO</emph> be <code>eg:convertTo2CharString( month-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>))</code>, let <emph>SDA</emph> be
                                            <code>eg:convertTo2CharString( day-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( timezone-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>))</code>; <var>TV</var> is <code>xs:gYearMonth( concat(</code>
                                        <code> '--', </code>
                                        <emph>SMO</emph>
                                        <code> '-', </code>
                                        <emph>SDA</emph>, <emph>STZ</emph>
                                        <code>) )</code>. </p>
                        </item>
                        <item>
                           <p>If <var>ST</var> is <code>xs:date</code>, then let
                                        <emph>SMO</emph> be <code>eg:convertTo2CharString( month-from-date(</code>
                                        <var>SV</var>
                                        <code>))</code>, let <emph>SDA</emph> be
                                            <code>eg:convertTo2CharString( day-from-date(</code>
                                        <var>SV</var>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( timezone-from-date(</code>
                                        <var>SV</var>
                                        <code>))</code>; <var>TV</var> is <code>xs:gYearMonth( concat(</code>
                                        <code> '--', </code>
                                        <emph>SMO</emph>
                                        <code>, '-', </code>
                                        <emph>SDA</emph>, <emph>STZ</emph>
                                        <code>) )</code>. </p>
                        </item>
                        <item>
                           <p> If <var>ST</var> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>.</p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p>When a value of any primitive type is cast as <code>xs:gDay</code>,
                                the <code>xs:gDay</code> value <var>TV</var> is derived from
                                <var>ST</var> and <var>SV</var> as follows:</p>
                     <ulist>
                        <item>
                           <p>If <var>ST</var> is <code>xs:gDay</code>, then
                                        <var>TV</var> is <var>SV</var>. </p>
                        </item>
                        <item>
                           <p>If <var>ST</var> is <code>xs:dateTime</code>, then let
                                        <emph>SDA</emph> be <code>eg:convertTo2CharString( day-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( timezone-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>))</code>; <var>TV</var> is <code>xs:gDay(
                                            concat( '---'</code>, <emph>SDA</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p>
                        </item>
                        <item>
                           <p>If <var>ST</var> is <code>xs:date</code>, then let
                                        <emph>SDA</emph> be <code>eg:convertTo2CharString( day-from-date(</code>
                                        <var>SV</var>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( timezone-from-date(</code>
                                        <var>SV</var>
                                        <code>))</code>; <var>TV</var> is <code>xs:gDay(
                                            concat( '---'</code>, <emph>SDA</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p>
                        </item>
                        <item>
                           <p> If <var>ST</var> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>. </p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p>When a value of any primitive type is cast as <code>xs:gMonth</code>,
                                the <code>xs:gMonth</code> value <var>TV</var> is derived from
                                <var>ST</var> and <var>SV</var> as follows:</p>
                     <ulist>
                        <item>
                           <p>If <var>ST</var> is <code>xs:gMonth</code>, then
                                        <var>TV</var> is <var>SV</var>. </p>
                        </item>
                        <item>
                           <p>If <var>ST</var> is <code>xs:dateTime</code>, then let
                                        <emph>SMO</emph> be <code>eg:convertTo2CharString( month-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( timezone-from-dateTime(</code>
                                        <var>SV</var>
                                        <code>))</code>; <var>TV</var> is <code>xs:gMonth(
                                            concat( '--' </code>, <emph>SMO</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p>
                        </item>
                        <item>
                           <p>If <var>ST</var> is <code>xs:date</code>, then let
                                        <emph>SMO</emph> be <code>eg:convertTo2CharString( month-from-date(</code>
                                        <var>SV</var>
                                        <code>))</code> and let <emph>STZ</emph> be
                                            <code>eg:convertTZtoString( timezone-from-date(</code>
                                        <var>SV</var>
                                        <code>))</code>; <var>TV</var> is <code>xs:gMonth(
                                            concat( '--'</code>, <emph>SMO</emph>, <emph>STZ</emph>
                                        <code>))</code>. </p>
                        </item>
                        <item>
                           <p> If <var>ST</var> is <code>xs:untypedAtomic</code>
                                        or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>.</p>
                        </item>
                     </ulist>
                  </item>
               </olist>
            </div3>
            <div3 id="casting-boolean">
               <head>Casting to <code>xs:boolean</code></head>
               <p>When the target type <var>TT</var> is <code>xs:boolean</code>, the
                        resulting <code>xs:boolean</code> value <var>TV</var> is derived from
                        the source value <var>SV</var> as follows:</p>
               <ulist>
                  <item>
                     <p>If <var>SV</var> is an instance of <code>xs:boolean</code>, then <var>TV</var>
                                is <var>SV</var>.</p>
                  </item>
                  <item>
                     <p>If <var>SV</var> is an instance of <code>xs:numeric</code> and
                                <var>SV</var> is <code>0</code>, <code>+0</code>, <code>-0</code>,
                                <code>0.0</code>, <code>0.0E0</code> or <code>NaN</code>, then
                                <var>TV</var> is <code>false</code>. </p>
                  </item>
                  <item>
                     <p>If <var>ST</var> is is an instance of <code>xs:numeric</code> and
                                <var>SV</var> is not one of the above values, then <var>TV</var>
                                is <code>true</code>. </p>
                  </item>
                  <item>
                     <p> If <var>ST</var> is <code>xs:untypedAtomic</code>
                                or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>. </p>
                  </item>
               </ulist>
            </div3>
            <div3 id="casting-to-binary">
               <head>Casting to <code>xs:base64Binary</code> and <code>xs:hexBinary</code></head>
               <p>Values of type <code>xs:base64Binary</code> can be cast as
                        <code>xs:hexBinary</code> and vice versa, since the two types have the same
                        value space. Casting to <code>xs:base64Binary</code> and
                        <code>xs:hexBinary</code> is also supported from the same type and from
                        <code>xs:untypedAtomic</code>, <code>xs:string</code> and subtypes of
                        <code>xs:string</code> using <bibref ref="xmlschema-2"/> semantics.</p>
            </div3>
            <div3 id="casting-to-anyuri">
               <head>Casting to xs:anyURI</head>
               <p>Casting to <code>xs:anyURI</code> is supported only from the same type,
                        <code>xs:untypedAtomic</code> or <code>xs:string</code>.</p>
               <p>When a value of any <termref def="dt-primitive-type">primitive type</termref> is cast as <code>xs:anyURI</code>, the
                        <code>xs:anyURI</code> value <var>TV</var> is derived from the
                        <var>ST</var> and <var>SV</var> as follows:</p>
               <ulist>
                  <item>
                     <p>If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code> see 
                                    <specref ref="casting-from-strings"/>.
                             </p>
                  </item>
               </ulist>
            </div3>
            <div3 id="casting-to-qname-and-notation">
               <head>Casting to xs:QName and xs:NOTATION</head>
               <p>Casting from <code>xs:string</code> or <code>xs:untypedAtomic</code> to
                  <code>xs:QName</code> or <code>xs:NOTATION</code> is described in 
                  <specref ref="casting-from-strings"/>.</p>
               <p>It is also possible to cast from <code>xs:NOTATION</code> to <code>xs:QName</code>, 
                  or from <code>xs:QName</code> to
                  any type derived by restriction from <code>xs:NOTATION</code>. (Casting to <code>xs:NOTATION</code>
                  itself is not allowed, because <code>xs:NOTATION</code> is an abstract type.) The resulting
                  <code>xs:QName</code> or <code>xs:NOTATION</code> has the same prefix, local name, and namespace URI
                  parts as the supplied value.</p>
               <note><p>See <specref ref="constructor-qname-notation"/> for a discussion of how the combination of
               atomization and casting might not produce the desired effect.</p></note>
            </div3>
            <div3 id="casting-to-ENTITY">
               <head>Casting to xs:ENTITY</head>
               <p>
                  <bibref ref="xmlschema-2"/> says that <quote>The
                     value space of ENTITY is the set of all strings that match the 
                     NCName production ... and have been
                     declared as an unparsed entity in a document type definition.</quote>
                  However,
                  <bibref ref="xslt-40"/> and <bibref ref="xquery-40"/> do not check that constructed values of type <code>xs:ENTITY</code> match declared unparsed entities.  Thus, this rule is relaxed in this specification and, in casting to <code>xs:ENTITY</code> and types derived from it, no check is made that the values correspond to declared unparsed entities.
               </p>
            </div3>
         </div2>
         <div2 id="casting-from-strings">
            <head>Casting from xs:string and xs:untypedAtomic</head>
            <changes>
               <change issue="1089" PR="1090" date="2024-03-19">
                  When casting from a string to a duration or time or dateTime, it is now specified that when there are more
                  digits in the fractional seconds than the implementation is able to retain, excess digits are truncated.
                  Rounding upwards (which could affect the number of minutes or hours in the value) is not permitted. 
               </change>
            </changes>
            <p>This section applies when the supplied value <var>SV</var>
               is an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>,
               including types derived from these by restriction. If the value is
               <code>xs:untypedAtomic</code>, it is treated in exactly the same way as a
               string containing the same sequence of characters.</p>
            
            <p>The supplied string is mapped to a typed value of the target type as defined in <bibref ref="xmlschema-2"/>. 
               Whitespace normalization is applied as indicated by the
               <code>whiteSpace</code> facet for the datatype. The resulting whitespace-normalized string 
               must be a valid lexical form for the datatype.  The semantics of casting follow the rules of
               XML Schema validation.  For example, <code>"13" cast as xs:unsignedInt</code> returns 
               the <code>xs:unsignedInt</code> typed 
               value <code>13</code>. This could also be written <code>xs:unsignedInt("13")</code>.</p>
            
            <p>The target type can be any simple type other than an
               abstract type. Specifically, it can be a type whose variety is atomic, union, or list.
               In each case the effect of casting to the target type is the same as constructing an element
               with the supplied value as its content, validating the element using the target type as
               the governing type, and atomizing the element to obtain its typed value.</p>
            
            <p>When the target type is a derived type that is restricted by a pattern facet, the
               lexical form is first checked against the pattern before further casting
               is attempted (See <specref ref="casting-to-derived-types"/>).  If the lexical form does
               not conform to the pattern, a dynamic 
               error <errorref class="RG" code="0001" type="dynamic"/> is raised.</p> 
            
            <p>For example, consider a user-defined type <code>my:boolean</code> which is derived by
               restriction from <code>xs:boolean</code> and specifies the pattern facet <code>value="0|1"</code>.
               The expression <code>"true" cast as my:boolean</code> would fail with a dynamic
               error <errorref class="RG" code="0001" type="dynamic"/>.</p>
            
            <p>Facets other than <code>pattern</code> are checked <emph>after</emph> the conversion.
               For example if there is a user-defined datatype called <code>my:height</code> 
               defined as a restriction of <code>xs:integer</code> with the facet <code>&lt;maxInclusive value="84"/></code>,
               then the expression <code>"100" cast as my:height</code> would fail with a dynamic
               error <errorref class="RG" code="0001" type="dynamic"/>.</p>
            
            <p>Casting to the types <code>xs:NOTATION</code>, <code>xs:anySimpleType</code>, 
               or <code>xs:anyAtomicType</code> is not permitted because these types are abstract (they have
               no immediate instances).</p>
            
            <p>Special rules apply when casting to namespace-sensitive types. The types <code>xs:QName</code>
               and <code>xs:NOTATION</code> are namespace-sensitive. Any type derived by restriction from 
               a namespace-sensitive type is itself namespace-sensitive, as is any union type having a
               namespace-sensitive type among its members, and any list type having a namespace-sensitive type
               as its item type. For details, see <specref ref="constructor-qname-notation"/>.</p>
            
            <note><p>Since version 3.0 of this specification, casting has been allowed between <code>xs:QName</code>
               and <code>xs:NOTATION</code> in either direction; this was not permitted in previous Recommendations. Version 3.0 also removed
               the rule that only a string literal (rather than a dynamic string) may be cast to an <code>xs:QName</code></p></note>
            
            <p>When casting to a numeric type:</p>
            <ulist>
               <item><p>If the value is too large or too small to be accurately represented by the implementation, 
                  it is handled as an overflow or underflow as defined in <specref ref="op.numeric"/>.</p></item>
               <item><p>If the target type is <code>xs:float</code> or <code>xs:double</code>, the string <code>-0</code> (and equivalents
                  such as <code>-0.0</code> or <code>-000</code>) <rfc2119>should</rfc2119> be converted to the value negative zero.
                  However, if the implementation is reliant on an implementation of XML Schema 1.0 in which negative zero
                  is not part of the value space for these types, these lexical forms <rfc2119>may</rfc2119> be converted to positive zero.</p></item>
            </ulist>
            <p>
               In casting to <code>xs:decimal</code> or to a type derived from <code>xs:decimal</code>, 
               if the value is not too large or too small but nevertheless cannot be represented accurately 
               with the number of decimal digits available to the implementation, the implementation may round 
               to the nearest representable value or may raise a dynamic error <errorref class="CA" code="0006" type="dynamic"/>. 
               The choice of rounding algorithm and the choice between rounding and error behavior is 
               <termref def="implementation-defined"/>.
            </p>
            <p>When casting to <code>xs:duration</code>, <code>xs:dateTime</code>, or <code>xs:time</code>,
            if the seconds component has more fractional digits than are supported by the implementation,
            excess digits <rfc2119>must</rfc2119> be truncated. This rule ensures that components
            other than the seconds component are unaffected: for example <code>xs:dateTime('2023-12-31T23:59:59.999999999')</code>
            is guaranteed to deliver an <code>xs:dateTime</code> value whose year component is 2023 rather than 2024.</p>
            
            <note><p>Implementations are required to support millisecond precision or greater.</p></note>
            
            <p>In casting to <code>xs:date</code>, <code>xs:dateTime</code>, <code>xs:gYear</code>, 
               or <code>xs:gYearMonth</code> 
               (or types derived from these), if the value is too large or too 
               small to be represented by the implementation, a dynamic error 
               <errorref class="DT" code="0001" type="dynamic"/> is raised.</p>
            <p>In casting to a duration value, if the value is too large or too small to be represented by the 
               implementation, a dynamic error <errorref class="DT" code="0002" type="dynamic"/> is raised.</p>
            <p> For <code>xs:anyURI</code>, the extent to which an implementation validates the
               lexical form of <code>xs:anyURI</code> is <termref def="implementation-dependent"/>.</p>
            <p>If the cast fails for any other reason, a dynamic error
               <errorref class="RG" code="0001" type="dynamic"/> is raised.</p>
            

            
            
         </div2>
         
         <div2 id="casting-non-primitive-types">
            <head>Casting involving non-primitive types</head>
            
            <p>Casting from <code>xs:string</code> and <code>xs:untypedAtomic</code> to any other type
            (primitive or non-primitive) has been described in <specref ref="casting-from-strings"/>.
            This section defines how other casts to non-primitive types operate, including casting
            to types derived by restriction, to union types, and to list types.</p>
            
            
         
         <div3 id="casting-to-derived-types">
            
            <head>Casting to derived types</head>
            <p>Casting a value to a derived type can be separated into a number of cases. In these rules:</p>
            <ulist>
               <item><p>The types <code>xs:integer</code>, <code>xs:yearMonthDuration</code>,
               and <code>xs:dayTimeDuration</code> are treated as quasi-primitive types 
                  (alongside the 20 truly <termref def="dt-primitive-type">primitive types</termref>).</p></item>
               <item><p>For any atomic type <var>T</var>, let <var>P(T)</var> denote the most specific primitive or quasi-primitive type
               such that <code>itemType-subtype(T, P(T))</code> is <code>true</code>.</p></item>
            </ulist>
            <p>The rules are then:</p>
            <olist>
               <item>
                  <p>When the source type <var>ST</var> is the same type as the target type <var>TT</var>: 
                     this case always succeeds, returning the source value <var>SV</var> unchanged.</p>
               </item>
               <item>
                  <p>When <code>itemType-subtype(ST, TT)</code> is <code>true</code>: 
                     see <specref ref="casting-from-derived-to-parent"/>. </p>
               </item>
               <item>
                  <p>When <var>TT</var> is the quasi-primitive type <code>xs:integer</code> 
                     and <code>SV</code> is an instance of <code>xs:numeric</code>:
                  see <specref ref="casting-to-integer"/>.</p>
               </item>
               <item>
                  <p>When <var>TT</var> is the quasi-primitive type <code>xs:yearMonthDuration</code> 
                     or <code>xs:dayTimeDuration</code> and <code>SV</code> is an instance of <code>xs:duration</code>:
                  see <specref ref="casting-to-duration-subtypes"/>.</p>
               </item>
               <item>
                  <p>When <var>P(ST)</var> is the same type as <var>P(TT)</var>: 
                     see <specref ref="casting-within-branch"/>.</p>
               </item>
               <item>
                  <p>Otherwise (<var>P(ST)</var> is not the same type as <var>P(TT)</var>): 
                     see <specref ref="casting-across-hierarchy"/>.</p>
               </item>
            </olist>
         </div3>
            
         <div3 id="casting-to-integer">
                  <head>Casting to xs:integer</head>
                  <p>When an atomic item <code>SV</code> is cast as <code>xs:integer</code>, the
                            resulting <code>xs:integer</code> value <var>TV</var> is obtained as follows:</p>
                  <ulist>
 <!--                    <item>
                        <p>If <var>ST</var> is <code>xs:integer</code>, or a type derived
                                    from <code>xs:integer</code>, then the <termref def="dt-datum"/> of <var>TV</var> is
                                    the same as the datum of <var>SV</var>, and the type annotation
                           of <var>TV</var> is <code>xs:integer</code> or any subtype of <code>xs:integer</code>
                           that includes this datum in its value space (in particular, the original type annotation
                        of <code>SV</code> <rfc2119>may</rfc2119> be retained).</p>
                     </item>-->
                     <item>
                        <p>If <var>ST</var> is
                                    <code>xs:decimal</code>, <code>xs:float</code> or
                                    <code>xs:double</code>, then <var>TV</var> is <var>SV</var>
                                    with the fractional part discarded and the value converted to
                                    <code>xs:integer</code>. Thus, casting <code>3.1456</code>
                                    returns <code>3</code> while <code>-17.89</code> returns
                                    <code>-17</code>. Casting <code>3.124E1</code>
                                    returns <code>31</code>. If <var>SV</var> is too large to be
                                    accommodated as an integer, (see <bibref ref="xmlschema-2"/> for
                           <termref def="implementation-defined"/> limits on numeric values) a 
                           dynamic error is
                                    raised <errorref class="CA" code="0003"/>. If <var>SV</var> is
                                    one of the special <code>xs:float</code> or
                                    <code>xs:double</code> values <code>NaN</code>,
                           <code>INF</code>, or <code>-INF</code>, a dynamic error is raised
                                        <errorref class="CA" code="0002"/>.</p>
                     </item>
                     <item>
                        <p>In all other cases, the general rules of <specref ref="casting-to-derived-types"/> apply.</p>
                     </item>
                     <!--<item>
                        <p>If <var>ST</var> is <code>xs:boolean</code>, <var>SV</var> is
                                    converted to <code>1</code> if <var>SV</var> is <code>1</code>
                                    or <code>true</code> and to <code>0</code> if <var>SV</var> is
                                    <code>0</code> or <code>false</code> and the conversion is complete.</p>
                     </item>
                     <item>
                        <p>If <var>ST</var> is <code>xs:untypedAtomic</code>
                                    or <code>xs:string</code>, see 
                                    <specref ref="casting-from-strings"/>.</p>
                     </item>-->
                     </ulist>
            <note><p>When casting to a subtype of <code>xs:integer</code> (for example, <code>xs:long</code>), the 
            rules in <specref ref="casting-to-derived-types"/> apply. Note, however, that these rules
            treat <code>xs:integer</code> as a quasi-primitive type.</p></note>
               </div3>
            
            <div3 id="casting-to-duration-subtypes">
               <head>Casting to <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code></head>
               
               <p>When the source value <var>SV</var> is an instance of <code>xs:duration</code> (including
               any subtype of <code>xs:duration</code>), then:</p>
               
               <ulist>
                  <item><p>If the target type <var>TT</var> is <code>xs:yearMonthDuration</code>, the result
                  is an instance of <code>xs:yearMonthDuration</code> whose <code>months</code> component
                  is equal to the <code>months</code> component of <var>SV</var>. The <code>seconds</code>
                  component of <var>SV</var> is ignored.</p></item>
                  <item><p>If the target type <var>TT</var> is <code>xs:dayTimeDuration</code>, the result
                  is an instance of <code>xs:dayTimeDuration</code> whose <code>seconds</code> component
                  is equal to the <code>seconds</code> component of <var>SV</var>. The <code>months</code>
                  component of <var>SV</var> is ignored.</p></item>
               </ulist>
               
               <p>In all other cases, the general rules of <specref ref="casting-to-derived-types"/> apply.</p>
               
               <note>
                  <p>In general, casting to <code>xs:yearMonthDuration</code> or <code>xs:dayTimeDuration</code>
                  loses information.</p>
               </note>
               
               
               <note><p>When casting to a subtype of <code>xs:dayTimeDuration</code> or 
                  <code>xs:yearMonthDuration</code>, the 
            rules in <specref ref="casting-to-derived-types"/> apply. Note, however, that these rules
            treat <code>xs:dayTimeDuration</code> and <code>xs:yearMonthDuration</code> as quasi-primitive types.</p></note>
               
               
            </div3>
            
         <div3 id="casting-from-derived-to-parent">
            <head>Casting from derived types to parent types</head>
            
            <p>
               It is always possible to cast an atomic item <var>A</var> to a type <var>T</var>
               if the relation <code>A instance of T</code> is true, provided that <var>T</var>
               is not an abstract type.
            </p>
            <p>For example, it is
              possible to cast an <code>xs:unsignedShort</code> to an
              <code>xs:unsignedInt</code>, to an <code>xs:integer</code>, to an
              <code>xs:decimal</code>, or to a union type
              whose member types are <code>xs:integer</code> and <code>xs:double</code>.</p> 
              <p>Since the value space of the original type is a subset
              of the value space of the target type, such a cast is always successful.</p> 
            <p>For the expression <code>A instance of T</code> to be true, <var>T</var> must be
               either an atomic type, or a union type that has no constraining facets. It cannot
               be a list type, nor a union type derived by restriction from another union type, nor
               a union type that has a list type among its member types.</p>
            <p>The
            result will have the same value as the original, but will have a new type annotation:</p>
            <ulist>
               <item><p>If <var>T</var> is an atomic type, then the type annotation of the result is <code>T</code>.
               </p></item>
               <item><p>If <var>T</var> is a union type, then the type of the result is an atomic type <code>M</code>
                  such that <var>M</var> is one of the atomic types in the transitive membership of
                  the union type <var>T</var> and <code>A instance of M</code> is true; if there is more
                  than one type <var>M</var> that satisfies these conditions (which could happen, for example,
                  if <var>T</var> is the union of two overlapping types such as <code>xs:int</code>
                  and <code>xs:positiveInteger</code>) then the first one is used, taking the member types
                  in the order in which they appear within the definition of the union type.</p></item>
            </ulist>
              
         </div3>
         <div3 id="casting-within-branch">
            <head>Casting within a branch of the type hierarchy</head>
            <p>It is possible to cast an <var>SV</var> to a <var>TT</var> if the type of the
                    <var>SV</var> and the <var>TT</var> type are both derived by restriction
               (directly or indirectly) from the same <termref def="dt-primitive-type">primitive type</termref>, provided that the
                    supplied value conforms to the constraints implied by the facets of the target
                    type.  This includes the case where the target type is derived from the type of the supplied value,
                    as well as the case where the type of the supplied value is derived from the target type.  For example, an instance of <code>xs:byte</code> can be cast as
                    <code>xs:unsignedShort</code>, provided the value is not negative.  </p>
            <p>If the value does not conform to the facets defined for the target type, then a dynamic
                    error is raised <errorref class="RG" code="0001"/>. See <bibref ref="xmlschema-2"/>.
                    In the case of the pattern facet (which applies to the lexical space rather than
                    the value space), the pattern is tested against the canonical 
                    representation of the value, as defined for the source type (or the result
                    of casting the value to an <code>xs:string</code>, in the case of types that have no canonical
                     representation defined for them).</p>
            <p>Note that this will cause casts to fail if the pattern excludes the canonical
                    lexical representation of the source type. For example, if the type
                    <code>my:distance</code> is defined as a restriction of <code>xs:decimal</code>
                    with a pattern that requires two digits after the decimal point, casting of an
                    <code>xs:integer</code> to <code>my:distance</code> will always fail, because
                    the canonical representation of an <code>xs:integer</code> does not conform to
                    this pattern.</p>
            <p>In some cases, casting from a parent type to a derived type requires special
                    rules. See <specref ref="casting-to-durations"/> for rules regarding casting to
                    <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code>.  See <specref ref="casting-to-ENTITY"/>, below, for casting to <code>xs:ENTITY</code> and types derived from it.</p>
            
         </div3>
         <div3 id="casting-across-hierarchy">
            <head>Casting across the type hierarchy</head>
            <p>When the <var>ST</var> and the <var>TT</var> are derived, directly or
               indirectly, from different <termref def="dt-primitive-type">primitive types</termref>, this is called casting across the
                    type hierarchy. Casting across the type hierarchy is logically equivalent to
                    three separate steps performed in order. Errors can occur in either of the
                    latter two steps.</p>
            <olist>
               <item>
                  <p>Cast the <var>SV</var>, up the hierarchy, to the <termref def="dt-primitive-type">primitive type</termref> of the
                            source, as described in <specref ref="casting-from-derived-to-parent"/>.</p>
                  <olist>
                     <item>
                        <p>
If <var>SV</var> is an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>, check its value against the 
                           pattern facet of <var>TT</var>, and raise a dynamic error <errorref class="RG" code="0001"/> if the check fails.</p>
                     </item>
                  </olist>
               </item>
               <item>
                  <p>Let <var>P(TT)</var> be the most specific primitive or quasi-primitive type of which <var>TT</var>
                  is a subtype, as described in <specref ref="casting-to-derived-types"/>.</p>
                  <p>Cast the value to <var>P(TT)</var>, as described in
                                <specref ref="casting-from-primitive-to-primitive"/> if <var>P(TT)</var>
                     is primitive, or as described in <specref ref="casting-to-derived-types"/> if <var>P(TT)</var>
                     is quasi-primitive.</p>

                        <p>If <var>TT</var> is derived from <code>xs:NOTATION</code>, assume for the
                        purposes of this rule that casting to <code>xs:NOTATION</code> succeeds.</p>
               </item>
               <item>
                  <p>Cast the value down to the target type <var>TT</var>, as described in <specref ref="casting-within-branch"/>
                        </p>
               </item>
            </olist>
         </div3>
         <div3 id="casting-to-union">
            <head>Casting to union types</head>
            <p>If the target type of a cast expression (or a constructor function) is a type with variety union, the
               supplied value must be one of the following:</p>
            
            <olist>
               <item><p>A value of type <code>xs:string</code> or <code>xs:untypedAtomic</code>.
               This case follows the general rules for casting from strings, and has already been
               described in <specref ref="casting-from-strings"/>.</p>
               
                  <p>If the union type has a pattern facet, the pattern is tested against the supplied
                     value after whitespace normalization, using the <code>whiteSpace</code>
                     normalization rules of the member datatype against which validation succeeds.</p>
               </item>
               <item><p>A value that is an instance of one of the atomic types in the transitive
               membership of the union type, and of the union type itself. This case has already been described in
               <specref ref="casting-from-derived-to-parent"/></p>
               
                  <p>This situation only applies when the value is an instance of the union type,
                  which means it will never apply when the union is derived by facet-based restriction
                  from another union type.</p>
                  
               </item>
               <item><p>A value that is castable to one or more of the atomic types in the transitive membership
                  of the union type (in the sense that the <code>castable as</code> operator returns <code>true</code>).</p>
                  <p>In this case the supplied value is cast to each atomic type in the transitive membership
                     of the union type in turn (in the order in which the member types appear in the declaration)
                     until one of these casts is successful; if none of them is successful, a dynamic error occurs
                     <errorref class="RG" code="0001"/>. If the union type has constraining facets then the
                     resulting value must satisfy these facets, otherwise a dynamic error occurs 
                     <errorref class="RG" code="0001"/>.</p>
                  
                  <p>If the union type has a pattern facet, the pattern is tested against the canonical
                  representation of the result value.</p>
                  
                  <p>Only the atomic types in the transitive membership of the union type are considered. The
                  union type may have list types in its transitive membership, but (unless the supplied value
                  is of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, in which case the
                  rules in <specref ref="casting-from-strings"/> apply), any list types in the membership
                  are effectively ignored.</p>
               </item>
               
            </olist>
            
            <p>If more than one of these conditions applies, then the casting is done according to the rules
            for the first condition that applies.</p>
            
            <p>If none of these conditions applies, the cast fails with a dynamic error
            <errorref class="RG" code="0001"/>.</p>          
            
            <p>Example: consider a type <var>U</var> whose member types are <code>xs:integer</code>
               and <code>xs:date</code>.</p>
            
               <ulist>
                  <item><p>The expression <code>"123" cast as U</code> returns the
                  <code>xs:integer</code> value <code>123</code>.</p></item>
                  <item><p>The expression <code>current-date() cast as U</code> returns
                     the current date as an instance of <code>xs:date</code>.</p></item>
                  <item><p>The expression <code>23.1 cast as U</code> returns the <code>xs:integer</code>
                  value <code>23</code>.</p></item>
               </ulist>
      
            
            <p>Example: consider a type <var>V</var> whose member types are <code>xs:short</code>
               and <code>xs:negativeInteger</code>.</p>
            
            <ulist>
               <item><p>The expression <code>"-123" cast as V</code> returns the
                  <code>xs:short</code> value <code>-123</code>.</p></item>
               <item><p>The expression <code>"-100000" cast as V</code> returns the
                  <code>xs:negativeInteger</code> value <code>-100000</code>.</p></item>
               <item><p>The expression <code>93.7 cast as V</code> returns the
                  <code>xs:short</code> value <code>93</code>.</p></item>
               <item><p>The expression <code>"93.7" cast as V</code> raises
                  a dynamic error <errorref class="RG" code="0001"/> on the grounds that the string
               <code>"93.7"</code> is not in the lexical space of the union type.</p></item>
     
            </ulist>
            
  
  
            <p>Example: consider a type <var>W</var> that is derived from the above type <var>V</var>
               by restriction, with a pattern facet of <code>-?\d\d</code>.</p>
               
               <ulist>
                  <item><p>The expression <code>"12" cast as V</code> returns the
                     <code>xs:short</code> value <code>12</code>.</p></item>
                  <item><p>The expression <code>"123" cast as V</code> raises
                     an dynamic error <errorref class="RG" code="0001"/> on the grounds that the string
                     <code>"123"</code> does not match the pattern facet.</p></item>
                  
               </ulist>   
               

         </div3>
         <div3 id="casting-to-list">
            <head>Casting to list types</head>
            <p>If the target type of a cast expression (or a constructor function) is a
            type with variety <code>list</code>, the supplied value must be of type <code>xs:string</code> or
            <code>xs:untypedAtomic</code>. The rules follow the general principle for
            all casts from <code>xs:string</code> outlined in <specref ref="casting-from-strings"/>.</p>
            
            <p diff="add" at="issue687">If the supplied value is not of type <code>xs:string</code> or
               <code>xs:untypedAtomic</code>, a type error is raised 
               <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
            
            <p>The semantics of the operation are consistent with validation: that is,
            the effect of casting a string <var>S</var> to a list type <var>L</var> is the same as
            constructing an element or attribute node whose string value is <var>S</var>,
            validating it using <var>L</var> as the governing type, and atomizing the resulting
            node. The result will always be either failure, or a sequence of zero or
            more atomic items each of which is an instance of the item type of <var>L</var>
            (or if the item type of <var>L</var> is a union type, an instance of one of the
            atomic types in its transitive membership).</p>
            
            <p>If the item type of the list type is namespace-sensitive, then the 
               namespace bindings in the static context will be used to
            resolve any namespace prefix, in the same way as when the target type is
            <code>xs:QName</code>.</p>
            
            <p>If the list type has a <code>pattern</code> facet, the pattern must match
            the supplied value after collapsing whitespace (an operation equivalent to the
            use of the <function>fn:normalize-space</function> function).</p>
            
            <p>For example, the expression <code>cast "A B C D" as xs:NMTOKENS</code>
            produces a sequence of four <code>xs:NMTOKEN</code> values, 
            <code>("A", "B", "C", "D")</code>.</p>
            
            <p>For example, given a user-defined type <code>my:coordinates</code> defined
            as a list of <code>xs:integer</code> with the facet <code>&lt;xs:length value="2"/></code>,
            the expression <code>my:coordinates("2 -1")</code> will return a sequence of two
            xs:integer values <code>(2, -1)</code>, while the expression <code>my:coordinates("1 2 3")</code>
            will result in a dynamic error because the length of the list does not conform to the
            <code>length</code> facet. The expression <code>my:coordinates("1.0 3.0")</code>
            will also fail because the strings <code>1.0</code> and <code>3.0</code> 
               are not in the lexical space of <code>xs:integer</code>.</p>
            

         </div3>
         </div2>
      </div1>
   </body>
   <back>
      <div1 id="biblio">
         <head>References</head>
         <div2 id="normative-biblio">
            <head>Normative references</head>
            <blist>
 
               
               
               <bibl id="charmod" key="Character Model for the World Wide Web 1.0: Fundamentals">
                  <titleref href="https://www.w3.org/TR/charmod/"
                     >Character Model for the World Wide Web 1.0:
                     Fundamentals</titleref>,
                  Martin J. Dürst, François Yergeau, <emph>et. al.</emph>, Editors.
                  World Wide Web Consortium,
                  15 February 2015.
                  This version is http://www.w3.org/TR/2005/REC-charmod-20050215/.
                  The <loc href="https://www.w3.org/TR/charmod/">latest version</loc>
                  is available at https://www.w3.org/TR/charmod/.</bibl>
               
               <bibl id="html5" key="HTML: Living Standard">
                  <titleref href="https://html.spec.whatwg.org/">HTML: Living Standard</titleref>.
                  WHATWG,
                  18 November 2022.</bibl>

               <bibl id="dom-ls" key="DOM: Living Standard">
                  <titleref href="https://dom.spec.whatwg.org/">DOM: Living Standard</titleref>.
                  WHATWG,
                  26 October 2022.</bibl>

               <bibl id="olson" key="IANA Timezone Database">
                  The <emph>tz</emph> timezone database, available at 
                  <loc href="http://www.iana.org/time-zones">http://www.iana.org/time-zones</loc>.
                  It is <termref def="implementation-defined"/> which version of the database is used.
               </bibl>
               
               <bibl id="ieee754-2019" key="IEEE 754-2019">IEEE. <emph>IEEE Standard for
                  Floating-Point Arithmetic.</emph>
               </bibl>
 
               <bibl id="ieee1003.1-2024" key="IEEE 1003.1-2024">
                  <titleref href="https://pubs.opengroup.org/onlinepubs/9799919799/functions/time.html"
                     >Open Group Base Specifications Issue 8</titleref>. IEEE, 2024.
               </bibl>
 
               <bibl id="ieee802-3" key="IEEE 802-3">“IEEE Standard for Ethernet,” in IEEE Std
               802.3-2022 (Revision of IEEE Std 802.3-2018). 29 July 2022.
               doi: 10.1109/IEEESTD.2022.9844436.
               </bibl>
 
               <bibl id="ISO3166" key="ISO 3166-1">ISO (International Organization for Standardization)
					<emph>Codes for the representation of names of countries
					 and their subdivisions - Part 1: Country codes</emph> ISO 3166-1:2013.
                    </bibl>
               <bibl  id="ISO8601" key="ISO 8601"
                  >ISO (International Organization for
                  Standardization). <emph>Representations of dates and times. Third edition,
                     2004-12-01.</emph> ISO 8601:2004(E). Available from:
                  <loc href="http://www.iso.org/">http://www.iso.org/"</loc>.
               </bibl>
               <bibl id="ISO10967" key="ISO 10967">ISO (International Organization
for Standardization). <emph>ISO/IEC 10967-1:2012, Information
technology&#8212;Language Independent Arithmetic&#8212;Part 1:
Integer and floating point arithmetic</emph> [Geneva]: International
Organization for Standardization, 2012. Available from: <loc href="http://www.iso.org/">http://www.iso.org/</loc>.
               </bibl>
               <bibl id="ISO15924" key="ISO 15924">ISO (International Organization for Standardization) 
                  <emph>Information and documentation &mdash; Codes
                     for the representation of names of scripts</emph> ISO 15924:2004, 
                  January 2004.</bibl>
               <bibl id="ISO15924_register" key="ISO 15924 Register">Unicode Consortium. 
                  <emph>Codes for the representation of names of scripts &mdash; Alphabetical list of four-letter script codes.</emph>
                  See <loc href="http://www.unicode.org/iso15924/iso15924-codes.html"/>.
                  Retrieved February 2013; continually updated.</bibl>
               
               <bibl id="LEIRI"
                  key="Legacy extended IRIs for XML resource identification"><emph>Legacy extended IRIs for XML resource identification</emph>.
                  Henry S. Thomson, Richard Tobin, and Norman Walsh (eds), World Wide Web Consortium. 3 November 2008. Available at
                  <loc href="http://www.w3.org/TR/leiri/">http://www.w3.org/TR/leiri/</loc>.
               </bibl>
               <bibl id="rfc1321" key="RFC 1321">IETF. <emph>RFC 1321: The MD5 Message-Digest Algorithm. </emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc1321.txt">http://www.ietf.org/rfc/rfc1321.txt</loc>.
               </bibl>
               <!--<bibl id="rfc2396" key="RFC 2396">IETF. <emph>RFC 2396: Uniform
                  Resource Identifiers (URI): Generic Syntax. </emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</loc>
                  </bibl>-->
               <bibl id="rfc2376" key="RFC 2376">IETF. <emph>RFC 2376: XML Media Types. </emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc2376.txt">http://www.ietf.org/rfc/rfc2376.txt</loc>.
               </bibl>
               <bibl id="rfc3986" key="RFC 3986">IETF. <emph>RFC 3986: Uniform
                  Resource Identifiers (URI): Generic Syntax. </emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</loc>.
               </bibl>
               <bibl id="rfc3987" key="RFC 3987">IETF. <emph>RFC 3987:
                  Internationalized Resource Identifiers (IRIs).</emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</loc>.
               </bibl>
               <bibl id="rfc4180" key="RFC 4180">IETF. <emph>RFC 4180:
                  Common Format and MIME Type for Comma-Separated Values (CSV) Files.</emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc4180.txt">http://www.ietf.org/rfc/rfc4180.txt</loc>.
               </bibl>
               <bibl id="rfc6151" key="RFC 6151">IETF. <emph>RFC 6151:
                  Updated Security Considerations for
                  the MD5 Message-Digest and the HMAC-MD5 Algorithms</emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc6151.txt">http://www.ietf.org/rfc/rfc6151.txt</loc>.
               </bibl>
               <bibl id="rfc7159" key="RFC 7159">IETF. <emph>RFC 7159: The Javascript Object Notation (JSON) Data Interchange Format</emph> Available at:
                  <loc href="http://www.rfc-editor.org/rfc/rfc7159.txt">http://www.rfc-editor.org/rfc/rfc7159.txt</loc>.
               </bibl>
               <bibl id="rfc7303" key="RFC 7303">H. Thompson and C. Lilley. <emph>XML Media Types</emph>.
                  IETF RFC 7303. See <loc href="http://www.ietf.org/rfc/rfc7303.txt">http://www.ietf.org/rfc/rfc7303.txt</loc>.</bibl>
               
               <bibl id="fips180-4" key="FIPS 180-4">National Institute of Standards and Technology.
                 <emph>Secure Hash Standard (SHS)</emph>. FIPS PUB 180-4. August 2015. 
                  See <loc href="http://dx.doi.org/10.6028/NIST.FIPS.180-4">http://dx.doi.org/10.6028/NIST.FIPS.180-4</loc>. </bibl>

               <bibl id="UNICODE-TR15"
                  key="UAX #15"><emph>Unicode Standard Annex #15: Unicode Normalization
                     Forms</emph>. 
                  Ed. Mark Davis and Ken Whistler, Unicode Consortium.
                  The current version is 9.0.0, dated 2016-02-24.
                  As with <bibref ref="Unicode"/>, the version to be used is <termref def="implementation-defined"/>.
                  Available at:
                  <loc href="http://www.unicode.org/reports/tr15/">http://www.unicode.org/reports/tr15/</loc>.                 
               </bibl>  
               
               <bibl id="UNICODE-TR29"
                  key="UAX #29"><emph>Unicode Standard Annex #29: Unicode Text Segmentation</emph>. 
                  Ed. Josh Hadley, Unicode Consortium.
                  The current version is 15.1.0, dated 2023-08-16.
                  As with <bibref ref="Unicode"/>, the version to be used is <termref def="implementation-defined"/>.
                  Available at:
                  <loc href="http://www.unicode.org/reports/tr29/">http://www.unicode.org/reports/tr29/</loc>.                 
               </bibl>  
               
               <bibl id="Unicode"
                     key="The Unicode Standard">
The Unicode Consortium, Reading, MA, Addison-Wesley, 2016. <emph>The Unicode Standard</emph>
as updated from time to time by the publication of new versions. See 
<loc href="http://www.unicode.org/standard/versions/">http://www.unicode.org/standard/versions/</loc>
for the latest version and additional information on versions of the standard and of the Unicode Character Database. 
The version of Unicode to be used is <termref def="implementation-defined"/>,
but implementations are recommended to use the latest Unicode version;
currently, Version 9.0.0.
</bibl>
               
                            
               
               <bibl id="UNICODE-TR10" key="UTS #10"><emph>Unicode
                  Technical Standard #10: Unicode Collation Algorithm</emph>. 
                  Ed. Mark Davis and Ken Whistler, Unicode Consortium. The current version is 9.0.0, dated 2016-05-18.
                  As with <bibref ref="Unicode"/>, the version to be used is <termref def="implementation-defined"/>. 
                  Available at: <loc href="http://www.unicode.org/reports/tr10/"/>.</bibl>
               
               <bibl id="UNICODE-TR35" key="UTS #35"><emph>Unicode
                  Technical Standard #35: Unicode Locale Data Markup Language</emph>. 
                  Ed Mark Davis <emph>et al</emph>, Unicode Consortium. The current version is 29, dated 2016-03-15.
                  As with <bibref ref="Unicode"/>, the version to be used is <termref def="implementation-defined"/>.
                  Available at: <loc href="http://www.unicode.org/reports/tr35/"/>.</bibl>
               
               <bibl id="xml" key="Extensible Markup Language (XML) 1.0 (Fifth Edition)"/>
               <bibl  id="xml11"
                  key="Extensible Markup Language (XML) 1.1 Recommendation"/> 
               <bibl  id="xpath"
                     key="XML Path Language (XPath) Version 1.0"/>
               <!--<bibl  id="xpath20"
                     key="XML Path Language (XPath) 2.0"/>-->
               <!--<bibl  id="xpath-30"
                     key="XML Path Language (XPath) 3.0"/>-->
               <bibl  id="xpath-40"
                      key="XML Path Language (XPath) 4.0">
                 <emph>CITATION: T.B.D.</emph>
               </bibl>
 
               <bibl  id="xslt10"
                  key="XSL Transformations (XSLT) Version 1.0"/>
               <bibl  id="xslt20"
                     key="XSL Transformations (XSLT) Version 2.0"/>
	       <bibl  id="xslt-40"
                     key="XSL Transformations (XSLT) Version 4.0">
                 <emph>CITATION: T.B.D.</emph>
               </bibl>
               <bibl  id="xpath-datamodel-30"
                     key="XQuery and XPath Data Model (XDM) 3.0"/>
               <bibl  id="xpath-datamodel-31"
                     key="XQuery and XPath Data Model (XDM) 3.1"/>
               <bibl  id="xpath-datamodel-40"
                     key="XQuery and XPath Data Model (XDM) 4.0"/>

			   <bibl  id="xslt-xquery-serialization-31"
                     key="XSLT and XQuery Serialization 3.1"/>
               <bibl  id="xquery-semantics"
                     key="XQuery 1.0 and XPath 2.0 Formal Semantics"/>
               <!--<bibl  id="xquery"
                     key="XQuery 1.0: An XML Query Language"/>-->
               <!--<bibl  id="xquery-30"
                     key="XQuery 3.0: An XML Query Language"/>-->
               <bibl  id="xquery-40"
                     key="XQuery 4.0: An XML Query Language">
                 <emph>CITATION: T.B.D.</emph>
               </bibl>
               <!--<bibl  id="xmlschema-1"
                     key="XML Schema Part 1: Structures Second Edition"> XML
                        Schema Part 1: Structures Second Edition, Oct 28 2004. Available at: 
						<loc href="http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</loc>
						</bibl>-->
               <bibl id="xinclude" key="XML Inclusions (XInclude) Version 1.0 (Second Edition)"/>
               <bibl  id="xmlschema-2"
                     key="XML Schema Part 2: Datatypes Second Edition"> XML Schema
                        Part 2: Datatypes Second Edition, Oct. 28 2004. Available at: 
						<loc href="http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</loc>
               </bibl>
               <bibl id="xmlschema11-1"      key="XSD 1.1 Part 1"/>
               <bibl id="xmlschema11-2"      key="XSD 1.1 Part 2"/>
               <bibl  id="xml-names" key="Namespaces in XML"/> 

               <bibl id="invisible-xml" key="Invisible XML">
                  <titleref href="https://invisiblexml.org/1.0/"
                     >Invisible XML Specification</titleref>,
                  Steven Pemberton, editor.
                  World Wide Web Consortium,
                  20 June 2020.
                  This version is https://invisiblexml.org/1.0/.
                  The <loc href="https://invisiblexml.org/current/">latest version</loc>
                  is available at https://invisiblexml.org/current/.</bibl>
            </blist>
         </div2>
         
         <div2 id="non-normative-biblio">
            <head>Non-normative references</head>
            <blist>
			   <bibl id="BLAKE3" key="BLAKE3 Hashing">
				  <emph>Blake3 Algorithm Specification</emph>. Available at:
				  <loc href="https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf">https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf</loc>
			   </bibl>			
               <bibl  id="CALCALC"
                     key="Calendrical Calculations">Edward M. Reingold and Nachum Dershowitz.
<emph>Calendrical Calculations Millennium edition (2nd Edition)</emph>. Cambridge University Press, 
ISBN 0 521 77752 6.</bibl>
               <bibl id="CLDR" key="Unicode CLDR">CLDR - Unicode Common Locale Data Repository. Available at:
                  <loc href="http://cldr.unicode.org">http://cldr.unicode.org</loc>.</bibl>
               <bibl id="charmod-normalization"
                  key="Character Model for the World Wide Web 1.0: Normalization">Character Model for the World Wide Web
                  1.0: Normalization, Last Call Working Draft. Available at:
                  <loc href="http://www.w3.org/TR/2004/WD-charmod-norm-20040225/">http://www.w3.org/TR/2004/WD-charmod-norm-20040225/</loc>.
               </bibl>
               <bibl id="expath" key="EXPath">EXPath: Collaboratively Defining Open Standards for Portable XPath Extensions.
               <loc href="http://expath.org/">http://expath.org/</loc>.</bibl> 
               <bibl id="exquery" key="EXQuery">EXQuery: Collaboratively Defining Open Standards for Portable XQuery Extensions.
                  <loc href="http://exquery.org/">http://exquery.org/</loc>.</bibl> 
               <bibl id="exslt" key="EXSLT">EXSLT: A Community Initiative to Provide Extensions to XSLT.
                  <loc href="https://exslt.github.io">https://exslt.github.io</loc>.</bibl> 
               <bibl id="functx" key="FunctX">FunctX Functions. 
                  <loc href="http://www.functx.com/">http://www.functx.com/</loc>.</bibl>
               
               <bibl id="Goessner" key="Goessner">Stefan Goessner. Converting Between XML and JSON.
               <loc href="https://www.xml.com/pub/a/2006/05/31/converting-between-xml-and-json.html">https://www.xml.com/pub/a/2006/05/31/converting-between-xml-and-json.html</loc>.
               31 May 2006.</bibl>
               <bibl  id="HTML40" key="HTML 4.0">HTML 4.01 Recommendation, 24 December
1999. Available at:
<loc href="http://www.w3.org/TR/REC-html40/">http://www.w3.org/TR/REC-html40/</loc>.
               </bibl>
               <bibl id="ICU" key="ICU">ICU - International Components for Unicode. Available at <loc href="http://site.icu-project.org">http://site.icu-project.org</loc>.
               </bibl>
               <bibl id="POSIX.1-2008" key="POSIX.1-2008">
                  <emph>The Open Group Base Specifications Issue 7 (IEEE Std 1003.1-2008)</emph>.
                  Available at: <loc href="http://pubs.opengroup.org/onlinepubs/9699919799/">http://pubs.opengroup.org/onlinepubs/9699919799/</loc>.
               </bibl>
               <bibl id="rfc822" key="RFC 822">IETF. <emph>RFC 822: Standard for the Format of ARPA Internet Text Messages. </emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc822.txt">http://www.ietf.org/rfc/rfc822.txt</loc>.
               </bibl>
               <bibl id="rfc850" key="RFC 850">IETF. <emph>RFC 850: Standard for Interchange of USENET Messages. </emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc850.txt">http://www.ietf.org/rfc/rfc850.txt</loc>.
               </bibl>
               <bibl id="rfc1036" key="RFC 1036">IETF. <emph>RFC 1036: Standard for Interchange of USENET Messages. </emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc1036.txt">http://www.ietf.org/rfc/rfc1036.txt</loc>.
               </bibl>
               <bibl id="rfc1123" key="RFC 1123">IETF. <emph>RFC 1123: Requirements for Internet Hosts -- Application and Support. </emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc1123.txt">http://www.ietf.org/rfc/rfc1123.txt</loc>.
               </bibl>
               <bibl id="rfc2616" key="RFC 2616">IETF. <emph>RFC 2616: Hypertext Transfer Protocol -- HTTP/1.1. </emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc2616.txt">http://www.ietf.org/rfc/rfc2616.txt</loc>.
               </bibl>
               <bibl id="rfc3339" key="RFC 3339">IETF. <emph>RFC 3339: Date and Time on the Internet: Timestamps. </emph> Available at:
                  <loc href="http://www.ietf.org/rfc/rfc3339.txt">http://www.ietf.org/rfc/rfc3339.txt</loc>.
               </bibl>
               <bibl id="UNICODE-TR18" key="UTS #18"><emph>Unicode
                  Technical Standard #18: Unicode Regular Expressions</emph>. 
                  Ed. Mark Davis and Andy Heniger, Unicode Consortium. The current version is 17, dated 2013-11-19. Available at:
                  <loc href="http://www.unicode.org/reports/tr18/">http://www.unicode.org/reports/tr18/</loc>.
               </bibl>
               
               
               
               
               <bibl  id="Working-With-Timezones"
                     key="Working With Timezones">World Wide Web Consortium Working Group Note. 
					 <emph>Working With Timezones, October 13, 2005.</emph> Available at:
<loc href="http://www.w3.org/TR/2005/NOTE-timezone-20051013/">http://www.w3.org/TR/2005/NOTE-timezone-20051013/</loc>.
               </bibl>
            </blist>
         </div2>
      </div1>

      <div1 id="error-summary">
         <head>Error codes</head>
         <p>The error text provided with these errors is non-normative.</p>
         <error-list>
            <error class="ER" code="0000" label="Unidentified error." type="dynamic">
               <p>Error code used by <function>fn:error</function> when no other error code is provided.</p>
            </error>
            <error class="AP" code="0001" label="Wrong number of arguments." type="dynamic">
               <p>Raised when <function>fn:apply</function> is called and the arity of the supplied function is not
                  the same as the number of members in the supplied array.</p>
            </error>
            <error class="AR" code="0001" label="Division by zero." type="dynamic">
               <p>This error is raised whenever an attempt is made to divide by zero.</p>
            </error>
            <error class="AR" code="0002" label="Numeric operation overflow/underflow."
                   type="dynamic">
               <p>This error is raised whenever numeric operations result in an overflow or underflow.</p>
            </error>
            <error class="AY" code="0001" label="Array index out of bounds." type="dynamic">
               <p>This error is raised when an integer used to select a member of an array is outside the range of values for that array.</p>
            </error>
            <error class="AY" code="0002" label="Negative array length." type="dynamic">
               <p>This error is raised when the <code>$length</code> argument to <function>array:subarray</function> is negative.</p>
            </error>
            <error class="CA" code="0001" label="Input value too large for decimal."
                   type="dynamic">
               <p>Raised when casting to <code>xs:decimal</code> if the supplied value exceeds the
               implementation-defined limits for the datatype.</p>
            </error>
            <error class="CA" code="0002" label="Invalid lexical value." type="dynamic">
               <p>Raised by <function>fn:resolve-QName</function> and <function>fn:QName</function> when a supplied value does not have the lexical
               form of a QName or URI respectively; and when casting to decimal, if the supplied value is <code>NaN</code> or Infinity.</p>
            </error>
            <error class="CA" code="0003" label="Input value too large for integer."
                   type="dynamic">
               <p>Raised when casting to <code>xs:integer</code> if the supplied value exceeds the
                  implementation-defined limits for the datatype.</p>
            </error>
            <error class="CA" code="0005" label="NaN supplied as float/double value."
                   type="dynamic">
               <p>Raised when multiplying or dividing a duration by a number, if the number supplied is <code>NaN</code>.</p>
            </error>
            <error class="CA" code="0006"
                   label="String to be cast to decimal has too many digits of precision."
                   type="dynamic">
               <p>Raised when casting a string to <code>xs:decimal</code> if the string has more digits of precision
               than the implementation can represent (the implementation also has the option of rounding).</p>
            </error>
            <error class="CH" code="0001" label="Codepoint not valid." type="dynamic">
               <p diff="chg" at="2023-06-12">Raised by <function>fn:codepoints-to-string</function> if the input contains an integer that is not the codepoint
               of a <termref def="dt-permitted-character">permitted character</termref>.</p>
            </error>
            <error class="CH" code="0002" label="Unsupported collation." type="dynamic">
               <p>Raised by any function that uses a collation if the requested collation is not recognized.</p>
            </error>
            <error class="CH" code="0003" label="Unsupported normalization form." type="static">
               <p>Raised by <function>fn:normalize-unicode</function> if the requested normalization form is not
               supported by the implementation.</p>
            </error>
            <error class="CH" code="0004" label="Collation does not support collation units."
                   type="dynamic">
               <p>Raised by functions such as <function>fn:contains</function> if the requested collation does
               not operate on a character-by-character basis.</p>
            </error>
            <error class="CH" code="0005" label="Unrecognized or invalid character name."
               type="dynamic">
               <p diff="chg" at="2023-06-12">Raised by <function>fn:char</function> if the supplied character name is not recognized, or
               if it represents a codepoint that is not
               a <termref def="dt-permitted-character">permitted character</termref>.</p>
            </error>
            <error class="CV" code="0001" label="CSV field quoting error."
               type="dynamic">
               <p>Raised when parsing CSV input if a syntax error in the input CSV is found.</p>
            </error>
            <error class="CV" code="0002" label="Invalid CSV delimiter error."
               type="dynamic">
               <p>Raised when parsing CSV input if the <code>field-separator</code>,
                  <code>record-separator</code>, or <code>quote-character</code> option is set to
                  an invalid value.</p>
            </error>
            <error class="CV" code="0003" label="Duplicate CSV delimiter error."
               type="dynamic">
               <p>Raised when parsing CSV input if the same delimiter character is assigned
                  to more than one role.</p>
            </error>
            <error class="CV" code="0004" label="Argument supplied is not a known column name."
               type="dynamic">
               <p>Raised by the function from the <code>get</code> entry of
                  <code>csv-columns-record</code>, if its <code>$key</code> argument is an
                  <code>xs:string</code> and is not one of the known column names.</p>
            </error>
            <!--<error class="CV" code="0005" label="Non-positive integer provided as column index."
               type="dynamic">
               <p>Raised by <function>fn:parse-csv</function>, <function>fn:csv-to-xml</function>, and the function
                  from the <code>field</code> entry of <code>csv-columns-record</code>, if an
                  argument referring to a column index is zero or negative. (The options
                  <code>number-of-columns</code>, <code>filter-columns</code>, or in a map passed
                  to <code>column-names</code>, or the argument to the <code>field</code> function.)
               </p>
            </error>
            <error class="CV" code="0006" label="Both options number-of-columns and filter-columns set"
               type="dynamic">
               <p>Raised by <function>fn:parse-csv</function> and <function>fn:csv-to-xml</function>, if both the
                  <code>number-of-columns</code> and <code>filter-columns</code> options are set:
                  they are mutually exclusive.</p>
            </error>-->
            <error class="DC" code="0001" label="No context document." type="dynamic">
               <p>Raised by <function>fn:id</function>, <function>fn:idref</function>, and <function>fn:element-with-id</function>
                  if the node that identifies the tree to be searched is a node in a tree whose root is not
                  a document node.</p>
            </error>
            <error class="DC" code="0002" label="Error retrieving resource." type="dynamic">
               <p>Raised by <function>fn:doc</function>, <function>fn:collection</function>, and <function>fn:uri-collection</function>
               to indicate that either the supplied URI cannot be dereferenced to obtain a resource, or the resource
               that is returned is not parseable as XML.</p>
            </error>
            <error class="DC" code="0003" label="Function not defined as deterministic." type="dynamic">
               <p>Raised by <function>fn:doc</function>, <function>fn:collection</function>, and <function>fn:uri-collection</function> 
                  to indicate that it is not possible to
               return a result that is guaranteed deterministic.</p>
            </error>
            <error class="DC" code="0004" label="Invalid collection URI."
                   type="dynamic">
               <p>Raised by <function>fn:collection</function> and <function>fn:uri-collection</function> 
                  if the argument is not a valid <code>xs:anyURI</code>.</p>
            </error>
            <error class="DC" code="0005" label="Invalid URI reference."
                   type="dynamic">
               <p>Raised (optionally) by <function>fn:doc</function> if the argument 
                  is not a valid <code>xs:anyURI</code>.</p>
            </error>
            <error class="DC" code="0006" label="String passed to fn:parse-xml is not a well-formed XML document."
               type="dynamic">
               <p>Raised by <function>fn:parse-xml</function> if the supplied string is not a well-formed and namespace-well-formed XML document;
               or if DTD validation is requested and the document is not valid against its DTD.</p>
            </error>
            <error class="DC" code="0007" label="String passed to fn:parse-xml is not a DTD-valid XML document."
               type="dynamic">
               <p>Raised by <function>fn:parse-xml</function> if DTD validation is requested and the supplied string 
                  has no DTD or is not valid against the DTD.</p>
            </error>
            <error class="DC" code="0008" label="Invalid value for the xsd-validation option of fn:parse-xml."
               type="dynamic">
               <p>Raised when the <code>xsd-validation</code> option to <function>fn:parse-xml</function> is supplied,
                  and the value is not one of the permitted values; for example if the option <code>type Q{U}NNN</code>
                  is used, and <code>Q{U}NNN</code> does not identify a type in the static context.</p>
            </error>
            <error class="DC" code="0009" label="Processor is not schema-aware."
               type="dynamic">
               <p>Raised when the <code>xsd-validation</code> option to <function>fn:parse-xml</function> is set to
                  a value other than <code>skip</code>, if the processor is not schema-aware.</p>
            </error>
            
            <error class="DC" code="0010" label="The processor does not support serialization."
               type="dynamic">
               <p>Raised when <function>fn:serialize</function> is called and the processor does not support serialization,
               in cases where the host language makes serialization an optional feature.</p>
            </error>
            <error class="DC" code="0011" label="String passed to fn:parse-html is not a well-formed HTML document."
                   type="dynamic">
               <p>Raised by <function>fn:parse-html</function> if the supplied string is not a well-formed HTML document.</p>
            </error>
            <error class="DC" code="0012" label="Unsupported HTML parser option."
                   type="dynamic">
               <p>Raised by <function>fn:parse-html</function> if a key passed to <code>$options</code>, or its value,
                  is not supported by the implementation.</p>
            </error>
            <error class="DC" code="0013" label="No validating XML parser available."
               type="dynamic">
               <p>Raised when the <code>dtd-validation</code> option to <function>fn:parse-xml</function> is set,
                  if no validating XML parser is available. Note: it is <rfc2119>recommended</rfc2119>
               that all processors should support the <code>dtd-validation</code> option, but there
               may be environments (such as web browsers) where this is not practically feasible.</p>
            </error>
            <error class="DC" code="0014" label="String passed to fn:parse-xml is not a schema-valid XML document."
               type="dynamic">
               <p>Raised by <function>fn:parse-xml</function> if XSD validation is requested and the XML document
                  represented by the supplied string is not valid against the relevant XSD schema.</p>
            </error>
			<error class="DF" code="1280" label="Invalid decimal format name."
                   type="dynamic">
               <p>This error is raised if the decimal format name supplied to <function>fn:format-number</function> is not a valid QName,
			   or if the prefix in the QName is undeclared, or if there is no decimal format in the static context with
			   a matching name.</p>
            </error>
            
			<error class="DF" code="1290" label="Invalid decimal format property."
                   type="dynamic">
               <p>This error is raised if a decimal format value supplied to
               <function>fn:format-number</function> is not valid for the associated property,
               or if the properties of the decimal format resulting from a supplied map
               do not have distinct values.</p>
            </error>
            
			<error class="DF" code="1310" label="Invalid decimal format picture string."
                   type="dynamic">
               <p>This error is raised if the picture string supplied to <function>fn:format-number</function> or 
                  <function>fn:format-integer</function> has invalid syntax.</p>
            </error>
            <error class="DT" code="0001" label="Overflow/underflow in date/time operation."
                   type="dynamic">
               <p>Raised when casting to date/time datatypes, or performing arithmetic with date/time values, if
               arithmetic overflow or underflow occurs.</p> 
            </error>
            <error class="DT" code="0002" label="Overflow/underflow in duration operation."
                   type="dynamic">
               <p>Raised when casting to duration datatypes, or performing arithmetic with duration values, if
                  arithmetic overflow or underflow occurs.</p> 
            </error>
            <error class="DT" code="0003" label="Invalid timezone value." type="dynamic">
               <p>Raised by <code>adjust-date-to-timezone</code> and related functions if the supplied timezone is invalid.</p> 
            </error>
            <error class="DT" code="0004" label="No timezone data available" type="dynamic">
               <p>Raised by <code>civil-timezone</code> if no timezone data is available for the given date/time and place.</p> 
            </error>
			<error class="FD" code="1340" label="Invalid date/time formatting parameters."
                   type="dynamic">
               <p>This error is raised if the picture string or calendar supplied to <function>fn:format-date</function>, <function>fn:format-time</function>, 
			   or <function>fn:format-dateTime</function> has invalid syntax.</p>
            </error>
			<error class="FD" code="1350" label="Invalid date/time formatting component."
                   type="dynamic">
               <p>This error is raised if the picture string supplied to <function>fn:format-date</function> 
			   selects a component that is not present in a date, or if the picture string supplied to <function>fn:format-time</function> 
			   selects a component that is not present in a time.</p>
            </error>

            <error class="HA" code="0001" label="Invalid algorithm." type="dynamic">
               <p>Raised by <function>fn:hash</function> if the effective value of the supplied
               algorithm is not one of the values supported by the implementation.</p>
            </error>
            
            <error class="JS" code="0001" label="JSON syntax error." type="dynamic">
               <p>Raised by functions such as <function>fn:json-doc</function>, <function>fn:parse-json</function> 
                  or <function>fn:json-to-xml</function> 
                  if the string supplied as input does not conform to the JSON grammar (optionally with implementation-defined extensions).</p>
            </error>
            
            <error class="JS" code="0003" label="JSON duplicate keys." type="dynamic">
               <p>Raised by functions such as <function>map:merge</function>, <function>fn:json-doc</function>, 
                  <function>fn:parse-json</function> or <function>fn:json-to-xml</function> 
                  if the input contains duplicate keys, when the chosen policy is to reject duplicates.</p>
            </error>
            
            <error class="JS" code="0004" label="JSON: not schema-aware." type="dynamic">
               <p>Raised by <function>fn:json-to-xml</function> if validation 
                  is requested when the processor does not support schema validation or typed nodes.</p>
            </error>
            
            <error class="JS" code="0005" label="Invalid options." type="dynamic">
               <p>Raised by functions such as <function>map:merge</function>, <function>fn:parse-json</function>,
                  and <function>fn:xml-to-json</function> if the <code>$options</code> map contains an invalid entry.</p>
            </error>
            
            <error class="JS" code="0006" label="Invalid XML representation of JSON." type="dynamic">
               <p>Raised by <function>fn:xml-to-json</function> if the XML input does not
                  conform to the rules for the XML representation of JSON.</p>
            </error>
            
            <error class="JS" code="0007" label="Bad JSON escape sequence." type="dynamic">
               <p>Raised by <function>fn:xml-to-json</function> if the XML input uses the attribute
                  <code>escaped="true"</code> or <code>escaped-key="true"</code>, and the corresponding string
                  or key contains an invalid JSON escape sequence.</p>
            </error>
            

            
            
            <error class="NS" code="0004" label="No namespace found for prefix." type="dynamic">
               <p>Raised by <function>fn:resolve-QName</function> and analogous functions if a supplied QName has a 
                  prefix that has no binding to a namespace.</p>
            </error>
            <error class="NS" code="0005" label="Base-uri not defined in the static context."
                   type="dynamic">
               <p>Raised by <function>fn:resolve-uri</function> if no base URI is available for resolving a relative URI.</p>
            </error>
            
            <error class="QM" code="0001" label="Module URI is a zero-length string."
               type="dynamic">
               <p>Raised by <function>fn:load-xquery-module</function> if the supplied module URI is zero-length.</p>
            </error>
            <error class="QM" code="0002" label="Module URI not found."
               type="dynamic">
               <p>Raised by <function>fn:load-xquery-module</function> if no module can be found with the supplied module URI.</p>
            </error>
            <error class="QM" code="0003" label="Static error in dynamically loaded XQuery module."
               type="dynamic">
               <p>Raised by <function>fn:load-xquery-module</function> if a static error 
                  (including a statically detected type error) is encountered when processing the library module.</p>
            </error>
            
            <error class="QM" code="0005" label="Parameter for dynamically loaded XQuery module has incorrect type."
               type="dynamic">
               <p>Raised by <function>fn:load-xquery-module</function> if a value is supplied for the initial context 
                  item or for an external variable, and the value does not conform to the required
                  type declared in the dynamically loaded module.</p>
            </error>
            <error class="QM" code="0006" label="No suitable XQuery processor available."
               type="dynamic">
               <p>Raised by <function>fn:load-xquery-module</function> if no XQuery processor is available supporting the requested
                  XQuery version (or if none is available at all).</p>
            </error>
            
    
            <error class="RG" code="0001" label="Invalid value for cast/constructor."
                   type="dynamic">
               <p>A general-purpose error raised when casting, if a cast between two datatypes is allowed in principle,
               but the supplied value cannot be converted: for example when attempting to cast the string <code>"nine"</code> to an integer.</p>
            </error>
            <error class="RG" code="0002" label="Invalid argument to fn:resolve-uri."
                   type="dynamic">
               <p>Raised when either argument to <function>fn:resolve-uri</function> is not a valid URI/IRI.</p>
            </error>
            <error class="RG" code="0003"
                   label="fn:zero-or-one called with a sequence containing more than one item."
                   type="dynamic">
               <p>Raised by <function>fn:zero-or-one</function> if the supplied value contains more than one item.</p> 
            </error>
            <error class="RG" code="0004"
                   label="fn:one-or-more called with a sequence containing no items."
                   type="dynamic"> 
               <p>Raised by <function>fn:one-or-more</function> if the supplied value is an empty sequence.</p>
            </error>
            <error class="RG" code="0005"
                   label="fn:exactly-one called with a sequence containing zero or more than one item."
                   type="dynamic">
               <p>Raised by <function>fn:exactly-one</function> if the supplied value is not a singleton sequence.</p>
            </error>
            <error class="RG" code="0006" label="Invalid argument type." type="static">
               <p>Raised by functions such as <function>fn:max</function>, <function>fn:min</function>, <function>fn:avg</function>, <function>fn:sum</function>
               if the supplied sequence contains values inappropriate to this function.</p> 
            </error>
            <error class="RG" code="0008"
                   label="The two arguments to fn:dateTime have inconsistent timezones."
                   type="dynamic">
               <p>Raised by <function>fn:dateTime</function> if the two arguments both have timezones and the timezones are different.</p>
            </error>
            <error class="RG" code="0009"
                   label="Error in resolving a relative URI against a base URI in fn:resolve-uri."
                   type="dynamic">
               <p>A catch-all error for <function>fn:resolve-uri</function>, recognizing that the implementation can choose between a variety
               of algorithms and that some of these may fail for a variety of reasons.</p>
            </error>
            <error class="RG" code="0010"
               label="Invalid date/time."
               type="dynamic">
               <p>Raised when the input to <function>fn:parse-ietf-date</function> does not match the prescribed
                  grammar, or when it represents an invalid date/time such as 31 February.</p>
            </error>
            <error class="RG" code="0011"
               label="Invalid radix."
               type="dynamic">
               <p>Raised when the radix supplied to <function>fn:parse-integer</function> is not in the range 2 to 36.</p>
            </error>
            <error class="RG" code="0012"
               label="Invalid digits."
               type="dynamic">
               <p>Raised when the digits in the string supplied to <function>fn:parse-integer</function> are not in the range appropriate
                  to the chosen radix.</p>
            </error>
            <!--<error class="RG" code="0013"
               label="Inconsistent options."
               type="dynamic">
               <p>Raised if an inconsistent set of options is supplied
                  in an <termref def="options">option map</termref>.</p>
            </error>-->
            
            <error class="RX" code="0001" label="Invalid regular expression flags." type="static">
               <p>Raised by regular expression functions such as <function>fn:matches</function> and <function>fn:replace</function> if the
               regular expression flags contain a character other than <code>i</code>, <code>m</code>, <code>q</code>, <code>s</code>, or <code>x</code>.</p>
            </error>
            <!--End of text replaced by erratum E25-->
            <error class="RX" code="0002" label="Invalid regular expression." type="dynamic">
               <p>Raised by regular expression functions such as <function>fn:matches</function> and <function>fn:replace</function> if the
                  regular expression is syntactically invalid.</p>
            </error>
            <error class="RX" code="0003" label="Regular expression matches zero-length string."
                   type="dynamic">
               <p>For functions such as <function>fn:replace</function> and <function>fn:tokenize</function>, raises an error if
               the supplied regular expression is capable of matching a zero length string.</p>
            </error>
            <error class="RX" code="0004" label="Invalid replacement string." type="dynamic">
               <p>Raised by <function>fn:replace</function> to report errors in the replacement string.</p>
            </error>
            <error class="RX" code="0005" label="Incompatible arguments for fn:replace." type="dynamic">
               <p>Raised by <function>fn:replace</function> if both the <code>$replacement</code> 
                  and <code>$action</code> arguments are supplied.</p>
            </error>
            <error class="TY" code="0012" label="Argument to fn:data contains a node that does not have a typed value."
                   type="dynamic">
               <p>Raised by <function>fn:data</function>, or by implicit atomization, if applied to a node with no typed value,
               the main example being an element validated against a complex type that defines it to have element-only content.</p>
            </error>
            <error class="TY" code="0013" label="The argument to fn:data contains a function item."
               type="dynamic">
               <p>Raised by <function>fn:data</function>, or by implicit atomization, if the sequence to be atomized contains
                a function item other than an array.</p>
            </error>
            <error class="TY" code="0014" label="The argument to fn:string is a function item."
               type="dynamic">
               <p>Raised by <function>fn:string</function>, or by implicit string conversion, if the input sequence contains
                  a function item.</p>
            </error>
            <!--<error class="TY" code="0015" label="An argument to fn:deep-equal contains a function item."
               type="dynamic">
               <p>Raised by <function>fn:deep-equal</function> if either input sequence contains a
                  function item.</p> 
            </error>-->
            <error class="UT" code="1170" label="Invalid URI reference."
               type="dynamic">
               <p>Raised by <function>fn:unparsed-text</function> or <function>fn:unparsed-text-lines</function>
                  if the <code>$source</code> argument contains a fragment identifier,
                  or if it cannot be resolved to an absolute URI (for example, because the
                  base-URI property in the static context is absent), or if it cannot be used to
                  retrieve the string representation of a resource.</p>
            </error>
            <error class="UT" code="1190" label="Cannot decode external resource."
               type="dynamic">
               <p diff="chg" at="2023-06-12">Raised by <function>fn:unparsed-text</function> or <function>fn:unparsed-text-lines</function>
                  if the <code>$encoding</code> argument is not a valid encoding name,
                  if the processor does not support the specified encoding, if the string
                  representation of the retrieved resource contains octets that cannot be decoded
                  into Unicode <termref def="character">characters</termref> using the specified
                  encoding, or if the resulting characters are not
                  <termref def="dt-permitted-character">permitted characters</termref>.</p>
            </error>
            <error class="UT" code="1200" label="Cannot infer encoding of external resource."
               type="dynamic">
               <p>Raised by <function>fn:unparsed-text</function> or <function>fn:unparsed-text-lines</function>
                  if the <code>$encoding</code> argument is absent and the processor
                  cannot infer the encoding using external information and the
                  encoding is not UTF-8.</p>
            </error>
            <error class="UR" code="0001" label="Invalid IPv6/IPvFuture authority"
               type="dynamic">
               <p>A dynamic error is raised if the authority component of a URI
               contains an open square bracket but no corresponding close square bracket.</p>
            </error>
            <error class="XT" code="0001" label="No suitable XSLT processor available"
               type="dynamic">
               <p>A dynamic error is raised if no XSLT processor suitable for evaluating a call on <function>fn:transform</function>
                  is available.</p>
            </error>
            <error class="XT" code="0002" label="Invalid parameters to XSLT transformation"
               type="dynamic">
               <p>A dynamic error is raised if the parameters supplied to <function>fn:transform</function> are invalid, for example
                  if two mutually exclusive parameters are supplied. If a suitable XSLT error code is available (for example in the
               case where the requested <code>initial-template</code> does not exist in the stylesheet), that error code should
               be used in preference.</p>
            </error>
            <error class="XT" code="0003" label="XSLT transformation failed"
               type="dynamic">
               <p>A dynamic error is raised if an XSLT transformation invoked using <function>fn:transform</function> fails with a
                  static or dynamic error. The XSLT error code is used if available; this error code provides a fallback when no XSLT
                  error code is returned, for example because the processor is an XSLT 1.0 processor.</p>
            </error>
            <error class="XT" code="0004" label="XSLT transformation has been disabled"
               type="dynamic">
               <p>A dynamic error is raised if the <function>fn:transform</function> function is invoked when XSLT transformation (or a specific
                  transformation option) has been disabled for security or other reasons.</p>
            </error>
            
            <error class="XT" code="0006" label="XSLT output contains non-accepted characters"
               type="dynamic">
               <p>A dynamic error is raised if the result of the <function>fn:transform</function> function contains characters available
                  only in XML 1.1 and the calling processor cannot handle such characters.</p>
            </error>
            

         </error-list>
      </div1>
      
      <div1 id="schemata">
         <head>Schemas</head>
         
         <changes>
            <change issue="648" PR="924" date="2024-01-09">
               Rules have been added clarifying that users should not be allowed to change the schema for
               the <code>fn</code> namespace.
            </change>
         </changes>
         <p>Two functions in this specification, <function>fn:analyze-string</function> and
         <function>fn:json-to-xml</function>, produce results in the form of an XDM node tree that must conform
         to a specified schema, defined in this appendix. 
         In both cases the elements in the result are in the namespace 
         <code>http://www.w3.org/2005/xpath-functions</code>, which is therefore the target namespace
         of the relevant schema.</p>
         
         <p diff="add" at="issue648">A processor <rfc2119>may</rfc2119> have built-in knowledge 
            of this schema, or it <rfc2119>may</rfc2119> read it from external files. 
            Any attempt to supply a modified form of this 
            schema will have unpredictable consequences. <emph>Modification</emph> here includes 
            not only actual changes to the text of a schema document, but also actions such as 
            using <code>xs:redefine</code> or <code>xs:override</code>, adding members to substitution 
            groups, or defining derived types. Processors are not <rfc2119>required</rfc2119> to detect and reject 
            such modifications. When validating against this schema, it is <rfc2119>recommended</rfc2119>
            that processors should ignore or reject any <code>xsi:schemaLocation</code> or 
            <code>xsi:type</code> attributes in the instance being validated.</p>
         
         <p>The schema for this namespace is organized as three schema documents. The first is a simple
         umbrella document that includes the other two. A copy can be found at 
            <loc href="xpath-functions.xsd">xpath-functions.xsd</loc>:</p>
         
         <?doc xpath-functions.xsd?>
         
         <div2 id="schema-for-analyze-string">
            <head>Schema for the result of <function>fn:analyze-string</function></head>
            <p>This schema describes the output of the function <function>fn:analyze-string</function>.</p>
            <p>The schema is reproduced below, and can also be found in <loc href="analyze-string.xsd">analyze-string.xsd</loc>:</p>
            <?doc analyze-string.xsd?>
         </div2>
         <div2 id="schema-for-json">
            <head>Schema for the result of <function>fn:json-to-xml</function></head>
            <p>This schema describes the output of the function <function>fn:json-to-xml</function>, and the input to the
            function <function>fn:xml-to-json</function>. </p>
            <p>The schema is reproduced below, and can also be found in <loc href="schema-for-json.xsd">schema-for-json.xsd</loc>:</p>
            <?doc schema-for-json.xsd?>
         </div2>
         <div2 id="schema-for-csv">
            <head>Schema for the result of <function>fn:csv-to-xml</function></head>
            <p>This schema describes the output of the function <function>fn:csv-to-xml</function>.</p>
            <p>The schema is reproduced below, and can also be found in <loc href="schema-for-csv.xsd">schema-for-csv.xsd</loc>:</p>
            <?doc schema-for-csv.xsd?>
         </div2>
      </div1>
      
      <inform-div1 id="glossary">
         <head>Glossary</head>
         <?glossary?>
      </inform-div1>

      <inform-div1 id="other-functions">
         <head>Functions defined elsewhere</head>
         <p>This Appendix describes some sources of functions that fall outside the scope of the function library defined
         in this specification. It includes both function specifications and function implementations. Inclusion of a function
         in this appendix does not constitute any kind of recommendation or endorsement; neither is omission from this appendix
         to be construed negatively. This Appendix does not attempt to give any information about licensing arrangements for
         these function specifications or implementations.</p>
         
         <div2 id="functions-in-other-w3c-specs">
            <head>XPath Functions Defined in Other W3C Recommendations</head>
            
            <p>A number of W3C Recommendations make use of XPath, and in some cases such Recommmendations define additional
            functions to be made available when XPath is used in a specific host language.</p>
            
            <div3 id="functions-defined-in-XSLT">
               <head>Functions Defined in XSLT</head>
               <p>The various versions of XSLT have all included additional functions intended to be available only when XPath
               is used within XSLT, and not in other host language environments. Some of these functions were originally defined
               in XSLT, and subsequently migrated into the core function library defined in this specification.</p>
               <p>Generally, the reason that functions have been defined in XSLT rather than in the core library has been that
               they required additional static or dynamic context information.</p>
               <p>XSLT-defined functions share the core namespace <code>http://www.w3.org/2005/xpath-functions</code> (but in XPath 1.0
               and XSLT 1.0, no namespace was defined for these functions).</p>
               <p>The conformance rules for XSLT 4.0 require implementations to support either XPath 3.0 or XPath 3.1. Some of the
               new functions in XPath 3.1, however, must be supported by all XSLT 4.0 implementations whether or not they implement
               other parts of XPath 3.1.</p>
               <p>The following table lists all functions that have been defined in XSLT 1.0, 2.0, or 3.0, and summarizes their status.</p>
               
               <table role="data">
                  <thead>
                     <tr>
                        <th>Function name</th>
                        <th>Availability</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr><td>fn:accumulator-after</td><td>XSLT 3.0 only</td></tr>
                     <tr><td>fn:accumulator-before</td><td>XSLT 3.0 only</td></tr>
                     <tr><td>fn:available-system-properties</td><td>XSLT 3.0 only</td></tr>
                     <tr><td>fn:collation-key</td><td>Common to XSLT 3.0 and XPath 3.1</td></tr>
                     <tr><td>fn:copy-of</td><td>XSLT 3.0 only</td></tr>
                     <tr><td>fn:current</td><td>XSLT 1.0, 2.0, and 3.0</td></tr>
                     <tr><td>fn:current-group</td><td>XSLT 2.0 and 3.0</td></tr>
                     <tr><td>fn:current-grouping-key</td><td>XSLT 2.0 and 3.0</td></tr>
                     <tr><td>fn:current-merge-group</td><td>XSLT 3.0 only</td></tr>
                     <tr><td>fn:current-merge-key</td><td>XSLT 3.0 only</td></tr>
                     <tr><td>fn:current-output-uri</td><td>XSLT 3.0 only</td></tr>
                     <tr><td>fn:document</td><td>XSLT 1.0, 2.0, and 3.0</td></tr>
                     <tr><td>fn:element-available</td><td>XSLT 1.0, 2.0, and 3.0</td></tr>
                     <tr><td>fn:format-date</td><td>XSLT 2.0; migrated to XPath 3.0 and 3.1</td></tr>
                     <tr><td>fn:format-dateTime</td><td>XSLT 2.0; migrated to XPath 3.0 and 3.1</td></tr>
                     <tr><td>fn:format-number</td><td>XSLT 1.0 and 2.0; migrated to XPath 3.0 and 3.1</td></tr>
                     <tr><td>fn:format-time</td><td>XSLT 2.0; migrated to XPath 3.0 and 3.1</td></tr>
                     <tr><td>fn:function-available</td><td>XSLT 1.0, 2.0, and 3.0</td></tr>
                     <tr><td>fn:generate-id</td><td>XSLT 1.0 and 2.0; migrated to XPath 3.0 and 3.1</td></tr>
                     <tr><td>fn:json-to-xml</td><td>Common to XSLT 3.0 and XPath 3.1</td></tr>
                     <tr><td>fn:key</td><td>XSLT 1.0, 2.0, and 3.0</td></tr>                    
                     <tr><td>fn:regex-group</td><td>XSLT 2.0 and 3.0</td></tr>
                     <tr><td>fn:snapshot</td><td>XSLT 3.0 only</td></tr>
                     <tr><td>fn:stream-available</td><td>XSLT 3.0 only</td></tr>
                     <tr><td>fn:system-property</td><td>XSLT 1.0, 2.0, and 3.0</td></tr>
                     <tr><td>fn:type-available</td><td>XSLT 2.0 and 3.0</td></tr>
                     <tr><td>fn:unparsed-entity-public-id</td><td>XSLT 2.0 and 3.0</td></tr>
                     <tr><td>fn:unparsed-entity-uri</td><td>XSLT 1.0, 2.0, and 3.0</td></tr>
                     <tr><td>fn:unparsed-text</td><td>XSLT 2.0; migrated to XPath 3.0 and 3.1</td></tr>
                     <tr><td>fn:xml-to-json</td><td>Common to XSLT 3.0 and XPath 3.1</td></tr>                    
                     <tr><td>map:contains</td><td>Common to XSLT 3.0 and XPath 3.1</td></tr>
                     <tr><td>map:entry</td><td>Common to XSLT 3.0 and XPath 3.1</td></tr>
                     <tr><td>map:find</td><td>Common to XSLT 3.0 and XPath 3.1</td></tr>
                     <tr><td>map:for-each</td><td>Common to XSLT 3.0 and XPath 3.1</td></tr>
                     <tr><td>map:get</td><td>Common to XSLT 3.0 and XPath 3.1</td></tr>
                     <tr><td>map:keys</td><td>Common to XSLT 3.0 and XPath 3.1</td></tr>
                     <tr><td>map:merge</td><td>Common to XSLT 3.0 and XPath 3.1</td></tr>
                     <tr><td>map:put</td><td>Common to XSLT 3.0 and XPath 3.1</td></tr>
                     <tr><td>map:remove</td><td>Common to XSLT 3.0 and XPath 3.1</td></tr>
                     <tr><td>map:size</td><td>Common to XSLT 3.0 and XPath 3.1</td></tr>
                  </tbody>
               </table>
               
            </div3>
            <div3 id="functions-defined-in-XForms">
               <head>Functions Defined in XForms</head>
               
               <p>XForms 1.1 is based on XPath 1.0. It adds the following functions to the set defined in XPath 1.0, using the same
               namespace:</p>
               
               <p><code>boolean-from-string</code>, <code>is-card-number</code>, <code>avg</code>, <code>min</code>, <code>max</code>, 
                  <code>count-non-empty</code>, <code>index</code>, <code>power</code>, <code>random</code>, <code>compare</code>,
                  <code>if</code>, <code>property</code>, 
               <code>digest</code>, <code>hmac</code>, <code>local-date</code>, <code>local-dateTime</code>, <code>now</code>, 
                  <code>days-from-date</code>, <code>days-to-date</code>, <code>seconds-from-dateTime</code>, <code>seconds-to-dateTime</code>,
               <code>adjust-dateTime-to-timezone</code>, <code>seconds</code>, <code>months</code>, <code>instance</code>, 
                  <code>current</code>, <code>id</code>, <code>context</code>, <code>choose</code>, <code>event</code>.</p>
               
               <p>XForms 2.0 was first published as a W3C Working Draft, and subsequently as a W3C Community Group specification. These
               draft specifications do not include any additional functions beyond those in the core XPath specification.</p>
            </div3>
            <div3 id="xquery-update">
               <head>Function Defined in XQuery Update 1.0</head>
               <p>The XQuery Update 1.0 specification defines one additional function in the core namespace
                  <code>http://www.w3.org/2005/xpath-functions</code>, namely <code role="example">fn:put</code>. This function can be used
               to write a document to external storage. It is thus unusual in that it has side-effects; the XQuery Update 1.0
               specification defines semantics for updating expressions including this function.</p>
               <p>Although XQuery Update 1.0 is defined as an extension of XQuery 1.0, a number of implementers have adapted it,
               in a fairly intuitive way, to work with later versions of XQuery. At the time of this publication, later versions of the
               XQuery Update specification remain at Working Draft status.</p>
            </div3>
         </div2>       
         <div2 id="functions-defined-by-community-groups">
            <head>Functions Defined by Community Groups</head>
            <p>A number of community groups, with varying levels of formal organization, have defined specifications for
            additional function libraries to augment the core functions defined in this specification. Many of the resulting
            function specifications have implementations available for popular XPath, XQuery, and XSLT processors, though
            the level of support is highly variable.</p>
            
            <p>The first such group was EXSLT. This activity was primarily concerned with augmenting the capability of
            XSLT 1.0, and many of its specifications were overtaken by core functions that became available in XPath 2.0.
            EXSLT defined a number of function modules covering:</p>
            <slist>
               <sitem>Dates and Times</sitem>
               <sitem>Dynamic XPath Evaluation</sitem>
               <sitem>Common (containing most notably the widely used <code>node-set</code> function)</sitem>
               <sitem>Math (<code>max</code>, <code>min</code>, <code>abs</code>, and trigonometric functions)</sitem>
               <sitem>Random Number Generation</sitem>
               <sitem>Regular Expressions</sitem>
               <sitem>Sets (operations on sets of nodes including set intersection and difference)</sitem>
               <sitem>String Manipulation (tokenize, replace, join and split, etc.)</sitem>
            </slist>
            <p>Specifications from the EXSLT group can be found at <bibref ref="exslt"/>.</p>
            
            <p>A renewed attempt to define additional function libraries using XPath 2.0 as its baseline formed
            under the name EXPath. Again, the specifications are in various states of maturity and stability, and
            implementation across popular processors is patchy. At the time of this publication the function libraries that
            exist in stable published form include:</p>
            
            <slist>
               <sitem>Binary (functions for manipulating binary data)</sitem>
               <sitem>File Handling (reading and writing files)</sitem>
               <sitem>Geospatial (handling of geographic data)</sitem>
               <sitem>HTTP Client (sending HTTP requests)</sitem>
               <sitem>ZIP Facility (reading and creating ZIP files or similar archives)</sitem>
            </slist>
            
            <p>The EXPath community has also been engaged in other related projects, such as defining packaging
            standards for distribution of XSLT/XQuery components, and tools for unit testing. Its specifications
            can be found at <bibref ref="expath"/>.</p>
            
            <p>A third activity has operated under the name EXQuery, which as the name suggests has focused
            on extensions to XQuery. EXQuery has published a single specification, RestXQ, which is primarily a 
            system of function annotations allowing XQuery functions to act as endpoints for RESTful services.
            It also includes some simple functions to assist with the creation of such services. The RestXQ specification
            can be found at <bibref ref="exquery"/>.</p>
         </div2>
         

         <div2 id="functx-library">
               <head>The FunctX Library</head>

               <p>Many useful functions can be written in XSLT or XQuery, and in this case the function implementations
                  themselves can be portable across different XSLT and XQuery processors. This section describes one such library.</p>
               
               
               <p>FunctX is an open-source library of general-purpose functions, supplied in the form of XQuery 1.0 and XSLT 2.0
               implementations. It contains over a hundred functions. Typical examples of these functions are:</p>
               
               <slist>
                  <sitem>Test whether a string is all-whitespace</sitem>
                  <sitem>Trim leading and trailing whitespace</sitem>
                  <sitem>Test whether all the values in a sequence are distinct</sitem>
                  <sitem>Capitalize the first character of a string</sitem>
                  <sitem>Change the namespace of all elements in a tree</sitem>
                  <sitem>Get the number of days in a given month</sitem>
                  <sitem>Get the first or last day in a given month</sitem>
                  <sitem>Get the date of the preceding or following day</sitem>
                  <sitem>Ask whether an element has element-only, mixed, or simple content</sitem>
                  <sitem>Find the position of a node in a sequence</sitem>
                  <sitem>Count words in a string</sitem>
               </slist>
               
               <p>The FunctX library can be found at <bibref ref="functx"/>.</p>
            </div2>
         
     </inform-div1>
	  <inform-div1 id="impl-def">
         <head>Implementation-defined features</head>
	      <?imp-def-features?>
	     
      </inform-div1>
	  <inform-div1 id="changelog" diff="chg" at="2022-11-16">
          <head>Changes since 3.1</head>
        <div2 id="changes-summary">
           <head>Summary of Changes</head>
           <?change-log?>
           
           
           
	     </div2>
	     
	     <div2 id="changes-to-casts-and-constructors">
	        <head>Changes to Casts and Constructor Functions</head>
	        <olist>
	           <item><p>The keyword for the argument has changed from <code>arg</code> to <code>value</code>.</p></item>
	           <item><p>The argument is now optional, and defaults to the context value (which is atomized if necessary).
	           This change aligns constructor functions such as <code>xs:string</code>, <code>xs:boolean</code>,
	              and <code>xs:numeric</code> with <function>fn:string</function>, <function>fn:boolean</function>,
	              and <function>fn:number</function>.</p></item>
	        </olist>
	     </div2>
	     <div2 id="miscellaneous-changes">
	        <head>Miscellaneous Changes</head>
	        <olist>
	           <item><p>The semantics of the HTML case-insensitive collation 
	              <code>"http://www.w3.org/2005/xpath-functions/collation/html-ascii-case-insensitive"</code>
	              are now defined normatively in this specification rather than by reference to the 
	              living HTML5 specification (which has changed since 3.1); and the rules now make ordering explicit rather than leaving
	              it implementation-defined.</p></item>
	           <item><p>An option in an <termref def="options">option map</termref> is now rejected if
                it is not described in the specification, if it is not supported by the implementation
                and if its name is in no namespace.</p></item>
	        </olist>
	     </div2>
	     <div2 id="editorial-changes">
	        <head>Editorial Changes</head>
	        <p>These changes are not highlighted in the change-marked version of the specification.</p>
	        <olist>
	           <item><p>The operator mapping table has been simplified so all the value comparison operators
	              are now defined in terms of two functions (for each data type): <code role="example">op:XX-equal</code>,
	              and <code role="example">op:XX-less-than</code>. The entries for <code role="example">op:XX-greater-than</code>
	           have therefore been removed.</p></item>
	           <item><p>The names of parameters appearing in function signatures have been changed. This
	           is to reflect the introduction of keyword arguments in XPath 4.0; the names chosen
	           for parameters are now more consistent across the function library.</p>
	           
	           <p>In 3.1 and earlier versions, the keywords used in the specification were for documentation
	           purposes only, so these changes do not affect backwards compatibility.</p>
	           
	           </item>
	           <item><p>Where appropriate, the phrase "the value of <code>$x</code>" has been replaced
	           by the simpler <code>$x</code>. No change in meaning is intended.</p></item>
	           <item><p>For functions that take a variable number of arguments, wherever possible
	           the specification now gives a single function signature indicating default values
	           for arguments that may be omitted, rather than multiple signatures.</p></item>
	           <item><p>The formal specifications of array functions have been rewritten to use two new
	              primitives: <code role="example">array:members</code> which converts an array to a sequence of value records, 
	              and <code role="example">array:of-members</code> which does the inverse. This has enabled many of the
	           functions to be specified more concisely, and with less duplication between similar functions
	           for sequences and arrays.</p></item>
	           <item><p>The appendix containing illustrative user-written functions has been dropped;
	           many of these functions are no longer needed.</p></item>

	        </olist>
	     </div2>
	  </inform-div1>
	     
	     

     <inform-div1 id="back-compatibility" diff="chg" at="A">
         <head>Backward compatibility</head>
         
         <p>This section summarizes the extent to which this specification is compatible with previous versions.</p>
         
         <p>Version 4.0 of this function library is fully backwards compatible with version 3.1, except as noted
         below:</p>
        
        <olist>
           <item>
              <p>In <function>fn:deep-equal</function>, and in other functions such as <function>fn:distinct-values</function>
              that refer to <function>fn:deep-equal</function>, the rules for comparing values of different numeric types 
                 (for example, <code>xs:double</code> and <code>xs:decimal</code>) have changed. 
                 In previous versions of the specification, <code>xs:decimal</code> values were converted
              to <code>xs:double</code>, leading to a possible loss of precision. This could make 
              comparisons non-transitive, leading to problems when grouping,
              and potentially (depending on the sort algorithm) with sorting. The problem has been fixed by requiring
              comparisons to be performed based on the exact mathematical value without any loss of precision.</p>
              
              <p>This means, for example, that <code>deep-equal(0.2, 0.2e0)</code> is now false, whereas in previous
              versions it was true. The two values are not mathematically equal, because the exact decimal equivalent
              of the <code>xs:double</code> value written as <code>0.2e0</code> is 
                 <code>0.200000000000000011102230246251565404236316680908203125</code>.</p>
              
              <p>The corresponding change has not been made to the <code>=</code> and <code>eq</code> operators,
              because it was found to be too disruptive. For example, if the context node is the element
              &lt;e price="10.0" discount="0.2"/>, there is an expectation that the expression 
                 <code>@price - @discount = 9.8</code> should return true. But (assuming untyped data), the result of
              the subtraction is an <code>xs:double</code> whose precise value is 
                 <code>9.800000000000000710542735760100185871124267578125</code>, so comparing the two values as
              decimals would return false.</p>
           </item>
           <item diff="add" at="2024-06-18">
              <p>In previous versions, unrecognized options supplied to the <code>$options</code>
              parameter of functions such as <function>fn:parse-json</function> were silently ignored. In
              4.0, they are rejected as a type error, unless they are QNames with a non-absent namespace,
              or are extensions recognized by the implementation.</p>
           </item>
           <item diff="add" at="2022-12-18">
              <p>In version 4.0, omitting the <code>$value</code> of <function>fn:error</function> has the same
                 effect as setting it to an empty sequence. In 3.1, the effects could be different (the effect of omitting
                 the argument was implementation-defined).</p>
           </item>
           <item diff="add" at="2023-03-13">
              <p>In version 3.1, the <function>fn:deep-equal</function> function did not merge adjacent text nodes after stripping
                 comments and processing instructions, so the elements <code><![CDATA[<a>abc<!--note1-->def</code>]]></code>
                 and <code><![CDATA[<a>abcde<!--note2-->f</code>]]></code> were considered non-equal. In version 4.0, 
                 the text nodes are now merged prior to comparison, so these two elements compare equal.</p>
           </item>
           <item diff="add" at="2024-10-01">
              <p>The format of numeric values in the output of <function>fn:xml-to-json</function> may be different. 
                 In version 3.1, the supplied value was parsed as an <code>xs:double</code> and then serialized
                 using the casting rules, resulting in an input value of 10000000 being output as <code>1e7</code>.
                 In version 4.0, the value is output <emph>as is</emph>, except for any changes (such as stripping
                 of leading zeroes or a leading plus sign) that might be needed to ensure the result is valid JSON.</p>
           </item>
           <item diff="add" at="2023-03-06">
              <p>In version 4.0, the function signature of <function>fn:namespace-uri-for-prefix</function> constrains the
                 first argument to be either an <code>xs:NCName</code> or a zero-length string (the new coercion rules
                 mean that any string in the form of an <code>xs:NCName</code> is acceptable). If a string is supplied
                 that does not meet these requirements, a type error will be raised. In version 3.1, this was not an error:
                 it came under the rule that when no namespace binding existed for the supplied prefix, the function
                 would return an empty sequence.</p>
              <p>Furthermore, because the expected type of this parameter is no longer <code>xs:string</code>, the
              special coercion rules for <code>xs:string</code> parameters in XPath 1.0 compatibility mode no longer apply.
              For example, supplying <code>xs:duration('PT1H')</code> as the first argument will now raise a
              type error, rather than looking for a namespace binding for the prefix <code>PT1H</code>.</p>
           </item>
           <item diff="add" at="issue687">
              <p>Version 4.0 makes it clear that the casting of a value other than <code>xs:string</code>
              or <code>xs:untypedAtomic</code> to a list type (whether using a cast expression or a
                 constructor function) is a type error <xerrorref spec="XP" class="TY" code="0004" type="type"/>. 
                 Previously this was defined as an error, but the kind of error and the error code were left unspecified.
              Accordingly, the function signatures of the constructor functions for built-in list types
              have been changed to use an argument type of <code>xs:string?</code>.</p>
           </item>
           <item diff="add" at="issue866">
              <p>The way that <function>fn:min</function> and <function>fn:max</function> compare numeric values of different types
              has changed. The most noticeable effect is that when these functions are applied to a sequence of
                 <code>xs:integer</code> or <code>xs:decimal</code> values, the result is an <code>xs:integer</code> or 
                 <code>xs:decimal</code>, rather than the result of converting this to an <code>xs:double</code>.</p>
           </item>
           <item diff="add" at="issue780">
              <p>The type of the third argument of <function>fn:format-number</function> has 
                 changed from <code>xs:string</code> to <code>(xs:string | xs:QName)</code>.
                 Because the expected type of this parameter is no longer <code>xs:string</code>, the
                 special coercion rules for <code>xs:string</code> parameters no longer apply.
                 For example, it is no
              longer possible to supply an instance of <code>xs:anyURI</code> or (when XPath 1.0 compatibility
              mode is in force) an instance of <code>xs:boolean</code> or <code>xs:duration</code>.</p>
           </item>

           <item diff="add" at="issue1725">
              <p>When <function>fn:put</function> replaces an entry in a map with a new value for an
              existing key, in the case where the existing key and the new key differ (for example,
              if they have different type annotations), it is no longer guaranteed that the new
              entry includes the new key rather than the existing key.</p>
		   </item>

           <item>
              <p>In regular expressions, the assertions <code>^</code> and <code>$</code> can no longer be
              followed by a quantifier. This is because (a) a quantifier that allows zero occurrences means
              that the assertion will always match, and (b) a quantifier that allows multiple occurrences
              has no effect. Processors may provide an option that allows such regular expressions to be
              accepted for compatibility reasons.</p>

           </item>
        </olist>
 
         <p>For compatibility issues regarding earlier versions, see the 3.1 version of this specification.</p>
         
         
         
         
      </inform-div1>
   </back>
 </spec>
