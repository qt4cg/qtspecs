<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2024/">2024</a>, <a href="2023/">2023</a>, <a href="2022/">2022</a>, <a href="2021/">2021</a>, <a href="2020/">2020</a></p><div class="toots">
<div class="toot" id="created-1030"><h2>Issue #1030 created<span class="toot-id"> #created-1030</span></h2><div class="pubdate">20 Feb at 14:37:07 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1030">https://github.com/qt4cg/qtspecs/issues/1030</a></div><details><summary>allow pattern matches in axis expression</summary><div class="markup"><p>There's a danger that this already exists, and that i dont know about it, but i dont think it does.</p>
<p>Consider this SO question.</p>
<p>https://stackoverflow.com/questions/78027093/selecting-preceding-cousins-inclusing-siblings</p>
<p>the questioner is writing this</p>
<p><code>/root/level1/level2[@id='6']/preceding::level2[parent::level1[parent::root]][1]</code></p>
<p>eeek...look at the nasty nested predicates</p>
<p>when he/she wants to write this</p>
<p><code>/root/level1/level2[@id='6']/preceding::(root/level/level2)[1]</code></p>
<p>there is an answer on the question which sort of shows how horrific the problem is in general.</p>
<p>(its a problem that crops up quite a lot for me)</p>
</div></details></div>
<div class="toot" id="created-1029"><h2>Issue #1029 created<span class="toot-id"> #created-1029</span></h2><div class="pubdate">20 Feb at 09:50:07 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1029">https://github.com/qt4cg/qtspecs/issues/1029</a></div><details><summary>Make argument of fn:void optional</summary><div class="markup"><p>If you want to supply a function that always returns an empty sequence, fn:void#0 would be useful; but currently there is no arity-zero variant.</p>
<p>Example: <code>map:build(...., combine:=fn:void#0)</code> returns a map in which any key that occurs more than once in the input is mapped to an empty sequence.</p>
<p>The first argument of <code>fn:void</code> should default to an empty sequence.</p>
</div></details></div>
<div class="toot" id="created-1028"><h2>Pull request #1028 created<span class="toot-id"> #created-1028</span></h2><div class="pubdate">19 Feb at 11:34:05 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1028">https://github.com/qt4cg/qtspecs/pull/1028</a></div><details><summary>960(partial) Recognize alternative representation of JSON null</summary><div class="markup"><p>Defines an option in parse-json and json-doc to define a representation for JSON null, defaulting to <code>()</code> as currently used. Selecting a different value may be useful because it bypasses the problem that the <code>?</code> and <code>??</code> operators flatten the results, causing <code>()</code> to be elided.</p>
<p>Suggests use of the QName <code>fn:null</code> as an alternative representation; and changes the JSON serialization method to recognize this QName as a representation of null.</p>
</div></details></div>
<div class="toot" id="created-1027"><h2>Pull request #1027 created<span class="toot-id"> #created-1027</span></h2><div class="pubdate">17 Feb at 22:21:06 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1027">https://github.com/qt4cg/qtspecs/pull/1027</a></div><details><summary>150 fn:ranks</summary><div class="markup"><p>As proposed and discussed  here: https://github.com/qt4cg/qtspecs/issues/150</p>
</div></details></div>
<div class="toot" id="created-1026"><h2>Issue #1026 created<span class="toot-id"> #created-1026</span></h2><div class="pubdate">17 Feb at 09:44:59 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1026">https://github.com/qt4cg/qtspecs/issues/1026</a></div><details><summary>XSLT match patterns on pinned maps and arrays</summary><div class="markup"><p>Given that <code>&lt;xsl:apply-templates select="pin(.)??course?code"/&gt;</code> will select items that are labeled with their position in the containing tree of maps and arrays, it should be possible to match the selected items with a match pattern of the form</p>
<p><code>match="?course?code"</code></p>
<p>that operates in a similar way to patterns such as <code>course/code</code> in XML.</p>
<p>Perhaps the pinning of the map should be done automatically by the <code>xsl:apply-templates</code> instruction.</p>
</div></details></div>
<div class="toot" id="created-1025"><h2>Pull request #1025 created<span class="toot-id"> #created-1025</span></h2><div class="pubdate">13 Feb at 21:25:18 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1025">https://github.com/qt4cg/qtspecs/pull/1025</a></div><details><summary>1001 Fix incorrect operator precedence in subsequence-where</summary><div class="markup"><p>Fixes the "equivalent expression" to subsequence-where.</p>
<p>Fix issue #1001</p>
</div></details></div>
<div class="toot" id="created-1024"><h2>Issue #1024 created<span class="toot-id"> #created-1024</span></h2><div class="pubdate">13 Feb at 21:10:56 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1024">https://github.com/qt4cg/qtspecs/issues/1024</a></div><details><summary>Precedence of `otherwise` operator</summary><div class="markup"><p>I made a mistake when specifying subsequence-where, caused by misunderstanding the precedence of the <code>otherwise</code> operator: see issue #1001.</p>
<p>In the expression</p>
<pre><code>let $start := index-where($input, $from)[1] 
              otherwise count($input) + 1
</code></pre>
<p>I failed to realise that <code>otherwise</code> binds more tightly than <code>+</code>.</p>
<p>I'm opening the issue to solicit views as to whether we have got this right.</p>
<p>One might take the view that the closest thing to <code>otherwise</code> in other familiar language is the ternary conditional operator, which has lower precedence than anything else including <code>and</code> and <code>or</code>; but then, its first operand is a boolean expression while it's relatively unlikely that the operands of <code>otherwise</code> will be boolean. I'm therefore thinking that it might be best to put it between 'eq' and '||`, so</p>
<p><code>$a eq $b otherwise $c || $d</code></p>
<p>parses as</p>
<p><code>$a eq ($b otherwise ($c || $d))</code></p>
</div></details></div>
<div class="toot" id="closed-827"><h2>Issue #827 closed<span class="toot-id"> #closed-827</span></h2><div class="pubdate">13 Feb at 20:04:46 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/827">https://github.com/qt4cg/qtspecs/issues/827</a></div><p>map:empty, map:exists ← array:empty, array:exists</p></div>
<div class="toot" id="closed-779"><h2>Issue #779 closed<span class="toot-id"> #closed-779</span></h2><div class="pubdate">13 Feb at 20:02:43 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/779">https://github.com/qt4cg/qtspecs/issues/779</a></div><p>Hash/checksum function</p></div>
<div class="toot" id="closed-978"><h2>Issue #978 closed<span class="toot-id"> #closed-978</span></h2><div class="pubdate">13 Feb at 17:21:34 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/978">https://github.com/qt4cg/qtspecs/pull/978</a></div><p>948 Reflected the comments of the CG on the specification of scan-left and scan-right</p></div>
<div class="toot" id="minutes-02-13"><h2>QT4 CG meeting 065 draft minutes<span class="toot-id"> #minutes-02-13</span></h2><div class="pubdate">13 Feb at 17:20:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2024/02-13">https://qt4cg.org/meeting/minutes/2024/02-13</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="closed-720"><h2>Issue #720 closed<span class="toot-id"> #closed-720</span></h2><div class="pubdate">13 Feb at 17:18:22 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/720">https://github.com/qt4cg/qtspecs/issues/720</a></div><p>From Records to Objects</p></div>
<div class="toot" id="closed-985"><h2>Issue #985 closed<span class="toot-id"> #closed-985</span></h2><div class="pubdate">13 Feb at 17:18:21 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/985">https://github.com/qt4cg/qtspecs/pull/985</a></div><p>720 Add lookup arrow expressions (method invocations)</p></div>
<div class="toot" id="closed-949"><h2>Issue #949 closed<span class="toot-id"> #closed-949</span></h2><div class="pubdate">13 Feb at 17:15:45 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/949">https://github.com/qt4cg/qtspecs/issues/949</a></div><p>Partial Function Applications: Allow return of function name</p></div>
<div class="toot" id="closed-972"><h2>Issue #972 closed<span class="toot-id"> #closed-972</span></h2><div class="pubdate">13 Feb at 17:15:44 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/972">https://github.com/qt4cg/qtspecs/pull/972</a></div><p>949 Partial Function Applications: Allow return of function name</p></div>
<div class="toot" id="closed-42"><h2>Issue #42 closed<span class="toot-id"> #closed-42</span></h2><div class="pubdate">13 Feb at 17:13:19 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/42">https://github.com/qt4cg/qtspecs/issues/42</a></div><p>Relax type incompatibility in order by clause (impl. dep. instead of XPST0004)</p></div>
<div class="toot" id="closed-55"><h2>Issue #55 closed<span class="toot-id"> #closed-55</span></h2><div class="pubdate">13 Feb at 17:13:05 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/55">https://github.com/qt4cg/qtspecs/issues/55</a></div><p>Provide an XML version of the stack trace</p></div>
<div class="toot" id="closed-79"><h2>Issue #79 closed<span class="toot-id"> #closed-79</span></h2><div class="pubdate">13 Feb at 17:12:58 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/79">https://github.com/qt4cg/qtspecs/issues/79</a></div><p>fn:deep-normalize-space($e as node())</p></div>
<div class="toot" id="closed-989"><h2>Issue #989 closed<span class="toot-id"> #closed-989</span></h2><div class="pubdate">13 Feb at 17:12:52 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/989">https://github.com/qt4cg/qtspecs/issues/989</a></div><p>character sequence constructor 'a' to 'z'</p></div>
<div class="toot" id="closed-994"><h2>Issue #994 closed<span class="toot-id"> #closed-994</span></h2><div class="pubdate">13 Feb at 17:12:44 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/994">https://github.com/qt4cg/qtspecs/issues/994</a></div><p>Invoking maps &amp; arrays: allow sequences?</p></div>
<div class="toot" id="closed-1009"><h2>Issue #1009 closed<span class="toot-id"> #closed-1009</span></h2><div class="pubdate">13 Feb at 17:08:23 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1009">https://github.com/qt4cg/qtspecs/issues/1009</a></div><p>QT4CG-064-03, QT4CG-064-04: Examples, Return type of `fallback`</p></div>
<div class="toot" id="closed-1010"><h2>Issue #1010 closed<span class="toot-id"> #closed-1010</span></h2><div class="pubdate">13 Feb at 17:08:21 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1010">https://github.com/qt4cg/qtspecs/pull/1010</a></div><p>1009 Examples, Return type of parse-json:fallback</p></div>
<div class="toot" id="closed-916"><h2>Issue #916 closed<span class="toot-id"> #closed-916</span></h2><div class="pubdate">13 Feb at 15:33:23 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/916">https://github.com/qt4cg/qtspecs/pull/916</a></div><p>720 Allow methods in maps with access to $this</p></div>
<div class="toot" id="created-1023"><h2>Pull request #1023 created<span class="toot-id"> #created-1023</span></h2><div class="pubdate">13 Feb at 12:39:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1023">https://github.com/qt4cg/qtspecs/pull/1023</a></div><details><summary>1020 explain consequences of function coercion</summary><div class="markup"><p>Adds explanatory material to explain my interpretation of the spec and the consequences on backwards compatibility. No change to the spec is proposed. (To review the PR, I suggest reading the change markings in the XQuery spec.)</p>
<p>Fix issue #1020</p>
</div></details></div>
<div class="toot" id="created-1022"><h2>Pull request #1022 created<span class="toot-id"> #created-1022</span></h2><div class="pubdate">13 Feb at 11:51:44 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/1022">https://github.com/qt4cg/qtspecs/pull/1022</a></div><details><summary>999 Allow comments in regular expressions</summary><div class="markup"><p>Fix #999</p>
</div></details></div>
<div class="toot" id="created-1021"><h2>Issue #1021 created<span class="toot-id"> #created-1021</span></h2><div class="pubdate">12 Feb at 12:46:10 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1021">https://github.com/qt4cg/qtspecs/issues/1021</a></div><details><summary>Extend `fn:doc`, `fn:collection` and `fn:uri-collection` with options maps</summary><div class="markup"><p><code>fn:doc</code>, <code>fn:collection</code> and <code>fn:uri-collection</code> currently expect only a single argument, a URI.</p>
<p>There is no way of adding additional parameters to those functions.</p>
<p>Several implementations of XPath have worked around that limitation by</p>
<ol>
<li>passing of parameters via query string as part of the URI:</li>
</ol>
<ul>
<li>see https://www.saxonica.com/documentation10/index.html#!sourcedocs/collections</li>
<li>exist-db's implementation of <code>uri-collection</code> works similarly</li>
</ul>
<ol start="2">
<li>create custom functions in other namespaces to add an options map as a second parameter</li>
</ol>
<ul>
<li><code>saxon:doc</code> in Saxon https://www.saxonica.com/documentation10/index.html#!changes/extensions/9.7-9.8</li>
<li><code>fetch:doc</code> in baseX https://docs.basex.org/wiki/Fetch_Module#fetch:doc</li>
</ul>
<p>While both approaches do work well, they do fall flat in terms of interoperability and discoverability.
A script written for Saxon leveraging <code>saxon:doc</code> will not work on baseX in vice versa even though they offer options with some overlap.
And a developer looking at the language specification will not discover that these options even exist.</p>
<p>I would like to add a second signature to the above functions with an options map as a second argument.</p>
<pre><code class="language-xquery">fn:doc($href as xs:string?) as document-node()?
fn:doc($href as xs:string?, $options as map(xs:string, *)? := ()) as document-node()?
</code></pre>
<p>NOTE: Looking at the other two functions below I believe the first parameter should be defined as <code>$href as xs:string? := ()</code></p>
<pre><code class="language-xquery">fn:collection( $uri as&nbsp;xs:string? :=&nbsp;())&nbsp;as&nbsp;item()*
fn:collection( $uri as&nbsp;xs:string? :=&nbsp;(), $options as map(xs:string, *)? := ())&nbsp;as&nbsp;item()*
</code></pre>
<pre><code class="language-xquery">fn:uri-collection( $uri as&nbsp;xs:string? :=&nbsp;())&nbsp;as&nbsp;xs:anyURI*
fn:uri-collection( $uri as&nbsp;xs:string? :=&nbsp;(), $options as map(xs:string, *)? := ())&nbsp;as&nbsp;xs:anyURI*
</code></pre>
<p>Since a lot of those options depend on the current runtime most of them will be "free" options.
This will also help us get to a specification quickly and circumvent long infighting about some very specific details.</p>
<p>I do see, however, a good chance of specifying a small set of options that would work across implementations.</p>
<h2>Possible standard options</h2>
<h3>For <code>fn:doc</code></h3>
<ul>
<li><code>validation</code>: wether and how to validate the input files against a schema</li>
<li><code>whitespace</code>: (<code>strip-space</code>, <code>stripws</code>) what to do with whitespace in the input document</li>
<li><code>parser</code>: could be used to define a different parser (for html documents)</li>
</ul>
<h3>For <code>collection</code> and <code>uri-collection</code> I see the following:</h3>
<ul>
<li><code>recurse</code>: traverse collection trees down into its subcollections</li>
<li><code>stable</code>: this is already vaguely mentioned in the spec and would benefit from a clearer specification</li>
<li><code>type</code>: (aka <code>media-type</code> or <code>content-type</code>) while the allowed values will be implementation defined the key should be standardised</li>
</ul>
<p>This would bring the above functions to follow a pattern developers are already familiar with (see <code>fn:serialize</code> and others)</p>
<p>Thanks for initial input by @ChristianGruen, Liam Quin and @michaelhkay</p>
</div></details></div>
<div class="toot" id="agenda-02-13"><h2>QT4 CG meeting 065 draft agenda<span class="toot-id"> #agenda-02-13</span></h2><div class="pubdate">12 Feb at 11:45:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2024/02-13">https://qt4cg.org/meeting/agenda/2024/02-13</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="created-1020"><h2>Issue #1020 created<span class="toot-id"> #created-1020</span></h2><div class="pubdate">11 Feb at 23:56:50 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1020">https://github.com/qt4cg/qtspecs/issues/1020</a></div><details><summary>When to apply the coercion rules</summary><div class="markup"><p>The rules for function calling say that the coercion rules are applied to the values supplied as function arguments; they are also applied in other circumstances such as when binding values to variables. The coercion rules are applied (as far as the spec is concerned) whether or not the supplied value already matches the required type.</p>
<p>Saxon has always attempted to optimise this process: if the supplied value is already an instance of the required type, no coercion takes place.</p>
<p>I have discovered at least one case where this assumption is incorrect: the coercion rules are not idempotent in the case where the supplied value matches the required type. This case concerns function coercion, exemplified by the new test case FunctionCall-058: if the expected type of a callback parameter is <code>function(xs:integer) as xs:boolean</code>, and the supplied value for the callback is a function that accepts <code>xs:decimal</code>, then the coercion rules say that a call to the supplied function that supplies an <code>xs:decimal</code> must be rejected as a type error even though the supplied function accepts it.</p>
<p>Note that this means we have introduced a rather subtle backwards incompatibility. In XQuery 3.1, coercion was not applied to variable bindings, so the following would work (the supplied function matches the declared type of the variable):</p>
<pre><code>declare variable $f as function(xs:integer) as xs:boolean 
              := function($x as item()) as xs:boolean {string($x)};
return $f("banana");
</code></pre>
<p>(see new tests VarDecl065/066)</p>
<p>In 4.0 I believe this is supposed to throw a type error, because the supplied function is wrapped in a wrapper function that checks that the supplied argument is an integer.</p>
<p>We have extended the coercion rules considerably in 4.0, and we need to be confident that there are no other similar cases where the coercion rules are no longer idempotent.</p>
</div></details></div>
<div class="toot" id="created-1019"><h2>Issue #1019 created<span class="toot-id"> #created-1019</span></h2><div class="pubdate">11 Feb at 15:23:07 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1019">https://github.com/qt4cg/qtspecs/issues/1019</a></div><details><summary>XQFO: Unknown option parameters</summary><div class="markup"><p>The current <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#option-parameter-conventions">option parameter conventions</a> are:</p>
<blockquote>
<ol start="4">
<li>It is not an error if the options map contains options with names other than those described in this specification. Implementations MAY attach an ·implementation-defined· meaning to such entries, and MAY define errors that arise if such entries are present with invalid values. Implementations MUST ignore such entries unless they have a specific ·implementation-defined· meaning. Implementations that define additional options in this way SHOULD use values of type <code>xs:QName</code> as the option names, using an appropriate namespace.</li>
</ol>
</blockquote>
<p>The obvious consequence is that wrongly typed or unsupported options are not reported as such:</p>
<pre><code class="language-xquery">serialize($node, map { 'format': 'html' })
</code></pre>
<p>I think we should still allow proprietary options, but raise errors when an option is neither defined in the specification nor supported by the given implementation. On the one hand, this will help users to spot typos (e.g., <code>byte-order-mask</code> or instead of <code>byte-order-mark</code>). On the other hand, options that are supported by one implementation will be rejected, which feels reasonable to me, as options usually change either the result, or the way how the input is treated.</p>
<p>If we believe that this change is too disruptive, we could tolerate entries with <code>xs:QName</code> keys.</p>
</div></details></div>
<div class="toot" id="created-1018"><h2>Issue #1018 created<span class="toot-id"> #created-1018</span></h2><div class="pubdate">11 Feb at 07:01:28 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1018">https://github.com/qt4cg/qtspecs/issues/1018</a></div><details><summary>Output of parse-csv()</summary><div class="markup"><p>I propose making some simplifications to the output of parse-csv() to make it more amenable to processing.</p>
<ol>
<li>Represent each row as a map, rather than as a structure with a data field and an accessor function. Note that implementations worried about memory usage can devise a custom map implementation optimised for the case where many maps have the same regular structure. (cf recent thread about Javascript "shapes")</li>
<li>The key for a field in this map should be an integer if (i) column-names is set to false, or (ii) the column in question does not have a unique header name; in other cases it should be the name from the header.</li>
<li>Replace the top-level <code>columns</code> record with a simple array of field names. It's easy enough to map names to positions using index-of.</li>
</ol>
<p>I also propose changing the name to <code>csv-to-maps</code> for consistency with <code>csv-to-table</code> and <code>csv-to-arrays</code>.</p>
<p>We should advocate use of csv-to-arrays where data is to be accessed positionally, and csv-to-maps where it is to be accessed by column names, and optimise the design accordingly.</p>
<p>Looking at a use case, the first example (§15.4.7.1) would be unnecessary if as proposed we change csv-to-xml to generate XHTML directly, But if it were needed, it would change from</p>
<pre><code>let $csv := fn:parse-csv(`name,city{$crlf}Bob,Berlin`)
return &lt;table&gt;
   &lt;thead&gt;{
      for $column in $csv?columns?fields
         return &lt;th&gt;{ $column }&lt;/th&gt;
   }&lt;/thead&gt;
   &lt;tbody&gt;{
      for $row in $csv?rows return &lt;tr&gt;
         { for $field in $row?fields return &lt;td&gt;{ $field }&lt;/td&gt; }
      &lt;/tr&gt;
   }&lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<p>to</p>
<pre><code>let $csv := fn:parse-csv(`name,city{$crlf}Bob,Berlin`)
return &lt;table&gt;
   &lt;thead&gt;{
      for $column in $csv?columns
         return &lt;th&gt;{ $column }&lt;/th&gt;
   }&lt;/thead&gt;
   &lt;tbody&gt;{
      for $row in $csv?rows return &lt;tr&gt;
         { for $column in $csv?columns return &lt;td&gt;{ $row?$column }&lt;/td&gt; }
      &lt;/tr&gt;
   }&lt;/tbody&gt;
&lt;/table&gt;

</code></pre>
</div></details></div></div><p>See 1951
            more statuses in yearly archives.</p></article></main></body></html>