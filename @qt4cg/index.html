<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2025/">2025</a>, <a href="2024/">2024</a>, <a href="2023/">2023</a>, <a href="2022/">2022</a>, <a href="2021/">2021</a>, <a href="2020/">2020</a></p><div class="toots">
<div class="toot" id="agenda-08-12"><h2>QT4 CG meeting 132 draft agenda<span class="toot-id"> #agenda-08-12</span></h2><div class="pubdate">11 Aug at 12:20:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2025/08-12">https://qt4cg.org/meeting/agenda/2025/08-12</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="created-2159"><h2>Issue #2159 created<span class="toot-id"> #created-2159</span></h2><div class="pubdate">10 Aug at 05:16:54 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/2159">https://github.com/qt4cg/qtspecs/issues/2159</a></div><details><summary>JNodes: Learning from JSONiq?</summary><div class="markup"><p>For those who have not stumbled upon JSONiq yet, I am adding some introductory links:</p>
<ul>
<li>https://www.jsoniq.org/docs/JSONiq-usecases/html-single/</li>
<li>https://www.jsoniq.org/docs/Introduction_to_JSONiq/html/</li>
<li>https://www.jsoniq.org/docs/JSONiqExtensionToXQuery/html-single/index.html</li>
</ul>
<p>JSONiq has been designed as a query and update language for JSON data. Its first versions were based on XQuery. Due to its similarities, it may give us some good inspirations for traversing and modifying JNodes.</p>
<p><a href="https://www.rumbledb.org/">RumbleDB</a> is a current implementation maintained by Ghislain Fourny (@ghislainfourny).</p>
</div></details></div>
<div class="toot" id="created-2158"><h2>Pull request #2158 created<span class="toot-id"> #created-2158</span></h2><div class="pubdate">09 Aug at 11:29:04 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/2158">https://github.com/qt4cg/qtspecs/pull/2158</a></div><details><summary>2157 Editorial updates to F+O §5.5 (Unicode collations)</summary><div class="markup"><p>Fix #2157</p>
</div></details></div>
<div class="toot" id="created-2157"><h2>Issue #2157 created<span class="toot-id"> #created-2157</span></h2><div class="pubdate">09 Aug at 10:18:55 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/2157">https://github.com/qt4cg/qtspecs/issues/2157</a></div><details><summary>Unicode collation algorithm references</summary><div class="markup"><p>In the F&amp;O reference to UTS#10 we say incorrectly that: The current version is 9.0.0, dated 2016-05-18.</p>
<p>Similarly for UTS#35 we say incorrectly: The current version is 29, dated 2016-03-15.</p>
<p>In §5.5, functions based on substring matching, we say</p>
<p>"In the definitions below, we refer to the terms match and minimal match as defined in definitions DS2 and DS4 of [[UTS #10]]."</p>
<p>It's not made clear what "the definitions below" is referring to: the terms "match" and "minimal match" are actually used in the rules of the individual functions.</p>
<p>The parenthetical sentence <code>(“collation unit” is equivalent to "collation element" as defined in [[UTS #10]])</code> is not very elegantly expressed.</p>
</div></details></div>
<div class="toot" id="created-2156"><h2>Pull request #2156 created<span class="toot-id"> #created-2156</span></h2><div class="pubdate">08 Aug at 21:35:41 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/2156">https://github.com/qt4cg/qtspecs/pull/2156</a></div><details><summary>2092 Drop map:pair, map:of-pairs, map-pairs</summary><div class="markup"><p>Addresses part of issue #2092.</p>
<p>While the function family <code>map:pair</code>, <code>map:of-pairs</code>, and <code>map:pairs</code> can be handy, they are not necessary, especially now that we have JNodes. They are also very easily user-written:</p>
<p><code>map:pair =&gt; {'key': $key, 'value': $value}</code></p>
<p><code>map:of-pairs =&gt; map:build($pairs, fn{?key}, fn{?value})</code></p>
<p><code>map:pairs =&gt; map:for-each($map, fn($k, $v){  {'key': $k, 'value': $v })</code></p>
<p>On the grounds that we should avoid providing multiple ways of solving the same problem, I propose dropping these three functions.</p>
<p>Note: in some ways I would have preferred to drop the alternative trio map:entry, map:entries, and map:merge; but two of these are present in the 3.1 specification.</p>
</div></details></div>
<div class="toot" id="closed-2021"><h2>Issue #2021 closed<span class="toot-id"> #closed-2021</span></h2><div class="pubdate">08 Aug at 18:31:46 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/2021">https://github.com/qt4cg/qtspecs/issues/2021</a></div><p>XSLT: Move "Patterns" section into "Template Rules"</p></div>
<div class="toot" id="closed-2078"><h2>Issue #2078 closed<span class="toot-id"> #closed-2078</span></h2><div class="pubdate">08 Aug at 01:28:21 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/2078">https://github.com/qt4cg/qtspecs/issues/2078</a></div><p>2031/2025 JNodes: inconsistency in data model taxonomy, definitions</p></div>
<div class="toot" id="created-2155"><h2>Pull request #2155 created<span class="toot-id"> #created-2155</span></h2><div class="pubdate">07 Aug at 12:02:37 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/2155">https://github.com/qt4cg/qtspecs/pull/2155</a></div><details><summary>2150 Define patterns for JNodes</summary><div class="markup"><p>Fix #2150
Fix #2010</p>
</div></details></div>
<div class="toot" id="closed-2151"><h2>Issue #2151 closed<span class="toot-id"> #closed-2151</span></h2><div class="pubdate">07 Aug at 09:06:48 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/2151">https://github.com/qt4cg/qtspecs/pull/2151</a></div><p>2021 Move the section on Patterns to a more logical place in the spec</p></div>
<div class="toot" id="closed-2153"><h2>Issue #2153 closed<span class="toot-id"> #closed-2153</span></h2><div class="pubdate">07 Aug at 08:27:56 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/2153">https://github.com/qt4cg/qtspecs/issues/2153</a></div><p>Remove limitations from `enum` type</p></div>
<div class="toot" id="created-2154"><h2>Pull request #2154 created<span class="toot-id"> #created-2154</span></h2><div class="pubdate">07 Aug at 08:25:22 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/2154">https://github.com/qt4cg/qtspecs/pull/2154</a></div><details><summary>2152 Revise rules for enumeration types</summary><div class="markup"><p>Fix #2152</p>
<p>Revises the rules for enumeration types: they are now structural subtypes of <code>xs:string</code> rather than nominative subtypes. The main effect is that <code>"x" instance of enum("x")</code> is now true. The change is motivated by use cases involving XSLT pattern matching, where strict "instance of" matching is required, with no coercion.</p>
</div></details></div>
<div class="toot" id="created-2153"><h2>Issue #2153 created<span class="toot-id"> #created-2153</span></h2><div class="pubdate">06 Aug at 18:53:06 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/2153">https://github.com/qt4cg/qtspecs/issues/2153</a></div><details><summary>Remove limitations from `enum` type</summary><div class="markup"><blockquote>
<p>"Tolkein" isn't an actual instance of enum("Tolkein"), it's only coercible to that type, and when types are used in paths it has to be an actual instance. I think we need to fix that.</p>
</blockquote>
<p><em>Originally posted by @michaelhkay in <a href="https://github.com/qt4cg/qtspecs/issues/2150#issuecomment-3160717989">#2150</a></em></p>
<p>It seems strange that there is no way to create a value that is an instance of a <em>singleton enumeration type</em>. Only casting (and  annotation, which is a kind of casting too) is available.</p>
<p>On the other hand:</p>
<pre><code class="language-xquery">let $x as enum("foo") := "foo"
return ( ()
  , $x instance of enum("foo")
  , $x instance of xs:string
  , atomic-equal($x, "foo")
)
(: true(), true(), true() :)
</code></pre>
<p>This means that <code>"foo"</code> <strong>should</strong> be an instance of <code>enum("foo")</code>, and then <code>enum("foo")</code> is a subtype of <code>xs:string</code>.</p>
<p>And the following is unclear (from <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#id-enumeration-types">3.2.6 Enumeration Types</a>):</p>
<ul>
<li>
<blockquote>
<p>It follows from these rules that an atomic item will only satisfy an <code>instance of</code> test if it has the correct type annotation, and this typically requires an explicit cast. So the expression <code>"red" instance of enum("red", "green", "blue")</code> returns <code>false</code>, while <code>"red" cast as enum("red") instance of enum("red", "green", "blue")</code> returns <code>true</code>.</p>
</blockquote>
</li>
</ul>
<p>Probably, a more narrow reason is that a singleton enumeration type is an "anonymous atomic type derived from <code>xs:string</code> <em>by restriction</em> using an enumeration facet" that permits only one value.  Yes, this makes type checking for an enum more complex, but seems not more complex than casting.</p>
<p>Anyway, is it possible to make any instance of <code>xs:string</code> also an instance of the corresponding singleton enumeration type?  (that is, essentially make it so that this casting happens "hidden", if required).</p>
</div></details></div>
<div class="toot" id="created-2152"><h2>Issue #2152 created<span class="toot-id"> #created-2152</span></h2><div class="pubdate">06 Aug at 15:55:49 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/2152">https://github.com/qt4cg/qtspecs/issues/2152</a></div><details><summary>"x" is not an instance of enum("x")</summary><div class="markup"><p>The usefulness of enum() types is limited by the fact that the string "x" is not actually an instance of <code>enum("x")</code>, it is only coercible to that type. This means that in contexts where strict type matching is required (for example, in XSLT patterns), either (a) you can't use enum() the way you would like, or (b) you use it and fail to understand why it fails.</p>
</div></details></div>
<div class="toot" id="created-2151"><h2>Pull request #2151 created<span class="toot-id"> #created-2151</span></h2><div class="pubdate">06 Aug at 11:04:04 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/2151">https://github.com/qt4cg/qtspecs/pull/2151</a></div><details><summary>2021 Move the section on Patterns to a more logical place in the spec</summary><div class="markup"><p>This PR simply moves the section on Patterns to a more logical place in the XSLT specification. Unless anyone objects, I will merge the PR without waiting for group approval, so that I can use the result as a baseline for further work on patterns and templates, hopefully giving a better diff baseline.</p>
</div></details></div>
<div class="toot" id="closed-1776"><h2>Issue #1776 closed<span class="toot-id"> #closed-1776</span></h2><div class="pubdate">06 Aug at 08:27:59 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/1776">https://github.com/qt4cg/qtspecs/issues/1776</a></div><p>Using `?` and `??` in XSLT patterns</p></div>
<div class="toot" id="created-2150"><h2>Issue #2150 created<span class="toot-id"> #created-2150</span></h2><div class="pubdate">06 Aug at 08:26:10 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/2150">https://github.com/qt4cg/qtspecs/issues/2150</a></div><details><summary>XSLT Patterns to match JNodes</summary><div class="markup"><p>Supersedes #1776.</p>
<p>Part of the motivation for introducing JNodes was to make rule-based recursive-descent transformation of JSON structures much easier. This issue addresses part of that capability, namely defining patterns that match JNodes (and perhaps improving the patterns that match maps and arrays).</p>
<p>In general I think the patterns that match JNodes should be distinct from the patterns that match XNodes; although we have unified path expressions so that a/b can select either an XNode or a JNode, I think there would be too much scope for confusion if match="a/b" were able to match a JNode as well as an XNode.</p>
<p>My first idea would be to allow the syntax <code>match="jnode(a)"</code> for a template rule that matches JNodes having a selector property of "a", similarly <code>jnode(a/b)</code>, <code>jnode(a//b)</code>, <code>jnode(a/*/b)</code>, <code>jnode(a[x="c"])</code> with semantics defined in much the same way.</p>
<p>But there's a question how this relates to type patterns. With type patterns, we can already do <code>match="type(jnode(record(Author, Title, *)))"</code> which matches a JNode whose content is of type <code>record(Author, Title, *)</code>. Where syntactically possible we allow type patterns to be abbreviated, so this would become <code>match="jnode(record(Author, Title, *))"</code> which conflicts with the above.</p>
<p>An analogy with <code>element(N, T)</code> might suggest <code>match="jnode(K, V)"</code> where K constrains the selector property of the JNode, and V constrains its content property. So we might have <code>match="jnode(books, array(record(Author, Title, *)))"</code> to match a JNode whose selector is "books" and whose content is of type  <code>array(record(Author, Title, *))</code>.</p>
<p>At the same time, while matching maps by a type such as <code>match="record(Author, Title, *))"</code> works well, I find that this is often accompatied by a predicate so it becomes <code>match="record(Author, Title, *))[Author='Tolkein']"</code>. It would be nice to express this more concisely and readably perhaps as <code>match="record(Author[.='Tolkein'], Title, *))"</code></p>
</div></details></div>
<div class="toot" id="closed-115"><h2>Issue #115 closed<span class="toot-id"> #closed-115</span></h2><div class="pubdate">06 Aug at 07:52:48 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/115">https://github.com/qt4cg/qtspecs/issues/115</a></div><p>Lookup operator on arrays of maps</p></div>
<div class="toot" id="created-2149"><h2>Pull request #2149 created<span class="toot-id"> #created-2149</span></h2><div class="pubdate">05 Aug at 11:52:53 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/2149">https://github.com/qt4cg/qtspecs/pull/2149</a></div><details><summary>2100 Make innermost, outermost, has-children, path apply to JNodes</summary><div class="markup"><p>Fix #2100</p>
</div></details></div>
<div class="toot" id="created-2148"><h2>Issue #2148 created<span class="toot-id"> #created-2148</span></h2><div class="pubdate">05 Aug at 09:21:22 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/2148">https://github.com/qt4cg/qtspecs/issues/2148</a></div><details><summary>fn:base-uri: Raise errors?</summary><div class="markup"><p>The (rather old) test case <a href="https://github.com/qt4cg/qt4tests/blob/cf7c1ed9990279dbaf2297b8fe252a3ca4a3c0ad/fn/base-uri.xml#L799-L811"><code>K2-BaseURIFunc-29</code></a> indicates that invalid URIs may result in an error:</p>
<pre><code class="language-xml">&lt;test-case name="K2-BaseURIFunc-29"&gt;
  &lt;description&gt; Use an URI in an xml:base element that is a valid URI, but an invalid HTTP URL. 
    Since implementations aren't required to validate specific schemes but allowed to, 
    this may either raise an error or return the URI. 
  &lt;/description&gt;
  &lt;created by="Frans Englich" on="2007-11-26"/&gt;
  &lt;dependency type="spec" value="XQ10+"/&gt;
  &lt;test&gt;&lt;![CDATA[let $i := fn:base-uri(&lt;anElement xml:base="http:\\example.com\\examples"&gt;Element content&lt;/anElement&gt;) 
    return $i eq "http:\\example.com\\examples" or empty($i)]]&gt;&lt;/test&gt;
  &lt;result&gt;
    &lt;assert-true/&gt;
  &lt;/result&gt;
&lt;/test-case&gt;
</code></pre>
<p>I raise this issue in the qtspecs repository as I wondered whether we should clarify how invalid URIs are to be handled by <code>fn:base-uri</code>.</p>
<p>If it’s the test that is misleading, I will be glad to correct the comment, or add an error code.</p>
</div></details></div>
<div class="toot" id="created-2147"><h2>Pull request #2147 created<span class="toot-id"> #created-2147</span></h2><div class="pubdate">05 Aug at 08:49:22 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/2147">https://github.com/qt4cg/qtspecs/pull/2147</a></div><details><summary>2143 Redesign of method calls</summary><div class="markup"><p>Although issue #2143 envisaged redefining method calls in terms of JNodes, this PR takes a different approach.</p>
<p>The "magic" performed by the lookup operator when the entry in a map is annotated %method is dropped. Instead we have a new operator <code>?&gt;</code> which is essentially defined as a macro: in simple cases <code>$map ?&gt; method (X)</code> is defined to be essentially an abbreviation for <code>($map ? method)($map, X)</code>.</p>
<p>I have used the operator <code>?&gt;</code> suggested by Christian, but in some ways I prefer the operator we had originally, <code>=?&gt;</code>, because (a) there is a stronger analogy with <code>=&gt;</code>, and (b) <code>?&gt;</code> brings up images of XML syntax for processing instructions.</p>
</div></details></div>
<div class="toot" id="created-2146"><h2>Pull request #2146 created<span class="toot-id"> #created-2146</span></h2><div class="pubdate">04 Aug at 19:01:16 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/2146">https://github.com/qt4cg/qtspecs/pull/2146</a></div><details><summary>Require at least one character in StringTemplateFixedPart</summary><div class="markup"><p>The grammar rules for <code>StringTemplate</code> are as follows:</p>
<pre><code>StringTemplate              ::=  "`" (StringTemplateFixedPart | StringTemplateVariablePart)* "`"
                                                                                      /* ws: explicit */
StringTemplateFixedPart     ::=  ((Char - ('{' | '}' | '`')) | "{{" | "}}" | "``")*
                                                                                      /* ws: explicit */
StringTemplateVariablePart  ::=  EnclosedExpr
                                                                                      /* ws: explicit */
</code></pre>
<p>But <code>StringTemplateFixedPart</code> should not be allowed as a zero-length token, because this is causing an ambiguity: the input <code>``</code> currently can be parsed as any of</p>
<pre><code class="language-xml">&lt;StringTemplate&gt;`&lt;StringTemplateFixedPart/&gt;`&lt;/StringTemplate&gt;
</code></pre>
<pre><code class="language-xml">&lt;StringTemplate&gt;`&lt;StringTemplateFixedPart/&gt;&lt;StringTemplateFixedPart/&gt;`&lt;/StringTemplate&gt;
</code></pre>
<pre><code class="language-xml">&lt;StringTemplate&gt;`&lt;StringTemplateFixedPart/&gt;&lt;StringTemplateFixedPart/&gt;&lt;StringTemplateFixedPart/&gt;`&lt;/StringTemplate&gt;
</code></pre>
<p>and so on.</p>
<p>In order to ensure an unambiguous result, <code>StringTemplateFixedPart</code> should be required to consist of at least one character. Also the <code>/* ws: explicit */</code> on <code>StringTemplateVariablePart</code> is superfluous. The grammar rules thus should be changed to:</p>
<pre><code class="language-xml">StringTemplate              ::=  "`" (StringTemplateFixedPart | StringTemplateVariablePart)* "`"
                                                                                      /* ws: explicit */
StringTemplateFixedPart     ::=  ((Char - ('{' | '}' | '`')) | "{{" | "}}" | "``")+
                                                                                      /* ws: explicit */
StringTemplateVariablePart  ::=  EnclosedExpr
</code></pre>
</div></details></div>
<div class="toot" id="created-2145"><h2>Pull request #2145 created<span class="toot-id"> #created-2145</span></h2><div class="pubdate">03 Aug at 19:22:35 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/2145">https://github.com/qt4cg/qtspecs/pull/2145</a></div><details><summary>Allow implicit whitespace in StringInterpolation</summary><div class="markup"><p>Production <code>StringInterpolation</code> currently does not allow implicit whitespace:</p>
<pre><code>StringInterpolation ::= "`{"  Expr?  "}`"
                                                                         /* ws: explicit */
</code></pre>
<p>But this is likely not intended - all examples in the spec do have whitespace adjacent to the braces.</p>
<p>This change thus removes <code> /* ws: explicit */</code> in order to allow implicit whitespace.</p>
</div></details></div>
<div class="toot" id="created-2143"><h2>Issue #2143 created<span class="toot-id"> #created-2143</span></h2><div class="pubdate">03 Aug at 07:05:13 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/2143">https://github.com/qt4cg/qtspecs/issues/2143</a></div><details><summary>JNodes and Methods</summary><div class="markup"><p>I propose changing the mechanism for invoking methods to take advantage of JNodes.</p>
<p>Instead of the current magic rule for the "?" operator, we move the magic to the rules for dynamic function calls: in a dynamic function call F(X, Y), if the value of F is a JNode J whose content property is a function item annotated with %method, then the function body is executed with the parent of J (that is, the containing map or array) as the context value. It seems much cleaner semantics to make this a rule for dynamic function calls rather than for map lookup.</p>
<p>The downside is that the call syntax now would become <code>($rectangle/area)()</code> rather than <code>$rectangle?area()</code>. Unfortunately <code>$rectangle/area()</code> parses as <code>$rectangle/(area())</code>. So we might want to invent some better syntax.</p>
</div></details></div>
<div class="toot" id="closed-2142"><h2>Issue #2142 closed<span class="toot-id"> #closed-2142</span></h2><div class="pubdate">01 Aug at 12:56:54 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/2142">https://github.com/qt4cg/qtspecs/pull/2142</a></div><p>Markup fixes in the HTML output</p></div>
<div class="toot" id="created-2142"><h2>Pull request #2142 created<span class="toot-id"> #created-2142</span></h2><div class="pubdate">01 Aug at 12:56:19 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/2142">https://github.com/qt4cg/qtspecs/pull/2142</a></div><details><summary>Markup fixes in the HTML output</summary><div class="markup"><ol>
<li>Moved all the processor comments to the end; this avoids having a comment before <code>&lt;!DOCTYPE HTML&gt;</code> which is frowned upon because ... reasons</li>
<li>The XSLT stylesheet was adding links for sections, but so was the main stylesheet, so they were coming out nested.</li>
<li>Don't attempt to link to functions or elements inside titles. (This also results in nested links)</li>
<li>Attempt to "unwrap" <code>&lt;p&gt;</code> elements around things that can't be inside a <code>&lt;p&gt;</code>, like various sorts of lists. It's a bit ugly, but it makes for much cleaner HTML.</li>
</ol>
<p>I'm just going to merge this because there's no practical way to see the consequences in the PR.</p>
<p>Apologies in advance that this will introduce some spurious diffs. I think those will go away after the build finishes and after you've rebased your PRs on the new stylesheets.</p>
</div></details></div>
<div class="toot" id="created-2141"><h2>Pull request #2141 created<span class="toot-id"> #created-2141</span></h2><div class="pubdate">01 Aug at 11:27:24 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/2141">https://github.com/qt4cg/qtspecs/pull/2141</a></div><details><summary>Remove nested paragraphs</summary><div class="markup"><p>I have no idea why the DTD allows <code>&lt;p&gt;</code> inside <code>&lt;p&gt;</code> but I assume this is a markup error and not intentional.</p>
</div></details></div>
<div class="toot" id="closed-2140"><h2>Issue #2140 closed<span class="toot-id"> #closed-2140</span></h2><div class="pubdate">01 Aug at 11:25:05 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/2140">https://github.com/qt4cg/qtspecs/pull/2140</a></div><p>Restore diffs</p></div>
<div class="toot" id="created-2140"><h2>Pull request #2140 created<span class="toot-id"> #created-2140</span></h2><div class="pubdate">01 Aug at 11:24:55 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/2140">https://github.com/qt4cg/qtspecs/pull/2140</a></div><details><summary>Restore diffs</summary><div class="markup"><p>With great appreciation to the fine folks at DeltaXignia!</p>
</div></details></div>
<div class="toot" id="closed-2138"><h2>Issue #2138 closed<span class="toot-id"> #closed-2138</span></h2><div class="pubdate">31 Jul at 17:39:12 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/2138">https://github.com/qt4cg/qtspecs/issues/2138</a></div><p>NodeTest `type(X|Y)`: double parentheses needed</p></div>
<div class="toot" id="created-2139"><h2>Issue #2139 created<span class="toot-id"> #created-2139</span></h2><div class="pubdate">31 Jul at 10:42:45 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/2139">https://github.com/qt4cg/qtspecs/issues/2139</a></div><details><summary>Binary comparisons</summary><div class="markup"><p>It seems confusing to me that <code>deep-equal</code> &amp; <code>atomic-equal</code> return different results than <code>eq</code> for binary types:</p>
<pre><code class="language-xquery">let $hex := xs:hexBinary(''), $base64 := xs:base64Binary('')
return (
  (: false :) deep-equal($hex, $base64),
  (: false :) atomic-equal($hex, $base64),
  (: true  :) $hex eq $base64
)
</code></pre>
<p>The rules say:</p>
<h4><code>fn:deep-equal</code></h4>
<blockquote>
<p>If both <code>$i1</code> and <code>$i2</code> are instances of <code>xs:hexBinary</code> or <code>xs:base64Binary</code>, <code>$i1</code> eq <code>$i2</code> returns <code>true</code>.</p>
</blockquote>
<p>This can be interpreted in two ways, but it seems to mean that <code>$i1</code> and <code>$i2</code> need to have the same type?</p>
<h4><code>fn:atomic-equal</code></h4>
<blockquote>
<p>One of the following conditions is true:
<code>$value1</code> and <code>$value2</code> are both instances of <code>xs:hexBinary</code>.
<code>$value1</code> and <code>$value2</code> are both instances of <code>xs:base64Binary</code>.</p>
</blockquote>
<h4><code>op:binary-equal</code></h4>
<blockquote>
<pre><code>op:binary-equal(
  $value1	as (xs:hexBinary | xs:base64Binary),	
  $value2	as (xs:hexBinary | xs:base64Binary)	
) as xs:boolean
</code></pre>
<p>The function returns <code>true</code> if <code>$value1</code> and <code>$value2</code> are of the same length, measured in binary octets, and contain the same octets in the same order. Otherwise, it returns <code>false</code>.</p>
</blockquote>
<p>As <code>atomic-equal(xs:double(3), xs:float(3))</code> returns <code>true</code>, I would also expect <code>true</code> for binary items with the same contents.</p>
<p>Related (for numbers): #986</p>
</div></details></div></div><p>See 4368
            more statuses in yearly archives.</p></article></main></body></html>