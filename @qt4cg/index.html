<!DOCTYPE HTML><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta charset="UTF-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"><link rel="stylesheet" href="/css/status.css"><title>@qt4cg statuses</title></head><body><main><article><h1>@qt4cg statuses</h1><p>This page displays recent status
            updates
            about the QT4CG project.</p><p>The are also captured in <a href="status.rss">an RSS feed</a>.</p><p>By year: <a href="2023/">2023</a>, <a href="2022/">2022</a></p><div class="toots">
<div class="toot" id="agenda-02-21"><h2>QT4 CG meeting 023 draft agenda<span class="toot-id"> #agenda-02-21</span></h2><div class="pubdate">17 Feb at 17:49:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/02-21">https://qt4cg.org/meeting/agenda/2023/02-21</a></div><p>Draft agenda published.</p></div>
<div class="toot" id="created-355"><h2>Pull request #355 created<span class="toot-id"> #created-355</span></h2><div class="pubdate">16 Feb at 21:41:38 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/355">https://github.com/qt4cg/qtspecs/pull/355</a></div><details><summary>Action QT4CG-022-02 - add to imp-def-feature appendix</summary><div class="markup"><p>Adds entries to the implementation-defined-features appendix of the serialization spec, corresponding to the option to generate <code>&lt;meta charset="XXX"&gt;</code> for HTML5.</p>
</div></details></div>
<div class="toot" id="created-354"><h2>Pull request #354 created<span class="toot-id"> #created-354</span></h2><div class="pubdate">16 Feb at 18:30:51 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/354">https://github.com/qt4cg/qtspecs/pull/354</a></div><details><summary>Combine multiple signatures of XSLT functions to use defaults</summary><div class="markup"><p>This PR addresses issue 69, by modifying those XSLT built-in functions that currently have multiple signatures, to use a single signature with parameter defaults instead.</p>
<p>The changes however don't currently render correctly. The XSLT processing pipeline needs to be changed to pick up the changes that were made to the F+O stylesheets to render parameter defaults correctly. I haven't yet managed to work out where this is done.</p>
</div></details></div>
<div class="toot" id="created-353"><h2>Pull request #353 created<span class="toot-id"> #created-353</span></h2><div class="pubdate">16 Feb at 17:22:48 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/353">https://github.com/qt4cg/qtspecs/pull/353</a></div><details><summary>Issue109 xsl note</summary><div class="markup"><p>Addresses issue #109 and issue #87. Unfortunately the PR also includes the unrelated commits for issue 22.</p>
</div></details></div>
<div class="toot" id="created-352"><h2>Issue #352 created<span class="toot-id"> #created-352</span></h2><div class="pubdate">16 Feb at 14:58:30 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/352">https://github.com/qt4cg/qtspecs/issues/352</a></div><details><summary>The @array attribute of xsl:for-each-group is no more</summary><div class="markup"><p>There is a note in XSLT Â§14.2 concerning the @array attribute of xsl:for-each-group, but this attribute has been dropped.</p>
</div></details></div>
<div class="toot" id="closed-351"><h2>Issue #351 closed<span class="toot-id"> #closed-351</span></h2><div class="pubdate">16 Feb at 08:48:37 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/351">https://github.com/qt4cg/qtspecs/pull/351</a></div><p>Another attempt to build off the merge-base branch</p></div>
<div class="toot" id="created-351"><h2>Pull request #351 created<span class="toot-id"> #created-351</span></h2><div class="pubdate">16 Feb at 08:48:31 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/351">https://github.com/qt4cg/qtspecs/pull/351</a></div><p>Another attempt to build off the merge-base branch</p></div>
<div class="toot" id="closed-341"><h2>Issue #341 closed<span class="toot-id"> #closed-341</span></h2><div class="pubdate">16 Feb at 00:17:45 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/341">https://github.com/qt4cg/qtspecs/issues/341</a></div><p>[XPath] Error-free selection operator for maps or arrays, or finite-domain functions</p></div>
<div class="toot" id="created-350"><h2>Issue #350 created<span class="toot-id"> #created-350</span></h2><div class="pubdate">16 Feb at 00:11:51 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/350">https://github.com/qt4cg/qtspecs/issues/350</a></div><details><summary>[XPath] CompPath (Composite-objects path) Expressions</summary><div class="markup"><h1>CompPath (Composite-objects path) Expressions</h1>
<p>As initially discussed in issue #341, we were exploring different ways to provide an XPath-like language to traverse in depth composite objects such as maps and arrays and select their members at any depth.
While working on this, the idea of an XPath-like language for composite items started to emerge and here we present this idea in a more or less crystalized form.</p>
<h2>1. Root Component</h2>
<p>Any CompPath expression must start off a composite item (of type map or array, or of other future composite item type (maybe set? )  ).
This can be a literal composite item or a reference to a variable whose value is a composite item.</p>
<p>Examples:</p>
<pre><code class="language-xq">
(: Literal composite items: :)
[1, 2, 3]

[1, [2,  3]]?2

{"x":1, "y" : map{ "z": 2}}

{"x":1, "y" : map{ "z": 2}} ?y

(: Variables containing composite items: :)
let $comp1 := [1, [2, 3]],
 $comp2 :=$comp1 ?2,
 $comp3 := {"x":1, "y" : map{ "z": 2}},
 $comp4 := $comp3 ?y
</code></pre>
<p>In the above examples all literal expressions and all variables (<strong><code>$comp1, $comp2, $comp3, $comp4</code></strong>) may serve as the root component for a CompPath expression.</p>
<h2>2. The component-path operator (\)</h2>
<p>The component-path operator "\" is used to build expressions for locating members at any depth within component trees. Its left-hand side expression must return a result that is a composite item or else this result is represented as such by wrapping it into an array.</p>
<p>The operator returns an array, the values of whose members are composite items themselves or any such value may be a non-composite "leaf" in the root-component tree).</p>
<p>Each operation E1\E2 is evaluated as follows: Expression E1 is evaluated, and the result is wrapped in an array A1. If any member of A1 is not a composite item, a type error is raised.
Each member of A1 serves in turn  to provide an inner "composite-focus" (the member as the "composite-context-item" or <strong><code>.</code></strong>, its index in A1 as the "composite-context-position" or <strong><code>index()</code></strong>, the set of keys of the composite-context-item as the "composite-keyset" or <strong><code>keys()</code></strong> and the size of this member as the "composite-context-size" (specified as one of: <strong><code>size()</code></strong>, or <strong><code>array-size()</code></strong> or <strong><code>key-size()</code></strong>) ) for the evaluation of E2. The result of each evaluation of  E2, if it isn't a single composite item, is wrapped in a single array. The arrays resulting from all the evaluations of E2 are wrapped  in a single array and this single array is the result of the evaluation.</p>
<p>E2 is typically a function over the <em>context-focus</em>  and its results will be the set of the next step composite-context-items (used as the left-hand-side of the next in chain composite-step-expression (see below)), or these results would be the final results of evaluation if this is the last-in chain composite-step-expression.</p>
<h2>3. Composite-Steps</h2>
<p>A <strong>composite-step</strong> is a part of a composite-path-expression that generates an array and filters its members by zero or more predicates. A <strong>composite-step-expression</strong> is either a <em>CompositeAxisStep</em> or a <em>CompositePostfixExpression</em>.</p>
<h2>4. Composite-Axes</h2>
<p>The following axes are defined for traversing a composite-item tree:</p>
<ul>
<li>The <strong><code>child-member::</code></strong> axis contains the members of the composite-context-item.</li>
<li>The  <strong><code>value-member::</code></strong>  axis contains the members of the composite-context-item that are not composite themselves.</li>
<li>The  <strong><code>node-member::</code></strong>  axis contains the members of the composite-context-item that are nodes.</li>
<li>The <strong><code>descendant-member::</code></strong> axis is defined as the transitive closure of the <strong><code>child-member::</code></strong> axis; it contains the descendent-members of the composite-context-item (the child members of the composite-context-item, and their child-members, ... and so on).</li>
<li>The <strong><code>self::</code></strong> axis contains just the composite-context-item.</li>
<li>The <strong><code>descendant-member-or-self::</code></strong> contains the composite-context-item and all of its descendent-members.</li>
<li>The <strong><code>following-sibling-member::</code></strong> axis contains the members of the immediate container of the composite-context-item that follow it. For any two members <strong><em>mem1</em></strong> and <strong><em>mem2</em></strong> of a composite item <strong><em>Comp</em></strong>, by definition <strong><em>mem2</em></strong> follows <strong><em>mem1</em></strong> if and only if <strong><em>Comp</em></strong> is an array and the index of <strong><em>mem2</em></strong> in <strong><em>Comp</em></strong> is greater than that of <strong><em>mem1</em></strong>, or if <strong><em>Comp</em></strong> is a map, then the key of <strong><em>mem2</em></strong> is greater than that of <strong><em>mem1</em></strong>.</li>
<li>The <strong><code>preceding-sibling-member::</code></strong> axis contains the members of the immediate container of the composite-context-item that precede it. For any two members <strong><em>mem1</em></strong> and <strong><em>mem2</em></strong> of a composite item <strong><em>Comp</em></strong>, by definition <strong><em>mem1</em></strong> precedes <strong><em>mem2</em></strong> if and only if <strong><em>Comp</em></strong> is an array and the index of <strong><em>mem2</em></strong> in <strong><em>Comp</em></strong> is greater than that of <strong><em>mem1</em></strong>, or if <strong><em>Comp</em></strong> is a map, then the key of <strong><em>mem2</em></strong> is greater than that of <strong><em>mem1</em></strong>.</li>
</ul>
<p>For example, <strong><code>following-sibling-member::5</code></strong> means all members of the composite-context-item with index &gt; 5,
and <strong><code>preceding-sibling-member::5</code></strong> means all members of the composite-context-item with index &lt; 5</p>
<p><strong>Note</strong>: If the immediate container of the composite-context-item is a map whose key-values cannot be ordered, then specifying either of the <strong><code>following-sibling-member::</code></strong> or <strong><code>preceding-sibling-member::</code></strong> axes on this composite-context-item must raise a type error. (Obviously, these two axes are meaningful only for composite items, whose members are ordered, such as the array).</p>
<p>If the composite-axis name is omitted from a composite-axis step, the default axis is <strong><code>child-member::</code></strong></p>
<h2>5. Composite Axis Steps</h2>
<p>A composite axis step completely resembles the ordinary axis step in XPath. It consists of three parts:</p>
<ol>
<li>The composite axis  (<strong><code>child-member::</code></strong>, <strong><code>descendant-member::</code></strong>, <strong><code>value-member::</code></strong>, <strong><code>node-member::</code></strong>, <strong><code>following-sibling-member::</code></strong>, <strong><code>preceding-sibling-member::</code></strong>, <strong><code>self::</code></strong>, or the <strong><code>descendant-member-or-self::</code></strong> axis)</li>
<li>The member test</li>
<li>The composite-predicates</li>
</ol>
<h2>6. Member Tests</h2>
<p>A member test is a condition on the key-name, index, or kind (<em>composite</em>, <em>map</em>, <em>array</em> or <em>value</em>, <em>node</em>, or (any) <em>member</em>). A member test determines which members contained by a copmosite-axis are selected by a composite-step.</p>
<p>As such, a member test is either an <em>identifier-test</em> (key-name or index) or a <em>kind-test</em> (<em>composite</em>, <em>map</em>, <em>array</em>,  <em>value</em>, or <em>member</em>)).</p>
<p>Examples of member identifiers:</p>
<ul>
<li>
<p>A string specifies a name of a key, whose value will be selected. For example: <strong><code>\child-member::X</code></strong> selects from the composite-context-item the value corresponding to its key which has the name "X".</p>
</li>
<li>
<p><strong><code>\child-member::3</code></strong> selects from the composite-context-item the value of its 3rd member, if it is an array or the value corresponding to its key <strong><code>3</code></strong>, if it is a map.</p>
</li>
<li>
<p><strong><code>following-sibling-member::3</code></strong> selects from the composite-content-item (which is most-likely an array) all of its members having index greater than 3.</p>
</li>
<li>
<p><strong><code>preceding-sibling-member::3</code></strong> selects from the composite-content-item (which is most-likely an array) all of its members having index less than 3.</p>
</li>
<li>
<p><strong><code>\descendant-member-or-self::X</code></strong> selects from the composite-context-item (that must be a map) and from all its descendant-members, the values corresponding to their key named "X", if these descendents have a key named "X".</p>
</li>
<li>
<p>Similarly <strong><code>\5</code></strong> is equivalent to <strong><code>\child-member::5</code></strong> and selects from the composite-context-item that is an array the value of its 5th member. This will also select the value corresponding to the key <strong><code>5</code></strong> from the composite-context-item if it is a map, because on the <strong><code>child-member::</code></strong> axis both maps and arrays may be selected.</p>
</li>
<li>
<p><strong><code>\X</code></strong> is equivalent to <strong><code>\child-member::X</code></strong> and selects from the composite-context-item (that must be a map), the value corresponding to its key which has the name "X".</p>
<p>There is also the pseudo-operator <code>\\</code> . This is an abbreviation for:</p>
<p><strong><code>\descendant-member-or-self::member()\</code></strong></p>
<p>Thus, <strong><code>\\X</code></strong> means: "(Deep) Select all members of the root-component that are the corresponding values of keys equal to 'X' "</p>
</li>
<li>
<p>We may use a <strong><em>kind test</em></strong> as part of the previous example, if we want to select only a specific kind of members of the composite-context-item.
<strong><code>\array()</code></strong>  In this example, although we are on the <strong><code>child-member::</code></strong> axis, we want to select only members of the composite-context-item that are arrays.</p>
</li>
<li>
<p><strong><code>\map()</code></strong>  In this example, although we are on the <strong><code>child-member::</code></strong> axis, we want to select only members of the composite-context-item that are maps.</p>
</li>
<li>
<p><strong><code>\value()</code></strong>  In this example we want to select only members of the composite-context-item that are not composite items themselves.</p>
</li>
<li>
<p><strong><code>\node()</code></strong>  In this example we want to select only members of the composite-context-item that are nodes.</p>
</li>
<li>
<p><strong><code>\member()</code></strong>  In this example we want to select all members of the composite-context-item, regardless whether they are maps, arrays, or values.</p>
</li>
</ul>
<h3>6.1 Wildcards</h3>
<p>The <strong><code>*</code></strong> wildcard can be used instead of a member identifier. Its meaning is to select all existing members of the composite-context-item, that is possibly selected by a specific axis and limited by a specific member kind-test.</p>
<p><strong>Examples</strong>:</p>
<ul>
<li><strong><code>\*</code></strong>  (: (Shallow) Selects all members of the composite-context-item :)</li>
<li><strong><code>\map()\*</code></strong>  (: Selects from the composite-context-item all values that correspond to a key of any map-member of the composite-context item :)</li>
<li><strong><code>\array()\*</code></strong>  (: Selects from the composite-context-item all members of all its members that are arrays :)</li>
<li><strong><code>\\*</code></strong>  (: (Deep) Select all members of the composite tree rooted by the root-component :)</li>
</ul>
<h2>7. Predicates</h2>
<p>As defined above, a <strong>composite-step</strong> has three parts: <em>composite-axis</em> (can be omitted and then a default axis is used), <em>member test</em>, and an optional <em>list of composite-predicates</em>.</p>
<p>A <strong><em>composite-predicate</em></strong> in a composite-step is an expression used as a <em>filter</em> applied on the members of the composite-context-item that are already selected by the axis and member tests of the axis step, and not filtered out by any preceding composite-predicates in the <em>composite-predicates-list</em>. The composite-predicate may be any XPath expression and is written within double square brackets.</p>
<p><strong>Examples</strong>:</p>
<ul>
<li><strong><code>\*[[3]]</code></strong>  (: Selects any member of the composite-context-item, that is an array and has a 3rd member or any member of the composite-context-item, that is a map and has a key <strong>3</strong> :)
This is a shorthand for: <strong><code>\*[[array-size() ge 3 or 3 = keys()]]</code></strong></li>
<li><strong><code>\array()[[3]]</code></strong> (: Selects those array members of the composite-context-item that have a 3rd member :)
This is a shorthand for: <strong><code>\*[[size() ge 3]]</code></strong></li>
<li><strong><code>\*[[size() eq 7]]</code></strong>  (: Selects those members whose array-size() or key-size() is exactly 7:)
This is a shorthand for: <strong><code>\composite::*[[self::map() and key-size() eq 7 or self::array() and array-size() eq 7]]</code></strong></li>
<li><strong><code>\*[[X]]</code></strong>  (: Selects any member of the composite-context-item, that is a map and has a key <strong>X</strong>  :)</li>
<li><strong><code>\map()[[X]]</code></strong> (: Selects any map member of the composite-context-item, that has a key <strong>X</strong>  :)
The above two expressions are a shorthand for: <strong><code>\*[['X' = keys()]]</code></strong></li>
<li><strong><code>\value()[[. gt 0]]</code></strong> (: Selects any value (non-composite member) of the composite-context-item, that is a positive number :)</li>
</ul>
<h2>8. Mixing CompPath and XPath expressions</h2>
<p>CompPath and XPath expressions can be used as parts of a single expression:</p>
<ul>
<li>A CompPath expression may be appended at the end of any XPath expression that produces a composite-object .</li>
<li>An XPath expression may be appended at the end of any CompPath expression. When doing this,</li>
</ul>
<p><strong><code>CompPathExpr / XPathExpr</code></strong></p>
<p>is equivalent to:</p>
<p><strong><code>CompPathExpr\node::* / XPathExpr</code></strong></p>
<p><strong>Example</strong>:</p>
<pre><code class="language-xq">let $myBooks := 
&lt;books&gt;
 &lt;book name="Tom Sawyer"&gt;
   &lt;author&gt;Mark Twain&lt;/author&gt;
 &lt;/book&gt;
 &lt;book name="Wuthering Heights"&gt;
   &lt;author&gt;Emily BrontÃ«&lt;/author&gt;
 &lt;/book&gt;
 &lt;book name="Jane Eyre"&gt;
   &lt;author&gt;Charlotte BrontÃ«&lt;/author&gt;
 &lt;/book&gt;
 &lt;book name="Adventures of Huckleberry Finn"&gt;
   &lt;author&gt;Mark Twain&lt;/author&gt;
 &lt;/book&gt;
&lt;/books&gt;,
$map1 := map {"science-works": map{"Einstein": "Special Theory of relativity",
                                  "Darwin" : "On the Origin of Species"
                                 },
             "literature" : map{"19the Century": $myBooks}
            }
return
  $map1\literature\\*/book[author eq 'Mark Twain']
</code></pre>
<p>Evaluating this mixed CompPath and XPath expression produces the correct result:</p>
<pre><code class="language-xq">&lt;book name="Tom Sawyer"&gt;
  &lt;author&gt;Mark Twain&lt;/author&gt;
&lt;/book&gt;
&lt;book name="Adventures of Huckleberry Finn"&gt;
  &lt;author&gt;Mark Twain&lt;/author&gt;
&lt;/book&gt;
</code></pre>
</div></details></div>
<div class="toot" id="closed-349"><h2>Issue #349 closed<span class="toot-id"> #closed-349</span></h2><div class="pubdate">15 Feb at 18:04:32 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/349">https://github.com/qt4cg/qtspecs/pull/349</a></div><p>Revert PR change; it doesn't work in this context</p></div>
<div class="toot" id="created-349"><h2>Pull request #349 created<span class="toot-id"> #created-349</span></h2><div class="pubdate">15 Feb at 18:04:27 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/349">https://github.com/qt4cg/qtspecs/pull/349</a></div><p>Revert PR change; it doesn't work in this context</p></div>
<div class="toot" id="closed-348"><h2>Issue #348 closed<span class="toot-id"> #closed-348</span></h2><div class="pubdate">15 Feb at 17:46:33 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/348">https://github.com/qt4cg/qtspecs/pull/348</a></div><p>Attempt to build PR with merge-base version of master</p></div>
<div class="toot" id="created-348"><h2>Pull request #348 created<span class="toot-id"> #created-348</span></h2><div class="pubdate">15 Feb at 17:46:07 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/348">https://github.com/qt4cg/qtspecs/pull/348</a></div><details><summary>Attempt to build PR with merge-base version of master</summary><div class="markup"><p>This PR changes the CI <code>build-pr.yml</code> script so that it checks out the version of master that the branch started from, rather than the current version of master, for building the specifications.</p>
<ul>
<li>Pro: we won't get build failures when the current master can't build the old version (for example, when images have been removed)</li>
<li>Con: we won't get any features from the current master, such as stylesheet updates</li>
</ul>
<p>Since failing builds are more troublesome than formatting issues, I'm going to say the pros outweigh the cons.</p>
</div></details></div>
<div class="toot" id="created-347"><h2>Pull request #347 created<span class="toot-id"> #created-347</span></h2><div class="pubdate">15 Feb at 14:06:34 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/347">https://github.com/qt4cg/qtspecs/pull/347</a></div><details><summary>Attempt to clarify fn:parse-uri and fn:build-uri</summary><div class="markup"><p>Fix #307</p>
</div></details></div>
<div class="toot" id="closed-346"><h2>Issue #346 closed<span class="toot-id"> #closed-346</span></h2><div class="pubdate">15 Feb at 10:11:01 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/346">https://github.com/qt4cg/qtspecs/pull/346</a></div><p>Remove dagger from record cross-references</p></div>
<div class="toot" id="created-346"><h2>Pull request #346 created<span class="toot-id"> #created-346</span></h2><div class="pubdate">15 Feb at 10:10:36 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/346">https://github.com/qt4cg/qtspecs/pull/346</a></div><details><summary>Remove dagger from record cross-references</summary><div class="markup"><p>Record types are better supported by the stylesheets so the dagger is simply a distraction.</p>
</div></details></div>
<div class="toot" id="created-345"><h2>Issue #345 created<span class="toot-id"> #created-345</span></h2><div class="pubdate">14 Feb at 22:52:25 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/345">https://github.com/qt4cg/qtspecs/issues/345</a></div><details><summary>Missing rule for matching atomic values against atomic types</summary><div class="markup"><p>In XPath Â§3.6.2 we have forgotten to state the obvious rule:</p>
<p>"An Atomic Value AV matches a generalized atomic type GAT if the type annotation of AV (call it T) satisfies the condition derives-from(T, GAT)."</p>
<p>At the same time it would a good idea to clarify whether locally-declared union and enum types fall within the definition of "schema types" (I think they should do so.)</p>
</div></details></div>
<div class="toot" id="closed-342"><h2>Issue #342 closed<span class="toot-id"> #closed-342</span></h2><div class="pubdate">14 Feb at 17:24:35 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/342">https://github.com/qt4cg/qtspecs/pull/342</a></div><p>Issue318 meta elements</p></div>
<div class="toot" id="minutes-02-14"><h2>QT4 CG meeting 022 draft minutes<span class="toot-id"> #minutes-02-14</span></h2><div class="pubdate">14 Feb at 17:12:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/02-14">https://qt4cg.org/meeting/minutes/2023/02-14</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="closed-338"><h2>Issue #338 closed<span class="toot-id"> #closed-338</span></h2><div class="pubdate">09 Feb at 17:30:02 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/338">https://github.com/qt4cg/qtspecs/pull/338</a></div><p>Add ednote per action QT4CG-016-02</p></div>
<div class="toot" id="created-344"><h2>Pull request #344 created<span class="toot-id"> #created-344</span></h2><div class="pubdate">09 Feb at 17:06:56 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/344">https://github.com/qt4cg/qtspecs/pull/344</a></div><details><summary>Issue 22: allow "for"/"let" keyword to be repeated in XPath</summary><div class="markup"><p>Addresses the proposal in issue 22 to allow repetition of the "let" or "for" keyword in a ForExpr or LetExpr. (It does not, however, allow "for" and "let" to be mixed).</p>
</div></details></div>
<div class="toot" id="created-343"><h2>Issue #343 created<span class="toot-id"> #created-343</span></h2><div class="pubdate">09 Feb at 12:47:25 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/343">https://github.com/qt4cg/qtspecs/issues/343</a></div><details><summary>XQFO: $collation argument</summary><div class="markup"><p>In the function set of the XQFO current specification, the type of the <code>$collation</code> parameter is sometimes <code>xs:string</code> and sometimes <code>xs:string?</code>, depending on the position of the parameter. Examples:</p>
<h4>Mandatory</h4>
<pre><code class="language-xquery">fn:distinct-values($values as&nbsp;xs:anyAtomicType*, $collation as fn:default-collation())&nbsp;as&nbsp;xs:anyAtomicType*
fn:index-of($input | as&nbsp;xs:anyAtomicType*, $search | as&nbsp;xs:anyAtomicType, $collation as&nbsp;xs:string)&nbsp;as&nbsp;xs:integer*
</code></pre>
<h4>Optional</h4>
<pre><code class="language-xquery">fn:sort($input as&nbsp;item()*, $collation as&nbsp;xs:string?, $key as&nbsp;function(item()) as xs:anyAtomicType*
fn:lowest($input as item()*, $collation as xs:string?, $key as&nbsp;function(item()) as xs:anyAtomicType*)&nbsp;as&nbsp;item()*
</code></pre>
<p>I think we should always allow an empty sequence.</p>
</div></details></div>
<div class="toot" id="created-342"><h2>Pull request #342 created<span class="toot-id"> #created-342</span></h2><div class="pubdate">09 Feb at 12:27:01 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/342">https://github.com/qt4cg/qtspecs/pull/342</a></div><details><summary>Issue318 meta elements</summary><div class="markup"><p>Revises the rules for serializing meta elements to take account of new HTML5 syntax.</p>
<p>Resolves issue #318</p>
</div></details></div>
<div class="toot" id="closed-330"><h2>Issue #330 closed<span class="toot-id"> #closed-330</span></h2><div class="pubdate">08 Feb at 08:35:16 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/330">https://github.com/qt4cg/qtspecs/pull/330</a></div><p>Update fn:parse-html to apply review feedback.</p></div>
<div class="toot" id="created-341"><h2>Issue #341 created<span class="toot-id"> #created-341</span></h2><div class="pubdate">08 Feb at 01:50:08 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/341">https://github.com/qt4cg/qtspecs/issues/341</a></div><details><summary>[XPath] Error-free selection operator for maps or arrays, or finite-domain functions</summary><div class="markup"><p>In March 2021 Jarno Elovirta raised on the <strong><em>#general channel</em></strong> of the XML.com Slack the problem that the existing map or array lookup operator "<strong>?</strong>" prevents a free traversal of a nested mapp/array object. For example, this expression results in error:</p>
<pre><code class="language-xq">[
  map {"k0": 1}, 
  map{"k0": [1, 2, 3]}
]  ?* ?("k0")  ?*
</code></pre>
<p><strong>[XPTY0004] Input of lookup operator must be map or array: 1.</strong></p>
<hr>
<p>There are three possible types of reaction to this problem:</p>
<ol>
<li>
<p>Do nothing</p>
</li>
<li>
<p>Relax the semantics of the map/array lookup operator "<strong>?</strong>" so that it can be applied on items of non-map/non-array type and in such case produce the empty sequence.</p>
</li>
<li>
<p>Introduce a similar operator to "<strong>?</strong>" that will behave as it, but instead of producing an error when applied on items of non-map/non-array type it produces the empty sequence.</p>
</li>
</ol>
<p>Obviously, we are not advocating the 1st choice above, or otherwise we wouldn't be raising any issue ðŸ˜„</p>
<p>Choice 2 could be implemented, but this would have a few drawbacks:</p>
<ul>
<li>it would bring a certain degree of backwards incompatibility</li>
<li>"silently returning nothing" is really difficult to debug or even notice unexpected results, as pointed out by @michaelhkay</li>
</ul>
<p><strong>This proposal is to choose alternative 3. above</strong>.</p>
<p>Why is it better than the 2nd one?</p>
<ul>
<li>No incompatibility can be introduced, as this is a new operator.</li>
<li>The user has intentionally chosen this operator over the "?" operator, and this means that the user is well aware of the new, sometimes tricky to observe/explain/debug behavior, but the user doesn't mind these effects and is ready to deal with them.</li>
</ul>
<h2>Definition</h2>
<p>By definition the operator <strong>"-&gt;"</strong> with left-hand-side any expression <strong><em>E</em></strong> and right-hand-side a literal string  <strong><em>X</em></strong>:</p>
<p>&nbsp;&nbsp;&nbsp;<strong><code>E -&gt; X</code></strong></p>
<p>is lexically expanded to:</p>
<p>&nbsp;&nbsp;&nbsp;<strong><code>E[. instance of map(*) or . instance of array(*)]?X </code></strong></p>
<h2>Example</h2>
<p>With the original expression provided by Jarno Elovirta, but now using the <strong>"-&gt;"</strong> operator:</p>
<pre><code class="language-xq">[
  map {"k0": 1}, 
  map{"k0": [1, 2, 3]}
]  -&gt;* -&gt;("k0")  -&gt;*
</code></pre>
<p>its evaluation produces the expected result (all the values within just one of the leaves of the tree), and no error:</p>
<p><strong><code>1, 2, 3</code></strong></p>
<p>That is, <strong><code>1 -&gt;*</code></strong>  produces the empty sequence and no error.</p>
<p><strong>Note</strong>:</p>
<p>Of course, the above example can be rewritten to this equivalent XPath 3.0 expression and will get the wanted result, but literally no one, myself included, will ever write this:</p>
<pre><code class="language-xq">[
 map {"k0": 1}, 
 map{"k0": [1, 2, 3]}
] [. instance of map(*) or . instance of array(*)]      ?*
           [. instance of map(*) or . instance of array(*)]      ?k0
                                [. instance of map(*) or . instance of array(*)]   ?*
</code></pre>
<p><img src="https://user-images.githubusercontent.com/10605892/217432167-5f7fbff0-3d8d-48a3-a27d-5f62cb77c3dc.png" alt="image"></p>
<h2>Thus <strong><em><code>this is all about making it possible/feasible and empowering our users!</code></em></strong></h2>
</div></details></div>
<div class="toot" id="created-340"><h2>Issue #340 created<span class="toot-id"> #created-340</span></h2><div class="pubdate">07 Feb at 22:02:07 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/340">https://github.com/qt4cg/qtspecs/issues/340</a></div><details><summary>fn:format-number: Specifying decimal format</summary><div class="markup"><p>It would be nice if the decimal format for <code>fn:format-number</code> could also be supplied via an options argument:</p>
<pre><code>format-number(
  value := 123.45,
  picture := '#.##0,00',
  format := map { 'decimal-separator': ',', 'grouping-separator': '.' }
)
</code></pre>
<p>If both <code>$decimal-format-name</code> and <code>$format</code> are supplied, an error would probably need to be raised.</p>
<p>The current writing of the query above is:</p>
<pre><code>declare decimal-format de decimal-separator = ',' grouping-separator = '.';

format-number(
  value := 123.45,
  picture := '#.##0,00',
  decimal-format-name': 'de'
)
</code></pre>
</div></details></div>
<div class="toot" id="minutes-02-07"><h2>QT4 CG meeting 021 draft minutes<span class="toot-id"> #minutes-02-07</span></h2><div class="pubdate">07 Feb at 17:20:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/minutes/2023/02-07">https://qt4cg.org/meeting/minutes/2023/02-07</a></div><p>Draft minutes published.</p></div>
<div class="toot" id="created-339"><h2>Issue #339 created<span class="toot-id"> #created-339</span></h2><div class="pubdate">07 Feb at 13:46:57 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/issues/339">https://github.com/qt4cg/qtspecs/issues/339</a></div><details><summary>The constraints on document-uri are too...constraining</summary><div class="markup"><p>The XPath data model imposes the following constraints on the document-uri property:</p>
<blockquote>
<p>If the <code>document-uri</code> is not the empty sequence, then the following constraint must hold: the node returned by evaluating <code>fn:doc()</code> with the document-uri as its argument must return the document node that provided the value of the <code>document-uri</code> property.</p>
<p>In other words, for any Document Node <code>$arg</code>, either <code>fn:document-uri($arg)</code> must return the empty sequence or <code>fn:doc(fn:document-uri($arg))</code> must return <code>$arg</code>.</p>
</blockquote>
<p>This contraint turns out to be inconvenient whenever the larger environment doesnâ€™t enforce a 1:1 mapping between URIs and documents.</p>
<p>For example, in a browser context, a JavaScript function that returns different versions of the same document over time cannot identify those documents with the same document-uri.</p>
<p>In XProc, a <code>p:add-attribute</code> step that returns a copy of its input document with one additional attribute, cannot identify the output document with the same document-uri as the input document.</p>
<p>Given that the document URI is often necessary to evaluate relative URI references within a document, the constraints imposed in the data model are too strict.</p>
</div></details></div>
<div class="toot" id="created-338"><h2>Pull request #338 created<span class="toot-id"> #created-338</span></h2><div class="pubdate">07 Feb at 13:33:27 GMT</div><div class="link">Link: <a href="https://github.com/qt4cg/qtspecs/pull/338">https://github.com/qt4cg/qtspecs/pull/338</a></div><details><summary>Add ednote per action QT4CG-016-02</summary><div class="markup"><p>This is a purely editorial change. Unless someone objects over the next few days, I'm just going to merge it in.</p>
</div></details></div>
<div class="toot" id="agenda-02-07"><h2>QT4 CG meeting 021 draft agenda<span class="toot-id"> #agenda-02-07</span></h2><div class="pubdate">04 Feb at 15:09:00 GMT</div><div class="link">Link: <a href="https://qt4cg.org/meeting/agenda/2023/02-07">https://qt4cg.org/meeting/agenda/2023/02-07</a></div><p>Draft agenda published.</p></div></div><p>See 154
            more statuses in yearly archives.</p></article></main></body></html>