<!DOCTYPE HTML><html xmlns="http://www.w3.org/1999/xhtml" lang="EN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>XSL Transformations (XSLT) Version 4.0</title><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link rel="stylesheet" type="text/css" href="css/w3c-base.css"><link rel="stylesheet" href="css/qtspecs.css"><link rel="stylesheet" href="css/xslt-40.css"><style type="text/css">
          body { margin-top: 50px }
          a.button { background: #DDD; border: 2px outset black; padding: 2px; margin: 2px; font-family: sans-serif; font-size: small;}
          a.button:hover { cursor:pointer; }
          a.button:active { border-style: inset; }
        </style><link rel="stylesheet" href="/css/autodiff.css"></head><body class="toc-inline"><div style="position:fixed; clear:both; top:0px" id="_autodiff_buttons"><p><a class="button" onclick="view('old')">
              View Old
            </a><a class="button" onclick="view('new')">
              View New
            </a><a class="button" onclick="view('both')">
              View Both
            </a><a class="button" onclick="view('only')">
              View Only
            </a><a class="button" onclick="scroll_to('prev')">
              Previous
            </a><a class="button" onclick="scroll_to('next')">
              Next
            </a><span id="__autodiff__"></span></p><p>This draft contains only sections that have differences from the version that it modified.</p></div><div class="head"><p><a href="https://www.w3.org/"><img src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C" alt="W3C" height="48" width="72"></a></p><h1><a id="title"></a>XSL Transformations (XSLT) Version 4.0</h1><h2><a id="w3c-doctype"></a>W3C Editor's Draft <span class="deltaxml-old" style="background:#FF5555">30 January</span><span class="deltaxml-new" style="background:#90EE90">2 February</span> 2026</h2><dl><dt>This version:</dt><dd><a href="https://qt4cg.org/specifications/xslt-40/">https://qt4cg.org/specifications/xslt-40/</a></dd><dt>Latest version:</dt><dd><a href="https://qt4cg.org/specifications/xslt-40/">https://qt4cg.org/specifications/xslt-40/</a></dd><dt>Most recent Recommendation of XSL Transformations (XSLT):</dt><dd><a href="https://www.w3.org/TR/xslt-30/">https://www.w3.org/TR/xslt-30/</a></dd><dt>Editor:</dt><dd>Michael Kay, Saxonica <a href="http://www.saxonica.com/">&lt;http://www.saxonica.com/&gt;</a></dd></dl><p>The following associated resources are available: <a href="xslt-40.xml">Specification in XML format</a>, <a href="schema-for-xslt40.xsd">XSD 1.1 Schema for XSLT 4.0 Stylesheets (non-normative)</a>, <a href="schema-for-xslt40.rnc">Relax-NG Schema for XSLT 4.0 Stylesheets (non-normative)</a>, <a href="xml-to-json.xsl">Stylesheet for XML-to-JSON conversion (non-normative)</a></p><p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;©&nbsp;2026&nbsp;<a href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="https://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="https://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="https://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p><hr></div><div><h2><a id="abstract"></a>Abstract</h2><p>This specification defines the syntax and semantics of XSLT 4.0, a language designed primarily for transforming XML documents into other XML documents, but also offering support for other data formats including JSON, HTML, and CSV.</p><p>XSLT 4.0 is a revised version of the XSLT 3.0 Recommendation <a href="#xslt-30">[XSLT 3.0]</a> published on 8 June 2017. Changes are presented in <a href="#whats-new-in-xslt4"><i>1.2 What’s New in XSLT 4.0?</i></a>. </p><p>XSLT 4.0 is designed to be used in conjunction with XPath 4.0, which is defined in <a href="#xpath-40">[XPath 4.0]</a>. XSLT shares the same data model as XPath 4.0, which is defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>, and it uses the library of functions and operators defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. XPath 4.0 and the underlying function library introduce a number of enhancements, for example the availability of union and record types. </p><p><em>This document contains hyperlinks to specific sections or definitions within other documents in this family of specifications. These links are indicated visually by a superscript identifying the target specification: for example XP for XPath 4.0, DM for the XDM data model version 4.0, FO for Functions and Operators version 4.0, SG for XSLT Streaming version 4.0.</em></p><p>An optional feature of the XSLT language is support for streamed transformations. The XSLT 4.0 specification has been modularized so that streaming is now described in a separate specification document. This has been done in order to make the specifications more manageable, both for editors and readers: it does not alter the status of streaming as an optional feature, available in some processors and not others.</p></div><div><h2><a id="status"></a>Status of this Document</h2><p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document.</em></p><p>This document is a working draft developed and maintained by a W3C Community Group, the <a href="https://www.w3.org/community/xslt-40/">XQuery and XSLT Extensions Community Group</a> unofficially known as QT4CG (where "QT" denotes Query and Transformation). This draft is work in progress and should not be considered either stable or complete. Standard W3C copyright and patent conditions apply.</p><p>The community group welcomes comments on the specification. Comments are best submitted as issues on the group's <a href="https://github.com/qt4cg/qtspecs/issues">GitHub repository</a>.</p><p>The community group maintains two extensive test suites, one oriented to XQuery and XPath, the other to XSLT. These can be found at <a href="https://github.com/qt4cg/qt4tests">qt4tests</a> and <a href="https://github.com/qt4cg/xslt40-test">xslt40-test</a> respectively. New tests, or suggestions for correcting existing tests, are welcome. The test suites include extensive metadata describing the conditions for applicability of each test case as well as the expected results. They do not include any test drivers for executing the tests: each implementation is expected to provide its own test driver.</p><div class="dedication" id="dedication"><h3>Dedication</h3><p>The publications of this community group <a href="../xquery-40/xpath-40.html#dedication">are dedicated</a> to our co-chair, Michael Sperberg-McQueen&nbsp;(1954–2024).</p></div></div><hr><div class="body"><div class="_diffs div1"><h2><a id="concepts"></a>2 <a href="#concepts" style="text-decoration: none">Concepts</a></h2><div class="_diffs div2"><h3><a id="initiating"></a>2.3 <a href="#initiating" style="text-decoration: none">Initiating a Transformation</a></h3><p>This document does not specify any application programming interfaces or other interfaces for initiating a transformation. This section, however, describes the information that is supplied when a transformation is initiated. Except where otherwise indicated, the information is <span class="verb">required</span>.</p><p>The execution of a stylesheet necessarily involves two activities: static analysis and dynamic evaluation. Static analysis consists of those tasks that can be performed by inspection of the stylesheet alone, including the binding of <a title="static variable" class="termref" href="#dt-static-variable">static variables</a>, the evaluation of <code>[xsl:]use-when</code> expressions (see <a href="#conditional-inclusion"><i>3.12.3 Conditional Element Inclusion</i></a>) and shadow attributes (see <a href="#shadow-attributes"><i>3.12.4 Shadow Attributes</i></a>), and the detection of <a title="static error" class="termref" href="#dt-static-error">static errors</a>. Dynamic evaluation consists of tasks which in general cannot be carried out until a source document is available.</p><p>Dynamic evaluation is further divided into two activities: <b>priming</b> the stylesheet, and <b>invoking</b> a selected component. </p><ul><li><p>Priming the stylesheet provides the dynamic context for evaluation, and supplies all the information needed to establish the values of global variables.</p></li><li><p>Invoking a component (such as a template or function) causes evaluation of that template or function to produce a result, which is an arbitrary XDM value.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-raw-result" title="raw result"></a>The result of invoking the selected component, after any required conversion to the declared result type of the component, is referred to as the <b>raw result</b>.<span class="definition">]</span></p><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> of the invocation is the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained in the target template or function, modified by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to convert the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> to the type declared in the <code>as</code> attribute of the <a href="#element-template"><code>xsl:template</code></a> or <a href="#element-function"><code>xsl:function</code></a> declaration, if present.</p><p>This raw result may optionally be post-processed to construct a result tree, to serialize the result, or both, as described in <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a>.</p></li></ul><p>Implementations <span class="verb">may</span> allow static analysis and dynamic evaluation to be initiated independently, so that the cost of static analysis can be amortized over multiple transformations using the same stylesheet. Implementations <span class="verb">may</span> also allow priming of a stylesheet and invocation of components to be initiated independently, in which case a single act of priming the stylesheet may be followed by a series of independent component invocations. Although this specification does not require such a separation, this section distinguishes information that is needed before static analysis can proceed, information that is needed to prime the stylesheet, and information that is needed when invoking components.</p><p>The language is designed to allow the static analysis of each <a title="package" class="termref" href="#dt-package">package</a> to be performed independently of other packages, with only basic knowledge of the properties of components made available by used packages. Beyond this, the specification leaves it to implementations to decide how to organize this process. When packages are not used explicitly, the entire stylesheet is treated as a single package.</p><div class="_diffs div3"><h4><a id="invoking-initial-mode"></a>2.3.3 <a href="#invoking-initial-mode" style="text-decoration: none">Apply-Templates Invocation</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-initial-match-selection" title="initial match selection"></a>A stylesheet may be evaluated by supplying a value to be processed, together with an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>. The value (which can be any sequence of items) is referred to as the <b>initial match selection</b>. The processing then corresponds to the effect of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.<span class="definition">]</span></p><p>The <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> will often be a single document node, traditionally called the source document of the transformation; but in general, it can be any sequence. If the initial match selection is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result of the transformation will be empty, since no template rules are evaluated.</p><p>Processing proceeds by finding the <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> that match the items in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, and evaluating these template rules with a <a title="focus" class="termref" href="#dt-focus">focus</a> based on the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>. The template rules are evaluated in <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a>.</p><p>The following information is needed when dynamic evaluation is to start with a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>:</p><ul><li><p>The <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>. An API that chooses to maintain compatibility with previous versions of this specification <span class="verb">should</span> allow a method of invocation in which a singleton node is provided, which is then used in two ways: the node itself acts as the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, and the root node of the containing tree acts as the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>. </p></li><li><p>Optionally, an initial <a title="mode" class="termref" href="#dt-mode">mode</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-initial-mode" title="initial mode"></a>The <b>initial mode</b> is the <a title="mode" class="termref" href="#dt-mode">mode</a> used to select <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> for processing items in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> when apply-templates invocation is used to initiate a transformation.<span class="definition">]</span></p><p>In searching for the <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> that best matches the items in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, the processor considers only those rules that apply to the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>.</p><p>If no <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> is supplied explicitly, then the initial mode is that named in the <code>default-mode</code> attribute of the (explicit or implicit) <a href="#element-package"><code>xsl:package</code></a> element of the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> or in the absence of such an attribute, the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>.</p><p><a id="err-XTDE0044"><span class="error">[ERR XTDE0044] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> when no <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> is supplied (either explicitly, or defaulted to the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>). </p><p>A (named or unnamed) <a title="mode" class="termref" href="#dt-mode">mode</a><var>M</var> is <b>eligible as an initial mode</b> if one of the following conditions applies, where <var>P</var> is the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> of the stylesheet:</p><ol class="enumar"><li><p><var>M</var> is explicitly declared in an <a href="#element-mode"><code>xsl:mode</code></a> declaration within <var>P</var>, and has <code>public</code> or <code>final</code><a title="visibility" class="termref" href="#dt-visibility">visibility</a> (either by virtue of its <code>visibility</code> attribute, or by virtue of an <a href="#element-expose"><code>xsl:expose</code></a> declaration).</p></li><li><p><var>M</var> is the unnamed mode.</p></li><li><p><var>M</var> is named in the <code>default-mode</code> attribute of the (explicit or implicit) <a href="#element-package"><code>xsl:package</code></a> element of <var>P</var>.</p></li><li><p><var>M</var> is declared in a package used by <var>P</var>, and is given <code>public</code> or <code>final</code><a title="visibility" class="termref" href="#dt-visibility">visibility</a> in <var>P</var> by means of an <a href="#element-accept"><code>xsl:accept</code></a> declaration.</p></li><li><p>The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>declared-modes</code> attribute of the explicit or implicit <a href="#element-package"><code>xsl:package</code></a> element of <var>P</var> is <code>no</code>, and <var>M</var> appears as a mode-name in the <code>mode</code> attribute of a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> declared within <var>P</var>.</p></li></ol><p><a id="err-XTDE0045"><span class="error">[ERR XTDE0045] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> and the specified mode is not eligible as an initial mode (as defined above). </p></li><li><p>Parameters, which will be passed to the template rules used to process items in the input sequence. The parameters consist of two sets of (QName, value) pairs, one set for <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameters</a> and one for non-tunnel parameters, in which the QName identifies the name of a parameter and the value provides the value of the parameter. Either or both sets of parameters may be empty. The effect is the same as when a template is invoked using <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with an <a href="#element-with-param"><code>xsl:with-param</code></a> child specifying <code>tunnel="yes"</code> or <code>tunnel="no"</code> as appropriate. If a parameter is supplied that is not declared or used, the value is simply ignored. These parameters are <em>not</em> used to set <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>.</p><p>A supplied value is converted if necessary to the declared type of the template parameter using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p></li><li><p>Details of how the result of the initial template is to be returned. For details, see <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a></p></li></ul><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> of the invocation is the result of processing the supplied input sequence as if by a call on <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> in the specified mode: specifically, each item in the input sequence is processed by selecting and evaluating the best matching template rule, and converting the result (if necessary) to the type declared in the <code>as</code> attribute of that template using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>; and the results of processing each item are then concatenated into a single sequence, respecting the order of items in the input sequence.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The design of the API for invoking a transformation should provide some means for users to designate the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a> as the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> in cases where it is not the <a title="default mode" class="termref" href="#dt-default-mode">default mode</a>.</p></div><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a><span class="error">[see <a href="#err-XTDE0700">ERR XTDE0700</a>]</span> if the <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> selected for processing any item in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> defines a <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a> that specifies <code>required="yes"</code> and no value is supplied for that parameter.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> can process further source documents in addition to those supplied when the transformation is invoked. These additional documents can be loaded using the functions <a href="#func-document"><code>document</code></a> (see <a href="#func-document"><i>20.1 fn:document</i></a>); or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-unparsed-text"><code>unparsed-text</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-unparsed-text-lines"><code>unparsed-text-lines</code></a>, or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a> (see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>); or using the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction; alternatively, they can be supplied as <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a> (see <a href="#global-variables"><i>9.5 Global Variables and Parameters</i></a>), or returned as the result of an <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> (see <a href="#extension-functions"><i>24.2 Extension Functions</i></a>).</p></div></div><div class="_diffs div3"><h4><a id="post-processing"></a>2.3.6 <a href="#post-processing" style="text-decoration: none">Post-processing the Raw Result</a></h4><p>There are three ways the result of a transformation may be delivered. (This applies both to the principal result, described here, and also to secondary results, generated using <a href="#element-result-document"><code>xsl:result-document</code></a>.)</p><ol class="enumar"><li><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> (a sequence of values) may be returned directly to the calling application.</p></li><li><p>A result tree may be constructed from the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a>. By default, a result tree is constructed if the <code>build-tree</code> attribute of the unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>yes</code>. An API for invoking transformations <span class="verb">may</span> allow this setting to be overridden by the calling application. If result tree construction is requested, it is performed as described in <a href="#result-tree-construction"><i>2.3.6.1 Result Tree Construction</i></a>. </p></li><li><p>Alternatively, the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> may be serialized as described in <a href="#result-serialization"><i>2.3.6.2 Serializing the Result</i></a>. The decision whether or not to serialize the result is determined by the rules of transformation API provided by the <a title="processor" class="termref" href="#dt-processor">processor</a>, and is not influenced by anything in the stylesheet.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>This specification does not constrain the design of application programming interfaces or the choice of defaults. In previous versions of this specification, result tree construction was a mandatory process, while serialization was optional. When invoking stylesheet functions directly, however, result tree construction and serialization may be inappropriate as defaults. These considerations may affect the design of APIs.</p><p>In previous versions of XSLT, results were delivered either in serialized form (as a character or byte stream), or as a tree. In the latter case processors typically would use either their own tree representation, or a standardized tree representation such as the W3C Document Object Model (DOM) (see <a href="#DOM-Level-2-Core">[DOM Level 2]</a>), adapted to the data structures offered by the programming language in which the API is defined. To deliver a raw result, processors need to define a representation not only of XDM nodes but also of sequences, atomic items, maps, arrays, and even functions. As with the return of a simple tree, this may involve a trade-off between strict fidelity to the XDM data model and usability in the particular programming language environment. It is <em>not</em> a requirement that an API should return results in a way that exposes every property of the XDM data model; for example there may be APIs that do not expose the precise type annotation of a returned node or atomic item, or that fail to expose the base URI or document URI of a node, or that provide no way of determining whether two nodes in the result sequence are the same node in the sense of the XPath <code>is</code> operator. The way in which maps, arrays, and functions are returned requires careful design choices. It is <span class="verb">recommended</span> that an API should be capable of returning any XDM value without error, and that there should be minimal loss of information if the raw results output by one transformation are subsequently used as input to another transformation.</p></div><div class="_diffs div4"><h5><a id="result-tree-construction"></a>2.3.6.1 <a href="#result-tree-construction" style="text-decoration: none">Result Tree Construction</a></h5><p>If a result tree is to be constructed from the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a>, then this is done by applying the rules for the process of <a href="https://qt4cg.org/specifications/xslt-xquery-serialization-40/#sequence-normalization">sequence normalization</a><sup><small>SE</small></sup> as defined in <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a>. This process takes as input the serialization parameters defined in the unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> of the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>; though the only parameter that is actually used by this process is <code>item-separator</code>. </p><p>The sequence normalization process either returns a document node, or raises a serialization error. The content of the document node is not necessarily well-formed (the document node may have any number of element or text nodes among its children).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>More specifically, the process raises a serialization error if any item in the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> is an attribute node, a namespace node, or a function (including a map, but not an array: arrays are flattened).</p></div><p>The tree that is constructed is referred to as a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>.</p><p>If the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> will consist of a document node with no children.</p><p>The base URI of the document node is set to the <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <code>item-separator</code> property has no effect if the raw result of the transformation is a sequence of length zero or one, which in practice will often be the case, especially in a traditional scenario such as transformation of an XML document to HTML.</p><p>If there is no <code>item-separator</code>, then a single space is inserted between adjacent atomic items; for example if the raw result is the sequence <code>1 to 5</code>, then sequence normalization produces a tree comprising a document node with a single child, the child being a text node with the string value <code>1 2 3 4 5</code>.</p><p>If there is an <code>item-separator</code>, then it is used not only between adjacent atomic items, but between any pair of items in the raw result. For example if the raw result is a sequence of two element nodes <code>A</code> and <code>B</code>, and the <code>item-separator</code> is a comma, then the result of sequence normalization will be a document node with three children: a copy of <code>A</code>, a text node whose string value is a single comma, and a copy of <code>B</code>.</p></div></div><div class="_diffs div4"><h5><a id="result-serialization"></a>2.3.6.2 <a href="#result-serialization" style="text-decoration: none">Serializing the Result</a></h5><p>See <a href="#parsing-and-serialization"><i>2.7 Parsing and Serialization</i></a>.</p><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> may optionally be serialized as described in <a href="#serialization"><i>26 Serialization</i></a>. The serialization is controlled by the serialization parameters defined in the unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> of the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The first phase of serialization, called <a href="https://qt4cg.org/specifications/xslt-xquery-serialization-40/#sequence-normalization">sequence normalization</a><sup><small>SE</small></sup>, takes place for some output methods but not others. For example, if the <code>json</code> output method (defined in <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a>) is selected, then the process of constructing a tree is bypassed.</p></div><p>The effect of serialization is to generate a sequence of octets, representing the serialized result in some character encoding. The processor’s API may define mechanisms enabling this sequence of octets to be written to persistent storage at some location. The default location is the location identified by the <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>.</p><p>In previous versions of this specification it was stated that when the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> of the initial template or function is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, a result tree should be produced if and only if the transformation generates no secondary results (that is, if it does not invoke <a href="#element-result-document"><code>xsl:result-document</code></a>). This provision is most likely to have a noticeable effect if the transformation produces serialized results, and these results are written to persistent storage: the effect is then that a transformation producing <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty principal result will overwrite any existing content at the base output URI location if and only if the transformation produces no other output. Processor APIs offering backwards compatibility with earlier versions of XSLT must respect this behavior, but there is no requirement for new processor APIs to do so.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-base-output-uri" title="base output URI"></a> The <b>base output URI</b> is a URI to be used as the base URI when resolving a relative URI reference allocated to a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>. If the transformation generates more than one final result tree, then typically each one will be allocated a URI relative to this base URI.<span class="definition">]</span> The way in which a base output URI is established is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. Each invocation of the stylesheet may supply a different base output URI. It is acceptable for the base output URI to be <a title="absent" class="termref" href="#dt-absent">absent</a>, provided no constructs (such as <a href="#element-result-document"><code>xsl:result-document</code></a>) are evaluated that depend on the value of the base output URI.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It will often be convenient for the base output URI to be the same as the location to which the principal result document is serialized, but this relationship is not a necessary one.</p></div></div></div></div></div><div class="_diffs div1"><h2><a id="stylesheet-structure"></a>3 <a href="#stylesheet-structure" style="text-decoration: none">Stylesheet Structure</a></h2><p>This section describes the overall structure of a stylesheet as a collection of XML documents.</p><div class="_diffs div2"><h3><a id="namespaces"></a>3.1 <a href="#namespaces" style="text-decoration: none">Namespaces</a></h3><p>A <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> is typically written as a namespace well-formed XML document: more formally, as described in <a href="#stylesheet-modules"><i>3.5 Stylesheet Modules</i></a>, a stylesheet module takes the form of an XDM tree rooted at an element node.</p><p>The names of elements and attributes in source documents and result documents are namespace-qualified names. In addition, as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a>, XSLT uses namespace-qualified names to identify variables, functions, templates, and other components. These names generally use namespace prefixes that are resolved to namespace URIs using a set of prefix-uri namespace bindings.</p><p>There are two ways namespace bindings can be established in a stylesheet module:</p><ul><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-native-namespace-bindings" title="native namespace bindings"></a> The <b>native namespace bindings</b> for any element in an XSLT <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> are the prefix-uri mappings defined by the namespace nodes of that element, according to the rules in <a href="#xpath-datamodel-40">[XDM 4.0]</a>.<span class="definition">]</span></p><p>For example, a namespace declaration of the form <code>xmlns:math="http://www.w3.org/2005/xpath-functions/math</code> establishes a binding of the prefix <code>math</code> to the namespace URI <code>http://www.w3.org/2005/xpath-functions/math</code>, thereby enabling functions in that namespace to be invoked using an expression such as <code>math:sin($theta)</code></p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-fixed-namespace-bindings" title="fixed namespace bindings"></a> The <b>fixed namespace bindings</b> for a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> are established using the <code>fixed-namespaces</code> attribute on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a> element enclosing the stylesheet module.<span class="definition">]</span></p><p>For example, the attribute <code>fixed-namespaces="math map array"</code> establishes bindings for the prefixes <code>math</code>, <code>map</code>, and <code>array</code> to the namespace URIs conventionally associated with these prefixes as described in <a href="#reserved-namespaces"><i>5.1.3 Reserved Namespaces</i></a>.</p></li></ul><p>Prefixes used in element and attribute names in the stylesheet, because these are interpreted by the XML parser and not only by the XSLT processor, <span class="verb">must</span> be bound using <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace bindings</a>. In particular, the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> is used in the names of XSLT elements, so it must be declared in every stylesheet module using a namespace declaration such as <code>xmlns:xsl="http://www.w3.org/1999/XSL/Transform</code>. (A different prefix can be used: some users prefer <code>xslt</code>, some favor the default namespace.) But namespace prefixes that are only used within the content of attribute and text nodes in the stylesheet (for example, <code>select="math:sin($theta)"</code>) can be declared in <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-applicable-static-namespaces" title="applicable static namespaces"></a> The <b>applicable static namespaces</b> for an element in a stylesheet module are the <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a> for the module if the root element of the module has a <code>fixed-namespaces</code> attribute, or the <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace bindings</a> of the element otherwise. <span class="definition">]</span></p><p>The effect of declaring fixed namespace bindings is described in more detail in <a href="#fixed-namespaces"><i>3.6.1 The fixed-namespaces Attribute</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>As a general rule:</p><ul><li><p>Prefixes used in the names of elements and attributes in the stylesheet must be declared using <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace bindings</a>.</p></li><li><p>Prefixes used in QNames appearing in the content of attribute nodes and text nodes in the stylesheet can usually be declared using <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a>. There are a small number of exceptions, notably the standard attributes <code>[xsl:]exclude-result-prefixes</code> and <code>[xsl:]extension-element-prefixes</code>, and the <code>stylesheet-prefix</code> and <code>result-prefix</code> attributes of <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a>.</p></li></ul></div><div class="_diffs div3"><h4><a id="xslt-namespace"></a>3.1.1 <a href="#xslt-namespace" style="text-decoration: none">XSLT Namespace</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-xslt-namespace" title="XSLT namespace"></a>The <b>XSLT namespace</b> has the URI <code>http://www.w3.org/1999/XSL/Transform</code>. It is used to identify elements, attributes, and other names that have a special meaning defined in this specification.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <code>1999</code> in the URI indicates the year in which the URI was allocated by the W3C. It does not indicate the version of XSLT being used, which is specified by attributes (see <a href="#stylesheet-element"><i>3.6 Stylesheet Element</i></a> and <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>).</p></div><p>XSLT <a title="processor" class="termref" href="#dt-processor">processors</a><span class="verb">must</span> use the XML namespaces mechanism <a href="#xml-names">[Namespaces in XML]</a> to recognize elements and attributes from this namespace. Elements from the XSLT namespace are recognized only in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> and not in the source document. The complete list of XSLT-defined elements is specified in <a href="#element-syntax-summary"><i>C Element Syntax Summary</i></a>. <a title="implementation" class="termref" href="#dt-implementation">Implementations</a><span class="verb">must not</span> extend the XSLT namespace with additional elements or attributes. Instead, any extension <span class="verb">must</span> be in a separate namespace. Any namespace that is used for additional instruction elements <span class="verb">must</span> be identified by means of the <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> mechanism specified in <a href="#extension-instruction"><i>24.3 Extension Instructions</i></a>.</p><p>Except where the rules for <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> dictate otherwise, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for any element in the stylesheet to be in the XSLT namespace unless it is an element defined in this specification <span class="error">[see <a href="#err-XTSE0010">ERR XTSE0010</a>]</span>.</p><p>This specification uses a prefix of <code>xsl:</code> for referring to elements in the XSLT namespace. However, XSLT stylesheets are free to use any prefix, provided that there is a namespace declaration that binds the prefix to the URI of the XSLT namespace.</p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">Throughout this specification, an element or attribute that is in no namespace, or an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> whose namespace part is an empty sequence, is referred to as having a <b>null namespace URI</b>.</span><span style="display: none;" class="add_version">Throughout this specification, an element or attribute that is in no namespace, or an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> whose namespace part is the empty sequence, is referred to as having a <b>null namespace URI</b>.</span><span class="modify_version">Throughout this specification, an element or attribute that is in no namespace, or an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> whose namespace part is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, is referred to as having a <b>null namespace URI</b>.</span></p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>By convention, the names of <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>, attributes and functions are all lower-case; they use hyphens to separate words, and they use abbreviations only if these already appear in the syntax of a related language such as XML or HTML. Names of types defined in XML Schema are regarded as single words and are capitalized exactly as in XML Schema. This sometimes leads to composite function names such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-current-dateTime"><code>current-dateTime</code></a>.</p></div></div></div><div class="_diffs div2"><h3><a id="simplified-stylesheet"></a>3.7 <a href="#simplified-stylesheet" style="text-decoration: none">Simplified Stylesheet Modules</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#include">next</a> | <a href="#fixed-namespaces">previous</a>)</p><ol><li><p> Simplified stylesheets no longer require an <code>xsl:version</code> attribute (which means they might not need a declaration of the XSLT namespace). Unless otherwise specified, a 4.0 simplified stylesheet defaults <code>expand-text</code> to <code>true</code>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/90">90</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/599">599</a>&nbsp;12 September 2023]</i></p></li><li><p> The outermost element of a simplified stylesheet need no longer be a literal result element, it can now be any instruction (including <a href="#element-result-document"><code>xsl:result-document</code></a>). This allows a simplified stylesheet to produce JSON output as well as XML or HTML. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2322">2322</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2323">2323</a>&nbsp;30 November 2025]</i></p></li></ol></div><p>A simplified syntax is allowed for a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that defines only a single template rule. A simplified stylesheet module consist of a single <a title="instruction" class="termref" href="#dt-instruction">instruction</a> or <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a> together with its contents. Such a stylesheet module is equivalent to a standard stylesheet module whose <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element contains a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> containing the instruction or literal result element; the template rule has a match <a title="pattern" class="termref" href="#dt-pattern">pattern</a> of <code>match="."</code>, which matches any item.</p><div class="example"><div class="exampleHeader"><a id="d4e10439"></a>Example: A Simplified Stylesheet</div><p>The following example shows a stylesheet that simply evaluates one XPath expression:</p><div class="exampleInner"><pre xml:space="preserve">&lt;out&gt;{count(//*)}&lt;/out&gt;</pre></div><p>The output of the stylesheet will be an XML document such as <code>&lt;out&gt;17&lt;/out&gt;</code> showing the number of elements found in the supplied source document.</p><p>This simplified stylesheet is defined to be equivalent to the following expanded stylesheet:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:stylesheet xmlns="http://www.w3.org/1999/XSL/Transform"
                  version="4.0" expand-text="yes"&gt;
    &lt;xsl:template match="."&gt;
        &lt;out&gt;{count(//*)}&lt;/out&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></div><p>Because the stylesheet contains no elements or attributes in the XSLT namespace, it does not need to contain any namespace declarations.</p></div><p>A simplified stylesheet can contain XSLT instructions, in which case the XSLT namespace needs to be declared. This is illustrated in the next example.</p><div class="example"><div class="exampleHeader"><a id="d4e10454"></a>Example: A Simplified Stylesheet Containing XSLT Instructions</div><p>This stylesheet outputs an HTML document containing a table that summarizes the value of transactions according to their rate of tax:</p><div class="exampleInner"><pre xml:space="preserve">&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xsl:version="4.0"&gt;
  &lt;head&gt;
    &lt;title&gt;Expenditure by Tax Rate&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
           &lt;th&gt;Gross Amount&lt;/th&gt;
           &lt;th&gt;Tax Rate&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;xsl:for-each-group select="//transaction" group-by="vat-rate"&gt;
          &lt;tr&gt;
            &lt;td&gt;{sum(current-group()/value)}&lt;/td&gt;
            &lt;td&gt;{current-grouping-key()}&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/xsl:for-each-group&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e10459"></a>Example: A Simplified Stylesheet to Transform JSON</div><p>This example expects as input a parsed JSON document containing an array of records. It outputs a serialized JSON document containing a selection of fields from these records.</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:result-document method="json" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:array&gt;
    &lt;xsl:for-each select="?*"&gt;
      &lt;xsl:record first="?firstName" 
                  last="?surname"
                  phone="?mobile"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:array&gt;
&lt;/xsl:result-document&gt;</pre></div></div><p>More formally, a simplified stylesheet module is equivalent to the standard stylesheet module that would be generated by applying the following transformation to the simplified stylesheet module, invoking the transformation by calling the <a title="named template" class="termref" href="#dt-named-template">named template</a><code>expand</code>, with the outermost element as the <a title="context node" class="termref" href="#dt-context-node">context node</a>: </p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:stylesheet version="4.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&amp;gt;

&lt;xsl:template name="expand"&gt;
  &lt;xsl:element name="xsl:stylesheet"&gt;
    &lt;xsl:variable name="version"
        select="(if (self::xsl:*) then @version else @xsl:version)
                   otherwise '4.0'"/&gt;
    &lt;xsl:attribute name="version" select="$version"/&gt;
    &lt;xsl:attribute name="expand-text" 
                   select="not(number($version) le 3.0)"/&gt;
    &lt;xsl:element name="xsl:template"&gt;
      &lt;xsl:attribute name="match" select="'.'"/&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div><p>The allowed content of an instruction or literal result element when used as a simplified stylesheet is the same as when it occurs within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. Thus, a simplified stylesheet cannot contain <a title="declaration" class="termref" href="#dt-declaration">declarations</a>. In particular, simplified stylesheets therefore cannot use <a title="template rule" class="termref" href="#dt-template-rule">template rules</a>, <a title="global variable" class="termref" href="#dt-global-variable">global variables</a>, <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>, <a title="key" class="termref" href="#dt-key">keys</a>, <a title="attribute set" class="termref" href="#dt-attribute-set">attribute-sets</a>, or <a title="output definition" class="termref" href="#dt-output-definition">output definitions</a>. Furthermore, they cannot contain <a href="#element-include"><code>xsl:include</code></a>, <a href="#element-import"><code>xsl:import</code></a>, or <a href="#element-use-package"><code>xsl:use-package</code></a> declarations.</p><p>The only useful way to initiate the transformation is to supply an item as the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, to be matched by the implicit <code>match="."</code> template rule using the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>There are several significant changes to simplified stylesheets in XSLT 4.0.</p><ol class="enumar"><li><p>It is no longer required to include an <code>xsl:version</code> attribute; this in turn means it is often no longer necessary to declare the <code>xsl</code> namespace. The <code>xsl:version</code> attribute defaults to the version of the XSLT processor, that is, "4.0" for an XSLT 4.0 processor.</p></li><li><p>If the <code>xsl:version</code> attribute is omitted, or is set to "4.0" or a larger value, then the <code>expand-text</code> attribute defaults to <code>true</code>, meaning that <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a> are recognized.</p></li><li><p>The outermost element of a simplified stylesheet can be any instruction (for example, <code>xsl:array</code>, <code>xsl:map</code>, or <code>xsl:result-document</code>), allowing the stylesheet to deliver arrays, maps, or serialized JSON.</p></li><li><p>The match pattern of the implicit template rule uses <code>match="."</code> rather than <code>match="/"</code>, allowing the <a title="" class="termref" href="#"></a> to be any item, not only a document node.</p></li></ol></div><div class="note"><p class="prefix"><b>Note:</b></p><p>It is technically valid for the outermost element to be <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a>, because these are defined as <a title="" class="termref" href="#">instructions</a>; however, this achieves no useful purpose because the result of these instructions is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p></div></div><div class="_diffs div2"><h3><a id="preprocessing"></a>3.12 <a href="#preprocessing" style="text-decoration: none">Stylesheet Preprocessing</a></h3><p><span style="display: none;" class="delete_version">This specification provides <span>three</span> features that cause the raw stylesheet to be preprocessed as the first stage of static processing: </span><span style="display: none;" class="add_version">This specification provides several features that cause the raw stylesheet to be preprocessed as the first stage of static processing: </span><span class="modify_version">This specification provides <span class="deltaxml-old" style="background:#FF5555">three</span><span class="deltaxml-new" style="background:#90EE90">several</span> features that cause the raw stylesheet to be preprocessed as the first stage of static processing: </span></p><ul><li><p>Whitespace and commentary are stripped (see <a href="#stylesheet-stripping"><i>3.12.1 Stripping Whitespace and Commentary from the Stylesheet</i></a>).</p></li><li class="add_version" style="display: none;"><p>Any <a href="#element-note"><code>xsl:note</code></a> elements are removed: see <a href="#xsl-note-elements"><i>3.12.2 The xsl:note element</i></a>.</p></li><li class="modify_version"><p><span class="deltaxml-new" style="background:#90EE90">Any </span><a href="#element-note"><code><span class="deltaxml-new" style="background:#90EE90">xsl:note</span></code></a><span class="deltaxml-new" style="background:#90EE90"> elements are removed: see </span><a href="#xsl-note-elements"><i><span class="deltaxml-new" style="background:#90EE90">3.12.2 The xsl:note element</span></i></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p>Elements may be conditionally included or excluded by means of an <code>[xsl:]use-when</code> attribute as described in <a href="#conditional-inclusion"><i>3.12.3 Conditional Element Inclusion</i></a>.</p></li><li><p>Attributes may be conditionally computed as described in <a href="#shadow-attributes"><i>3.12.4 Shadow Attributes</i></a>.</p></li></ul><p></p><p>Note that many of the rules affecting the validity of stylesheet documents apply to a stylesheet after this preprocessing phase has been carried out.</p></div></div><div class="_diffs div1"><h2><a id="constructs"></a>5 <a href="#constructs" style="text-decoration: none">Features of the XSLT Language</a></h2><div class="_diffs div2"><h3><a id="static-and-dynamic-context"></a>5.3 <a href="#static-and-dynamic-context" style="text-decoration: none">The Static and Dynamic Context</a></h3><p>XPath defines the concept of an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-expression-context">expression context</a><sup><small>XP</small></sup> which contains all the information that can affect the result of evaluating an <a title="expression" class="termref" href="#dt-expression">expression</a>. The expression context has two parts, the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-context">static context</a><sup><small>XP</small></sup>, and the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamic-context">dynamic context</a><sup><small>XP</small></sup>. The components that make up the expression context are defined in the XPath specification (see <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#context">2.2 Expression Context</a>). This section describes the way in which these components are initialized when an XPath expression is contained within an XSLT stylesheet.</p><p> This section does not apply to <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a> (whose context is defined in <a href="#static-expression"><i>9.7 Static Expressions</i></a>), nor to XPath expressions evaluated using <a href="#element-evaluate"><code>xsl:evaluate</code></a> (whose context is defined in <a href="#evaluate-dynamic-context"><i>10.5.2 Dynamic context for the target expression</i></a>). </p><p>As well as providing values for the static and dynamic context components defined in the XPath specification, XSLT defines additional context components of its own. These context components are used by XSLT instructions (for example, <a href="#element-next-match"><code>xsl:next-match</code></a> and <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>), and also by the functions in the extended function library described in this specification.</p><p>The following four sections describe:</p><blockquote><p><a href="#static-context"><i>5.3.1 Initializing the Static Context</i></a><br><a href="#additional-static-context"><i>5.3.2 Additional Static Context Components used by XSLT</i></a><br><a href="#xpath-dynamic-context"><i>5.3.3 Initializing the Dynamic Context</i></a><br><a href="#additional-dynamic-context"><i>5.3.4 Additional Dynamic Context Components used by XSLT</i></a></p></blockquote><div class="_diffs div3"><h4><a id="static-context"></a>5.3.1 <a href="#static-context" style="text-decoration: none">Initializing the Static Context</a></h4><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-context">static context</a><sup><small>XP</small></sup> of an XPath expression appearing in an XSLT stylesheet is initialized as follows. In these rules, the term <b>containing element</b> means the element within the stylesheet that is the parent of the attribute or text node whose value contains the XPath expression in question, and the term <b>enclosing element</b> means the containing element or any of its ancestors.</p><ul><li><p><a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is set to <code>true</code> if and only if the containing element is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a> (see <a href="#backwards"><i>3.8 Backwards Compatible Processing</i></a>).</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-namespaces">statically known namespaces</a><sup><small>XP</small></sup> are the <span><a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a></span> for the containing element.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-default-namespace-elements-and-types">default namespace for elements and types</a><sup><small>XP</small></sup> is determined as described in <a href="#unprefixed-element-names"><i>5.1.2.1 Unprefixed Element Names</i></a>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-default-function-namespace">default function namespace</a><sup><small>XP</small></sup> is <code>http://www.w3.org/2005/xpath-functions</code> (and cannot be changed).</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-issd">in-scope schema definitions</a><sup><small>XP</small></sup> for the XPath expression are the same as the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> for the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, and are as specified in <a href="#built-in-types"><i>3.13 Built-in Types</i></a>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-in-scope-variables">in-scope variables</a><sup><small>XP</small></sup> are defined by the <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable binding elements</a> that are in scope for the containing element (see <a href="#variables-and-parameters"><i>9 Variables and Parameters</i></a>).</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-statically-known-function-definitions">statically known function definitions</a><sup><small>XP</small></sup> are:</p><ul><li><p>The functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> in namespaces <code>http://www.w3.org/2005/xpath-functions</code> and <code>http://www.w3.org/2005/xpath-functions/math</code>;</p></li><li><p>The functions defined in this specification in namespaces <code>http://www.w3.org/2005/xpath-functions</code> and <code>http://www.w3.org/2005/xpath-functions/map</code>;</p></li><li><p>Constructor functions for all the simple types in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-issd">in-scope schema definitions</a><sup><small>XP</small></sup>, including both built-in types and user-defined types;</p></li><li><p>The <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> defined in the containing <a title="package" class="termref" href="#dt-package">package</a>;</p></li><li><p>Stylesheet functions defined in used packages, subject to visibility: see <a href="#package-dependencies"><i>3.4.2 Dependencies between Packages</i></a>;</p></li><li><p>any <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> bound using <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> mechanisms (see <a href="#extension"><i>24 Extensibility and Fallback</i></a>).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The term <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> includes both vendor-supplied and user-written extension functions.</p></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>It follows from the above that a conformant XSLT processor must implement the entire library of functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> as well as those defined in this specification.</p></div></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-collations">statically known collations</a><sup><small>XP</small></sup> are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, except that they <span class="verb">must</span> always include (a) the Unicode codepoint collation, defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#string-compare">5.3 Comparison of strings</a>, and (b) the family of UCA collations described in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#uca-collations">5.3.4 The Unicode Collation Algorithm</a>.</p></li><li><p><b>Static base URI</b>: In a conventional interpreted environment, the static base URI of an expression in the stylesheet is the base URI of the containing element in the stylesheet. The concept of the base URI of a node is defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-base-uri">7.6.2 base-uri Accessor</a>.</p><p>When stylesheets are executed in an environment where no source code is present (for example, because the code of the stylesheet has been compiled and is distributed as executable object code), it is <span class="verb">recommended</span> (subject to operational constraints such as security) that the static base URI used during stylesheet evaluation should be the location from which the stylesheet was loaded for execution (its “deployed location”). This means, for example, that when the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> or <a href="#func-document"><code>document</code></a> functions are called with a relative URI, the required document is by default located relative to the deployed location of the stylesheet. </p><p>Whether or not the stylesheet is executed directly from source code, it is possible that no static base URI is available, for example because the code was supplied as an anonymous input stream, or because security policies are set to prevent executable code discovering the location from which it was loaded. If the static base URI is not known, the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-static-base-uri"><code>static-base-uri</code></a> function returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, and other operations that depend on the static base URI may fail with a dynamic error.</p></li><li><p>The set of <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-decimal-formats">statically known decimal formats</a><sup><small>XP</small></sup> is the set of decimal formats defined by <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations in the stylesheet. </p></li></ul></div><div class="_diffs div3"><h4><a id="additional-dynamic-context"></a>5.3.4 <a href="#additional-dynamic-context" style="text-decoration: none">Additional Dynamic Context Components used by XSLT</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#named-item-types">next</a> | <a href="#unprefixed-qnames">previous</a>)</p><ol><li><p></p><p>XSLT-specific components of the dynamic context can now be retained in the captured context of a function item, in the same way as XPath-defined components of the dynamic context.</p><i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/407">407</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2274">2274</a>&nbsp;6 January 2026]</i><p></p></li></ol></div><p>In addition to the values that make up the <a title="focus" class="termref" href="#dt-focus">focus</a>, an XSLT processor maintains a number of other dynamic context components that reflect aspects of the evaluation context. These components are fully described in the sections of the specification that maintain and use them. They are:</p><ul><li><p>The <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a>, which is the <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> most recently invoked by an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a> instruction: see <a href="#apply-imports"><i>6.9 Overriding Template Rules</i></a>; </p></li><li><p>The <a title="current mode" class="termref" href="#dt-current-mode">current mode</a>, which is the <a title="mode" class="termref" href="#dt-mode">mode</a> set by the most recent call of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> (for a full definition see <a href="#modes"><i>6.7 Modes</i></a>);</p></li><li><p>The <a title="current group" class="termref" href="#dt-current-group">current group</a> and <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a>, which provide information about the collection of items currently being processed by an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction: see <a href="#func-current-group"><i>14.2.1 fn:current-group</i></a> and <a href="#func-current-grouping-key"><i>14.2.2 fn:current-grouping-key</i></a>;</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In XSLT 3.0 the initial value of these two properties is “absent”, which means that any reference to their values causes a dynamic error. Previously, the initial value was <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. </p></div></li><li><p>The <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> and <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a>, which provide information about the collection of items currently being processed by an <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p></li><li><p>The <a title="current captured groups" class="termref" href="#dt-current-captured-groups">current captured groups</a>: this is maintained when a string is matched against a regular expression using the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction. It is a map from integer group numbers (reflecting the ordering of capturing parentheses with the regular expression) to string segments: a string segment is a contiguous substring of the input string being matched, characterized by the position of the first and last characters of the substring within the input. The current captured groups are accessible to applications using the <a href="#func-regex-groups"><code>regex-groups</code></a> and <a href="#func-regex-group"><code>regex-group</code></a> functions: see <a href="#func-regex-group"><i>17.2.2 fn:regex-group</i></a>.</p></li><li><p>The <a title="output state" class="termref" href="#dt-output-state">output state</a>: this is a flag whose two possible values are <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a> and <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>. The initial setting when the stylesheet is invoked by executing a template is <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a>, and it is switched to <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a> by instructions such as <a href="#element-variable"><code>xsl:variable</code></a>. For more details, see <a href="#result-document-restrictions"><i>25.2 Restrictions on the use of xsl:result-document</i></a>.</p></li><li><p>The <a title="current output URI" class="termref" href="#dt-current-output-uri">current output URI</a>: this is the URI associated with the result tree to which instructions are currently writing. The current output URI is initially the same as the <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>. During the evaluation of an <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, the current output URI is set to the absolute URI identified by the <code>href</code> attribute of that instruction.</p></li></ul><p>The following non-normative table summarizes the initial state of each of the components in the evaluation context, and the instructions which cause the state of the component to change.</p><table class="data"><caption>Components of the Dynamic Evaluation Context</caption><thead><tr><th style="text-align:left; vertical-align:top">Component</th><th style="text-align:left; vertical-align:top">Initial Setting</th><th style="text-align:left; vertical-align:top">Set by</th><th style="text-align:left; vertical-align:top">Cleared by</th></tr></thead><tbody><tr><td style="vertical-align:top; text-align:left"><a title="focus" class="termref" href="#dt-focus">focus</a></td><td style="vertical-align:top; text-align:left">See <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>.</td><td style="vertical-align:top; text-align:left"><a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-for-each"><code>xsl:for-each</code></a>, <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, <a href="#element-analyze-string"><code>xsl:analyze-string</code></a>, evaluation of <a title="pattern" class="termref" href="#dt-pattern">patterns</a></td><td style="vertical-align:top; text-align:left">Calls to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a></td></tr><tr><td style="vertical-align:top; text-align:left"><a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a></td><td style="vertical-align:top; text-align:left">If apply-templates invocation is used (see <a href="#invoking-initial-mode"><i>2.3.3 Apply-Templates Invocation</i></a>), then for each item in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, the <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a> is initially set to the template rule chosen for processing that item. Otherwise, <a title="absent" class="termref" href="#dt-absent">absent</a>. </td><td style="vertical-align:top; text-align:left"><a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, <a href="#element-next-match"><code>xsl:next-match</code></a></td><td style="vertical-align:top; text-align:left">See <a href="#apply-imports"><i>6.9 Overriding Template Rules</i></a>. </td></tr><tr><td style="vertical-align:top; text-align:left"><a title="current mode" class="termref" href="#dt-current-mode">current mode</a></td><td style="vertical-align:top; text-align:left">the initial <a title="mode" class="termref" href="#dt-mode">mode</a></td><td style="vertical-align:top; text-align:left"><a href="#element-apply-templates"><code>xsl:apply-templates</code></a></td><td style="vertical-align:top; text-align:left">Calls to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>. Also cleared while evaluating global variables and stylesheet parameters, <a title="pattern" class="termref" href="#dt-pattern">patterns</a>, and the sequence constructor contained in <a href="#element-key"><code>xsl:key</code></a> or <a href="#element-sort"><code>xsl:sort</code></a>. Clearing the current mode causes the current mode to be set to the default (unnamed) mode.</td></tr><tr><td style="vertical-align:top; text-align:left"><a title="current group" class="termref" href="#dt-current-group">current group</a></td><td style="vertical-align:top; text-align:left">absent</td><td style="vertical-align:top; text-align:left"><a href="#element-for-each-group"><code>xsl:for-each-group</code></a></td><td style="vertical-align:top; text-align:left">See <a href="#func-current-group"><i>14.2.1 fn:current-group</i></a>.</td></tr><tr><td style="vertical-align:top; text-align:left"><a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a></td><td style="vertical-align:top; text-align:left">absent</td><td style="vertical-align:top; text-align:left"><a href="#element-for-each-group"><code>xsl:for-each-group</code></a></td><td style="vertical-align:top; text-align:left">See <a href="#func-current-grouping-key"><i>14.2.2 fn:current-grouping-key</i></a>.</td></tr><tr><td style="vertical-align:top; text-align:left"><a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a></td><td style="vertical-align:top; text-align:left">absent</td><td style="vertical-align:top; text-align:left"><a href="#element-merge"><code>xsl:merge</code></a></td><td style="vertical-align:top; text-align:left">See <a href="#func-current-merge-group"><i>15.5.1 fn:current-merge-group</i></a>.</td></tr><tr><td style="vertical-align:top; text-align:left"><a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a></td><td style="vertical-align:top; text-align:left"><span>absent</span></td><td style="vertical-align:top; text-align:left"><a href="#element-merge"><code>xsl:merge</code></a></td><td style="vertical-align:top; text-align:left">See <a href="#func-current-merge-key"><i>15.5.3 fn:current-merge-key</i></a> and <a href="#func-current-merge-key-array"><i>15.5.2 fn:current-merge-key-array</i></a>.</td></tr><tr><td style="vertical-align:top; text-align:left"><a title="current captured groups" class="termref" href="#dt-current-captured-groups">current captured substrings</a></td><td style="vertical-align:top; text-align:left">empty sequence</td><td style="vertical-align:top; text-align:left"><a href="#element-matching-substring"><code>xsl:matching-substring</code></a></td><td style="vertical-align:top; text-align:left"><a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>; Calls to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>, dynamic function calls, evaluation of global variables, stylesheet parameters, and <a title="pattern" class="termref" href="#dt-pattern">patterns</a></td></tr><tr><td style="vertical-align:top; text-align:left"><a title="output state" class="termref" href="#dt-output-state">output state</a></td><td style="vertical-align:top; text-align:left"><a title="final output state" class="termref" href="#dt-final-output-state">final output state</a></td><td style="vertical-align:top; text-align:left">Set to <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a> by instructions such as <a href="#element-variable"><code>xsl:variable</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, etc., and by calls on <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a></td><td style="vertical-align:top; text-align:left">None</td></tr><tr><td style="vertical-align:top; text-align:left"><a title="current output URI" class="termref" href="#dt-current-output-uri">current output URI</a></td><td style="vertical-align:top; text-align:left"><a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a></td><td style="vertical-align:top; text-align:left"><a href="#element-result-document"><code>xsl:result-document</code></a></td><td style="vertical-align:top; text-align:left">Calls to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>, dynamic function calls, evaluation of <a title="global variable" class="termref" href="#dt-global-variable">global variables</a>, <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, and <a title="pattern" class="termref" href="#dt-pattern">patterns</a>.</td></tr></tbody></table><p><span class="definition">[Definition:&nbsp;</span><a id="dt-initial-setting" title="initial setting"></a>The <b>initial setting</b> of a component of the dynamic context is used when evaluating <a title="global variable" class="termref" href="#dt-global-variable">global variables</a> and <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, when evaluating the <code>use</code> and <code>match</code> attributes of <a href="#element-key"><code>xsl:key</code></a>, and when evaluating the <code>initial-value</code> of <a href="#element-accumulator"><code>xsl:accumulator</code></a> and the <code>select</code> expressions or contained sequence constructors of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a><span class="definition">]</span>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-non-contextual-function-call" title="non-contextual function call"></a>The term <b>non-contextual function call</b> is used to refer to function calls that do not pass the dynamic context to the called function. This includes all calls on <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> and all <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamic-function-call">dynamic function calls</a><sup><small>XP</small></sup>, (that is calls to function items). It excludes calls to some functions in the namespace <code>http://www.w3.org/2005/xpath-functions</code>, in particular those that explicitly depend on the context, such as the <a href="#func-current-group"><code>current-group</code></a> and <a href="#func-regex-group"><code>regex-group</code></a> functions. It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether, and under what circumstances, calls to <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> are non-contextual.<span class="definition">]</span></p><p>Named function references (such as <code>position#0</code>) and calls on <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a> (for example, <code>function-lookup("position", 0)</code>) are defined to retain the XPath static and dynamic context at the point of invocation as part of the closure of the resulting function item, and to use this preserved context when a dynamic function call is subsequently made using the function item. In XSLT 4.0 this rule extends to the XSLT extensions to the dynamic context defined in this section. For example the call <code>regex-group#1</code>) delivers a function item that holds a snapshot of the <a title="" class="termref" href="#"></a> in its closure, and subsequent evaluation of that function item will return the relevant value from that snapshot.</p></div></div></div><div class="_diffs div1"><h2><a id="rules"></a>6 <a href="#rules" style="text-decoration: none">Template Rules</a></h2><p>Template rules define the processing that can be applied to items that match a particular <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p><div class="_diffs div2"><h3><a id="modes"></a>6.7 <a href="#modes" style="text-decoration: none">Modes</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-mode" title="mode"></a> A <b>mode</b> is a set of template rules; when the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects a set of items for processing, it identifies the rules to be used for processing those items by nominating a mode, explicitly or implicitly.<span class="definition">]</span> Modes allow a node in a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> (for example) to be processed multiple times, each time producing a different result. They also allow different sets of <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> to be active when processing different trees, for example when processing documents loaded using the <a href="#func-document"><code>document</code></a> function (see <a href="#func-document"><i>20.1 fn:document</i></a>). </p><p>Modes are identified by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>; in addition to any named modes, there is always one unnamed mode available. Whether a mode is named or unnamed, its properties <span class="verb">may</span> be defined in an <a href="#element-mode"><code>xsl:mode</code></a> declaration. If a mode name is used (for example in an <a href="#element-template"><code>xsl:template</code></a> declaration or an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction) and no declaration of that mode appears in the stylesheet, the mode is implicitly declared with default properties.</p><div class="_diffs div3"><h4><a id="declaring-modes"></a>6.7.1 <a href="#declaring-modes" style="text-decoration: none">Declaring Modes</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#apply-templates-function">next</a> | <a href="#applying-templates">previous</a>)</p><ol><li><p> The <a href="#element-mode"><code>xsl:mode</code></a> declaration acquires an attribute <code>as="sequence-type"</code> which declares the return type of all template rules in that mode. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/750">750</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/751">751</a>&nbsp;16 October 2023]</i></p></li><li><p> The <a href="#element-mode"><code>xsl:mode</code></a> declaration acquires an attribute <code>copy-namespaces</code> which determines whether or not the built-in template rule copies unused namespace bindings. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1724">1724</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1929">1929</a>&nbsp;13 April 2025]</i></p></li></ol></div><p class="element-syntax"><a id="element-mode"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:mode<br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕<br>&nbsp;&nbsp;streamable? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;use-accumulators? = <var>tokens</var>〔''〕<br>&nbsp;&nbsp;on-no-match? = "deep-copy" | "shallow-copy" | "shallow-copy-all" | "deep-skip" | "shallow-skip" | "text-only-copy" | "fail"〔'text-only-copy'〕<br>&nbsp;&nbsp;on-multiple-match? = "use-last" | "fail"〔'use-last'〕<br>&nbsp;&nbsp;warning-on-no-match? = <var>boolean</var><br>&nbsp;&nbsp;warning-on-multiple-match? = <var>boolean</var><br>&nbsp;&nbsp;typed? = <var>string</var>〔'unspecified'〕<br>&nbsp;&nbsp;copy-namespaces? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;visibility? = "public" | "private" | "final"〔'private'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-template">xsl:template</a>*) --&gt;<br>&lt;/xsl:mode&gt;</code></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-unnamed-mode" title="unnamed mode"></a>The <b>unnamed mode</b> is the default mode used when no <code>mode</code> attribute is specified on an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction or <a href="#element-template"><code>xsl:template</code></a> declaration, unless a different <a title="default mode" class="termref" href="#dt-default-mode">default mode</a> has been specified using the <code>[xsl:]default-mode</code> attribute of a containing element.<span class="definition">]</span></p><p>Every <a title="mode" class="termref" href="#dt-mode">mode</a> other than the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a> is identified by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p><p>A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> may contain multiple <a href="#element-mode"><code>xsl:mode</code></a> declarations and may include or import <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> that also contain <a href="#element-mode"><code>xsl:mode</code></a> declarations. The name of an <a href="#element-mode"><code>xsl:mode</code></a> declaration is the value of its <code>name</code> attribute, if any.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-mode-definition" title="mode definition"></a>All the <a href="#element-mode"><code>xsl:mode</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> that share the same name are grouped into a named <b>mode definition</b>; those that have no name are grouped into a single unnamed mode definition.<span class="definition">]</span></p><p>The <code>declared-modes</code> attribute of the <a href="#element-package"><code>xsl:package</code></a> element determines whether implicit mode declarations are allowed, as described in <a href="#requiring-explicit-modes"><i>3.4.5.1 Requiring Explicit Mode Declarations</i></a>. If the package allows implicit mode declarations, then if a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> does not contain a declaration of the unnamed mode, a declaration is implied equivalent to an <a href="#element-mode"><code>xsl:mode</code></a> element with no attributes. Similarly, if there is a mode that is named in an <a href="#element-template"><code>xsl:template</code></a> or <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> element, or in the <code>[xsl:]default-mode</code> attribute of a containing element, and the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> does not contain a declaration of that mode, then a declaration is implied comprising an <a href="#element-mode"><code>xsl:mode</code></a> element with a <code>name</code> attribute equal to that mode name, plus the attribute <code>visibility="private"</code>. </p><p>The attributes of the <a href="#element-mode"><code>xsl:mode</code></a> declaration establish values for a number of properties of a mode. The allowed values and meanings of the attributes are given in the following table.</p><table class="data"><caption>Attributes of the <code>xsl:mode</code> Element</caption><thead><tr><th style="text-align:left; vertical-align:top">Attribute</th><th style="text-align:left; vertical-align:top">Values</th><th style="text-align:left; vertical-align:top">Meaning</th></tr></thead><tbody><tr><td style="vertical-align:top; text-align:left">name</td><td style="vertical-align:top; text-align:left">An <a title="EQName" class="termref" href="#dt-eqname">EQName</a></td><td style="vertical-align:top; text-align:left">Specifies the name of the mode. If omitted, this <a href="#element-mode"><code>xsl:mode</code></a> declaration provides properties of the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a></td></tr><tr><td style="vertical-align:top; text-align:left">as</td><td style="vertical-align:top; text-align:left">A <code>SequenceType</code></td><td style="vertical-align:top; text-align:left">Declares the type of value returned by all template rules in this mode. If any template rules in this mode declare their return type using an <code>as</code> attribute on <a href="#element-template"><code>xsl:template</code></a>, the values must be consistent.</td></tr><tr><td style="vertical-align:top; text-align:left">streamable</td><td style="vertical-align:top; text-align:left"><code>yes</code> or <code>no</code> (default <code>no</code>)</td><td style="vertical-align:top; text-align:left">Determines whether template rules in this mode are to be capable of being processed using <a title="streaming" class="termref" href="#dt-streaming">streaming</a>. If the value <code>yes</code> is specified, then the body of any <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> that uses this mode <span class="verb">must</span> conform to the rules for streamable templates given in <a href="../xslt-streaming-40/#streamable-templates">5 Streamable Templates</a><sup><small>SG</small></sup>.</td></tr><tr><td style="vertical-align:top; text-align:left">use-accumulators</td><td style="vertical-align:top; text-align:left"><span style="display: none;" class="delete_version">List of accumulator names, or <code>#all</code> (default is an empty list)</span><span style="display: none;" class="add_version">List of accumulator names, or <code>#all</code> (default is the empty list)</span><span class="modify_version">List of accumulator names, or <code>#all</code> (default is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty list)</span></td><td style="vertical-align:top; text-align:left">Relevant only when this mode is the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> of the transformation, determines which accumulators are applicable to documents containing nodes in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>. For further details see <a href="#applicability-of-accumulators"><i>19.2 Applicability of Accumulators</i></a>.</td></tr><tr><td style="vertical-align:top; text-align:left">on-no-match</td><td style="vertical-align:top; text-align:left">One of <code>deep-copy</code>, <code>shallow-copy</code>, <code>deep-skip</code>, <code>shallow-skip</code>, <code>text-only-copy</code> or <code>fail</code> (default <code>text-only-copy</code>)</td><td style="vertical-align:top; text-align:left">Determines selection of the built-in <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> that are used to process an item when an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects an item that does not match any user-written <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. For details, see <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>.</td></tr><tr><td style="vertical-align:top; text-align:left">on-multiple-match</td><td style="vertical-align:top; text-align:left">One of <code>fail</code> or <code>use-last</code> (default <code>use-last</code>)</td><td style="vertical-align:top; text-align:left">Defines the action to be taken when <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> is used in this mode and more than one user-written <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is available to process an item, each having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> and <a title="priority" class="termref" href="#dt-priority">priority</a>. The value <code>fail</code> indicates that it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if more than one template rule matches an item. The value <code>use-last</code> indicates that the situation is not to be treated as an error (the last template in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a> is the one that is used). </td></tr><tr><td style="vertical-align:top; text-align:left">warning-on-no-match</td><td style="vertical-align:top; text-align:left">One of <code>yes</code> or <code>no</code>. The default is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a></td><td style="vertical-align:top; text-align:left">Requests the <a title="processor" class="termref" href="#dt-processor">processor</a> to output (or not to output) a warning message in the case where an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects an item that matches no user-written template rule. The form and destination of such warnings is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The processor <span class="verb">may</span> ignore this attribute, for example if the environment provides no suitable means of communicating with the user. </td></tr><tr><td style="vertical-align:top; text-align:left">warning-on-multiple-match</td><td style="vertical-align:top; text-align:left">One of <code>yes</code> or <code>no</code>. The default is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a></td><td style="vertical-align:top; text-align:left">Requests the <a title="processor" class="termref" href="#dt-processor">processor</a> to output a warning message in the case where an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects an item that matches multiple template rules having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> and <a title="priority" class="termref" href="#dt-priority">priority</a>. The form and destination of such warnings is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The processor <span class="verb">may</span> ignore this attribute, for example if the environment provides no suitable means of communicating with the user.</td></tr><tr><td style="vertical-align:top; text-align:left">typed</td><td style="vertical-align:top; text-align:left">One of <code>yes</code>, <code>no</code>, <code>strict</code>, <code>lax</code>, or <code>unspecified</code>. The default is <code>unspecified</code>.</td><td style="vertical-align:top; text-align:left">See <a href="#xsl-mode-typed"><i>6.7.4 Declaring the Type of Values Processed by a Mode</i></a>.</td></tr><tr><td style="vertical-align:top; text-align:left">copy-namespaces</td><td style="vertical-align:top; text-align:left">One of <code>yes</code> or <code>no</code>. The default is <code>yes</code>.</td><td style="vertical-align:top; text-align:left">If <code>on-no-match</code> is <code>shallow-copy</code>, <code>shallow-copy-all</code>, or <code>deep-copy</code>, this attribute determines the effective value of the <code>copy-namespaces</code> attribute on the implicit <code>xsl:copy</code> or <code>xsl:copy-of</code> instruction in the built-in template rule (see <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>). In other cases it is ignored, apart from checking that its value is valid. </td></tr><tr><td style="vertical-align:top; text-align:left">visibility</td><td style="vertical-align:top; text-align:left">One of <code>public</code>, <code>private</code>, or <code>final</code>. The default is <code>private</code>.</td><td style="vertical-align:top; text-align:left">See <a href="#visibility"><i>3.4.4.1 Visibility of Components</i></a>. If the mode is unnamed, that is, if the <code>name</code> attribute is absent, then the <code>visibility</code> attribute if present <span class="verb">must</span> have the value <code>private</code>. <table class="ednote" caption="Editorial note"><tbody><tr><td style="text-align: left; vertical-align:top; width: 50%;"><b>Editorial note</b></td><td style="text-align: right; vertical-align:top; width: 50%;">&nbsp;</td></tr><tr style="text-align: left; vertical-align: top;"><td colspan="2">See issue 270.</td></tr></tbody></table></td></tr></tbody></table><p><span class="definition">[Definition:&nbsp;</span><a id="dt-streamable-mode" title="streamable mode"></a>A <b>streamable mode</b> is a <a title="mode" class="termref" href="#dt-mode">mode</a> that is declared in an <a href="#element-mode"><code>xsl:mode</code></a> declaration with the attribute <code>streamable="yes"</code>.<span class="definition">]</span></p><p>For any named <a title="mode" class="termref" href="#dt-mode">mode</a>, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of each attribute is taken from an <a href="#element-mode"><code>xsl:mode</code></a> declaration that has a matching name in its <code>name</code> attribute, and that specifies an explicit value for the required attribute. If there is no such declaration, the default value of the attribute is used. If there is more than one such declaration, the one with highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</p><p>For the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of each attribute is taken from an <a href="#element-mode"><code>xsl:mode</code></a> declaration that has no <code>name</code> attribute, and that specifies an explicit value for the required attribute. If there is no such declaration, the default value of the attribute is used. If there is more than one such declaration, the one with highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</p><p><a id="err-XTSE0545"><span class="error">[ERR XTSE0545] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if for any named or unnamed <a title="mode" class="termref" href="#dt-mode">mode</a>, a package explicitly specifies two conflicting values for the same attribute in different <a href="#element-mode"><code>xsl:mode</code></a> declarations having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless there is another definition of the same attribute with higher import precedence. The attributes in question are the attributes other than <code>name</code> on the <a href="#element-mode"><code>xsl:mode</code></a> element. </p></div><div class="_diffs div3"><h4><a id="mode-result-type"></a>6.7.5 <a href="#mode-result-type" style="text-decoration: none">Declaring the Result Type of a Mode</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#enclosing-modes">next</a> | <a href="#xsl-mode-typed">previous</a>)</p><ol><li><p> The result type of a mode can be declared using an <code>as</code> attribute. The result type of all template rules in this mode must be consistent with this, as must the values returned by any built-in template rules for the mode. <i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/233">233</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/750">750</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/1382">1382</a>&nbsp;PRs <a href="https://github.com/qt4cg/qtspecs/pull/751">751</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/pull/1386">1386</a>&nbsp;18 October 2023]</i></p></li></ol></div><p>Traditionally, template rules have most commonly been used to construct XDM nodes, and the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction has been used to add nodes to a result tree. However, it is also possible to use template rules to produce other kinds of value, for example strings, booleans, or maps. For the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction to be useful, it will generally be the case that all template rules in a mode produce the same kind of value: for example, if one rule delivers a boolean, then the other rules will also deliver a boolean.</p><p>XSLT 4.0 therefore allows the result type of the template rules in a mode to be declared using the <code>as</code> attribute on the <a href="#element-mode"><code>xsl:mode</code></a> declaration. If this is absent, it defaults to <code>item()*</code>. The presence of an <code>as</code> attribute on a mode provides useful documentation and consistency checking, and enables the XSLT processor to infer a static type for an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction, which can be useful for optimization.</p><p>If a template rule <var>R</var> is <a title="applicable" class="termref" href="#dt-applicable">applicable</a> to a mode <var>M</var>, and <var>M</var> is declared with an <code>as</code> attribute whose value is the <code>SequenceType</code><var>T</var>, then:</p><ul><li><p>If <var>R</var> has an <code>as</code> attribute, the <code>SequenceType</code><var>S</var> declared by <var>R</var> must be a subtype of <var>T</var>.</p><p><a id="err-XTSE4040"><span class="error">[ERR XTSE4040] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a><var>R</var> has an <code>as</code> attribute <var>S</var>, and the template rule is <a title="applicable" class="termref" href="#dt-applicable">applicable</a> to a <a title="mode" class="termref" href="#dt-mode">mode</a><var>M</var> that is declared with an <code>as</code> attribute <var>T</var>, and the sequence type <var>S</var> is not a subtype of the sequence type <var>T</var> as defined by the relationship <code>subtype(S, T)</code> in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-seqtype-subtype">3.3.1 Subtypes of Sequence Types</a>.</p></li><li><p>If <var>R</var> has no <code>as</code> attribute, then it is treated as if it had an <code>as</code> attribute set to <var>T</var>. This means that a <a title="type error" class="termref" href="#dt-type-error">type error</a><span class="error">[see <a href="#err-XTTE0505">ERR XTTE0505</a>]</span> is raised if the result of the template rule cannot be coerced to a value of type <var>T</var>.</p><p><span style="display: none;" class="delete_version">If <var>R</var> is applicable to more than one mode, then it must meet the requirements of each one, which implies that these requirements must be consistent with each other: for example, if one mode specifies <code>as="node()"</code> and another specifies <code>as="map(*)"</code>, then a type error is inevitable if the template rule is actually evaluated, and like other type errors this can be raised statically if detected statically. An <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-implausible">implausibility</a><sup><small>XP</small></sup><span class="verb">may</span> be reported if the only value that would satisfy both types is an empty sequence, map, or array.</span><span style="display: none;" class="add_version">If <var>R</var> is applicable to more than one mode, then it must meet the requirements of each one, which implies that these requirements must be consistent with each other: for example, if one mode specifies <code>as="node()"</code> and another specifies <code>as="map(*)"</code>, then a type error is inevitable if the template rule is actually evaluated, and like other type errors this can be raised statically if detected statically. An <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-implausible">implausibility</a><sup><small>XP</small></sup><span class="verb">may</span> be reported if the only value that would satisfy both types is the empty sequence, map, or array.</span><span class="modify_version">If <var>R</var> is applicable to more than one mode, then it must meet the requirements of each one, which implies that these requirements must be consistent with each other: for example, if one mode specifies <code>as="node()"</code> and another specifies <code>as="map(*)"</code>, then a type error is inevitable if the template rule is actually evaluated, and like other type errors this can be raised statically if detected statically. An <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-implausible">implausibility</a><sup><small>XP</small></sup><span class="verb">may</span> be reported if the only value that would satisfy both types is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, map, or array.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>In practice the best way to satisfy this rule is to ensure that if a template rule is applicable to more than one mode (including the case <code>mode="#all"</code>), then either (a) all those modes should have the same declared result type, or (b) the template rule should declare an explicit result type that is compatible with each one of the relevant modes.</p></div></li><li><p>The requirement to return values of the correct type extends also to the built-in template rule for the mode (see <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>). Since it is not possible to determine statically whether the explicit template rules for a mode provide complete coverage of all possible inputs, any failure of the built-in template rule to return a value that can be coerced to the expected type <span class="verb">must</span> be raised dynamically <span class="error">[see <a href="#err-XTTE0505">ERR XTTE0505</a>]</span>.</p></li></ul></div></div><div class="_diffs div2"><h3><a id="built-in-rule"></a>6.8 <a href="#built-in-rule" style="text-decoration: none">Built-in Template Rules</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#apply-imports">next</a> | <a href="#enclosing-modes">previous</a>)</p><ol><li><p> To allow recursive-descent transformation on a tree of maps and arrays, a new set of built-in templates rules <code>shallow-copy-all</code> is introduced. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/570">570</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/718">718</a>&nbsp;26 September 2023]</i></p></li></ol></div><p>When an item is selected by <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and there is no user-specified <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that can be used to process that item, then a built-in template rule is evaluated instead. </p><p>The built-in <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> have lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than all other template rules. Thus, the stylesheet author can override a built-in template rule by including an explicit template rule.</p><p>There are <span>seven</span> sets of built-in template rules available. The set that is chosen is a property of the <a title="mode" class="termref" href="#dt-mode">mode</a> selected by the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction. This property is set using the <code>on-no-match</code> attribute of the <a href="#element-mode"><code>xsl:mode</code></a> declaration, which takes one of the values <code>deep-copy</code>, <code>shallow-copy</code>, <span><code>shallow-copy-all</code>,</span><code>deep-skip</code>, <code>shallow-skip</code>, <code>text-only-copy</code>, or <code>fail</code>, the default being <code>text-only-copy</code>. The effect of these <span>seven</span> sets of built-in template rules is explained in the following subsections.</p><div class="_diffs div3"><h4><a id="built-in-templates-shallow-copy-all"></a>6.8.4 <a href="#built-in-templates-shallow-copy-all" style="text-decoration: none">Built-in Templates: Shallow Copy All</a></h4><p>This processing mode is introduced in XSLT 4.0 as a variant of <code>shallow-copy</code> to enable recursive descent processing of trees involving maps and arrays, such as might result from parsing JSON input. </p><p>For all items other than maps and arrays, the effect of <code>shallow-copy-all</code> is exactly the same as <code>shallow-copy</code>.</p><p>For arrays, the processing is as follows. A new result array is created, and its content is populated by decomposing the input array to a sequence of <b>value records</b> using the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-members"><code>array:members</code></a>. Each of these value records is processed by a call on <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> (using the current mode, and passing on the values of all template parameters); the result of the called template is expected to be a value record.</p><p>That is, the template rule is equivalent to the following, except that this does not show the propagation of template parameters:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:array use="?value"&gt;
  &lt;xsl:apply-templates select="array:members(.)" mode="#current"/&gt;
&lt;/xsl:array&gt;</pre></div><table class="ednote" caption="Editorial note"><tbody><tr><td style="text-align: left; vertical-align:top; width: 50%;"><b>Editorial note</b></td><td style="text-align: right; vertical-align:top; width: 50%;">&nbsp;</td></tr><tr style="text-align: left; vertical-align: top;"><td colspan="2">TODO: the use attribute is no more. Example need reworking.</td></tr></tbody></table><div class="note"><p class="prefix"><b>Note:</b></p><p>A <b>value record</b> is a single-entry map: it has a single key-value pair with the key <code>"value"</code>, the corresponding value being a member of the original array. The default processing for a value record, unless specified otherwise, is to apply templates to the value, as indicated by the rules that follow.</p></div><p>For maps, the processing is as follows:</p><ul><li><p>If the map contains two or more entries, then a new result map is created, and its content is populated by decomposing the input map using the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-map-entries"><code>map:entries</code></a> to produce a sequence of single-entry maps (each containing one key and one value), and then applying templates to this sequence, using the current mode, and passing on the values of all template parameters.</p></li><li><p>If the map contains a single entry <code>{ <var>K</var> : <var>V<sub>0</sub></var> }</code>, then a new single entry map <code>{ <var>K</var>: <var>V<sub>1</sub></var> }</code> is constructed in which <var>V<sub>1</sub></var> is the result of applying templates to <var>V<sub>0</sub></var> (using the current mode, and passing on the values of all template parameters).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This rule has the effect that if the input is a value record, the output will also be a value record.</p></div></li><li><p>If the map is empty, the result is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty map.</p></li></ul><p>In the first case, the template rule is equivalent to the following, except that this does not show the propagation of template parameters:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:map&gt;
  &lt;xsl:apply-templates select="map:entries(.)" mode="#current"/&gt;
&lt;/xsl:map&gt;</pre></div><p>In the second case, the template rule is equivalent to the following, except that this does not show the propagation of template parameters:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:map-entry key="map:keys(.)"&gt;
  &lt;xsl:apply-templates select="map:items(.)" mode="#current"/&gt;
&lt;/xsl:map-entry&gt;</pre></div><p>The reason there is a special rule for maps with one entry is to ensure that the process terminates.</p><p>The overall effect is best understood with an example.</p><div class="example"><div class="exampleHeader"><a id="d4e24004"></a><a id="d4e24008"></a>Example: Modified Identity Transformation of a JSON Document</div><p>The following stylesheet transforms a supplied JSON document by deleting all properties named <code>"Note"</code>, appearing at any level:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:stylesheet version="3.0"
     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
				  
&lt;xsl:mode on-no-match="shallow-copy-all"/&gt;

&lt;xsl:template match="record(Note)"&gt;
  &lt;!-- no action --&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div><p>Consider the following JSON input, converted to an array of maps by calling the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-parse-json"><code>parse-json</code></a>:</p><div class="exampleInner"><pre xml:space="preserve">[
  { "Title": "Computer Architecture",
    "Authors": [ "Enid Blyton", { "Note": "possibly misattributed" } ],
    "Category": "Computers",
    "Price": 42.60
  },
  { "Title": "Steppenwolf",
    "Authors": [ "Hermann Hesse" ],
    "Category": "Fiction",
    "Price": 12.00,
    "Note": "out of print"
  },
  { "Title": "How to Explore Outer Space with Binoculars",
    "Authors": [ "Bruce Betts", "Erica Colon" ],
    "Category": "Science",
    "Price": 10.40
  }
]</pre></div><p>The logic proceeds as follows:</p><ol class="enumar"><li><p>The outermost array is processed by applying templates to a sequence of value records, the first being in the form:</p><div class="exampleInner"><pre xml:space="preserve">{ "value": map: { "Title": ..., "Author": ..., ... }</pre></div><p>The result of applying templates to these value records is expected to comprise a new sequence of value records, which is used to construct the final output array.</p></li><li><p>Each of the value records is processed using the rule for single-entry maps. This rule produces a new value record by applying templates to the value, that is, to a map of the form <code>map: { "Title": ..., "Author": ..., ... }</code> representing a book.</p></li><li><p>Each of these books, being represented by a map with more than two entries, is processed by a template rule that splits the map into its multiple entries, each represented as a singleton map (a map with one key and one value). One of these single-entry maps, for example, would be <code>{"Title": "Steppenwolf"}</code>.</p></li><li><p>The default processing for a single-entry map of the form <code>{ "Title": "Steppenwolf" }</code> is to return the value unchanged. This is achieved by applying templates to the string <code>"Steppenwolf"</code>; the default template rule for strings returns the string unchanged.</p></li><li><p>When a single-entry map in the form <code>{ "Note": "out of print" }</code> is encountered, no output is produced, meaning that entry in the parent map is effectively dropped. This is because there is an explicit template rule with <code>match="record(Note)"</code> that matches such single-entry maps.</p></li><li><p>When a single-entry map in the form <code>"Authors": [ "Bruce Betts", "Erica Colon" ]</code> is encountered, a new single-entry map is produced; it has the same key (<code>"Authors"</code>), and a value obtained by applying templates to the array <code>[ "Bruce Betts", "Erica Colon" ]</code>. The default processing for an array, in which none of the constituents are matched by explicit template rules, ends up delivering a copy of the array.</p></li><li><p>When the single-entry map <code>"Authors": [ "Enid Blyton", { "Note": "possibly misattributed" } ]</code> is encountered, the recursive processing results in templates being applied to the map <code>{ "Note": "possibly misattributed" }</code>. This matches the template rule having <code>match="record(Note)"</code>, which returns no output, so the entry is effectively deleted.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The map entry is deleted, but the map itself remains, so the value becomes <code>"Authors": [ "Enid Blyton", map: {} ]</code>.</p></div></li></ol></div></div><div class="_diffs div3"><h4><a id="built-in-templates-deep-skip"></a>6.8.5 <a href="#built-in-templates-deep-skip" style="text-decoration: none">Built-in Templates: Deep Skip</a></h4><p>The effect of processing a tree using a <a title="mode" class="termref" href="#dt-mode">mode</a> that specifies <code>on-no-match="deep-skip"</code> is that where no explicit template rule is specified for an element, that element and all its descendants are ignored, and are not copied to the result tree.</p><p>The effect of choosing <code>on-no-match="deep-skip"</code> is as follows:</p><ul><li><p>The built-in rule for document nodes is equivalent to calling <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with no <code>select</code> attribute, and with the <code>mode</code> attribute set to <code>#current</code>. If the built-in rule was invoked with parameters, those parameters are passed on in the implicit <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p><p>In the case where there are no parameters, this is equivalent to the following rule:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:template match="document-node()" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;</pre></div></li><li><p>The built-in rule for all items other than document nodes (that is, for all other kinds of node, as well as atomic items and functions, including maps and and arrays) is to do nothing, that is, to return <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence (without applying templates to any children or ancestors).</p><p>This is equivalent to the following rule:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:template match="." mode="M"/&gt;</pre></div></li></ul></div><div class="_diffs div3"><h4><a id="built-in-templates-shallow-skip"></a>6.8.6 <a href="#built-in-templates-shallow-skip" style="text-decoration: none">Built-in Templates: Shallow Skip</a></h4><p>The effect of processing a tree using a <a title="mode" class="termref" href="#dt-mode">mode</a> that specifies <code>on-no-match="shallow-skip"</code> is to drop both the textual content and the markup from the result document, except where there is an explicit user-written <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> that dictates otherwise.</p><p>The built-in rule for document nodes and element nodes applies templates (in the current mode) first to the node’s attributes and then to its children. If the built-in rule was invoked with parameters, those parameters are passed on in the implicit <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instructions.</p><p>In the case where there are no parameters, this is equivalent to the following rule:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:template match="document-node()|element()" mode="M"&gt;
  &lt;xsl:apply-templates select="@*" mode="#current"/&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;</pre></div><p>The built-in template rule for all other kinds of node, and for atomic items and functions (including maps, but not arrays) is empty: that is, when the item is matched, the built-in template rule returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p><p>This is equivalent to the following rule:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:template match="." mode="M"/&gt;</pre></div><p>The built-in <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> for arrays (see <a href="#arrays"><i>22 Arrays</i></a>) is to apply templates to the members of the array. It is equivalent to invoking <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with the <code>select</code> attribute set to <code>?*</code> (which selects the members of the array), and with the <code>mode</code> attribute set to <code>#current</code>. If the built-in rule was invoked with parameters, those parameters are passed on in the implicit <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p><p>This is equivalent to the following in the case where there are no parameters:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:template match=".[. instance of array(*)]" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current" select="?*"/&gt;
&lt;/xsl:template&gt;</pre></div></div></div></div><div class="_diffs div1"><h2><a id="repetition"></a>7 <a href="#repetition" style="text-decoration: none">Repetition</a></h2><p>XSLT offers two constructs for processing each <span>entry in a collection</span>: <a href="#element-for-each"><code>xsl:for-each</code></a> and <a href="#element-iterate"><code>xsl:iterate</code></a>.</p><p>Both instructions can be used to process the items in a sequence, the elements in an array, or the entries in a map. Arrays and maps are processed by reducing them to a sequence of items, so in what follows, the terms <b>item</b> and <b>sequence</b> are used generically.</p><p>The main difference between the two constructs is that with <a href="#element-for-each"><code>xsl:for-each</code></a>, the processing applied to each item in the sequence is independent of the processing applied to any other item; this means that the items may be processed in any order or in parallel, though the order of the output sequence is well defined and corresponds to the order of the input (sorted if so requested). By contrast, with <a href="#element-iterate"><code>xsl:iterate</code></a>, the processing is explicitly sequential: while one item is being processed, values may be computed which are then available for use while the next item is being processed. This makes <a href="#element-iterate"><code>xsl:iterate</code></a> suitable for tasks such as creating a running total over a sequence of financial transactions.</p><p>A further difference is that <a href="#element-for-each"><code>xsl:for-each</code></a> permits sorting of the input sequence, while <a href="#element-iterate"><code>xsl:iterate</code></a> does not.</p><div class="_diffs div2"><h3><a id="for-each"></a>7.1 <a href="#for-each" style="text-decoration: none">The <code>xsl:for-each</code> instruction</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#xsl-if">next</a> | <a href="#apply-imports">previous</a>)</p><ol><li><p> The <a href="#element-for-each"><code>xsl:for-each</code></a> and <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instructions acquire an attribute <code>separator</code> that can be used to insert content between adjacent items. [This change was in the editor's draft adopted as a baseline when the WG commenced work.] <i>&nbsp;&nbsp;[&nbsp;&nbsp;1 January 2022]</i></p></li></ol></div><p class="element-syntax"><a id="element-for-each"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:for-each<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:for-each&gt;</code></p><p>The <a href="#element-for-each"><code>xsl:for-each</code></a> instruction processes each in a sequence of items, evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> within the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction once for each item in that sequence.</p><p> The <code>select</code> attribute is <span class="verb">required</span>; it contains an <a title="expression" class="termref" href="#dt-expression">expression</a> which is evaluated to produce a sequence, called the input sequence. If there is an <a href="#element-sort"><code>xsl:sort</code></a> element present (see <a href="#sorting"><i>13 Sorting</i></a>) the input sequence is sorted to produce a sorted sequence. Otherwise, the sorted sequence is the same as the input sequence.</p><p>The <a href="#element-for-each"><code>xsl:for-each</code></a> instruction contains a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is evaluated once for each item in the sorted sequence, with the <a title="focus" class="termref" href="#dt-focus">focus</a> set as follows:</p><ul><li><p>The <a title="context item" class="termref" href="#dt-context-item">context item</a> is the item being processed. </p></li><li><p>The <a title="context position" class="termref" href="#dt-context-position">context position</a> is the position of this item in the sorted sequence.</p></li><li><p>The <a title="context size" class="termref" href="#dt-context-size">context size</a> is the size of the sorted sequence (which is the same as the size of the input sequence).</p></li></ul><p> For each item in the input sequence, evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> produces a sequence of items (see <a href="#sequence-constructors"><i>5.7 Sequence Constructors</i></a>). These output sequences are concatenated; if item <var>Q</var> follows item <var>P</var> in the sorted sequence, then the result of evaluating the sequence constructor with <var>Q</var> as the context item is concatenated after the result of evaluating the sequence constructor with <var>P</var> as the context item. The result of the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction is the concatenated sequence of items.</p><div class="example"><div class="exampleHeader"><a id="d4e24869"></a>Example: Using <code>xsl:for-each</code> to process a sequence<a id="d4e24869"></a>Example: Using <code>xsl:for-each</code> to process a sequence</div><p>For example, given an XML document with this structure</p><div class="exampleInner"><pre xml:space="preserve">&lt;customers&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
&lt;/customers&gt;</pre></div><p>the following would create an HTML document containing a table with a row for each <code>customer</code> element</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Customers&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;table&gt;
	 &lt;tbody&gt;
	  &lt;xsl:for-each select="customers/customer"&gt;
	    &lt;tr&gt;
	      &lt;th&gt;
           &lt;xsl:apply-templates select="name"/&gt;
	      &lt;/th&gt;
	      &lt;xsl:for-each select="order"&gt;
           &lt;td&gt;
             &lt;xsl:apply-templates/&gt;
           &lt;/td&gt;
	      &lt;/xsl:for-each&gt;
	    &lt;/tr&gt;
	  &lt;/xsl:for-each&gt;
	&lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;</pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e24884"></a>Example: Using <code>xsl:for-each</code> to process an array<a id="d4e24884"></a>Example: Using <code>xsl:for-each</code> to process an array</div><p>Consider a JSON document of the form:</p><div class="exampleInner"><pre xml:space="preserve">[
  { "city": "London", "latitude": 51.5099, "longitude": -0.1181 },
  { "city": "Paris",  "latitude": 48.8647, "longitude": 2.3488 },
  { "city": "Berlin", "latitude": 52.5200, "longitude": 13.4049 }                  
]</pre></div><p>The following code processes this array to produce an XML representation of the same information. The cities are sorted by name:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:for-each select="json-doc('input.json')?*"&gt;
   &lt;xsl:sort select="?city"/&gt;
   &lt;city number="{position()}" 
         name="{?city}" 
         latitude="{?latitude}" 
         longitude="{?longitude}"/&gt;
&lt;/xsl:for-each&gt;</pre></div><p><span style="display: none;" class="delete_version">In this example it is possible to use the expression <code>$array?*</code> to convert an array to a sequence. This works because the members of the array are all single items. In the more general case (a member of the array might be an empty sequence, corresponding to the JSON value <code>null</code>, or it might be a sequence containing several items), <span>the function <code>array:members</code> can be used to deliver the contents of the array as a sequence of <em>value records</em>. This is illustrated in the next example.</span></span><span style="display: none;" class="add_version">In this example it is possible to use the expression <code>$array?*</code> to convert an array to a sequence. This works because the members of the array are all single items. In the more general case (a member of the array might be the empty sequence, corresponding to the JSON value <code>null</code>, or it might be a sequence containing several items), <span>the function <code>array:members</code> can be used to deliver the contents of the array as a sequence of <em>value records</em>. This is illustrated in the next example.</span></span><span class="modify_version">In this example it is possible to use the expression <code>$array?*</code> to convert an array to a sequence. This works because the members of the array are all single items. In the more general case (a member of the array might be <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, corresponding to the JSON value <code>null</code>, or it might be a sequence containing several items), <span>the function <code>array:members</code> can be used to deliver the contents of the array as a sequence of <em>value records</em>. This is illustrated in the next example.</span></span></p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e24910"></a>Example: Using <code>xsl:for-each</code> to process an array containing nulls<a id="d4e24910"></a>Example: Using <code>xsl:for-each</code> to process an array containing nulls</div><p>Consider a JSON document of the form:</p><div class="exampleInner"><pre xml:space="preserve">[
   { "city": "London", "data": [12.3, 15.6, null, 18.2] },
   { "city": "Paris",  "data": [7.9, 19.1, 23.0, null] },
   { "city": "Berlin", "data": [5.6, null, 14.6, 9.5] }                  
]</pre></div><p>The requirement is to convert this to the following XML:</p><div class="exampleInner"><pre xml:space="preserve">&lt;cities&gt;
  &lt;city name="London" Q1="12.3" Q2="15.6" Q3="" Q4="18.2"/&gt;
  &lt;city name="Paris" Q1="7.9" Q2="19.1" Q3="23.0" Q4=""/&gt;
  &lt;city name="Berlin" Q1="5.6" Q2="" Q3="14.6" Q4="9.5"/&gt;
&lt;/cities&gt;</pre></div><p>The following code achieves this transformation:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:for-each select="json-doc('input.json')?*"&gt;
   &lt;city name="{?city}"&gt;
     &lt;xsl:for-each select="array:members(?data)"&gt;
       &lt;xsl:attribute name="Q{position()}" select="?value"/&gt;
     &lt;/xsl:for-each&gt;
   &lt;/city&gt;  
&lt;/xsl:for-each&gt;</pre></div><p><span style="display: none;" class="delete_version">In this example the expression <code>$array?*</code> cannot be used on the inner arrays because JSON nulls (which translate to an empty sequence in XDM) would be lost. Instead the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-members"><code>array:members</code></a> is used to create a sequence of value records: a non-null entry is represented by a value such as <code>{ 'value': 12.3 }</code>, while a null entry would be <code>{ 'value': () }</code>.</span><span style="display: none;" class="add_version">In this example the expression <code>$array?*</code> cannot be used on the inner arrays because JSON nulls (which translate to the empty sequence in XDM) would be lost. Instead the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-members"><code>array:members</code></a> is used to create a sequence of value records: a non-null entry is represented by a value such as <code>{ 'value': 12.3 }</code>, while a null entry would be <code>{ 'value': () }</code>.</span><span class="modify_version">In this example the expression <code>$array?*</code> cannot be used on the inner arrays because JSON nulls (which translate to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence in XDM) would be lost. Instead the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-members"><code>array:members</code></a> is used to create a sequence of value records: a non-null entry is represented by a value such as <code>{ 'value': 12.3 }</code>, while a null entry would be <code>{ 'value': () }</code>.</span></p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e24938"></a>Example: Using <code>xsl:for-each</code> to process a map<a id="d4e24938"></a>Example: Using <code>xsl:for-each</code> to process a map</div><p>Consider a JSON document of the form:</p><div class="exampleInner"><pre xml:space="preserve">{
  "London": { "latitude": 51.5099, "longitude": -0.1181 },
  "Paris":  { "latitude": 48.8647, "longitude": 2.3488 },
  "Berlin": { "latitude": 52.5200, "longitude": 13.4049 }                  
}</pre></div><p>The following code processes this map to produce an XML representation of the same information. The cities are sorted by name:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:for-each select="map:pairs(json-doc('input.json'))"&gt;
   &lt;xsl:sort select="?key"/&gt;
   &lt;city number="{position()}" 
         name="{?key}" 
         latitude="{?value?latitude}" 
         longitude="{?value?longitude}"/&gt;
&lt;/xsl:for-each&gt;</pre></div><p>In this example the map is decomposed to a sequence of key-value pairs, each represented as a map with two entries, <code>"key"</code> and <code>"value"</code>, which can be accessed using the lookup expressions <code>?key</code> and <code>?value</code>.</p></div></div><div class="_diffs div2"><h3><a id="iterate"></a>7.2 <a href="#iterate" style="text-decoration: none">The <code>xsl:iterate</code> Instruction</a></h3><p>The <code>xsl:iterate</code> instruction processes the items in a sequence in order; unlike <code>xsl:for-each</code>, the result of processing one item can affect the way that subsequent items are processed.</p><p class="element-syntax"><a id="element-iterate"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:iterate<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-param">xsl:param</a>*, <a href="#element-on-completion">xsl:on-completion</a>?, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:iterate&gt;</code></p><p class="element-syntax"><a id="element-next-iteration"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:next-iteration&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-with-param">xsl:with-param</a>*) --&gt;<br>&lt;/xsl:next-iteration&gt;</code></p><p class="element-syntax"><a id="element-break"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:break<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:break&gt;</code></p><p class="element-syntax"><a id="element-on-completion"></a><code>&lt;xsl:on-completion<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:on-completion&gt;</code></p><div class="example"><div class="exampleHeader"><a id="d4e25040"></a>Example: Processing an array using <code>xsl:iterate</code><a id="d4e25040"></a>Example: Processing an array using <code>xsl:iterate</code></div><p>Consider the following JSON document representing transactions in a bank account:</p><div class="exampleInner"><pre xml:space="preserve">[
  { "date": "2008-09-01", credit: 12.00 },
  { "date": "2008-09-01", credit: 8.00 },
  { "date": "2008-09-02", debit: 2.00 },
  { "date": "2008-09-02", credit: 12.00 }
]</pre></div><p>The following code converts this to an XML representation that includes a running balance:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:iterate select="json-doc('account.json') =&gt; array:members()"&gt;
   &lt;xsl:param name="balance" as="xs:decimal" select="0"/&gt;               
   &lt;xsl:variable name="delta" select="?value?credit otherwise -?value?debit"/&gt;               
   &lt;entry date="{ ?value?date }"
          amount="{ $delta }"
          balance="{ $balance + $delta }"/&gt;
   &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="balance" select="$balance + $delta"/&gt;
   &lt;/xsl:next-iteration&gt;   
&lt;/xsl:iterate&gt;</pre></div><p>Using <code>array:members()</code> in this way makes it possible to process any array, including one whose members are arbitrary sequences rather than single items. In this particular case, if it is known that the JSON array will not contain any <code>null</code> entries, or if any <code>null</code> entries are to be ignored, it becomes possible to simplify the code as follows:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:iterate select="json-doc('account.json')?*"&gt;
   &lt;xsl:param name="balance" as="xs:decimal" select="0"/&gt;               
   &lt;xsl:variable name="delta" select="?credit otherwise -?debit"/&gt;               
   &lt;entry date="{ ?date }"
          amount="{ $delta }"
          balance="{ $balance + $delta }"/&gt;
   &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="balance" select="$balance + $delta"/&gt;
   &lt;/xsl:next-iteration&gt;   
&lt;/xsl:iterate&gt;</pre></div></div><p>The <code>select</code> attribute contains an <a title="expression" class="termref" href="#dt-expression">expression</a> which is evaluated to produce a sequence, called the input sequence.</p><p>The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained in the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction is evaluated once for each item in the input sequence, in order, or until the loop exits by evaluating an <a href="#element-break"><code>xsl:break</code></a> instruction, whichever is earlier. Within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the body of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction, the <a title="context item" class="termref" href="#dt-context-item">context item</a> is set to each item from the value of the <code>select</code> expression in turn; the <a title="context position" class="termref" href="#dt-context-position">context position</a> reflects the position of this item in the input sequence, and the <a title="context size" class="termref" href="#dt-context-size">context size</a> is the number of items in the input sequence (which may be greater than the number of iterations, if the loop exits prematurely using <a href="#element-break"><code>xsl:break</code></a>).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If <a href="#element-iterate"><code>xsl:iterate</code></a> is used in conjunction with <a href="#element-source-document"><code>xsl:source-document</code></a> to achieve streaming, calls on the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-last"><code>last</code></a> will be disallowed. </p></div><p><span style="display: none;" class="delete_version">The <a href="#element-break"><code>xsl:break</code></a> and <a href="#element-on-completion"><code>xsl:on-completion</code></a> elements may have either a <code>select</code> attribute or a non-empty contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> but not both. The effect of the element in both cases is obtained by evaluating the <code>select</code> expression if present or the contained sequence constructor otherwise; if neither is present, the value is an empty sequence.</span><span style="display: none;" class="add_version">The <a href="#element-break"><code>xsl:break</code></a> and <a href="#element-on-completion"><code>xsl:on-completion</code></a> elements may have either a <code>select</code> attribute or a non-empty contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> but not both. The effect of the element in both cases is obtained by evaluating the <code>select</code> expression if present or the contained sequence constructor otherwise; if neither is present, the value is the empty sequence.</span><span class="modify_version">The <a href="#element-break"><code>xsl:break</code></a> and <a href="#element-on-completion"><code>xsl:on-completion</code></a> elements may have either a <code>select</code> attribute or a non-empty contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> but not both. The effect of the element in both cases is obtained by evaluating the <code>select</code> expression if present or the contained sequence constructor otherwise; if neither is present, the value is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">The <a href="#element-on-completion"><code>xsl:on-completion</code></a> element appears before other children of <a href="#element-iterate"><code>xsl:iterate</code></a> to ensure that variables declared in the sequence constructor are not in scope within <a href="#element-on-completion"><code>xsl:on-completion</code></a>, since such variables do not have a defined value within <a href="#element-on-completion"><code>xsl:on-completion</code></a> especially in the case where the value of the <code>select</code> attribute is an empty sequence.</span><span style="display: none;" class="add_version">The <a href="#element-on-completion"><code>xsl:on-completion</code></a> element appears before other children of <a href="#element-iterate"><code>xsl:iterate</code></a> to ensure that variables declared in the sequence constructor are not in scope within <a href="#element-on-completion"><code>xsl:on-completion</code></a>, since such variables do not have a defined value within <a href="#element-on-completion"><code>xsl:on-completion</code></a> especially in the case where the value of the <code>select</code> attribute is the empty sequence.</span><span class="modify_version">The <a href="#element-on-completion"><code>xsl:on-completion</code></a> element appears before other children of <a href="#element-iterate"><code>xsl:iterate</code></a> to ensure that variables declared in the sequence constructor are not in scope within <a href="#element-on-completion"><code>xsl:on-completion</code></a>, since such variables do not have a defined value within <a href="#element-on-completion"><code>xsl:on-completion</code></a> especially in the case where the value of the <code>select</code> attribute is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></div><p>The effect of <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> is to cause the iteration to continue by processing the next item in the input sequence, potentially with different values for the iteration parameters. The effect of <a href="#element-break"><code>xsl:break</code></a> is to cause the iteration to finish, whether or not all the items in the input sequence have been processed. In both cases the affected iteration is the one controlled by the innermost ancestor <a href="#element-iterate"><code>xsl:iterate</code></a> element.</p><p>The instructions <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> and <a href="#element-break"><code>xsl:break</code></a> are allowed only as descendants of an <a href="#element-iterate"><code>xsl:iterate</code></a> instruction, and only in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> forming the body of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction. </p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-tail-position" title="tail position"></a>An <a title="instruction" class="termref" href="#dt-instruction">instruction</a><var>J</var> is in a <b>tail position</b> within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a><var>SC</var> if it satisfies one of the following conditions:</p><ul><li><p><var>J</var> is the last instruction in <var>SC</var>, ignoring any <a href="#element-fallback"><code>xsl:fallback</code></a> instructions.</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-if"><code>xsl:if</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch of an <a href="#element-choose"><code>xsl:choose</code></a><span>or <a href="#element-switch"><code>xsl:switch</code></a></span> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-try"><code>xsl:try</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var> (that is, it is immediately followed by an <a href="#element-catch"><code>xsl:catch</code></a> element, ignoring any <a href="#element-fallback"><code>xsl:fallback</code></a> elements).</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-catch"><code>xsl:catch</code></a> element within an <a href="#element-try"><code>xsl:try</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p></li></ul><p>]</p><p><a id="err-XTSE3120"><span class="error">[ERR XTSE3120] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-break"><code>xsl:break</code></a> or <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> element appears other than in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> forming the body of an <a href="#element-iterate"><code>xsl:iterate</code></a> instruction. </p><p><a id="err-XTSE3125"><span class="error">[ERR XTSE3125] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of <a href="#element-break"><code>xsl:break</code></a> or <a href="#element-on-completion"><code>xsl:on-completion</code></a> is present and the instruction has children. </p><p><a id="err-XTSE3130"><span class="error">[ERR XTSE3130] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>name</code> attribute of an <a href="#element-with-param"><code>xsl:with-param</code></a> child of an <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> element does not match the <code>name</code> attribute of an <a href="#element-param"><code>xsl:param</code></a> child of the innermost containing <a href="#element-iterate"><code>xsl:iterate</code></a> instruction. </p><p>Parameter names in <a href="#element-with-param"><code>xsl:with-param</code></a> must be unique: <span class="error">[see <a href="#err-XTSE0670">ERR XTSE0670</a>]</span>.</p><p>The result of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction is the concatenation of the sequences that result from the repeated evaluation of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, followed by the sequence that results from evaluating the <a href="#element-break"><code>xsl:break</code></a> or <a href="#element-on-completion"><code>xsl:on-completion</code></a> element if any.</p><p>Any <a href="#element-param"><code>xsl:param</code></a> element that appears as a child of <a href="#element-iterate"><code>xsl:iterate</code></a> declares a parameter whose value may vary from one iteration to the next. The initial value of the parameter is the value obtained according to the rules given in <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>. The dynamic context for evaluating the initial value of an <a href="#element-param"><code>xsl:param</code></a> element is the same as the dynamic context for evaluating the <code>select</code> expression of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction (the context item is thus <em>not</em> the first item in the input sequence).</p><p>On the first iteration a parameter always takes its initial value (which may depend on variables or other aspects of the dynamic context). Subsequently:</p><ul><li><p>If an <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction is evaluated, then parameter values for processing the next item in the input sequence can be set in the <a href="#element-with-param"><code>xsl:with-param</code></a> children of that instruction; in the absence of an <a href="#element-with-param"><code>xsl:with-param</code></a> element that names a particular parameter, that parameter will retain its value from the previous iteration.</p></li><li><p>If an <a href="#element-break"><code>xsl:break</code></a> instruction is evaluated, no further items in the input sequence are processed.</p></li><li><p>If neither an <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> nor an <a href="#element-break"><code>xsl:break</code></a> instruction is evaluated, then the next item in the input sequence is processed using parameter values that are unchanged from the previous iteration.</p></li></ul><p>The <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction contributes nothing to the result sequence (technically, it returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence). The instruction supplies parameter values for the next iteration, which are evaluated according to the rules given in <a href="#with-param"><i>9.10 Setting Parameter Values</i></a>; if there are no further items in the input sequence then it supplies parameter values for use while evaluating the body of the <a href="#element-on-completion"><code>xsl:on-completion</code></a> element if any.</p><p>The <a href="#element-break"><code>xsl:break</code></a> instruction indicates that the iteration should terminate without processing any remaining items from the input sequence. The <code>select</code> expression or contained sequence constructor is evaluated using the same context item, position, and size as the <a href="#element-break"><code>xsl:break</code></a> instruction itself, and the result is appended to the result of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction as a whole.</p><p>If neither an <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> nor an <a href="#element-break"><code>xsl:break</code></a> instruction is evaluated, the next item in the input sequence is processed with parameter values unchanged from the previous iteration; if there are no further items in the input sequence, the iteration terminates.</p><p>The optional <a href="#element-on-completion"><code>xsl:on-completion</code></a> element (which is not technically an <a title="instruction" class="termref" href="#dt-instruction">instruction</a> and is not technically part of the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>) is evaluated when the input sequence is exhausted. It is not evaluated if the evaluation is terminated using <a href="#element-break"><code>xsl:break</code></a>. During evaluation of its <code>select</code> expression or sequence constructor the context item, position, and size are <a title="absent" class="termref" href="#dt-absent">absent</a> (that is, any reference to these values is an error). However, the values of the parameters to <a href="#element-iterate"><code>xsl:iterate</code></a> are available, and take the values supplied by the <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction evaluated while processing the last item in the sequence.</p><p><span style="display: none;" class="delete_version">If the input sequence is empty, then the result of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction is the result of evaluating the <code>select</code> attribute or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> forming the body of the <a href="#element-on-completion"><code>xsl:on-completion</code></a> element, using the initial values of the <a href="#element-param"><code>xsl:param</code></a> elements. If there is no <a href="#element-on-completion"><code>xsl:on-completion</code></a> element, the result is an empty sequence.</span><span style="display: none;" class="add_version">If the input sequence is empty, then the result of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction is the result of evaluating the <code>select</code> attribute or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> forming the body of the <a href="#element-on-completion"><code>xsl:on-completion</code></a> element, using the initial values of the <a href="#element-param"><code>xsl:param</code></a> elements. If there is no <a href="#element-on-completion"><code>xsl:on-completion</code></a> element, the result is the empty sequence.</span><span class="modify_version">If the input sequence is empty, then the result of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction is the result of evaluating the <code>select</code> attribute or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> forming the body of the <a href="#element-on-completion"><code>xsl:on-completion</code></a> element, using the initial values of the <a href="#element-param"><code>xsl:param</code></a> elements. If there is no <a href="#element-on-completion"><code>xsl:on-completion</code></a> element, the result is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>Conceptually, <a href="#element-iterate"><code>xsl:iterate</code></a> behaves like a tail-recursive function. The <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction then represents the recursive call, supplying the tail of the input sequence as an implicit parameter. There are two main reasons for providing the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction. One is that many XSLT users find writing recursive functions to be a difficult skill, and this construct promises to be easier to learn. The other is that recursive function calls are difficult for an optimizer to analyze. Because <a href="#element-iterate"><code>xsl:iterate</code></a> is more constrained than a general-purpose head-tail recursive function, it should be more amenable to optimization. In particular, when the instruction is used in conjunction with <a href="#element-source-document"><code>xsl:source-document</code></a>, it is designed to make it easy for the implementation to use streaming techniques, processing the nodes in an input document sequentially as they are read, without building the entire document tree in memory.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>One of the motivations for introducing the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction was to enable information to be retained while processing a streamed sequence of sibling nodes. For examples illustrating this, see <a href="../xslt-streaming-40/#streaming-with-xsl-iterate">6 Streaming with</a><sup><small>SG</small></sup>.</p></div></div></div><div class="_diffs div1"><h2><a id="conditionals"></a>8 <a href="#conditionals" style="text-decoration: none">Conditional Processing</a></h2><p>There are several instructions in XSLT that support conditional processing: <a href="#element-if"><code>xsl:if</code></a>, <a href="#element-choose"><code>xsl:choose</code></a><span>, and <a href="#element-switch"><code>xsl:switch</code></a></span>. The <a href="#element-if"><code>xsl:if</code></a> instruction provides simple <span>if-then-else</span> conditionality; the <a href="#element-choose"><code>xsl:choose</code></a> instruction supports selection of one choice when there are several possibilities, <span>and <a href="#element-switch"><code>xsl:switch</code></a> allows a branch to be selected based on the value of a given expression.</span></p><p>XSLT 3.0 also supports <a href="#element-try"><code>xsl:try</code></a> and <a href="#element-catch"><code>xsl:catch</code></a> which define conditional processing to handle <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>XSLT offers a number of ways of expressing conditional logic.</p><p>XSLT 1.0 offered the <a href="#element-if"><code>xsl:if</code></a> instruction for cases where output was to be produced only if a condition was true, with <a href="#element-choose"><code>xsl:choose</code></a> available for multi-way branches where different output was to be produced under different input conditions. In addition, of course, XSLT 1.0 also offered the option of rule-based processing using templates and match patterns.</p><p>XSLT 2.0 added the XPath conditional expression providing two-way branches for use at a finer-grained level where <a href="#element-choose"><code>xsl:choose</code></a> could be excessively verbose: it allowed constructs such as <code>&lt;xsl:value-of select="if ($x) then 'red' else 'green'/&gt;</code> to be reduced from eight lines of code to one.</p><p>XSLT 4.0 introduces the <code>then</code> and <code>else</code> attributes for <a href="#element-if"><code>xsl:if</code></a>, which are particularly useful in contexts such as the body of an <a href="#element-function"><code>xsl:function</code></a> declaration where the alternative results are conveniently evaluated using XPath expressions rather than XSLT instructions: for example a recursive function might have as its body the instruction <code>&lt;xsl:if test="empty($seq)" then="1" else="head($seq) * my:f(tail($seq))"/&gt;</code>. The <code>select</code> attribute of <a href="#element-when"><code>xsl:when</code></a> and <a href="#element-otherwise"><code>xsl:otherwise</code></a> is introduced for similar reasons: XSLT instructions are most useful when contructing node trees, whereas XPath expressions are more convenient when computing atomic items. Again, the main contribution of these enhancements is to reduce visual clutter, making the code more concise and more easily readable.</p><p>The <a href="#element-switch"><code>xsl:switch</code></a> instruction is introduced in XSLT 4.0 as an alternative to <a href="#element-choose"><code>xsl:choose</code></a> for the common use case where the conditions test for multiple different values of some common expression. By avoiding repetition of the common expression whose value is being tested, the logic becomes self-explanatory both to the human reader of the code and to an optimizing compiler, making it easier to generate efficient branching code.</p></div><div class="_diffs div2"><h3><a id="xsl-if"></a>8.1 <a href="#xsl-if" style="text-decoration: none">Conditional Processing with <code>xsl:if</code></a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#xsl-choose">next</a> | <a href="#for-each">previous</a>)</p><ol><li><p> The <a href="#element-if"><code>xsl:if</code></a> instruction now allows <code>then</code> and <code>else</code> attributes. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/167">167</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/237">237</a>&nbsp;25 November 2022]</i></p></li></ol></div><p class="element-syntax"><a id="element-if"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:if<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;then? = <var>expression</var><br>&nbsp;&nbsp;else? = <var>expression</var>〔()〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:if&gt;</code></p><p>The <a href="#element-if"><code>xsl:if</code></a> element has a mandatory <code>test</code> attribute, whose value is an <a title="expression" class="termref" href="#dt-expression">expression</a>. The content is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><p>If the <a href="#element-if"><code>xsl:if</code></a> element has a <code>then</code> attribute, then it <span class="verb">must</span> have no children. That is, the <code>then</code> attribute and the contained sequence constructor are mutually exclusive.</p><p>The result of the <a href="#element-if"><code>xsl:if</code></a> instruction depends on the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-ebv">effective boolean value</a><sup><small>XP</small></sup> of the expression in the <code>test</code> attribute. The rules for determining the effective boolean value of an expression are given in <a href="#xpath-40">[XPath 4.0]</a>: they are the same as the rules used for XPath conditional expressions.</p><p>If the effective boolean value of the <a title="expression" class="termref" href="#dt-expression">expression</a> is <code>true</code>, then:</p><ul><li><p>If there is a <code>then</code> attribute, the expression in the <code>then</code> attribute is evaluated, and the resulting value is returned as the result of the <a href="#element-if"><code>xsl:if</code></a> instruction.</p></li><li><p>If there is a non-empty sequence constructor, it is evaluated and the resulting value is returned as the result of the <a href="#element-if"><code>xsl:if</code></a> instruction.</p></li><li><p>Otherwise, the result of the <a href="#element-if"><code>xsl:if</code></a> instruction is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p></li></ul><p>If the effective boolean value of the <code>test</code><a title="expression" class="termref" href="#dt-expression">expression</a> is <code>false</code>, then:</p><ul><li><p>If there is an <code>else</code> attribute, the expression in the <code>else</code> attribute is evaluated, and the resulting value is returned as the result of the <a href="#element-if"><code>xsl:if</code></a> instruction.</p></li><li><p>Otherwise, the result of the <a href="#element-if"><code>xsl:if</code></a> instruction is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p></li></ul><p>If the <code>test</code> expression has no effective boolean value (for example, if it is a sequence of several integers, or a map), then a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs. (See <a href="https://www.w3.org/TR/xpath-functions/#ERRFORG0006" title="FORG0006"><span class="error">[ERR FORG0006] </span></a><sup><small>FO</small></sup>.)</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The semantics of the <a href="#element-if"><code>xsl:if</code></a> instruction are essentially equivalent to the semantics of the conditional expression in XPath: the construct <code>&lt;xsl:if test="C" then="X" else="Y"/&gt;</code> can equivalently be written <code>&lt;xsl:sequence select="if (C) then X else Y"/&gt;</code>. The same effect can also be achieved by writing <code>&lt;xsl:choose&gt;&lt;xsl:when test="C" select="X"/&gt;&lt;xsl:otherwise select="Y"/&gt;&lt;/xsl:choose&gt;.</code> The choice of which of these constructs to use is a largely matter of personal style. </p></div><div class="example"><div class="exampleHeader"><a id="d4e25686"></a>Example: Using <code>xsl:if</code> to insert separators<a id="d4e25686"></a>Example: Using <code>xsl:if</code> to insert separators</div><p>In the following example, the names in a group of names are formatted as a comma separated list:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:template match="namelist/name"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:if test="not(position()=last())"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;</pre></div><p>This adds a comma after every item except the last. This can also be expressed as:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:template match="namelist/name"&gt;
  &lt;xsl:if test="not(position()=1)"&gt;, &lt;/xsl:if&gt;
  &lt;xsl:apply-templates/&gt; 
&lt;/xsl:template&gt;</pre></div><p>which inserts a comma before every item except the first. (This formulation might be more efficient, since determining whether an item is the last may involve look-ahead.)</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e25700"></a>Example: Using <code>xsl:if</code> as the body of a function<a id="d4e25700"></a>Example: Using <code>xsl:if</code> as the body of a function</div><p>The following example shows the use of <a href="#element-if"><code>xsl:if</code></a> to deliver the result of a recursive function:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:function name="f:product" as="xs:double"&gt;
   &lt;xsl:param name="in" as="xs:double*"/&gt;
   &lt;xsl:if test="empty($in)" then="1e0" else="head($in) * f:product(tail($in))"/&gt;
&lt;/xsl:function&gt;</pre></div></div></div><div class="_diffs div2"><h3><a id="xsl-choose"></a>8.2 <a href="#xsl-choose" style="text-decoration: none">Conditional Processing with <code>xsl:choose</code></a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#xsl-switch">next</a> | <a href="#xsl-if">previous</a>)</p><ol><li><p> In <a href="#element-choose"><code>xsl:choose</code></a>, the <a href="#element-when"><code>xsl:when</code></a> and <code>xsl:otherwise</code> elements can take a <code>select</code> attribute in place of a sequence constructor. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/167">167</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/237">237</a>&nbsp;25 November 2022]</i></p></li></ol></div><p class="element-syntax"><a id="element-choose"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:choose&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-when">xsl:when</a>+, <a href="#element-otherwise">xsl:otherwise</a>?) --&gt;<br>&lt;/xsl:choose&gt;</code></p><p class="element-syntax"><a id="element-when"></a><code>&lt;xsl:when<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:when&gt;</code></p><p class="element-syntax"><a id="element-otherwise"></a><code>&lt;xsl:otherwise<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:otherwise&gt;</code></p><p>The <a href="#element-choose"><code>xsl:choose</code></a> element selects one among a number of possible alternatives. It consists of a sequence of one or more <a href="#element-when"><code>xsl:when</code></a> elements followed by an optional <a href="#element-otherwise"><code>xsl:otherwise</code></a> element. Each <a href="#element-when"><code>xsl:when</code></a> element has <span>an</span> attribute, <code>test</code>, which specifies an <a title="expression" class="termref" href="#dt-expression">expression</a> used as a condition.</p><p><span style="display: none;" class="delete_version">The effective value of an <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch may be supplied using either a <code>select</code> attribute or a contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. These are mutually exclusive: if the <code>select</code> attribute is present then the sequence constructor must be empty, and if the sequence constructor is non-empty then the <code>select</code> attribute must be absent <span><span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span></span>. If the <code>select</code> attribute is absent and the sequence constructor is empty, then the effective value is an empty sequence.</span><span style="display: none;" class="add_version">The effective value of an <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch may be supplied using either a <code>select</code> attribute or a contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. These are mutually exclusive: if the <code>select</code> attribute is present then the sequence constructor must be empty, and if the sequence constructor is non-empty then the <code>select</code> attribute must be absent <span><span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span></span>. If the <code>select</code> attribute is absent and the sequence constructor is empty, then the effective value is the empty sequence.</span><span class="modify_version">The effective value of an <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch may be supplied using either a <code>select</code> attribute or a contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. These are mutually exclusive: if the <code>select</code> attribute is present then the sequence constructor must be empty, and if the sequence constructor is non-empty then the <code>select</code> attribute must be absent <span><span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span></span>. If the <code>select</code> attribute is absent and the sequence constructor is empty, then the effective value is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p><p>When an <a href="#element-choose"><code>xsl:choose</code></a> element is processed, each of the <a href="#element-when"><code>xsl:when</code></a> elements is tested in turn (that is, in the order that the elements appear in the stylesheet), until one of the <a href="#element-when"><code>xsl:when</code></a> elements is satisfied. If none of the <a href="#element-when"><code>xsl:when</code></a> elements is satisfied, then the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is considered, as described below.</p><p>An <a href="#element-when"><code>xsl:when</code></a> element is satisfied if the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-ebv">effective boolean value</a><sup><small>XP</small></sup> of the <a title="expression" class="termref" href="#dt-expression">expression</a> in its <code>test</code> attribute is <code>true</code>. The rules for determining the effective boolean value of an expression are given in <a href="#xpath-40">[XPath 4.0]</a>: they are the same as the rules used for XPath conditional expressions.</p><p><span style="display: none;" class="delete_version">The first, and only the first, <a href="#element-when"><code>xsl:when</code></a> element that is satisfied is evaluated, and the resulting sequence <span>(that is, the result of evaluating its <code>select</code> attribute or contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> as appropriate)</span> is returned as the result of the <a href="#element-choose"><code>xsl:choose</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, the content of the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is evaluated, and the resulting sequence is returned as the result of the <a href="#element-choose"><code>xsl:choose</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, and no <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is present, the result of the <a href="#element-choose"><code>xsl:choose</code></a> instruction is an empty sequence.</span><span style="display: none;" class="add_version">The first, and only the first, <a href="#element-when"><code>xsl:when</code></a> element that is satisfied is evaluated, and the resulting sequence <span>(that is, the result of evaluating its <code>select</code> attribute or contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> as appropriate)</span> is returned as the result of the <a href="#element-choose"><code>xsl:choose</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, the content of the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is evaluated, and the resulting sequence is returned as the result of the <a href="#element-choose"><code>xsl:choose</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, and no <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is present, the result of the <a href="#element-choose"><code>xsl:choose</code></a> instruction is the empty sequence.</span><span class="modify_version">The first, and only the first, <a href="#element-when"><code>xsl:when</code></a> element that is satisfied is evaluated, and the resulting sequence <span>(that is, the result of evaluating its <code>select</code> attribute or contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> as appropriate)</span> is returned as the result of the <a href="#element-choose"><code>xsl:choose</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, the content of the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is evaluated, and the resulting sequence is returned as the result of the <a href="#element-choose"><code>xsl:choose</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, and no <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is present, the result of the <a href="#element-choose"><code>xsl:choose</code></a> instruction is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p><p><span>The <code>select</code> expressions and sequence constructors of <a href="#element-when"><code>xsl:when</code></a> and <a href="#element-otherwise"><code>xsl:otherwise</code></a> instructions after the selected one are not evaluated.</span> The <code>test</code> expressions for <a href="#element-when"><code>xsl:when</code></a> instructions after the selected one are not evaluated.</p><div class="example"><div class="exampleHeader"><a id="d4e25871"></a>Example: Using <code>xsl:choose</code> for formatting a numbered list <a id="d4e25871"></a>Example: Using <code>xsl:choose</code> for formatting a numbered list </div><p>The following example enumerates items in an ordered list using arabic numerals, letters, or roman numerals depending on the depth to which the ordered lists are nested.</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:template match="orderedlist/listitem"&gt;
  &lt;fo:list-item indent-start='2pi'&gt;
    &lt;fo:list-item-label&gt;
      &lt;xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test='$level=1'&gt;
          &lt;xsl:number format="i"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:when test='$level=2'&gt;
          &lt;xsl:number format="a"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:number format="1"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;/fo:list-item-label&gt;
    &lt;fo:list-item-body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/fo:list-item-body&gt;
  &lt;/fo:list-item&gt;
&lt;/xsl:template&gt;</pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e25879"></a>Example: Using the <code>select</code> attribute of <code>xsl:when</code> and <code>xsl:otherwise</code><a id="d4e25879"></a>Example: Using the <code>select</code> attribute of <code>xsl:when</code> and <code>xsl:otherwise</code></div><p>The following example is equivalent to the one above:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:template match="orderedlist/listitem"&gt;
  &lt;fo:list-item indent-start='2pi'&gt;
    &lt;fo:list-item-label&gt;
      &lt;xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/&gt;
      &lt;xsl:variable name="format" as="xs:string"&gt;
        &lt;xsl:choose&gt;
          &lt;xsl:when test='$level=1' select="'i'"/&gt;
          &lt;xsl:when test='$level=2' select="'a'"/&gt;
          &lt;xsl:otherwise select="'1'"/&gt;
        &lt;/xsl:choose&gt;
      &lt;/xsl:variable&gt;  
      &lt;xsl:number format="{ $format }"/&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;/fo:list-item-label&gt;
    &lt;fo:list-item-body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/fo:list-item-body&gt;
  &lt;/fo:list-item&gt;
&lt;/xsl:template&gt;</pre></div></div></div><div class="_diffs div2"><h3><a id="xsl-switch"></a>8.3 <a href="#xsl-switch" style="text-decoration: none">Conditional Processing with <code>xsl:switch</code></a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#try-catch">next</a> | <a href="#xsl-choose">previous</a>)</p><ol><li><p> A new <a href="#element-switch"><code>xsl:switch</code></a> instruction is introduced. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/167">167</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/237">237</a>&nbsp;25 November 2022]</i></p></li></ol></div><p class="element-syntax"><a id="element-switch"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:switch<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-when">xsl:when</a>+, <a href="#element-otherwise">xsl:otherwise</a>?, <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br>&lt;/xsl:switch&gt;</code></p><p class="element-syntax"><a id="element-when"></a><code>&lt;xsl:when<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:when&gt;</code></p><p class="element-syntax"><a id="element-otherwise"></a><code>&lt;xsl:otherwise<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:otherwise&gt;</code></p><p>The <a href="#element-switch"><code>xsl:switch</code></a> element selects one among a number of possible alternatives. The <code>select</code> attribute of the <a href="#element-switch"><code>xsl:switch</code></a> element is evaluated to obtain an atomic item, which is compared with the values given by the <code>test</code> attributes of the <a href="#element-when"><code>xsl:when</code></a> elements, in turn.</p><p>The content of the <a href="#element-switch"><code>xsl:switch</code></a> element consists of a sequence of one or more <a href="#element-when"><code>xsl:when</code></a> elements followed by an optional <a href="#element-otherwise"><code>xsl:otherwise</code></a> element. Each <a href="#element-when"><code>xsl:when</code></a> element has <span>an</span> attribute, <code>test</code>, which contains an <a title="expression" class="termref" href="#dt-expression">expression</a>.</p><p><span style="display: none;" class="delete_version">The result of an <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch may be supplied using either a <code>select</code> attribute or a contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. These are mutually exclusive: if the <code>select</code> attribute is present then the sequence constructor must be empty, and if the sequence constructor is non-empty then the <code>select</code> attribute must be absent. If the <code>select</code> attribute is absent and the sequence constructor is empty, then the result is an empty sequence.</span><span style="display: none;" class="add_version">The result of an <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch may be supplied using either a <code>select</code> attribute or a contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. These are mutually exclusive: if the <code>select</code> attribute is present then the sequence constructor must be empty, and if the sequence constructor is non-empty then the <code>select</code> attribute must be absent. If the <code>select</code> attribute is absent and the sequence constructor is empty, then the result is the empty sequence.</span><span class="modify_version">The result of an <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch may be supplied using either a <code>select</code> attribute or a contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. These are mutually exclusive: if the <code>select</code> attribute is present then the sequence constructor must be empty, and if the sequence constructor is non-empty then the <code>select</code> attribute must be absent. If the <code>select</code> attribute is absent and the sequence constructor is empty, then the result is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p><p>Any <a href="#element-fallback"><code>xsl:fallback</code></a> children are ignored by an XSLT 4.0 processor, but can be used to define the recovery action to be taken by a processor for an earlier version of XSLT when operating with <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a>.</p><p>An <a href="#element-switch"><code>xsl:switch</code></a> element is processed as follows:</p><ul><li><p>The <code>select</code> expression of the <a href="#element-switch"><code>xsl:switch</code></a> element is evaluated.</p></li><li><p>The result of the evaluation is converted to a single atomic item by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>; a type error occurs if this conversion is not possible. This value is referred to below as the <b>selector</b>.</p></li><li><p>Each of the <a href="#element-when"><code>xsl:when</code></a> elements is tested in turn (that is, in the order that the elements appear in the stylesheet), until one of the <a href="#element-when"><code>xsl:when</code></a> elements is satisfied. If none of the <a href="#element-when"><code>xsl:when</code></a> elements is satisfied, then the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is considered, as described below.</p><p>An <a href="#element-when"><code>xsl:when</code></a> element is tested by first evaluating its <code>test</code> expression and converting the result to a sequence of atomic items by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>, and then comparing this sequence of atomic items with the <code>selector</code> value. The comparison is performed using the rules of the XPath <code>=</code> operator, using the default collation that is in scope for the <a href="#element-switch"><code>xsl:switch</code></a> instruction.</p><p>An <a href="#element-when"><code>xsl:when</code></a> element is satisfied if the result of this comparison is <code>true</code>.</p></li><li><p><span style="display: none;" class="delete_version">The first, and only the first, <a href="#element-when"><code>xsl:when</code></a> element that is satisfied is evaluated, and the resulting sequence <span>(that is, the result of evaluating its <code>select</code> attribute or contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> as appropriate)</span> is returned as the result of the <a href="#element-switch"><code>xsl:switch</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, the content of the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is evaluated, and the resulting sequence is returned as the result of the <a href="#element-switch"><code>xsl:switch</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, and no <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is present, the result of the <a href="#element-switch"><code>xsl:switch</code></a> instruction is an empty sequence.</span><span style="display: none;" class="add_version">The first, and only the first, <a href="#element-when"><code>xsl:when</code></a> element that is satisfied is evaluated, and the resulting sequence <span>(that is, the result of evaluating its <code>select</code> attribute or contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> as appropriate)</span> is returned as the result of the <a href="#element-switch"><code>xsl:switch</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, the content of the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is evaluated, and the resulting sequence is returned as the result of the <a href="#element-switch"><code>xsl:switch</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, and no <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is present, the result of the <a href="#element-switch"><code>xsl:switch</code></a> instruction is the empty sequence.</span><span class="modify_version">The first, and only the first, <a href="#element-when"><code>xsl:when</code></a> element that is satisfied is evaluated, and the resulting sequence <span>(that is, the result of evaluating its <code>select</code> attribute or contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> as appropriate)</span> is returned as the result of the <a href="#element-switch"><code>xsl:switch</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, the content of the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is evaluated, and the resulting sequence is returned as the result of the <a href="#element-switch"><code>xsl:switch</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, and no <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is present, the result of the <a href="#element-switch"><code>xsl:switch</code></a> instruction is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p>The <code>select expressions</code> and sequence constructors of <a href="#element-when"><code>xsl:when</code></a> and <a href="#element-otherwise"><code>xsl:otherwise</code></a> instructions after the selected one are not evaluated. The <code>test</code> expressions for <a href="#element-when"><code>xsl:when</code></a> instructions after the selected one are not evaluated.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>There is no requirement that the values of <code>select</code> expressions should be literals, nor that the values should be distinct.</p></div><div class="example"><div class="exampleHeader"><a id="d4e26091"></a>Example: Using <code>xsl:switch</code> as a lookup table<a id="d4e26091"></a>Example: Using <code>xsl:switch</code> as a lookup table</div><p>The following example shows a simple function to convert a month number to a month name:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:function name="f:month-name" as="xs:string"&gt;
    &lt;xsl:param name="month-number" as="xs:integer"/&gt;
    &lt;xsl:switch select="$month-number"&gt;
      &lt;xsl:when test="1" select="'January'"/&gt;
      &lt;xsl:when test="2" select="'February'"/&gt;
      &lt;xsl:when test="3" select="'March'"/&gt;
      &lt;xsl:when test="4" select="'April'"/&gt;
      &lt;xsl:when test="5" select="'May'"/&gt;
      &lt;xsl:when test="6" select="'June'"/&gt;
      &lt;xsl:when test="7" select="'July'"/&gt;
      &lt;xsl:when test="8" select="'August'"/&gt;
      &lt;xsl:when test="9" select="'September'"/&gt;
      &lt;xsl:when test="10" select="'October'"/&gt;
      &lt;xsl:when test="11" select="'November'"/&gt;
      &lt;xsl:when test="12" select="'December'"/&gt;
      &lt;xsl:otherwise select="error('Unknown month')"/&gt;
    &lt;/xsl:switch&gt;
  &lt;/xsl:function&gt;</pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e26099"></a>Example: Using <code>xsl:switch</code> to return the number of days in the month<a id="d4e26099"></a>Example: Using <code>xsl:switch</code> to return the number of days in the month</div><p>This function returns the number of days in a month, returning <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence if the supplied month is invalid.</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:function name="f:days-in-month" as="xs:integer?"&gt;
    &lt;xsl:param name="month-number" as="xs:integer"/&gt;
    &lt;xsl:param name="leap-year" as="xs:boolean"/&gt;
    &lt;xsl:switch select="$month-number"&gt;
      &lt;xsl:when test="1, 3, 5, 7, 8, 10, 12" select="31"/&gt;
      &lt;xsl:when test="4, 6, 9, 11" select="30"/&gt;
      &lt;xsl:when test="2"&gt;
         &lt;xsl:if test="$leap-year" then="29" else="28"/&gt;
      &lt;/xsl:when&gt;
    &lt;/xsl:switch&gt;
  &lt;/xsl:function&gt;</pre></div></div></div><div class="_diffs div2"><h3><a id="try-catch"></a>8.4 <a href="#try-catch" style="text-decoration: none">Try/Catch</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#default-values-of-parameters">next</a> | <a href="#xsl-switch">previous</a>)</p><ol><li><p> New variables <code>err:stack-trace</code>, <code>err:additional</code>, and <code>err:map</code> are available within an <a href="#element-catch"><code>xsl:catch</code></a> clause. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1503">1503</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1505">1505</a>&nbsp;26 November 2024]</i></p></li></ol></div><p>The <a href="#element-try"><code>xsl:try</code></a> instruction can be used to trap dynamic errors occurring within the expression it wraps; the recovery action if such errors occur is defined using a child <a href="#element-catch"><code>xsl:catch</code></a> element.</p><p class="element-syntax"><a id="element-try"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:try<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;rollback-output? = <var>boolean</var>〔'yes'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<var>sequence-constructor</var>, <a href="#element-catch">xsl:catch</a>, (<a href="#element-catch">xsl:catch</a> | <a href="#element-fallback">xsl:fallback</a>)*) --&gt;<br>&lt;/xsl:try&gt;</code></p><div class="note"><p class="prefix"><b>Note:</b></p><p>Because a sequence constructor may contain an <a href="#element-fallback"><code>xsl:fallback</code></a> element, the effect of this content model is that an <a href="#element-fallback"><code>xsl:fallback</code></a> instruction may appear as a child of <a href="#element-try"><code>xsl:try</code></a> in any position.</p></div><p class="element-syntax"><a id="element-catch"></a><code>&lt;xsl:catch<br>&nbsp;&nbsp;errors? = <var>tokens</var>〔'*'〕<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:catch&gt;</code></p><p>An <a href="#element-try"><code>xsl:try</code></a> instruction evaluates either the expression contained in its <code>select</code> attribute, or its contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and returns the result of that evaluation if it succeeds without error. If a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs during the evaluation, the processor evaluates the first <a href="#element-catch"><code>xsl:catch</code></a> child element applicable to the error, and returns that result instead.</p><p><span style="display: none;" class="delete_version">If the <a href="#element-try"><code>xsl:try</code></a> element has a <code>select</code> attribute, then it <span class="verb">must</span> have no children other than <a href="#element-catch"><code>xsl:catch</code></a> and <a href="#element-fallback"><code>xsl:fallback</code></a>. That is, the <code>select</code> attribute and the contained sequence constructor are mutually exclusive. If neither is present, the result of the <a href="#element-try"><code>xsl:try</code></a> is an empty sequence (no dynamic error can occur in this case).</span><span style="display: none;" class="add_version">If the <a href="#element-try"><code>xsl:try</code></a> element has a <code>select</code> attribute, then it <span class="verb">must</span> have no children other than <a href="#element-catch"><code>xsl:catch</code></a> and <a href="#element-fallback"><code>xsl:fallback</code></a>. That is, the <code>select</code> attribute and the contained sequence constructor are mutually exclusive. If neither is present, the result of the <a href="#element-try"><code>xsl:try</code></a> is the empty sequence (no dynamic error can occur in this case).</span><span class="modify_version">If the <a href="#element-try"><code>xsl:try</code></a> element has a <code>select</code> attribute, then it <span class="verb">must</span> have no children other than <a href="#element-catch"><code>xsl:catch</code></a> and <a href="#element-fallback"><code>xsl:fallback</code></a>. That is, the <code>select</code> attribute and the contained sequence constructor are mutually exclusive. If neither is present, the result of the <a href="#element-try"><code>xsl:try</code></a> is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence (no dynamic error can occur in this case).</span></p><p>The <code>rollback-output</code> attribute is described in <a href="#recovery"><i>8.4.1 Recovery of Result Trees</i></a>. The default value is <code>yes</code>.</p><p><a id="err-XTSE3140"><span class="error">[ERR XTSE3140] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-try"><code>xsl:try</code></a> element is present and the element has children other than <a href="#element-catch"><code>xsl:catch</code></a> and <a href="#element-fallback"><code>xsl:fallback</code></a> elements. </p><p>Any <a href="#element-fallback"><code>xsl:fallback</code></a> children of the <a href="#element-try"><code>xsl:try</code></a> element are ignored by an XSLT 3.0 processor, but can be used to define the recovery action taken by an XSLT 1.0 or XSLT 2.0 processor operating with <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a>.</p><p>The <a href="#element-catch"><code>xsl:catch</code></a> element has an optional <code>errors</code> attribute, which lists the error conditions that the <a href="#element-catch"><code>xsl:catch</code></a> element is designed to intercept. The default value is <code>errors="*"</code>, which catches all errors. The value is a whitespace-separated list of <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTests</a><sup><small>XP</small></sup>; an <a href="#element-catch"><code>xsl:catch</code></a> element catches an error condition if this list includes a <code>NameTest</code> that matches the error code associated with that error condition.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Error codes are QNames. Those defined in this specification and in related specifications are all in the <a title="standard error namespace" class="termref" href="#dt-standard-error-namespace">standard error namespace</a>, and may therefore be caught using an <a href="#element-catch"><code>xsl:catch</code></a> element such as <code>&lt;xsl:catch errors="err:FODC0001 err:FODC0005"&gt;</code> where the namespace prefix <code>err</code> is bound to this namespace. Errors defined by implementers, and errors raised by an explicit call of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-error"><code>error</code></a> function or by use of the <a href="#element-message"><code>xsl:message</code></a> or <a href="#element-assert"><code>xsl:assert</code></a> instruction, may use error codes in other namespaces.</p></div><p>If more than one <a href="#element-catch"><code>xsl:catch</code></a> element matches an error, the error is processed using the first one that matches, in document order. If no <a href="#element-catch"><code>xsl:catch</code></a> matches the error, then the error is not caught (that is, evaluation of the <a href="#element-try"><code>xsl:try</code></a> element fails with the dynamic error).</p><p>An <a href="#element-catch"><code>xsl:catch</code></a> element may have either a <code>select</code> attribute, or a contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><p><a id="err-XTSE3150"><span class="error">[ERR XTSE3150] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-catch"><code>xsl:catch</code></a> element is present unless the element has empty content. </p><p><span style="display: none;" class="delete_version">The result of evaluating the <a href="#element-catch"><code>xsl:catch</code></a> element is the result of evaluating the XPath expression in its <code>select</code> attribute or the result of evaluating the contained sequence constructor; if neither is present, the result is an empty sequence. This result is delivered as the result of the <a href="#element-try"><code>xsl:try</code></a> instruction.</span><span style="display: none;" class="add_version">The result of evaluating the <a href="#element-catch"><code>xsl:catch</code></a> element is the result of evaluating the XPath expression in its <code>select</code> attribute or the result of evaluating the contained sequence constructor; if neither is present, the result is the empty sequence. This result is delivered as the result of the <a href="#element-try"><code>xsl:try</code></a> instruction.</span><span class="modify_version">The result of evaluating the <a href="#element-catch"><code>xsl:catch</code></a> element is the result of evaluating the XPath expression in its <code>select</code> attribute or the result of evaluating the contained sequence constructor; if neither is present, the result is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. This result is delivered as the result of the <a href="#element-try"><code>xsl:try</code></a> instruction.</span></p><p>If a dynamic error occurs during the evaluation of <a href="#element-catch"><code>xsl:catch</code></a>, it causes the containing <a href="#element-try"><code>xsl:try</code></a> to fail with this error. The error is not caught by other sibling <a href="#element-catch"><code>xsl:catch</code></a> elements within the same <a href="#element-try"><code>xsl:try</code></a> instruction, but it may be caught by an <a href="#element-try"><code>xsl:try</code></a> instruction at an outer level, or by an <a href="#element-try"><code>xsl:try</code></a> instruction nested within the <a href="#element-catch"><code>xsl:catch</code></a>. </p><p>Within the <code>select</code> expression, or within the sequence constructor contained by the <a href="#element-catch"><code>xsl:catch</code></a> element, a number of variables are implicitly declared, giving information about the error that occurred. These are lexically scoped to the <a href="#element-catch"><code>xsl:catch</code></a> element. These variables are all in the <a title="standard error namespace" class="termref" href="#dt-standard-error-namespace">standard error namespace</a>, and they are initialized as described in the following table:</p><table class="data"><caption>Variables Available within <code>xsl:catch</code></caption><thead><tr><th style="text-align:left; vertical-align:top">Variable</th><th style="text-align:left; vertical-align:top">Type</th><th style="text-align:left; vertical-align:top">Value</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top">err:code</td><td style="text-align:left; vertical-align:top">xs:QName</td><td style="text-align:left; vertical-align:top">The error code</td></tr><tr><td style="text-align:left; vertical-align:top">err:description</td><td style="text-align:left; vertical-align:top">xs:string?</td><td style="text-align:left; vertical-align:top">A description of the error condition; <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence if no description is available (for example, if the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-error"><code>error</code></a> function was called with one argument).</td></tr><tr><td style="text-align:left; vertical-align:top">err:value</td><td style="text-align:left; vertical-align:top">item()*</td><td style="text-align:left; vertical-align:top">Value associated with the error. For an error raised by calling the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-error"><code>error</code></a> function, this is the value of the third argument (if supplied). For an error raised by evaluating <a href="#element-message"><code>xsl:message</code></a> with <code>terminate="yes"</code>, or a failing <a href="#element-assert"><code>xsl:assert</code></a>, this is the document node at the root of the tree containing the XML message body.</td></tr><tr><td style="text-align:left; vertical-align:top">err:module</td><td style="text-align:left; vertical-align:top">xs:string?</td><td style="text-align:left; vertical-align:top">The URI (or system ID) of the stylesheet module containing the instruction where the error occurred; <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence if the information is not available.</td></tr><tr><td style="text-align:left; vertical-align:top">err:line-number</td><td style="text-align:left; vertical-align:top">xs:integer?</td><td style="text-align:left; vertical-align:top"><span style="display: none;" class="delete_version">The line number within the stylesheet module of the instruction where the error occurred; an empty sequence if the information is not available. The value <span class="verb">may</span> be approximate.</span><span style="display: none;" class="add_version">The line number within the stylesheet module of the instruction where the error occurred; the empty sequence if the information is not available. The value <span class="verb">may</span> be approximate.</span><span class="modify_version">The line number within the stylesheet module of the instruction where the error occurred; <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence if the information is not available. The value <span class="verb">may</span> be approximate.</span></td></tr><tr><td style="text-align:left; vertical-align:top">err:column-number</td><td style="text-align:left; vertical-align:top">xs:integer?</td><td style="text-align:left; vertical-align:top"><span style="display: none;" class="delete_version">The column number within the stylesheet module of the instruction where the error occurred; an empty sequence if the information is not available. The value <span class="verb">may</span> be approximate.</span><span style="display: none;" class="add_version">The column number within the stylesheet module of the instruction where the error occurred; the empty sequence if the information is not available. The value <span class="verb">may</span> be approximate.</span><span class="modify_version">The column number within the stylesheet module of the instruction where the error occurred; <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence if the information is not available. The value <span class="verb">may</span> be approximate.</span></td></tr><tr><td style="text-align:left; vertical-align:top">err:stack-trace</td><td style="text-align:left; vertical-align:top">xs:string?</td><td style="text-align:left; vertical-align:top">An <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> string containing diagnostic information about the state of execution at the point where the error occured, or <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence if no stack trace is available.</td></tr><tr><td style="text-align:left; vertical-align:top">err:additional</td><td style="text-align:left; vertical-align:top">item()*</td><td style="text-align:left; vertical-align:top">Additional <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> information about the error.</td></tr><tr><td style="text-align:left; vertical-align:top">err:map</td><td style="text-align:left; vertical-align:top">map(xs:string, item()*)</td><td style="text-align:left; vertical-align:top">A map with entries that are bound to the variables above. The local names of the variables are assigned as keys. No map entries are created for those values that are empty sequences. The variable can be used to pass on all error information to another function.</td></tr></tbody></table><p>Variables declared within the sequence constructor of the <a href="#element-try"><code>xsl:try</code></a> element (and not within an <a href="#element-catch"><code>xsl:catch</code></a>) are not visible within the <a href="#element-catch"><code>xsl:catch</code></a> element.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Within an <a href="#element-catch"><code>xsl:catch</code></a> it is possible to re-raise the error using the function call <code>error($err:code, $err:description, $err:value)</code>.</p></div><p>The following additional rules apply to the catching of errors:</p><ol class="enumar"><li><p>All dynamic errors occurring during the evaluation of the <a href="#element-try"><code>xsl:try</code></a> sequence constructor or <code>select</code> expression are caught (provided they match one of the <a href="#element-catch"><code>xsl:catch</code></a> elements). </p><div class="note"><p class="prefix"><b>Note:</b></p><ul><li><p>This includes errors occurring in functions or templates invoked in the course of this evaluation, unless already caught by a nested <a href="#element-try"><code>xsl:try</code></a>.</p></li><li><p>It also includes (for example) errors caused by calling the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-error"><code>error</code></a> function, or the <a href="#element-message"><code>xsl:message</code></a> instruction with <code>terminate="yes"</code>, or the <a href="#element-assert"><code>xsl:assert</code></a> instruction, or the <code>xs:error</code> constructor function. </p></li><li><p>It does not include errors that occur while evaluating references to variables whose declaration and initialization is outside the <a href="#element-try"><code>xsl:try</code></a>.</p></li></ul></div></li><li><p>The existence of an <a href="#element-try"><code>xsl:try</code></a> instruction does not affect the obligation of the processor to raise certain errors as static errors, or its right to choose whether to raise some errors (such as <a title="type error" class="termref" href="#dt-type-error">type errors</a>) statically or dynamically. Static errors are never caught.</p></li><li><p>Some fatal errors arising in the processing environment, such as running out of memory, may cause termination of the transformation despite the presence of an <a href="#element-try"><code>xsl:try</code></a> instruction. This is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p></li><li><p>If the sequence constructor or <code>select</code> expression of the <a href="#element-try"><code>xsl:try</code></a> causes execution of <a href="#element-result-document"><code>xsl:result-document</code></a>, <a href="#element-message"><code>xsl:message</code></a>, or <a href="#element-assert"><code>xsl:assert</code></a> instructions and fails with a dynamic error that is caught, it is implementation-dependent whether these instructions have any externally visible effect. The processor is <span class="verb">not required</span> to roll back any changes made by these instructions. The same applies to any side effects caused by extension functions or extension instructions.</p></li><li><p>A serialization error that occurs during the serialization of a <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a> produced using <a href="#element-result-document"><code>xsl:result-document</code></a> is treated as a dynamic error in the evaluation of the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, and may be caught (for example by an <a href="#element-try"><code>xsl:try</code></a> instruction that contains the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction). A serialization error that occurs while serializing the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> is treated as occurring after the transformation has finished, and cannot be caught. </p></li><li><p>A validation error is treated as occurring in the instruction that requested validation. For example, if the stylesheet is producing XHTML output and requests validation of the entire result document by means of the attribute <code>validation="strict"</code> on the instruction that creates the outermost <code>html</code> element, then a validation failure can be caught only at that level. Although the validation error might be detected, for example, while writing a <code>p</code> element at a location where no <code>p</code> element is allowed, it is not treated as an error in the instruction that writes the <code>p</code> element and cannot be caught at that level.</p></li><li><p>A type error may be caught if the processor raises it dynamically; this does not affect the processor’s right to raise the error statically if it chooses.</p><p>The following rules are provided to define which expression is considered to fail when a type error occurs, and therefore where the error can be caught. The general principle is that where the semantics of a construct <var>C</var> place requirements on the type of some subexpression, a type error is an error in the evaluation of <var>C</var>, not in the evaluation of the subexpression.</p><p>For example, consider the following construct:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="v" as="xs:integer"&gt;
  &lt;xsl:sequence select="$foo"/&gt;
&lt;/xsl:variable&gt;</pre></div><p>The expected type of the result of the sequence constructor is <code>xs:integer</code>; if the value of variable <code>$foo</code> turns out to be a string, then a type error will occur. It is not possible to catch this by writing:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="v" as="xs:integer"&gt;
  &lt;xsl:try&gt;
    &lt;xsl:sequence select="$foo"/&gt;
    &lt;xsl:catch&gt;...&lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:variable&gt;</pre></div><p>This fails to catch the error because the <a href="#element-sequence"><code>xsl:sequence</code></a> instruction is deemed to evaluate successfully; the failure only occurs when the result of this instruction is bound to the variable.</p><p>A similar rule applies to functions: if the body of a function computes a result which does not conform to the required type of the function result, it is not possible to catch this error within the function body itself; it can only be caught by the caller of the function. Similarly, if an expression used to compute an argument to a function returns a value of the wrong type for the function signature, this is not considered an error in this expression, but an error in evaluating the function call as a whole.</p><p>A consequence of these rules is that when a type error occurs while initializing a global variable (because the initializer returns a value of the wrong type, given the declared type of the variable), then this error cannot be caught.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Because processors are permitted to raise type errors during static analysis, it is unwise to attempt to recover from type errors dynamically. The best strategy is generally to prevent their occurrence. For example, rather than writing <code>$p + 1</code> where <code>$p</code> is a parameter of unknown type, and then catching the type error that occurs if <code>$p</code> is not numeric, it is better first to test whether <code>$p</code> is numeric, perhaps by means of an expression such as <code>$p instance of my:numeric</code>, where <code>my:numeric</code> is a union type with <code>xs:double</code>, <code>xs:float</code>, and <code>xs:decimal</code> as its member types.</p></div></li><li><p>The fact that the application tries to catch errors does not prevent the processor from organizing the evaluation in such a way as to prevent errors occurring. For example <code>exists(//a[10 div . gt 5])</code> may still do an “early exit”, rather than examining every item in the sequence just to see if it triggers a divide-by-zero error.</p></li><li><p>Except as specified above, the optimizer must not rearrange the evaluation (at compile time or at run time) so that expressions written to be subject to the try/catch are evaluated outside its scope, or expressions written to be external to the try/catch are evaluated within its scope. This does not prevent expressions being rearranged, but any expression that is so rearranged must carry its try/catch context with it.</p></li></ol></div><div class="_diffs div2"><h3><a id="conditional-content-construction"></a>8.5 <a href="#conditional-content-construction" style="text-decoration: none">Conditional Content Construction</a></h3><p>The facilities described in this section are designed to make it easier to generate result trees conditionally depending on what is found in the input, without violating the rules for streamability. Although these facilities were introduced to the language specifically to make streaming easier, they are available whether or not streaming is in use, and users have often found them convenient in non-streaming applications.</p><p>The facilities are introduced first by example:</p><div class="example"><div class="exampleHeader"><a id="d4e26770"></a><a id="d4e26774"></a>Example: Generating a Wrapper Element for a non-Empty Sequence</div><p>The following example generates an <code>events</code> element if and only if there are one or more <code>event</code> elements. The code could be written like this:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:if test="exists(event)"&gt;
  &lt;events&gt;
    &lt;xsl:copy-of select="event"/&gt;
  &lt;/events&gt;
&lt;/xsl:if&gt;</pre></div><p>However, the above code would not be <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-guaranteed-streamable">guaranteed-streamable</a><sup><small>SG</small></sup>, because it processes the child <code>event</code> elements more than once. To make it streamable, it can be rewritten as:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:where-populated&gt;
  &lt;events&gt;
    &lt;xsl:copy-of select="event"/&gt;
  &lt;/events&gt;
&lt;/xsl:where-populated&gt;</pre></div><p>The effect of the <a href="#element-where-populated"><code>xsl:where-populated</code></a> instruction, as explained later, is to avoid outputting the <code>events</code> element if it would have no children. A streaming implementation will typically hold the start tag of the <code>events</code> element in a buffer, to be sent to the output destination only if and when a child node is generated.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e26801"></a><a id="d4e26805"></a>Example: Generating a Header and Footer only if there is Content</div><p>The following example generates an <code>h3</code> element and a summary paragraph only if a list of items is non-empty. The code could be written like this:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:if test="exists(item-for-sale)"&gt;
  &lt;h1&gt;Items for Sale&lt;/h1&gt;
&lt;/xsl:if&gt;  
&lt;xsl:apply-templates select="item-for-sale"/&gt;
&lt;xsl:if test="exists(item-for-sale)"&gt;
  &lt;p&gt;Total value: {accumulator-before('total-value')}&lt;/p&gt;
&lt;/xsl:if&gt;</pre></div><p>However, the above code would not be <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-guaranteed-streamable">guaranteed-streamable</a><sup><small>SG</small></sup>, because it processes the child <code>item-for-sale</code> elements more than once. To make it streamable, it can be rewritten as:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:sequence&gt;
  &lt;xsl:on-non-empty&gt;
    &lt;h1&gt;Items for Sale&lt;/h1&gt;
  &lt;/xsl:on-non-empty&gt;  
  &lt;xsl:apply-templates select="item-for-sale"/&gt;
  &lt;xsl:on-non-empty&gt;
    &lt;p&gt;Total value: {accumulator-before('total-value')}&lt;/p&gt;
  &lt;/xsl:on-non-empty&gt;  
&lt;/xsl:sequence&gt;</pre></div><p>The effect of the <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction, as explained later, is to output the enclosed content only if the containing sequence constructor also generates “ordinary” content, that is, if there is content generated by instructions other than <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e26827"></a><a id="d4e26831"></a>Example: Generating Substitute Text when there is no Content</div><p>The following example generates a summary paragraph only if a list of items is empty. The code could be written like this:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:apply-templates select="item-for-sale"/&gt;
&lt;xsl:if test="empty(item-for-sale)"&gt;
  &lt;p&gt;There are no items for sale.&lt;/p&gt;
&lt;/xsl:if&gt;</pre></div><p>However, the above code would not be <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-guaranteed-streamable">guaranteed-streamable</a><sup><small>SG</small></sup>, because it processes the child <code>item-for-sale</code> elements more than once (the fact that the list is empty is irrelevant, because streamability is determined statically). To make the code streamable, it can be rewritten as:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:sequence&gt;
  &lt;xsl:apply-templates select="item-for-sale"/&gt;
  &lt;xsl:on-empty&gt;
    &lt;p&gt;There are no items for sale.&lt;/p&gt;
  &lt;/xsl:on-empty&gt;
&lt;/xsl:sequence&gt;</pre></div><p>The effect of the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction, as explained later, is to output the enclosed content only if the containing sequence constructor generates no “ordinary” content, that is, if there is no content generated by instructions other than <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions.</p></div><p>For further examples showing the use of these instructions when streaming, see <a href="../xslt-streaming-40/#handling-empty-input">7 Handling Empty Input</a><sup><small>SG</small></sup>.</p><div class="_diffs div3"><h4><a id="where-populated"></a>8.5.1 <a href="#where-populated" style="text-decoration: none">The <code>xsl:where-populated</code> instruction</a></h4><p class="element-syntax"><a id="element-where-populated"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:where-populated&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:where-populated&gt;</code></p><p>The <a href="#element-where-populated"><code>xsl:where-populated</code></a> instruction encloses a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. The result of the instruction is established as follows:</p><ol class="enumar"><li><p>The sequence constructor is evaluated in the usual way (taking into account any <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions) to produce a result <var>$R</var>.</p></li><li><p>The result of the instruction is the value of the expression <code>$R[not(deemed-empty(.))]</code> where the function <code>deemed-empty($item as item())</code> returns <code>true</code> if and only if <code>$item</code> is one of the following:</p><ul><li><p>A document or element node that has no children.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If an element has attributes or namespaces, these do not prevent the element being deemed empty.</p><p>If a document or element node has children, the node is not deemed empty, even if the children are empty. For example, a document node created using an <a href="#element-variable"><code>xsl:variable</code></a> instruction in the form <code>&lt;xsl:variable name="temp"&gt;&lt;a/&gt;&lt;/xsl:variable&gt;</code> is not deemed empty, even though the contained &lt;a/&gt; element is empty.</p></div></li><li><p>A node, other than a document or element node, whose string value is zero-length.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>A whitespace-only text node is not deemed empty.</p></div></li><li><p>An atomic item such that the result of casting the atomic item to a string is zero-length.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This can happen only when the atomic item is of type <code>xs:string</code>, <code>xs:anyURI</code>, <code>xs:untypedAtomic</code>, <code>xs:hexBinary</code>, or <code>xs:base64Binary</code>.</p></div></li><li><p>A map whose size (number of key/value pairs) is zero.</p></li><li><p>An array (see <a href="#arrays"><i>22 Arrays</i></a>) where the result of flattening the array using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-flatten"><code>array:flatten</code></a> function is either <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, or a sequence in which every item is deemed empty (applying these rules recursively).</p></li></ul></li></ol><div class="example"><div class="exampleHeader"><a id="d4e26941"></a><a id="d4e26945"></a>Example: Generating an HTML list</div><p>The following example generates an HTML unnumbered list, if and only if the list is non-empty. Note that the presence of the <code>class</code> attribute does not make the list non-empty. The code is written to be streamable.</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:where-populated expand-text="yes"&gt;
  &lt;ul class="my-list"&gt;
    &lt;xsl:for-each select="source-item"&gt;
       &lt;li&gt;{.}&lt;/li&gt;
    &lt;/xsl:for-each&gt;
  &lt;/ul&gt;
&lt;/xsl:where-populated&gt;</pre></div></div></div><div class="_diffs div3"><h4><a id="on-empty"></a>8.5.2 <a href="#on-empty" style="text-decoration: none">The <code>xsl:on-empty</code> instruction</a></h4><p class="element-syntax"><a id="element-on-empty"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:on-empty<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:on-empty&gt;</code></p><p>The <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction has the same content model as <a href="#element-sequence"><code>xsl:sequence</code></a>, and when it is evaluated, the same rules apply. In particular, the <code>select</code> attribute and the contained sequence constructor are mutually exclusive <span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span>.</p><p>When an <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction appears in a sequence constructor, then:</p><ol class="enumar"><li><p>It must be the only <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction in the sequence constructor, and</p></li><li><p>It must not be followed in the sequence constructor by any other <a title="instruction" class="termref" href="#dt-instruction">instruction</a>, other than <a href="#element-fallback"><code>xsl:fallback</code></a>, or by a significant text node (that is, a text node that has not been discarded under the provisions of <a href="#stylesheet-stripping"><i>3.12.1 Stripping Whitespace and Commentary from the Stylesheet</i></a>), or by a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>. It may, however, be followed by non-instructions such as <a href="#element-catch"><code>xsl:catch</code></a> where appropriate.</p></li></ol><p><span style="display: none;" class="delete_version"><span class="definition">[Definition:&nbsp;</span><a id="dt-vacuous" title="vacuous"></a>An item is <b>vacuous</b> if it is one of the following: a zero-length text node; a document node with no children; an atomic item which, on casting to <code>xs:string</code>, produces a zero-length string; or an array which on flattening using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-flatten"><code>array:flatten</code></a> function produces either an empty sequence or a sequence consisting entirely of <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items.<span class="definition">]</span></span><span style="display: none;" class="add_version"><span class="definition">[Definition:&nbsp;</span><a id="dt-vacuous" title="vacuous"></a>An item is <b>vacuous</b> if it is one of the following: a zero-length text node; a document node with no children; an atomic item which, on casting to <code>xs:string</code>, produces a zero-length string; or an array which on flattening using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-flatten"><code>array:flatten</code></a> function produces either the empty sequence or a sequence consisting entirely of <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items.<span class="definition">]</span></span><span class="modify_version"><span class="definition">[Definition:&nbsp;</span><a id="dt-vacuous" title="vacuous"></a>An item is <b>vacuous</b> if it is one of the following: a zero-length text node; a document node with no children; an atomic item which, on casting to <code>xs:string</code>, produces a zero-length string; or an array which on flattening using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-flatten"><code>array:flatten</code></a> function produces either <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence or a sequence consisting entirely of <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items.<span class="definition">]</span></span></p><p>An <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction is triggered only if every preceding sibling instruction, text node, and literal result element in the same <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> returns either <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, or a sequence consisting entirely of <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items. </p><p>If an <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction is triggered, then the result of the containing <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is the result of the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that the (vacuous) results produced by other instructions in the sequence constructor are discarded. This is relevant mainly when the result of the sequence constructor is used for something other than constructing a node: for example if it forms the result of a function, or the value of a variable, and the function or variable specifies a required type.</p><p>When streaming, it may be necessary to buffer vacuous items in the result sequence until it is known whether the result will contain items that are non-vacuous. In many common situations, however — in particular, when the sequence constructor is being used to create the content of a node — vacuous items can be discarded immediately because they do not affect the content of the node being constructed. </p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In nearly all cases, the rules for <a href="#element-on-empty"><code>xsl:on-empty</code></a> are aligned with the rules for constructing complex content. If the sequence constructor within a literal result element or an <a href="#element-element"><code>xsl:element</code></a> instruction includes an <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction, then the content of the element will be the value delivered by the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction if and only if the content would otherwise be empty.</p><p>There is one minor exception to this rule: if the sequence constructor delivers multiple zero-length strings, then in the absence of the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction the new element would contain whitespace, made up of the separators between these zero-length strings; but <a href="#element-on-empty"><code>xsl:on-empty</code></a> takes no account of these separators.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Attribute and namespace nodes created by the sequence constructor are significant; the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction will not be triggered if such nodes are present. If this is not the desired effect, it is possible to partition the sequence constructor to change the scope of <a href="#element-on-empty"><code>xsl:on-empty</code></a>, for example:</p><div class="exampleInner"><pre xml:space="preserve">&lt;ol&gt;
  &lt;xsl:attribute name="class" select="numbered-list"/&gt;
  &lt;xsl:sequence&gt;
    &lt;xsl:value-of select="xyz"/&gt;
    &lt;xsl:on-empty select="'The list is empty'"/&gt;
  &lt;/xsl:sequence&gt;
&lt;/ol&gt;</pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Where the sequence constructor is a child of an instruction with an <code>[xsl:]use-attribute-sets</code> attribute, any attribute nodes created by expanding the referenced attribute set(s) are not part of the result of the sequence constructor and therefore play no role in determining whether an <a href="#element-on-empty"><code>xsl:on-empty</code></a> or <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction is triggered. Equally, when the sequence constructor is a child of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, attribute nodes generated by expanding the attributes of the literal result element are not taken into account.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>If <a href="#element-on-empty"><code>xsl:on-empty</code></a> is the only instruction in a sequence constructor then it is always evaluated.</p><p>If <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> appear in the same sequence constructor, then the rules ensure that only one of them will be evaluated.</p></div></div></div></div><div class="_diffs div1"><h2><a id="variables-and-parameters"></a>9 <a href="#variables-and-parameters" style="text-decoration: none">Variables and Parameters</a></h2><p><span class="definition">[Definition:&nbsp;</span><a id="dt-variable-binding-element" title="variable-binding element"></a>The two elements <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> are referred to as <b>variable-binding elements</b>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-variable" title="variable"></a>The <a href="#element-variable"><code>xsl:variable</code></a> element declares a <b>variable</b>, which may be a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> or a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-parameter" title="parameter"></a>The <a href="#element-param"><code>xsl:param</code></a> element declares a <b>parameter</b>, which may be a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a>, a <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a>, a <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a>, or an <a href="#element-iterate"><code>xsl:iterate</code></a> parameter. A parameter is a <a title="variable" class="termref" href="#dt-variable">variable</a> with the additional property that its value can be set by the caller.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-value" title="value"></a>A variable is a binding between a name and a value. The <b>value</b> of a variable is any sequence (of nodes, atomic items, and/or function items), as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>.<span class="definition">]</span></p><div class="_diffs div2"><h3><a id="parameters"></a>9.2 <a href="#parameters" style="text-decoration: none">Parameters</a></h3><p class="element-syntax"><a id="element-param"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:param<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;required? = <var>boolean</var><br>&nbsp;&nbsp;tunnel? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;static? = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:param&gt;</code></p><p>The <a href="#element-param"><code>xsl:param</code></a> element may be used:</p><ul><li><p>As a child of <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-package"><code>xsl:package</code></a>, to define a parameter to the transformation. <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">Stylesheet parameters</a> are set by the calling application: see <a href="#priming-stylesheet"><i>2.3.2 Priming a Stylesheet</i></a>. </p></li><li><p>As a child of <a href="#element-template"><code>xsl:template</code></a> to define a parameter to a template, which may be supplied when the template is invoked using <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a>. <a title="template parameter" class="termref" href="#dt-template-parameter">Template parameters</a> are set by means of an <a href="#element-with-param"><code>xsl:with-param</code></a> child element of the invoking instruction, as described in <a href="#with-param"><i>9.10 Setting Parameter Values</i></a>.</p></li><li><p>As a child of <a href="#element-function"><code>xsl:function</code></a> to define a parameter to a stylesheet function, which may be supplied when the function is called from an XPath <a title="expression" class="termref" href="#dt-expression">expression</a>. <a title="function parameter" class="termref" href="#dt-function-parameter">Function parameters</a> are set <span>either positionally or by keyword</span> by means of the argument list in an XPath function call. </p></li><li><p>As a child of <a href="#element-iterate"><code>xsl:iterate</code></a> to define a parameter that can vary from one iteration to the next. Iteration parameters always take their default values for the first iteration, and in subsequent iterations are set using an <a href="#element-with-param"><code>xsl:with-param</code></a> child of the <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction.</p></li></ul><p>The attributes applicable to <a href="#element-param"><code>xsl:param</code></a> depend on its parent element in the stylesheet, as defined by the following table:</p><table class="data"><caption>Attributes of the <code>xsl:param</code> Element</caption><thead><tr><th style="text-align:left; vertical-align:top">Parent Element</th><th style="text-align:left; vertical-align:top">name</th><th style="text-align:left; vertical-align:top">select</th><th style="text-align:left; vertical-align:top">as</th><th style="text-align:left; vertical-align:top">required</th><th style="text-align:left; vertical-align:top">tunnel</th><th style="text-align:left; vertical-align:top">static</th></tr></thead><tbody><tr><th style="text-align:left; vertical-align:top"><a href="#element-package"><code>xsl:package</code></a></th><td style="text-align:left; vertical-align:top">mandatory</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top">yes|<b>no</b></td><td style="text-align:left; vertical-align:top"><b>no</b></td><td style="text-align:left; vertical-align:top">yes|<b>no</b></td></tr><tr><th style="text-align:left; vertical-align:top"><a href="#element-stylesheet"><code>xsl:stylesheet</code></a></th><td style="text-align:left; vertical-align:top">mandatory</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top">yes|<b>no</b></td><td style="text-align:left; vertical-align:top"><b>no</b></td><td style="text-align:left; vertical-align:top">yes|<b>no</b></td></tr><tr><th style="text-align:left; vertical-align:top"><a href="#element-template"><code>xsl:template</code></a></th><td style="text-align:left; vertical-align:top">mandatory</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top">yes|<b>no</b></td><td style="text-align:left; vertical-align:top">yes|<b>no</b></td><td style="text-align:left; vertical-align:top"><b>no</b></td></tr><tr><th style="text-align:left; vertical-align:top"><a href="#element-function"><code>xsl:function</code></a></th><td style="text-align:left; vertical-align:top">mandatory</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top"><b>yes</b>|no</td><td style="text-align:left; vertical-align:top"><b>no</b></td><td style="text-align:left; vertical-align:top"><b>no</b></td></tr><tr><th style="text-align:left; vertical-align:top"><a href="#element-iterate"><code>xsl:iterate</code></a></th><td style="text-align:left; vertical-align:top">mandatory</td><td style="text-align:left; vertical-align:top">mandatory</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top"><b>no</b></td><td style="text-align:left; vertical-align:top"><b>no</b></td><td style="text-align:left; vertical-align:top"><b>no</b></td></tr></tbody></table><p>In the table, the entries for the <code>name</code>, <code>select</code>, and <code>as</code> attributes indicate whether the attribute must appear, is optional, or must be absent; the entries for the <code>required</code>, <code>tunnel</code>, and <code>static</code> attributes indicate the values that are permitted if the attribute is present, with the default value shown in bold. (The value <code>yes</code> can also be written <code>true</code> or <code>1</code>, while <code>no</code> can also be written <code>false</code> or <code>0</code>.)</p><p>The <code>name</code> attribute is mandatory: it specifies the name of the parameter. The value of the <code>name</code> attribute is an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, which is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a>.</p><p><a id="err-XTSE0580"><span class="error">[ERR XTSE0580] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the values of the <code>name</code> attribute of two sibling <a href="#element-param"><code>xsl:param</code></a> elements represent the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>. </p><p>If the <a href="#element-param"><code>xsl:param</code></a> element has a <code>select</code> attribute, then the sequence constructor <span class="verb">must</span> be empty.</p><p>The <code>static</code> attribute can take the value <code>yes</code> only on <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, and is explained in <a href="#global-variables"><i>9.5 Global Variables and Parameters</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Local variables may <a title="shadows" class="termref" href="#dt-shadows">shadow</a> template parameters and function parameters: see <a href="#scope-of-variables"><i>9.9 Scope of Variables</i></a>.</p></div><p>The optional <code>tunnel</code> attribute may be used to indicate that a parameter is a <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameter</a>. The default is <code>no</code>; the value <code>yes</code> may be specified only for <a title="template parameter" class="termref" href="#dt-template-parameter">template parameters</a>. Tunnel parameters are described in <a href="#tunnel-params"><i>10.1.6 Tunnel Parameters</i></a></p><div class="_diffs div3"><h4><a id="parameter-type"></a>9.2.1 <a href="#parameter-type" style="text-decoration: none">The Required Type of a Parameter</a></h4><p>The <a href="#element-param"><code>xsl:param</code></a> element has an optional <code>as</code> attribute, which specifies the <a title="required type" class="termref" href="#dt-required-type">required type</a> of the parameter. The value of the <code>as</code> attribute is a <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a>. If the <code>as</code> attribute is omitted, then the required type is <code>item()*</code>.</p><p>The <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of the parameter is the value supplied by the caller. If no value was supplied by the caller, and if the parameter is not mandatory, then the default value is used as the supplied value as described in <a href="#default-values-of-parameters"><i>9.2.2 Default Values of Parameters</i></a>.</p><p>The <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of the parameter is converted to the <a title="required type" class="termref" href="#dt-required-type">required type</a> using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p><p><a id="err-XTTE0590"><span class="error">[ERR XTTE0590] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the conversion of the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of a parameter, or of the context item, does not match the <a title="required type" class="termref" href="#dt-required-type">required type</a>, after applying any permitted conversions. </p><p><span style="display: none;" class="delete_version">For example, the following declares a parameter that requires the supplied value (after atomization) to be either a QName, or the string <code>"*"</code>, or an empty sequence:</span><span style="display: none;" class="add_version">For example, the following declares a parameter that requires the supplied value (after atomization) to be either a QName, or the string <code>"*"</code>, or the empty sequence:</span><span class="modify_version">For example, the following declares a parameter that requires the supplied value (after atomization) to be either a QName, or the string <code>"*"</code>, or <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence:</span></p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:param name="n" as="(xs:QName | enum('*'))?"/&gt;</pre></div></div></div><div class="_diffs div2"><h3><a id="variable-values"></a>9.3 <a href="#variable-values" style="text-decoration: none">Values of Variables and Parameters</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#global-variables">next</a> | <a href="#default-values-of-parameters">previous</a>)</p><ol><li><p> A variable-binding with no <code>as</code> or <code>select</code> attribute no longer attempts to create an implicit document node if the sequence constructor contains certain instructions (such as <a href="#element-map"><code>xsl:map</code></a>, <a href="#element-array"><code>xsl:array</code></a>, <a href="#element-record"><code>xsl:record</code></a>, and <a href="#element-select"><code>xsl:select</code></a>). <i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/2009">2009</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/2288">2288</a>&nbsp;PRs <a href="https://github.com/qt4cg/qtspecs/pull/2015">2015</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/pull/2296">2296</a>&nbsp;20 May 2025]</i></p></li></ol></div><p>A <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> may specify the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of a <a title="variable" class="termref" href="#dt-variable">variable</a> or the default value of a <a title="parameter" class="termref" href="#dt-parameter">parameter</a> in four different ways.</p><ul><li><p>If the <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> has a <code>select</code> attribute, then the value of the attribute <span class="verb">must</span> be an <a title="expression" class="termref" href="#dt-expression">expression</a> and the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of the variable is the value that results from evaluating the expression. In this case, the content of the variable-binding element <span class="verb">must</span> be empty.</p></li><li><p>If the <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> has empty content and has neither a <code>select</code> attribute nor an <code>as</code> attribute, then the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of the variable is a zero-length string. Thus</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="x"/&gt;</pre></div><p>is equivalent to</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="x" select="''"/&gt;</pre></div></li><li><p>If a <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> satisfies all the following conditions:</p><ul><li><p>The element has no <code>select</code> attribute</p></li><li><p>The element has no <code>as</code> attribute</p></li><li><p>The element has non-empty content (that is, the variable-binding element has one or more child nodes)</p></li><li><p>There is no <a title="disqualifying element" class="termref" href="#dt-disqualifying-element">disqualifying element</a> among the element's children.</p></li></ul><p>then the content of the variable-binding element specifies the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a>. The content of the variable-binding element is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>; a new document is constructed with a document node having as its children the sequence of nodes that results from evaluating the sequence constructor and then applying the rules given in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>. The value of the variable is then a singleton sequence containing this document node. For further details, see <a href="#temporary-trees"><i>9.4 Creating Implicit Document Nodes</i></a>. </p></li><li><p>Otherwise, the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> is the sequence that results from evaluating the (possibly empty) <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained within the variable-binding element (see <a href="#sequence-constructors"><i>5.7 Sequence Constructors</i></a>). </p></li></ul><p>These combinations are summarized in the table below.</p><table class="data"><caption>Effect of Different Attribute Combinations on <code>xsl:variable</code></caption><thead><tr><th style="text-align:left; vertical-align:top">select attribute</th><th style="text-align:left; vertical-align:top">as attribute</th><th style="text-align:left; vertical-align:top">content</th><th style="text-align:left; vertical-align:top">Effect</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">empty</td><td style="text-align:left; vertical-align:top">Value is obtained by evaluating the <code>select</code> attribute</td></tr><tr><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">empty</td><td style="text-align:left; vertical-align:top">Value is obtained by evaluating the <code>select</code> attribute, coerced to the type required by the <code>as</code> attribute</td></tr><tr><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">Static error</td></tr><tr><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">Static error</td></tr><tr><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">empty</td><td style="text-align:left; vertical-align:top">Value is a zero-length string</td></tr><tr><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">empty</td><td style="text-align:left; vertical-align:top"><span style="display: none;" class="delete_version">Value is an empty sequence, provided the <code>as</code> attribute permits an empty sequence</span><span style="display: none;" class="add_version">Value is the empty sequence, provided the <code>as</code> attribute permits the empty sequence</span><span class="modify_version">Value is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, provided the <code>as</code> attribute permits <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence</span></td></tr><tr><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">includes a <a title="disqualifying element" class="termref" href="#dt-disqualifying-element">disqualifying element</a></td><td style="text-align:left; vertical-align:top">Value is obtained by evaluating the sequence constructor</td></tr><tr><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">present and does not include a <a title="disqualifying element" class="termref" href="#dt-disqualifying-element">disqualifying element</a></td><td style="text-align:left; vertical-align:top">Value is a document node whose content is obtained by evaluating the sequence constructor</td></tr><tr><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">Value is obtained by evaluating the sequence constructor, coerced to the type required by the <code>as</code> attribute</td></tr></tbody></table><p><a id="err-XTSE0620"><span class="error">[ERR XTSE0620] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> has a <code>select</code> attribute and has non-empty content. </p><div class="example"><div class="exampleHeader"><a id="d4e28283"></a><a id="d4e28287"></a>Example: Values of Variables</div><p>The value of the following variable is the sequence of integers (1, 2, 3):</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="i" as="xs:integer*" select="1 to 3"/&gt;</pre></div><p>The value of the following variable is an integer, assuming that the attribute <code>@size</code> exists, and is annotated either as an integer, or as <code>xs:untypedAtomic</code>:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="i" as="xs:integer" select="@size"/&gt;</pre></div><p>The value of the following variable is a zero-length string:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="z"/&gt;</pre></div><p>The value of the following variable is a document node containing an empty element as a child:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="doc"&gt;&lt;c/&gt;&lt;/xsl:variable&gt;</pre></div><p>The value of the following variable is a sequence of integers (2, 4, 6):</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="seq" as="xs:integer*"&gt;
  &lt;xsl:for-each select="1 to 3"&gt;
    &lt;xsl:sequence select=".*2"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;</pre></div><p>The value of the following variable is a sequence of parentless attribute nodes:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="attset" as="attribute()+"&gt;
  &lt;xsl:attribute name="x"&gt;2&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="y"&gt;3&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="z"&gt;4&lt;/xsl:attribute&gt;    
&lt;/xsl:variable&gt;</pre></div><p>The value of the following variable is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="empty" as="empty-sequence()"/&gt;</pre></div></div><p>The actual value of the variable depends on the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a>, as described above, and the required type, which is determined by the value of the <code>as</code> attribute.</p><div class="example"><div class="exampleHeader"><a id="d4e28322"></a><a id="d4e28326"></a>Example: Pitfalls with Numeric Predicates</div><p>When a variable is used to select nodes by position, be careful not to do:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</pre></div><p>This will output the values of all the <code>td</code> elements, space-separated (or with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, the value of the first <code>td</code> element), because the variable <code>n</code> will be bound to a node, not a number. Instead, do one of the following:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="n" select="2"/&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</pre></div><p>or</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[position()=$n]"/&gt;</pre></div><p>or</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="n" as="xs:integer"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</pre></div></div></div><div class="_diffs div2"><h3><a id="local-variables"></a>9.8 <a href="#local-variables" style="text-decoration: none">Local Variables and Parameters</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-local-variable" title="local variable"></a>As well as being allowed as a <a title="declaration" class="termref" href="#dt-declaration">declaration</a>, the <a href="#element-variable"><code>xsl:variable</code></a> element is also allowed in <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructors</a>. Such a variable is known as a <b>local variable</b>.<span class="definition">]</span></p><p>An <a href="#element-param"><code>xsl:param</code></a> element may also be used to create a variable binding with local scope:</p><ul><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-template-parameter" title="template parameter"></a> An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an <a href="#element-template"><code>xsl:template</code></a> element, before any non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter is known as a <b>template parameter</b>. A template parameter is a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a> with the additional property that its value can be set when the template is called, using any of the instructions <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a>.<span class="definition">]</span></p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-function-parameter" title="function parameter"></a> An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an <a href="#element-function"><code>xsl:function</code></a> element, before any non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter is known as a <b>function parameter</b>. A function parameter is a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a> with the additional property that its value can be set when the function is called, using a function call in an XPath <a title="expression" class="termref" href="#dt-expression">expression</a>.<span class="definition">]</span></p></li><li><p>An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an <a href="#element-iterate"><code>xsl:iterate</code></a> instruction, before any non-<a href="#element-param"><code>xsl:param</code></a> children of that element. This defines a parameter whose value may be initialized on entry to the iteration, and which may be varied each time round the iteration by use of an <a href="#element-with-param"><code>xsl:with-param</code></a> element in the <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction. </p></li></ul><p>The result of evaluating a local <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> element (that is, the contribution it makes to the result of the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> it is part of) is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p></div></div><div class="_diffs div1"><h2><a id="callable-components"></a>10 <a href="#callable-components" style="text-decoration: none">Callable Components</a></h2><p>This section describes three constructs that can be used to provide subroutine-like functionality that can be invoked from anywhere in the stylesheet: named templates (see <a href="#named-templates"><i>10.1 Named Templates</i></a>), named attribute sets (see <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a>), and <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> (see <a href="#stylesheet-functions"><i>10.3 Stylesheet Functions</i></a>).</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-invocation-construct" title="invocation construct"></a>The following constructs are classified as <b>invocation constructs</b>: the instructions <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, and <a href="#element-next-match"><code>xsl:next-match</code></a>; XPath function calls that bind to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>; XPath dynamic function calls; the functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a>; the <code>[xsl:]use-attribute-sets</code> attribute. These all have the characteristic that they can cause evaluation of constructs that are not lexically contained within the calling construct.<span class="definition">]</span></p><div class="_diffs div2"><h3><a id="stylesheet-functions"></a>10.3 <a href="#stylesheet-functions" style="text-decoration: none">Stylesheet Functions</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#xsl-function-name">next</a> | <a href="#invoking-templates-with-extension-instructions">previous</a>)</p><ol><li><p>Parameters on functions declared using <a href="#element-function"><code>xsl:function</code></a> can now be defined as optional, with a default value supplied.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/155">155</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/159">159</a>&nbsp;30 September 2022]</i></p></li><li><p>User-defined functions can now have names that are in no namespace. An unprefixed name appearing in a function call is resolved to a no-namespace function with matching local name in preference to a function in the standard <code>fn</code> namespace.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/657">657</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2200">2200</a>&nbsp;23 September 2025]</i></p></li></ol></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-stylesheet-function" title="stylesheet function"></a>An <a href="#element-function"><code>xsl:function</code></a> declaration declares the name, parameters, and implementation of a family of <b>stylesheet functions</b> that can be called from any XPath <a title="expression" class="termref" href="#dt-expression">expression</a> within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (subject to visibility rules).<span class="definition">]</span></p><p class="element-syntax"><a id="element-function"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:function<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕<br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"〔'private'〕<br>&nbsp;&nbsp;streamability? = "unclassified" | "absorbing" | "inspection" | "filter" | "shallow-descent" | "deep-descent" | "ascent" | <var>eqname</var>〔'unclassified'〕<br>&nbsp;&nbsp;override-extension-function? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;<span class="grayed">[override]?</span> = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;new-each-time? = "yes" | "true" | "1" | "no" | "false" | "0" | "maybe"<br>&nbsp;&nbsp;cache? = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-param">xsl:param</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:function&gt;</code></p><p>The effect of an <a href="#element-function"><code>xsl:function</code></a> declaration is to add a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> to the static context for all XPath <a title="expression" class="termref" href="#dt-expression">expressions</a> used in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (including an XPath expression used within a predicate in a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>).</p><p>The content of the <a href="#element-function"><code>xsl:function</code></a> element consists of zero or more <a href="#element-param"><code>xsl:param</code></a> elements that specify the formal parameters of the function, followed by a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that defines the value to be returned by the function.</p><p>The children and attributes of the <a href="#element-function"><code>xsl:function</code></a> declaration translate directly into properties of the <a title="function definition" class="termref" href="#dt-function-definition">function definition</a>:</p><ul><li><p>The <code>xsl:function/@name</code> attribute defines the function’s name.</p></li><li><p>The <code>xsl:param</code> children define the function’s parameters:</p><ul><li><p>The <code>xsl:param/@name</code> attribute defines the name of the parameter.</p></li><li><p>The <code>xsl:param/@required</code> attribute determines whether the parameter is mandatory or optional.</p></li><li><p>The <code>xsl:param/@as</code> attribute determines the required type of the parameter.</p></li><li><p>The <code>xsl:param/@select</code> attribute determines a default value for an optional parameter.</p></li></ul></li><li><p>The <code>xsl:function/@as</code> attribute defines the return type of the function.</p></li><li><p>The implementation of the function is defined by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> content of the <a href="#element-function"><code>xsl:function</code></a> element.</p></li></ul><p>An <a href="#element-function"><code>xsl:function</code></a> declaration can only appear as a <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element in a stylesheet module.</p><div class="_diffs div3"><h4><a id="xsl-function-name"></a>10.3.1 <a href="#xsl-function-name" style="text-decoration: none">Function Name and Arity</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#constructing-sequences">next</a> | <a href="#stylesheet-functions">previous</a>)</p><ol><li><p> Stylesheet functions may now be in no namespace, and may be invoked without use of a namespace prefix, provided they are private to a package. <i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/657">657</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/2235">2235</a>&nbsp;PRs <a href="https://github.com/qt4cg/qtspecs/pull/2200">2200</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/pull/2236">2236</a>&nbsp;7 October 2025]</i></p></li></ol></div><p>The name of the function is given by the <code>name</code> attribute.</p><p><a id="err-XTSE0740"><span class="error">[ERR XTSE0740] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> has a name that is in no namespace, unless the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the function is <code>private</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>XSLT 4.0 allows the function name to be unprefixed, provided that its <a title="visibility" class="termref" href="#dt-visibility">visibility</a> is <code>private</code>. This represents a QName in no namespace. A function call using an unprefixed function name is resolved to a no-namespace function name in preference to a function in the default function namespace, which for XSLT is always the <code>fn</code> namespace.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>To prevent the namespace URI used for the function name appearing in the result document, use the <code>exclude-result-prefixes</code> attribute on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element: see <a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for Literal Result Elements</i></a>.</p><p>The name of the function must not be in a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a>: <span class="error">[see <a href="#err-XTSE0080">ERR XTSE0080</a>]</span></p></div><p>The function parameters are defined by child <a href="#element-param"><code>xsl:param</code></a> elements. The parameters must have distinct names. The list of parameters must contain zero or more required parameters, followed by zero or more optional parameters. A parameter is optional if it has the attribute <code>required="no"</code>; otherwise, it is required.</p><p><span style="display: none;" class="delete_version">The default value for an optional parameter can be defined using the <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of the <a href="#element-param"><code>xsl:param</code></a> element. These must be absent for a required parameter. If an optional parameter has no <code>select</code> attribute and the contained sequence constructor is empty, then the default value will be an empty sequence. This will lead to a type error if the required type of the parameter does not permit an empty sequence.</span><span style="display: none;" class="add_version">The default value for an optional parameter can be defined using the <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of the <a href="#element-param"><code>xsl:param</code></a> element. These must be absent for a required parameter. If an optional parameter has no <code>select</code> attribute and the contained sequence constructor is empty, then the default value will be the empty sequence. This will lead to a type error if the required type of the parameter does not permit the empty sequence.</span><span class="modify_version">The default value for an optional parameter can be defined using the <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of the <a href="#element-param"><code>xsl:param</code></a> element. These must be absent for a required parameter. If an optional parameter has no <code>select</code> attribute and the contained sequence constructor is empty, then the default value will be <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. This will lead to a type error if the required type of the parameter does not permit <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>When considering function overriding, dynamic function calls, and details such as the <code>function-lookup</code> function, it is useful to think of an <a href="#element-function"><code>xsl:function</code></a> declaration with optional parameters as a syntactic short-cut for a set of <a href="#element-function"><code>xsl:function</code></a> declarations of varying arity, each of which calls the function with next-higher arity, supplying the default value of the parameter explicitly in the function call.</p><p>This is not an exact equivalence, however, because of the rules allowing default values of function parameters to be context-dependent.</p></div><p>The <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> derived from the <a href="#element-function"><code>xsl:function</code></a> declaration has an <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> from <var>M</var> to <var>M</var>+<var>N</var>, where <var>M</var> is the number of required parameters and <var>N</var> is the number of optional parameters. The arity range constrains the number of arguments that may appear in a call to this function.</p><p>For example, the following <a href="#element-function"><code>xsl:function</code></a> declaration declares a function, named <code>f:compare</code>, with an arity range of (2 to 3). The effect of calling <code>f:compare($a, $b)</code> is the same as the effect of calling <code>f:compare($a, $b, { "order": "ascending" })</code>.</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:function name="f:compare" as="xs:boolean"&gt;
  &lt;xsl:param name="arg1" as="xs:double"/&gt;
  &lt;xsl:param name="arg2" as="xs:double"/&gt;
  &lt;xsl:param name="options" as="map(*)" 
             required="no" 
             select="{ 'order': 'ascending' }"/&gt;
  &lt;xsl:if test="$options?order = 'descending'" 
          then="$arg1 gt $arg2" 
          else="$arg2 gt $arg1"/&gt;
&lt;/xsl:function&gt;</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Functions are not polymorphic. Although the XPath function call mechanism allows two functions to have the same name and <span>non-overlapping <a title="arity range" class="termref" href="#dt-arity-range">arity ranges</a></span>, it does not allow them to be distinguished by the types of their arguments.</p></div></div></div><div class="_diffs div2"><h3><a id="static-xpath-evaluation"></a>10.4 <a href="#static-xpath-evaluation" style="text-decoration: none">Static XPath Evaluation</a></h3><p>The two instructions described in this section, <code>xsl:sequence</code> and <code>xsl:select</code>, can be used to evaluate XPath expressions that are statically known: that is, the XPath expressions are statically processed during the static processing of the stylesheet, and are dynamically evaluated during the dynamic evaluation of the stylesheet. The <a href="#element-sequence"><code>xsl:sequence</code></a> instruction can also be used to evaluate a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><div class="_diffs div3"><h4><a id="constructing-sequences"></a>10.4.1 <a href="#constructing-sequences" style="text-decoration: none">The <code>xsl:sequence</code> Instruction</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#select-instruction">next</a> | <a href="#xsl-function-name">previous</a>)</p><ol><li><p> An <code>as</code> attribute is available on the <a href="#element-sequence"><code>xsl:sequence</code></a> instruction. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/46">46</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1306">1306</a>&nbsp;27 June 2024]</i></p></li></ol></div><p class="element-syntax"><a id="element-sequence"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:sequence<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:sequence&gt;</code></p><p>The <a href="#element-sequence"><code>xsl:sequence</code></a> instruction may be used within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> to construct a sequence of nodes, atomic items, and/or function items. This sequence is returned as the result of the instruction. Unlike most other instructions, <a href="#element-sequence"><code>xsl:sequence</code></a> can return a sequence containing existing nodes, rather than constructing new nodes. When <a href="#element-sequence"><code>xsl:sequence</code></a> is used to select atomic items or function items, the effect is very similar to the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction.</p><p><span style="display: none;" class="delete_version">The <code>select</code> attribute and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> are mutually exclusive; if the instruction has a <code>select</code> attribute, then it <span class="verb">must</span> have no children other than <a href="#element-fallback"><code>xsl:fallback</code></a> instructions. If there is no <code>select</code> attribute and no contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, the result is an empty sequence. </span><span style="display: none;" class="add_version">The <code>select</code> attribute and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> are mutually exclusive; if the instruction has a <code>select</code> attribute, then it <span class="verb">must</span> have no children other than <a href="#element-fallback"><code>xsl:fallback</code></a> instructions. If there is no <code>select</code> attribute and no contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, the result is the empty sequence. </span><span class="modify_version">The <code>select</code> attribute and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> are mutually exclusive; if the instruction has a <code>select</code> attribute, then it <span class="verb">must</span> have no children other than <a href="#element-fallback"><code>xsl:fallback</code></a> instructions. If there is no <code>select</code> attribute and no contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, the result is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. </span></p><p>The effect of the instruction is as follows:</p><ol class="enumar"><li><p>Evaluate the expression in the <code>select</code> attribute if present, or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> otherwise. Call the result <var>T</var>.</p></li><li><p>Use the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to convert <var>T</var> to the sequence type appearing in the <code>as</code> attribute, defaulting to <code>item()*</code>. The converted result is the value returned by the <a href="#element-sequence"><code>xsl:sequence</code></a> instruction.</p></li></ol><p><a id="err-XTSE3185"><span class="error">[ERR XTSE3185] </span></a>For the elements <a href="#element-sequence"><code>xsl:sequence</code></a>, <a href="#element-on-empty"><code>xsl:on-empty</code></a>, <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a>, <a href="#element-when"><code>xsl:when</code></a>, <a href="#element-otherwise"><code>xsl:otherwise</code></a>, <a href="#element-matching-substring"><code>xsl:matching-substring</code></a>, <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>, <a href="#element-map"><code>xsl:map</code></a>, <a href="#element-map-entry"><code>xsl:map-entry</code></a>, <a href="#element-array"><code>xsl:array</code></a>, <a href="#element-array-member"><code>xsl:array-member</code></a>, and <a href="#element-result-document"><code>xsl:result-document</code></a>, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute is present and the instruction has children other than <a href="#element-fallback"><code>xsl:fallback</code></a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a href="#element-sequence"><code>xsl:sequence</code></a> instruction was first introduced in XSLT 2.0, so the <code>xsl:fallback</code> instruction is relevant only to an XSLT 1.0 processor operating in forwards compatibility mode.</p><p>An XSLT 2.0 or 3.0 processor operating in forwards compatibility mode will ignore the <code>@as</code> attribute.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a href="#element-sequence"><code>xsl:sequence</code></a> instruction is most commonly used as the final instruction in the body of <a href="#element-function"><code>xsl:function</code></a>, to compute the result of the function. If the result is a single item, consider writing <code>&lt;xsl:sequence select="..." as="item()"/&gt;</code> to make this clear to the reader.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The main use case for allowing <a href="#element-sequence"><code>xsl:sequence</code></a> to contain a sequence constructor is to allow the instructions within an <a href="#element-fork"><code>xsl:fork</code></a> element to be divided into groups.</p><p>It can also be used to limit the scope of local variables or of standard attributes such as <code>[xsl:]default-collation</code>.</p></div><div class="example"><div class="exampleHeader"><a id="d4e32421"></a><a id="d4e32425"></a>Example: Constructing a Sequence of Integers</div><p>The following code:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="values" as="xs:integer*"&gt;
    &lt;xsl:sequence select="(1,2,3,4)"/&gt;
    &lt;xsl:sequence select="(8,9,10)"/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="sum($values)"/&gt;</pre></div><p>produces the output: <code>37</code></p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e32435"></a>Example: Using <code>xsl:for-each</code> to Construct a Sequence<a id="d4e32435"></a>Example: Using <code>xsl:for-each</code> to Construct a Sequence</div><p>The following code constructs a sequence containing the value of the <code>@price</code> attribute for selected elements, or a computed price for those elements that have no <code>@price</code> attribute:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="prices" as="xs:decimal*"&gt;
   &lt;xsl:for-each select="//product"&gt;
      &lt;xsl:sequence select="@price otherwise @cost * 1.5" as="xs:decimal"/&gt;
   &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;</pre></div><p>Note that the existing <code>@price</code> attributes could equally have been added to the <code>$prices</code> sequence using <a href="#element-copy-of"><code>xsl:copy-of</code></a> or <a href="#element-value-of"><code>xsl:value-of</code></a>. However, <a href="#element-copy-of"><code>xsl:copy-of</code></a> would create a copy of the attribute node, which is not needed in this situation, while <a href="#element-value-of"><code>xsl:value-of</code></a> would create a new text node, which then has to be converted to an <code>xs:decimal</code>. Using <a href="#element-sequence"><code>xsl:sequence</code></a>, which in this case atomizes the existing attribute node and adds an <code>xs:decimal</code> atomic item to the result sequence, is a more direct way of achieving the same result.</p><p>This example could alternatively be solved at the XPath level:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:sequence select="//product/(+@price otherwise @cost*1.5))"/&gt;</pre></div><p>or, in XSLT 4.0:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:select&gt;//product/(+@price otherwise @cost*1.5))&lt;/xsl:select&gt;</pre></div><p>The apparently redundant <code>+</code> operator is there to atomize the attribute value: the expression on the right hand side of the <code>/</code> operator must not return a sequence containing both nodes and non-nodes (atomic items or function items).</p></div></div></div></div><div class="_diffs div1"><h2><a id="creating-new-nodes"></a>11 <a href="#creating-new-nodes" style="text-decoration: none">Creating Nodes</a></h2><p>This section describes instructions that directly create new nodes.</p><div class="_diffs div2"><h3><a id="copying"></a>11.9 <a href="#copying" style="text-decoration: none">Copying Nodes</a></h3><div class="_diffs div3"><h4><a id="shallow-copy"></a>11.9.1 <a href="#shallow-copy" style="text-decoration: none">Shallow Copy</a></h4><p class="element-syntax"><a id="element-copy"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:copy<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;copy-namespaces? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;inherit-namespaces? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;use-attribute-sets? = <var>eqnames</var>〔''〕<br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:copy&gt;</code></p><p>The <a href="#element-copy"><code>xsl:copy</code></a> instruction provides a way of copying a selected item. The selected item is the item selected by evaluating the expression in the <code>select</code> attribute if present, or the <a title="context item" class="termref" href="#dt-context-item">context item</a> otherwise. If the selected item is a node, evaluating the <a href="#element-copy"><code>xsl:copy</code></a> instruction constructs a copy of the selected node, and the result of the <a href="#element-copy"><code>xsl:copy</code></a> instruction is this newly constructed node. By default, the namespace nodes of the context node are automatically copied as well, but the attributes and children of the node are not automatically copied.</p><p><a id="err-XTTE0945"><span class="error">[ERR XTTE0945] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to use the <a href="#element-copy"><code>xsl:copy</code></a> instruction with no <code>select</code> attribute when the context item is absent. </p><p><span style="display: none;" class="delete_version">If the <code>select</code> expression returns an empty sequence, the <a href="#element-copy"><code>xsl:copy</code></a> instruction returns an empty sequence, and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is not evaluated.</span><span style="display: none;" class="add_version">If the <code>select</code> expression returns the empty sequence, the <a href="#element-copy"><code>xsl:copy</code></a> instruction returns the empty sequence, and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is not evaluated.</span><span class="modify_version">If the <code>select</code> expression returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the <a href="#element-copy"><code>xsl:copy</code></a> instruction returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is not evaluated.</span></p><p><a id="err-XTTE3180"><span class="error">[ERR XTTE3180] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>select</code> expression is a sequence of more than one item.</p><p>When the selected item is an atomic item or function item, the <a href="#element-copy"><code>xsl:copy</code></a> instruction returns this value. The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is not evaluated. </p><p>When the selected item is an attribute node, text node, comment node, processing instruction node, or namespace node, the <a href="#element-copy"><code>xsl:copy</code></a> instruction returns a new node that is a copy of the context node. The new node will have the same node kind, name, and string value as the context node. In the case of an attribute node, it will also have the same values for the <code>is-id</code> and <code>is-idrefs</code> properties. The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is not evaluated. </p><p>When the selected item is a document node or element node, the <a href="#element-copy"><code>xsl:copy</code></a> instruction returns a new node that has the same node kind and name as the selected node. The content of the new node is formed by evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained in the <a href="#element-copy"><code>xsl:copy</code></a> instruction. If the <code>select</code> attribute is present then the sequence constructor is evaluated with the selected item as the <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a>; otherwise it is evaluated using the context of the <a href="#element-copy"><code>xsl:copy</code></a> instruction unchanged. The sequence obtained by evaluating this sequence constructor is used (after prepending any attribute nodes or namespace nodes as described in the following paragraphs) to construct the content of the document or element node, as described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>.</p><p>When the selected item is a document node, the <code>unparsed-entities</code> property of the existing document node is copied to the new document node.</p><p>When the selected item is an element or attribute node, the values of the <code>is-id</code>, <code>is-idrefs</code>, and <code>nilled</code> properties of the new element or attribute depend on the values of the <code>validation</code> and <code>type</code> attributes, as defined in <a href="#validation"><i>25.4 Validation</i></a>.</p><p>The <a href="#element-copy"><code>xsl:copy</code></a> instruction has an optional <code>use-attribute-sets</code> attribute, whose value is a whitespace-separated list of QNames that identify <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declarations. This attribute is used only when copying element nodes. This list is expanded as described in <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a> to produce a sequence of attribute nodes. This sequence is prepended to the sequence produced as a result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><p>The <a href="#element-copy"><code>xsl:copy</code></a> instruction has an optional <code>copy-namespaces</code> attribute, with the value <code>yes</code> or <code>no</code>. The default value is <code>yes</code>. The attribute is used only when copying element nodes. If the value is set to <code>yes</code>, or is omitted, then all the namespace nodes of the source element are copied as namespace nodes for the result element. These copied namespace nodes are prepended to the sequence produced as a result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (it is immaterial whether they come before or after any attribute nodes produced by expanding the <code>use-attribute-sets</code> attribute). If the value is set to <code>no</code>, then the namespace nodes are not copied. However, namespace nodes will still be added to the result element as <span class="verb">required</span> by the namespace fixup process: see <a href="#namespace-fixup"><i>5.7.3 Namespace Fixup</i></a>.</p><p>The <a href="#element-copy"><code>xsl:copy</code></a> instruction has an optional <code>inherit-namespaces</code> attribute, with the value <code>yes</code> or <code>no</code>. The default value is <code>yes</code>. The attribute is used only when copying element nodes. If the value is set to <code>yes</code>, or is omitted, then the namespace nodes created for the newly constructed element (whether these were copied from those of the source node, or generated as a result of namespace fixup) are copied to the children and descendants of the newly constructed element, as described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>. If the value is set to <code>no</code>, then these namespace nodes are not automatically copied to the children. This may result in namespace undeclarations (such as <code>xmlns=""</code> or, in the case of XML Namespaces 1.1, <code>xmlns:p=""</code>) appearing on the child elements when a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is serialized.</p><p><a id="err-XTTE0950"><span class="error">[ERR XTTE0950] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to use the <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction to copy a node that has namespace-sensitive content if the <code>copy-namespaces</code> attribute has the value <code>no</code> and its explicit or implicit <code>validation</code> attribute has the value <code>preserve</code>. It is also a type error if either of these instructions (with <code>validation="preserve"</code>) is used to copy an attribute having namespace-sensitive content, unless the parent element is also copied. A node has namespace-sensitive content if its typed value contains an item of type <code>xs:QName</code> or <code>xs:NOTATION</code> or a type derived therefrom. The reason this is an error is because the validity of the content depends on the namespace context being preserved. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>When attribute nodes are copied, whether with <a href="#element-copy"><code>xsl:copy</code></a> or with <a href="#element-copy-of"><code>xsl:copy-of</code></a>, the processor does not automatically copy any associated namespace information. The namespace used in the attribute name itself will be declared by virtue of the namespace fixup process (see <a href="#namespace-fixup"><i>5.7.3 Namespace Fixup</i></a>) when the attribute is added to an element in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>, but if namespace prefixes are used in the content of the attribute (for example, if the value of the attribute is an XPath expression) then it is the responsibility of the stylesheet author to ensure that suitable namespace nodes are added to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. This can be achieved by copying the namespace nodes using <a href="#element-copy"><code>xsl:copy</code></a>, or by generating them using <a href="#element-namespace"><code>xsl:namespace</code></a>.</p></div><p>The optional attributes <code>type</code> and <code>validation</code> may be used on the <a href="#element-copy"><code>xsl:copy</code></a> instruction to validate the contents of an element, attribute or document node against a type definition, element declaration, or attribute declaration in a schema, and thus to determine the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that the new copy of an element or attribute node will carry. These attributes are ignored when copying an item that is not an element, attribute or document node. When the node being copied is an element or document node, these attributes also affect the type annotation carried by any elements and attributes that have the copied element or document node as an ancestor. These two attributes are both optional, and if one is specified then the other <span class="verb">must</span> be omitted. The permitted values of these attributes and their semantics are described in <a href="#validation"><i>25.4 Validation</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The final <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of the node in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> also depends on the <code>type</code> and <code>validation</code> attributes of the instructions used to create the ancestors of the node.</p></div><p>When a node is copied, its base URI is copied, except when the result of the <a href="#element-copy"><code>xsl:copy</code></a> instruction is an element node having an <code>xml:base</code> attribute, in which case the base URI of the new node is taken as the value of its <code>xml:base</code> attribute, resolved if it is relative against the base URI of the <a href="#element-copy"><code>xsl:copy</code></a> instruction. </p><p>When an <code>xml:id</code> attribute is copied, using either the <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction, it is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether the value of the attribute is subjected to attribute value normalization (that is, effectively applying the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-normalize-space"><code>normalize-space</code></a> function).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In most cases the value will already have been subjected to attribute value normalization on the source tree, but if this processing has not been performed on the source tree, it is not an error for it to be performed on the result tree.</p></div></div></div></div><div class="_diffs div1"><h2><a id="sorting"></a>13 <a href="#sorting" style="text-decoration: none">Sorting</a></h2><p><span class="definition">[Definition:&nbsp;</span><a id="dt-sort-key-specification" title="sort key specification"></a>A <b>sort key specification</b> is a sequence of one or more adjacent <a href="#element-sort"><code>xsl:sort</code></a> elements which together define rules for sorting the items in an input sequence to form a sorted sequence.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-sort-key-component" title="sort key component"></a>Within a <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a>, each <a href="#element-sort"><code>xsl:sort</code></a> element defines one <b>sort key component</b>.<span class="definition">]</span> The first <a href="#element-sort"><code>xsl:sort</code></a> element specifies the primary component of the sort key specification, the second <a href="#element-sort"><code>xsl:sort</code></a> element specifies the secondary component of the sort key specification, and so on.</p><p>A sort key specification may occur immediately within an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-for-each"><code>xsl:for-each</code></a>, <a href="#element-perform-sort"><code>xsl:perform-sort</code></a>, or <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>When used within <a href="#element-for-each"><code>xsl:for-each</code></a>, <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, or <a href="#element-perform-sort"><code>xsl:perform-sort</code></a>, <a href="#element-sort"><code>xsl:sort</code></a> elements must occur before any other children.</p></div><div class="_diffs div2"><h3><a id="creating-sorted-sequence"></a>13.2 <a href="#creating-sorted-sequence" style="text-decoration: none">Creating a Sorted Sequence</a></h3><p class="element-syntax"><a id="element-perform-sort"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:perform-sort<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>+, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:perform-sort&gt;</code></p><p>The <a href="#element-perform-sort"><code>xsl:perform-sort</code></a> instruction is used to return a <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted sequence</a>.</p><p><span style="display: none;" class="delete_version">The <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a> is obtained either by evaluating the <code>select</code> attribute or by evaluating the contained sequence constructor (but not both). If there is no <code>select</code> attribute and no sequence constructor then the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a> (and therefore, the <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted sequence</a>) is an empty sequence.</span><span style="display: none;" class="add_version">The <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a> is obtained either by evaluating the <code>select</code> attribute or by evaluating the contained sequence constructor (but not both). If there is no <code>select</code> attribute and no sequence constructor then the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a> (and therefore, the <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted sequence</a>) is the empty sequence.</span><span class="modify_version">The <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a> is obtained either by evaluating the <code>select</code> attribute or by evaluating the contained sequence constructor (but not both). If there is no <code>select</code> attribute and no sequence constructor then the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a> (and therefore, the <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted sequence</a>) is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p><p><a id="err-XTSE1040"><span class="error">[ERR XTSE1040] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-perform-sort"><code>xsl:perform-sort</code></a> instruction with a <code>select</code> attribute has any content other than <a href="#element-sort"><code>xsl:sort</code></a> and <a href="#element-fallback"><code>xsl:fallback</code></a> instructions. </p><p>The result of the <a href="#element-perform-sort"><code>xsl:perform-sort</code></a> instruction is the result of sorting its <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a> using its contained <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a>.</p><div class="example"><div class="exampleHeader"><a id="d4e39067"></a><a id="d4e39071"></a>Example: Sorting a Sequence of Atomic Items</div><p>The following stylesheet function sorts a sequence of atomic items using the value itself as the sort key.</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:function name="local:sort" 
          as="xs:anyAtomicType*"&gt;
  &lt;xsl:param name="in" as="xs:anyAtomicType*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="."/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;</pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e39072"></a><a id="d4e39076"></a>Example: Writing a Function to Perform a Sort</div><p>The following example defines a function that sorts books by price, and uses this function to output the five books that have the lowest prices:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:function name="bib:books-by-price" 
          as="schema-element(bib:book)*"&gt;
  &lt;xsl:param name="in" as="schema-element(bib:book)*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="xs:decimal(bib:price)"/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;
   ...
   &lt;xsl:copy-of select="bib:books-by-price(//bib:book)
                             [position() = 1 to 5]"/&gt;</pre></div></div></div></div><div class="_diffs div1"><h2><a id="grouping"></a>14 <a href="#grouping" style="text-decoration: none">Grouping</a></h2><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#func-current-group">next</a> | <a href="#comparing-sort-keys">previous</a>)</p><ol><li><p> A new attribute <code>xsl:for-each-group/@split-when</code> is available to give applications more complete control over how a sequence is partitioned <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/571">571</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/740">740</a>&nbsp;26 September 2023]</i></p></li><li><p> A new attribute <code>xsl:for-each-group/@merge-when</code> is available to give applications control to create groups based on clustering, overlap, and networks. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2051">2051</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2123">2123</a>&nbsp;30 September 2025]</i></p></li></ol></div><p>The facilities described in this section are designed to allow items in a sequence to be grouped based on common values; for example it allows grouping of elements having the same value for a particular attribute, or elements with the same name, or elements with common values for any other <a title="expression" class="termref" href="#dt-expression">expression</a>. Since grouping identifies items with duplicate values, the same facilities also allow selection of the distinct values in a sequence of items, that is, the elimination of duplicates.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Simple elimination of duplicates can also be achieved using the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-distinct-values"><code>distinct-values</code></a>: see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>.</p></div><p>In addition these facilities allow grouping based on sequential position, for example selecting groups of adjacent <code>para</code> elements. The facilities also provide an easy way to do fixed-size grouping, for example identifying groups of three adjacent nodes, which is useful when arranging data in multiple columns.</p><p>For each group of items identified, it is possible to evaluate a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> for the group. Grouping is nestable to multiple levels so that groups of distinct items can be identified, then from among the distinct groups selected, further sub-grouping of distinct items in the current group can be done. </p><p>It is also possible for one item to participate in more than one group.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Grouping can also be achieved by constructing a map. For example, the function call <code>map:build(//employee, fn { department })</code> constructs a map in which employees are grouped by department.</p></div><div class="_diffs div2"><h3><a id="xsl-for-each-group"></a>14.1 <a href="#xsl-for-each-group" style="text-decoration: none">The <code>xsl:for-each-group</code> Element</a></h3><p>The <a href="#element-for-each-group"><code>xsl:for-each-group</code></a><a title="instruction" class="termref" href="#dt-instruction">instruction</a> allows a flat sequence of items to be processed as a sequence of groups, allowing a number of criteria to be used to define the grouping. The instruction may be used anywhere within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><p class="element-syntax"><a id="element-for-each-group"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:for-each-group<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;group-by? = <var>expression</var><br>&nbsp;&nbsp;group-adjacent? = <var>expression</var><br>&nbsp;&nbsp;group-starting-with? = <var>pattern</var><br>&nbsp;&nbsp;group-ending-with? = <var>pattern</var><br>&nbsp;&nbsp;split-when? = <var>expression</var><br>&nbsp;&nbsp;merge-when? = <var>expression</var><br>&nbsp;&nbsp;composite? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;collation? = { <var>uri</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:for-each-group&gt;</code></p><p>The <code>select</code> attribute contains an <a title="expression" class="termref" href="#dt-expression">expression</a> which is evaluated to produce a sequence, called the <a title="population" class="termref" href="#dt-population">population</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-group" title="group"></a>The <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction allocates the items in an input sequence into <b>groups</b> of items (that is, it establishes a collection of sequences) based either on common values of a grouping key, or on a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that the initial or final item in a group must match.<span class="definition">]</span> The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the content of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction is evaluated once for each of these groups.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-population" title="population"></a>The sequence of items to be grouped, which is referred to as the <b>population</b>, is determined by evaluating the XPath <a title="expression" class="termref" href="#dt-expression">expression</a> contained in the <code>select</code> attribute.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-population-order" title="population order"></a>The population is treated as a sequence; the order of items in this sequence is referred to as <b>population order</b>.<span class="definition">]</span></p><p>A group is never empty. If the population is empty, the number of groups will be zero.</p><p>The assignment of items to groups depends on the <code>group-by</code>, <code>group-adjacent</code>, <code>group-starting-with</code>, <code>group-ending-with</code>, <span><code>split-when</code>,</span><span>and <code>merge-when</code></span> attributes. </p><p><a id="err-XTSE1080"><span class="error">[ERR XTSE1080] </span></a>These <span>six</span> attributes are mutually exclusive: it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if none of these attributes is present or if more than one of them is present. </p><p><a id="err-XTSE1090"><span class="error">[ERR XTSE1090] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to specify the <code>collation</code> attribute or the <code>composite</code> attribute if neither the <code>group-by</code> attribute nor the <code>group-adjacent</code> attribute is specified. </p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-grouping-key" title="grouping key"></a>If the <code>group-by</code> or <code>group-adjacent</code> attributes is present, then for each item in the <a title="population" class="termref" href="#dt-population">population</a> a set of <b>grouping keys</b> is calculated, as follows: the expression contained in the <code>group-by</code> or <code>group-adjacent</code> attribute is evaluated; the result is atomized; and any <code>xs:untypedAtomic</code> items are cast to <code>xs:string</code>. If <code>composite="yes"</code> is specified, there is a single grouping key whose value is the resulting sequence; otherwise, there is a set of grouping keys, consisting of the distinct atomic items present in the result sequence.<span class="definition">]</span></p><p>When calculating grouping keys for an item in the population, the <a title="expression" class="termref" href="#dt-expression">expression</a> contained in the <code>group-by</code> or <code>group-adjacent</code> attribute is evaluated with that item as the <a title="context item" class="termref" href="#dt-context-item">context item</a>, with its position in <a title="population order" class="termref" href="#dt-population-order">population order</a> as the <a title="context position" class="termref" href="#dt-context-position">context position</a>, and with the size of the population as the <a title="context size" class="termref" href="#dt-context-size">context size</a>.</p><p>If the <code>group-by</code> attribute is present, and if the <code>composite</code> attribute is omitted or takes the value <code>no</code>, then an item in the population <span class="verb">may</span> have multiple grouping keys: that is, the <code>group-by</code> expression evaluates to a sequence, and each item in the sequence is treated as a separate grouping key. The item is included in as many groups as there are distinct grouping keys (which may be zero).</p><p>If the <code>group-adjacent</code> attribute is used, and if the <code>composite</code> attribute is omitted or takes the value <code>no</code>, then each item in the population <span class="verb">must</span> have exactly one grouping key value.</p><p><span style="display: none;" class="delete_version"><a id="err-XTTE1100"><span class="error">[ERR XTTE1100] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>group-adjacent</code> expression is an empty sequence or a sequence containing more than one item, unless <code>composite="yes"</code> is specified. </span><span style="display: none;" class="add_version"><a id="err-XTTE1100"><span class="error">[ERR XTTE1100] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>group-adjacent</code> expression is the empty sequence or a sequence containing more than one item, unless <code>composite="yes"</code> is specified. </span><span class="modify_version"><a id="err-XTTE1100"><span class="error">[ERR XTTE1100] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>group-adjacent</code> expression is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence or a sequence containing more than one item, unless <code>composite="yes"</code> is specified. </span></p><p> Atomic <a title="grouping key" class="termref" href="#dt-grouping-key">grouping keys</a> are compared using the rules of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-distinct-values"><code>distinct-values</code></a> function, using the relevant collation. The relevant collation is the collation specified as the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>collation</code> attribute, resolved if relative against the base URI of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element; if there is no <code>collation</code> attribute then the <a title="default collation" class="termref" href="#dt-default-collation">default collation</a> is used. Given this collation, two grouping keys <var>K<sub>1</sub></var> and <var>K<sub>2</sub></var> are considered equal if <code>count(distinct-values(($K1, $K2), $collation)) = 1</code>. </p><p>Composite grouping keys are equal if they contain the same number of items and the items are pairwise equal when compared according to the rules in the previous paragraph.</p><p><a id="err-XTDE1110"><span class="error">[ERR XTDE1110] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the collation URI specified to <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> (after resolving against the base URI) is a collation that is not recognized by the implementation. (For notes, <span class="error">[see <a href="#err-XTDE1035">ERR XTDE1035</a>]</span>.) </p><p>For more information on collations, see <a href="#collating-sequences"><i>13.1.3 Sorting Using Collations</i></a>.</p><p>The way in which an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element is evaluated depends on which of the six group-defining attributes is present:</p><ul><li><p>If the <code>group-by</code> attribute is present, the items in the <a title="population" class="termref" href="#dt-population">population</a> are examined, in population order. For each item <var>J</var>, the expression in the <code>group-by</code> attribute is evaluated to produce a sequence of zero or more <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> values. If <code>composite="yes"</code> is specified, there will be a single grouping key, which will in general be a sequence of zero or more atomic items; otherwise, there will be zero or more grouping keys, each of which will be a single atomic item. For each one of these <a title="grouping key" class="termref" href="#dt-grouping-key">grouping keys</a>, if there is already a group created to hold items having that grouping key value, <var>J</var> is appended to that group; otherwise a new group is created for items with that grouping key value, and <var>J</var> becomes its first member.</p><p>An item in the population may thus be appended to zero, one, or many groups. An item will never be appended more than once to the same group; if two or more grouping keys for the same item are equal, then the duplicates are ignored. An <em>item</em> here means the item at a particular position within the population—if the population contains the same node at several different positions in the sequence then a group may indeed contain duplicate nodes.</p><p>The number of groups will be the same as the number of distinct grouping key values present in the <a title="population" class="termref" href="#dt-population">population</a>. </p></li><li><p>If the <code>group-adjacent</code> attribute is present, the items in the <a title="population" class="termref" href="#dt-population">population</a> are examined, in population order. If an item has the same value for the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> as its preceding item within the <a title="population" class="termref" href="#dt-population">population</a> (in <a title="population order" class="termref" href="#dt-population-order">population order</a>), then it is appended to the same group as its preceding item; otherwise a new group is created and the item becomes its first member.</p></li><li><p>If the <code>group-starting-with</code> attribute is present, then its value <span class="verb">must</span> be a <a href="#doc-xslt40-Pattern">pattern</a>. </p><p>The items in the <a title="population" class="termref" href="#dt-population">population</a> are examined in <a title="population order" class="termref" href="#dt-population-order">population order</a>. If an item matches the pattern, or is the first item in the population, then a new group is created and the item becomes its first member. Otherwise, the item is appended to the same group as its preceding item within the population.</p></li><li><p>If the <code>group-ending-with</code> attribute is present, then its value <span class="verb">must</span> be a <a href="#doc-xslt40-Pattern">pattern</a>. </p><p>The items in the <a title="population" class="termref" href="#dt-population">population</a> are examined in <a title="population order" class="termref" href="#dt-population-order">population order</a>. If an item is the first item in the population, or if the previous item in the population matches the pattern, then a new group is created and the item becomes its first member. Otherwise, the item is appended to the same group as its preceding item within the population.</p></li><li><p>If the <code>split-when</code> attribute is present, then its value <span class="verb">must</span> be an expression. This expression is evaluated once for every item in the <a title="population" class="termref" href="#dt-population">population</a> except the first. The context item is that item, the context position is its position in the <a title="population" class="termref" href="#dt-population">population</a>, and the context size is the size of the population. The expression is supplied with two variables: <code>$group</code> is set to the contents of the current group being constructed, and <code>$next</code> is the next item in the population. If the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-ebv">effective boolean value</a><sup><small>XP</small></sup> of the expression is <code>true</code>, then this item forms the start of a new group; if it is <code>false</code>, the item is added to the existing group.</p><ul><li><p>The variable <code>$group</code> is implicitly declared, and <a title="shadows" class="termref" href="#dt-shadows">shadows</a> any other variable of the same name. Its name is in no namespace. Its scope is the <code>split-when</code> expression, and its type is <code>item()+</code>.</p></li><li><p>The variable <code>$next</code> is implicitly declared, and <a title="shadows" class="termref" href="#dt-shadows">shadows</a> any other variable of the same name. Its name is in no namespace. Its scope is the <code>split-when</code> expression, and its type is <code>item()</code>.</p></li></ul><p>For example:</p><ul><li><p><code>split-when="count($group) = 3"</code> starts a new group whenever the existing group has exactly three members; that is, it partitions the population into groups of size 3 (with the last group being smaller if necessary).</p></li><li><p><code>split-when="$next[self::h1]"</code> starts a new group whenever an <code>h1</code> element is encountered. The effect is the same as specifying <code>group-starting-with="h1"</code></p></li><li><p><code>split-when="foot($group)/@continued='no'"</code> starts a new group immediately after any element having <code>@continued="no"</code>. The effect is the same as specifying <code>group-ending-with="*[@continued='no']"</code></p></li><li><p><code>split-when="node-name($group[last()] != node-name($next)"</code> starts a new group whenever the name of an item differs from the name of the previous item. The effect is the same as specifying <code>group-adjacent="node-name(.)"</code>.</p></li><li><p><code>split-when="foot($group)[self::hr] or $next[self::hr]"</code> starts a new group immediately before and immediately after every <code>hr</code> element. (That is, <code>hr</code> elements become singleton groups.)</p></li><li><p><code>split-when="$next ne foot($group) + 1"</code> starts a new group whenever the current item is not equal to the previous item plus one. For example <code>1, 2, 5, 6, 7, 10, 11</code> is grouped as <code>(1, 2), (5, 6, 7), (10, 11)</code>.</p></li><li><p><code>split-when="sum($group/string-length()) gt 40"</code> starts a new group when the sum of the string lengths of the items in the current group exceeds 40.</p></li><li><p><code>split-when="ends-with(foot($group), '.') and matches($next, '^\p{Lu}')"</code> starts a new group when the last item in the current group ends with <code>"."</code> and the next item starts with a capital letter.</p></li><li><p><code>split-when="deep-equal(slice($group, -2 to -1), ('', ''))"</code> starts a new group after two consecutive zero-length strings.</p></li><li><p><code>split-when="count($group) gt 1 and head($group)/@name = foot($group)/@name"</code> starts a new group if the last item in the current group has the same value for <code>@name</code> as the first item in that group (provided they are not the same item).</p></li></ul></li><li><p>If the <code>merge-when</code> attribute is present, then its value <span class="verb">must</span> be an expression that is a sequence comparator. <span class="definition">[Definition:&nbsp;</span><a id="dt-sequence-comparator" title=""></a>A <b>sequence comparator</b> is an expression that evaluates two sequences of items and results in a true or false value. <span class="definition">]</span></p><p>The sequence comparator is supplied with two variables: <code>$group-a</code> and <code>$group-b</code>. Each of these variables is implicitly declared, and <a title="shadows" class="termref" href="#dt-shadows">shadows</a> any other variable of the same name. Its name is in no namespace. Its scope is the <code>merge-when</code> expression, and its type is <code>item()+</code>.</p><p>The sequence comparator is evaluated not item by item (as with <code>split-when</code>) but group by group. The context item is <a title="absent" class="termref" href="#dt-absent">absent</a>, the context position is the position of the first sequence (<code>$group-a</code>) within the sequence of groups being constructed, and the context size is the number of groups at the moment of evaluation.</p><p>The process begins by creating singleton groups. For each item in the <a title="population" class="termref" href="#dt-population">population</a> a group is created, with that item's position as its grouping key, and the item as its only member.</p><p>After the groups are created, they are evaluated pairwise against the <a title="" class="termref" href="#dt-sequence-comparator">sequence comparator</a>. The pairwise comparison begins with the first two groups, then the first and third groups, and so on until the first and last groups, then pairwise comparison moves to the second and third groups, then the second and fourth groups, and so forth. Pairwise comparison proceeds until the next-to-last and last groups are evaluated.</p><p><code>$group-a</code> is set to the items in the first group in a pair of groups, <var>G<sub>1</sub></var>, and <code>$group-b</code> to the second group, <var>G<sub>2</sub></var>.</p><p>If the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-ebv">effective boolean value</a><sup><small>XP</small></sup> of the sequence comparator is <code>true</code>, then all items in <var>G<sub>2</sub></var> are merged with the items in <var>G<sub>1</sub></var>, preserving original sequence order, and the grouping keys of <var>G<sub>2</sub></var> are merged with those of <var>G<sub>1</sub></var>, sorted in ascending order. The process of merging two groups is identical to the process described in <a href="#merging"><i>15 Merging</i></a> to merge sequences. Pairwise comparison then restarts from the beginning with the first pair of groups, as described above. </p><p>The process is repeated until it is the case that there is no pair of groups for which the <a title="" class="termref" href="#dt-sequence-comparator">sequence comparator</a> evaluates to <code>true</code>, or there is only one group.</p><p>Every item in the population will be appended to exactly one group. </p><p>Unlike other grouping methods, a group created by <code>merge-when</code> may have more than one grouping key. Although those grouping keys are not significant for the semantics of the grouping operation, they can be used to examine the original population, and they are useful for the merge operation.</p><p><code>merge-when</code> is most effective for building clusters or networks. For example:</p><ul><li><p><code>merge-when="$group-a/(@id | is-related-to) = $group-b/(@id | is-related-to)"</code> creates groups of elements. In a group with more than one item, each item has at least one other item that it relates to, or that relates to the same item it relates to. That is, each group represents a kind of network cluster.</p></li><li><p>Suppose we have elements containing text units where word tokens of significance are wrapped in children <code>tok</code> elements. <code>merge-when="every $a in $group-a, $b in $group-b satisfies count($a/tok[. = $b/tok]) ge 3"</code> creates groups of possibly related texts. In groups of more than one item, any pair of texts has at least three common word-tokens. </p></li><li><p><code>merge-when="some $a in $group-a, $b in $group-b satisfies count($a/tok[. = $b/tok]) ge 3"</code> creates groups of related texts, likely less cohesive than in the previous example. In groups of more than one item, every text has at least one other text with which it has three word-tokens in common. </p></li><li><p><code>merge-when="not($group-a = $group-b)"</code> creates maximal groups of distinct values. For example, <code>4, 1, 5, 1, 9, 4, 1</code> is grouped as <code>4, 1, 5, 9</code> (with grouping keys <code>1, 2, 3, 5</code>), <code>1, 4</code> (with grouping keys <code>4, 6</code>), and <code>1</code> (with grouping key <code>7</code>). Note, the first group is always the result of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-distinct-values"><code>distinct-values</code></a> function, and the final group always contains the items that appear most frequently in the original population. </p></li><li><p> In <code>merge-when="count($group-a) le 3 and count(distinct-values(($group-a, $group-b) ! node-name(.))) eq 1"</code> no group has more than three items. Within each group, every item has the same node name. The effect is the same as specifying <code>group-by="node-name(.)"</code> then subgrouping with <code>split-when="count($group) = 3"</code>.</p></li><li><p><code>merge-when="some $a in $group-a, $b in $group-b satisfies tokenize($a/@class) = tokenize($b/@class)"</code> creates groups of elements. In a group with multiple items, every item has at least one other item that has at least one of its tokens in <code>@class</code>.</p></li><li><p><code>merge-when="some $a in $group-a, $b in $group-b satisfies abs($a - $b) le 2"</code> creates groups of numerals. Each numeral has at least one other numeral where the two differ by two or less. For example, <code>3, 9, 4, 1, 10, 6</code> is grouped as <code>(3, 4, 1, 6)</code> (with grouping keys <code>1, 3, 4, 6</code>) and <code>(9, 10)</code> (with grouping keys <code>2, 5</code>).</p></li><li><p><code>merge-when="some $a in $group-a, $b in $group-b satisfies abs($a - $b) le xs:dayTimeDuration('PT2H')"</code> creates groups of time values. Within groups of more than one item, each time value has at least one other time value that is two hours or less apart. For example, <code>xs:time("11:12:00Z"), xs:time("13:24:55Z"), xs:time("09:44:10Z"), xs:time("14:09:22Z"), xs:time("08:16:30Z")</code> is grouped as <code>(xs:time("11:12:00Z"), xs:time("09:44:10Z"), xs:time("08:16:30Z"))</code> (with grouping keys <code>1, 3, 5</code>) and <code>(xs:time("13:24:55Z"), xs:time("14:09:22Z"))</code> (with grouping keys <code>2, 4</code>).</p></li><li><p><code>merge-when="every $a in $group-a, $b in $group-b satisfies (string-to-codepoints($a) = string-to-codepoints($b))"</code> creates groups of strings. In groups with more than one member, each member shares at least one codepoint with every other member. For example, <code>("animal", "bison", "cat", "dog", "zebra")</code> is grouped as <code>("animal", "bison", "zebra")</code> (linking letters are a, i, n, and b), <code>("cat")</code> (although it shares letter a with "animal," the group has already been merged with "bison," which has no common letter with "cat"), and <code>("dog")</code>. The grouping keys are <code>1, 2, 5</code>, <code>3</code>, and <code>4</code>, respectively.</p></li></ul></li></ul><p>In all cases the order of items within each group is predictable, and reflects the original <a title="population order" class="termref" href="#dt-population-order">population order</a>, in that the items are processed in population order and each item is appended at the end of zero or more groups.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>As always, a different algorithm may be used if it achieves the same effect.</p></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-initial-item" title="initial item"></a>For each <a title="group" class="termref" href="#dt-group">group</a>, the item within the group that is first in <a title="population order" class="termref" href="#dt-population-order">population order</a> is known as the <b>initial item</b> of the group.<span class="definition">]</span></p><p>The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained in the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element is evaluated once for each of the <a title="group" class="termref" href="#dt-group">groups</a>, in <a title="processing order" class="termref" href="#dt-processing-order">processing order</a>. The sequences that result are concatenated, in <a title="processing order" class="termref" href="#dt-processing-order">processing order</a>, to form the result of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element. Within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, the <a title="context item" class="termref" href="#dt-context-item">context item</a> is the <a title="initial item" class="termref" href="#dt-initial-item">initial item</a> of the relevant group, the <a title="context position" class="termref" href="#dt-context-position">context position</a> is the position of this group in the <a title="processing order" class="termref" href="#dt-processing-order">processing order</a> of the groups, and the <a title="context size" class="termref" href="#dt-context-size">context size</a> is the number of groups This has the effect that within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, a call on <code>position()</code> takes successive values <code>1, 2, ... last()</code>.</p></div></div><div class="_diffs div1"><h2><a id="merging"></a>15 <a href="#merging" style="text-decoration: none">Merging</a></h2><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#func-current-merge-group">next</a> | <a href="#func-current-grouping-key">previous</a>)</p><ol><li><p> Composite merge keys are now allowed. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1684">1684</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1689">1689</a>&nbsp;9 January 2025]</i></p></li></ol></div><p>The <a href="#element-merge"><code>xsl:merge</code></a> instruction allows a sorted sequence of items to be constructed by merging several input sequences. Each input sequence <span class="verb">must</span> have a merge key (one or more atomic items that can be computed as a function of the items in the sequence); the input sequence <span class="verb">must</span> either already be sorted on the value of its merge keys, or pre-sorting on these values must be requested. The merge keys for the different input sequences <span class="verb">must</span> be compatible in the sense that key values from an item in one sequence are always comparable with key values from an item in a different sequence.</p><p>For example, if two log files contain details of events sorted by date and time, then the <a href="#element-merge"><code>xsl:merge</code></a> instruction can be used to combine these into a single sequence that is also sorted by date and time.</p><p>The data written to the output sequence can be computed in an arbitrary way from the data in the input sequences, provided it follows the ordering of the input sequences.</p><p>The <a href="#element-merge"><code>xsl:merge</code></a> instruction can be used to merge several sequences of items that all have the same structure (more precisely, sequences whose merge keys are computed in the same way): for example, log files created by the same application running on different machines in a server farm. Alternatively, <a href="#element-merge"><code>xsl:merge</code></a> can be used to merge sequences that have different structure (sequences whose merge keys are computed in different ways), provided that the computed merge keys are compatible: an example might be two log files created by different applications, using different XML vocabularies, that both contain timestamped events but represent the timestamp in different ways. The <a href="#element-merge-source"><code>xsl:merge-source</code></a> element represents a set of input sequences that follow common rules, including the rules for computing the merge key. The <a href="#element-merge"><code>xsl:merge</code></a> operation may take any number of <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements representing different rules for input sequences, and each <a href="#element-merge-source"><code>xsl:merge-source</code></a> element may describe any number (zero or more) of input sequences. The number of input sequences to the merging operation is thus fixed only at the time the <a href="#element-merge"><code>xsl:merge</code></a> instruction is evaluated, and <span class="verb">may</span> vary from one evaluation to another.</p><p>The following examples illustrate some of the possibilities. The detailed explanation of the constructs used follows later in this section.</p><div class="example"><div class="exampleHeader"><a id="d4e40997"></a><a id="d4e41001"></a>Example: Merging All the Files in a Collection</div><p>This example takes as input a homogeneous collection of XML log files each of which contains a sorted sequence of <code>event</code> elements with a <code>timestamp</code> attribute validated as an instance of <code>xs:dateTime</code>. It merges the events from the input files into a single sorted output file.</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:result-document href="merged-events.xml"&gt;
  &lt;events&gt;
    &lt;xsl:merge&gt;
      &lt;xsl:merge-source for-each-source="uri-collection('log-files')"
                        select="events/event"&gt;
        &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:copy-of select="current-merge-group()"/&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/events&gt;
&lt;/xsl:result-document&gt;</pre></div><p>The example assumes that there are several input files each of which has a structure similar to the following, in which the <code>timestamp</code> attribute has a typed value that is an instance of <code>xs:dateTime</code>:</p><div class="exampleInner"><pre xml:space="preserve">&lt;events&gt;
   &lt;event timestamp="2009-08-20T12:01:01Z"&gt;Transaction T1234 started&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:08Z"&gt;Transaction T1235 started&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:12Z"&gt;Transaction T1235 ended&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:15Z"&gt;Transaction T1234 ended&lt;/event&gt;
&lt;/events&gt;</pre></div><p>The output file will have the same structure, and will contain copies of all the <code>event</code> elements from all of the input files, in sorted order. Note that multiple events with the same timestamp can occur either within a single file or across multiple files: the order of appearance of these events in the output file corresponds to the order of the log files within the collection (which might or might not be predictable, depending on the implementation).</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e41027"></a><a id="d4e41031"></a>Example: Merging Two Heterogeneous Files</div><p>This example takes as input two log files with different structure, producing a single merged output in which the entries have a common structure:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:result-document href="merged-events.xml"&gt;
  &lt;events&gt;
    &lt;xsl:merge&gt;
      &lt;xsl:merge-source select="doc('log-file-1.xml')/events/event"&gt;
        &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-source select="doc('log-files-2.xml')/log/day/record"&gt;
        &lt;xsl:merge-key select="dateTime(../@date, time)"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:apply-templates select="current-merge-group()" 
                             mode="standardize-log-entry"/&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/events&gt;
&lt;/xsl:result-document&gt;</pre></div><p>Here the first input file has a structure similar to that shown in the previous example, while the second input has a different structure, of the form:</p><div class="exampleInner"><pre xml:space="preserve">&lt;log&gt;
  &lt;day date="2009-08-20"&gt;
    &lt;record&gt;
      &lt;time&gt;12:01:09-05:00&lt;/time&gt;
      &lt;message&gt;Temperature 15.4C&lt;/message&gt;
    &lt;/record&gt;
    &lt;record&gt;
      &lt;time&gt;12:03:00-05:00&lt;/time&gt;
      &lt;message&gt;Temperature 18.2C&lt;/message&gt;
    &lt;/record&gt;
  &lt;/day&gt;
&lt;/log&gt;</pre></div><p>The templates in mode <code>standardize-log-entry</code> convert the log entries to a common output format, for example:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:template match="event" mode="standardize-log-entry" 
                            as="schema-element(event)"&gt;
  &lt;xsl:copy-of select="." validation="preserve"/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="record" mode="standardize-log-entry" 
                             as="schema-element(event)"&gt;
  &lt;event timestamp="{dateTime(../@date, time)}" xsl:validation="strict"&gt;
    &lt;xsl:value-of select="message"/&gt;
  &lt;/event&gt;
&lt;/xsl:template&gt;</pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a href="#element-merge"><code>xsl:merge</code></a> instruction is designed to enable streaming of data, so that there is no need to allocate memory to hold the input sequences. However, it can also be used in cases where streamed processing is not possible, for example when the input needs to be sorted.</p></div><div class="_diffs div2"><h3><a id="merge-terminology"></a>15.1 <a href="#merge-terminology" style="text-decoration: none">Terminology for Merging</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-source-definition" title="merge source definition"></a>A <b>merge source definition</b> is the definition of one kind of input to the merge operation. It selects zero or more <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequences</a>, and it includes a <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a> to define how the <a title="merge key value" class="termref" href="#dt-merge-key-value">merge key values</a> are computed for each such merge input sequence.<span class="definition">]</span> A merge source definition corresponds to an <a href="#element-merge-source"><code>xsl:merge-source</code></a> element in the stylesheet.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-input-sequence" title="merge input sequence"></a>A <b>merge input sequence</b> is an arbitrary <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-sequence">sequence</a><sup><small>DM</small></sup> of items which is already sorted according to the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a> for the corresponding <a title="merge source definition" class="termref" href="#dt-merge-source-definition">merge source definition</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-key-specification" title="merge key specification"></a>A <b>merge key specification</b> consists of one or more adjacent <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements which together define how the <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequences</a> selected by a <a title="merge source definition" class="termref" href="#dt-merge-source-definition">merge source definition</a> are sorted. Each <a href="#element-merge-key"><code>xsl:merge-key</code></a> element defines one <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a>.<span class="definition">]</span> For example, a merge key specification for a log file might specify two merge key components, <code>date</code> and <code>time</code>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-key-component" title="merge key component"></a>A <b>merge key component</b> specifies one component of a <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>; it corresponds to a single <a href="#element-merge-key"><code>xsl:merge-key</code></a> element in the stylesheet.<span class="definition">]</span></p><p><span style="display: none;" class="delete_version"><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-key-value" title="merge key value"></a> For each item in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequence</a>, a value is computed for each <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> within the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>. The value computed for an item by using the <var>N</var>th <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> is referred to as the <var>N</var>th <b>merge key value</b> of that item.<span class="definition">]</span> A merge key value may be any sequence of atomic items (including an empty sequence).</span><span style="display: none;" class="add_version"><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-key-value" title="merge key value"></a> For each item in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequence</a>, a value is computed for each <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> within the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>. The value computed for an item by using the <var>N</var>th <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> is referred to as the <var>N</var>th <b>merge key value</b> of that item.<span class="definition">]</span> A merge key value may be any sequence of atomic items (including the empty sequence).</span><span class="modify_version"><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-key-value" title="merge key value"></a> For each item in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequence</a>, a value is computed for each <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> within the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>. The value computed for an item by using the <var>N</var>th <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> is referred to as the <var>N</var>th <b>merge key value</b> of that item.<span class="definition">]</span> A merge key value may be any sequence of atomic items (including <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence).</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-combined-merge-key-value" title="combined merge key value"></a> The ordered collection of <a title="merge key value" class="termref" href="#dt-merge-key-value">merge key values</a> computed for one item in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequence</a> (one for each <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> within the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>) is referred to as a <b>combined merge key value</b>.<span class="definition">]</span> Since each merge key value is (in general) a sequence of atomic items, the combined merge key value is modeled as an array of such sequences.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-activation" title="merge activation"></a>A <b>merge activation</b> is a single evaluation of the sequence constructor contained within the <a href="#element-merge-action"><code>xsl:merge-action</code></a> element, which occurs once for each distinct <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">combined merge key value</a>.<span class="definition">]</span></p></div><div class="_diffs div2"><h3><a id="merge-keys"></a>15.4 <a href="#merge-keys" style="text-decoration: none">Defining the Merge Keys</a></h3><p>The keys on which the input sequences are sorted are referred to as merge keys. If the attribute <code>sort-before-merge</code> has the value <code>yes</code>, the input sequences will be sorted into the correct sequence before the merge operation takes place (alternatively, the processor <span class="verb">may</span> use an algorithm that has the same effect as sorting followed by merging). If the attribute is absent or has the value <code>no</code>, then the input sequences <span class="verb">must</span> already be in the correct order.</p><p>The merge key for each type of input sequence (that is, for each <a href="#element-merge-source"><code>xsl:merge-source</code></a> element) is defined by a sequence of <a href="#element-merge-key"><code>xsl:merge-key</code></a> element children of the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element. Each <a href="#element-merge-key"><code>xsl:merge-key</code></a> element defines one merge key component. The syntax and semantics of an <a href="#element-merge-key"><code>xsl:merge-key</code></a> element are closely based on the rules for the <a href="#element-sort"><code>xsl:sort</code></a> element (<span>with minor exceptions noted below; the only difference in syntax is</span> the absence of the <code>stable</code> attribute); the <span>main</span> difference is that <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements do not cause a sort to take place, they merely declare the existing sort order of the input sequence. </p><p class="element-syntax"><a id="element-merge-key"></a><code>&lt;xsl:merge-key<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;lang? = { <var>language</var> }<br>&nbsp;&nbsp;order? = { "ascending" | "descending" }〔'ascending'〕<br>&nbsp;&nbsp;collation? = { <var>uri</var> }<br>&nbsp;&nbsp;case-order? = { "upper-first" | "lower-first" }<br>&nbsp;&nbsp;data-type? = { "text" | "number" | <var>eqname</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:merge-key&gt;</code></p><p>The <code>select</code> attribute and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> are mutually exclusive:</p><p><a id="err-XTSE3200"><span class="error">[ERR XTSE3200] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-merge-key"><code>xsl:merge-key</code></a> element with a <code>select</code> attribute has non-empty content. </p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">From XSLT 4.0, the <code>select</code> expression or contained sequence constructor may evaluate (after atomization) to an arbitrary sequence of atomic items. Previously, only a singleton atomic item or an empty sequence was allowed.</span><span style="display: none;" class="add_version">From XSLT 4.0, the <code>select</code> expression or contained sequence constructor may evaluate (after atomization) to an arbitrary sequence of atomic items. Previously, only a singleton atomic item or the empty sequence was allowed.</span><span class="modify_version">From XSLT 4.0, the <code>select</code> expression or contained sequence constructor may evaluate (after atomization) to an arbitrary sequence of atomic items. Previously, only a singleton atomic item or <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence was allowed.</span></p></div><p>The value of <var>N</var>th item in the merge key of an item <var>J</var> in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequence</a><var>S</var> is computed as follows, where <var>K</var> is the <var>N</var>th <a href="#element-merge-key"><code>xsl:merge-key</code></a> element of the relevant <a href="#element-merge-source"><code>xsl:merge-source</code></a>:</p><ol class="enumar"><li><p>If <var>K</var> has a <code>select</code> attribute, then the result of evaluating and atomizing that <code>select</code> expression;</p></li><li><p>If <var>K</var> contains a non-empty sequence constructor, then the result of evaluating and atomizing that sequence constructor;</p></li><li><p>Otherwise, the result of atomizing the context item.</p></li></ol><p>In each case the evaluation uses a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on <var>J</var>, or, if <code>streamable="yes"</code> is specified on the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element, a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on a snapshot of <var>J</var> (see <a href="../xslt-streaming-40/#streamable-merging">10 Streamable Merging</a><sup><small>SG</small></sup>). </p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that <code>position()</code> and <code>last()</code> return 1 (one). This differs from the way <a href="#element-sort"><code>xsl:sort</code></a> keys are evaluated, where <code>position()</code> is the position in the unsorted sequence, and <code>last()</code> is the size of the unsorted sequence.</p></div><p>The effect of the <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements is defined in terms of the rules for an equivalent sequence of <a href="#element-sort"><code>xsl:sort</code></a> elements: if the rules for sorting (see <a href="#sorting-process"><i>13.1.1 The Sorting Process</i></a>) with <code>stable="yes"</code> would place an item <var>A</var> before an item <var>B</var> in the <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted sequence</a> produced by the sorting process, then <var>A</var> must precede <var>B</var> in the input sequence to the merging process.</p><p>The merge keys of the various input sequences to a merge operation must be compatible with each other, since the merge operation will decide the ordering of the result sequence by comparing merge key values across input sequences. This means that across all the <a href="#element-merge-source"><code>xsl:merge-source</code></a> children of an <a href="#element-merge"><code>xsl:merge</code></a> instruction:</p><ul><li><p>Each <a href="#element-merge-source"><code>xsl:merge-source</code></a> element <span class="verb">must</span> have the same number of <a href="#element-merge-key"><code>xsl:merge-key</code></a> child elements; let this number be <var>N</var>.</p></li><li><p>For each integer <var>J</var> in 1..<var>N</var>, consider the set <var>S</var> of <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements that are in position <var>J</var> among the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of their parent <a href="#element-merge-source"><code>xsl:merge-source</code></a> element. For each attribute <var>A</var> in the set <code>lang</code>, <code>order</code>, <code>collation</code>, <code>case-order</code>, and <code>data-type</code> it must be the case that for any two elements <var>s1</var> and <var>s2</var> in <var>S</var>, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of attribute <var>A</var> on <var>s1</var> is the same as the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of attribute <var>A</var> on <var>s2</var>, where two attributes are said to have the same effective value if either (a) both attributes are absent, or (b) both attributes are present and the results of evaluating them (they are attribute value templates) are codepoint-equal. Furthermore, in the case of the <code>collation</code> attribute, the absolute collation URI must be the same after resolving against the base URI.</p></li></ul><p>If any of the attributes <code>lang</code>, <code>order</code>, <code>collation</code>, <code>case-order</code>, or <code>data-type</code> are <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a>, then their <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> are evaluated using the <a title="focus" class="termref" href="#dt-focus">focus</a> of the containing <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p><p><a id="err-XTSE2200"><span class="error">[ERR XTSE2200] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the number of <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of a <a href="#element-merge-source"><code>xsl:merge-source</code></a> element is not equal to the number of <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of another <a href="#element-merge-source"><code>xsl:merge-source</code></a> child of the same <a href="#element-merge"><code>xsl:merge</code></a> instruction. </p><p><a id="err-XTDE2210"><span class="error">[ERR XTDE2210] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if there are two <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements that occupy corresponding positions among the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of two different <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements and that have differing <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> for any of the attributes <code>lang</code>, <code>order</code>, <code>collation</code>, <code>case-order</code>, or <code>data-type</code>. Values are considered to differ if they have different <a title="effective value" class="termref" href="#dt-effective-value">effective values</a>. In the case of the <code>collation</code> attribute, the values are compared as absolute URIs after resolving against the base URI. The error <span class="verb">may</span> be raised statically if it is detected statically. </p><p><a id="err-XTDE2220"><span class="error">[ERR XTDE2220] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if any input sequence to an <a href="#element-merge"><code>xsl:merge</code></a> instruction contains two items that are not correctly sorted according to the merge key values defined on the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of the corresponding <a href="#element-merge-source"><code>xsl:merge-source</code></a> element, when compared using the collation rules defined by the attributes of the corresponding <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of the <a href="#element-merge"><code>xsl:merge</code></a> instruction, unless the attribute <code>sort-before-merge</code> is present with the value <code>yes</code>. </p><p><a id="err-XTTE2230"><span class="error">[ERR XTTE2230] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if some item selected by a particular merge key in one input sequence is not comparable using the XPath <code>le</code> operator with the corresponding item selected by the corresponding sort key in another input sequence. </p></div></div><div class="_diffs div1"><h2><a id="regular-expressions"></a>17 <a href="#regular-expressions" style="text-decoration: none">Regular Expressions</a></h2><p>The function library for XPath 3.0 defines several functions that make use of regular expressions:</p><ul><li><p><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-matches"><code>matches</code></a> returns a boolean result that indicates whether or not a string matches a given regular expression.</p></li><li><p><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-replace"><code>replace</code></a> takes a string as input and returns a string obtained by replacing all substrings that match a given regular expression with a replacement string.</p></li><li><p><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-tokenize"><code>tokenize</code></a> returns a sequence of strings formed by breaking a supplied input string at any separator that matches a given regular expression.</p></li><li><p><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-analyze-string"><code>analyze-string</code></a> returns a tree of nodes that effectively add markup to a string indicating the parts of the string that matched the regular expression, as well as its captured groups.</p></li></ul><p>These functions are described in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>.</p><p>Supplementing these functions, XSLT provides an instruction <a href="#element-analyze-string"><code>xsl:analyze-string</code></a>, which is defined in this section.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction predates the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-analyze-string"><code>analyze-string</code></a> function, and provides very similar functionality, though in a different way.</p></div><p>The regular expressions used by this instruction, and the flags that control the interpretation of these regular expressions, <span class="verb">must</span> conform to the syntax defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> (see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#regex-syntax">6.1 Regular expression syntax</a>), which is itself based on the syntax defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>.</p><p>As described in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#regex-syntax">6.1 Regular expression syntax</a>, the effect of processing a string using a regular expression is a sequence of non-overlapping matching segments, each of which is associated with a set of captured groups, represented as a map from a group number to a segment of the input string. The term <b>segment</b> here means a contiguous (and possibly empty) subsequence of characters from the input string, characterized by a starting position and ending position within that string.</p><div class="_diffs div2"><h3><a id="analyze-string"></a>17.1 <a href="#analyze-string" style="text-decoration: none">The <code>xsl:analyze-string</code> Instruction</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#func-regex-group">next</a> | <a href="#func-current-merge-key">previous</a>)</p><ol><li><p> The <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> and <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> elements within <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> may now take a <code>select</code> attribute in place of a contained sequence constructor. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/443">443</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/489">489</a>&nbsp;16 May 2023]</i></p></li><li><p> The rules for <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> have been adjusted to allow for new capabilities in regular expressions, such as zero-width assertions. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/998">998</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1856">1856</a>&nbsp;18 March 2025]</i></p></li></ol></div><p class="element-syntax"><a id="element-analyze-string"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:analyze-string<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;<b>regex</b> = { <var>string</var> }<br>&nbsp;&nbsp;flags? = { <var>string</var> }〔''〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-matching-substring">xsl:matching-substring</a>?, <a href="#element-non-matching-substring">xsl:non-matching-substring</a>?, <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br>&lt;/xsl:analyze-string&gt;</code></p><p class="element-syntax"><a id="element-matching-substring"></a><code>&lt;xsl:matching-substring<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:matching-substring&gt;</code></p><p class="element-syntax"><a id="element-non-matching-substring"></a><code>&lt;xsl:non-matching-substring<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:non-matching-substring&gt;</code></p><p>The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction takes as input a string (the result of evaluating the expression in the <code>select</code> attribute), a regular expression (the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>regex</code> attribute), and a set of flags.</p><p><span style="display: none;" class="delete_version">If the result of evaluating the <code>select</code> expression is an empty sequence, it is treated as a zero-length string. If the value is not a string, it is converted to a string by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</span><span style="display: none;" class="add_version">If the result of evaluating the <code>select</code> expression is the empty sequence, it is treated as a zero-length string. If the value is not a string, it is converted to a string by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</span><span class="modify_version">If the result of evaluating the <code>select</code> expression is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, it is treated as a zero-length string. If the value is not a string, it is converted to a string by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</span></p><p>The <code>flags</code> attribute may be used to control the interpretation of the regular expression. If the attribute is omitted, the effect is the same as supplying a zero-length string. This is interpreted in the same way as the <code>$flags</code> attribute of the functions <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-matches"><code>matches</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-replace"><code>replace</code></a>, and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-tokenize"><code>tokenize</code></a>. Specifically, if it contains the letter <code>m</code>, the match operates in multiline mode. If it contains the letter <code>s</code>, it operates in dot-all mode. If it contains the letter <code>i</code>, it operates in case-insensitive mode. If it contains the letter <code>x</code>, then whitespace within the regular expression is ignored. For more detailed specifications of these modes, see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> (<a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#flags">6.2 Flags</a>).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Because the <code>regex</code> attribute is an attribute value template, curly brackets within the regular expression must be doubled. For example, to match a sequence of one to five characters, write <code>regex=".{{1,5}}"</code>. For regular expressions containing many curly brackets it may be more convenient to use a notation such as <code>regex="{'[0-9]{1,5}[a-z]{3}[0-9]{1,2}'}"</code>, or to use a variable:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="regex" 
               expand-text="no"&gt;[0-9]{1,5}[a-z]{3}[0-9]{1,2}&lt;/xsl:variable&gt;
&lt;xsl:analyze-string regex="{$regex}"....</pre></div></div><p>The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction may have two child elements: <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> and <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>. Both elements are optional, and neither may appear more than once. At least one of them must be present. If both are present, the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> element must come first.</p><p>The content of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction must take one of the following forms:</p><ol class="enumar"><li><p>A single <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> instruction, followed by zero or more <a href="#element-fallback"><code>xsl:fallback</code></a> instructions</p></li><li><p>A single <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> instruction, followed by zero or more <a href="#element-fallback"><code>xsl:fallback</code></a> instructions</p></li><li><p>A single <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> instruction, followed by a single <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> instruction, followed by zero or more <a href="#element-fallback"><code>xsl:fallback</code></a> instructions</p></li></ol><p><a id="err-XTSE1130"><span class="error">[ERR XTSE1130] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction contains neither an <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> nor an <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> element. </p><p>Any <a href="#element-fallback"><code>xsl:fallback</code></a> elements among the children of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction are ignored by an processor supporting XSLT 2.0 or later, but allow fallback behavior to be defined when the stylesheet is used with an XSLT 1.0 processor operating with forwards-compatible behavior.</p><p>For the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> and <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> elements, the <code>select</code> attribute and the contained sequence constructor are mutually exclusive <span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span>.</p><p>This instruction is designed to process all the non-overlapping substrings of the input string that match the regular expression supplied: that is, the <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-disjoint-matching-segments">disjoint matching segments</a><sup><small>FO</small></sup> that result from processing the input string using the supplied regular expression and the supplied flags.</p><p><a id="err-XTDE1140"><span class="error">[ERR XTDE1140] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>regex</code> attribute does not conform to the <span class="verb">required</span> syntax for regular expressions, as specified in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. If the regular expression is known statically (for example, if the attribute does not contain any <a title="expression" class="termref" href="#dt-expression">expressions</a> enclosed in curly brackets) then the processor <span class="verb">may</span> raise the error as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p><p><a id="err-XTDE1145"><span class="error">[ERR XTDE1145] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>flags</code> attribute has a value other than the values defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. If the value of the attribute is known statically (for example, if the attribute does not contain any <a title="expression" class="termref" href="#dt-expression">expressions</a> enclosed in curly brackets) then the processor <span class="verb">may</span> raise the error as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p><p>Processing proceeds as follows. Let <var>M</var> be the sequence of <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-disjoint-matching-segments">disjoint matching segments</a><sup><small>FO</small></sup> that results from applying the regular expression to the input string, with the given flags, in order of their start position. Between any two adjacent matching segments <var>M<sub>1</sub></var> and <var>M<sub>2</sub></var>, if the end position of <var>M<sub>1</sub></var> is not the same as the start position of <var>M<sub>2</sub></var>, insert a non-matching segment comprising the characters from the input string between the end of <var>M<sub>1</sub></var> and the start of <var>M<sub>2</sub></var>. Similarly, insert a non-matching segment at the start of the sequence if the first matching segment is not positioned at the start of the input, and insert a non-matching segment at the end if the last matching segment is not positioned at the end of the input. The result is a sequence consisting of matching and non-matching segments, that together define a partitioning of the input string.</p><p>The instruction then processes each of these segments in turn. For a matching segment, it evaluates the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> child if it exists. For a non-matching segment, it evaluates the <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> if it exists. The child <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> or <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> is evaluated by evaluating its <code>select</code> attribute or its contained sequence constructor. The context item for this evaluation is the string value of the matching or non-matching segment (as an instance of <code>xs:string</code>); the context position is the position of this segment within the sequence of matching and non-matching segments, and the context size is the number of segments.</p><p>If the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> or <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> child is absent, then processing proceeds as if the element were present with empty content and no <code>select</code> attribute. That is, the corresponding segment produces no output.</p></div></div><div class="_diffs div1"><h2><a id="diagnostics"></a>23 <a href="#diagnostics" style="text-decoration: none">Diagnostics</a></h2><div class="_diffs div2"><h3><a id="message"></a>23.1 <a href="#message" style="text-decoration: none">Messages</a></h3><p class="element-syntax"><a id="element-message"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:message<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;terminate? = { <var>boolean</var> }〔'no'〕<br>&nbsp;&nbsp;error-code? = { <var>eqname</var> }〔'Q{http://www.w3.org/2005/xqt-errors}XTMM9000'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:message&gt;</code></p><p>The <a href="#element-message"><code>xsl:message</code></a> instruction sends a message in an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> way. The <a href="#element-message"><code>xsl:message</code></a> instruction causes the creation of a new document, which is typically serialized and output to an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> destination. The result of the <a href="#element-message"><code>xsl:message</code></a> instruction is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p><p>The content of the message may be specified by using either or both of the optional <code>select</code> attribute and the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the content of the <a href="#element-message"><code>xsl:message</code></a> instruction.</p><p>If the <a href="#element-message"><code>xsl:message</code></a> instruction contains a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, then the sequence obtained by evaluating this sequence constructor is used to construct the content of the new document node, as described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>.</p><p>If the <a href="#element-message"><code>xsl:message</code></a> instruction has a <code>select</code> attribute, then the value of the attribute <span class="verb">must</span> be an XPath expression. The effect of the <a href="#element-message"><code>xsl:message</code></a> instruction is then the same as if a single <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction with this <code>select</code> attribute were added to the start of the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><p>If the <a href="#element-message"><code>xsl:message</code></a> instruction has no content and no <code>select</code> attribute, then an empty message is produced.</p><p>The tree produced by the <a href="#element-message"><code>xsl:message</code></a> instruction is not technically a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>. The tree has no URI and processors are not <span class="verb">required</span> to make the tree accessible to applications.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In many cases, the XML document produced using <a href="#element-message"><code>xsl:message</code></a> will consist of a document node owning a single text node. However, it may contain a more complex structure.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>An implementation might implement <a href="#element-message"><code>xsl:message</code></a> by popping up an alert box or by writing to a log file. Because the order of execution of instructions is implementation-defined, the order in which such messages appear is not predictable.</p></div><p>The <code>terminate</code> attribute is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>.</p><p>If the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>terminate</code> attribute is <code>yes</code>, then the <a title="processor" class="termref" href="#dt-processor">processor</a><span class="verb">must</span> raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> after sending the message. This error may be caught in the same way as any other dynamic error using <a href="#element-catch"><code>xsl:catch</code></a>. The default value is <code>no</code>. Note that because the order of evaluation of instructions is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>, this gives no guarantee that any particular instruction will or will not be evaluated before processing terminates.</p><p>The optional <code>error-code</code> attribute (also interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>) may be used to indicate the error code associated with the message. This may be used irrespective of the value of <code>terminate</code>. The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the error code attribute is expected to be an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If no error code is specified, or if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is not a valid EQName, the error code will have local part <code>XTMM9000</code> and namespace URI <code>http://www.w3.org/2005/xqt-errors</code>. User-defined error codes <span class="verb">should</span> be in a namespace other than <code>http://www.w3.org/2005/xqt-errors</code>. When the value of <code>terminate</code> is <code>yes</code>, the error code may be matched in an <a href="#element-catch"><code>xsl:catch</code></a> element to catch the error and cause processing to continue normally.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>XPath 4.0 allows an <a title="EQName" class="termref" href="#dt-eqname">EQName</a> to include both a prefix and a URI, for example <code>error-code="{http://example.com/ns}my:error-code"</code>.</p></div><p><a id="err-XTMM9000"><span class="error">[ERR XTMM9000] </span></a>When a transformation is terminated by use of <code>&lt;xsl:message terminate="yes"/&gt;</code>, the effect is the same as when a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> occurs during the transformation. The default error code is <code>XTMM9000</code>; this may be overridden using the <code>error-code</code> attribute of the <a href="#element-message"><code>xsl:message</code></a> instruction. </p><div class="example"><div class="exampleHeader"><a id="d4e49235"></a><a id="d4e49239"></a>Example: Localizing Messages</div><p>One convenient way to do localization is to put the localized information (message text, etc.) in an XML document, which becomes an additional input file to the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. For example, suppose messages for a language <code><var>L</var></code> are stored in an XML file <code>resources/<var>L</var>.xml</code> in the form:</p><div class="exampleInner"><pre xml:space="preserve">&lt;messages&gt;
  &lt;message name="problem"&gt;A problem was detected.&lt;/message&gt;
  &lt;message name="error"&gt;An error was detected.&lt;/message&gt;
&lt;/messages&gt;</pre></div><p>Then a stylesheet could use the following approach to localize messages:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:param name="lang" select="'en'"/&gt;
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message select="string($messages/message[@name=$name])"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</pre></div></div><p>Any <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> that occurs while evaluating the <code>select</code> expression or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and any <a title="serialization error" class="termref" href="#dt-serialization-error">serialization error</a> that occurs while processing the result, does not cause the transformation to fail; at worst, it means that no message is output, or that the only message that is output is one that relates to the error that occurred.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An example of such an error is the serialization error that occurs when processing the instruction <code>&lt;xsl:message select="@code"/&gt;</code> (on the grounds that free-standing attributes cannot be serialized). Making such errors recoverable means that it is implementation-defined whether or not they are raised to the user and whether they cause termination of the transformation. If the processor chooses to recover from the error, the content of any resulting message is implementation-dependent.</p><p>One possible recovery action is to include a description of the error in the generated message text.</p></div></div><div class="_diffs div2"><h3><a id="assertions"></a>23.2 <a href="#assertions" style="text-decoration: none">Assertions</a></h3><p>The <a href="#element-assert"><code>xsl:assert</code></a> instruction is used to assert that the value of a particular expression is <code>true</code>; if the value of the expression is <code>false</code>, and assertions are enabled, then a dynamic error occurs.</p><p class="element-syntax"><a id="element-assert"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:assert<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;error-code? = { <var>eqname</var> }〔'Q{http://www.w3.org/2005/xqt-errors}XTMM9001'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:assert&gt;</code></p><p>By default, assertions are disabled.</p><p>An implementation <span class="verb">must</span> provide an external mechanism to enable or disable assertion checking. This may work either statically or dynamically, and may be at the level of the stylesheet as a whole, or at the level of an individual package, or otherwise. The detail of such mechanisms is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p>If assertion checking is enabled, the instruction is evaluated as follows:</p><ol class="enumar"><li><p>The expression in the <code>test</code> attribute is evaluated. If the effective boolean value of the result is <code>true</code>, the assertion succeeds, and no further action is taken. If the effective boolean value is <code>false</code>, or if a dynamic error occurs during evaluation of the expression, then the assertion fails.</p></li><li><p>If the assertion fails, then the effect of the instruction is governed by the rules for evaluation of an <a href="#element-message"><code>xsl:message</code></a> instruction with the same <code>select</code> attribute, <code>error-code</code> attribute, and contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and with the value <code>terminate="yes"</code>. However, the default error code if the <code>error-code</code> attribute is omitted is <code>XTMM9001</code> rather than <code>XTMM9000</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>To the extent that the behavior of <a href="#element-message"><code>xsl:message</code></a> is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, this rule does not prevent an implementation treating <a href="#element-assert"><code>xsl:assert</code></a> and <a href="#element-message"><code>xsl:message</code></a> differently.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>If evaluation of the <code>test</code> expression fails with a dynamic error, the effect is exactly the same as if the evaluation returns <code>false</code>, including the fact that the instruction fails with error code <code>XTMM9001</code>.</p></div></li><li><p>If an assertion fails, then the following sibling instructions of the <a href="#element-assert"><code>xsl:assert</code></a> instruction are not evaluated.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that <a href="#element-assert"><code>xsl:assert</code></a> can be used (rather like <a href="#element-if"><code>xsl:if</code></a> and <a href="#element-choose"><code>xsl:choose</code></a>) to prevent subsequent instructions from executing if a particular precondition is not true, which might be useful if the subsequent instructions have side-effects (for example, by calling extension functions) or if they can fail in uncatchable ways (for example, non-terminating recursion). It is worth noting that there are limits to this guarantee. It does not ensure, for example, that when an assertion within a template fails, the following siblings of the <a href="#element-call-template"><code>xsl:call-template</code></a> instruction that invokes that template will not be evaluated; nor does it ensure that if an assertion fails while processing the first item of a sequence using <a href="#element-for-each"><code>xsl:for-each</code></a>, then subsequent items in the sequence will not be processed. </p></div></li></ol><p><a id="err-XTMM9001"><span class="error">[ERR XTMM9001] </span></a>When a transformation is terminated by use of <a href="#element-assert"><code>xsl:assert</code></a>, the effect is the same as when a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> occurs during the transformation. The default error code is <code>XTMM9001</code>; this may be overridden using the <code>error-code</code> attribute of the <a href="#element-assert"><code>xsl:assert</code></a> instruction. </p><p>As with any other dynamic error, an error caused by an assertion failing may be trapped using <a href="#element-try"><code>xsl:try</code></a>: see <a href="#try-catch"><i>8.4 Try/Catch</i></a>.</p><p>The result of the <a href="#element-assert"><code>xsl:assert</code></a> instruction is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p><div class="example"><div class="exampleHeader"><a id="d4e49424"></a><a id="d4e49428"></a>Example: Using Assertions with Static Parameters</div><p>The following example shows a stylesheet function that checks that the value of its supplied argument is in range. The check is performed only if the <a title="static parameter" class="termref" href="#dt-static-parameter">static parameter</a><code>$DEBUG</code> is set to <code>true</code>.</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:param name="DEBUG" as="xs:boolean" select="false()" 
           static="yes" required="no"/&gt;
&lt;xsl:function name="f:days-elapsed" as="xs:integer"&gt;
  &lt;xsl:param name="date" as="xs:date"/&gt;
  &lt;xsl:assert use-when="$DEBUG" test="$date lt current-date()"/&gt;
  &lt;xsl:sequence select="(current-date() - $since) 
                            div xs:dayTimeDuration('PT1D')"/&gt;
&lt;/xsl:function&gt;</pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Implementations should avoid optimizing <a href="#element-assert"><code>xsl:assert</code></a> instructions away. As a guideline, if the result of a sequence constructor is required by the transformation, the implementation should ensure that all <a href="#element-assert"><code>xsl:assert</code></a> instructions in that sequence constructor are evaluated. Conversely, if the result of a sequence constructor is not required by the transformation, its <a href="#element-assert"><code>xsl:assert</code></a> instructions should not be evaluated.</p><p>This guidance is not intended to prevent optimizations such as lazy evaluation, where evaluation of a sequence constructor may finish early, as soon as enough information is available to evaluate the containing instruction.</p></div><p>An implementation <span class="verb">may</span> provide a user option allowing a processor to treat assertions as being true without explicit checking. This option <span class="verb">must not</span> be enabled by default. If such an option is in force, the effect of any assertion not being true is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, given the assertion <code>&lt;xsl:assert test="count(//title)=1"/&gt;</code>, a processor might generate code for the expression <code>&lt;xsl:value-of select="//title"/&gt;</code> that stops searching for <code>title</code> elements after finding the first one. In the event that the source document contains more than one <code>title</code>, execution of the stylesheet may fail in arbitrary ways, or it may produce incorrect output.</p></div></div></div><div class="_diffs div1"><h2><a id="extension"></a>24 <a href="#extension" style="text-decoration: none">Extensibility and Fallback</a></h2><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#extension-attributes">next</a> | <a href="#array-construction">previous</a>)</p><ol><li><p> Functions that accept a lexical QName as an argument, such as <a href="#func-key"><code>key</code></a>, <a href="#func-function-available"><code>function-available</code></a>, <a href="#func-element-available"><code>element-available</code></a>, <a href="#func-type-available"><code>type-available</code></a>, <a href="#func-system-property"><code>system-property</code></a>, <a href="#func-accumulator-before"><code>accumulator-before</code></a>, and <a href="#func-accumulator-after"><code>accumulator-after</code></a>, now have the option of supplying an <code>xs:QName</code> value instead. [This change was in the editor's draft accepted by the WG as its baseline when it started work.] <i>&nbsp;&nbsp;[&nbsp;&nbsp;1 January 2022]</i></p></li></ol></div><p>XSLT allows three kinds of extension: extension attributes, extension instructions, and extension functions.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-extension-attribute" title="extension attribute"></a>An <b>extension attribute</b> is an attribute appearing on an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>, where the name of the attribute is in a non-null namespace other than the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-extension-instruction" title="extension instruction"></a>An <b>extension instruction</b> is an element within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that is in a namespace (not the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>) designated as an extension namespace.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-extension-function" title="extension function"></a>An <b>extension function</b> is a named function introduced to the static or dynamic context by mechanisms outside the scope of this specification.<span class="definition">]</span></p><p>This specification does not define any mechanism for creating or binding implementations of <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a>, <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>, or <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a>, and it is not <span class="verb">required</span> that implementations support any such mechanism. Such mechanisms, if they exist, are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. Therefore, an XSLT stylesheet that must be portable between XSLT implementations cannot rely on particular extensions being available. XSLT provides mechanisms that allow an XSLT stylesheet to determine whether the implementation makes particular extensions available, and to specify what happens if those extensions are not available. If an XSLT stylesheet is careful to make use of these mechanisms, it is possible for it to take advantage of extensions and still retain portability.</p><p><a id="err-XTSE0085"><span class="error">[ERR XTSE0085] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a> in the name of any <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attribute</a>, <a title="extension function" class="termref" href="#dt-extension-function">extension function</a>, or <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>, other than a function or instruction defined in this specification or in a normatively referenced specification. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a prefix bound to a reserved namespace in the <code>[xsl:]extension-element-prefixes</code> attribute. </p><div class="_diffs div2"><h3><a id="extension-instruction"></a>24.3 <a href="#extension-instruction" style="text-decoration: none">Extension Instructions</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#creating-result-trees">next</a> | <a href="#extension-attributes">previous</a>)</p><ol><li><p> It is possible to invoke a named template using an extension instruction, specifically, an element whose name matches the name of the named template. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/168">168</a>&nbsp;&nbsp;30 September 2022]</i></p></li></ol></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-extension-namespace" title="extension namespace"></a>The <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> mechanism allows namespaces to be designated as <b>extension namespaces</b>. When a namespace is designated as an extension namespace and an element with a name from that namespace occurs in a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, then the element is treated as an <a title="instruction" class="termref" href="#dt-instruction">instruction</a> rather than as a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>.<span class="definition">]</span> The namespace determines the semantics of the instruction.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Since an element that is a child of an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element is not occurring <em>in a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a></em>, <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> (see <a href="#user-defined-top-level"><i>3.6.4 User-defined Data Elements</i></a>) are not extension elements as defined here, and nothing in this section applies to them.</p></div><p>In XSLT 4.0 it is possible to use extension instructions to invoke named templates: see <a href="#invoking-templates-with-extension-instructions"><i>10.1.3 Invoking Named Templates using Extension Instructions</i></a>. </p><div class="_diffs div3"><h4><a id="fallback"></a>24.3.3 <a href="#fallback" style="text-decoration: none">Fallback</a></h4><p class="element-syntax"><a id="element-fallback"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:fallback&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:fallback&gt;</code></p><p>The content of an <a href="#element-fallback"><code>xsl:fallback</code></a> element is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and when performing fallback, the value returned by the <a href="#element-fallback"><code>xsl:fallback</code></a> element is the result of evaluating this sequence constructor.</p><p>When not performing fallback, evaluating an <a href="#element-fallback"><code>xsl:fallback</code></a> element returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence: the content of the <a href="#element-fallback"><code>xsl:fallback</code></a> element is not evaluated.</p><p>There are two situations where a <a title="processor" class="termref" href="#dt-processor">processor</a> performs fallback: when an extension instruction that is not available is evaluated, and when an instruction in the XSLT namespace, that is not defined in XSLT 3.0, is evaluated within a region of the stylesheet for which <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> is enabled.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Fallback processing is not invoked in other situations, for example it is not invoked when an XPath expression uses unrecognized syntax or contains a call to an unknown function. To handle such situations dynamically, the stylesheet should call functions such as <a href="#func-system-property"><code>system-property</code></a> and <a href="#func-function-available"><code>function-available</code></a> to decide what capabilities are available.</p></div><p><a id="err-XTDE1450"><span class="error">[ERR XTDE1450] </span></a>When a <a title="processor" class="termref" href="#dt-processor">processor</a> performs fallback for an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> that is not recognized, if the instruction element has one or more <a href="#element-fallback"><code>xsl:fallback</code></a> children, then the content of each of the <a href="#element-fallback"><code>xsl:fallback</code></a> children <span class="verb">must</span> be evaluated; it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if it has no <a href="#element-fallback"><code>xsl:fallback</code></a> children. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>This is different from the situation with unrecognized <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>. As explained in <a href="#forwards"><i>3.9 Forwards Compatible Processing</i></a>, an unrecognized XSLT element appearing within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is a static error unless (a) <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> is enabled, and (b) the instruction has an <a href="#element-fallback"><code>xsl:fallback</code></a> child.</p></div></div></div></div><div class="_diffs div1"><h2><a id="result-trees"></a>25 <a href="#result-trees" style="text-decoration: none">Transformation Results</a></h2><p>The output of a transformation includes a <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> and zero or more <a title="secondary result" class="termref" href="#dt-secondary-result">secondary results</a>.</p><p>The way in which these results are delivered to an application is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p>Serialization of results is described further in <a href="#serialization"><i>26 Serialization</i></a></p><div class="_diffs div2"><h3><a id="creating-result-trees"></a>25.1 <a href="#creating-result-trees" style="text-decoration: none">Creating Secondary Results</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#func-current-output-uri">next</a> | <a href="#extension-instruction">previous</a>)</p><ol><li><p> A new serialization parameter <code>escape-solidus</code> is provided to control whether the character <code>/</code> is escaped as <code>\/</code> by the JSON serialization method. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/530">530</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/534">534</a>&nbsp;9 June 2023]</i></p></li><li><p> The input to the serializer can be defined using the <code>select</code> attribute of <a href="#element-result-document"><code>xsl:result-document</code></a> as an alternative to using a sequence constructor. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1534">1534</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1549">1549</a>&nbsp;12 November 2024]</i></p></li><li><p> A new serialization parameter <code>canonical</code> is available to give control over serialization of XML, XHTML, and JSON. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/938">938</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2259">2259</a>&nbsp;2 November 2025]</i></p></li><li><p> A new serialization parameter <code>json-lines</code> is available to enable output as one JSON value per line. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1538">1538</a>&nbsp;PRs <a href="https://github.com/qt4cg/qtspecs/pull/1497">1497</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/pull/1546">1546</a>&nbsp;13 November 2024]</i></p></li></ol></div><p class="element-syntax"><a id="element-result-document"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:result-document<br>&nbsp;&nbsp;format? = { <var>eqname</var> }<br>&nbsp;&nbsp;href? = { <var>uri</var> }<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;method? = { "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | <var>eqname</var> }<br>&nbsp;&nbsp;allow-duplicate-names? = { <var>boolean</var> }<br>&nbsp;&nbsp;build-tree? = { <var>boolean</var> }<br>&nbsp;&nbsp;byte-order-mark? = { <var>boolean</var> }<br>&nbsp;&nbsp;canonical? = { <var>boolean</var> }<br>&nbsp;&nbsp;cdata-section-elements? = { <var>eqnames</var> }<br>&nbsp;&nbsp;doctype-public? = { <var>string</var> }<br>&nbsp;&nbsp;doctype-system? = { <var>string</var> }<br>&nbsp;&nbsp;encoding? = { <var>string</var> }<br>&nbsp;&nbsp;escape-solidus? = { <var>boolean</var> }<br>&nbsp;&nbsp;escape-uri-attributes? = { <var>boolean</var> }<br>&nbsp;&nbsp;html-version? = { <var>decimal</var> }<br>&nbsp;&nbsp;include-content-type? = { <var>boolean</var> }<br>&nbsp;&nbsp;indent? = { <var>boolean</var> }<br>&nbsp;&nbsp;item-separator? = { <var>string</var> }<br>&nbsp;&nbsp;json-lines? = { <var>boolean</var> }<br>&nbsp;&nbsp;json-node-output-method? = { "xml" | "html" | "xhtml" | "text" | <var>eqname</var> }<br>&nbsp;&nbsp;media-type? = { <var>string</var> }<br>&nbsp;&nbsp;normalization-form? = { "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | <var>nmtoken</var> }<br>&nbsp;&nbsp;omit-xml-declaration? = { <var>boolean</var> }<br>&nbsp;&nbsp;parameter-document? = { <var>uri</var> }<br>&nbsp;&nbsp;standalone? = { <var>boolean</var> | "omit" }<br>&nbsp;&nbsp;suppress-indentation? = { <var>eqnames</var> }<br>&nbsp;&nbsp;undeclare-prefixes? = { <var>boolean</var> }<br>&nbsp;&nbsp;use-character-maps? = <var>eqnames</var><br>&nbsp;&nbsp;output-version? = { <var>nmtoken</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:result-document&gt;</code></p><p>The <a href="#element-result-document"><code>xsl:result-document</code></a> instruction is used to create a <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>.</p><p>The <code>select</code> attribute and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> are mutually exclusive; if the <code>select</code> attribute is present then the sequence constructor must be empty, and if the sequence constructor is non-empty then the <code>select</code> attribute must be absent <span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span>. The value of the <code>select</code> attribute or the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is referred to as the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a>.</p><p>As with the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> of the transformation, a <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a> may be delivered to the calling application in three ways (see <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a>):</p><ol class="enumar"><li><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> may be delivered <em>as is</em>.</p></li><li><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> may be used to construct a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> by invoking the process of <a href="https://qt4cg.org/specifications/xslt-xquery-serialization-40/#sequence-normalization">sequence normalization</a><sup><small>SE</small></sup>.</p></li><li><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> may be serialized to a sequence of octets (which may then, optionally, be saved to a persistent storage location).</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The name of the instruction, <a href="#element-result-document"><code>xsl:result-document</code></a>, is a little misleading. The instruction does not necessarily deliver either an XML document tree nor a serialized XML document. Instead, for example, it might deliver an array, a map, serialized JSON, or a sequence of atomic items.</p></div><p>The decision whether or not to serialize the raw result depends on the <a title="processor" class="termref" href="#dt-processor">processor</a> and on the way it is invoked. This is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, and it is not controlled by anything in the stylesheet.</p><p>If the result is not serialized, then the decision whether to return the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> or to construct a tree depends on the effective value of the <code>build-tree</code> attribute. If the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>build-tree</code> attribute is <code>yes</code>, then a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is created by invoking the process of <a href="https://qt4cg.org/specifications/xslt-xquery-serialization-40/#sequence-normalization">sequence normalization</a><sup><small>SE</small></sup>. Conversely, if the result <em>is</em> serialized, then the decision whether or not to construct a tree depends on the choice of serialization method, and the <code>build-tree</code> attribute is then ignored. For example, with <code>method="xml"</code> a tree is always constructed, whereas with <code>method="json"</code> a tree is never constructed. </p><p>The <a href="#element-result-document"><code>xsl:result-document</code></a> instruction defines a URI that may be used to identify the <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>. The instruction may optionally specify the output format to be used for serializing the result.</p><p>Technically, the result of evaluating the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. This means it does not contribute anything to the result of the sequence constructor it is part of.</p><p>The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>format</code> attribute, if specified, <span class="verb">must</span> be an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. The value is expanded using the namespace declarations in scope for the <a href="#element-result-document"><code>xsl:result-document</code></a> element. The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a><span class="verb">must</span> match the expanded QName of a named <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. This identifies the <a href="#element-output"><code>xsl:output</code></a> declaration that will control the serialization of the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> (see <a href="#serialization"><i>26 Serialization</i></a>), if the result tree is serialized. If the <code>format</code> attribute is omitted, the unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> is used to control serialization of the result tree.</p><p><a id="err-XTDE1460"><span class="error">[ERR XTDE1460] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>format</code> attribute is not a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if it does not match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> in the containing <a title="package" class="termref" href="#dt-package">package</a>. If the processor is able to detect the error statically (for example, when the <code>format</code> attribute contains no curly brackets), then the processor <span class="verb">may</span> optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The only way to select the unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> is to omit the <code>format</code> attribute.</p></div><p>The <code>parameter-document</code> attribute allows serialization parameters to be supplied in an external document. The external document must contain an <code>output:serialization-parameters</code> element with the format described in <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a> section <a href="../xslt-xquery-serialization-40/#serparams-in-xdm-instance">3.1 Setting Serialization Parameters by Means of a Parameter Document</a>, and the parameters are interpreted as described in that specification.</p><p>If present, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the URI supplied in the <code>parameter-document</code> attribute is dereferenced, after resolution against the base URI of the <a href="#element-result-document"><code>xsl:result-document</code></a> element if it is a relative reference. The parameter document <span class="verb">should</span> be read during run-time evaluation of the stylesheet. If the location of the stylesheet at development time is different from the deployed location, any relative reference should be resolved against the deployed location. A serialization error occurs if the result of dereferencing the URI is ill-formed or invalid; but if no document can be found at the specified location, the attribute <code>should</code> be ignored.</p><p>A serialization parameter specified in the <code>parameter-document</code> takes precedence over a value supplied directly as an attribute of <a href="#element-result-document"><code>xsl:result-document</code></a>, which in turn takes precedence over a value supplied in the selected output definition, except that the values of the <code>cdata-section-elements</code> and <code>suppress-indentation</code> attributes are merged in the same way as when multiple <a href="#element-output"><code>xsl:output</code></a> declarations are merged.</p><p>The attributes <code>method</code>, <code>allow-duplicate-names</code>, <code>build-tree</code>, <code>byte-order-mark</code><code>canonical</code>, <code>cdata-section-elements</code>, <code>doctype-public</code>, <code>doctype-system</code>, <code>encoding</code>, <code>escape-solidus</code><code>escape-uri-attributes</code>, <code>html-version</code>, <code>indent</code>, <code>item-separator</code>, <code>json-lines</code>, <code>json-node-output-method</code>, <code>media-type</code>, <code>normalization-form</code>, <code>omit-xml-declaration</code>, <code>standalone</code>, <code>suppress-indentation</code>, <code>undeclare-prefixes</code>, <code>use-character-maps</code>, and <code>output-version</code> may be used to override attributes defined in the selected <a title="output definition" class="termref" href="#dt-output-definition">output definition</a>.</p><p>With the exception of <code>use-character-maps</code>, these attributes are all defined as <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a>, so their values may be set dynamically. For any of these attributes that is present on the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute overrides or supplements the corresponding value from the output definition. This works in the same way as when one <a href="#element-output"><code>xsl:output</code></a> declaration overrides another. Some of the attributes have more specific rules:</p><ul><li><p>In the case of <code>cdata-section-elements</code> and <code>suppress-indentation</code>, the value of the serialization parameter is the union of the expanded names of the elements named in this instruction and the elements named in the selected output definition.</p></li><li><p>In the case of <code>use-character-maps</code>, the character maps referenced in this instruction supplement and take precedence over those defined in the selected output definition.</p></li><li><p>In the case of <code>doctype-public</code> and <code>doctype-system</code>, setting the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute to a zero-length string has the effect of overriding any value for these attributes obtained from the output definition. The corresponding serialization parameter is not set (is “absent”).</p></li><li><p>In the case of <code>item-separator</code>, setting the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute to the special value <code>"#absent"</code> has the effect of overriding any value for this attribute obtained from the output definition. The corresponding serialization parameter is not set (is “absent”). It is not possible to set the value of the serialization parameter to the literal 7-character string <code>"#absent"</code>. </p></li><li><p>In all other cases, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of an attribute actually present on this instruction takes precedence over the value defined in the selected output definition.</p></li></ul><p>In the case of the attributes <code>method</code>, <code>json-node-output-method</code><code>cdata-section-elements</code>, <code>suppress-indentation</code>, and <code>use-character-maps</code>, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute contains an <a title="EQName" class="termref" href="#dt-eqname">EQName</a> or a space-separated list of <a title="EQName" class="termref" href="#dt-eqname">EQNames</a>. Where lexical QNames are used in these attributes (whether prefixed or unprefixed), the namespace context is established in the same way as for the corresponding attributes of <a href="#element-output"><code>xsl:output</code></a>: see <a href="#id-default-serialization-parameters"><i>26.2 Serialization parameters</i></a>.</p><p>The <code>output-version</code> attribute on the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction overrides the <code>version</code> attribute on <a href="#element-output"><code>xsl:output</code></a> (it has been renamed because <code>version</code> is available with a different meaning as a standard attribute: see <a href="#standard-attributes"><i>3.3 Standard Attributes</i></a>). In all other cases, attributes correspond if they have the same name.</p><p>There are some serialization parameters that apply to some output methods but not to others. For example, the <code>indent</code> attribute has no effect on the <code>text</code> output method. If a value is supplied for an attribute that is inapplicable to the output method, its value is not passed to the serializer. The processor <span class="verb">may</span> validate the value of such an attribute, but is not <span class="verb">required</span> to do so.</p><p>The <code>item-separator</code> serialization parameter is used when the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> is used to construct a result tree by applying sequence normalization, and it is also used when the result tree is serialized. For example, if the sequence constructor delivers a sequence of integers, and the <code>text</code> serialization method is used, then the result of serialization will be a string obtained by converting each integer to a string, and separating the strings using the defined <code>item-separator</code>.</p><p>The <code>href</code> attribute is optional. The default value is the zero-length string. The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute <span class="verb">must</span> be a <a title="URI Reference" class="termref" href="#dt-uri-reference">URI Reference</a>, which may be absolute or relative. If it is relative, then it is resolved against the <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>. There <span class="verb">may</span> be <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> restrictions on the form of absolute URI that may be used, but the implementation is not <span class="verb">required</span> to enforce any restrictions. Any valid relative URI reference <span class="verb">must</span> be accepted. Note that the zero-length string is a valid relative URI reference.</p><p>If the implementation provides an API to access <a title="secondary result" class="termref" href="#dt-secondary-result">secondary results</a>, then it <span class="verb">must</span> allow a secondary result to be identified by means of the absolutized value of the <code>href</code> attribute. In addition, if a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is constructed (that is, if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of <code>build-tree</code> is <code>yes</code>), then this value is used as the base URI of the document node at the root of the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The base URI of the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is not necessarily the same thing as the URI of its serialized representation on disk, if any. For example, a server (or browser client) might store final result trees only in memory, or in an internal disk cache. As long as the processor satisfies requests for those URIs, it is irrelevant where they are actually written on disk, if at all.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>It will often be the case that one <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> contains links to another final result tree produced during the same transformation, in the form of a relative URI reference. The mechanism of associating a URI with a final result tree has been chosen to allow the integrity of such links to be preserved when the trees are serialized.</p><p>As well as being potentially significant in any API that provides access to final result trees, the base URI of the new document node is relevant if the final result tree, rather than being serialized, is supplied as input to a further transformation.</p></div><p>The optional attributes <code>type</code> and <code>validation</code> may be used on the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction to validate the contents of a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>, and to determine the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that elements and attributes within the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> will carry. The permitted values and their semantics are described in <a href="#validating-document-nodes"><i>25.4.2 Validating Document Nodes</i></a>. Any such validation is applied to the document node produced as the result of <a href="https://qt4cg.org/specifications/xslt-xquery-serialization-40/#sequence-normalization">sequence normalization</a><sup><small>SE</small></sup>. If sequence normalization does not take place (typically because the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> is delivered to the application directly, or because the selected serialization method does not involve sequence normalization) then the <code>validation</code> and <code>type</code> attributes are ignored.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Validation applies after inserting item separators as determined by the <code>item-separator</code> serialization parameter, and an inappropriate choice of <code>item-separator</code> may cause the result to become invalid.</p></div><p>A <a title="processor" class="termref" href="#dt-processor">processor</a><span class="verb">may</span> allow a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> to be serialized. Serialization is described in <a href="#serialization"><i>26 Serialization</i></a>. However, an implementation (for example, a <a title="processor" class="termref" href="#dt-processor">processor</a> running in an environment with no access to writable filestore) is not <span class="verb">required</span> to support the serialization of <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a>. An implementation that does not support the serialization of final result trees <span class="verb">may</span> ignore the <code>format</code> attribute and the serialization attributes. Such an implementation <span class="verb">must</span> provide the application with some means of access to the (un-serialized) result tree, using its URI to identify it.</p><p>Implementations may provide additional mechanisms, outside the scope of this specification, for defining the way in which <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a> are processed. Such mechanisms <span class="verb">may</span> make use of the XSLT-defined attributes on the <a href="#element-result-document"><code>xsl:result-document</code></a> and/or <a href="#element-output"><code>xsl:output</code></a> elements, or they <span class="verb">may</span> use additional elements or attributes in an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> namespace.</p><div class="example"><div class="exampleHeader"><a id="d4e51402"></a><a id="d4e51406"></a>Example: Multiple Result Documents</div><p> The following example takes an XHTML document as input, and breaks it up so that the text following each &lt;h1&gt; element is included in a separate document. A new document <code>toc.html</code> is constructed to act as an index:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:stylesheet
	version="3.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
	
&lt;xsl:output name="toc-format" method="xhtml" indent="yes"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"/&gt;
            
&lt;xsl:output name="section-format" method="xhtml" indent="no"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"/&gt;	
	 
&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document href="toc.html" 
                       format="toc-format" 
                       validation="strict"&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;head&gt;&lt;title&gt;Table of Contents&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Table of Contents&lt;/h1&gt;
        &lt;xsl:for-each select="/*/xhtml:body/(*[1] | xhtml:h1)"&gt;
          &lt;p&gt;
            &lt;a href="section{position()}.html"&gt;
              &lt;xsl:value-of select="."/&gt;
            &lt;/a&gt;
          &lt;/p&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:for-each-group select="/*/xhtml:body/*" group-starting-with="xhtml:h1"&gt;
    &lt;xsl:result-document href="section{position()}.html" 
                         format="section-format" validation="strip"&gt;  	
      &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
        &lt;head&gt;&lt;title&gt;&lt;xsl:value-of select="."/&gt;&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;xsl:copy-of select="current-group()"/&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:result-document&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div></div></div></div></div><div class="back"><div class="_diffs div1"><h2><a id="glossary"></a>B <a href="#glossary" style="text-decoration: none">Glossary</a> (Non-Normative)</h2><dl><dt><a href="#dt-sequence-comparator"></a></dt><dd><p>A <b>sequence comparator</b> is an expression that evaluates two sequences of items and results in a true or false value. </p></dd><dt><a href="#dt-absent">absent</a></dt><dd><p>A component of the context that has no value is said to be <b>absent</b>.</p></dd><dt><a href="#dt-accumulator">accumulator</a></dt><dd><p>An <b>accumulator</b> defines a series of values associated with the nodes of the tree. If an accumulator is applicable to a particular tree, then for each node in the tree, other than attribute and namespace nodes, there will be two values available, called the pre-descent and post-descent values. These two values are available via a pair of functions, <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a>.</p></dd><dt><a href="#dt-accumulator-function">accumulator function</a></dt><dd><p>The functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a> are referred to as the <b>accumulator functions</b>.</p></dd><dt><a href="#dt-alias">alias</a></dt><dd><p>A stylesheet can use the <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> element to declare that a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> is being used as an <b>alias</b> for a <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a>.</p></dd><dt><a href="#dt-applicable">applicable</a></dt><dd><p>A <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is <b>applicable</b> to one or more modes. The modes to which it is applicable are defined by the <code>mode</code> attribute of the <a href="#element-template"><code>xsl:template</code></a> element. If the attribute is omitted, then the template rule is applicable to the <a title="default mode" class="termref" href="#dt-default-mode">default mode</a> specified in the <code>[xsl:]default-mode</code> attribute of the innermost containing element that has such an attribute, which in turn defaults to the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. If the <code>mode</code> attribute is present, then its value <span class="verb">must</span> be a non-empty whitespace-separated list of tokens, each of which defines a mode to which the template rule is applicable.</p></dd><dt><a href="#dt-applicable-static-namespaces">applicable static namespaces</a></dt><dd><p> The <b>applicable static namespaces</b> for an element in a stylesheet module are the <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a> for the module if the root element of the module has a <code>fixed-namespaces</code> attribute, or the <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace bindings</a> of the element otherwise. </p></dd><dt><a href="#dt-arity-range">arity range</a></dt><dd><p>A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> has an <b>arity range</b>, which defines the minimum and maximum number of arguments that must be supplied in a call to the function. The static context can contain multiple <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> with the same name, provided that their <b>arity ranges</b> do not overlap.</p></dd><dt><a href="#dt-atomization">atomize</a></dt><dd><p>The term <b>atomization</b> is defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-atomization">2.6.3 Atomization</a>. It is a process that takes as input a sequence of items, and returns a sequence of atomic items, in which the nodes are replaced by their typed values as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>. Arrays (see <a href="#arrays"><i>22 Arrays</i></a>) are atomized by atomizing their members, recursively.</p></dd><dt><a href="#dt-attribute-set">attribute set</a></dt><dd><p>An <b>attribute set</b> is defined as a set of <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declarations in the same <a title="package" class="termref" href="#dt-package">package</a> that share the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p></dd><dt><a href="#dt-attribute-set-invocation">attribute set invocation</a></dt><dd><p>An <b>attribute set invocation</b> is a pseudo-instruction corresponding to a single EQName appearing within an <code>[xsl:]use-attribute-sets</code> attribute; the effect of the pseudo-instruction is to cause the referenced <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> to be evaluated.</p></dd><dt><a href="#dt-attribute-value-template">attribute value template</a></dt><dd><p>In an attribute that is designated as an <b>attribute value template</b>, such as an attribute of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, an <a title="expression" class="termref" href="#dt-expression">expression</a> can be used by surrounding the expression with curly brackets (<code>{}</code>), following the general rules for <a title="value template" class="termref" href="#dt-value-template">value templates</a></p></dd><dt><a href="#dt-backwards-compatible-behavior">backwards compatible behavior</a></dt><dd><p>An element is processed with <b>backwards compatible behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is less than <span>4.0</span>.</p></dd><dt><a href="#dt-base-output-uri">base output URI</a></dt><dd><p> The <b>base output URI</b> is a URI to be used as the base URI when resolving a relative URI reference allocated to a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>. If the transformation generates more than one final result tree, then typically each one will be allocated a URI relative to this base URI.</p></dd><dt><a href="#dt-basic-xslt-processor">basic XSLT processor</a></dt><dd><p>A <b>basic XSLT processor</b> is an XSLT processor that implements all the mandatory requirements of this specification with the exception of constructs explicitly associated with an optional feature.</p></dd><dt><a href="#dt-character-map">character map</a></dt><dd><p>A <b>character map</b> allows a specific character appearing in a text or attribute node in the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> to be substituted by a specified string of characters during serialization.</p></dd><dt><a href="#dt-circularity">circularity</a></dt><dd><p>A <b>circularity</b> is said to exist if a construct such as a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, or a <a title="key" class="termref" href="#dt-key">key</a>, cannot be evaluated without reference to its own value. For example, if the <a title="expression" class="termref" href="#dt-expression">expression</a> or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> specifying the value of a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a><var>X</var> references a global variable <var>Y</var>, then the value for <var>Y</var><span class="verb">must</span> be computed before the value of <var>X</var>. A circularity exists if it is impossible to do this for all global variable definitions.</p></dd><dt><a href="#dt-coercion-rules">coercion rules</a></dt><dd><p> The term <b>coercion rules</b> means the coercion rules defined in <a href="#xpath-40">[XPath 4.0]</a>, applied unless otherwise specified with XPath 1.0 compatibility mode set to <code>false</code>.</p></dd><dt><a href="#dt-collation">collation</a></dt><dd><p>Facilities in XSLT 3.0 and XPath 3.0 that require strings to be ordered rely on the concept of a named <b>collation</b>. A collation is a set of rules that determine whether two strings are equal, and if not, which of them is to be sorted before the other.</p></dd><dt><a href="#dt-combined-merge-key-value">combined merge key value</a></dt><dd><p> The ordered collection of <a title="merge key value" class="termref" href="#dt-merge-key-value">merge key values</a> computed for one item in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequence</a> (one for each <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> within the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>) is referred to as a <b>combined merge key value</b>.</p></dd><dt><a href="#dt-compatible">compatible</a></dt><dd><p>The signatures of two <a title="component" class="termref" href="#dt-component">components</a> are <b>compatible</b> if they present the same interface to the user of the component. The additional rules depend on the kind of component.</p></dd><dt><a href="#dt-component">component</a></dt><dd><p>The term <b>component</b> is used to refer to any of the following: a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, a <a title="named template" class="termref" href="#dt-named-template">named template</a>, a <a title="mode" class="termref" href="#dt-mode">mode</a>, an <a title="accumulator function" class="termref" href="#dt-accumulator-function">accumulator</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, a <a title="key" class="termref" href="#dt-key">key</a>, <a title="global variable" class="termref" href="#dt-global-variable">global variable</a>, or a <a title="mode" class="termref" href="#dt-mode">mode</a>.</p></dd><dt><a href="#dt-containing-package">containing package</a></dt><dd><p>A component declaration results in multiple components, one in the package in which the declaration appears, and potentially one in each package that uses the declaring package, directly or indirectly, subject to the visibility of the component. Each of these multiple components has the same <a title="declaring package" class="termref" href="#dt-declaring-package">declaring package</a>, but each has a different <b>containing package</b>. For the original component, the declaring package and the containing package are the same; for a copy of a component made as a result of an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration, the declaring package will be the original package, and the containing package will be the package in which the <a href="#element-use-package"><code>xsl:use-package</code></a> declaration appears.</p></dd><dt><a href="#dt-context-item">context item</a></dt><dd><p>The <b>context item</b> is the item currently being processed. An item (see <a href="#xpath-datamodel-40">[XDM 4.0]</a>) is either an atomic item (such as an integer, date, or string), a node, or a function item. It changes whenever instructions such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-for-each"><code>xsl:for-each</code></a> are used to process a sequence of items; each item in such a sequence becomes the context item while that item is being processed.</p></dd><dt><a href="#dt-context-node">context node</a></dt><dd><p>If the <a title="context item" class="termref" href="#dt-context-item">context item</a> is a node (as distinct from an atomic item such as an integer), then it is also referred to as the <b>context node</b>. The context node is not an independent variable, it changes whenever the context item changes. When the context item is an atomic item or a function item, there is no context node.</p></dd><dt><a href="#dt-context-position">context position</a></dt><dd><p>The <b>context position</b> is the position of the context item within the sequence of items currently being processed. It changes whenever the context item changes. When an instruction such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or <a href="#element-for-each"><code>xsl:for-each</code></a> is used to process a sequence of items, the first item in the sequence is processed with a context position of 1, the second item with a context position of 2, and so on.</p></dd><dt><a href="#dt-context-size">context size</a></dt><dd><p>The <b>context size</b> is the number of items in the sequence of items currently being processed. It changes whenever instructions such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-for-each"><code>xsl:for-each</code></a> are used to process a sequence of items; during the processing of each one of those items, the context size is set to the count of the number of items in the sequence (or equivalently, the position of the last item in the sequence).</p></dd><dt><a href="#dt-current-captured-groups">current captured groups</a></dt><dd><p>While the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> instruction is active, a set of <b>current captured groups</b> is available, corresponding to the capturing subexpressions of the regular expression.</p></dd><dt><a href="#dt-current-group">current group</a></dt><dd><p>The <b>current group</b> is the <a title="group" class="termref" href="#dt-group">group</a> itself, as a sequence of items</p></dd><dt><a href="#dt-current-grouping-key">current grouping key</a></dt><dd><p>The <b>current grouping key</b> is a single atomic item, or in the case of a composite key, a sequence of atomic items, containing the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> of the items in the <a title="current group" class="termref" href="#dt-current-group">current group</a>.</p></dd><dt><a href="#dt-current-merge-group">current merge group</a></dt><dd><p>The <b>current merge group</b> is a map. During evaluation of an <a href="#element-merge"><code>xsl:merge</code></a> instruction, as each group of items with equal <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">combined merge key values</a> is processed, the current merge group is set to a map whose keys are the names of the various merge sources, and whose associated values are the items from each merge source having the relevant composite merge key value.</p></dd><dt><a href="#dt-current-merge-key">current merge key</a></dt><dd><p>The <b>current merge key</b> is a an array, whose members are sequences of atomic items. There is one member in the array for each <a href="#element-merge-key"><code>xsl:merge-key</code></a> element in the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>. During evaluation of an <a href="#element-merge"><code>xsl:merge</code></a> instruction, as each group of items with equal <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">combined merge key values</a> is processed, the current merge key is set to the combined merge key value that these items have in common.</p></dd><dt><a href="#dt-current-mode">current mode</a></dt><dd><p>At any point in the processing of a stylesheet, there is a <b>current mode</b>. When the transformation is initiated, the current mode is the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>, as described in <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>. Whenever an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction is evaluated, the current mode becomes the mode selected by this instruction.</p></dd><dt><a href="#dt-current-output-uri">current output URI</a></dt><dd><p>The <b>current output URI</b> is the URI associated with the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a> that is currently being written.</p></dd><dt><a href="#dt-current-template-rule">current template rule</a></dt><dd><p>At any point in the processing of a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, there may be a <b>current template rule</b>. Whenever a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is chosen as a result of evaluating <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a>, the template rule becomes the current template rule for the evaluation of the rule’s sequence constructor.</p></dd><dt><a href="#dt-decimal-format">decimal format</a></dt><dd><p>All the <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations in a package that share the same name are grouped into a named <b>decimal format</b>; those that have no name are grouped into a single unnamed decimal format.</p></dd><dt><a href="#dt-declaration">declaration</a></dt><dd><p>Top-level elements fall into two categories: declarations, and user-defined data elements. Top-level elements whose names are in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> are <b>declarations</b>. Top-level elements in any other namespace are <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> (see <a href="#user-defined-top-level"><i>3.6.4 User-defined Data Elements</i></a>)</p></dd><dt><a href="#dt-declaration-order">declaration order</a></dt><dd><p>The <a title="declaration" class="termref" href="#dt-declaration">declarations</a> within a <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet level</a> have a total ordering known as <b>declaration order</b>. The order of declarations within a stylesheet level is the same as the document order that would result if each stylesheet module were inserted textually in place of the <a href="#element-include"><code>xsl:include</code></a> element that references it.</p></dd><dt><a href="#dt-declaring-package">declaring package</a></dt><dd><p>The <b>declaring package</b> of a <a title="component" class="termref" href="#dt-component">component</a> is the package that contains the declaration (or, in the case of <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> and <a href="#element-key"><code>xsl:key</code></a>, multiple declarations) of the component.</p></dd><dt><a href="#dt-default-collation">default collation</a></dt><dd><p>In this specification the term <b>default collation</b> means the collation that is used by XPath operators such as <code>eq</code> and <code>lt</code> appearing in XPath expressions within the stylesheet.</p></dd><dt><a href="#dt-default-mode">default mode</a></dt><dd><p>The <code>[xsl:]default-mode</code> attribute defines the <b>default mode</b>, which is used as the default value for the <a title="mode" class="termref" href="#dt-mode">mode</a> attribute of all <a href="#element-template"><code>xsl:template</code></a> and <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> elements within its scope.</p></dd><dt><a href="#dt-default-priority">default priority</a></dt><dd><p>If no <code>priority</code> attribute is specified on an <a href="#element-template"><code>xsl:template</code></a> element, a <b>default priority</b> is computed, based on the syntactic form of the <a title="pattern" class="termref" href="#dt-pattern">pattern</a> supplied in the <code>match</code> attribute.</p></dd><dt><a href="#dt-defining-element">defining element</a></dt><dd><p>A string in the form of a lexical QName may occur as the value of an attribute node in a stylesheet module, or within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> contained in an attribute or text node within a stylesheet module, or as the result of evaluating an XPath expression contained in such a node. The element containing this attribute or text node is referred to as the <b>defining element</b> of the lexical QName.</p></dd><dt><a href="#dt-deprecated">deprecated</a></dt><dd><p>Some constructs defined in this specification are described as being <b>deprecated</b>. The use of this term implies that stylesheet authors <span class="verb">should not</span> use the construct, and that the construct may be removed in a later version of this specification.</p></dd><dt><a href="#dt-disqualifying-element">disqualifying element</a></dt><dd><p>The <b>disqualifying elements</b> are <a href="#element-map"><code>xsl:map</code></a>, <a href="#element-map-entry"><code>xsl:map-entry</code></a>, <a href="#element-array"><code>xsl:array</code></a>, <a href="#element-array-member"><code>xsl:array-member</code></a>, <a href="#element-record"><code>xsl:record</code></a>, and <a href="#element-select"><code>xsl:select</code></a>. If a sequence constructor includes one of these elements, then construction of the implicit document node does not take place.</p></dd><dt><a href="#dt-dynamic-error">dynamic error</a></dt><dd><p>An error that is not capable of detection until a source document is being transformed is referred to as a <b>dynamic error</b>.</p></dd><dt><a href="#dt-eclipsed">eclipsed</a></dt><dd><p>An <a href="#element-function"><code>xsl:function</code></a> declaration <var>F</var> is said to be <b>eclipsed</b> if the containing package includes an <a href="#element-function"><code>xsl:function</code></a> declaration <var>G</var> such that <var>F</var> and <var>G</var> have the same name, <var>F</var> has lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than <var>G</var>, and the <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> of <var>G</var> includes the totality of the arity range of <var>F</var>.</p></dd><dt><a href="#dt-effective-value">effective value</a></dt><dd><p>The <b>effective value</b> of an attribute or text node in the stylesheet is the value after any required expansion or normalization.</p></dd><dt><a href="#dt-effective-version">effective version</a></dt><dd><p>The <b>effective version</b> of an element in a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> or <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> is the decimal value of the <code>[xsl:]version</code> attribute (see <a href="#standard-attributes"><i>3.3 Standard Attributes</i></a>) on that element or on the innermost ancestor element that has such an attribute, <span>subject to special rules for the <a href="#element-output"><code>xsl:output</code></a> and <a href="#element-fallback"><code>xsl:fallback</code></a> elements.</span></p></dd><dt><a href="#dt-embedded-stylesheet-module">embedded stylesheet module</a></dt><dd><p>A stylesheet module whose outermost element is the child of a non-XSLT element in a host document is referred to as an <b>embedded stylesheet module</b>. See <a href="#embedded"><i>3.11 Embedded Stylesheet Modules</i></a>.</p></dd><dt><a href="#dt-enclosing-mode">enclosing mode</a></dt><dd><p>A mode declared by an <a href="#element-mode"><code>xsl:mode</code></a> declaration that has one or more contained <a href="#element-template"><code>xsl:template</code></a> declarations is referred to as an <b>enclosing mode</b>.</p></dd><dt><a href="#dt-eqname">EQName</a></dt><dd><p>An <b>EQName</b> is a string representing an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> where the string, after removing leading and trailing whitespace, is in the form defined by the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup> production in the XPath specification.</p></dd><dt><a href="#dt-expanded-qname">expanded QName</a></dt><dd><p>An <b>expanded QName</b> is a value in the value space of the <code>xs:QName</code> datatype as defined in the XDM data model (see <a href="#xpath-datamodel-40">[XDM 4.0]</a>): that is, a triple containing namespace prefix (optional), namespace URI (optional), and local name. Two expanded QNames are equal if the namespace URIs are the same (or both absent) and the local names are the same. The prefix plays no part in the comparison, but is used only if the expanded QName needs to be converted back to a string.</p></dd><dt><a href="#dt-explicit-default">explicit default</a></dt><dd><p>An <b>explicit default</b> for a parameter is indicated by the presence of either a <code>select</code> attribute or a non-empty sequence constructor.</p></dd><dt><a href="#dt-explicitly-mandatory">explicitly mandatory</a></dt><dd><p>A parameter is <b>explicitly mandatory</b> if it is a <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a><span>with no <code>required</code> attribute</span>, or if the <code>required</code> attribute is present and has the value <code>yes</code>.</p></dd><dt><a href="#dt-expression">expression</a></dt><dd><p>Within this specification, the term <b>XPath expression</b>, or simply <b>expression</b>, means a string that matches the production <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP</small></sup> defined in <a href="#xpath-40">[XPath 4.0]</a>.</p></dd><dt><a href="#dt-extension-attribute">extension attribute</a></dt><dd><p>An <b>extension attribute</b> is an attribute appearing on an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>, where the name of the attribute is in a non-null namespace other than the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>.</p></dd><dt><a href="#dt-extension-function">extension function</a></dt><dd><p>An <b>extension function</b> is a named function introduced to the static or dynamic context by mechanisms outside the scope of this specification.</p></dd><dt><a href="#dt-extension-instruction">extension instruction</a></dt><dd><p>An <b>extension instruction</b> is an element within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that is in a namespace (not the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>) designated as an extension namespace.</p></dd><dt><a href="#dt-extension-namespace">extension namespace</a></dt><dd><p>The <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> mechanism allows namespaces to be designated as <b>extension namespaces</b>. When a namespace is designated as an extension namespace and an element with a name from that namespace occurs in a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, then the element is treated as an <a title="instruction" class="termref" href="#dt-instruction">instruction</a> rather than as a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>.</p></dd><dt><a href="#dt-final-output-state">final output state</a></dt><dd><p>The first of the two <a title="output state" class="termref" href="#dt-output-state">output states</a> is called <b>final output</b> state. This state applies when instructions are writing to a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>.</p></dd><dt><a href="#dt-final-result-tree">final result tree</a></dt><dd><p>A <b>final result tree</b> is a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> that forms part of the output of a transformation: specifically, a tree built by post-processing the items in the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or in a <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>. Once created, the contents of a final result tree are not accessible within the stylesheet itself.</p></dd><dt><a href="#dt-fixed-namespace-bindings">fixed namespace bindings</a></dt><dd><p> The <b>fixed namespace bindings</b> for a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> are established using the <code>fixed-namespaces</code> attribute on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a> element enclosing the stylesheet module.</p></dd><dt><a href="#dt-focus">focus</a></dt><dd><p>When a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is evaluated, the <a title="processor" class="termref" href="#dt-processor">processor</a> keeps track of which items are being processed by means of a set of implicit variables referred to collectively as the <b>focus</b>.</p></dd><dt><a href="#dt-forwards-compatible-behavior">forwards compatible behavior</a></dt><dd><p>An element is processed with <b>forwards compatible behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is greater than <span>4.0</span>.</p></dd><dt><a href="#dt-function-definition">function definition</a></dt><dd><p>The term <b>function definition</b> is defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#static_context">2.2.1 Static Context</a>. It is the definition of a function that can be called statically from within an XPath expression: in the case of XSLT it typically means either a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, or a built-in function such as those defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a></p></dd><dt><a href="#dt-function-parameter">function parameter</a></dt><dd><p> An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an <a href="#element-function"><code>xsl:function</code></a> element, before any non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter is known as a <b>function parameter</b>. A function parameter is a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a> with the additional property that its value can be set when the function is called, using a function call in an XPath <a title="expression" class="termref" href="#dt-expression">expression</a>.</p></dd><dt><a href="#dt-global-context-item">global context item</a></dt><dd><p>An item that is the <b>global context item</b> for the transformation acts as the <a title="context item" class="termref" href="#dt-context-item">context item</a> when evaluating the <code>select</code> expression or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a><span>whose declaration is</span> within the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>, as described in <a href="#focus"><i>5.3.3.1 Maintaining Position: the Focus</i></a>. The global context item may also be available in a <a title="named template" class="termref" href="#dt-named-template">named template</a> when the stylesheet is invoked as described in <a href="#invoking-initial-template"><i>2.3.4 Call-Template Invocation</i></a></p></dd><dt><a href="#dt-global-variable">global variable</a></dt><dd><p>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a><a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> declares a <b>global variable</b> that is visible everywhere except within any region where it is <a title="shadows" class="termref" href="#dt-shadows">shadowed</a> by another variable binding.</p></dd><dt><a href="#dt-gnode-pattern">GNode pattern</a></dt><dd><p>An <b>GNode pattern</b> uses a subset of the syntax for path expressions, and is defined to match a GNode if the corresponding path expression would select the GNode.</p></dd><dt><a href="#dt-group">group</a></dt><dd><p>The <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction allocates the items in an input sequence into <b>groups</b> of items (that is, it establishes a collection of sequences) based either on common values of a grouping key, or on a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that the initial or final item in a group must match.</p></dd><dt><a href="#dt-grouping-key">grouping key</a></dt><dd><p>If the <code>group-by</code> or <code>group-adjacent</code> attributes is present, then for each item in the <a title="population" class="termref" href="#dt-population">population</a> a set of <b>grouping keys</b> is calculated, as follows: the expression contained in the <code>group-by</code> or <code>group-adjacent</code> attribute is evaluated; the result is atomized; and any <code>xs:untypedAtomic</code> items are cast to <code>xs:string</code>. If <code>composite="yes"</code> is specified, there is a single grouping key whose value is the resulting sequence; otherwise, there is a set of grouping keys, consisting of the distinct atomic items present in the result sequence.</p></dd><dt><a href="#dt-high-priority-package-location">high priority package location</a></dt><dd><p>A <code>xsl:package-location</code> without the attribute <code>is-priority</code>, or with <code>is-priority</code> set to <code>true</code> is a <b>high priority package location</b>.</p></dd><dt><a href="#dt-homonymous">homonymous</a></dt><dd><p>Two <a title="component" class="termref" href="#dt-component">components</a> are said to be <b>homonymous</b> if they have the same <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a>.</p></dd><dt><a href="#dt-identical-types">identical (types)</a></dt><dd><p>Types <var>S</var> and <var>T</var> are considered <b>identical</b> for the purpose of these rules if and only if <code>subtype(S, T)</code> and <code>subtype(T, S)</code> both hold, where the subtype relation is defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-seqtype-subtype">3.3.1 Subtypes of Sequence Types</a>.</p></dd><dt><a href="#dt-immediate-result">immediate result</a></dt><dd><p>The result of evaluating a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is the sequence of items formed by concatenating the results of evaluating each of the nodes in the sequence constructor, retaining order. This is referred to as the <b>immediate result</b> of the sequence constructor.</p></dd><dt><a href="#dt-implementation">implementation</a></dt><dd><p>A specific product that performs the functions of an <a title="processor" class="termref" href="#dt-processor">XSLT processor</a> is referred to as an <b>implementation</b>.</p></dd><dt><a href="#dt-implementation-defined">implementation-defined</a></dt><dd><p>In this specification, the term <b>implementation-defined</b> refers to a feature where the implementation is allowed some flexibility, and where the choices made by the implementation <span class="verb">must</span> be described in documentation that accompanies any conformance claim.</p></dd><dt><a href="#dt-implementation-dependent">implementation-dependent</a></dt><dd><p>The term <b>implementation-dependent</b> refers to a feature where the behavior <span class="verb">may</span> vary from one implementation to another, and where the vendor is not expected to provide a full specification of the behavior.</p></dd><dt><a href="#dt-implicit-default">implicit default</a></dt><dd><p>If a parameter that is not <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a> has no <a title="explicit default" class="termref" href="#dt-explicit-default">explicit default</a> value, then it has an <b>implicit default</b> value, which is the empty sequence if there is an <code>as</code> attribute, or a zero-length string if not.</p></dd><dt><a href="#dt-implicitly-mandatory">implicitly mandatory</a></dt><dd><p>If a parameter has an <a title="implicit default" class="termref" href="#dt-implicit-default">implicit default</a> value which cannot be converted to the <a title="required type" class="termref" href="#dt-required-type">required type</a> (that is, if it has an <code>as</code> attribute which does not permit the empty sequence), then the parameter is <b>implicitly mandatory</b>.</p></dd><dt><a href="#dt-import-precedence">import precedence</a></dt><dd><p>A <a title="declaration" class="termref" href="#dt-declaration">declaration</a><var>D</var> in the stylesheet is defined to have lower <b>import precedence</b> than another declaration <var>E</var> if the stylesheet level containing <var>D</var> would be visited before the stylesheet level containing <var>E</var> in a post-order traversal of the import tree (that is, a traversal of the import tree in which a stylesheet level is visited after its children). Two declarations within the same stylesheet level have the same import precedence.</p></dd><dt><a href="#dt-import-tree">import tree</a></dt><dd><p>The <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet levels</a> making up a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> are treated as forming an <b>import tree</b>. In the import tree, each stylesheet level has one child for each <a href="#element-import"><code>xsl:import</code></a> declaration that it contains.</p></dd><dt><a href="#dt-initial-function">initial function</a></dt><dd><p>A stylesheet may be evaluated by calling a named <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, referred to as the <b>initial function</b>.</p></dd><dt><a href="#dt-initial-item">initial item</a></dt><dd><p>For each <a title="group" class="termref" href="#dt-group">group</a>, the item within the group that is first in <a title="population order" class="termref" href="#dt-population-order">population order</a> is known as the <b>initial item</b> of the group.</p></dd><dt><a href="#dt-initial-match-selection">initial match selection</a></dt><dd><p>A stylesheet may be evaluated by supplying a value to be processed, together with an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>. The value (which can be any sequence of items) is referred to as the <b>initial match selection</b>. The processing then corresponds to the effect of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p></dd><dt><a href="#dt-initial-mode">initial mode</a></dt><dd><p>The <b>initial mode</b> is the <a title="mode" class="termref" href="#dt-mode">mode</a> used to select <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> for processing items in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> when apply-templates invocation is used to initiate a transformation.</p></dd><dt><a href="#dt-initial-named-template">initial named template</a></dt><dd><p>A stylesheet may be evaluated by selecting a named template to be evaluated; this is referred to as the <b>initial named template</b>.</p></dd><dt><a href="#dt-initial-sequence">initial sequence</a></dt><dd><p>The sequence to be sorted is referred to as the <b>initial sequence</b>.</p></dd><dt><a href="#dt-initial-setting">initial setting</a></dt><dd><p>The <b>initial setting</b> of a component of the dynamic context is used when evaluating <a title="global variable" class="termref" href="#dt-global-variable">global variables</a> and <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, when evaluating the <code>use</code> and <code>match</code> attributes of <a href="#element-key"><code>xsl:key</code></a>, and when evaluating the <code>initial-value</code> of <a href="#element-accumulator"><code>xsl:accumulator</code></a> and the <code>select</code> expressions or contained sequence constructors of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a></p></dd><dt><a href="#dt-in-scope-schema-component">in-scope schema component</a></dt><dd><p>The <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> that may be referenced by name in a <a title="package" class="termref" href="#dt-package">package</a> are referred to as the <b>in-scope schema components</b>.</p></dd><dt><a href="#dt-instruction">instruction</a></dt><dd><p>An <b>instruction</b> is either an <a title="XSLT instruction" class="termref" href="#dt-xslt-instruction">XSLT instruction</a> or an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>.</p></dd><dt><a href="#dt-invocation-construct">invocation construct</a></dt><dd><p>The following constructs are classified as <b>invocation constructs</b>: the instructions <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, and <a href="#element-next-match"><code>xsl:next-match</code></a>; XPath function calls that bind to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>; XPath dynamic function calls; the functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a>; the <code>[xsl:]use-attribute-sets</code> attribute. These all have the characteristic that they can cause evaluation of constructs that are not lexically contained within the calling construct.</p></dd><dt><a href="#dt-key">key</a></dt><dd><p>A <b>key</b> is defined as a set of <a href="#element-key"><code>xsl:key</code></a> declarations in the same <a title="package" class="termref" href="#dt-package">package</a> that share the same name.</p></dd><dt><a href="#dt-key-specifier">key specifier</a></dt><dd><p>The expression in the <code>use</code> attribute and the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> within an <a href="#element-key"><code>xsl:key</code></a> declaration are referred to collectively as the <b>key specifier</b>. The key specifier determines the values that may be used to find a node using this <a title="key" class="termref" href="#dt-key">key</a>.</p></dd><dt><a href="#dt-lexical-qname">lexical QName</a></dt><dd><p>A <b>lexical QName</b> is a string representing an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> where the string, after removing leading and trailing whitespace, is within the lexical space of the <code>xs:QName</code> datatype as defined in XML Schema (see <a href="#xmlschema-2">[XML Schema Part 2]</a>): that is, a local name optionally preceded by a namespace prefix and a colon.</p></dd><dt><a href="#dt-library-package">library package</a></dt><dd><p>Every <a title="package" class="termref" href="#dt-package">package</a> within a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, other than the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>, is referred to as a <b>library package</b>.</p></dd><dt><a href="#dt-literal-namespace-uri">literal namespace URI</a></dt><dd><p>A namespace URI in the stylesheet tree that is being used to specify a namespace URI in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> is called a <b>literal namespace URI</b>.</p></dd><dt><a href="#dt-literal-result-element">literal result element</a></dt><dd><p>In a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, an element in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that does not belong to the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> and that is not an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> (see <a href="#extension-instruction"><i>24.3 Extension Instructions</i></a>) is classified as a <b>literal result element</b>.</p></dd><dt><a href="#dt-local-variable">local variable</a></dt><dd><p>As well as being allowed as a <a title="declaration" class="termref" href="#dt-declaration">declaration</a>, the <a href="#element-variable"><code>xsl:variable</code></a> element is also allowed in <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructors</a>. Such a variable is known as a <b>local variable</b>.</p></dd><dt><a href="#dt-low-priority-package-location">low priority package location</a></dt><dd><p>A <code>xsl:package-location</code> with <code>is-priority</code> set to <code>false</code> is a <b>low priority package location</b>.</p></dd><dt><a href="#dt-merge-activation">merge activation</a></dt><dd><p>A <b>merge activation</b> is a single evaluation of the sequence constructor contained within the <a href="#element-merge-action"><code>xsl:merge-action</code></a> element, which occurs once for each distinct <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">combined merge key value</a>.</p></dd><dt><a href="#dt-merge-input-sequence">merge input sequence</a></dt><dd><p>A <b>merge input sequence</b> is an arbitrary <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-sequence">sequence</a><sup><small>DM</small></sup> of items which is already sorted according to the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a> for the corresponding <a title="merge source definition" class="termref" href="#dt-merge-source-definition">merge source definition</a>.</p></dd><dt><a href="#dt-merge-key-component">merge key component</a></dt><dd><p>A <b>merge key component</b> specifies one component of a <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>; it corresponds to a single <a href="#element-merge-key"><code>xsl:merge-key</code></a> element in the stylesheet.</p></dd><dt><a href="#dt-merge-key-specification">merge key specification</a></dt><dd><p>A <b>merge key specification</b> consists of one or more adjacent <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements which together define how the <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequences</a> selected by a <a title="merge source definition" class="termref" href="#dt-merge-source-definition">merge source definition</a> are sorted. Each <a href="#element-merge-key"><code>xsl:merge-key</code></a> element defines one <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a>.</p></dd><dt><a href="#dt-merge-key-value">merge key value</a></dt><dd><p> For each item in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequence</a>, a value is computed for each <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> within the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>. The value computed for an item by using the <var>N</var>th <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> is referred to as the <var>N</var>th <b>merge key value</b> of that item.</p></dd><dt><a href="#dt-merge-source-definition">merge source definition</a></dt><dd><p>A <b>merge source definition</b> is the definition of one kind of input to the merge operation. It selects zero or more <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequences</a>, and it includes a <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a> to define how the <a title="merge key value" class="termref" href="#dt-merge-key-value">merge key values</a> are computed for each such merge input sequence.</p></dd><dt><a href="#dt-mode">mode</a></dt><dd><p> A <b>mode</b> is a set of template rules; when the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects a set of items for processing, it identifies the rules to be used for processing those items by nominating a mode, explicitly or implicitly.</p></dd><dt><a href="#dt-mode-definition">mode definition</a></dt><dd><p>All the <a href="#element-mode"><code>xsl:mode</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> that share the same name are grouped into a named <b>mode definition</b>; those that have no name are grouped into a single unnamed mode definition.</p></dd><dt><a href="#dt-named-template">named template</a></dt><dd><p>Templates can be invoked by name. An <a href="#element-template"><code>xsl:template</code></a> element with a <code>name</code> attribute defines a <b>named template</b>.</p></dd><dt><a href="#dt-namespace-fixup">namespace fixup</a></dt><dd><p>The rules for the individual XSLT instructions that construct a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> (see <a href="#creating-new-nodes"><i>11 Creating Nodes</i></a>) prescribe some of the situations in which namespace nodes are written to the tree. These rules, however, are not sufficient to ensure that the prescribed constraints are always satisfied. The XSLT processor <span class="verb">must</span> therefore add additional namespace nodes to satisfy these constraints. This process is referred to as <b>namespace fixup</b>.</p></dd><dt><a href="#dt-native-namespace-bindings">native namespace bindings</a></dt><dd><p> The <b>native namespace bindings</b> for any element in an XSLT <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> are the prefix-uri mappings defined by the namespace nodes of that element, according to the rules in <a href="#xpath-datamodel-40">[XDM 4.0]</a>.</p></dd><dt><a href="#dt-non-contextual-function-call">non-contextual function call</a></dt><dd><p>The term <b>non-contextual function call</b> is used to refer to function calls that do not pass the dynamic context to the called function. This includes all calls on <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> and all <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamic-function-call">dynamic function calls</a><sup><small>XP</small></sup>, (that is calls to function items). It excludes calls to some functions in the namespace <code>http://www.w3.org/2005/xpath-functions</code>, in particular those that explicitly depend on the context, such as the <a href="#func-current-group"><code>current-group</code></a> and <a href="#func-regex-group"><code>regex-group</code></a> functions. It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether, and under what circumstances, calls to <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> are non-contextual.</p></dd><dt><a href="#dt-non-schema-aware-processor">non-schema-aware processor</a></dt><dd><p>A <b>non-schema-aware processor</b> is a processor that does not claim conformance with the schema-aware conformance feature. Such a processor <span class="verb">must</span> handle constructs associated with schema-aware processing as described in this section.</p></dd><dt><a href="#dt-first-appearance">order of first appearance</a></dt><dd><p>There is a total ordering among <a title="group" class="termref" href="#dt-group">groups</a> referred to as the <b>order of first appearance</b>. A group <var>G</var> is defined to precede a group <var>H</var> in order of first appearance if the <a title="initial item" class="termref" href="#dt-initial-item">initial item</a> of <var>G</var> precedes the initial item of <var>H</var> in population order. If two groups <var>G</var> and <var>H</var> have the same initial item (because the item is in both groups) then <var>G</var> precedes <var>H</var> if the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> of <var>G</var> precedes the grouping key of <var>H</var> in the sequence that results from evaluating the <code>group-by</code> expression of this initial item.</p></dd><dt><a href="#dt-output-definition">output definition</a></dt><dd><p>All the <a href="#element-output"><code>xsl:output</code></a> declarations within a <a title="package" class="termref" href="#dt-package">package</a> that share the same name are grouped into a named <b>output definition</b>; those that have no name are grouped into a single unnamed output definition.</p></dd><dt><a href="#dt-output-state">output state</a></dt><dd><p>Each instruction in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is evaluated in one of two possible <b>output states</b>: <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a> or <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>.</p></dd><dt><a href="#dt-override">override</a></dt><dd><p>A component in a using package may <b>override</b> a component in a used package, provided that the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the component in the used package is either <code>abstract</code> or <code>public</code>. The overriding declaration is written as a child of the <a href="#element-override"><code>xsl:override</code></a> element, which in turn appears as a child of <a href="#element-use-package"><code>xsl:use-package</code></a>.</p></dd><dt><a href="#dt-package">package</a></dt><dd><p>An explicit <b>package</b> is represented by an <a href="#element-package"><code>xsl:package</code></a> element, which will generally be the outermost element of an XML document. When the <a href="#element-package"><code>xsl:package</code></a> element is not used explicitly, the entire stylesheet comprises a single implicit package.</p></dd><dt><a href="#dt-package-manifest">package manifest</a></dt><dd><p>The content of the <a href="#element-package"><code>xsl:package</code></a> element is referred to as the <b>package manifest</b></p></dd><dt><a href="#dt-parameter">parameter</a></dt><dd><p>The <a href="#element-param"><code>xsl:param</code></a> element declares a <b>parameter</b>, which may be a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a>, a <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a>, a <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a>, or an <a href="#element-iterate"><code>xsl:iterate</code></a> parameter. A parameter is a <a title="variable" class="termref" href="#dt-variable">variable</a> with the additional property that its value can be set by the caller.</p></dd><dt><a href="#dt-pattern">pattern</a></dt><dd><p>A <b>pattern</b> specifies a set of conditions on an item. An item that satisfies the conditions matches the pattern; an item that does not satisfy the conditions does not match the pattern.</p></dd><dt><a href="#dt-picture-string">picture string</a></dt><dd><p>The <b>picture string</b> is the string supplied as the second argument of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-number"><code>format-number</code></a> function.</p></dd><dt><a href="#dt-place-marker">place marker</a></dt><dd><p>The <a href="#element-number"><code>xsl:number</code></a> instruction performs two tasks: firstly, determining a <b>place marker</b> (this is a sequence of integers, to allow for hierarchic numbering schemes such as <code>1.12.2</code> or <code>3(c)ii</code>), and secondly, formatting the place marker for output as a text node in the result sequence.</p></dd><dt><a href="#dt-population">population</a></dt><dd><p>The sequence of items to be grouped, which is referred to as the <b>population</b>, is determined by evaluating the XPath <a title="expression" class="termref" href="#dt-expression">expression</a> contained in the <code>select</code> attribute.</p></dd><dt><a href="#dt-population-order">population order</a></dt><dd><p>The population is treated as a sequence; the order of items in this sequence is referred to as <b>population order</b>.</p></dd><dt><a href="#dt-portion">portion</a></dt><dd><p>The integer literals and the optional <code>NamePart</code> within the version number are referred to as the <b>portions</b> of the version number.</p></dd><dt><a href="#dt-predicate-pattern">predicate pattern</a></dt><dd><p>A <b>predicate pattern</b> is written as <code>.</code> (dot) followed by zero or more predicates in square brackets, and it matches any item for which each of the predicates evaluates to <code>true</code>.</p></dd><dt><a href="#dt-principal-result">principal result</a></dt><dd><p>A <b>principal result</b>: this can be any sequence of items (as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>).</p></dd><dt><a href="#dt-principal-stylesheet-module">principal stylesheet module</a></dt><dd><p>Within a <a title="package" class="termref" href="#dt-package">package</a>, one <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> functions as the <b>principal stylesheet module</b>. The complete package is assembled by finding the stylesheet modules referenced directly or indirectly from the principal stylesheet module using <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a> elements: see <a href="#include"><i>3.10.2 Stylesheet Inclusion</i></a> and <a href="#import"><i>3.10.3 Stylesheet Import</i></a>.</p></dd><dt><a href="#dt-priority">priority</a></dt><dd><p>The <b>priority</b> of a template rule is specified by the <code>priority</code> attribute on the <a href="#element-template"><code>xsl:template</code></a> declaration. If no priority is specified explicitly for a template rule, its <a title="default priority" class="termref" href="#dt-default-priority">default priority</a> is used, as defined in <a href="#default-priority"><i>6.3.3 Default Priority for Patterns</i></a>.</p></dd><dt><a href="#dt-optimal-package-location">priority package location</a></dt><dd><p>The first package location whose value of <code>href</code>, when resolved as described in <a href="#uri-references"><i>5.8 URI References</i></a>, allows the system to find the specified resource, and its entry if the resource is an archive, is the <b>optimal package location</b>.</p></dd><dt><a href="#dt-processing-order">processing order</a></dt><dd><p>There is another total ordering among groups referred to as <b>processing order</b>. If group <var>R</var> precedes group <var>S</var> in processing order, then in the result sequence returned by the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction the items generated by processing group <var>R</var> will precede the items generated by processing group <var>S</var>.</p></dd><dt><a href="#dt-processor">processor</a></dt><dd><p>The software responsible for transforming source trees into result trees using an XSLT stylesheet is referred to as the <b>processor</b>. This is sometimes expanded to <em>XSLT processor</em> to avoid any confusion with other processors, for example an XML processor.</p></dd><dt><a href="#dt-raw-result">raw result</a></dt><dd><p>The result of invoking the selected component, after any required conversion to the declared result type of the component, is referred to as the <b>raw result</b>.</p></dd><dt><a href="#dt-reference-binding">reference binding</a></dt><dd><p>The process of identifying the <a title="component" class="termref" href="#dt-component">component</a> to which a <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic reference</a> applies (possibly chosen from several <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> alternatives) is called <b>reference binding</b>.</p></dd><dt><a href="#dt-required-type">required type</a></dt><dd><p>The context within a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> where an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> appears may specify the <b>required type</b> of the expression. The required type indicates the type of the value that the expression is expected to return.</p></dd><dt><a href="#dt-reserved-namespace">reserved namespace</a></dt><dd><p>The XSLT namespace, together with certain other namespaces recognized by an XSLT processor, are classified as <b>reserved namespaces</b> and <span class="verb">must</span> be used only as specified in this and related specifications.</p></dd><dt><a href="#dt-result-tree">result tree</a></dt><dd><p>The term <b>result tree</b> is used to refer to any <a title="tree" class="termref" href="#dt-tree">tree</a> constructed by <a title="instruction" class="termref" href="#dt-instruction">instructions</a> in the stylesheet. A result tree is either a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> or a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a>.</p></dd><dt><a href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a></dt><dd><p>A <b>schema-aware XSLT processor</b> is an XSLT processor that implements the mandatory requirements of this specification connected with the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration, the <code>[xsl:]validation</code> and <code>[xsl:]type attributes</code>, and the ability to handle input documents whose nodes have type annotations other than <code>xs:untyped</code> and <code>xs:untypedAtomic</code>. The mandatory requirements of this specification are taken to include the mandatory requirements of XPath 4.0, as described in <a href="#xpath-40">[XPath 4.0]</a>. A requirement is mandatory unless the specification includes wording (such as the use of the words <span class="verb">should</span> or <span class="verb">may</span>) that clearly indicates that it is optional.</p></dd><dt><a href="#dt-schema-component">schema component</a></dt><dd><p>Type definitions and element and attribute declarations are referred to collectively as <b>schema components</b>.</p></dd><dt><a href="#dt-schema-instance-namespace">schema instance namespace</a></dt><dd><p>The <b>schema instance namespace</b><code>http://www.w3.org/2001/XMLSchema-instance</code>, <span>with conventional prefix <code>xsi</code></span>, is used as defined in <a href="#xmlschema-1">[XML Schema Part 1]</a></p></dd><dt><a href="#dt-schema-namespace">schema namespace</a></dt><dd><p>The <b>schema namespace</b><code>http://www.w3.org/2001/XMLSchema</code>, <span>with conventional prefix <code>xs</code></span>, is used as defined in <a href="#xmlschema-1">[XML Schema Part 1]</a></p></dd><dt><a href="#dt-secondary-result">secondary result</a></dt><dd><p>Zero or more <b>secondary results</b>: each secondary result can be any sequence of items (as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>).</p></dd><dt><a href="#dt-sequence-constructor">sequence constructor</a></dt><dd><p>A <b>sequence constructor</b> is a sequence of zero or more sibling nodes in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that can be evaluated to return a sequence of nodes, atomic items, and function items. The way that the resulting sequence is used depends on the containing instruction.</p></dd><dt><a href="#dt-sequence-type">SequenceType</a></dt><dd><p>A <b>SequenceType</b> constrains the type and number of items in a sequence. The term is used both to denote the concept, and to refer to the syntactic form in which sequence types are expressed in the XPath grammar: specifically <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup> in <a href="#xpath-40">[XPath 4.0]</a>.</p></dd><dt><a href="#dt-serialization">serialization</a></dt><dd><p>A frequent requirement is to output a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> as an XML document (or in other formats such as HTML). This process is referred to as <b>serialization</b>.</p></dd><dt><a href="#dt-serialization-error">serialization error</a></dt><dd><p>If a transformation has successfully produced a <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>, it is still possible that errors may occur in serializing that result . For example, it may be impossible to serialize the result using the encoding selected by the user. Such an error is referred to as a <b>serialization error</b>.</p></dd><dt><a href="#dt-serialization-feature">serialization feature</a></dt><dd><p>A processor that claims conformance with the <b>serialization feature</b><span class="verb">must</span> support the conversion of a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> to a sequence of octets following the rules defined in <a href="#serialization"><i>26 Serialization</i></a>.</p></dd><dt><a href="#dt-shadows">shadows</a></dt><dd><p>Within a region of the stylesheet where a binding <var>B</var>1 is visible, <var>B<sub>1</sub></var> shadows another binding <var>B<sub>2</sub></var> having the same name as <var>B<sub>1</sub></var> if <var>B<sub>1</sub></var> occurs at a point where <var>B<sub>2</sub></var> is visible.</p></dd><dt><a href="#dt-simplified-stylesheet-module">simplified stylesheet</a></dt><dd><p>A <b>simplified stylesheet</b>, which is a subtree rooted at a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, as described in <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>. This is first converted to a <a title="standard stylesheet module" class="termref" href="#dt-standard-stylesheet-module">standard stylesheet module</a> by wrapping it in an xsl:stylesheet element using the transformation described in <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>.</p></dd><dt><a href="#dt-singleton-focus">singleton focus</a></dt><dd><p>A <b>singleton focus</b> based on an item <var>J</var> has the <a title="context item" class="termref" href="#dt-context-item">context item</a> (and therefore the <a title="context node" class="termref" href="#dt-context-node">context node</a>, if <var>J</var> is a node) set to <var>J</var>, and the <a title="context position" class="termref" href="#dt-context-position">context position</a> and <a title="context size" class="termref" href="#dt-context-size">context size</a> both set to 1 (one).</p></dd><dt><a href="#dt-snapshot">snapshot</a></dt><dd><p>A <b>snapshot</b> of a node <var>N</var> is a deep copy of <var>N</var>, as produced by the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction with <code>copy-namespaces</code> set to <code>yes</code>, <code>copy-accumulators</code> set to <code>yes</code>, and <code>validation</code> set to <code>preserve</code>, with the additional property that for every ancestor of <var>N</var>, the copy also has a corresponding ancestor whose name, node-kind, and base URI are the same as the corresponding ancestor of <var>N</var>, and that has copies of the attributes, namespaces and accumulator values of the corresponding ancestor of <var>N</var>. But the ancestor has a type annotation of <code>xs:anyType</code>, has the properties <code>nilled</code>, <code>is-id</code>, and <code>is-idref</code> set to <code>false</code>, and has no children other than the child that is a copy of <var>N</var> or one of its ancestors.</p></dd><dt><a href="#dt-sorted-sequence">sorted sequence</a></dt><dd><p>The sequence after sorting as defined by the <a href="#element-sort"><code>xsl:sort</code></a> elements is referred to as the <b>sorted sequence</b>.</p></dd><dt><a href="#dt-sort-key-component">sort key component</a></dt><dd><p>Within a <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a>, each <a href="#element-sort"><code>xsl:sort</code></a> element defines one <b>sort key component</b>.</p></dd><dt><a href="#dt-sort-key-specification">sort key specification</a></dt><dd><p>A <b>sort key specification</b> is a sequence of one or more adjacent <a href="#element-sort"><code>xsl:sort</code></a> elements which together define rules for sorting the items in an input sequence to form a sorted sequence.</p></dd><dt><a href="#dt-sort-key-value">sort key value</a></dt><dd><p> For each item in the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a>, a value is computed for each <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a> within the <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a>. The value computed for an item by using the <var>N</var>th sort key component is referred to as the <var>N</var>th <b>sort key value</b> of that item.</p></dd><dt><a href="#dt-source-tree">source tree</a></dt><dd><p>The term <b>source tree</b> means any tree provided as input to the transformation. This includes the document containing the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> if any, documents containing nodes present in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, documents containing nodes supplied as the values of <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, documents obtained from the results of functions such as <a href="#func-document"><code>document</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a>, and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a>, documents read using the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction, and documents returned by extension functions or extension instructions. In the context of a particular XSLT instruction, the term <b>source tree</b> means any tree provided as input to that instruction; this may be a source tree of the transformation as a whole, or it may be a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> produced during the course of the transformation.</p></dd><dt><a href="#dt-stable">stable</a></dt><dd><p>A <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a> is said to be <b>stable</b> if its first <a href="#element-sort"><code>xsl:sort</code></a> element has no <code>stable</code> attribute, or has a <code>stable</code> attribute whose <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is <code>yes</code>.</p></dd><dt><a href="#dt-standard-attributes">standard attributes</a></dt><dd><p>There are a number of <b>standard attributes</b> that may appear on any <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>: specifically <code>default-collation</code>, <code>default-mode</code>, <code>default-validation</code>, <code>exclude-result-prefixes</code>, <code>expand-text</code>, <code>extension-element-prefixes</code>, <code>schema-role</code>, <code>use-when</code>, <code>version</code>, and <code>xpath-default-namespace</code>.</p></dd><dt><a href="#dt-standard-error-namespace">standard error namespace</a></dt><dd><p>The <b>standard error namespace</b><code>http://www.w3.org/2005/xqt-errors</code>, <span>with conventional prefix <code>err</code></span>, is used for error codes defined in this specification and related specifications. It is also used for the names of certain predefined variables accessible within the scope of an <a href="#element-catch"><code>xsl:catch</code></a> element.</p></dd><dt><a href="#dt-standard-function-namespace">standard function namespace</a></dt><dd><p>The <b>standard function namespace</b><code>http://www.w3.org/2005/xpath-functions</code>, <span>with conventional prefix <code>fn</code></span>, is used for functions in the function library defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> and for standard functions defined in this specification.</p></dd><dt><a href="#dt-standard-stylesheet-module">standard stylesheet module</a></dt><dd><p>A <b>standard stylesheet module</b>, which is a subtree rooted at an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element.</p></dd><dt><a href="#dt-static-error">static error</a></dt><dd><p>An error that can be detected by examining a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> before execution starts (that is, before the source document and values of stylesheet parameters are available) is referred to as a <b>static error</b>.</p></dd><dt><a href="#dt-static-expression">static expression</a></dt><dd><p>A <b>static expression</b> is an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> whose value must be computed during static analysis of the stylesheet.</p></dd><dt><a href="#dt-static-parameter">static parameter</a></dt><dd><p>A <a title="static variable" class="termref" href="#dt-static-variable">static variable</a> declared using an <a href="#element-param"><code>xsl:param</code></a> element is referred to as a <b>static parameter</b>.</p></dd><dt><a href="#dt-static-variable">static variable</a></dt><dd><p>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a><a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> having the attribute <code>static="yes"</code> declares a <b>static variable</b>: that is, a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> whose value is known during static analysis of the stylesheet.</p></dd><dt><a href="#dt-streamable-mode">streamable mode</a></dt><dd><p>A <b>streamable mode</b> is a <a title="mode" class="termref" href="#dt-mode">mode</a> that is declared in an <a href="#element-mode"><code>xsl:mode</code></a> declaration with the attribute <code>streamable="yes"</code>.</p></dd><dt><a href="#dt-streamed-document">streamed document</a></dt><dd><p>A <b>streamed document</b> is a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> that is processed using streaming, that is, without constructing a complete tree of nodes in memory.</p></dd><dt><a href="#dt-streamed-node">streamed node</a></dt><dd><p>A <b>streamed node</b> is a node in a <a title="streamed document" class="termref" href="#dt-streamed-document">streamed document</a>.</p></dd><dt><a href="#dt-streaming">streaming</a></dt><dd><p>The term <b>streaming</b> refers to a manner of processing in which XML documents (such as source and result documents) are not represented by a complete tree of nodes occupying memory proportional to document size, but instead are processed “on the fly” as a sequence of events, similar in concept to the stream of events notified by an XML parser to represent markup in lexical XML.</p></dd><dt><a href="#dt-streaming-feature">streaming feature</a></dt><dd><p>A processor that claims conformance with the <b>streaming feature</b><span class="verb">must</span> use streamed processing in cases where (a) streaming is requested (for example by using the attribute <code>streamable="yes"</code> on <a href="#element-mode"><code>xsl:mode</code></a>, or on the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction) and (b) the constructs in question are <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-guaranteed-streamable">guaranteed-streamable</a><sup><small>SG</small></sup> according to this specification.</p></dd><dt><a href="#dt-string-value">string value</a></dt><dd><p>The term <b>string value</b> is defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-string-value">7.6.12 string-value Accessor</a>. Every node has a <a title="string value" class="termref" href="#dt-string-value">string value</a>. For example, the <a title="string value" class="termref" href="#dt-string-value">string value</a> of an element is the concatenation of the <a title="string value" class="termref" href="#dt-string-value">string values</a> of all its descendant text nodes.</p></dd><dt><a href="#dt-stylesheet">stylesheet</a></dt><dd><p>A <b>stylesheet</b> consists of one or more packages: specifically, one <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> and zero or more <a title="library package" class="termref" href="#dt-library-package">library packages</a>.</p></dd><dt><a href="#dt-stylesheet-function">stylesheet function</a></dt><dd><p>An <a href="#element-function"><code>xsl:function</code></a> declaration declares the name, parameters, and implementation of a family of <b>stylesheet functions</b> that can be called from any XPath <a title="expression" class="termref" href="#dt-expression">expression</a> within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (subject to visibility rules).</p></dd><dt><a href="#dt-stylesheet-level">stylesheet level</a></dt><dd><p>A <b>stylesheet level</b> is a collection of <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> connected using <a href="#element-include"><code>xsl:include</code></a> declarations: specifically, two stylesheet modules <var>A</var> and <var>B</var> are part of the same stylesheet level if one of them includes the other by means of an <a href="#element-include"><code>xsl:include</code></a> declaration, or if there is a third stylesheet module <var>C</var> that is in the same stylesheet level as both <var>A</var> and <var>B</var>.</p></dd><dt><a href="#dt-stylesheet-module">stylesheet module</a></dt><dd><p>A <a title="package" class="termref" href="#dt-package">package</a> consists of one or more <b>stylesheet modules</b>, each one forming all or part of an XML document.</p></dd><dt><a href="#dt-stylesheet-parameter">stylesheet parameter</a></dt><dd><p>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a><a href="#element-param"><code>xsl:param</code></a> element declares a <b>stylesheet parameter</b>. A stylesheet parameter is a global variable with the additional property that its value can be supplied by the caller when a transformation is initiated.</p></dd><dt><a href="#dt-supplied-value">supplied value</a></dt><dd><p>The value of the variable is computed using the <a title="expression" class="termref" href="#dt-expression">expression</a> given in the <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, as described in <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>. This value is referred to as the <b>supplied value</b> of the variable.</p></dd><dt><a href="#dt-symbolic-identifier">symbolic identifier</a></dt><dd><p>The <b>symbolic identifier</b> of a <a title="component" class="termref" href="#dt-component">component</a> is a composite name used to identify the component uniquely within a package. The symbolic identifier comprises the kind of component (stylesheet function, named template, accumulator, attribute set, global variable, key, or mode), the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the component (namespace URI plus local name), and in the case of stylesheet functions, <span>the upper bound of the <a title="arity range" class="termref" href="#dt-arity-range">arity range</a></span>.</p></dd><dt><a href="#dt-symbolic-reference">symbolic reference</a></dt><dd><p>The <a title="declaration" class="termref" href="#dt-declaration">declaration</a> of a component includes constructs that can be interpreted as references to other <a title="component" class="termref" href="#dt-component">components</a> by means of their <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifiers</a>. These constructs are generically referred to as <b>symbolic references</b>. Examples of constructs that give rise to symbolic references are the <code>name</code> attribute of <a href="#element-call-template"><code>xsl:call-template</code></a>; the <code>[xsl:]use-attribute-sets</code> attribute of <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, and <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>; the explicit or implicit <code>mode</code> attribute of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>; XPath variable references referring to global variables; XPath static function calls (including partial function applications) referring to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>; and named function references (example: <code>my:f#1</code>) referring to stylesheet functions. </p></dd><dt><a href="#dt-tail-position">tail position</a></dt><dd><p>An <a title="instruction" class="termref" href="#dt-instruction">instruction</a><var>J</var> is in a <b>tail position</b> within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a><var>SC</var> if it satisfies one of the following conditions:</p><ul><li><p><var>J</var> is the last instruction in <var>SC</var>, ignoring any <a href="#element-fallback"><code>xsl:fallback</code></a> instructions.</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-if"><code>xsl:if</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch of an <a href="#element-choose"><code>xsl:choose</code></a><span>or <a href="#element-switch"><code>xsl:switch</code></a></span> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-try"><code>xsl:try</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var> (that is, it is immediately followed by an <a href="#element-catch"><code>xsl:catch</code></a> element, ignoring any <a href="#element-fallback"><code>xsl:fallback</code></a> elements).</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-catch"><code>xsl:catch</code></a> element within an <a href="#element-try"><code>xsl:try</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p></li></ul></dd><dt><a href="#dt-target-expression">target expression</a></dt><dd><p>The string that results from evaluating the expression in the <code>xpath</code> attribute is referred to as the <b>target expression</b>.</p></dd><dt><a href="#dt-target-namespace-uri">target namespace URI</a></dt><dd><p>The namespace URI that is to be used in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> as a substitute for a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> is called the <b>target namespace URI</b>.</p></dd><dt><a href="#dt-template">template</a></dt><dd><p>An <a href="#element-template"><code>xsl:template</code></a> declaration defines a <b>template</b>, which contains a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>; this sequence constructor is evaluated to determine the result of the template. A template can serve either as a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>, invoked by matching items against a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, or as a <a title="named template" class="termref" href="#dt-named-template">named template</a>, invoked explicitly by name. It is also possible for the same template to serve in both capacities.</p></dd><dt><a href="#dt-template-parameter">template parameter</a></dt><dd><p> An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an <a href="#element-template"><code>xsl:template</code></a> element, before any non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter is known as a <b>template parameter</b>. A template parameter is a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a> with the additional property that its value can be set when the template is called, using any of the instructions <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a>.</p></dd><dt><a href="#dt-template-rule">template rule</a></dt><dd><p>A stylesheet contains a set of <b>template rules</b> (see <a href="#rules"><i>6 Template Rules</i></a>). A template rule has three parts: a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that is matched against selected items (often but not necessarily nodes), a (possibly empty) set of <a title="template parameter" class="termref" href="#dt-template-parameter">template parameters</a>, and a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that is evaluated to produce a sequence of items.</p></dd><dt><a href="#dt-temporary-output-state">temporary output state</a></dt><dd><p>The second of the two <a title="output state" class="termref" href="#dt-output-state">output states</a> is called <b>temporary output</b> state. This state applies when instructions are writing to a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> or any other non-final destination.</p></dd><dt><a href="#dt-temporary-tree">temporary tree</a></dt><dd><p>The term <b>temporary tree</b> means any tree that is neither a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> nor a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>.</p></dd><dt><a href="#dt-text-value-template">text value template</a></dt><dd><p>In a text node that is designated as a <b>text value template</b>, <a title="expression" class="termref" href="#dt-expression">expressions</a> can be used by surrounding each expression with curly brackets (<code>{}</code>).</p></dd><dt><a href="#dt-top-level">top-level</a></dt><dd><p>An element occurring as a child of an <a href="#element-package"><code>xsl:package</code></a>, <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-override"><code>xsl:override</code></a> element is called a <b>top-level</b> element.</p></dd><dt><a href="#dt-top-level-package">top-level package</a></dt><dd><p>For a given transformation, one <a title="package" class="termref" href="#dt-package">package</a> functions as the <b>top-level package</b>. The complete <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is assembled by finding the packages referenced directly or indirectly from the top-level package using <a href="#element-use-package"><code>xsl:use-package</code></a> declarations: see <a href="#package-dependencies"><i>3.4.2 Dependencies between Packages</i></a>.</p></dd><dt><a href="#dt-traversal">traversal</a></dt><dd><p>A <b>traversal</b> of a tree is a sequence of <a title="traversal-event" class="termref" href="#dt-traversal-event">traversal events</a>.</p></dd><dt><a href="#dt-traversal-event">traversal-event</a></dt><dd><p>a <b>traversal event</b> (shortened to <b>event</b> in this section) is a pair comprising a phase (start or end) and a node.</p></dd><dt><a href="#dt-tree">tree</a></dt><dd><p>The term <b>tree</b> is used (as in <a href="#xpath-datamodel-40">[XDM 4.0]</a>) to refer to the aggregate consisting of a parentless node together with all its descendant nodes, plus all their attributes and namespaces.</p></dd><dt><a href="#dt-tunnel-parameter">tunnel parameter</a></dt><dd><p>A parameter passed to a template may be defined as a <b>tunnel parameter</b>. Tunnel parameters have the property that they are automatically passed on by the called template to any further templates that it calls, and so on recursively.</p></dd><dt><a href="#dt-type-annotation">type annotation</a></dt><dd><p>The term <b>type annotation</b> is used in this specification to refer to the value returned by the <code>dm:type-name</code> accessor of a node: see <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-type-name">7.6.13 type-name Accessor</a>.</p></dd><dt><a href="#dt-typed-value">typed value</a></dt><dd><p>The term <b>typed value</b> is defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-typed-value">7.6.14 typed-value Accessor</a>. Every node, other than an element whose type annotation identifies it as having element-only content, has a <a title="string value" class="termref" href="#dt-string-value">typed value</a>. For example, the <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> of an attribute of type <code>xs:IDREFS</code> is a sequence of zero or more <code>xs:IDREF</code> values.</p></dd><dt><a href="#dt-type-error">type error</a></dt><dd><p>Certain errors are classified as <b>type errors</b>. A type error occurs when the value supplied as input to an operation is of the wrong type for that operation, for example when an integer is supplied to an operation that expects a node.</p></dd><dt><a href="#dt-type-pattern">type pattern</a></dt><dd><p>A <b>type pattern</b> is written as <code>~T</code> (where <var>T</var> is an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup>) followed by zero or more predicates in square brackets, and it matches any item of type <var>T</var> for which each of the predicates evaluates to <code>true</code>.</p></dd><dt><a href="#dt-unnamed-mode">unnamed mode</a></dt><dd><p>The <b>unnamed mode</b> is the default mode used when no <code>mode</code> attribute is specified on an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction or <a href="#element-template"><code>xsl:template</code></a> declaration, unless a different <a title="default mode" class="termref" href="#dt-default-mode">default mode</a> has been specified using the <code>[xsl:]default-mode</code> attribute of a containing element.</p></dd><dt><a href="#dt-uri-reference">URI Reference</a></dt><dd><p>Within this specification, the term <b>URI Reference</b>, unless otherwise stated, refers to a string in the lexical space of the <code>xs:anyURI</code> datatype as defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>.</p></dd><dt><a href="#dt-use">use</a></dt><dd><p>If a package <var>Q</var> contains an <a href="#element-use-package"><code>xsl:use-package</code></a> element that references package <var>P</var>, then package <var>Q</var> is said to <b>use</b> package <var>P</var>. In this relationship package <var>Q</var> is referred to as the <b>using</b> package, package <var>P</var> as the <b>used</b> package.</p></dd><dt><a href="#dt-data-element">user-defined data element</a></dt><dd><p>In addition to <a title="declaration" class="termref" href="#dt-declaration">declarations</a>, the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element may contain among its children any element not from the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, provided that the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the element has a non-null namespace URI. Such elements are referred to as <b>user-defined data elements</b>.</p></dd><dt><a href="#dt-vacuous">vacuous</a></dt><dd><p><span style="display: none;" class="delete_version">An item is <b>vacuous</b> if it is one of the following: a zero-length text node; a document node with no children; an atomic item which, on casting to <code>xs:string</code>, produces a zero-length string; or an array which on flattening using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-flatten"><code>array:flatten</code></a> function produces either an empty sequence or a sequence consisting entirely of <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items.</span><span style="display: none;" class="add_version">An item is <b>vacuous</b> if it is one of the following: a zero-length text node; a document node with no children; an atomic item which, on casting to <code>xs:string</code>, produces a zero-length string; or an array which on flattening using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-flatten"><code>array:flatten</code></a> function produces either the empty sequence or a sequence consisting entirely of <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items.</span><span class="modify_version">An item is <b>vacuous</b> if it is one of the following: a zero-length text node; a document node with no children; an atomic item which, on casting to <code>xs:string</code>, produces a zero-length string; or an array which on flattening using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-flatten"><code>array:flatten</code></a> function produces either <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence or a sequence consisting entirely of <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items.</span></p></dd><dt><a href="#dt-value">value</a></dt><dd><p>A variable is a binding between a name and a value. The <b>value</b> of a variable is any sequence (of nodes, atomic items, and/or function items), as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>.</p></dd><dt><a href="#dt-value-template">value template</a></dt><dd><p>Collectively, attribute value templates and text value templates are referred to as <b>value templates</b>.</p></dd><dt><a href="#dt-variable">variable</a></dt><dd><p>The <a href="#element-variable"><code>xsl:variable</code></a> element declares a <b>variable</b>, which may be a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> or a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a>.</p></dd><dt><a href="#dt-variable-binding-element">variable-binding element</a></dt><dd><p>The two elements <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> are referred to as <b>variable-binding elements</b>.</p></dd><dt><a href="#dt-visibility">visibility</a></dt><dd><p>The <b>visibility</b> of a <a title="component" class="termref" href="#dt-component">component</a> is one of: <code>private</code>, <code>public</code>, <code>abstract</code>, <code>final</code>, or <code>hidden</code>.</p></dd><dt><a href="#dt-whitespace-text-node">whitespace text node</a></dt><dd><p>A <b>whitespace text node</b> is a text node whose content consists entirely of whitespace characters (that is, <span class="unicode-codepoint">U+0009</span> (<span class="unicode-name">TAB</span>) , <span class="unicode-codepoint">U+000A</span> (<span class="unicode-name">NEWLINE</span>) , <span class="unicode-codepoint">U+000D</span> (<span class="unicode-name">CARRIAGE RETURN</span>) , or <span class="unicode-codepoint">U+0020</span> (<span class="unicode-name">SPACE</span>) ).</p></dd><dt><a href="#xml-namespace">XML namespace</a></dt><dd><p>The <b>XML namespace</b>, defined in <a href="#xml-names">[Namespaces in XML]</a> as <code>http://www.w3.org/XML/1998/namespace</code>, is used for attributes such as <code>xml:lang</code>, <code>xml:space</code>, and <code>xml:id</code>.</p></dd><dt><a href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a></dt><dd><p>The term <b>XPath 1.0 compatibility mode</b> is defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#static_context">2.2.1 Static Context</a>. This is a setting in the static context of an XPath expression; it has two values, <code>true</code> and <code>false</code>. When the value is set to <code>true</code>, the semantics of function calls and certain other operations are adjusted to give a greater degree of backwards compatibility between XPath <span>4.0</span> and XPath 1.0.</p></dd><dt><a href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a></dt><dd><p>An element in the stylesheet is processed with <b>XSLT 1.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 1.0.</p></dd><dt><a href="#dt-1.0-compatibility-feature">XSLT 1.0 compatibility feature</a></dt><dd><p>A processor that claims conformance with the <b>XSLT 1.0 compatibility feature</b><span class="verb">must</span> support the processing of stylesheet instructions and XPath expressions with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, as defined in <a href="#backwards"><i>3.8 Backwards Compatible Processing</i></a>.</p></dd><dt><a href="#dt-xslt-20-behavior">XSLT 2.0 behavior</a></dt><dd><p>An element is processed with <b>XSLT 2.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 2.0.</p></dd><dt><a href="#dt-xslt-30-behavior">XSLT 3.0 behavior</a></dt><dd><p>An element is processed with <b>XSLT 3.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 3.0.</p></dd><dt><a href="#dt-xslt-element">XSLT element</a></dt><dd><p>An <b>XSLT element</b> is an element in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> whose syntax and semantics are defined in this specification.</p></dd><dt><a href="#dt-xslt-instruction">XSLT instruction</a></dt><dd><p>An <b>XSLT instruction</b> is an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a> whose syntax summary in this specification contains the annotation <code>&lt;!-- category: instruction --&gt;</code>.</p></dd><dt><a href="#dt-xslt-namespace">XSLT namespace</a></dt><dd><p>The <b>XSLT namespace</b> has the URI <code>http://www.w3.org/1999/XSL/Transform</code>. It is used to identify elements, attributes, and other names that have a special meaning defined in this specification.</p></dd></dl></div><div class="_diffs div1"><h2><a id="error-summary"></a>D <a href="#error-summary" style="text-decoration: none">Summary of Error Conditions</a> (Non-Normative)</h2><p>This appendix provides a summary of error conditions that a processor may raise. This list includes all error codes defined in this specification, but this is not an exhaustive list of all errors that can occur. Implementations <span class="verb">must</span> raise errors using these error codes, and applications can test for these codes; however, when more than one rule in the specification is violated, different processors will not necessarily raise the same error code. Implementations are not <span class="verb">required</span> to raise errors using the descriptive text used here.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The appendix is non-normative because the same information is given normatively elsewhere.</p></div><p><b>Static errors</b></p><dl><dt><a href="#err-XTSE0010"><span class="error">ERR XTSE0010</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an XSLT-defined element is used in a context where it is not permitted, if a <span class="verb">required</span> attribute is omitted, or if the content of the element does not correspond to the content that is allowed for the element.</p></dd><dt><a href="#err-XTSE0020"><span class="error">ERR XTSE0020</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an attribute (other than an attribute written using curly brackets in a position where an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a> is permitted) contains a value that is not one of the permitted values for that attribute.</p></dd><dt><a href="#err-XTSE0080"><span class="error">ERR XTSE0080</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a> in the name of a <a title="named template" class="termref" href="#dt-named-template">named template</a>, a <a title="mode" class="termref" href="#dt-mode">mode</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, a <a title="key" class="termref" href="#dt-key">key</a>, a <a title="decimal format" class="termref" href="#dt-decimal-format">decimal-format</a>, a <a title="variable" class="termref" href="#dt-variable">variable</a> or <a title="parameter" class="termref" href="#dt-parameter">parameter</a>, a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, a named <a title="output definition" class="termref" href="#dt-output-definition">output definition</a>, an <a title="accumulator" class="termref" href="#dt-accumulator">accumulator</a>, or a <a title="character map" class="termref" href="#dt-character-map">character map</a><span>; except that the name <code>xsl:initial-template</code> is permitted as a template name.</span></p></dd><dt><a href="#err-XTSE0085"><span class="error">ERR XTSE0085</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a> in the name of any <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attribute</a>, <a title="extension function" class="termref" href="#dt-extension-function">extension function</a>, or <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>, other than a function or instruction defined in this specification or in a normatively referenced specification. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a prefix bound to a reserved namespace in the <code>[xsl:]extension-element-prefixes</code> attribute. </p></dd><dt><a href="#err-XTSE0090"><span class="error">ERR XTSE0090</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for an element from the XSLT namespace to have an attribute whose namespace is either null (that is, an attribute with an unprefixed name) or the XSLT namespace, other than attributes defined for the element in this document.</p></dd><dt><a href="#err-XTSE0110"><span class="error">ERR XTSE0110</span></a></dt><dd><p>The value of the <code>version</code> attribute <span class="verb">must</span> be a number: specifically, it <span class="verb">must</span> be a valid instance of the type <code>xs:decimal</code> as defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>.</p></dd><dt><a href="#err-XTSE0120"><span class="error">ERR XTSE0120</span></a></dt><dd><p>An <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a> element <span class="verb">must not</span> have any text node children.</p></dd><dt><a href="#err-XTSE0122"><span class="error">ERR XTSE0122</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token appearing in the <code>fixed-namespaces</code> attribute takes a form that is not one of the permitted forms, or if it is interpreted as a URI but cannot be dereferenced to locate a namespace well-formed XML document. It is not permitted to bind the prefix <code>xmlns</code>. It is not permitted to bind the prefix <code>xml</code> or the XML namespace URI <code>http://www.w3.org/XML/1998/namespace</code>, other than to each other.</p></dd><dt><a href="#err-XTSE0125"><span class="error">ERR XTSE0125</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of an <code>[xsl:]default-collation</code> attribute, after resolving against the base URI, contains no URI that the implementation recognizes as a collation URI.</p></dd><dt><a href="#err-XTSE0130"><span class="error">ERR XTSE0130</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a> element has a child element whose name has a null namespace URI.</p></dd><dt><a href="#err-XTSE0165"><span class="error">ERR XTSE0165</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the processor is not able to retrieve the resource identified by the URI reference [ in the <code>href</code> attribute of <a href="#element-include"><code>xsl:include</code></a> or <a href="#element-import"><code>xsl:import</code></a> ] , or if the resource that is retrieved does not contain a stylesheet module.</p></dd><dt><a href="#err-XTSE0170"><span class="error">ERR XTSE0170</span></a></dt><dd><p>An <a href="#element-include"><code>xsl:include</code></a> element <span class="verb">must</span> be a <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element.</p></dd><dt><a href="#err-XTSE0190"><span class="error">ERR XTSE0190</span></a></dt><dd><p>An <a href="#element-import"><code>xsl:import</code></a> element <span class="verb">must</span> be a <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element.</p></dd><dt><a href="#err-XTSE0210"><span class="error">ERR XTSE0210</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a stylesheet module directly or indirectly references itself via a chain of <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a> declarations that contains at least one <a href="#element-import"><code>xsl:import</code></a>.</p></dd><dt><a href="#err-XTSE0215"><span class="error">ERR XTSE0215</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-import-schema"><code>xsl:import-schema</code></a> element that contains an <code>xs:schema</code> element has a <code>schema-location</code> attribute, or if it has a <code>namespace</code> attribute that conflicts with the target namespace of the contained schema.</p></dd><dt><a href="#err-XTSE0220"><span class="error">ERR XTSE0220</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the synthetic schema document does not satisfy the constraints described in <a href="#xmlschema-1">[XML Schema Part 1]</a> (section 5.1, <em>Errors in Schema Construction and Structure</em>). This includes, without loss of generality, conflicts such as multiple definitions of the same name.</p></dd><dt><a href="#err-XTSE0260"><span class="error">ERR XTSE0260</span></a></dt><dd><p>Within an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a> that is <span class="verb">required</span> to be empty, any content other than comments or processing instructions, including any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> preserved using the <code>xml:space="preserve"</code> attribute, is a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></dd><dt><a href="#err-XTSE0265"><span class="error">ERR XTSE0265</span></a></dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there is a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> in a <a title="package" class="termref" href="#dt-package">package</a> that specifies <code>input-type-annotations="strip"</code> and another <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that specifies <code>input-type-annotations="preserve"</code>, or if a stylesheet module specifies the value <code>strip</code> or <code>preserve</code> and the same value is not specified on the <a href="#element-package"><code>xsl:package</code></a> element of the containing package.</p></dd><dt><a href="#err-XTSE0270"><span class="error">ERR XTSE0270</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if within any <a title="package" class="termref" href="#dt-package">package</a> the same <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP</small></sup> appears in both an <a href="#element-strip-space"><code>xsl:strip-space</code></a> and an <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> declaration if both have the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>. Two NameTests are considered the same if they match the same set of names (which can be determined by comparing them after expanding namespace prefixes to URIs).</p></dd><dt><a href="#err-XTSE0280"><span class="error">ERR XTSE0280</span></a></dt><dd><p>In the case of a prefixed <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> used as the value (or as part of the value) of an attribute in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, or appearing within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> in the stylesheet, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a title="defining element" class="termref" href="#dt-defining-element">defining element</a> has no namespace node whose name matches the prefix of the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>.</p></dd><dt><a href="#err-XTSE0340"><span class="error">ERR XTSE0340</span></a></dt><dd><p>Where an attribute is defined to contain a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the pattern does not match the production <a href="#doc-xslt40-Pattern">Pattern</a>.</p></dd><dt><a href="#err-XTSE0350"><span class="error">ERR XTSE0350</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an unescaped left curly bracket appears in a fixed part of a value template without a matching right curly bracket.</p></dd><dt><a href="#err-XTSE0370"><span class="error">ERR XTSE0370</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an unescaped right curly bracket occurs in a fixed part of a value template.</p></dd><dt><a href="#err-XTSE0500"><span class="error">ERR XTSE0500</span></a></dt><dd><p>An <a href="#element-template"><code>xsl:template</code></a> element <span class="verb">must</span> have either a <code>match</code> attribute or a <code>name</code> attribute, or both. An <a href="#element-template"><code>xsl:template</code></a> element that has no <code>match</code> attribute <span class="verb">must</span> have no <code>mode</code> attribute and no <code>priority</code> attribute. An <a href="#element-template"><code>xsl:template</code></a> element that has no <code>name</code> attribute <span class="verb">must</span> have no <code>visibility</code> attribute.</p></dd><dt><a href="#err-XTSE0530"><span class="error">ERR XTSE0530</span></a></dt><dd><p>The value of the <code>priority</code> attribute [ of the <a href="#element-template"><code>xsl:template</code></a> element] <span class="verb">must</span> conform to the rules for the <code>xs:decimal</code> type defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>. Negative values are permitted.</p></dd><dt><a href="#err-XTSE0545"><span class="error">ERR XTSE0545</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if for any named or unnamed <a title="mode" class="termref" href="#dt-mode">mode</a>, a package explicitly specifies two conflicting values for the same attribute in different <a href="#element-mode"><code>xsl:mode</code></a> declarations having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless there is another definition of the same attribute with higher import precedence. The attributes in question are the attributes other than <code>name</code> on the <a href="#element-mode"><code>xsl:mode</code></a> element.</p></dd><dt><a href="#err-XTSE0550"><span class="error">ERR XTSE0550</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the list of modes [in the <code>mode</code> attribute of <a href="#element-template"><code>xsl:template</code></a> ] is empty, if the same token is included more than once in the list, if the list contains an invalid token, or if the token <code>#all</code> appears together with any other value.</p></dd><dt><a href="#err-XTSE0580"><span class="error">ERR XTSE0580</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the values of the <code>name</code> attribute of two sibling <a href="#element-param"><code>xsl:param</code></a> elements represent the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p></dd><dt><a href="#err-XTSE0620"><span class="error">ERR XTSE0620</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> has a <code>select</code> attribute and has non-empty content.</p></dd><dt><a href="#err-XTSE0630"><span class="error">ERR XTSE0630</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains more than one non-hidden binding of a global variable with the same name and same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless it also contains another binding with the same name and higher import precedence.</p></dd><dt><a href="#err-XTSE0650"><span class="error">ERR XTSE0650</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction whose <code>name</code> attribute does not match the <code>name</code> attribute of any <a title="named template" class="termref" href="#dt-named-template">named template</a> visible in the containing <a title="package" class="termref" href="#dt-package">package</a> (this includes any template defined in this package, as well as templates accepted from used packages whose visibility in this package is not <code>hidden</code>). For more details of the process of binding the called template, see <a href="#component-references"><i>3.4.4.5 Binding References to Components</i></a>.</p></dd><dt><a href="#err-XTSE0660"><span class="error">ERR XTSE0660</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains more than one non-hidden <a title="template" class="termref" href="#dt-template">template</a> with the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless it also contains a <a title="template" class="termref" href="#dt-template">template</a> with the same name and higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p></dd><dt><a href="#err-XTSE0670"><span class="error">ERR XTSE0670</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if two or more sibling <a href="#element-with-param"><code>xsl:with-param</code></a> elements have <code>name</code> attributes that represent the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p></dd><dt><a href="#err-XTSE0680"><span class="error">ERR XTSE0680</span></a></dt><dd><p>In the case of <a href="#element-call-template"><code>xsl:call-template</code></a>, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to pass a non-tunnel parameter named <var>x</var> to a template that does not have a non-tunnel <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a> named <var>x</var>, unless the <a href="#element-call-template"><code>xsl:call-template</code></a> instruction is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>.</p></dd><dt><a href="#err-XTSE0690"><span class="error">ERR XTSE0690</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains both (a) a named template named <var>T</var> that is not overridden by another named template of higher import precedence and that has an <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a> non-tunnel parameter named <var>P</var>, and (b) an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction whose <code>name</code> attribute equals <var>T</var> and that has no non-tunnel <a href="#element-with-param"><code>xsl:with-param</code></a> child element whose <code>name</code> attribute equals <var>P</var>. (All names are compared as QNames.)</p></dd><dt><a href="#err-XTSE0710"><span class="error">ERR XTSE0710</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of the <code>use-attribute-sets</code> attribute of an <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, or <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element, or the <code>xsl:use-attribute-sets</code> attribute of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, is not a whitespace-separated sequence of <a title="EQName" class="termref" href="#dt-eqname">EQNames</a>, or if it contains an EQName that does not match the <code>name</code> attribute of any <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declaration in the containing <a title="package" class="termref" href="#dt-package">package</a>.</p></dd><dt><a href="#err-XTSE0740"><span class="error">ERR XTSE0740</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> has a name that is in no namespace, unless the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the function is <code>private</code>.</p></dd><dt><a href="#err-XTSE0760"><span class="error">ERR XTSE0760</span></a></dt><dd><p>It is a static error if an <a href="#element-param"><code>xsl:param</code></a> child of an <a href="#element-function"><code>xsl:function</code></a> element has either a <code>select</code> attribute or non-empty content<span>, unless it specifies <code>required="no"</code>.</span></p></dd><dt><a href="#err-XTSE0761"><span class="error">ERR XTSE0761</span></a></dt><dd><p>It is a static error if an <a href="#element-param"><code>xsl:param</code></a> child of an <a href="#element-function"><code>xsl:function</code></a> element specifies <code>required="no"</code>, unless all following-sibling <a href="#element-param"><code>xsl:param</code></a> elements also specify <code>required="no"</code>.</p></dd><dt><a href="#err-XTSE0769"><span class="error">ERR XTSE0769</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a <a title="package" class="termref" href="#dt-package">package</a> to contain an <a href="#element-function"><code>xsl:function</code></a> declaration <var>F</var> and an <a href="#element-function"><code>xsl:function</code></a> declaration <var>G</var> such that <var>F</var> and <var>G</var> have the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>, <var>F</var> has lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than <var>G</var>, and the <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> of <var>G</var> includes part but not all of the arity range of <var>F</var>, unless <var>G</var> is itself <a title="eclipsed" class="termref" href="#dt-eclipsed">eclipsed</a> by another <a href="#element-function"><code>xsl:function</code></a> declaration.</p></dd><dt><a href="#err-XTSE0770"><span class="error">ERR XTSE0770</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a <a title="package" class="termref" href="#dt-package">package</a> to contain an <a href="#element-function"><code>xsl:function</code></a> declaration <var>F</var> and an <a href="#element-function"><code>xsl:function</code></a> declaration <var>G</var> such that <var>F</var> and <var>G</var> have the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, if the <a title="arity range" class="termref" href="#dt-arity-range">arity ranges</a> of <var>F</var> and <var>G</var> overlap in whole or in part, unless <var>F</var> and <var>G</var> are both <a title="eclipsed" class="termref" href="#dt-eclipsed">eclipsed</a> by another <a href="#element-function"><code>xsl:function</code></a> declaration.</p></dd><dt><a href="#err-XTSE0805"><span class="error">ERR XTSE0805</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an attribute on a literal result element is in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, unless it is one of the attributes explicitly defined in this specification.</p></dd><dt><a href="#err-XTSE0808"><span class="error">ERR XTSE0808</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a namespace prefix is used within the <code>[xsl:]exclude-result-prefixes</code> attribute and there is no namespace binding in scope for that prefix.</p></dd><dt><a href="#err-XTSE0809"><span class="error">ERR XTSE0809</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value <code>#default</code> is used within the <code>[xsl:]exclude-result-prefixes</code> attribute and the parent element of the <code>[xsl:]exclude-result-prefixes</code> attribute has no default namespace.</p></dd><dt><a href="#err-XTSE0810"><span class="error">ERR XTSE0810</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if within a <a title="package" class="termref" href="#dt-package">package</a> there is more than one such declaration [more than one <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration] with the same <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> and different values for the <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a>, unless there is also an <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration with the same <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> and a higher import precedence. </p></dd><dt><a href="#err-XTSE0812"><span class="error">ERR XTSE0812</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a value other than <code>#default</code> is specified for either the <code>stylesheet-prefix</code> or the <code>result-prefix</code> attributes of the <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> element when there is no in-scope binding for that namespace prefix.</p></dd><dt><a href="#err-XTSE0840"><span class="error">ERR XTSE0840</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-attribute"><code>xsl:attribute</code></a> element is present unless the element has empty content.</p></dd><dt><a href="#err-XTSE0870"><span class="error">ERR XTSE0870</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-text"><code>xsl:text</code></a> or <a href="#element-value-of"><code>xsl:value-of</code></a> element is present when the content of the element is non-empty.</p></dd><dt><a href="#err-XTSE0880"><span class="error">ERR XTSE0880</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> element is present unless the element has empty content.</p></dd><dt><a href="#err-XTSE0910"><span class="error">ERR XTSE0910</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-namespace"><code>xsl:namespace</code></a> element is present when the element has content other than one or more <a href="#element-fallback"><code>xsl:fallback</code></a> instructions, or if the <code>select</code> attribute is absent when the element has empty content.</p></dd><dt><a href="#err-XTSE0940"><span class="error">ERR XTSE0940</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-comment"><code>xsl:comment</code></a> element is present unless the element has empty content.</p></dd><dt><a href="#err-XTSE0975"><span class="error">ERR XTSE0975</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>value</code> attribute of <a href="#element-number"><code>xsl:number</code></a> is present unless the <code>select</code>, <code>level</code>, <code>count</code>, and <code>from</code> attributes are all absent.</p></dd><dt><a href="#err-XTSE1015"><span class="error">ERR XTSE1015</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-sort"><code>xsl:sort</code></a> element with a <code>select</code> attribute has non-empty content.</p></dd><dt><a href="#err-XTSE1017"><span class="error">ERR XTSE1017</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-sort"><code>xsl:sort</code></a> element other than the first in a sequence of sibling <a href="#element-sort"><code>xsl:sort</code></a> elements has a <code>stable</code> attribute.</p></dd><dt><a href="#err-XTSE1040"><span class="error">ERR XTSE1040</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-perform-sort"><code>xsl:perform-sort</code></a> instruction with a <code>select</code> attribute has any content other than <a href="#element-sort"><code>xsl:sort</code></a> and <a href="#element-fallback"><code>xsl:fallback</code></a> instructions.</p></dd><dt><a href="#err-XTSE1060"><span class="error">ERR XTSE1060</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#func-current-group"><code>current-group</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p></dd><dt><a href="#err-XTSE1070"><span class="error">ERR XTSE1070</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#func-current-grouping-key"><code>current-grouping-key</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p></dd><dt><a href="#err-XTSE1080"><span class="error">ERR XTSE1080</span></a></dt><dd><p>These <span>six</span> attributes [the <code>group-by</code>, <code>group-adjacent</code>, <code>group-starting-with</code>, <code>group-ending-with</code>, <span><code>split-when</code>,</span><span>and <code>merge-when</code></span> attributes of <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> ] are mutually exclusive: it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if none of these attributes is present or if more than one of them is present.</p></dd><dt><a href="#err-XTSE1090"><span class="error">ERR XTSE1090</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to specify the <code>collation</code> attribute or the <code>composite</code> attribute if neither the <code>group-by</code> attribute nor the <code>group-adjacent</code> attribute is specified.</p></dd><dt><a href="#err-XTSE1130"><span class="error">ERR XTSE1130</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction contains neither an <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> nor an <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> element.</p></dd><dt><a href="#err-XTSE1205"><span class="error">ERR XTSE1205</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-key"><code>xsl:key</code></a> declaration has a <code>use</code> attribute and has non-empty content, or if it has empty content and no <code>use</code> attribute.</p></dd><dt><a href="#err-XTSE1210"><span class="error">ERR XTSE1210</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#element-key"><code>xsl:key</code></a> declaration has a <code>collation</code> attribute whose value (after resolving against the base URI) is not a URI recognized by the implementation as referring to a collation.</p></dd><dt><a href="#err-XTSE1220"><span class="error">ERR XTSE1220</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there are several <a href="#element-key"><code>xsl:key</code></a> declarations in the same <a title="package" class="termref" href="#dt-package">package</a> with the same key name and different effective collations. Two collations are the same if their URIs are equal under the rules for comparing <code>xs:anyURI</code> values, or if the implementation can determine that they are different URIs referring to the same collation.</p></dd><dt><a href="#err-XTSE1222"><span class="error">ERR XTSE1222</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there are several <a href="#element-key"><code>xsl:key</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> with the same key name and different <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> for the <code>composite</code> attribute.</p></dd><dt><a href="#err-XTSE1290"><span class="error">ERR XTSE1290</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a named or unnamed <a title="decimal format" class="termref" href="#dt-decimal-format">decimal format</a> contains two conflicting values for the same attribute in different <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless there is another definition of the same attribute with higher import precedence.</p></dd><dt><a href="#err-XTSE1295"><span class="error">ERR XTSE1295</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the character specified in the <code>zero-digit</code> attribute is not a digit or is a digit that does not have the numeric value zero. </p></dd><dt><a href="#err-XTSE1300"><span class="error">ERR XTSE1300</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if, for any named or unnamed decimal format, the properties identifying <b>marker</b> characters to be used in a <a title="picture string" class="termref" href="#dt-picture-string">picture string</a> do not identify distinct values. These properties are <var>decimal-separator</var>, <var>grouping-separator</var>, <var>exponent-separator</var>, <var>percent</var>, <var>per-mille</var>, <var>zero-digit</var>, <var>digit</var>, and <var>pattern-separator</var>.</p></dd><dt><a href="#err-XTSE1430"><span class="error">ERR XTSE1430</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there is no namespace bound to the prefix on the element bearing the <code>[xsl:]extension-element-prefixes</code> attribute or, when <code>#default</code> is specified, if there is no default namespace.</p></dd><dt><a href="#err-XTSE1505"><span class="error">ERR XTSE1505</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if both the <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are present on the <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, <a href="#element-source-document"><code>xsl:source-document</code></a>, or <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements, or on a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>.</p></dd><dt><a href="#err-XTSE1520"><span class="error">ERR XTSE1520</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of the <code>type</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, <span><a href="#element-source-document"><code>xsl:source-document</code></a>, or <a href="#element-merge-source"><code>xsl:merge-source</code></a></span> instruction, or the <code>xsl:type</code> attribute of a literal result element, is not a valid <code>QName</code>, or if it uses a prefix that is not defined in <span>the <a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a> of the containing instruction</span>, or if the QName is not the name of a type definition included in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> for the <a title="package" class="termref" href="#dt-package">package</a>. </p></dd><dt><a href="#err-XTSE1530"><span class="error">ERR XTSE1530</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of the <code>type</code> attribute of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction refers to a complex type definition</p></dd><dt><a href="#err-XTSE1560"><span class="error">ERR XTSE1560</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if two <a href="#element-output"><code>xsl:output</code></a> declarations within an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> specify explicit values for the same attribute (other than <code>cdata-section-elements</code>, <code>suppress-indentation</code>, and <code>use-character-maps</code>), with the values of the attributes being not equal, unless there is another <a href="#element-output"><code>xsl:output</code></a> declaration within the same <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> that has higher import precedence and that specifies an explicit value for the same attribute. </p></dd><dt><a href="#err-XTSE1570"><span class="error">ERR XTSE1570</span></a></dt><dd><p>The value [of the <code>method</code> attribute on <a href="#element-output"><code>xsl:output</code></a> ] <span class="verb">must</span> (if present) be a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If it is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> in no namespace, then it identifies a method specified in <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a> and <span class="verb">must</span> be one of <code>xml</code>, <code>html</code>, <code>xhtml</code>, <code>text</code>, <code>json</code>, or <code>adaptive</code>.</p></dd><dt><a href="#err-XTSE1580"><span class="error">ERR XTSE1580</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains two or more character maps with the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless it also contains another character map with the same name and higher import precedence.</p></dd><dt><a href="#err-XTSE1590"><span class="error">ERR XTSE1590</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a name in the <code>use-character-maps</code> attribute of the <a href="#element-output"><code>xsl:output</code></a> or <a href="#element-character-map"><code>xsl:character-map</code></a> elements does not match the <code>name</code> attribute of any <a href="#element-character-map"><code>xsl:character-map</code></a> in the containing <a title="package" class="termref" href="#dt-package">package</a>.</p></dd><dt><a href="#err-XTSE1600"><span class="error">ERR XTSE1600</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a character map references itself, directly or indirectly, via a name in the <code>use-character-maps</code> attribute.</p></dd><dt><a href="#err-XTSE1650"><span class="error">ERR XTSE1650</span></a></dt><dd><p>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware processor</a><span class="verb">must</span> raise a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> includes an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.</p></dd><dt><a href="#err-XTSE1660"><span class="error">ERR XTSE1660</span></a></dt><dd><p>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware processor</a><span class="verb">must</span> raise a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> includes an <code>[xsl:]type</code> attribute; or an <code>[xsl:]validation</code> or <code>[xsl:]default-validation</code> attribute with a value other than <code>strip</code>, <code>preserve</code>, or <code>lax</code>; or an <a href="#element-mode"><code>xsl:mode</code></a> element whose <code>typed</code> attribute is equal to <code>yes</code> or <code>strict</code>; or an <code>as</code> attribute whose value is a <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a> that can only match nodes with a type annotation other than <code>xs:untyped</code> or <code>xs:untypedAtomic</code> (for example, <code>as="element(*, xs:integer)"</code>).</p></dd><dt><a href="#err-XTSE2200"><span class="error">ERR XTSE2200</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the number of <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of a <a href="#element-merge-source"><code>xsl:merge-source</code></a> element is not equal to the number of <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of another <a href="#element-merge-source"><code>xsl:merge-source</code></a> child of the same <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p></dd><dt><a href="#err-XTSE3000"><span class="error">ERR XTSE3000</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if after evaluating each <a href="#element-package-location"><code>xsl:package-location</code></a> declaration and <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> package location, no <a title="priority package location" class="termref" href="#dt-optimal-package-location">priority package location</a> is found.</p></dd><dt><a href="#err-XTSE3002"><span class="error">ERR XTSE3002</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> returned by the <a title="priority package location" class="termref" href="#dt-optimal-package-location">priority package location</a> does not conform to the rules of the implicit or explicit value of attribute <code>format</code>.</p></dd><dt><a href="#err-XTSE3003"><span class="error">ERR XTSE3003</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> returned by the <a title="priority package location" class="termref" href="#dt-optimal-package-location">priority package location</a> does not conform to the name and version specified in an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration.</p></dd><dt><a href="#err-XTSE3004"><span class="error">ERR XTSE3004</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the attribute <code>archive-type</code> is present without the attribute <code>path-in-archive</code>, or if it does not have the value <code>zip</code> or an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> value.</p></dd><dt><a href="#err-XTSE3005"><span class="error">ERR XTSE3005</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a package is dependent on itself, where package <var>A</var> is defined as being dependent on package <var>B</var> if <var>A</var> contains an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration that references <var>B</var>, or if <var>A</var> contains an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration that references a package <var>C</var> that is itself dependent on <var>B</var>.</p></dd><dt><a href="#err-XTSE3008"><span class="error">ERR XTSE3008</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration appears in a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that is not in the same <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet level</a> as the <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet module</a> of the <a title="package" class="termref" href="#dt-package">package</a>.</p></dd><dt><a href="#err-XTSE3010"><span class="error">ERR XTSE3010</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the explicit exposed visibility of a component is inconsistent with its declared visibility, as defined in the above table. (This error occurs only when the component declaration has an explicit <code>visibility</code> attribute, and the component is also listed explicitly by name in an <a href="#element-expose"><code>xsl:expose</code></a> declaration.)</p></dd><dt><a href="#err-XTSE3020"><span class="error">ERR XTSE3020</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token in the <code>names</code> attribute of <a href="#element-expose"><code>xsl:expose</code></a>, other than a wildcard, matches no component in the containing package.</p></dd><dt><a href="#err-XTSE3022"><span class="error">ERR XTSE3022</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>component</code> attribute of <a href="#element-expose"><code>xsl:expose</code></a> specifies <code>*</code> (meaning all component kinds) and the <code>names</code> attribute is not a wildcard.</p></dd><dt><a href="#err-XTSE3025"><span class="error">ERR XTSE3025</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the effect of an <a href="#element-expose"><code>xsl:expose</code></a> declaration would be to make a component <code>abstract</code>, unless the component is already <code>abstract</code> in the absence of the <a href="#element-expose"><code>xsl:expose</code></a> declaration. </p></dd><dt><a href="#err-XTSE3030"><span class="error">ERR XTSE3030</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token in the <code>names</code> attribute of <a href="#element-accept"><code>xsl:accept</code></a>, other than a wildcard, matches no component in the used package.</p></dd><dt><a href="#err-XTSE3032"><span class="error">ERR XTSE3032</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>component</code> attribute of <a href="#element-accept"><code>xsl:accept</code></a> specifies <code>*</code> (meaning all component kinds) and the <code>names</code> attribute is not a wildcard.</p></dd><dt><a href="#err-XTSE3040"><span class="error">ERR XTSE3040</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the visibility assigned to a component by an <a href="#element-accept"><code>xsl:accept</code></a> element is incompatible with the visibility of the corresponding component in the used package, as defined by the above table, unless the token that matches the component name is a wildcard, in which case the <a href="#element-accept"><code>xsl:accept</code></a> element is treated as not matching that component.</p></dd><dt><a href="#err-XTSE3050"><span class="error">ERR XTSE3050</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#element-use-package"><code>xsl:use-package</code></a> elements in a <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> cause two or more <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> components to be accepted with a visibility other than <code>hidden</code>.</p></dd><dt><a href="#err-XTSE3051"><span class="error">ERR XTSE3051</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token in the <code>names</code> attribute of <a href="#element-accept"><code>xsl:accept</code></a>, other than a wildcard, matches the symbolic name of a component declared within an <a href="#element-override"><code>xsl:override</code></a> child of the same <a href="#element-use-package"><code>xsl:use-package</code></a> element.</p></dd><dt><a href="#err-XTSE3055"><span class="error">ERR XTSE3055</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a component declaration appearing as a child of <a href="#element-override"><code>xsl:override</code></a> is <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> with any other declaration in the using package, regardless of <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, including any other overriding declaration in the package manifest of the using package.</p></dd><dt><a href="#err-XTSE3058"><span class="error">ERR XTSE3058</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a component declaration appearing as a child of <a href="#element-override"><code>xsl:override</code></a> does not match (is not <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> with) some component in the used package.</p></dd><dt><a href="#err-XTSE3060"><span class="error">ERR XTSE3060</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the component referenced by an <a href="#element-override"><code>xsl:override</code></a> declaration has <a title="visibility" class="termref" href="#dt-visibility">visibility</a> other than <code>public</code> or <code>abstract</code></p></dd><dt><a href="#err-XTSE3070"><span class="error">ERR XTSE3070</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the signature of an overriding component is not <a title="compatible" class="termref" href="#dt-compatible">compatible</a> with the signature of the component that it is overriding.</p></dd><dt><a href="#err-XTSE3075"><span class="error">ERR XTSE3075</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use the component reference <code>xsl:original</code> when the overridden component has <code>visibility="abstract"</code>.</p></dd><dt><a href="#err-XTSE3080"><span class="error">ERR XTSE3080</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> (as distinct from a <a title="library package" class="termref" href="#dt-library-package">library package</a>) contains components whose visibility is <code>abstract</code>.</p></dd><dt><a href="#err-XTSE3085"><span class="error">ERR XTSE3085</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a>, when the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>declared-modes</code> attribute of an <a href="#element-package"><code>xsl:package</code></a> element is <code>yes</code>, if the package contains an explicit reference to an undeclared mode, or if it implicitly uses the unnamed mode and the unnamed mode is undeclared.</p></dd><dt><a href="#err-XTSE3087"><span class="error">ERR XTSE3087</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if more than one <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration appears within a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>, or if several modules within a single <a title="package" class="termref" href="#dt-package">package</a> contain inconsistent <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declarations</p></dd><dt><a href="#err-XTSE3088"><span class="error">ERR XTSE3088</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>as</code> attribute is present [on the <a href="#element-context-item"><code>xsl:context-item</code></a> element] when <code>use="absent"</code> is specified.</p></dd><dt><a href="#err-XTSE3089"><span class="error">ERR XTSE3089</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>as</code> attribute is present [on the <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> element] when <code>use="absent"</code> is specified.</p></dd><dt><a href="#err-XTSE3105"><span class="error">ERR XTSE3105</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a template rule applicable to a mode that is defined with <code>typed="strict"</code> uses a match pattern that contains a <code>RelativePathExprP</code> whose first <code>StepExprP</code> is an <code>AxisStepP</code> whose <code>ForwardStepP</code> uses an axis whose principal node kind is <code>Element</code> and whose <code>NodeTest</code> is an <code>EQName</code> that does not correspond to the name of any global element declaration in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a>.</p></dd><dt><a href="#err-XTSE3120"><span class="error">ERR XTSE3120</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-break"><code>xsl:break</code></a> or <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> element appears other than in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> forming the body of an <a href="#element-iterate"><code>xsl:iterate</code></a> instruction.</p></dd><dt><a href="#err-XTSE3125"><span class="error">ERR XTSE3125</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of <a href="#element-break"><code>xsl:break</code></a> or <a href="#element-on-completion"><code>xsl:on-completion</code></a> is present and the instruction has children.</p></dd><dt><a href="#err-XTSE3130"><span class="error">ERR XTSE3130</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>name</code> attribute of an <a href="#element-with-param"><code>xsl:with-param</code></a> child of an <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> element does not match the <code>name</code> attribute of an <a href="#element-param"><code>xsl:param</code></a> child of the innermost containing <a href="#element-iterate"><code>xsl:iterate</code></a> instruction.</p></dd><dt><a href="#err-XTSE3140"><span class="error">ERR XTSE3140</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-try"><code>xsl:try</code></a> element is present and the element has children other than <a href="#element-catch"><code>xsl:catch</code></a> and <a href="#element-fallback"><code>xsl:fallback</code></a> elements.</p></dd><dt><a href="#err-XTSE3150"><span class="error">ERR XTSE3150</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-catch"><code>xsl:catch</code></a> element is present unless the element has empty content.</p></dd><dt><a href="#err-XTSE3185"><span class="error">ERR XTSE3185</span></a></dt><dd><p>For the elements <a href="#element-sequence"><code>xsl:sequence</code></a>, <a href="#element-on-empty"><code>xsl:on-empty</code></a>, <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a>, <a href="#element-when"><code>xsl:when</code></a>, <a href="#element-otherwise"><code>xsl:otherwise</code></a>, <a href="#element-matching-substring"><code>xsl:matching-substring</code></a>, <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>, <a href="#element-map"><code>xsl:map</code></a>, <a href="#element-map-entry"><code>xsl:map-entry</code></a>, <a href="#element-array"><code>xsl:array</code></a>, <a href="#element-array-member"><code>xsl:array-member</code></a>, and <a href="#element-result-document"><code>xsl:result-document</code></a>, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute is present and the instruction has children other than <a href="#element-fallback"><code>xsl:fallback</code></a>.</p></dd><dt><a href="#err-XTSE3190"><span class="error">ERR XTSE3190</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if two sibling <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements have the same name.</p></dd><dt><a href="#err-XTSE3195"><span class="error">ERR XTSE3195</span></a></dt><dd><p>If the <code>for-each-item</code> attribute is present then the <code>for-each-source</code>, <code>use-accumulators</code>, and <code>streamable</code> attributes must all be absent. If <span>either or both of the <code>use-accumulators</code> or <code>streamable</code> attributes is present </span> then the <code>for-each-source</code> attribute must be present. If the <code>for-each-source</code> attribute is present then the <code>for-each-item</code> attribute must be absent. </p></dd><dt><a href="#err-XTSE3200"><span class="error">ERR XTSE3200</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-merge-key"><code>xsl:merge-key</code></a> element with a <code>select</code> attribute has non-empty content.</p></dd><dt><a href="#err-XTSE3300"><span class="error">ERR XTSE3300</span></a></dt><dd><p>It is a <a href="https://qt4cg.org/specifications/xslt-40/#dt-static-error">static error</a><sup><small>XT</small></sup> if the list of accumulator names [in the <code>use-accumulators</code> attribute] contains an invalid token, contains the same token more than once, or contains the token <code>#all</code> along with any other value; or if any token (other than <code>#all</code>) is not the name of a <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-declared-streamable">declared-streamable</a><sup><small>SG</small></sup> accumulator visible in the containing package.</p></dd><dt><a href="#err-XTSE3350"><span class="error">ERR XTSE3350</span></a></dt><dd><p>It is a <a href="https://qt4cg.org/specifications/xslt-40/#dt-static-error">static error</a><sup><small>XT</small></sup> for a <a title="package" class="termref" href="#dt-package">package</a> to contain two or more accumulators with the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless there is another accumulator with the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>, and a higher import precedence.</p></dd><dt><a href="#err-XTSE3355"><span class="error">ERR XTSE3355</span></a></dt><dd><p>It is a <a href="https://qt4cg.org/specifications/xslt-40/#dt-static-error">static error</a><sup><small>XT</small></sup> for a an <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> element to specify <code>capture="yes"</code> unless it also specifies <code>phase="end"</code>.</p></dd><dt><a href="#err-XTSE3440"><span class="error">ERR XTSE3440</span></a></dt><dd><p>In the case of a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> (that is, an <a href="#element-template"><code>xsl:template</code></a> element having a <code>match</code> attribute) appearing as a child of <a href="#element-override"><code>xsl:override</code></a>, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the list of modes in the <code>mode</code> attribute contains <code>#all</code> or <code>#unnamed</code>, or if it contains <code>#default</code> and the <a title="default mode" class="termref" href="#dt-default-mode">default mode</a> is the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>, or if the <code>mode</code> attribute is omitted when the default mode is the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>.</p></dd><dt><a href="#err-XTSE3450"><span class="error">ERR XTSE3450</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a variable declared with <code>static="yes"</code> is inconsistent with another static variable of the same name that is declared earlier in stylesheet tree order and that has lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p></dd><dt><a href="#err-XTSE3460"><span class="error">ERR XTSE3460</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> element appears in a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> declared within an <a href="#element-override"><code>xsl:override</code></a> element. (To invoke the template rule that is being overridden, <a href="#element-next-match"><code>xsl:next-match</code></a> should therefore be used.)</p></dd><dt><a href="#err-XTSE3470"><span class="error">ERR XTSE3470</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#func-current-merge-group"><code>current-merge-group</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p></dd><dt><a href="#err-XTSE3500"><span class="error">ERR XTSE3500</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#func-current-merge-key-array"><code>current-merge-key-array</code></a> or <a href="#func-current-merge-key"><code>current-merge-key</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p></dd><dt><a href="#err-XTSE3520"><span class="error">ERR XTSE3520</span></a></dt><dd><p>It is a static error if a parameter to <a href="#element-iterate"><code>xsl:iterate</code></a> is <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly mandatory</a>.</p></dd><dt><a href="#err-XTSE4005"><span class="error">ERR XTSE4005</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-mode"><code>xsl:mode</code></a> declaration with one or more <a href="#element-template"><code>xsl:template</code></a> children has no <code>name</code> attribute.</p></dd><dt><a href="#err-XTSE4010"><span class="error">ERR XTSE4010</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-mode"><code>xsl:mode</code></a> declaration has a child <a href="#element-template"><code>xsl:template</code></a> element with a <code>name</code> attribute, with a <code>mode</code> attribute, or with no <code>match</code> attribute.</p></dd><dt><a href="#err-XTSE4015"><span class="error">ERR XTSE4015</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-mode"><code>xsl:mode</code></a> declaration having one or more child <a href="#element-template"><code>xsl:template</code></a> elements has a <code>default-mode</code> attribute whose value differs from its <code>name</code> attribute, or if any of those child <a href="#element-template"><code>xsl:template</code></a> elements has a <code>default-mode</code> attribute that differs from the <code>name</code> attribute of the <a href="#element-mode"><code>xsl:mode</code></a> declaration.</p></dd><dt><a href="#err-XTSE4020"><span class="error">ERR XTSE4020</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains both (a) an <a href="#element-mode"><code>xsl:mode</code></a> declaration having one or more child <a href="#element-template"><code>xsl:template</code></a> elements, and (b) an <a href="#element-template"><code>xsl:template</code></a> declaration that is not one of those children but that references that <a href="#element-mode"><code>xsl:mode</code></a> declaration in its <code>mode</code> attribute.</p></dd><dt><a href="#err-XTSE4025"><span class="error">ERR XTSE4025</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains (a) an <a href="#element-mode"><code>xsl:mode</code></a> declaration having one or more child <a href="#element-template"><code>xsl:template</code></a> elements, and (b) a second <a href="#element-mode"><code>xsl:mode</code></a> declaration having the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p></dd><dt><a href="#err-XTSE4030"><span class="error">ERR XTSE4030</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a package contains two <a href="#element-item-type"><code>xsl:item-type</code></a> or <a href="#element-record-type"><code>xsl:record-type</code></a> declarations having the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless there is another definition with the same name and higher import precedence. It is also a static error if the name of the item type uses a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a>, or if it has the same name as a type in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-is-types">in-scope schema types</a><sup><small>XP</small></sup> of the static context.</p></dd><dt><a href="#err-XTSE4035"><span class="error">ERR XTSE4035</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for an item type named <var>N</var> to contain in its <code>as</code> attribute a reference to <var>N</var>, or to an item type that references <var>N</var> directly or indirectly.</p></dd><dt><a href="#err-XTSE4040"><span class="error">ERR XTSE4040</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a><var>R</var> has an <code>as</code> attribute <var>S</var>, and the template rule is <a title="applicable" class="termref" href="#dt-applicable">applicable</a> to a <a title="mode" class="termref" href="#dt-mode">mode</a><var>M</var> that is declared with an <code>as</code> attribute <var>T</var>, and the sequence type <var>S</var> is not a subtype of the sequence type <var>T</var> as defined by the relationship <code>subtype(S, T)</code> in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-seqtype-subtype">3.3.1 Subtypes of Sequence Types</a>.</p></dd><dt><a href="#err-XTSE4045"><span class="error">ERR XTSE4045</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of any <code>[xsl:]schema-role</code> in a stylesheet package does not match the value of the <code>role</code> attribute on some <a href="#element-import-schema"><code>xsl:import-schema</code></a> element in the same package.</p></dd><dt><a href="#err-XTSE4050"><span class="error">ERR XTSE4050</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the names of the fields in an <a href="#element-record-type"><code>xsl:record-type</code></a> declaration are not distinct.</p></dd><dt><a href="#err-XTSE4051"><span class="error">ERR XTSE4051</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-field"><code>xsl:field</code></a> element has a <code>default</code> attribute unless it specifies <code>required="no"</code>.</p></dd></dl><p><b>Type errors</b></p><dl><dt><a href="#err-XTDE0450"><span class="error">ERR XTDE0450</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result sequence contains a function item. </p></dd><dt><a href="#err-XTTE0505"><span class="error">ERR XTTE0505</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> cannot be coerced to the required type.</p></dd><dt><a href="#err-XTTE0510"><span class="error">ERR XTTE0510</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction with no <code>select</code> attribute is evaluated when the <a title="context item" class="termref" href="#dt-context-item">context item</a> is not a node. </p></dd><dt><a href="#err-XTTE0570"><span class="error">ERR XTTE0570</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of a variable cannot be converted to the required type.</p></dd><dt><a href="#err-XTTE0590"><span class="error">ERR XTTE0590</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the conversion of the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of a parameter, or of the context item, does not match the <a title="required type" class="termref" href="#dt-required-type">required type</a>, after applying any permitted conversions.</p></dd><dt><a href="#err-XTTE0780"><span class="error">ERR XTTE0780</span></a></dt><dd><p>If the <code>as</code> attribute [of <a href="#element-function"><code>xsl:function</code></a> ] is specified, then the result evaluated by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (see <a href="#sequence-constructors"><i>5.7 Sequence Constructors</i></a>) is converted to the required type, using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if this conversion fails.</p></dd><dt><a href="#err-XTTE0945"><span class="error">ERR XTTE0945</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to use the <a href="#element-copy"><code>xsl:copy</code></a> instruction with no <code>select</code> attribute when the context item is absent. </p></dd><dt><a href="#err-XTTE0950"><span class="error">ERR XTTE0950</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to use the <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction to copy a node that has namespace-sensitive content if the <code>copy-namespaces</code> attribute has the value <code>no</code> and its explicit or implicit <code>validation</code> attribute has the value <code>preserve</code>. It is also a type error if either of these instructions (with <code>validation="preserve"</code>) is used to copy an attribute having namespace-sensitive content, unless the parent element is also copied. A node has namespace-sensitive content if its typed value contains an item of type <code>xs:QName</code> or <code>xs:NOTATION</code> or a type derived therefrom. The reason this is an error is because the validity of the content depends on the namespace context being preserved.</p></dd><dt><a href="#err-XTTE0990"><span class="error">ERR XTTE0990</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the <a href="#element-number"><code>xsl:number</code></a> instruction is evaluated, with no <code>value</code> or <code>select</code> attribute, when the <a title="context item" class="termref" href="#dt-context-item">context item</a> is not a node. </p></dd><dt><a href="#err-XTTE1000"><span class="error">ERR XTTE1000</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>select</code> attribute of the <a href="#element-number"><code>xsl:number</code></a> instruction is anything other than a single node.</p></dd><dt><a href="#err-XTTE1100"><span class="error">ERR XTTE1100</span></a></dt><dd><p><span style="display: none;" class="delete_version">It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>group-adjacent</code> expression is an empty sequence or a sequence containing more than one item, unless <code>composite="yes"</code> is specified.</span><span style="display: none;" class="add_version">It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>group-adjacent</code> expression is the empty sequence or a sequence containing more than one item, unless <code>composite="yes"</code> is specified.</span><span class="modify_version">It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>group-adjacent</code> expression is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence or a sequence containing more than one item, unless <code>composite="yes"</code> is specified.</span></p></dd><dt><a href="#err-XTTE1510"><span class="error">ERR XTTE1510</span></a></dt><dd><p>If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>strict</code>, and schema validity assessment concludes that the validity of the element or attribute is invalid or unknown, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be raised statically if it can be detected statically. </p></dd><dt><a href="#err-XTTE1512"><span class="error">ERR XTTE1512</span></a></dt><dd><p>If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>strict</code>, and there is no matching top-level declaration in the schema, then a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be raised statically if it can be detected statically. </p></dd><dt><a href="#err-XTTE1515"><span class="error">ERR XTTE1515</span></a></dt><dd><p>If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>lax</code>, and schema validity assessment concludes that the element or attribute is invalid, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be raised statically if it can be detected statically. </p></dd><dt><a href="#err-XTTE1535"><span class="error">ERR XTTE1535</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the value of the <code>type</code> attribute of an <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction refers to a complex type definition and one or more of the items being copied is an attribute node.</p></dd><dt><a href="#err-XTTE1540"><span class="error">ERR XTTE1540</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an <code>[xsl:]type</code> attribute is defined for a constructed element or attribute, and the outcome of schema validity assessment against that type is that the <code>validity</code> property of that element or attribute information item is other than <code>valid</code>.</p></dd><dt><a href="#err-XTTE1545"><span class="error">ERR XTTE1545</span></a></dt><dd><p>A <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs if a <code>type</code> or <code>validation</code> attribute is defined (explicitly or implicitly) for an instruction that constructs a new attribute node, if the effect of this is to cause the attribute value to be validated against a type that is derived from, or constructed by list or union from, the primitive types <code>xs:QName</code> or <code>xs:NOTATION</code>.</p></dd><dt><a href="#err-XTTE1550"><span class="error">ERR XTTE1550</span></a></dt><dd><p>A <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs [when a document node is validated] unless the children of the document node comprise exactly one element node, no text nodes, and zero or more comment and processing instruction nodes, in any order.</p></dd><dt><a href="#err-XTTE1555"><span class="error">ERR XTTE1555</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if, when validating a document node, document-level constraints (such as ID/IDREF constraints) are not satisfied. </p></dd><dt><a href="#err-XTTE2230"><span class="error">ERR XTTE2230</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if some item selected by a particular merge key in one input sequence is not comparable using the XPath <code>le</code> operator with the corresponding item selected by the corresponding sort key in another input sequence.</p></dd><dt><a href="#err-XTTE3090"><span class="error">ERR XTTE3090</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the <a href="#element-context-item"><code>xsl:context-item</code></a> child of <a href="#element-template"><code>xsl:template</code></a> specifies that a context item is required and none is supplied by the caller, that is, if the context item is absent at the point where <a href="#element-call-template"><code>xsl:call-template</code></a> is evaluated.</p></dd><dt><a href="#err-XTTE3100"><span class="error">ERR XTTE3100</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction in a particular <code>mode</code> selects an item that does not satisfy the constraints imposed by the <code>@typed</code> attribute.</p></dd><dt><a href="#err-XTTE3165"><span class="error">ERR XTTE3165</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the expression in the <code>with-params</code> attribute of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is anything other than a single map of type <code>map(xs:QName, item()*)</code>.</p></dd><dt><a href="#err-XTTE3170"><span class="error">ERR XTTE3170</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>namespace-context</code> attribute of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is anything other than a single node.</p></dd><dt><a href="#err-XTTE3180"><span class="error">ERR XTTE3180</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>select</code> expression [of the <a href="#element-copy"><code>xsl:copy</code></a> element] is a sequence of more than one item.</p></dd><dt><a href="#err-XTTE3375"><span class="error">ERR XTTE3375</span></a></dt><dd><p>A type error occurs if the result of the input sequence [of an <a href="#element-map"><code>xsl:map</code></a> instruction] is not an instance of the required type <code>map(*)*</code>.</p></dd></dl><p><b>Dynamic errors</b></p><dl><dt><a href="#err-XTDE0030"><span class="error">ERR XTDE0030</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of an attribute written using curly brackets, in a position where an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a> is permitted, is a value that is not one of the permitted values for that attribute. If the processor is able to detect the error statically (for example, when any XPath expressions within the curly brackets can be evaluated statically), then the processor may optionally raise this as a static error.</p></dd><dt><a href="#err-XTDE0040"><span class="error">ERR XTDE0040</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies a template name that does not match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of a named template defined in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, whose visibility is <code>public</code> or <code>final</code>.</p></dd><dt><a href="#err-XTDE0041"><span class="error">ERR XTDE0041</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies a function name and arity that does not match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and arity of a named <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> defined in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, whose visibility is <code>public</code> or <code>final</code>.</p></dd><dt><a href="#err-XTDE0044"><span class="error">ERR XTDE0044</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> when no <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> is supplied (either explicitly, or defaulted to the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>).</p></dd><dt><a href="#err-XTDE0045"><span class="error">ERR XTDE0045</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> and the specified mode is not eligible as an initial mode (as defined above).</p></dd><dt><a href="#err-XTDE0050"><span class="error">ERR XTDE0050</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if a stylesheet declares a visible <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a> that is <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly</a> or <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly</a> mandatory, and no value for this parameter is supplied when the stylesheet is primed. A stylesheet parameter is visible if it is not masked by another global variable or parameter with the same name and higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>. If the parameter is a <a title="static parameter" class="termref" href="#dt-static-parameter">static parameter</a> then the value <span class="verb">must</span> be supplied prior to the static analysis phase.</p></dd><dt><a href="#err-XTDE0160"><span class="error">ERR XTDE0160</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if an element has an <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of <var>V</var> (with <var>V</var> &lt; <span>4.0</span>) when the implementation does not support backwards compatible behavior for XSLT version <var>V</var>.</p></dd><dt><a href="#err-XTDE0290"><span class="error">ERR XTDE0290</span></a></dt><dd><p>Where the result of evaluating an XPath expression (or an attribute value template) is required to be a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>, or if it is permitted to be a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> and the actual value takes the form of a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>, then unless otherwise specified it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the value has a prefix and the <a title="defining element" class="termref" href="#dt-defining-element">defining element</a> has no namespace node whose name matches that prefix. This error <span class="verb">may</span> be raised as a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of the expression can be determined statically.</p></dd><dt><a href="#err-XTDE0410"><span class="error">ERR XTDE0410</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the sequence used to construct the content of an element node contains a namespace node or attribute node that is preceded in the sequence by a node that is neither a namespace node nor an attribute node.</p></dd><dt><a href="#err-XTDE0420"><span class="error">ERR XTDE0420</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the sequence used to construct the content of a document node contains a namespace node or attribute node.</p></dd><dt><a href="#err-XTDE0430"><span class="error">ERR XTDE0430</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the sequence contains two or more namespace nodes having the same name but different <a title="string value" class="termref" href="#dt-string-value">string values</a> (that is, namespace nodes that map the same prefix to different namespace URIs).</p></dd><dt><a href="#err-XTDE0440"><span class="error">ERR XTDE0440</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the sequence contains a namespace node with no name and the element node being constructed has a null namespace URI (that is, it is an error to define a default namespace when the element is in no namespace). </p></dd><dt><a href="#err-XTDE0540"><span class="error">ERR XTDE0540</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the conflict resolution algorithm for template rules leaves more than one matching template rule when the declaration of the relevant <a title="mode" class="termref" href="#dt-mode">mode</a> has an <code>on-multiple-match</code> attribute with the value <code>fail</code>.</p></dd><dt><a href="#err-XTDE0555"><span class="error">ERR XTDE0555</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a> is used to process <span>an item</span> using a mode whose declaration specifies <code>on-no-match="fail"</code> when there is no <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> whose match pattern matches that <span>item</span>. </p></dd><dt><a href="#err-XTDE0560"><span class="error">ERR XTDE0560</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a> is evaluated when the <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a> is <a title="absent" class="termref" href="#dt-absent">absent</a>.</p></dd><dt><a href="#err-XTDE0565"><span class="error">ERR XTDE0565</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if a call on the <a href="#func-apply-templates"><code>apply-templates</code></a> function selects a <a title="mode" class="termref" href="#dt-mode">mode</a> that is not explicitly declared in the containing package, or accepted from a used package, or whose visibility is <code>private</code>.</p></dd><dt><a href="#err-XTDE0640"><span class="error">ERR XTDE0640</span></a></dt><dd><p>In general, a <a title="circularity" class="termref" href="#dt-circularity">circularity</a> in a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a>.</p></dd><dt><a href="#err-XTDE0700"><span class="error">ERR XTDE0700</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if a template that has an <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a> or <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly mandatory</a> parameter is invoked without supplying a value for that parameter.</p></dd><dt><a href="#err-XTDE0820"><span class="error">ERR XTDE0820</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute [of the <a href="#element-element"><code>xsl:element</code></a> instruction] is not a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>. </p></dd><dt><a href="#err-XTDE0830"><span class="error">ERR XTDE0830</span></a></dt><dd><p>In the case of an <a href="#element-element"><code>xsl:element</code></a> instruction with no <code>namespace</code> attribute, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> whose prefix is not declared in <span>the <a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a></span> for the <a href="#element-element"><code>xsl:element</code></a> instruction.</p></dd><dt><a href="#err-XTDE0835"><span class="error">ERR XTDE0835</span></a></dt><dd><p> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>namespace</code> attribute [of the <a href="#element-element"><code>xsl:element</code></a> instruction] is not in the lexical space of the <code>xs:anyURI</code> datatype or if it is the string <code>http://www.w3.org/2000/xmlns/</code>.</p></dd><dt><a href="#err-XTDE0850"><span class="error">ERR XTDE0850</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute [of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction] is not a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>.</p></dd><dt><a href="#err-XTDE0855"><span class="error">ERR XTDE0855</span></a></dt><dd><p>In the case of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction with no <code>namespace</code> attribute, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute is the string <code>xmlns</code>.</p></dd><dt><a href="#err-XTDE0860"><span class="error">ERR XTDE0860</span></a></dt><dd><p>In the case of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction with no <code>namespace</code> attribute, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> whose prefix is not declared in <span>the <a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a></span> for the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction.</p></dd><dt><a href="#err-XTDE0865"><span class="error">ERR XTDE0865</span></a></dt><dd><p> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>namespace</code> attribute [of the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction] is not in the lexical space of the <code>xs:anyURI</code> datatype or if it is the string <code>http://www.w3.org/2000/xmlns/</code>.</p></dd><dt><a href="#err-XTDE0890"><span class="error">ERR XTDE0890</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute [of the <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> instruction] is not both an <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup> and a <a href="https://www.w3.org/TR/REC-xml/#NT-PITarget">PITarget</a><sup><small>XML</small></sup>.</p></dd><dt><a href="#err-XTDE0905"><span class="error">ERR XTDE0905</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the string value of the new namespace node is not valid in the lexical space of the datatype <code>xs:anyURI</code>, or if it is the string <code>http://www.w3.org/2000/xmlns/</code>.</p></dd><dt><a href="#err-XTDE0920"><span class="error">ERR XTDE0920</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute [of the <a href="#element-namespace"><code>xsl:namespace</code></a> instruction] is neither a zero-length string nor an <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>, or if it is <code>xmlns</code>. </p></dd><dt><a href="#err-XTDE0925"><span class="error">ERR XTDE0925</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a href="#element-namespace"><code>xsl:namespace</code></a> instruction generates a namespace node whose name is <code>xml</code> and whose string value is not <code>http://www.w3.org/XML/1998/namespace</code>, or a namespace node whose string value is <code>http://www.w3.org/XML/1998/namespace</code> and whose name is not <code>xml</code>.</p></dd><dt><a href="#err-XTDE0930"><span class="error">ERR XTDE0930</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if evaluating the <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of an <a href="#element-namespace"><code>xsl:namespace</code></a> instruction results in a zero-length string. </p></dd><dt><a href="#err-XTDE0980"><span class="error">ERR XTDE0980</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if any undiscarded item in the atomized sequence supplied as the value of the <code>value</code> attribute of <a href="#element-number"><code>xsl:number</code></a> cannot be converted to an integer, or if the resulting integer is less than 0 (zero). </p></dd><dt><a href="#err-XTDE1030"><span class="error">ERR XTDE1030</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if, for any <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a>, the set of <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a> evaluated for all the items in the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a>, after any type conversion requested, contains a pair of atomic items that are not comparable using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-compare"><code>fn:compare</code></a>. If the processor is able to detect the error statically, it <span class="verb">may</span> optionally raise it as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></dd><dt><a href="#err-XTDE1035"><span class="error">ERR XTDE1035</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <code>collation</code> attribute of <a href="#element-sort"><code>xsl:sort</code></a> (after resolving against the base URI) is not a URI that is recognized by the implementation as referring to a collation.</p></dd><dt><a href="#err-XTDE1061"><span class="error">ERR XTDE1061</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <a href="#func-current-group"><code>current-group</code></a> function is used when the current group is <a title="absent" class="termref" href="#dt-absent">absent</a> , or when it is invoked in the course of evaluating a pattern. The error <span class="verb">may</span> be reported statically if it can be detected statically.</p></dd><dt><a href="#err-XTDE1071"><span class="error">ERR XTDE1071</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <a href="#func-current-grouping-key"><code>current-grouping-key</code></a> function is used when the current grouping key is <a title="absent" class="termref" href="#dt-absent">absent</a>, or when it is invoked in the course of evaluating a pattern. The error <span class="verb">may</span> be reported statically if it can be detected statically.</p></dd><dt><a href="#err-XTDE1110"><span class="error">ERR XTDE1110</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the collation URI specified to <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> (after resolving against the base URI) is a collation that is not recognized by the implementation. (For notes, <span class="error">[see <a href="#err-XTDE1035">ERR XTDE1035</a>]</span>.)</p></dd><dt><a href="#err-XTDE1140"><span class="error">ERR XTDE1140</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>regex</code> attribute [of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction] does not conform to the <span class="verb">required</span> syntax for regular expressions, as specified in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. If the regular expression is known statically (for example, if the attribute does not contain any <a title="expression" class="termref" href="#dt-expression">expressions</a> enclosed in curly brackets) then the processor <span class="verb">may</span> raise the error as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p></dd><dt><a href="#err-XTDE1145"><span class="error">ERR XTDE1145</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>flags</code> attribute [of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction] has a value other than the values defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. If the value of the attribute is known statically (for example, if the attribute does not contain any <a title="expression" class="termref" href="#dt-expression">expressions</a> enclosed in curly brackets) then the processor <span class="verb">may</span> raise the error as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p></dd><dt><a href="#err-XTDE1160"><span class="error">ERR XTDE1160</span></a></dt><dd><p>When a URI reference [supplied to the <a href="#func-document"><code>document</code></a> function] contains a fragment identifier, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the media type is not one that is recognized by the processor, or if the fragment identifier does not conform to the rules for fragment identifiers for that media type, or if the fragment identifier selects something other than a sequence of nodes (for example, if it selects a range of characters within a text node). </p></dd><dt><a href="#err-XTDE1162"><span class="error">ERR XTDE1162</span></a></dt><dd><p>When a URI reference [supplied to the <a href="#func-document"><code>document</code></a> function] is a relative reference, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if no base URI is available to resolve the relative reference. This can arise for example when the URI is contained in a node that has no base URI (for example a parentless text node), or when the second argument to the function is a node that has no base URI, or when the base URI from the static context is undefined. </p></dd><dt><a href="#err-XTDE1260"><span class="error">ERR XTDE1260</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the value of <code>$key-name</code> is not a valid QName, or if there is no namespace declaration in scope for the prefix of the QName, or if the name obtained by expanding the QName is not the same as the expanded name of any <a href="#element-key"><code>xsl:key</code></a> declaration in the containing <a title="package" class="termref" href="#dt-package">package</a>. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></dd><dt><a href="#err-XTDE1262"><span class="error">ERR XTDE1262</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the key identified in a call to the function <a href="#func-map-for-key"><code>map-for-key</code></a> is unsuitable because it uses a collation other than the Unicode Codepoint Collation, or because it is defined with <code>composite=yes</code>.</p></dd><dt><a href="#err-XTDE1270"><span class="error">ERR XTDE1270</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> to call the <a href="#func-key"><code>key</code></a> function with two arguments if there is no <a title="context node" class="termref" href="#dt-context-node">context node</a>, or if the root of the tree containing the context node is not a document node; or to call the function with three arguments if the root of the tree containing the node supplied in the third argument is not a document node.</p></dd><dt><a href="#err-XTDE1360"><span class="error">ERR XTDE1360</span></a></dt><dd><p>If the <a href="#func-current"><code>current</code></a> function is evaluated within an expression that is evaluated when the context item is absent, a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> occurs.</p></dd><dt><a href="#err-XTDE1370"><span class="error">ERR XTDE1370</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if <code>$node</code>, or the context item if the second argument is omitted, is a node in a tree whose root is not a document node.</p></dd><dt><a href="#err-XTDE1380"><span class="error">ERR XTDE1380</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if <code>$node</code>, or the context item if the second argument is omitted, is a node in a tree whose root is not a document node.</p></dd><dt><a href="#err-XTDE1390"><span class="error">ERR XTDE1390</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the value supplied as the <code>$property-name</code> argument [to the <a href="#func-system-property"><code>system-property</code></a> function] is not a valid QName, or if there is no namespace declaration in scope for the prefix of the QName. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p></dd><dt><a href="#err-XTDE1400"><span class="error">ERR XTDE1400</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <code>$name</code> argument [passed to the <a href="#func-function-available"><code>function-available</code></a> function] <span>evaluates to a string that is not</span> a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the value is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no namespace declaration is present in the static context. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></dd><dt><a href="#err-XTDE1420"><span class="error">ERR XTDE1420</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the arguments supplied to a call on an extension function do not satisfy the rules defined for that particular extension function, or if the extension function raises an error, or if the result of the extension function cannot be converted to an XPath value.</p></dd><dt><a href="#err-XTDE1425"><span class="error">ERR XTDE1425</span></a></dt><dd><p>When the containing element is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> to evaluate an extension function call if no implementation of the extension function is available.</p></dd><dt><a href="#err-XTDE1428"><span class="error">ERR XTDE1428</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the argument [passed to the <a href="#func-type-available"><code>type-available</code></a> function] <span>evaluates to a string that is not</span> a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the value is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no namespace declaration is present in the static context. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></dd><dt><a href="#err-XTDE1440"><span class="error">ERR XTDE1440</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the argument [passed to the <a href="#func-element-available"><code>element-available</code></a> function] <span>evaluates to a string that is not</span> a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the value is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no namespace declaration is present in the static context. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></dd><dt><a href="#err-XTDE1450"><span class="error">ERR XTDE1450</span></a></dt><dd><p>When a <a title="processor" class="termref" href="#dt-processor">processor</a> performs fallback for an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> that is not recognized, if the instruction element has one or more <a href="#element-fallback"><code>xsl:fallback</code></a> children, then the content of each of the <a href="#element-fallback"><code>xsl:fallback</code></a> children <span class="verb">must</span> be evaluated; it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if it has no <a href="#element-fallback"><code>xsl:fallback</code></a> children.</p></dd><dt><a href="#err-XTDE1460"><span class="error">ERR XTDE1460</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>format</code> attribute [of an <a href="#element-result-document"><code>xsl:result-document</code></a> element] is not a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if it does not match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> in the containing <a title="package" class="termref" href="#dt-package">package</a>. If the processor is able to detect the error statically (for example, when the <code>format</code> attribute contains no curly brackets), then the processor <span class="verb">may</span> optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></dd><dt><a href="#err-XTDE1480"><span class="error">ERR XTDE1480</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> to evaluate the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction in <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>.</p></dd><dt><a href="#err-XTDE1490"><span class="error">ERR XTDE1490</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> for a transformation to generate two or more <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a> with the same URI.</p></dd><dt><a href="#err-XTDE1500"><span class="error">ERR XTDE1500</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> for a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> to write to an external resource and read from the same resource during a single transformation, if the same absolute URI is used to access the resource in both cases. </p></dd><dt><a href="#err-XTDE1665"><span class="error">ERR XTDE1665</span></a></dt><dd><p>A <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a><span class="verb">may</span> be raised if the input to the processor includes an item that requires availability of an optional feature that the processor does not provide.</p></dd><dt><a href="#err-XTDE2210"><span class="error">ERR XTDE2210</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if there are two <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements that occupy corresponding positions among the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of two different <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements and that have differing <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> for any of the attributes <code>lang</code>, <code>order</code>, <code>collation</code>, <code>case-order</code>, or <code>data-type</code>. Values are considered to differ if they have different <a title="effective value" class="termref" href="#dt-effective-value">effective values</a>. In the case of the <code>collation</code> attribute, the values are compared as absolute URIs after resolving against the base URI. The error <span class="verb">may</span> be raised statically if it is detected statically.</p></dd><dt><a href="#err-XTDE2220"><span class="error">ERR XTDE2220</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if any input sequence to an <a href="#element-merge"><code>xsl:merge</code></a> instruction contains two items that are not correctly sorted according to the merge key values defined on the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of the corresponding <a href="#element-merge-source"><code>xsl:merge-source</code></a> element, when compared using the collation rules defined by the attributes of the corresponding <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of the <a href="#element-merge"><code>xsl:merge</code></a> instruction, unless the attribute <code>sort-before-merge</code> is present with the value <code>yes</code>.</p></dd><dt><a href="#err-XTDE3052"><span class="error">ERR XTDE3052</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an invocation of an abstract component is evaluated. </p></dd><dt><a href="#err-XTDE3086"><span class="error">ERR XTDE3086</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration specifies <code>use="required"</code>, and no global context item is supplied.</p></dd><dt><a href="#err-XTDE3160"><span class="error">ERR XTDE3160</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="target expression" class="termref" href="#dt-target-expression">target expression</a> [of an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction] is not a valid <a title="expression" class="termref" href="#dt-expression">expression</a> (that is, if a static error occurs when analyzing the string according to the rules of the XPath specification).</p></dd><dt><a href="#err-XTDE3175"><span class="error">ERR XTDE3175</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is evaluated when use of <a href="#element-evaluate"><code>xsl:evaluate</code></a> has been statically or dynamically disabled. </p></dd><dt><a href="#err-XTDE3340"><span class="error">ERR XTDE3340</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the value of the first argument to the <a href="#func-accumulator-before"><code>accumulator-before</code></a> or <a href="#func-accumulator-after"><code>accumulator-after</code></a> function is <span>a string that is</span> not a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if there is no namespace declaration in scope for the prefix of the QName, or if the name obtained by expanding the QName is not the same as the expanded name of any <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration appearing in the <a title="package" class="termref" href="#dt-package">package</a> in which the function call appears. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></dd><dt><a href="#err-XTDE3350"><span class="error">ERR XTDE3350</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> to call the <a href="#func-accumulator-before"><code>accumulator-before</code></a> or <a href="#func-accumulator-after"><code>accumulator-after</code></a> function when there is no <a title="context item" class="termref" href="#dt-context-item">context item</a>.</p></dd><dt><a href="#err-XTTE3360"><span class="error">ERR XTTE3360</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to call the <a href="#func-accumulator-before"><code>accumulator-before</code></a> or <a href="#func-accumulator-after"><code>accumulator-after</code></a> function when the <a title="context item" class="termref" href="#dt-context-item">context item</a> is not a node, or when it is an attribute or namespace node.</p></dd><dt><a href="#err-XTDE3362"><span class="error">ERR XTDE3362</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> to call the <a href="#func-accumulator-before"><code>accumulator-before</code></a> or <a href="#func-accumulator-after"><code>accumulator-after</code></a> function when the context item is a node in a tree to which the selected accumulator is not applicable (including the case where it is not applicable because the document is streamed and the accumulator is not declared with <code>streamable="yes"</code>). Implementations <span class="verb">may</span> raise this error but are <span class="verb">not required</span> to do so, if they are capable of streaming documents without imposing this restriction.</p></dd><dt><a href="#err-XTDE3365"><span class="error">ERR XTDE3365</span></a></dt><dd><p>In the absence of the <code>[xsl:]duplicates</code> attribute, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs if the set of keys in the maps making up the input sequence [of an <a href="#element-map"><code>xsl:map</code></a> or <a href="#element-record"><code>xsl:record</code></a> instruction] contains duplicates.</p></dd><dt><a href="#err-XTDE3400"><span class="error">ERR XTDE3400</span></a></dt><dd><p>It is an error if there is a cyclic set of dependencies among accumulators such that the (pre- or post-descent) value of an accumulator depends directly or indirectly on itself. A processor <span class="verb">may</span> report this as a <a title="static error" class="termref" href="#dt-static-error">static error</a> if it can be detected statically. Alternatively a processor <span class="verb">may</span> report this as a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>. As a further option, a processor may fail catastrophically when this error occurs.</p></dd><dt><a href="#err-XTDE3480"><span class="error">ERR XTDE3480</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <a href="#func-current-merge-group"><code>current-merge-group</code></a> function is used when the current merge group is <a title="absent" class="termref" href="#dt-absent">absent</a>. The error <span class="verb">may</span> be reported statically if it can be detected statically.</p></dd><dt><a href="#err-XTDE3490"><span class="error">ERR XTDE3490</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <code>$source</code> argument of the <a href="#func-current-merge-group"><code>current-merge-group</code></a> function <span>(when supplied)</span> does not match the <code>name</code> attribute of any <a href="#element-merge-source"><code>xsl:merge-source</code></a> element for the current merge operation. The error <span class="verb">may</span> be reported statically if it can be detected statically.</p></dd><dt><a href="#err-XTDE3510"><span class="error">ERR XTDE3510</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <a href="#func-current-merge-key-array"><code>current-merge-key-array</code></a> or <a href="#func-current-merge-key"><code>current-merge-key</code></a> function is used when the current merge key is <a title="absent" class="termref" href="#dt-absent">absent</a>, or when it is invoked in the course of evaluating a pattern. The error <span class="verb">may</span> be reported statically if it can be detected statically.</p></dd><dt><a href="#err-XTDE3530"><span class="error">ERR XTDE3530</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an <a href="#element-try"><code>xsl:try</code></a> instruction is unable to recover the state of a final result tree because recovery has been disabled by use of the attribute <code>rollback-output="no"</code>.</p></dd><dt><a href="#err-XTDE4060"><span class="error">ERR XTDE4060</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an <a href="#element-array"><code>xsl:array</code></a> instruction with a <code>for-each</code> attribute includes items constructed using an <a href="#element-array-member"><code>xsl:array-member</code></a> instruction mixed (in the same array member) with items not so constructed.</p></dd><dt><a href="#err-XTMM9000"><span class="error">ERR XTMM9000</span></a></dt><dd><p>When a transformation is terminated by use of <code>&lt;xsl:message terminate="yes"/&gt;</code>, the effect is the same as when a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> occurs during the transformation. The default error code is <code>XTMM9000</code>; this may be overridden using the <code>error-code</code> attribute of the <a href="#element-message"><code>xsl:message</code></a> instruction.</p></dd><dt><a href="#err-XTMM9001"><span class="error">ERR XTMM9001</span></a></dt><dd><p>When a transformation is terminated by use of <a href="#element-assert"><code>xsl:assert</code></a>, the effect is the same as when a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> occurs during the transformation. The default error code is <code>XTMM9001</code>; this may be overridden using the <code>error-code</code> attribute of the <a href="#element-assert"><code>xsl:assert</code></a> instruction.</p></dd></dl></div></div><p role="navigation" id="back-to-top"><a href="#title"><abbr title="Back to top">↑</abbr></a></p><script src="js/toc.js"></script><script src="/js/scroll.js"></script></body></html>