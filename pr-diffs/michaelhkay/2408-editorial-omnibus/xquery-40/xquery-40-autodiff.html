<!DOCTYPE HTML><html xmlns="http://www.w3.org/1999/xhtml" lang="EN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>XQuery 4.0: An XML Query Language </title><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link rel="stylesheet" type="text/css" href="css/w3c-base.css"><link rel="stylesheet" href="css/qtspecs.css"><link rel="stylesheet" href="css/xquery-40.css"><style type="text/css">
          body { margin-top: 50px }
          a.button { background: #DDD; border: 2px outset black; padding: 2px; margin: 2px; font-family: sans-serif; font-size: small;}
          a.button:hover { cursor:pointer; }
          a.button:active { border-style: inset; }
        </style><link rel="stylesheet" href="/css/autodiff.css"></head><body class="toc-inline"><div style="position:fixed; clear:both; top:0px" id="_autodiff_buttons"><p><a class="button" onclick="view('old')">
              View Old
            </a><a class="button" onclick="view('new')">
              View New
            </a><a class="button" onclick="view('both')">
              View Both
            </a><a class="button" onclick="view('only')">
              View Only
            </a><a class="button" onclick="scroll_to('prev')">
              Previous
            </a><a class="button" onclick="scroll_to('next')">
              Next
            </a><span id="__autodiff__"></span></p><p>This draft contains only sections that have differences from the version that it modified.</p></div><div class="head"><p><a href="https://www.w3.org/"><img src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C" alt="W3C" height="48" width="72"></a></p><h1><a id="title"></a>XQuery 4.0: An XML Query Language </h1><h2><a id="w3c-doctype"></a>W3C Editor's Draft <span class="deltaxml-old" style="background:#FF5555">30&nbsp;January</span><span class="deltaxml-new" style="background:#90EE90">2&nbsp;February</span>&nbsp;2026</h2><dl><dt>This version:</dt><dd><a href="https://qt4cg.org/specifications/xquery-40/">https://qt4cg.org/specifications/xquery-40/</a></dd><dt>Most recent version of XQuery:</dt><dd><a href="https://qt4cg.org/specifications/xquery-40/">https://qt4cg.org/specifications/xquery-40/</a></dd><dt>Most recent Recommendation of XQuery:</dt><dd><a href="https://www.w3.org/TR/2017/REC-xquery-31-20170321/">https://www.w3.org/TR/2017/REC-xquery-31-20170321/</a></dd><dt>Editor:</dt><dd>Michael Kay, Saxonica <a href="http://www.saxonica.com/">&lt;http://www.saxonica.com/&gt;</a></dd></dl><p>This document is also available in these non-normative formats: <a href="xquery-40.xml">XML</a>.</p><p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;©&nbsp;2000&nbsp;<a href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="https://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="https://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="https://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p><hr></div><div><h2><a id="abstract"></a>Abstract</h2><p class="xquery">XML is a versatile markup language, capable of labeling the information content of diverse data sources, including structured and semi-structured documents, relational databases, and object repositories. A query language that uses the structure of XML intelligently can express queries across all these kinds of data, whether physically stored in XML or viewed as XML via middleware. This specification describes a query language called XQuery, which is designed to be broadly applicable across many types of XML data sources.</p><p class="xquery">A list of changes made since XQuery 3.1 can be found in <a href="#id-revision-log"><b>J Change Log</b></a>. </p></div><div><h2><a id="status"></a>Status of this Document</h2><p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document.</em></p><p>This document is a working draft developed and maintained by a W3C Community Group, the <a href="https://www.w3.org/community/xslt-40/">XQuery and XSLT Extensions Community Group</a> unofficially known as QT4CG (where "QT" denotes Query and Transformation). This draft is work in progress and should not be considered either stable or complete. Standard W3C copyright and patent conditions apply.</p><p>The community group welcomes comments on the specification. Comments are best submitted as issues on the group's <a href="https://github.com/qt4cg/qtspecs/issues">GitHub repository</a>.</p><p id="at-risk">As the Community Group moves towards publishing dated, stable drafts, some features that the group thinks may likely be removed or substantially changed are marked “at risk” in their changes section. In this draft:</p><ul><li><a href="#id-filter-maps-and-arrays">Filter Expressions for Maps and Arrays</a></li></ul><p>The community group maintains two extensive test suites, one oriented to XQuery and XPath, the other to XSLT. These can be found at <a href="https://github.com/qt4cg/qt4tests">qt4tests</a> and <a href="https://github.com/qt4cg/xslt40-test">xslt40-test</a> respectively. New tests, or suggestions for correcting existing tests, are welcome. The test suites include extensive metadata describing the conditions for applicability of each test case as well as the expected results. They do not include any test drivers for executing the tests: each implementation is expected to provide its own test driver.</p><div class="dedication" id="dedication"><h3>Dedication</h3><p class="xquery">The publications of this community group <a href="xpath-40.html#dedication">are dedicated</a> to our co-chair, Michael Sperberg-McQueen&nbsp;(1954–2024).</p></div></div><hr><div class="body"><div class="_diffs div1"><h2><a id="id-basics"></a>2 <a href="#id-basics" style="text-decoration: none">Basics</a></h2><div class="_diffs div2"><h3><a id="id-terminology"></a>2.1 <a href="#id-terminology" style="text-decoration: none">Terminology</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-ebnf-introduction">next</a> | <a href="#id-introduction">previous</a>)</p><ol><li><p>The EBNF operators <code>++</code> and <code>**</code> have been introduced, for more concise representation of sequences using a character such as <code>","</code> as a separator. The notation is borrowed from Invisible XML.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1366">1366</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1498">1498</a>]</i></p></li></ol></div><p>The basic building block of XQuery 4.0 is the <b>expression</b>, which is a string of <a href="#Unicode">[Unicode]</a> characters; the version of Unicode to be used is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The language provides several kinds of expressions which may be constructed from keywords, symbols, and operands. In general, the operands of an expression are other expressions. XQuery 4.0 allows expressions to be nested with full generality. <span class="xquery">(However, unlike a pure functional language, it does not allow variable substitution if the variable declaration contains construction of new nodes.)</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>This specification contains no assumptions or requirements regarding the character set encoding of strings of <a href="#Unicode">[Unicode]</a> characters.</p></div><p>Like XML, XQuery 4.0 is a case-sensitive language. Keywords in XQuery 4.0 use lower-case characters and are not reserved—that is, names in XQuery 4.0 expressions are allowed to be the same as language keywords, except for certain unprefixed function-names listed in <a href="#id-reserved-fn-names"><b>A.4 Reserved Function Names</b></a>.</p><p>In this specification the phrases <span class="verb">must</span>, <span class="verb">must not</span>, <span class="verb">should</span>, <span class="verb">should not</span>, <span class="verb">may</span>, <span class="verb">required</span>, and <span class="verb">recommended</span>, when used in normative text and rendered in small capitals, are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p><p>Certain aspects of language processing are described in this specification as <b>implementation-defined</b> or <b>implementation-dependent</b>.</p><ul><li><p> [<a id="dt-implementation-defined" title="implementation defined">Definition</a>: <b>Implementation-defined</b> indicates an aspect that may differ between implementations, but must be specified by the implementer for each particular implementation.] </p></li><li><p> [<a id="dt-implementation-dependent" title="implementation   dependent">Definition</a>: <b>Implementation-dependent</b> indicates an aspect that may differ between implementations, is not specified by this or any W3C specification, and is not required to be specified by the implementer for any particular implementation.] </p></li></ul><div class="_diffs div3"><h4><a id="id-values"></a>2.1.3 <a href="#id-values" style="text-decoration: none">Values</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-namespaces-and-qnames">next</a> | <a href="#id-expression-names">previous</a>)</p><ol><li><p> The term <b>atomic value</b> has been replaced by <a title="atomic item" class="termref" href="#dt-atomic-item">atomic item</a>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1337">1337</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1361">1361</a>&nbsp;2 August 2024]</i></p></li><li><p> The terms <b>XNode</b> and <code>JNode</code> are introduced; the existing term <b>node</b> remains in use as a synonym for <b>XNode</b> where the context does not specify otherwise. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2025">2025</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2031">2031</a>&nbsp;13 June 2025]</i></p></li></ol></div><p> [<a id="dt-value" title="value">Definition</a>: In the <a title="data model" class="termref" href="#dt-datamodel">data model</a>, a <b>value</b> is always a <a title="sequence" class="termref" href="#dt-sequence">sequence</a>.] </p><p> [<a id="dt-sequence" title="sequence">Definition</a>: A <b>sequence</b> is an ordered collection of zero or more <a title="item" class="termref" href="#dt-item">items</a>.] </p><p> [<a id="dt-item" title="item">Definition</a>: An <b>item</b> is either an <a title="atomic item" class="termref" href="#dt-atomic-item">atomic item</a>, a <a title="node" class="termref" href="#dt-node">node</a>, or a <a title="function item" class="termref" href="#dt-function-item">function item</a>.] </p><p> [<a id="dt-atomic-item" title="atomic item">Definition</a>: An <b>atomic item</b> is a value in the value space of an <b>atomic type</b>, as defined in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.] </p><p> [<a id="dt-XNode" title="XNode">Definition</a>: An <b>XNode</b> is an instance of one of the <b>node kinds</b> defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#nodes">7.1 XML Nodes</a>.] Each XNode has a unique <b>node identity</b>, a <b>typed value</b>, and a <b>string value</b>. In addition, some XNodes have a <b>name</b>. The <b>typed value</b> of an XNode is a sequence of zero or more atomic items. The <b>string value</b> of an XNode is a value of type <code>xs:string</code>. The <b>name</b> of an XNode is a value of type <code>xs:QName</code>.</p><p> [<a id="dt-node" title="node">Definition</a>: Except where the context indicates otherwise, the term <b>node</b> is used as a synonym for <a title="XNode" class="termref" href="#dt-XNode">XNode</a>.] </p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-JNode" title="JNode"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">JNode</span></b><span class="deltaxml-new" style="background:#90EE90"> (see also </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XDM 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> section </span><a href="../xpath-datamodel-40/#id-JNodes"><span class="deltaxml-new" style="background:#90EE90">8.4 JNodes</span></a><span class="deltaxml-new" style="background:#90EE90">) is an encapsulation of a value as it appears within a tree of maps and arrays, typically (but not necessarily) obtained by parsing JSON texts.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-GNode" title="GNode"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">GNode</span></b><span class="deltaxml-new" style="background:#90EE90"> (for </span><em><span class="deltaxml-new" style="background:#90EE90">generalized node</span></em><span class="deltaxml-new" style="background:#90EE90">) is either an </span><a title="XNode" class="termref" href="#dt-XNode"><span class="deltaxml-new" style="background:#90EE90">XNode</span></a><span class="deltaxml-new" style="background:#90EE90"> or a </span><a title="JNode" class="termref" href="#dt-JNode"><span class="deltaxml-new" style="background:#90EE90">JNode</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p> [<a id="dt-function-item" title="function item">Definition</a>: A <b>function item</b> is an item that can be called using a <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a>.] </p><p>Maps (see <a href="#id-maps"><b>4.14.1 Maps</b></a>) and arrays (see <a href="#id-arrays"><b>4.14.2 Arrays</b></a>) are specific kinds of <a title="function item" class="termref" href="#dt-function-item">function item</a>s.</p><p><span style="display: none;" class="delete_version"> [<a id="dt-singleton" title="singleton">Definition</a>: A sequence containing exactly one item is called a <b>singleton</b>.] An item is identical to a singleton sequence containing that item. Sequences are never nested—for example, combining the values 1, (2, 3), and ( ) into a single sequence results in the sequence (1, 2, 3). [<a id="dt-empty-sequence" title="empty sequence">Definition</a>: A sequence containing zero items is called an <b>empty sequence</b>.] </span><span style="display: none;" class="add_version"> [<a id="dt-singleton" title="singleton">Definition</a>: A sequence containing exactly one item is called a <b>singleton</b>.] An item is identical to a singleton sequence containing that item. Sequences are never nested—for example, combining the values 1, (2, 3), and ( ) into a single sequence results in the sequence (1, 2, 3). [<a id="dt-empty-sequence" title="empty sequence">Definition</a>: The sequence containing zero items is called the <b>empty sequence</b>.] </span><span class="modify_version"> [<a id="dt-singleton" title="singleton">Definition</a>: A sequence containing exactly one item is called a <b>singleton</b>.] An item is identical to a singleton sequence containing that item. Sequences are never nested—for example, combining the values 1, (2, 3), and ( ) into a single sequence results in the sequence (1, 2, 3). [<a id="dt-empty-sequence" title="empty sequence">Definition</a>: <span class="deltaxml-old" style="background:#FF5555">A</span><span class="deltaxml-new" style="background:#90EE90">The</span> sequence containing zero items is called <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> <b>empty sequence</b>.] </span></p><p> [<a id="dt-data-model-instance" title="XDM instance">Definition</a>: The term <b>XDM instance</b> is used, synonymously with the term <a title="value" class="termref" href="#dt-value">value</a>, to denote an unconstrained <a title="sequence" class="termref" href="#dt-sequence">sequence</a> of <a title="item" class="termref" href="#dt-item">items</a>.] </p></div></div><div class="_diffs div2"><h3><a id="id-security-resources"></a>2.3 <a href="#id-security-resources" style="text-decoration: none">External Resources and Security</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-processing-model">next</a> | <a href="#eval_context">previous</a>)</p><ol><li><p>This section (“External Resources and Security”) is new.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2047">2047</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2213">2213</a>&nbsp;23 October 2025]</i></p></li></ol></div><p>The XPath, XQuery, and XSLT languages provide a number of capabilities to access external resources. These include:</p><ul><li><p>Functions such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc-available"><code>doc-available</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-unparsed-text"><code>unparsed-text</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-unparsed-text-lines"><code>unparsed-text-lines</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-unparsed-text-available"><code>unparsed-text-available</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-uri-collection"><code>uri-collection</code></a>, and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-unparsed-binary"><code>unparsed-binary</code></a>, and in XSLT, the <code>document</code> function and the <code>xsl:source-document</code> and <code>xsl:merge</code> instructions.</p></li><li><p>Static inclusion of code using <code>import module</code> in XQuery, or <code>xsl:include</code>, <code>xsl:import</code>, and <code>xsl:use-package</code> in XSLT.</p></li><li><p>Dynamic inclusion and execution of external code using the functions <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-transform"><code>transform</code></a> and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-load-xquery-module"><code>load-xquery-module</code></a>, and in XSLT, the <code>xsl:evaluate</code> instruction.</p></li><li><p>The ability to write to external resources using the <code>xsl:result-document</code> instruction in XSLT, or the <code>put</code> function in the XQuery Update Facility.</p></li><li><p>The ability to invoke arbitrary user-defined external functions (called extension functions in XSLT).</p></li><li><p>The ability to invoke vendor-defined external/extension functions; a notable example being the EXPath File library.</p></li><li><p>Access to environment variables and system properties using functions such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-environment-variable"><code>environment-variable</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-available-environment-variables"><code>available-environment-variables</code></a>, and (in XSLT) <code>system-property</code>.</p></li><li><p>Static inclusion of XSD schemas and schema documents using <code>import schema</code>in XQuery or <code>xsl:import-schema</code> in XSLT, or indirectly using <code>xs:import</code>, <code>xs:include</code>, <code>xs:redefine</code>, or <code>xs:override</code> in XSD schema documents.</p></li><li><p>Dynamic loading of XSD schema documents (directly or indirectly) using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-xsd-validator"><code>xsd-validator</code></a> function.</p></li><li><p>The ability to parse XML or HTML documents that contain references to external entities, for example by using the <code>parse-xml</code> and <code>parse-html</code> functions.</p></li><li><p>The ability to parse XML documents in a way that causes other external resources to be fetched, for example by activating XInclude, or by performing XSD validation using <code>xsi:schema-location</code>.</p></li><li><p>Implicit access to third-party libraries supporting (for example) collations or localization.</p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">External resources are always referenced by means of a URI. The way in which a URI is dereferenced to obtain a resource is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation defined</span></a><span class="deltaxml-new" style="background:#90EE90">. It is </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">recommended</span></span><span class="deltaxml-new" style="background:#90EE90"> that popular URI schemes such as </span><code><span class="deltaxml-new" style="background:#90EE90">http</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">https</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">file</span></code><span class="deltaxml-new" style="background:#90EE90"> should be supported, but this </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> be subject to user configuration and security constraints. Implementations are free to support indirection mechanisms such as catalogs and resolver callbacks, as well as supporting additional URI schemes and protocols, whether standardized or not.</span></p><p> [<a id="dt-trusted" title="trusted">Definition</a>: The static context includes a boolean property called <b>trusted</b> that determines whether external resources are available.] This may take the following values:</p><ol class="enumar"><li><p><b>false</b>: No external resources are available other than resources explicitly made available by the caller through some trusted implementation-defined mechanism.</p><p> [<a id="dt-untrusted" title="untrusted">Definition</a>: ]Code executing with <a title="trusted" class="termref" href="#dt-trusted">trusted</a> set to <code>false</code> is said to be <b>untrusted</b>. </p></li><li><p><b>true</b>: Trusted code has access to all the resources available to its immediate caller.</p></li></ol><p>The functions <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-transform"><code>transform</code></a> and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-load-xquery-module"><code>load-xquery-module</code></a>, and the XSLT instruction <code>xsl:evaluate</code>, have an option allowing the trust level of the executed code to be set:</p><ol class="enumar"><li><p>If <code>trusted</code> is set to <code>true</code>, the invoked code executes with the same trust level as its caller.</p></li><li><p>If <code>trusted</code> is set to <code>false</code>, the invoked code is not able to access any external resources other than resources explicitly made available using an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation defined</a> mechanism under the control of the caller.</p></li></ol><p>Some resources, such as XML documents, may themselves contain references to other resources. For example, an XML document may reference external entities (including an external DTD). External entity expansion is recognized as a known security risk. Functions that invoke XML parsing (such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-parse-xml"><code>parse-xml</code></a>, <code>doc</code>, or <code>collection</code>) therefore have a <code>trusted</code> option indicating whether the document being parsed is trusted to access external entities. Such access is allowed only if (a) the <code>trusted</code> option is set to <code>true</code>, or (b) access to the external entity in question is explicitly enabled by the caller.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The term <b>explicitly enabled</b> is not intended to mean that every resource to which access is permitted must be individually listed. The mechanism for enabling access might provide access to a class of resources (for example, all resources accessible using the HTTPS protocol, or all resources within the containing XML database having particular access permissions). The mechanism might also take account of other criteria, for example it might impose limits on the size or other characteristics of the resources accessed.</p></div><p>It is <span class="verb">recommended</span> that any external API used to invoke XPath, XQuery, or XSLT processing should similarly offer the ability to indicate whether the code being executed is <a title="trusted" class="termref" href="#dt-trusted">trusted</a>.</p><p>In the interests of security, the default for these options is <b>false</b>. However, for backwards compatibility reasons, processors <span class="verb">may</span> provide an option whereby a trusted user can change the default.</p><p>In general, when an application requests access to an external resource which is not available because the application is untrusted, the processor <span class="verb">should</span> behave in the same way as if the resource did not exist. However, the processor <span class="verb">may</span> choose to disclose in its diagnostics why the request was unsuccessful.</p><p>A processor <span class="verb">may</span> (but is not <span class="verb">required</span> to) limit an application’s consumption of resources such as CPU cycles and memory when the application is untrusted.</p><p> [<a id="dt-available-docs" title="available documents">Definition</a>: The term <b>available documents</b> refers (TODO: for the time being) to the set of XML documents that an application is able to access by URI.] </p></div><div class="_diffs div2"><h3><a id="id-processing-model"></a>2.4 <a href="#id-processing-model" style="text-decoration: none">Processing Model</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-guarded-expressions">next</a> | <a href="#id-security-resources">previous</a>)</p><ol><li><p> The static typing option has been dropped. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1343">1343</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1344">1344</a>&nbsp;3 September 2024]</i></p></li></ol></div><p>The semantics of XQuery 4.0 are defined in terms of the <a title="data model" class="termref" href="#dt-datamodel">data model</a> and the <a title="expression context" class="termref" href="#dt-expression-context">expression context</a>.</p><div class="svg-image"><svg xmlns="http://www.w3.org/2000/svg" width="630pt" height="667pt" viewBox="0.00 0.00 629.62 666.50" preserveAspectRatio="xMidYMid meet" zoomAndPan="magnify" version="1.1" contentscripttype="text/ecmascript" contentstyletype="text/css"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 662.5)"><title>Processing_Model</title><g id="a_graph0"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="XQuery Processing Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="white" stroke="none" points="-4,4 -4,-662.5 625.62,-662.5 625.62,4 -4,4"/></a></g><g id="clust1" class="cluster"><title>clusterQT4</title><g id="a_clust1"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="Query Processing" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="none" stroke="black" points="260,-80.5 260,-575 526,-575 526,-80.5 260,-80.5"/><text text-anchor="middle" x="393" y="-557.7" font-family="Times,serif" font-size="14.00">Query Processing</text></a></g></g><g id="clust2" class="cluster"><title>clusterEP</title><g id="a_clust2"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="XQuery Processing Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="none" stroke="black" points="8,-174 8,-349 252,-349 252,-174 8,-174"/><text text-anchor="middle" x="130" y="-331.7" font-family="Times,serif" font-size="14.00">External processing</text></a></g></g><g id="node1" class="node"><title>Exec</title><g id="a_node1"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="Execution Engine" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M351.38,-223C351.38,-223 304.62,-223 304.62,-223 298.62,-223 292.62,-217 292.62,-211 292.62,-211 292.62,-194 292.62,-194 292.62,-188 298.62,-182 304.62,-182 304.62,-182 351.38,-182 351.38,-182 357.38,-182 363.38,-188 363.38,-194 363.38,-194 363.38,-211 363.38,-211 363.38,-217 357.38,-223 351.38,-223"/><text text-anchor="middle" x="328" y="-205.7" font-family="Times,serif" font-size="14.00">Execution</text><text text-anchor="middle" x="328" y="-189.2" font-family="Times,serif" font-size="14.00">Engine</text></a></g></g><g id="node2" class="node"><title>XDM</title><g id="a_node2"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#dt-data-model-instance" xlink:title="XPath Data Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="none" stroke="black" points="347.5,-129.5 268.5,-129.5 268.5,-88.5 347.5,-88.5 347.5,-129.5"/><text text-anchor="middle" x="308" y="-112.2" font-family="Times,serif" font-size="14.00" fill="blue">XPath Data</text><text text-anchor="middle" x="308" y="-95.7" font-family="Times,serif" font-size="14.00" fill="blue">Model</text></a></g></g><g id="edge9" class="edge"><title>Exec-&gt;XDM</title><g id="a_edge9"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title=" DQ4" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M321.21,-170.46C319.13,-160.9 316.83,-150.39 314.74,-140.84"/><polygon fill="black" stroke="black" points="317.78,-171.15 323.34,-180.17 324.62,-169.65 317.78,-171.15"/><polygon fill="black" stroke="black" points="318.21,-140.32 312.65,-131.29 311.37,-141.81 318.21,-140.32"/></a></g><g id="a_edge9-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title="Access and create" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="334.79" y="-150.7" font-family="Times,serif" font-size="14.00" fill="blue"> DQ4</text></a></g></g><g id="node16" class="node"><title>Serialize</title><polygon fill="none" stroke="black" points="333.62,-36 276.38,-36 276.38,0 339.62,0 339.62,-30 333.62,-36"/><polyline fill="none" stroke="black" points="333.62,-36 333.62,-30"/><polyline fill="none" stroke="black" points="339.62,-30 333.62,-30"/><text text-anchor="middle" x="308" y="-12.95" font-family="Times,serif" font-size="14.00">Serialize</text></g><g id="edge18" class="edge"><title>XDM-&gt;Serialize</title><g id="a_edge18"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#id-serialization" xlink:title=" DM4" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M308,-88.25C308,-76.33 308,-60.94 308,-47.69"/><polygon fill="black" stroke="black" points="311.5,-47.81 308,-37.81 304.5,-47.81 311.5,-47.81"/></a></g><g id="a_edge18-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#id-serialization" xlink:title="Serialize" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="324.5" y="-57.2" font-family="Times,serif" font-size="14.00" fill="blue"> DM4</text></a></g></g><g id="node3" class="node"><title>AST</title><g id="a_node3"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ5" xlink:title="Abstract Syntax Tree (AST)" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M375.75,-316.5C375.75,-316.5 280.25,-316.5 280.25,-316.5 274.25,-316.5 268.25,-310.5 268.25,-304.5 268.25,-304.5 268.25,-287.5 268.25,-287.5 268.25,-281.5 274.25,-275.5 280.25,-275.5 280.25,-275.5 375.75,-275.5 375.75,-275.5 381.75,-275.5 387.75,-281.5 387.75,-287.5 387.75,-287.5 387.75,-304.5 387.75,-304.5 387.75,-310.5 381.75,-316.5 375.75,-316.5"/><text text-anchor="middle" x="328" y="-299.2" font-family="Times,serif" font-size="14.00" fill="blue">Abstract</text><text text-anchor="middle" x="328" y="-282.7" font-family="Times,serif" font-size="14.00" fill="blue">Syntax Tree (AST)</text></a></g></g><g id="edge3" class="edge"><title>AST-&gt;Exec</title><g id="a_edge3"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title=" DQ1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M328,-275.15C328,-263.28 328,-247.94 328,-234.5"/><polygon fill="black" stroke="black" points="331.5,-234.83 328,-224.83 324.5,-234.83 331.5,-234.83"/></a></g><g id="a_edge3-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title="Access AST" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="343" y="-244.2" font-family="Times,serif" font-size="14.00" fill="blue"> DQ1</text></a></g></g><g id="edge2" class="edge"><title>AST-&gt;AST</title><g id="a_edge2"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ5" xlink:title=" SQ5" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M387.98,-304.22C398.46,-303.12 405.75,-300.38 405.75,-296 405.75,-293.47 403.31,-291.48 399.23,-290.05"/><polygon fill="black" stroke="black" points="399.96,-286.62 389.47,-288.08 398.58,-293.49 399.96,-286.62"/></a></g><g id="a_edge2-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ5" xlink:title="Normalize" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="419.62" y="-290.95" font-family="Times,serif" font-size="14.00" fill="blue"> SQ5</text></a></g></g><g id="node4" class="node"><title>Static</title><g id="a_node4"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#dt-static-context" xlink:title="Static Context" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="none" stroke="black" points="513.38,-432.5 458.62,-432.5 454.62,-428.5 454.62,-391.5 509.38,-391.5 513.38,-395.5 513.38,-432.5"/><polyline fill="none" stroke="black" points="509.38,-428.5 454.62,-428.5"/><polyline fill="none" stroke="black" points="509.38,-428.5 509.38,-391.5"/><polyline fill="none" stroke="black" points="509.38,-428.5 513.38,-432.5"/><text text-anchor="middle" x="484" y="-415.2" font-family="Times,serif" font-size="14.00" fill="blue">Static</text><text text-anchor="middle" x="484" y="-398.7" font-family="Times,serif" font-size="14.00" fill="blue">Context</text></a></g></g><g id="edge6" class="edge"><title>Static-&gt;AST</title><g id="a_edge6"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ1234" xlink:title=" SQ4" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M456.83,-391.14C431.18,-372.4 392.55,-344.17 364.28,-323.51"/><polygon fill="black" stroke="black" points="366.48,-320.79 356.35,-317.71 362.35,-326.44 366.48,-320.79"/></a></g><g id="a_edge6-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ1234" xlink:title="Resolve names" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="442.96" y="-360.2" font-family="Times,serif" font-size="14.00" fill="blue"> SQ4</text></a></g></g><g id="node5" class="node"><title>Dynamic</title><g id="a_node5"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#dt-dynamic-context" xlink:title="Dynamic Context" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="none" stroke="black" points="518.12,-316.5 455.88,-316.5 451.88,-312.5 451.88,-275.5 514.12,-275.5 518.12,-279.5 518.12,-316.5"/><polyline fill="none" stroke="black" points="514.12,-312.5 451.88,-312.5"/><polyline fill="none" stroke="black" points="514.12,-312.5 514.12,-275.5"/><polyline fill="none" stroke="black" points="514.12,-312.5 518.12,-316.5"/><text text-anchor="middle" x="485" y="-299.2" font-family="Times,serif" font-size="14.00" fill="blue">Dynamic</text><text text-anchor="middle" x="485" y="-282.7" font-family="Times,serif" font-size="14.00" fill="blue">Context</text></a></g></g><g id="edge7" class="edge"><title>Static-&gt;Dynamic</title><g id="a_edge7"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title=" DQ2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M484.17,-391.14C484.33,-373.73 484.55,-348.14 484.73,-328.03"/><polygon fill="black" stroke="black" points="488.23,-328.17 484.81,-318.14 481.23,-328.11 488.23,-328.17"/></a></g><g id="a_edge7-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title="Provide access" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="499.47" y="-360.2" font-family="Times,serif" font-size="14.00" fill="blue"> DQ2</text></a></g></g><g id="edge8" class="edge"><title>Dynamic-&gt;Exec</title><g id="a_edge8"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title=" DQ5" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M442.04,-269.96C420.21,-257.24 393.74,-241.81 371.79,-229.02"/><polygon fill="black" stroke="black" points="439.99,-272.82 450.4,-274.83 443.52,-266.77 439.99,-272.82"/><polygon fill="black" stroke="black" points="373.77,-226.12 363.37,-224.11 370.25,-232.17 373.77,-226.12"/></a></g><g id="a_edge8-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title="Access and change" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="435.56" y="-244.2" font-family="Times,serif" font-size="14.00" fill="blue"> DQ5</text></a></g></g><g id="node6" class="node"><title>Schema</title><g id="a_node6"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#dt-issd" xlink:title="In-Scope Schema Definitions" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="none" stroke="black" points="434.38,-542.5 357.62,-542.5 357.62,-485 434.38,-485 434.38,-542.5"/><text text-anchor="middle" x="396" y="-525.2" font-family="Times,serif" font-size="14.00" fill="blue">In-Scope</text><text text-anchor="middle" x="396" y="-508.7" font-family="Times,serif" font-size="14.00" fill="blue">Schema</text><text text-anchor="middle" x="396" y="-492.2" font-family="Times,serif" font-size="14.00" fill="blue">Definitions</text></a></g></g><g id="edge4" class="edge"><title>Schema-&gt;Static</title><path fill="none" stroke="black" d="M420.75,-484.7C432.67,-471.18 446.95,-455 458.92,-441.43"/><polygon fill="black" stroke="black" points="461.41,-443.89 465.4,-434.08 456.16,-439.26 461.41,-443.89"/></g><g id="node7" class="node"><title>XQuery</title><g id="a_node7"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="XQuery/XQueryX" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M350.62,-432.5C350.62,-432.5 305.38,-432.5 305.38,-432.5 299.38,-432.5 293.38,-426.5 293.38,-420.5 293.38,-420.5 293.38,-403.5 293.38,-403.5 293.38,-397.5 299.38,-391.5 305.38,-391.5 305.38,-391.5 350.62,-391.5 350.62,-391.5 356.62,-391.5 362.62,-397.5 362.62,-403.5 362.62,-403.5 362.62,-420.5 362.62,-420.5 362.62,-426.5 356.62,-432.5 350.62,-432.5"/><text text-anchor="middle" x="328" y="-415.2" font-family="Times,serif" font-size="14.00">XQuery/</text><text text-anchor="middle" x="328" y="-398.7" font-family="Times,serif" font-size="14.00">XQueryX</text></a></g></g><g id="edge1" class="edge"><title>XQuery-&gt;AST</title><g id="a_edge1"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ1234" xlink:title=" SQ1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M328,-391.14C328,-373.73 328,-348.14 328,-328.03"/><polygon fill="black" stroke="black" points="331.5,-328.14 328,-318.14 324.5,-328.14 331.5,-328.14"/></a></g><g id="a_edge1-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ1234" xlink:title="Parse query" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="341.88" y="-360.2" font-family="Times,serif" font-size="14.00" fill="blue"> SQ1</text></a></g></g><g id="node8" class="node"><title>Modules</title><g id="a_node8"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#id-module-declaration" xlink:title="Modules" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M504,-531.75C504,-531.75 464,-531.75 464,-531.75 458,-531.75 452,-525.75 452,-519.75 452,-519.75 452,-507.75 452,-507.75 452,-501.75 458,-495.75 464,-495.75 464,-495.75 504,-495.75 504,-495.75 510,-495.75 516,-501.75 516,-507.75 516,-507.75 516,-519.75 516,-519.75 516,-525.75 510,-531.75 504,-531.75"/><text text-anchor="middle" x="484" y="-508.7" font-family="Times,serif" font-size="14.00" fill="blue">Modules</text></a></g></g><g id="edge5" class="edge"><title>Modules-&gt;Static</title><g id="a_edge5"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ1234" xlink:title=" SQ3" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M484,-495.37C484,-481.22 484,-460.89 484,-443.97"/><polygon fill="black" stroke="black" points="487.5,-444.43 484,-434.43 480.5,-444.43 487.5,-444.43"/></a></g><g id="a_edge5-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ1234" xlink:title="Augment with module prolog" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="497.88" y="-453.7" font-family="Times,serif" font-size="14.00" fill="blue"> SQ3</text></a></g></g><g id="node9" class="node"><title>XML</title><polygon fill="none" stroke="black" points="64,-314 16,-314 16,-278 70,-278 70,-308 64,-314"/><polyline fill="none" stroke="black" points="64,-314 64,-308"/><polyline fill="none" stroke="black" points="70,-308 64,-308"/><text text-anchor="middle" x="43" y="-290.95" font-family="Times,serif" font-size="14.00">XML</text></g><g id="node11" class="node"><title>PSVI</title><g id="a_node11"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#id-data-model-generation" xlink:title="Infoset/PSVI" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="none" stroke="black" points="89.62,-223 38.38,-223 38.38,-182 95.62,-182 95.62,-217 89.62,-223"/><polyline fill="none" stroke="black" points="89.62,-223 89.62,-217"/><polyline fill="none" stroke="black" points="95.62,-217 89.62,-217"/><text text-anchor="middle" x="67" y="-205.7" font-family="Times,serif" font-size="14.00" fill="blue">Infoset/</text><text text-anchor="middle" x="67" y="-189.2" font-family="Times,serif" font-size="14.00" fill="blue">PSVI</text></a></g></g><g id="edge10" class="edge"><title>XML-&gt;PSVI</title><g id="a_edge10"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DM1" xlink:title=" DM1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M47.51,-277.79C50.73,-265.54 55.14,-248.73 58.95,-234.21"/><polygon fill="black" stroke="black" points="62.3,-235.2 61.46,-224.64 55.53,-233.42 62.3,-235.2"/></a></g><g id="a_edge10-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DM1" xlink:title="Parse and optionally validate" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="73.65" y="-244.2" font-family="Times,serif" font-size="14.00" fill="blue"> DM1</text></a></g></g><g id="node10" class="node"><title>JSON</title><polygon fill="none" stroke="black" points="136,-314 88,-314 88,-278 142,-278 142,-308 136,-314"/><polyline fill="none" stroke="black" points="136,-314 136,-308"/><polyline fill="none" stroke="black" points="142,-308 136,-308"/><text text-anchor="middle" x="115" y="-290.95" font-family="Times,serif" font-size="14.00">JSON</text></g><g id="edge11" class="edge"><title>JSON-&gt;XDM</title><g id="a_edge11"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DM2" xlink:title=" DM2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M122.16,-277.83C133.44,-252.48 157.47,-204.7 190,-174 209.46,-155.63 235.2,-140.87 257.67,-130.17"/><polygon fill="black" stroke="black" points="259.07,-133.38 266.69,-126.02 256.14,-127.02 259.07,-133.38"/></a></g><g id="a_edge11-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DM2" xlink:title="Generate Data Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="206.5" y="-197.45" font-family="Times,serif" font-size="14.00" fill="blue"> DM2</text></a></g></g><g id="edge12" class="edge"><title>PSVI-&gt;XDM</title><g id="a_edge12"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DM2" xlink:title=" DM2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M69.38,-181.69C71.84,-170.02 76.84,-155.92 87,-147.5 112.23,-126.59 199.89,-116.96 256.94,-112.82"/><polygon fill="black" stroke="black" points="257.02,-116.33 266.75,-112.15 256.53,-109.34 257.02,-116.33"/></a></g><g id="a_edge12-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DM2" xlink:title="Generate Data Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="103.5" y="-150.7" font-family="Times,serif" font-size="14.00" fill="blue"> DM2</text></a></g></g><g id="node12" class="node"><title>Direct</title><g id="a_node12"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="Other/Direct Generation" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M232.12,-316.5C232.12,-316.5 171.88,-316.5 171.88,-316.5 165.88,-316.5 159.88,-310.5 159.88,-304.5 159.88,-304.5 159.88,-287.5 159.88,-287.5 159.88,-281.5 165.88,-275.5 171.88,-275.5 171.88,-275.5 232.12,-275.5 232.12,-275.5 238.12,-275.5 244.12,-281.5 244.12,-287.5 244.12,-287.5 244.12,-304.5 244.12,-304.5 244.12,-310.5 238.12,-316.5 232.12,-316.5"/><text text-anchor="middle" x="202" y="-299.2" font-family="Times,serif" font-size="14.00">Other/Direct</text><text text-anchor="middle" x="202" y="-282.7" font-family="Times,serif" font-size="14.00">Generation</text></a></g></g><g id="edge13" class="edge"><title>Direct-&gt;XDM</title><g id="a_edge13"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DM3" xlink:title=" DM3" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M207.72,-275.16C215.37,-250.35 230.42,-207.11 251,-174 258.93,-161.24 269.48,-148.58 279.34,-137.94"/><polygon fill="black" stroke="black" points="281.63,-140.62 286,-130.96 276.56,-135.78 281.63,-140.62"/></a></g><g id="a_edge13-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DM3" xlink:title="Other/Direct Generation" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="267.5" y="-197.45" font-family="Times,serif" font-size="14.00" fill="blue"> DM3</text></a></g></g><g id="node13" class="node"><title>XSD</title><g id="a_node13"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="XML Schema" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="none" stroke="black" points="374.75,-658.5 321.25,-658.5 321.25,-617.5 380.75,-617.5 380.75,-652.5 374.75,-658.5"/><polyline fill="none" stroke="black" points="374.75,-658.5 374.75,-652.5"/><polyline fill="none" stroke="black" points="380.75,-652.5 374.75,-652.5"/><text text-anchor="middle" x="351" y="-641.2" font-family="Times,serif" font-size="14.00">XML</text><text text-anchor="middle" x="351" y="-624.7" font-family="Times,serif" font-size="14.00">Schema</text></a></g></g><g id="edge14" class="edge"><title>XSD-&gt;Schema</title><g id="a_edge14"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#id-schema-import-processing" xlink:title=" SI1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M358.33,-617.09C364.65,-599.92 373.96,-574.63 381.74,-553.49"/><polygon fill="black" stroke="black" points="384.96,-554.89 385.13,-544.29 378.39,-552.47 384.96,-554.89"/></a></g><g id="a_edge14-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#id-schema-import-processing" xlink:title="XML Schema Import" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="382.06" y="-586.2" font-family="Times,serif" font-size="14.00" fill="blue"> SI1</text></a></g></g><g id="node14" class="node"><title>DirectXSD</title><g id="a_node14"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="Other/Direct Generation" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M471.12,-658.5C471.12,-658.5 410.88,-658.5 410.88,-658.5 404.88,-658.5 398.88,-652.5 398.88,-646.5 398.88,-646.5 398.88,-629.5 398.88,-629.5 398.88,-623.5 404.88,-617.5 410.88,-617.5 410.88,-617.5 471.12,-617.5 471.12,-617.5 477.12,-617.5 483.12,-623.5 483.12,-629.5 483.12,-629.5 483.12,-646.5 483.12,-646.5 483.12,-652.5 477.12,-658.5 471.12,-658.5"/><text text-anchor="middle" x="441" y="-641.2" font-family="Times,serif" font-size="14.00">Other/Direct</text><text text-anchor="middle" x="441" y="-624.7" font-family="Times,serif" font-size="14.00">Generation</text></a></g></g><g id="edge15" class="edge"><title>DirectXSD-&gt;Schema</title><g id="a_edge15"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SI2" xlink:title=" SI2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M433.67,-617.09C427.35,-599.92 418.04,-574.63 410.26,-553.49"/><polygon fill="black" stroke="black" points="413.61,-552.47 406.87,-544.29 407.04,-554.89 413.61,-552.47"/></a></g><g id="a_edge15-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SI2" xlink:title="Other/Direct Generation" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="437.69" y="-586.2" font-family="Times,serif" font-size="14.00" fill="blue"> SI2</text></a></g></g><g id="node15" class="node"><title>Host</title><g id="a_node15"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="Host Environment" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M609.62,-534.25C609.62,-534.25 546.38,-534.25 546.38,-534.25 540.38,-534.25 534.38,-528.25 534.38,-522.25 534.38,-522.25 534.38,-505.25 534.38,-505.25 534.38,-499.25 540.38,-493.25 546.38,-493.25 546.38,-493.25 609.62,-493.25 609.62,-493.25 615.62,-493.25 621.62,-499.25 621.62,-505.25 621.62,-505.25 621.62,-522.25 621.62,-522.25 621.62,-528.25 615.62,-534.25 609.62,-534.25"/><text text-anchor="middle" x="578" y="-516.95" font-family="Times,serif" font-size="14.00">Host</text><text text-anchor="middle" x="578" y="-500.45" font-family="Times,serif" font-size="14.00">Environment</text></a></g></g><g id="edge16" class="edge"><title>Host-&gt;Static</title><g id="a_edge16"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ1234" xlink:title=" SQ2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M559.43,-493.04C545.4,-478.15 525.95,-457.51 510.31,-440.92"/><polygon fill="black" stroke="black" points="512.98,-438.65 503.57,-433.77 507.88,-443.45 512.98,-438.65"/></a></g><g id="a_edge16-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ1234" xlink:title="Initialize from host environment" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="547.69" y="-453.7" font-family="Times,serif" font-size="14.00" fill="blue"> SQ2</text></a></g></g><g id="edge17" class="edge"><title>Host-&gt;Dynamic</title><g id="a_edge17"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title=" DQ3" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M574.75,-492.79C572.44,-480.41 568.87,-464.29 564,-450.5 548.03,-405.24 521.13,-356.55 503.22,-326.42"/><polygon fill="black" stroke="black" points="506.23,-324.64 498.08,-317.87 500.24,-328.25 506.23,-324.64"/></a></g><g id="a_edge17-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title="Initialize from host environment" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="571.59" y="-406.95" font-family="Times,serif" font-size="14.00" fill="blue"> DQ3</text></a></g></g></g></svg></div><p>Figure 1: Processing Model Overview</p><p>Figure 1 provides a schematic overview of the processing steps that are discussed in detail below. Some of these steps are completely outside the domain of XQuery 4.0; in Figure 1, these are depicted outside the line that represents the boundaries of the language, an area labeled <b>external processing</b>. The external processing domain includes generation of <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instances</a> that represent the data to be queried (see <a href="#id-data-model-generation"><b>2.4.1 Data Model Generation</b></a>), schema import processing (see <a href="#id-schema-import-processing"><b>2.4.2 Schema Import Processing</b></a>), and serialization<span class="xquery"> (see <a href="#id-serialization"><b>2.4.5 Serialization</b></a>)</span>. The area inside the boundaries of the language is known as the <span class="xquery"><b>query processing domain</b></span>, which includes the static analysis and dynamic evaluation phases (see <a href="#id-expression-processing"><b>2.4.3 Expression Processing</b></a>). Consistency constraints on the <span class="xquery">query</span> processing domain are defined in <a href="#id-consistency-constraints"><b>2.4.6 Consistency Constraints</b></a>.</p><div class="_diffs div3"><h4><a id="id-expression-processing"></a>2.4.3 <a href="#id-expression-processing" style="text-decoration: none">Expression Processing</a></h4><p>XQuery 4.0 defines two phases of processing called the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a> and the <a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation">dynamic evaluation phase</a> (see Figure 1). During the static analysis phase, <a title="static error" class="termref" href="#dt-static-error">static errors</a>, <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a>, or <a title="type error" class="termref" href="#dt-type-error">type errors</a> may be raised. During the dynamic evaluation phase, only <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a> or <a title="type error" class="termref" href="#dt-type-error">type errors</a> may be raised. These kinds of errors are defined in <a href="#id-kinds-of-errors"><b>2.5.1 Kinds of Errors</b></a>. </p><p>Within each phase, an implementation is free to use any strategy or algorithm whose result conforms to the specifications in this document.</p><div class="_diffs div4"><h5><a id="id-static-analysis"></a>2.4.3.1 <a href="#id-static-analysis" style="text-decoration: none">Static Analysis Phase</a></h5><p> [<a id="dt-static-analysis" title="static analysis phase">Definition</a>: The <b>static analysis phase</b> depends on the expression itself and on the <a title="static context" class="termref" href="#dt-static-context">static context</a>. The <b>static analysis phase</b> does not depend on input data (other than schemas).] </p><p id="SQ1234">During the static analysis phase, the <span class="xquery">query</span> is typically parsed into an internal representation called the <b>operation tree</b> (step SQ1 in Figure 1). A parse error is raised as a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXPST0003" title="err:XPST0003">err:XPST0003</a>]. The <a title="static context" class="termref" href="#dt-static-context">static context</a> is initialized by the implementation (step SQ2). <span class="xquery">The <a title="static context" class="termref" href="#dt-static-context">static context</a> is then changed and augmented based on information in the <b>prolog</b> (step SQ3). The static context is extended with function declarations and variable declarations from imported modules. If the <a title="schema aware feature" class="termref" href="#dt-schema-aware-feature">Schema Aware Feature</a> is supported, the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> are populated with information from imported schemas. </span> The <a title="static context" class="termref" href="#dt-static-context">static context</a> is used to resolve schema type names, function names, namespace prefixes, and variable names (step SQ4). If a name of one of these kinds in the <b>operation tree</b> is not found in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, a <a title="static error" class="termref" href="#dt-static-error">static error</a> ([<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>] or [<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>]) is raised (however, see exceptions to this rule in <a href="#id-element-test"><b>3.2.7.2 Element Types</b></a> and <a href="#id-attribute-test"><b>3.2.7.3 Attribute Types</b></a>.)</p><p id="SQ5">The <b>operation tree</b> is then typically normalized by making explicit the implicit operations such as <a title="atomization" class="termref" href="#dt-atomization">atomization</a> and extraction of <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean values</a> (step SQ5).</p><p>During the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a>, a processor may perform type analysis. The effect of type analysis is to assign a <a title="static type" class="termref" href="#dt-static-type">static type</a> to each expression in the operation tree. [<a id="dt-static-type" title="static type">Definition</a>: The <b>static type</b> of an expression is the best inference that the processor is able to make statically about the type of the result of the expression.] This specification does not define the rules for type analysis nor the static types that are assigned to particular expressions: the only constraint is that the inferred type must match all possible values that the expression is capable of returning.</p><p>Examples of inferred static types might be:</p><ul><li><p>For the expression <code>concat(a,b)</code> the inferred static type is <code>xs:string</code></p></li><li><p>For the expression <code>$a = $v</code> the inferred static type is <code>xs:boolean</code></p></li><li><p><span style="display: none;" class="delete_version">For the expression <code>$s[exp]</code> the inferred static type has the same item type as the static type of <code>$s</code>, but a cardinality that allows the empty sequence even if the static type of <code>$s</code> does not allow an empty sequence.</span><span style="display: none;" class="add_version">For the expression <code>$s[exp]</code> the inferred static type has the same item type as the static type of <code>$s</code>, but a cardinality that allows the empty sequence even if the static type of <code>$s</code> does not allow the empty sequence.</span><span class="modify_version">For the expression <code>$s[exp]</code> the inferred static type has the same item type as the static type of <code>$s</code>, but a cardinality that allows the empty sequence even if the static type of <code>$s</code> does not allow <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p>The inferred static type of the expression <code>data($x)</code> (whether written explicitly or inserted into the operation tree in places where atomization is implicit) depends on the inferred static type of <code>$x</code>: for example, if <code>$x</code> has type <code>element(*, xs:integer)</code> then <code>data($x)</code> has static type <code>xs:integer</code>.</p></li></ul><p>In XQuery 1.0 and XPath 2.0, rules for static type inferencing were published normatively in <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>, but implementations were allowed to refine these rules to infer a more precise type where possible. In subsequent versions, the rules for static type inferencing are entirely implementation-dependent.</p><p>Every kind of expression also imposes requirements on the type of its operands. For example, with the expression <code>substring($a, $b, $c)</code>, <code>$a</code> must be of type <code>xs:string</code> (or something that can be converted to <code>xs:string</code> by the function calling rules), while <code>$b</code> and <code>$c</code> must be numeric.</p><p>A processor <span class="verb">may</span> raise a type error during static analysis if the inferred static type of an expression has no overlap (intersection) with the required type, and cannot be converted to the required type using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. For example, given the call <code>fn:upper-case($s)</code>, the processor <span class="verb">may</span> raise an error if the declared or inferred type of <code>$s</code> is <code>xs:integer</code>, but not if it is <code>xs:anyAtomicType</code>. </p><p>In addition, type analysis <span class="verb">may</span> conclude that an expression is <a title="implausible" class="termref" href="#dt-implausible">implausible</a>. Implausible expressions may be considered erroneous unless such checks have been disabled. For example, the expression <code>round(tokenize($input))</code> is implausible because the required type for <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-round"><code>fn:round</code></a> is <code>xs:numeric?</code>, while the static type of <code>tokenize($input)</code> is <code>xs:string*</code>, and these two sequence types are <a title="substantively disjoint" class="termref" href="#dt-substantively-disjoint">substantively disjoint</a>. This topic is described further in <a href="#id-implausible-expressions"><b>2.5.6 Implausible Expressions</b></a>.</p><p>Alternatively, the processor <span class="verb">may</span> defer all type checking until the dynamic evaluation phase.</p></div></div></div><div class="_diffs div2"><h3><a id="errors"></a>2.5 <a href="#errors" style="text-decoration: none">Error Handling</a></h3><div class="_diffs div3"><h4><a id="id-errors-and-opt"></a>2.5.4 <a href="#id-errors-and-opt" style="text-decoration: none">Errors and Optimization</a></h4><p>Because different implementations may choose to evaluate or optimize an expression in different ways, certain aspects of raising <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a> are <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>, as described in this section.</p><p>An implementation is always free to evaluate the operands of an operator in any order.</p><p>In some cases, a processor can determine the result of an expression without accessing all the data that would be implied by the formal expression semantics. For example, the formal description of <a title="filter expression" class="termref" href="#dt-filter-expression">filter expressions</a> suggests that <code>$s[1]</code> should be evaluated by examining all the items in sequence <code>$s</code>, and selecting all those that satisfy the predicate <code>position()=1</code>. In practice, many implementations will recognize that they can evaluate this expression by taking the first item in the sequence and then exiting. If <code>$s</code> is defined by an expression such as <code>//book[author eq 'Berners-Lee']</code>, then this strategy may avoid a complete scan of a large document and may therefore greatly improve performance. However, a consequence of this strategy is that a dynamic error or type error that would be detected if the expression semantics were followed literally might not be detected at all if the evaluation exits early. In this example, such an error might occur if there is a <code>book</code> element in the input data with more than one <code>author</code> subelement.</p><p>The extent to which a processor may optimize its access to data, at the cost of not raising errors, is defined by the following rules.</p><p>Consider an expression <em>Q</em> that has an operand (sub-expression) <em>E</em>. In general the value of <em>E</em> is a sequence. At an intermediate stage during evaluation of the sequence, some of its items will be known and others will be unknown. If, at such an intermediate stage of evaluation, a processor is able to establish that there are only two possible outcomes of evaluating <em>Q</em>, namely the value <em>V</em> or an error, then the processor may deliver the result <em>V</em> without evaluating further items in the operand <em>E</em>. For this purpose, two values are considered to represent the same outcome if their items are pairwise the same, where nodes are the same if they have the same identity, and values are the same if they are equal and have exactly the same type.</p><p>There is an exception to this rule: If a processor evaluates an operand <em>E</em> (wholly or in part), then it is required to establish that the actual value of the operand <em>E</em> does not violate any constraints on its cardinality. For example, the expression <code>$e eq 0</code> results in a type error if the value of <code>$e</code> contains two or more items. A processor is not allowed to decide, after evaluating the first item in the value of <code>$e</code> and finding it equal to zero, that the only possible outcomes are the value <code>true</code> or a type error caused by the cardinality violation. It must establish that the value of <code>$e</code> contains no more than one item.</p><p>These rules apply to all the operands of an expression considered in combination: thus if an expression has two operands <em>E1</em> and <em>E2</em>, it may be evaluated using any samples of the respective sequences that satisfy the above rules.</p><p>The rules cascade: if <em>A</em> is an operand of <em>B</em> and <em>B</em> is an operand of <em>C</em>, then the processor needs to evaluate only a sufficient sample of <em>B</em> to determine the value of <em>C</em>, and needs to evaluate only a sufficient sample of <em>A</em> to determine this sample of <em>B</em>.</p><p>The effect of these rules is that the processor is free to stop examining further items in a sequence as soon as it can establish that further items would not affect the result except possibly by causing an error. For example, the processor may return <code>true</code> as the result of the expression <code>S1 = S2</code> as soon as it finds a pair of equal values from the two sequences.</p><p>Another consequence of these rules is that where none of the items in a sequence contributes to the result of an expression, the processor is not obliged to evaluate any part of the sequence. Again, however, the processor cannot dispense with a required cardinality check: if <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence is not permitted in the relevant context, then the processor must ensure that the operand is not <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p><p>Examples:</p><ul><li><p>If an implementation can find (for example, by using an index) that at least one item returned by <code>$expr1</code> in the following example has the value <code>47</code>, it is allowed to return <code>true</code> as the result of the <code>some</code> expression, without searching for another item returned by <code>$expr1</code> that would raise an error if it were evaluated. </p><div class="exampleInner"><pre xml:space="preserve">some $x in $expr1 satisfies $x = 47</pre></div></li><li><p>In the following example, if an implementation can find (for example, by using an index) the <code>product</code> element-nodes that have an <code>id</code> child with the value <code>47</code>, it is allowed to return these nodes as the result of the <a title="path expression" class="termref" href="#dt-path-expression">path expression</a>, without searching for another <code>product</code> node that would raise an error because it has an <code>id</code> child whose value is not an integer.</p><div class="exampleInner"><pre xml:space="preserve">//product[id = 47]</pre></div></li></ul><p>For a variety of reasons, including optimization, implementations may rewrite expressions into a different form. There are a number of rules that limit the extent of this freedom: </p><ul><li><p> Other than the raising or not raising of errors, the result of evaluating a rewritten expression must conform to the semantics defined in this specification for the original expression. </p><div class="note"><p class="prefix"><b>Note:</b></p><p> This allows an implementation to return a result in cases where the original expression would have raised an error, or to raise an error in cases where the original expression would have returned a result. The main cases where this is likely to arise in practice are (a) where a rewrite changes the order of evaluation, such that a subexpression causing an error is evaluated when the expression is written one way and is not evaluated when the expression is written a different way, and (b) where intermediate results of the evaluation cause overflow or other out-of-range conditions. </p></div><div class="note"><p class="prefix"><b>Note:</b></p><p> This rule does not mean that the result of the expression will always be the same in non-error cases as if it had not been rewritten, because there are many cases where the result of an expression is to some degree <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> or <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. </p></div></li><li><p> The rules described in <a href="#id-guarded-expressions"><b>2.5.5 Guarded Expressions</b></a> ensure that for certain kinds of expression (for example conditional expressions), changing the order of evaluation of subexpressions does not result in dynamic errors that would not otherwise occur.</p></li><li><p> Expressions must not be rewritten in such a way as to create or remove static errors. The static errors in this specification are defined for the original expression, and must be preserved if the expression is rewritten.</p></li><li><p> As stated earlier, an expression must not be rewritten to dispense with a required cardinality check: for example, <code>string-length(//title)</code> must raise an error if the document contains more than one title element. </p></li></ul></div><div class="_diffs div3"><h4><a id="id-guarded-expressions"></a>2.5.5 <a href="#id-guarded-expressions" style="text-decoration: none">Guarded Expressions</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-implausible-expressions">next</a> | <a href="#id-processing-model">previous</a>)</p><ol><li><p> The rules for “errors and optimization” have been tightened up to disallow many cases of optimizations that alter error behavior. In particular there are restrictions on reordering the operands of <code>and</code> and <code>or</code>, and of predicates in filter expressions, in a way that might allow the processor to raise dynamic errors that the author intended to prevent. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/71">71</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/230">230</a>&nbsp;15 November 2022]</i></p></li></ol></div><p> [<a id="dt-guarded" title="guarded">Definition</a>: An expression <var>E</var> is said to be <b>guarded</b> by some governing condition <var>C</var> if evaluation of <var>E</var> is not allowed to fail with a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> except when <var>C</var> applies.] </p><p>For example, in a conditional expression <code>if (P) then T else F</code>, the subexpression <var>T</var> is guarded by <var>P</var>, and the subexpression <var>F</var> is guarded by <code>not(P)</code>. One way an implementation can satisfy this rule is by not evaluating <var>T</var> unless <var>P</var> is true, and likewise not evaluating <var>F</var> unless <var>P</var> is false. Another way of satisfying the rule is for the implementation to evaluate all the subexpressions, but to catch any errors that occur in a guarded subexpression so they are not propagated. </p><p>The existence of this rule enables errors to be prevented by writing expressions such as <code>if ($y eq 0) then "N/A" else ($x div $y)</code>. This example will never fail with a divide-by-zero error because the <code>else</code> branch of the conditional is <a title="guarded" class="termref" href="#dt-guarded">guarded</a>.</p><p>Similarly, in the mapping expression <code><var>E<sub>1</sub></var>!<var>E<sub>2</sub></var></code>, the subexpression <var>E<sub>2</sub></var> is guarded by the existence of an item from <var>E<sub>1</sub></var>. This means, for example, that the expression <code>(1 to $n)!doc('bad.xml')</code> must not raise a dynamic error if <code>$n</code> is zero. The rule governing evaluation of guarded expressions is phrased so as not to disallow “loop-lifting” or “constant-folding” optimizations whose aim is to avoid repeated evaluation of a common subexpression; but such optimizations must not result in errors that would not otherwise occur.</p><p>The complete list of expressions that have guarded subexpressions is as follows:</p><ul><li><p>In a conditional expression (<a href="#doc-xquery40-IfExpr">IfExpr</a>) the <code>then</code> branch is guarded by the condition being true, and the <code>else</code> branch is guarded by the condition being false.</p></li><li class="xquery"><p>In a <code>switch</code> expression (<a href="#doc-xquery40-SwitchExpr">SwitchExpr</a>), the <code>return</code> expression of a particular <code>case</code> is guarded by the condition for that case matching, and no earlier case matching.</p></li><li class="xquery"><p>In a <code>typeswitch</code> expression (<a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a>), the <code>return</code> expression of a particular <code>case</code> is guarded by the condition for that case matching, and no earlier case matching.</p></li><li><p>In an <a title="and expression" class="termref" href="#dt-and-expression">and expression</a>, the second operand is guarded by the value of the first operand being true.</p></li><li><p>In an <a title="or expression" class="termref" href="#dt-or-expression">or expression</a>, the second operand is guarded by the value of the first operand being false.</p></li><li><p><span style="display: none;" class="delete_version">In an <code>otherwise</code> expression (<a href="#doc-xquery40-OtherwiseExpr">OtherwiseExpr</a>), the second operand is guarded by the value of the first operand being an empty sequence.</span><span style="display: none;" class="add_version">In an <code>otherwise</code> expression (<a href="#doc-xquery40-OtherwiseExpr">OtherwiseExpr</a>), the second operand is guarded by the value of the first operand being the empty sequence.</span><span class="modify_version">In an <code>otherwise</code> expression (<a href="#doc-xquery40-OtherwiseExpr">OtherwiseExpr</a>), the second operand is guarded by the value of the first operand being <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p>In a path expression of the form <code><var>E<sub>1</sub></var>/<var>E<sub>2</sub></var></code> or <code><var>E<sub>1</sub></var>//<var>E<sub>2</sub></var></code>, and in a mapping expression of the form <code><var>E<sub>1</sub></var>!<var>E<sub>2</sub></var></code>, the right-hand operand <var>E<sub>2</sub></var> is guarded by the existence of at least one item in the result of evaluating <var>E<sub>1</sub></var>.</p><p>This rule applies even if <var>E<sub>2</sub></var> does not reference the context value. For example, no dynamic error can be thrown by the expression <code>(1 to $n)!doc('bad.xml')</code> in the case where <code>$n</code> is zero.</p></li><li><p>In a filter expression of the form <code><var>E</var>[<var>P</var>]</code>, the predicate <var>P</var> is guarded by the existence of at least one item in the result of evaluating <var>E</var>.</p><p>This rule has the consequence that in a filter expression with multiple predicates, such as <code><var>E</var>[<var>P<sub>1</sub></var>][<var>P<sub>2</sub></var>]</code>, evaluation of <var>P<sub>2</sub></var> must not raise a dynamic error unless <var>P<sub>1</sub></var> returns <code>true</code>. This rule does not prevent reordering of predicates (for example, to take advantage of indexes), but it does require that any such reordering must not result in errors that would not otherwise occur.</p></li><li><p class="xquery">In a <code>FLWOR</code> expression (<a href="#doc-xquery40-FLWORExpr">FLWORExpr</a>), an expression that is logically dependent on the tuples in the tuple stream is guarded by the existence of a relevant tuple. This applies even where the expression does not actually reference any of the variable bindings in the tuple stream. For example, in the expression <code>for $x in <var>S</var> return <var>E</var></code>, the expression <var>E</var> is guarded by the existence of an item bound to <code>$x</code>.</p><p>This means that the expression <code>for $x in 1 to $n return doc('bad.xml')</code> must not raise a dynamic error in the case where <code>$n</code> is zero.</p></li><li><p>In a <code>quantified</code> expression (<a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a>) such as <code>some $x in <var>S</var> satisfies <var>P</var></code>, the expression <var>P</var> is guarded by the existence of an item bound to <code>$x</code>.</p></li></ul><p>The fact that an expression is <a title="guarded" class="termref" href="#dt-guarded">guarded</a> does not remove the obligation to report <a title="static error" class="termref" href="#dt-static-error">static errors</a> in the expression; nor does it remove the option to report statically detectable <a title="type error" class="termref" href="#dt-type-error">type errors</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>These rules do not constrain the order of evaluation of subexpressions. For example, given an expression such as <code>//person[@first = "Winston"][@last = "Churchill"]</code>, or equivalently <code>//person[@first = "Winston" and @last = "Churchill"]</code>, an implementation might use an index on the value of <code>@last</code> to select items that satisfy the second condition, and then filter these items on the value of the first condition. Alternatively, it might evaluate both predicates in parallel. Or it might interpose an additional redundant condition: <code>//person[string-length(@first) + string-length(@last) = 16][@first = "Winston"][@last = "Churchill"]</code>. But implementations must ensure that such rewrites do not result in dynamic errors being reported that would not occur if the predicates were evaluated in order as written.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Although the rules for guarded expressions prevent optimizations resulting in spurious errors, they do not prevent optimizations whose effect is to mask errors. For example, the rules guarantee that <code>("A", 3)[. instance of xs:integer][. eq 3]</code> will not raise an error caused by the comparison <code>("A" eq 3)</code>, but they do not guarantee the converse: the expression <code>("A", 3)[. eq 3][. instance of xs:integer]</code> may or may not raise a dynamic error.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The rules in this section do not disallow all expression rewrites that might result in dynamic errors. For example, rewriting <code>($x - $y + $z)</code> as <code>($x + $z - $y)</code> is permitted even though it might result in an arithmetic overflow.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Some implementations allow calls on external functions that have side-effects. The semantics of such function calls are entirely <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation defined</a>. Processors <span class="verb">may</span> choose to reference the rules for <a title="guarded" class="termref" href="#dt-guarded">guarded</a> expressions when defining the behavior of such function calls, but this is outside the scope of the language specification.</p></div></div><div class="_diffs div3"><h4><a id="id-implausible-expressions"></a>2.5.6 <a href="#id-implausible-expressions" style="text-decoration: none">Implausible Expressions</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-choice-item-types">next</a> | <a href="#id-guarded-expressions">previous</a>)</p><ol><li><p><span style="display: none;" class="delete_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return an empty sequence rather than an error. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/602">602</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/603">603</a>&nbsp;25 July 2023]</i></span><span style="display: none;" class="add_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return the empty sequence rather than an error. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/602">602</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/603">603</a>&nbsp;25 July 2023]</i></span><span class="modify_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence rather than an error. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/602">602</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/603">603</a>&nbsp;25 July 2023]</i></span></p></li></ol></div><p> [<a id="dt-implausible" title="implausible">Definition</a>: Certain expressions, while not erroneous, are classified as being <b>implausible</b>, because they achieve no useful effect.] </p><p><span style="display: none;" class="delete_version">An example of an implausible expression is <code>@code/text()</code>. This expression will always evaluate to an empty sequence, because attribute nodes cannot have text node children. The semantics of the expression are well defined, but it is likely that the user writing this expression intended something different: if they wanted to write an expression that evaluated to an empty sequence, there would be easier ways to write it.</span><span style="display: none;" class="add_version">An example of an implausible expression is <code>@code/text()</code>. This expression will always evaluate to the empty sequence, because attribute nodes cannot have text node children. The semantics of the expression are well defined, but it is likely that the user writing this expression intended something different: if they wanted to write an expression that evaluated to the empty sequence, there would be easier ways to write it.</span><span class="modify_version">An example of an implausible expression is <code>@code/text()</code>. This expression will always evaluate to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, because attribute nodes cannot have text node children. The semantics of the expression are well defined, but it is likely that the user writing this expression intended something different: if they wanted to write an expression that evaluated to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, there would be easier ways to write it.</span></p><p>Where an expression is classified (by rules in this specification) as being <a title="implausible" class="termref" href="#dt-implausible">implausible</a>, a processor <span class="verb">may</span> (but is not <span class="verb">required</span> to) raise a static error.</p><p>For reasons of backwards compatibility and interoperability, and to facilitate automatic generation of XQuery 4.0 code, a processor <span class="verb">must</span> provide a mode of operation in which <a title="implausible" class="termref" href="#dt-implausible">implausible</a> expressions are not treated as static errors, but are evaluated with the defined semantics for the expression.</p><p>Some other examples of implausible expressions include:</p><ul><li><p><span style="display: none;" class="delete_version"><code>round(tokenize($input))</code>. The result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-tokenize"><code>fn:tokenize</code></a> is a sequence of strings (<code>xs:string*</code>), while the required type for the first argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-round"><code>fn:round</code></a> is optional numeric (<code>xs:numeric?</code>). The expression can succeed only in the exceptional case where the result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-tokenize"><code>fn:tokenize</code></a> is an empty sequence, in which case the result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-round"><code>fn:round</code></a> will also be an empty sequence; it is therefore highly likely that the expression was written in error.</span><span style="display: none;" class="add_version"><code>round(tokenize($input))</code>. The result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-tokenize"><code>fn:tokenize</code></a> is a sequence of strings (<code>xs:string*</code>), while the required type for the first argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-round"><code>fn:round</code></a> is optional numeric (<code>xs:numeric?</code>). The expression can succeed only in the exceptional case where the result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-tokenize"><code>fn:tokenize</code></a> is the empty sequence, in which case the result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-round"><code>fn:round</code></a> will also be the empty sequence; it is therefore highly likely that the expression was written in error.</span><span class="modify_version"><code>round(tokenize($input))</code>. The result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-tokenize"><code>fn:tokenize</code></a> is a sequence of strings (<code>xs:string*</code>), while the required type for the first argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-round"><code>fn:round</code></a> is optional numeric (<code>xs:numeric?</code>). The expression can succeed only in the exceptional case where the result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-tokenize"><code>fn:tokenize</code></a> is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, in which case the result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-round"><code>fn:round</code></a> will also be <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence; it is therefore highly likely that the expression was written in error.</span></p></li><li><p><span style="display: none;" class="delete_version"><code>parse-csv($input)?column-names</code>. The signature of the <code>parse-csv</code> function declares its return type as <code>record(columns, rows)</code>. There is no field in this record named <code>column-names</code>, and therefore the lookup expression will always return an empty sequence. Again, there is no good reason that a user would write this, so it is likely that it was written in error.</span><span style="display: none;" class="add_version"><code>parse-csv($input)?column-names</code>. The signature of the <code>parse-csv</code> function declares its return type as <code>record(columns, rows)</code>. There is no field in this record named <code>column-names</code>, and therefore the lookup expression will always return the empty sequence. Again, there is no good reason that a user would write this, so it is likely that it was written in error.</span><span class="modify_version"><code>parse-csv($input)?column-names</code>. The signature of the <code>parse-csv</code> function declares its return type as <code>record(columns, rows)</code>. There is no field in this record named <code>column-names</code>, and therefore the lookup expression will always return <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. Again, there is no good reason that a user would write this, so it is likely that it was written in error.</span></p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The specification is deliberately conservative in the choice of constructs that have been classified as implausible. Constructs have not been classified as implausible merely because there are better ways of writing the same thing, but only in cases where it is considered that no user in full understanding of the specification would intentionally write such a construct. All these cases correspond to situations that would be classed as errors in a language with stricter static typing rules.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In many cases the classification of constructs as implausible is designed to protect users from usability problems that have been found with earlier versions of the language. without introducing backwards incompatibilities.</p></div></div></div><div class="_diffs div2"><h3><a id="id-important-concepts"></a>2.6 <a href="#id-important-concepts" style="text-decoration: none">Concepts</a></h3><p>This section explains some concepts that are important to the processing of XQuery 4.0 expressions.</p><div class="_diffs div3"><h4><a id="id-document-order"></a>2.6.1 <a href="#id-document-order" style="text-decoration: none">Document Order</a></h4><p>An ordering called <b>document order</b> is defined among all the nodes accessible during processing of a given <span class="xquery">query</span> , which may consist of one or more <b>trees</b> (documents or fragments).</p><p><span style="display: none;" class="delete_version">Document order applies both to <a title="XNode" class="termref" href="#dt-XNode">XNodes</a> (typically corresponding to nodes in an XML document, and generally referred to simply as <b>nodes</b>), and also to <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-JNode">JNodes</a><sup><small>DM</small></sup>, often corresponding to the contents of a JSON source text. These are known collectively as <a title="GNode" class="termref" href="#dt-GNode">GNodes</a> (for "generalized node").</span><span style="display: none;" class="add_version">Document order applies both to <a title="XNode" class="termref" href="#dt-XNode">XNodes</a> (typically corresponding to nodes in an XML document, and generally referred to simply as <b>nodes</b>), and also to <a href="#dt-JNode" title="JNode" class="termref">JNodes</a>, often corresponding to the contents of a JSON source text. These are known collectively as <a title="GNode" class="termref" href="#dt-GNode">GNodes</a> (for "generalized node").</span><span class="modify_version">Document order applies both to <a title="XNode" class="termref" href="#dt-XNode">XNodes</a> (typically corresponding to nodes in an XML document, and generally referred to simply as <b>nodes</b>), and also to <a href="#dt-JNode" title="JNode" class="termref">JNodes</a><span class="deltaxml-old" style="background:#FF5555">DM</span>, often corresponding to the contents of a JSON source text. These are known collectively as <a title="GNode" class="termref" href="#dt-GNode">GNodes</a> (for "generalized node").</span></p><p>Document order is defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#document-order">6.2 Document Order</a>, and its definition is repeated here for convenience. Document order is a total ordering, although the relative order of some nodes is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. [<a id="dt-document-order" title="document order">Definition</a>: Informally, <b>document order</b> is the order in which nodes appear in the XML serialization of a document.] [<a id="stable" title="stable">Definition</a>: Document order is <b>stable</b>, which means that the relative order of two nodes will not change during the processing of a given <span class="xquery">query</span> , even if this order is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.] [<a id="dt-reverse-document-order" title="reverse document order">Definition</a>: The node ordering that is the reverse of document order is called <b>reverse document order</b>.] </p><p>Within an <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-XTree">XTree</a><sup><small>DM</small></sup>, (that is, a tree consisting of XNodes), document order satisfies the following constraints:</p><ol class="enumar"><li><p>The root node precedes all other nodes.</p></li><li><p>A parent node precedes its children (and therefore its descendants).</p></li><li><p>The children of a node <var>N</var> precede the following siblings of <var>N</var>.</p></li><li><p>Attribute nodes immediately follow the namespace nodes of the element node with which they are associated. The relative order of attribute nodes is stable but <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p></li><li><p>The relative order of siblings is the order in which they occur in the <code>children</code> property of their parent node.</p></li></ol><p>Similarly, within an <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-JTree">JTree</a><sup><small>DM</small></sup>, (that is, a tree consisting of JNodes), document order satisfies the following constraints:</p><ol class="enumar"><li><p>The root JNode precedes all other JNodes.</p></li><li><p>A parent JNode precedes its children (and therefore its descendants).</p></li><li><p>The children of a JNode <var>N</var> precede the following siblings of <var>N</var>.</p></li><li><p>The children of a JNode that wraps an array follow the ordering of the members of the array.</p></li><li><p>The children of a JNode that wraps a map follow the ordering of the entries in the map.</p></li></ol><p>The relative order of nodes in distinct trees is stable but <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>, subject to the following constraint: If any node in a given tree T1 is before any node in a different tree T2, then all nodes in tree T1 are before all nodes in tree T2.</p></div><div class="_diffs div3"><h4><a id="id-ebv"></a>2.6.4 <a href="#id-ebv" style="text-decoration: none">Effective Boolean Value</a></h4><p>Under certain circumstances (some of which are listed below), it is necessary to find the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of a value. [<a id="dt-ebv" title="effective boolean value">Definition</a>: The <b>effective boolean value</b> of a value is defined as the result of applying the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> function to the value.] </p><p>The dynamic semantics of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> are repeated here for convenience:</p><ol class="enumar"><li><p><span style="display: none;" class="delete_version">If its operand is an empty sequence, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> returns <code>false</code>.</span><span style="display: none;" class="add_version">If its operand is the empty sequence, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> returns <code>false</code>.</span><span class="modify_version">If its operand is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> returns <code>false</code>.</span></p></li><li><p>If its operand is a sequence whose first item is a <a title="GNode" class="termref" href="#dt-GNode">GNode</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> returns <code>true</code>.</p></li><li><p>If its operand is a <a title="singleton" class="termref" href="#dt-singleton">singleton</a> value of type <code>xs:boolean</code> or derived from <code>xs:boolean</code>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> returns the value of its operand unchanged.</p></li><li><p>If its operand is a <a title="singleton" class="termref" href="#dt-singleton">singleton</a> value of type <code>xs:string</code>, <code>xs:anyURI</code>, <code>xs:untypedAtomic</code>, or a type derived from one of these, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> returns <code>false</code> if the operand value has zero length; otherwise it returns <code>true</code>.</p></li><li><p>If its operand is a <a title="singleton" class="termref" href="#dt-singleton">singleton</a> value of any <a title="numeric" class="termref" href="#dt-numeric">numeric</a> type or derived from a numeric type, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> returns <code>false</code> if the operand value is <code>NaN</code> or is numerically equal to zero; otherwise it returns <code>true</code>.</p></li><li><p>In all other cases, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> raises a type error [<a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFORG0006" title="err:FORG0006">err:FORG0006</a>]<sup><small>FO40</small></sup>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For instance, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> raises a type error if the operand is a function, a map, or an array.</p></div></li></ol><p>The <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of a sequence is computed implicitly during processing of the following types of expressions: </p><ul><li><p>Logical expressions (<code>and</code>, <code>or</code>)</p></li><li><p>The <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-not"><code>fn:not</code></a> function</p></li><li class="xquery"><p>The <code>where</code> clause of a FLWOR expression</p></li><li><p>Certain types of <a title="" class="termref" href="#dt-predicate">predicates</a>, such as <code>a[b]</code></p></li><li><p>Conditional expressions (<code>if</code>)</p></li><li><p>Quantified expressions (<code>some</code>, <code>every</code>)</p></li><li class="xquery"><p><a href="#prod-xquery40-WindowStartCondition">WindowStartCondition</a> and <a href="#prod-xquery40-WindowEndCondition">WindowEndCondition</a> in <code>window</code> clauses.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The definition of <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> is <em>not</em> used when casting a value to the type <code>xs:boolean</code>, for example in a <code>cast</code> expression. It also plays no role in the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> used when passing a value to a function whose signature declares a parameter of type <code>xs:boolean</code>.</p></div></div></div></div><div class="_diffs div1"><h2><a id="id-types"></a>3 <a href="#id-types" style="text-decoration: none">Types</a></h2><p>As noted in <a href="#id-values"><b>2.1.3 Values</b></a>, every value in XQuery 4.0 is regarded as a <a title="sequence" class="termref" href="#dt-sequence">sequence</a> of zero, one, or more <a title="item" class="termref" href="#dt-item">items</a>. The type system of XQuery 4.0, described in this section, classifies the kinds of value that the language can handle, and the operations permitted on different kinds of value.</p><p>The type system of XQuery 4.0 is related to the type system of <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> in two ways:</p><ul><li><p>atomic items in XQuery 4.0 (which are one kind of <a title="item" class="termref" href="#dt-item">item</a>) have <a title="atomic type" class="termref" href="#dt-atomic-type">atomic types</a> such as <code>xs:string</code>, <code>xs:boolean</code>, and <code>xs:integer</code>. These types are taken directly from their definitions in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.</p></li><li><p><a title="XNode" class="termref" href="#dt-XNode">XNodes</a> (which are another kind of <a title="item" class="termref" href="#dt-item">item</a>) have a property called a <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> which determines the type of their content. The type annotation is a <a title="schema type" class="termref" href="#dt-schema-type">schema type</a>. The type annotation of a node must not be confused with the item type of the node. For example, an element <code>&lt;age&gt;23&lt;/age&gt;</code> might have been validated against a schema that defines this element as having <code>xs:integer</code> content. If this is the case, the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of the node will be <code>xs:integer</code>, and in the XQuery 4.0 type system, the node will match the <a title="item type" class="termref" href="#dt-item-type">item type</a><code>element(age, xs:integer)</code>. </p></li></ul><p>This chapter of the specification starts by defining <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a> and <a title="item type" class="termref" href="#dt-item-type">item types</a>, which describe the range of <a title="value" class="termref" href="#dt-value">values</a> that can be bound to variables, used in expressions, or passed to functions. It then describes how these relate to <a title="schema type" class="termref" href="#dt-schema-type">schema types</a>, that is, the simple and complex types defined in an XSD schema.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In many situations the terms <b>item type</b> and <b>sequence type</b> are used interchangeably to refer either to the type itself, or to the syntactic construct that designates the type: so in the expression <code>$x instance of xs:string*</code>, the construct <code>xs:string*</code> uses the <a href="#doc-xquery40-SequenceType">SequenceType</a> syntax to designate a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> whose instances are sequences of strings. When more precision is required, the specification is careful to use the terms <a title="item type" class="termref" href="#dt-item-type">item type</a> and <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> to refer to the actual types, while using the production names <a href="#doc-xquery40-ItemType">ItemType</a> and <a href="#doc-xquery40-SequenceType">SequenceType</a> to refer to the syntactic designators of these types.</p></div><div class="_diffs div2"><h3><a id="id-sequencetype-syntax"></a>3.1 <a href="#id-sequencetype-syntax" style="text-decoration: none">Sequence Types</a></h3><p> [<a id="dt-sequence-type" title="sequence type">Definition</a>: A <b>sequence type</b> is a type that can be expressed using the <a href="#doc-xquery40-SequenceType">SequenceType</a> syntax. Sequence types are used whenever it is necessary to refer to a type in an XQuery 4.0 expression. Since all values are sequences, every value matches one or more <b>sequence types</b>.] </p><p>Whenever it is necessary to refer to a <b>sequence type</b> in an XQuery 4.0 expression, the <a href="#doc-xquery40-SequenceType">SequenceType</a> syntax is used.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SequenceType"></a><code><a href="#prod-xquery40-SequenceType">SequenceType</a></code></td><td>::=</td><td><code>("empty-sequence" "(" ")")<br>| (<a href="#doc-xquery40-SequenceType-ItemType">ItemType</a><a href="#doc-xquery40-SequenceType-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SequenceType-ItemType"></a><code><a href="#prod-xquery40-ItemType">ItemType</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-RegularItemType">RegularItemType</a> | <a href="#doc-xquery40-FunctionType">FunctionType</a> | <a href="#prod-xquery40-TypeName">TypeName</a> | <a href="#prod-xquery40-ChoiceItemType">ChoiceItemType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SequenceType-OccurrenceIndicator"></a><code><a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a></code></td><td>::=</td><td><code>"?" | "*" | "+"</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-occurrence-indicators">xgc: occurrence-indicators</a> */</td></tr></tbody></table><p> [<a id="dt-sequence-type-designator" title="sequence type designator">Definition</a>: A <b>sequence type designator</b> is a syntactic construct conforming to the grammar rule <a href="#doc-xquery40-SequenceType">SequenceType</a>. A sequence type designator is said to <b>designate</b> a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>.] </p><p>With the exception of the special type <code>empty-sequence()</code>, a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> consists of an <a title="item type" class="termref" href="#dt-item-type">item type</a> that constrains the type of each item in the sequence, and a <b>cardinality</b> that constrains the number of items in the sequence. Apart from the item type <code>item()</code>, which permits any kind of item, item types divide into <b>node types</b> (such as <code>element()</code>), <b>generalized atomic types</b> (such as <code>xs:integer</code>) and function types (such as <code>function() as item()*</code>).</p><p>The cardinality of a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> is represented in the <a title="sequence type designator" class="termref" href="#dt-sequence-type-designator">sequence type designator</a> syntax by an <a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a>. The occurrence indicators <code>+</code>, <code>*</code>, and <code>?</code> bind to the last <a href="#doc-xquery40-ItemType">ItemType</a> in the <a href="#doc-xquery40-SequenceType">SequenceType</a>, as described in the <a href="#parse-note-occurrence-indicators">occurrence-indicators</a> constraint.</p><div class="_diffs div3"><h4><a id="id-sequencetype-matching"></a>3.1.2 <a href="#id-sequencetype-matching" style="text-decoration: none">Sequence Type Matching</a></h4><p> [<a id="dt-sequencetype-matching" title="SequenceType matching">Definition</a>: <b>SequenceType matching</b> compares a value with an expected <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>. ] For example, an <code>instance of</code> expression returns <code>true</code> if a given value matches a given <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>, and <code>false</code> if it does not.</p><p>An XQuery 4.0 implementation must be able to determine relationships among the types in type annotations in an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> and the types in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> (ISSD). <span class="xquery">An XQuery 4.0 implementation must be able to determine relationships among the types in ISSDs used in different modules of the same query.</span></p><p> [<a id="dt-subtype-substitution" title="subtype substitution">Definition</a>: The use of a value that has a <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> that is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of the expected type is known as <b>subtype substitution</b>.] Subtype substitution does not change the actual type of a value. For example, if an <code>xs:integer</code> value is used where an <code>xs:decimal</code> value is expected, the value retains its type as <code>xs:integer</code>.</p><p>The rules for <a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching">SequenceType matching</a> are given below, with examples (the examples are for purposes of illustration, and do not cover all possible cases).</p><ul><li><p>The <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a><code>empty-sequence()</code> matches a value that is the empty sequence.</p></li><li><p>An <a href="#doc-xquery40-ItemType">ItemType</a> with no <a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a> matches any value that contains exactly one item if the <a href="#doc-xquery40-ItemType">ItemType</a> matches that item (see <a href="#id-matching-item"><b>3.2 Item Types</b></a>).</p></li><li><p>An <a href="#doc-xquery40-ItemType">ItemType</a> with an <a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a> matches a value if the number of items in the value matches the <a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a> and the <a href="#doc-xquery40-ItemType">ItemType</a> matches each of the items in the value.</p></li></ul><p>An <a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a> specifies the number of items in a sequence, as follows:</p><ul><li><p><code>?</code> matches zero or one items</p></li><li><p><code>*</code> matches zero or more items</p></li><li><p><code>+</code> matches one or more items</p></li></ul><p><span style="display: none;" class="delete_version">As a consequence of these rules, any <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> whose <a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a> is <code>*</code> or <code>?</code> matches a value that is an empty sequence.</span><span style="display: none;" class="add_version">As a consequence of these rules, any <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> whose <a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a> is <code>*</code> or <code>?</code> matches a value that is the empty sequence.</span><span class="modify_version">As a consequence of these rules, any <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> whose <a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a> is <code>*</code> or <code>?</code> matches a value that is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></div></div><div class="_diffs div2"><h3><a id="id-matching-item"></a>3.2 <a href="#id-matching-item" style="text-decoration: none">Item Types</a></h3><p> [<a id="dt-item-type" title="item type">Definition</a>: An <b>item type</b> is a type that can be expressed using the <a href="#doc-xquery40-ItemType">ItemType</a> syntax, which forms part of the <a href="#doc-xquery40-SequenceType">SequenceType</a> syntax. Item types match individual <a title="item" class="termref" href="#dt-item">items</a>.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>While this definition is adequate for the purpose of defining the syntax of XQuery 4.0, it ignores the fact that there are also item types that cannot be expressed using XQuery 4.0 syntax: specifically, item types that reference an anonymous simple type or complex type defined in a schema. Such types can appear as type annotations on nodes following schema validation.</p></div><p>In most cases, the set of items matched by an item type consists either exclusively of <a title="atomic item" class="termref" href="#dt-atomic-item">atomic items</a>, exclusively of <a title="node" class="termref" href="#dt-node">nodes</a>, or exclusively of <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-function-item">function items</a><sup><small>DM</small></sup>. Exceptions include the generic types <code>item()</code>, which matches all items, <code>xs:error</code>, which matches no items, and <a title="choice item type" class="termref" href="#dt-choice-item-type">choice item types</a>, which can match any combination of types. </p><p> [<a id="dt-item-type-designator" title="item type designator">Definition</a>: An <b>item type designator</b> is a syntactic construct conforming to the grammar rule <a href="#doc-xquery40-ItemType">ItemType</a>. An item type designator is said to <b>designate</b> an <a title="item type" class="termref" href="#dt-item-type">item type</a>.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Two <a title="item type designator" class="termref" href="#dt-item-type-designator">item type designators</a> may designate the same item type. For example, <code>element()</code> and <code>element(*)</code> are equivalent, as are <code>attribute(A)</code> and <code>attribute(A, xs:anySimpleType)</code>.</p></div><p><a title="lexical QName" class="termref" href="#dt-qname">Lexical QNames</a> appearing in an <a title="item type designator" class="termref" href="#dt-item-type-designator">item type designator</a><span class="xquery">(other than within a <a title="function assertion" class="termref" href="#dt-function-assertion">function assertion</a>)</span> are expanded using the <a title="default type namespace rule" class="termref" href="#dt-default-type-namespace-rule">default type namespace rule</a>. Equality of QNames is defined by the <code>eq</code> operator.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType"></a><code><a href="#prod-xquery40-ItemType">ItemType</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-ItemType-RegularItemType">RegularItemType</a> | <a href="#doc-xquery40-ItemType-FunctionType">FunctionType</a> | <a href="#doc-xquery40-ItemType-TypeName">TypeName</a> | <a href="#doc-xquery40-ItemType-ChoiceItemType">ChoiceItemType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-RegularItemType"></a><code><a href="#prod-xquery40-RegularItemType">RegularItemType</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-ItemType-AnyItemTest">AnyItemTest</a> | <a href="#doc-xquery40-ItemType-NodeKindTest">NodeKindTest</a> | <a href="#doc-xquery40-ItemType-GNodeType">GNodeType</a> | <a href="#doc-xquery40-ItemType-JNodeType">JNodeType</a> | <a href="#doc-xquery40-ItemType-MapType">MapType</a> | <a href="#doc-xquery40-ItemType-ArrayType">ArrayType</a> | <a href="#doc-xquery40-ItemType-RecordType">RecordType</a> | <a href="#doc-xquery40-ItemType-EnumerationType">EnumerationType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-AnyItemTest"></a><code><a href="#prod-xquery40-AnyItemTest">AnyItemTest</a></code></td><td>::=</td><td><code>"item" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-NodeKindTest"></a><code><a href="#prod-xquery40-NodeKindTest">NodeKindTest</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-ItemType-DocumentTest">DocumentTest</a><br>| <a href="#doc-xquery40-ItemType-ElementTest">ElementTest</a><br>| <a href="#doc-xquery40-ItemType-AttributeTest">AttributeTest</a><br>| <a href="#doc-xquery40-ItemType-SchemaElementTest">SchemaElementTest</a><br>| <a href="#doc-xquery40-ItemType-SchemaAttributeTest">SchemaAttributeTest</a><br>| <a href="#doc-xquery40-ItemType-PITest">PITest</a><br>| <a href="#doc-xquery40-ItemType-CommentTest">CommentTest</a><br>| <a href="#doc-xquery40-ItemType-TextTest">TextTest</a><br>| <a href="#doc-xquery40-ItemType-NamespaceNodeTest">NamespaceNodeTest</a><br>| <a href="#doc-xquery40-ItemType-AnyNodeKindTest">AnyNodeKindTest</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-DocumentTest"></a><code><a href="#prod-xquery40-DocumentTest">DocumentTest</a></code></td><td>::=</td><td><code>"document-node" "(" (<a href="#doc-xquery40-ItemType-ElementTest">ElementTest</a> | <a href="#doc-xquery40-ItemType-SchemaElementTest">SchemaElementTest</a> | <a href="#doc-xquery40-ItemType-NameTestUnion">NameTestUnion</a>)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-ElementTest"></a><code><a href="#prod-xquery40-ElementTest">ElementTest</a></code></td><td>::=</td><td><code>"element" "(" (<a href="#doc-xquery40-ItemType-NameTestUnion">NameTestUnion</a> ("," <a href="#doc-xquery40-ItemType-TypeName">TypeName</a> "?"?)?)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-SchemaElementTest"></a><code><a href="#prod-xquery40-SchemaElementTest">SchemaElementTest</a></code></td><td>::=</td><td><code>"schema-element" "(" <a href="#prod-xquery40-ElementName">ElementName</a> ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-NameTestUnion"></a><code><a href="#prod-xquery40-NameTestUnion">NameTestUnion</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-ItemType-NameTest">NameTest</a> ++ "|")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-NameTest"></a><code><a href="#prod-xquery40-NameTest">NameTest</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-ItemType-EQName">EQName</a> | <a href="#prod-xquery40-Wildcard">Wildcard</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-AttributeTest"></a><code><a href="#prod-xquery40-AttributeTest">AttributeTest</a></code></td><td>::=</td><td><code>"attribute" "(" (<a href="#doc-xquery40-ItemType-NameTestUnion">NameTestUnion</a> ("," <a href="#doc-xquery40-ItemType-TypeName">TypeName</a>)?)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-SchemaAttributeTest"></a><code><a href="#prod-xquery40-SchemaAttributeTest">SchemaAttributeTest</a></code></td><td>::=</td><td><code>"schema-attribute" "(" <a href="#prod-xquery40-AttributeName">AttributeName</a> ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-PITest"></a><code><a href="#prod-xquery40-PITest">PITest</a></code></td><td>::=</td><td><code>"processing-instruction" "(" (<a href="#prod-xquery40-NCName">NCName</a> | <a href="#doc-xquery40-ItemType-StringLiteral">StringLiteral</a>)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-StringLiteral"></a><code><a href="#prod-xquery40-StringLiteral">StringLiteral</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-AposStringLiteral">AposStringLiteral</a> | <a href="#prod-xquery40-QuotStringLiteral">QuotStringLiteral</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-CommentTest"></a><code><a href="#prod-xquery40-CommentTest">CommentTest</a></code></td><td>::=</td><td><code>"comment" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-TextTest"></a><code><a href="#prod-xquery40-TextTest">TextTest</a></code></td><td>::=</td><td><code>"text" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-NamespaceNodeTest"></a><code><a href="#prod-xquery40-NamespaceNodeTest">NamespaceNodeTest</a></code></td><td>::=</td><td><code>"namespace-node" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-AnyNodeKindTest"></a><code><a href="#prod-xquery40-AnyNodeKindTest">AnyNodeKindTest</a></code></td><td>::=</td><td><code>"node" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-GNodeType"></a><code><a href="#prod-xquery40-GNodeType">GNodeType</a></code></td><td>::=</td><td><code>"gnode" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-JNodeType"></a><code><a href="#prod-xquery40-JNodeType">JNodeType</a></code></td><td>::=</td><td><code>"jnode" "(" (("*" | <a href="#prod-xquery40-NCName">NCName</a> | <a href="#doc-xquery40-Constant">Constant</a>) ("," ("*" | <a href="#doc-xquery40-SequenceType">SequenceType</a>))?)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-MapType"></a><code><a href="#prod-xquery40-MapType">MapType</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-AnyMapType">AnyMapType</a> | <a href="#prod-xquery40-TypedMapType">TypedMapType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-ArrayType"></a><code><a href="#prod-xquery40-ArrayType">ArrayType</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-AnyArrayType">AnyArrayType</a> | <a href="#prod-xquery40-TypedArrayType">TypedArrayType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-RecordType"></a><code><a href="#prod-xquery40-RecordType">RecordType</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-AnyRecordType">AnyRecordType</a> | <a href="#prod-xquery40-TypedRecordType">TypedRecordType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-EnumerationType"></a><code><a href="#prod-xquery40-EnumerationType">EnumerationType</a></code></td><td>::=</td><td><code>"enum" "(" (<a href="#doc-xquery40-ItemType-StringLiteral">StringLiteral</a> ++ ",") ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-FunctionType"></a><code><a href="#prod-xquery40-FunctionType">FunctionType</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-Annotation">Annotation</a>* (<a href="#prod-xquery40-AnyFunctionType">AnyFunctionType</a><br>| <a href="#prod-xquery40-TypedFunctionType">TypedFunctionType</a>)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-TypeName"></a><code><a href="#prod-xquery40-TypeName">TypeName</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-ItemType-EQName">EQName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-EQName"></a><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-QName">QName</a> | <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-ChoiceItemType"></a><code><a href="#prod-xquery40-ChoiceItemType">ChoiceItemType</a></code></td><td>::=</td><td><code>"(" (<a href="#doc-xquery40-ItemType">ItemType</a> ++ "|") ")"</code></td></tr></tbody></table><p>This section defines the syntax and semantics of different <code>ItemTypes</code> in terms of the values that they match.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For an explanation of the EBNF grammar notation (and in particular, the operators <code>++</code> and <code>**</code>), see <a href="#id-grammar"><b>A.1 EBNF</b></a>.</p></div><p>An <a title="item type designator" class="termref" href="#dt-item-type-designator">item type designator</a> written simply as an <code>EQName</code> (that is, a <code>TypeName</code>) is interpreted as follows:</p><ol class="enumar"><li><p>If the name is written as a lexical QName, then it is expanded using the <a title="default type namespace rule" class="termref" href="#dt-default-type-namespace-rule">default type namespace rule</a>.</p></li><li><p>If the expanded name matches a <a title="named item type" class="termref" href="#dt-named-item-type">named item type</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, then it is taken as a reference to the corresponding item type. The rules that apply are the rules for the expanded item type definition.</p></li><li><p>Otherwise, it must match the name of a type in the <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>: specifically, an <a title="atomic type" class="termref" href="#dt-atomic-type">atomic type</a> or a <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a>. See <a href="#id-predefined-types"><b>3.5 Schema Types</b></a> for details. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>A name in the <code>xs</code> namespace will always fall into this category, since the namespace is reserved. See <a href="#id-namespaces-and-qnames"><b>2.1.4 Namespaces and QNames</b></a>.</p></div></li><li><p>If the name cannot be resolved to a type, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0051" title="err:XPST0051">err:XPST0051</a>].</p></li></ol><div class="_diffs div3"><h4><a id="id-function-map-array-tests"></a>3.2.8 <a href="#id-function-map-array-tests" style="text-decoration: none">Function, Map, and Array Types</a></h4><p>The following sections describe the syntax for <a title="item type" class="termref" href="#dt-item-type">item types</a> for functions, including arrays and maps.</p><p>The <a title="subtype" class="termref" href="#dt-subtype">subtype</a> relation among these types is described in the various subsections of <a href="#id-itemtype-subtype"><b>3.3.2 Subtypes of Item Types</b></a>.</p><div class="_diffs div4"><h5><a id="id-map-test"></a>3.2.8.2 <a href="#id-map-test" style="text-decoration: none">Map Types</a></h5><p>A <a href="#doc-xquery40-MapType">MapType</a> designates an item type that either matches any map, or that matches maps whose keys and values are constrained to specific types.</p><a id="d2e9920"></a><a id="d2e9960"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-MapType"></a><code><a href="#prod-xquery40-MapType">MapType</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-MapType-AnyMapType">AnyMapType</a> | <a href="#doc-xquery40-MapType-TypedMapType">TypedMapType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-MapType-AnyMapType"></a><code><a href="#prod-xquery40-AnyMapType">AnyMapType</a></code></td><td>::=</td><td><code>"map" "(" "*" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-MapType-TypedMapType"></a><code><a href="#prod-xquery40-TypedMapType">TypedMapType</a></code></td><td>::=</td><td><code>"map" "(" <a href="#doc-xquery40-MapType-ItemType">ItemType</a> "," <a href="#doc-xquery40-MapType-SequenceType">SequenceType</a> ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-MapType-ItemType"></a><code><a href="#prod-xquery40-ItemType">ItemType</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-RegularItemType">RegularItemType</a> | <a href="#doc-xquery40-FunctionType">FunctionType</a> | <a href="#prod-xquery40-TypeName">TypeName</a> | <a href="#prod-xquery40-ChoiceItemType">ChoiceItemType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-MapType-SequenceType"></a><code><a href="#prod-xquery40-SequenceType">SequenceType</a></code></td><td>::=</td><td><code>("empty-sequence" "(" ")")<br>| (<a href="#doc-xquery40-MapType-ItemType">ItemType</a><a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody></table><p>An <a href="#prod-xquery40-AnyMapType">AnyMapType</a><code>map(*)</code> matches any map.</p><p>The <a href="#doc-xquery40-MapType">MapType</a><code>map(K, V)</code> matches any map where every key is an instance of <code>K</code> and every value is an instance of <code>V</code>.</p><p>The <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-entry-order">entry-order</a><sup><small>DM</small></sup> of a map has no effect on whether the map matches a particular map type.</p><p>Although the grammar for <code>TypedMapType</code> allows the key to be described using the full <code>ItemType</code> syntax, the item type used must be a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a> [<a href="#ERRXPST0152" title="err:XPST0152">err:XPST0152</a>].</p><p>For example, given a map <code>$M</code> whose keys are integers and whose results are strings, such as <code>{ 0: "no", 1: "yes" }</code>, the following following expressions deliver the result shown: </p><ul><li><p><code>$M instance of map(*)</code> returns <code>true</code></p></li><li><p><code>$M instance of map(xs:integer, xs:string)</code> returns <code>true</code></p></li><li><p><code>$M instance of map(xs:decimal, xs:anyAtomicType)</code> returns <code>true</code></p></li><li><p><code>$M instance of map(xs:int, xs:string)</code> returns <code>false</code></p></li><li><p><code>$M instance of map(xs:integer, xs:token))</code> returns <code>false</code></p></li></ul><p>A map is also a function item, and therefore matches certain function types. Specifically, a map that matches <code>map(K, V)</code> also matches a function type of the form <code>function(xs:anyAtomicType) as R</code> provided that both the following conditions are satisfied:</p><ul><li><p><var>V</var> is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of <var>R</var></p></li><li><p><code>empty-sequence()</code> is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of <var>R</var></p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">To understand this rule, consider the use of a map <code>$M</code> in a function call <code>$M($K)</code>, which is equivalent to the function call <code>map:get($M, $K)</code>. This function accepts any atomic item for the argument <code>$K</code>, and hence matches a function type that requires an argument type of <code>xs:anyAtomicType</code>. If the key <code>$K</code> is present in the map, the result of the function will be a value of type <var>V</var>; if not, it will be an empty sequence. The map is therefore substitutable for the function type provided that the function type allows both a value of type <var>V</var> and the empty sequence as possible results.</span><span style="display: none;" class="add_version">To understand this rule, consider the use of a map <code>$M</code> in a function call <code>$M($K)</code>, which is equivalent to the function call <code>map:get($M, $K)</code>. This function accepts any atomic item for the argument <code>$K</code>, and hence matches a function type that requires an argument type of <code>xs:anyAtomicType</code>. If the key <code>$K</code> is present in the map, the result of the function will be a value of type <var>V</var>; if not, it will be the empty sequence. The map is therefore substitutable for the function type provided that the function type allows both a value of type <var>V</var> and the empty sequence as possible results.</span><span class="modify_version">To understand this rule, consider the use of a map <code>$M</code> in a function call <code>$M($K)</code>, which is equivalent to the function call <code>map:get($M, $K)</code>. This function accepts any atomic item for the argument <code>$K</code>, and hence matches a function type that requires an argument type of <code>xs:anyAtomicType</code>. If the key <code>$K</code> is present in the map, the result of the function will be a value of type <var>V</var>; if not, it will be <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. The map is therefore substitutable for the function type provided that the function type allows both a value of type <var>V</var> and the empty sequence as possible results.</span></p><p>The key type <var>K</var> does not enter into this rule. That is because in the function call <code>$M($K)</code>, the sought key <code>$K</code> does not have to be of the same type as the keys actually present in the map.</p><p>The transitivity rules for item type matching mean that if an item <var>M</var> matches a type <var>T</var>, and <var>T</var> is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of <var>U</var>, then <var>M</var> also matches type <var>U</var>. So the fact that a map from integers to strings (<code>map(xs:integer, xs:string)</code>) matches <code>function(xs:anyAtomicType) as xs:string?</code> means that it will also match other function types such as <code>function(xs:integer) as xs:string?</code> and <code>function(xs:decimal) as xs:anyAtomicType?</code></p><p><span style="display: none;" class="delete_version">Furthermore, the rules for <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> mean that any map can be supplied as a value in a context where it does not actually match the required function type, but can be coerced to a function that does. For example a map of type <code>map(xs:integer, xs:string)</code> can be coerced to a function of type <code>function(xs:integer) as xs:string</code>; in this situation a type error will occur only if a call on the function actually returns an empty sequence. </span><span style="display: none;" class="add_version">Furthermore, the rules for <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> mean that any map can be supplied as a value in a context where it does not actually match the required function type, but can be coerced to a function that does. For example a map of type <code>map(xs:integer, xs:string)</code> can be coerced to a function of type <code>function(xs:integer) as xs:string</code>; in this situation a type error will occur only if a call on the function actually returns the empty sequence. </span><span class="modify_version">Furthermore, the rules for <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> mean that any map can be supplied as a value in a context where it does not actually match the required function type, but can be coerced to a function that does. For example a map of type <code>map(xs:integer, xs:string)</code> can be coerced to a function of type <code>function(xs:integer) as xs:string</code>; in this situation a type error will occur only if a call on the function actually returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. </span></p></div><p>Examples:</p><ul><li><p><code>$M instance of fn(*)</code> returns <code>true</code></p></li><li><p><code>$M instance of fn(xs:anyAtomicType) as item()*</code> returns <code>true</code></p></li><li><p><code>$M instance of fn(xs:integer) as item()*</code> returns <code>true</code></p></li><li><p><code>$M instance of fn(xs:int) as item()*</code> returns <code>true</code></p></li><li><p><code>$M instance of fn(xs:string) as item()*</code> returns <code>true</code></p></li><li><p><code>not($M instance of fn(xs:integer) as xs:string)</code> returns <code>true</code></p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The last case might seem surprising; however, <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> ensures that <code>$M</code> can be used successfully anywhere that the required type is <code>fn(xs:integer) as xs:string</code>.</p></div><p>Rules defining whether one map type is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of another are given in <a href="#id-item-subtype-maps"><b>3.3.2.7 Subtyping Maps</b></a>.</p></div><div class="_diffs div4"><h5><a id="id-record-test"></a>3.2.8.3 <a href="#id-record-test" style="text-decoration: none">Record Types</a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-jnode-types">next</a> | <a href="#id-function-test">previous</a>)</p><ol><li><p> Record types are added as a new kind of <code>ItemType</code>, constraining the value space of maps. </p></li><li><p> The syntax <code>record(*)</code> is allowed; it matches any map. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/52">52</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/728">728</a>&nbsp;10 October 2023]</i></p></li><li><p><span style="display: none;" class="delete_version"> The syntax <code>record()</code> is allowed; the only thing it matches is an empty map. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1491">1491</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1577">1577</a>&nbsp;17 October 2024]</i></span><span style="display: none;" class="add_version"> The syntax <code>record()</code> is allowed; the only thing it matches is the empty map. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1491">1491</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1577">1577</a>&nbsp;17 October 2024]</i></span><span class="modify_version"> The syntax <code>record()</code> is allowed; the only thing it matches is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty map. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1491">1491</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1577">1577</a>&nbsp;17 October 2024]</i></span></p></li></ol></div><p>A <a href="#doc-xquery40-RecordType">RecordType</a> matches maps that meet specific criteria.</p><p>For example, the <code>RecordType</code><code>record(r as xs:double, i as xs:double)</code> matches a map if the map has exactly two entries: an entry with key <code>"r"</code> whose value is a <a title="singleton" class="termref" href="#dt-singleton">singleton</a><code>xs:double</code> value, and an entry with key <code>"i"</code> whose value is also a <a title="singleton" class="termref" href="#dt-singleton">singleton</a><code>xs:double</code> value.</p><p>Record types describe a subset of the value space of maps. They do not define any new kinds of values, or any additional operations. They are useful in many cases to describe more accurately the type of a variable, function parameter, or function result, giving benefits both in the readability of the code, and in the ability of the processor to detect and diagnose type errors and to optimize execution.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordType"></a><code><a href="#prod-xquery40-RecordType">RecordType</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-RecordType-AnyRecordType">AnyRecordType</a> | <a href="#doc-xquery40-RecordType-TypedRecordType">TypedRecordType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordType-AnyRecordType"></a><code><a href="#prod-xquery40-AnyRecordType">AnyRecordType</a></code></td><td>::=</td><td><code>"record" "(" "*" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordType-TypedRecordType"></a><code><a href="#prod-xquery40-TypedRecordType">TypedRecordType</a></code></td><td>::=</td><td><code>"record" "(" (<a href="#doc-xquery40-RecordType-FieldDeclaration">FieldDeclaration</a> ** ",") <a href="#doc-xquery40-RecordType-ExtensibleFlag">ExtensibleFlag</a>? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordType-FieldDeclaration"></a><code><a href="#prod-xquery40-FieldDeclaration">FieldDeclaration</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-RecordType-FieldName">FieldName</a> "?"? ("as" <a href="#doc-xquery40-RecordType-SequenceType">SequenceType</a>)?</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordType-FieldName"></a><code><a href="#prod-xquery40-FieldName">FieldName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-NCName">NCName</a> | <a href="#doc-xquery40-RecordType-StringLiteral">StringLiteral</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordType-StringLiteral"></a><code><a href="#prod-xquery40-StringLiteral">StringLiteral</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-AposStringLiteral">AposStringLiteral</a> | <a href="#prod-xquery40-QuotStringLiteral">QuotStringLiteral</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordType-SequenceType"></a><code><a href="#prod-xquery40-SequenceType">SequenceType</a></code></td><td>::=</td><td><code>("empty-sequence" "(" ")")<br>| (<a href="#doc-xquery40-ItemType">ItemType</a><a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordType-ExtensibleFlag"></a><code><a href="#prod-xquery40-ExtensibleFlag">ExtensibleFlag</a></code></td><td>::=</td><td><code>"," "*"</code></td></tr></tbody></table><p>If the list of fields ends with <code>",*"</code> then the record type is said to be <b>extensible</b>. For example, the <code>RecordType</code><code>record(e as element(Employee), *)</code> matches a map if it has an entry with key <code>"e"</code> whose value matches <code>element(Employee)</code>, regardless what other entries the map might contain.</p><p>For generality:</p><ul><li><p>The syntax <code>record()</code> defines a record type that has no explicit fields and that is not extensible. The only thing it matches is an <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-map">empty map</a><sup><small>DM</small></sup>.</p></li><li><p>The syntax <code>record(*)</code> defines an extensible record type that has no explicit field declarations. It is equivalent to the item type <code>map(*)</code>: that is, it matches any map.</p></li></ul><p>A record type can constrain only those entries whose keys are strings, but when the record type is marked as extensible, then other entries may be present in the map with either string or non-string keys. Entries whose key is a string can be expressed using an (unquoted) NCName if the key conforms to NCName syntax, or using a (quoted) string literal otherwise.</p><p>Although constructors for named record types produce a map in which the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-entry-order">entry order</a><sup><small>DM</small></sup> reflects the order of field definitions in the record type definition, the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-entry-order">entry order</a><sup><small>DM</small></sup> of a map has no effect on whether the map matches a particular record type: the entries in a map do not have to be in any particular order.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Lookup expressions have been extended in 4.0 so that non-NCName keys can be used without parentheses: <code>employee?"middle name"</code></p></div><p>If the type declaration for a field is omitted, then <code>item()*</code> is assumed: that is, the map entry may have any type.</p><p>If the field name is followed by a question mark, then the value must have the specified type if it is present, but it may also be absent. For example, the <code>RecordType</code><code>record(first as xs:string, middle? as xs:string, last as xs:string, *)</code> requires the map to have string-valued entries with keys <code>"first"</code> and <code>"last"</code>; it also declares that if the map has an entry with key <code>"middle"</code>, the value of that entry must be a single <code>xs:string</code>. Declaring the type as <code>record(first as xs:string, middle? as xs:string?, last as xs:string, *)</code> also allows the entry with key <code>"middle"</code> to be present but empty.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Within an extensible record type, a <code>FieldDeclaration</code> that is marked optional and has no declared type does not constrain the map in any way, so it serves no practical purpose, but it is permitted because it may have documentary value.</p></div><p>The names of the fields in a record type must be distinct [<a href="#ERRXPST0021" title="err:XPST0021">err:XPST0021</a>].</p><p>If a variable <code>$rec</code> is known to conform to a particular record type, then when a lookup expression <code>$rec?field</code> is used, (a) the processor can report a type error if <code>$rec</code> cannot contain an entry with name <code>field</code> (see <a href="#id-implausible-lookup-expressions"><b>4.14.3.4 Implausible Lookup Expressions</b></a>), and (b) the processor can make static type inferences about the type of value returned by <code>$rec?field</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>(TODO: change function signatures as suggested here!) A number of functions in the standard function library use maps as function arguments; this is a useful technique where the information to be supplied across the interface is highly variable. However, the type signature for such functions typically declares the argument type as <code>map(*)</code>, which gives very little information (and places very few constraints) on the values that are actually passed across. Using record types offers the possibility of improving this: for example, the options argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-parse-json"><code>fn:parse-json</code></a>, previously given as <code>map(*)</code>, can now be expressed as <code>record(liberal? as xs:boolean, duplicates? as xs:string, escape? as xs:boolean, fallback as fn(xs:string) as xs:string, *)</code>. In principle the <code>xs:string</code> type used to describe the <code>duplicates</code> option could also be replaced by a schema-defined subtype of <code>xs:string</code> that enumerates the permitted values (<code>"reject"</code>, <code>"use-first"</code>, <code>"use-last"</code>). </p><p>The use of a record type in the signature of such a function causes the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to be invoked. So, for example, if the function expects an entry in the map to be an <code>xs:double</code> value, it becomes possible to supply a map in which the corresponding entry has type <code>xs:integer</code>.</p><p>Greater precision in defining the types of such arguments also enables better type checking, better diagnostics, better optimization, better documentation, and better syntax-directed editing tools.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>One of the motivations for introducing record types is to enable better pattern matching in XSLT when processing JSON input. With XML input, patterns are often based around XML element names. JSON has no direct equivalent of XML’s element names; matching a JSON object such as <code>{longitude: 130.2, latitude: 53.4}</code> relies instead on recognizing the property names appearing in the object. XSLT 4.0, by integrating record types into pattern matching syntax, allows such an object to be matched with a pattern of the form <code>match="record(longitude, latitude)"</code></p></div><p>Rules defining whether one record type is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of another are given in <a href="#id-item-subtype-records"><b>3.3.2.9 Subtyping Records</b></a>.</p></div></div></div><div class="_diffs div2"><h3><a id="id-sequencetype-subtype"></a>3.3 <a href="#id-sequencetype-subtype" style="text-decoration: none">Subtype Relationships</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-item-subtype-documents">next</a> | <a href="#id-generalized-node-types">previous</a>)</p><ol><li><p>The presentation of the rules for the subtype relationship between sequence types and item types has been substantially rewritten to improve clarity; no change to the semantics is intended.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/196">196</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/202">202</a>&nbsp;25 October 2022]</i></p></li></ol></div><p> [<a id="dt-subtype" title="subtype">Definition</a>: Given two <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a> or <a title="item type" class="termref" href="#dt-item-type">item types</a>, the rules in this section determine if one is a <b>subtype</b> of the other. If a type <var>A</var> is a subtype of type <var>B</var>, it follows that every value matched by <var>A</var> is also matched by <var>B</var>.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The relationship <code>subtype(A, A)</code> is always true: every type is a subtype of itself.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The converse is not necessarily true: we cannot infer that if every value matched by <var>A</var> is also matched by <var>B</var>, then <var>A</var> is a subtype of type <var>B</var>. For example, <var>A</var> might be defined as the set of strings matching the regular expression <code>[A-Z]*</code>, while <var>B</var> is the set of strings matching the regular expression <code>[A-Za-z]*</code>; no subtype relationship holds between these types.</p></div><p>The rules for deciding whether one <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> is a subtype of another are given in <a href="#id-seqtype-subtype"><b>3.3.1 Subtypes of Sequence Types</b></a>. The rules for deciding whether one <a title="item type" class="termref" href="#dt-item-type">item type</a> is a subtype of another are given in <a href="#id-itemtype-subtype"><b>3.3.2 Subtypes of Item Types</b></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The subtype relationship is not acyclic. There are cases where <code>subtype(A, B)</code> and <code>subtype(B, A)</code> are both true. This implies that <var>A</var> and <var>B</var> have the same value space, but they can still be different types. For example this applies when <var>A</var> is a union type with member types <code>xs:string</code> and <code>xs:integer</code>, while <var>B</var> is a union type with member types <code>xs:integer</code> and <code>xs:string</code>. These are different types (<code>"23" cast as A</code> produces a string, while <code>"23" cast as B</code> produces an integer, because casting is attempted to each member type in order) but both types have the same value space. </p></div><div class="_diffs div3"><h4><a id="id-itemtype-subtype"></a>3.3.2 <a href="#id-itemtype-subtype" style="text-decoration: none">Subtypes of Item Types</a></h4><p>We use the notation <code>A ⊆ B</code>, or <code>itemtype-subtype(A, B)</code> to indicate that an <a title="item type" class="termref" href="#dt-item-type">item type</a><code>A</code> is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of an item type <code>B</code>. This section defines the rules for deciding whether any two item types have this relationship.</p><p>The rules in this section apply to <a title="item type" class="termref" href="#dt-item-type">item types</a>, not to <a title="item type designator" class="termref" href="#dt-item-type-designator">item type designators</a>. For example, if the name <code>STR</code> has been defined in the static context as a <a title="named item type" class="termref" href="#dt-named-item-type">named item type</a> referring to the type <code>xs:string</code>, then anything said here about the type <code>xs:string</code> applies equally whether it is designated as <code>xs:string</code> or as <code>STR</code>, or indeed as the parenthesized forms <code>(xs:string)</code> or <code>(STR)</code>.</p><p>References to <a title="named item type" class="termref" href="#dt-named-item-type">named item types</a> are handled as described in <a href="#id-itemtype-subtype-aliases"><b>3.3.2.10 Subtyping of Named Item Types</b></a>.</p><p>The relationship <code>A ⊆ B</code> is true if and only if at least one of the conditions listed in the following subsections applies:</p><div class="_diffs div4"><h5><a id="id-item-subtype-maps"></a>3.3.2.7 <a href="#id-item-subtype-maps" style="text-decoration: none">Subtyping Maps</a></h5><p>Given item types <var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply:</p><ol class="enumar"><li><p>Both of the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>map(<var>K</var>, <var>V</var>)</code>, for any <var>K</var> and <var>V</var></p></li><li><p><var>B</var> is <code>map(*)</code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e13763"></a><a id="d2e13803"></a>Example:</div><p><code>map(xs:integer, item()*) ⊆ map(*)</code></p></div></li><li><p>All the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>map(<var>K<sub>a</sub></var>, <var>V<sub>a</sub></var>)</code></p></li><li><p><var>B</var> is <code>map(<var>K<sub>b</sub></var>, <var>V<sub>b</sub></var>)</code></p></li><li><p><code><var>K<sub>a</sub></var> ⊆ <var>K<sub>b</sub></var></code></p></li><li><p><code><var>V<sub>a</sub></var> ⊑ <var>V<sub>b</sub></var></code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e13817"></a><a id="d2e13857"></a>Example:</div><p><code>map(xs:long, item()) ⊆ map(xs:integer, item()+)</code></p></div></li><li><p>Both the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>map(*)</code> (or, because of the transitivity rules, any other map type)</p></li><li><p><var>B</var> is <code>function(*)</code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e13843"></a><a id="d2e13883"></a>Example:</div><p><code>map(xs:long, xs:string?) ⊆ function(*)</code></p></div></li><li><p>Both the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>map(*)</code> (or, because of the transitivity rules, any other map type)</p></li><li><p><var>B</var> is <code>function(xs:anyAtomicType) as item()*</code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e13869"></a><a id="d2e13909"></a>Example:</div><p><code>map(xs:long, xs:string?) ⊆ function(xs:anyAtomicType) as item()*</code></p></div></li><li><p>All the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>map(<var>K</var>, <var>V</var>)</code></p></li><li><p><var>B</var> is <code>function(xs:anyAtomicType) as <var>R</var></code></p></li><li><p><var>V</var> ⊆ <var>R</var></p></li><li><p><code>empty-sequence()</code> ⊆ <var>R</var></p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e13916"></a><a id="d2e13956"></a>Examples:</div><ul><li><p><code>map(xs:int, node()) ⊆ function(xs:anyAtomicType) as node()?</code></p></li><li><p><code>map(xs:int, node()+) ⊆ function(xs:anyAtomicType) as node()*</code></p></li></ul><p>The function accepts type <code>xs:anyAtomicType</code> rather than <code>xs:int</code>, because <code>$M("xyz")</code> is a valid call on a map (treated as a function) even when all the keys in the map are integers.</p><p><span style="display: none;" class="delete_version">The return type of the function is extended from <code>node()</code> or <code>node()+</code> to allow an empty sequence because <code>$M("xyz")</code> can return an empty sequence even if none of the entries in the map contains an empty sequence.</span><span style="display: none;" class="add_version">The return type of the function is extended from <code>node()</code> or <code>node()+</code> to allow the empty sequence because <code>$M("xyz")</code> can return the empty sequence even if none of the entries in the map contains the empty sequence.</span><span class="modify_version">The return type of the function is extended from <code>node()</code> or <code>node()+</code> to allow <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence because <code>$M("xyz")</code> can return <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence even if none of the entries in the map contains <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></div></li></ol></div></div></div><div class="_diffs div2"><h3><a id="id-coercion-rules"></a>3.4 <a href="#id-coercion-rules" style="text-decoration: none">Coercion Rules</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-function-coercion">next</a> | <a href="#id-item-subtype-attributes">previous</a>)</p><ol><li><p> The term "function conversion rules" used in 3.1 has been replaced by the term "coercion rules". <i>&nbsp;&nbsp;[&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/254">254</a>&nbsp;29 November 2022]</i></p></li><li><p> The coercion rules allow “relabeling” of a supplied atomic item where the required type is a derived atomic type: for example, it is now permitted to supply the value 3 when calling a function that expects an instance of <code>xs:positiveInteger</code>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/117">117</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/254">254</a>&nbsp;29 November 2022]</i></p></li><li><p> The coercion rules now allow any numeric type to be implicitly converted to any other, for example an <code>xs:double</code> is accepted where the required type is <code>xs:decimal</code>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/980">980</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/911">911</a>&nbsp;30 January 2024]</i></p></li><li><p> The coercion rules now allow conversion in either direction between <code>xs:hexBinary</code> and <code>xs:base64Binary</code>. <i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/130">130</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/480">480</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/815">815</a>&nbsp;7 November 2023]</i></p></li><li><p> The coercion rules now apply recursively to the members of an array and the entries in a map. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1318">1318</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1501">1501</a>&nbsp;29 October 2024]</i></p></li><li><p> The coercion rules now reorder the entries in a map when the required type is a record type. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1862">1862</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1874">1874</a>&nbsp;25 March 2025]</i></p></li></ol></div><p> [<a id="dt-coercion-rules" title="coercion rules">Definition</a>: The <b>coercion rules</b> are rules used to convert a supplied value to a required type, for example when converting an argument of a function call to the declared type of the function parameter. ] The required type is expressed as a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>. The effect of the coercion rules may be to accept the value as supplied, to convert it to a value that matches the required type, or to reject it with a type error.</p><p>This section defines how the coercion rules operate; the situations in which the rules apply are defined elsewhere, by reference to this section.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In previous versions of this specification, the coercion rules were referred to as the <em>function conversion</em> rules. The terminology has changed because the rules are not exclusively associated with functions or function calling.</p></div><p><span style="display: none;" class="delete_version">If the required type is <code>empty-sequence()</code>, no coercion takes place (the supplied value must be an empty sequence, or a type error occurs).</span><span style="display: none;" class="add_version">If the required type is <code>empty-sequence()</code>, no coercion takes place (the supplied value must be the empty sequence, or a type error occurs).</span><span class="modify_version">If the required type is <code>empty-sequence()</code>, no coercion takes place (the supplied value must be <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, or a type error occurs).</span></p><p>In all other cases, the required <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a><var>T</var> comprises a required <a title="item type" class="termref" href="#dt-item-type">item type</a><var>R</var> and an optional occurrence indicator. The coercion rules are then applied to a supplied value <var>V</var> and the required type <var>T</var> as follows:</p><ol class="enumar"><li><p>Each item in <var>V</var> is processed against the required item type <var>R</var> using the item coercion rules defined in <a href="#id-item-coercion-rules"><b>3.4.1 Item Coercion Rules</b></a>, and the results are sequence-concatenated into a single sequence <var>V′</var>.</p></li><li><p>A type error is raised if the cardinality of <var>V′</var> does not match the required cardinality of <var>T</var> [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li></ol><div class="_diffs div3"><h4><a id="id-item-coercion-rules"></a>3.4.1 <a href="#id-item-coercion-rules" style="text-decoration: none">Item Coercion Rules</a></h4><p>The rules in this section are used to process each item <var>J</var> in a supplied sequence, given a required <a title="item type" class="termref" href="#dt-item-type">item type</a><var>R</var>.</p><ol class="enumar"><li><p>If <var>R</var> is a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a> (for example, if it is an <a title="atomic type" class="termref" href="#dt-atomic-type">atomic type</a>, a <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a>, or an <a title="enumeration type" class="termref" href="#dt-enumeration-type">enumeration type</a>), and <var>J</var> is not an atomic item, then: </p><ol class="enumla"><li><p><var>J</var> is <a title="atomization" class="termref" href="#dt-atomization">atomized</a> to produce a sequence of atomic items <var>JJ</var>.</p></li><li><p>Each atomic item in <var>JJ</var> is coerced to the required type <var>R</var> by recursive application of the item coercion rules (the rules in this section) to produce a value <var>V</var>.</p></li><li><p>The result is the <a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation">sequence concatenation</a> of the <var>V</var> values.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, if <code>J</code> is an element with type annotation <code>xs:integer</code>, and <code>R</code> is the union type <code>xs:numeric</code>, then the effect is to atomize the element to an <code>xs:integer</code>, and then to coerce the resulting <code>xs:integer</code> to <code>xs:numeric</code> (which leaves the integer unchanged). This is not the same as attempting to coerce the element to each of the alternatives of the union type in turn, which would deliver an instance of <code>xs:double</code>.</p></div></li><li><p>Otherwise, if <var>R</var> is a <a title="choice item type" class="termref" href="#dt-choice-item-type">choice item type</a> or a <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a> (which includes the case where it is an <a title="enumeration type" class="termref" href="#dt-enumeration-type">enumeration type</a>), then:</p><ol class="enumla"><li><p>If <var>J</var> matches (is an instance of) one of the alternatives in <var>R</var>, then <var>J</var> is coerced to the first alternative in <var>R</var> that <var>J</var> matches.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>There are two situations where coercing an item to a type that it already matches does not simply return the item unchanged:</p><ul><li><p>When the required type is a typed function type (see <a href="#id-function-test"><b>3.2.8.1 Function Types</b></a>), then function coercion is applied to coerce <var>J</var> to that function type, as described in <a href="#id-function-coercion"><b>3.4.3 Function Coercion</b></a>.</p></li><li><p>When the required type is a record type and the supplied value is a map, then coercion may change the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-entry-order">entry order</a><sup><small>DM</small></sup> of the entries in the map.</p></li></ul></div></li><li><p>Otherwise, the item coercion rules (the rules in this section) are applied to <var>J</var> recursively with <var>R</var> set to each of the alternatives in the choice or union item type, in order, until an alternative is found that does not result in a type error; a type error is raised only if all alternatives fail.</p><p>The error code used in the event of failure should be the error code arising from the first unsuccessful matching attempt. (The diagnostic information associated with the error may also describe how further attempts failed.)</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Suppose the required type is <code>(xs:integer | element(e))*</code> and the supplied value is the sequence <code>(&lt;e&gt;22&lt;/e&gt;, 23, &lt;f&gt;24&lt;/f&gt;)</code>. Item coercion is applied independently to each of the three items in this sequence. The first item matches one of the alternatives, namely <code>element(e)</code>, so it is returned unchanged as an element node. The second item (the integer 23) also matches one of the alternatives, and is returned unchanged as an integer. The third item does not match any of the alternatives, so coercion is attempted to each one in turn. Coercion to type <code>xs:integer</code> succeeds (by virtue of atomization and untyped atomic conversion), so the final result is the sequence <code>(&lt;e&gt;22&lt;/e&gt;, 23, 24)</code></p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Suppose the required type is <code>enum("red", "green", "blue")</code> and the supplied value is <code>"green"</code>. The enumeration type is defined as a choice item type whose alternatives are singleton enumerations, so the rules are applied first to the type <code>enum("red")</code> (which fails), and then to the type <code>enum("green")</code> (which succeeds). The strings in an enumeration type are required to be distinct so the order of checking is in this case immaterial. The supplied value will be accepted, and will be relabeled if necessary as an instance of <code>xs:string</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Schema-defined union types behave in exactly the same way as <a title="choice item type" class="termref" href="#dt-choice-item-type">choice item types.</a></p></div></li><li><p>If <var>R</var> is an <a title="atomic type" class="termref" href="#dt-atomic-type">atomic type</a> and <var>J</var> is an <a title="atomic item" class="termref" href="#dt-atomic-item">atomic item</a>, then:</p><ol class="enumla"><li><p>If <var>J</var> is an instance of <var>R</var> then it is used unchanged.</p></li><li><p>If <var>J</var> is an instance of type <code>xs:untypedAtomic</code> then:</p><ol class="enumlr"><li><p>If <var>R</var> is <a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive">namespace-sensitive</a> then a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a href="#ERRXPTY0117" title="err:XPTY0117">err:XPTY0117</a>] is raised.</p></li><li><p>Otherwise, <var>J</var> is cast to type <var>R</var>.</p></li></ol></li></ol></li><li><p>If there is an entry (<var>from</var>, <var>to</var>) in the following table such that <var>J</var> is an instance of <var>from</var>, and <var>to</var> is <var>R</var>, then <var>J</var> is cast to type <var>R</var>.</p><table style="border:1px solid" class="medium"><caption>Implicit Casting</caption><thead><tr><th>from</th><th>to</th></tr></thead><tbody><tr><td><code>xs:decimal</code></td><td><code>xs:double</code></td></tr><tr><td><code>xs:double</code></td><td><code>xs:decimal</code></td></tr><tr><td><code>xs:decimal</code></td><td><code>xs:float</code></td></tr><tr><td><code>xs:float</code></td><td><code>xs:decimal</code></td></tr><tr><td><code>xs:float</code></td><td><code>xs:double</code></td></tr><tr><td><code>xs:double</code></td><td><code>xs:float</code></td></tr><tr><td><code>xs:string</code></td><td><code>xs:anyURI</code></td></tr><tr><td><code>xs:anyURI</code></td><td><code>xs:string</code></td></tr><tr><td><code>xs:hexBinary</code></td><td><code>xs:base64Binary</code></td></tr><tr><td><code>xs:base64Binary</code></td><td><code>xs:hexBinary</code></td></tr></tbody></table><div class="note"><p class="prefix"><b>Note:</b></p><p>The item type in the <var>to</var> column must match <var>R</var> exactly; however, <var>J</var> may belong to a subtype of the type in the <var>from</var> column.</p><p>For example, an <code>xs:NCName</code> will be cast to type <code>xs:anyURI</code>, but an <code>xs:anyURI</code> will not be cast to type <code>xs:NCName</code>.</p><p>Similarly, an <code>xs:integer</code> will be cast to type <code>xs:double</code>, but an <code>xs:double</code> will not be cast to type <code>xs:integer</code>.</p></div></li><li><p>If <var>R</var> is an <a title="singleton enumeration type" class="termref" href="#dt-singleton-enumeration-type">singleton enumeration type</a> and <var>J</var> is an instance of <code>xs:untypedAtomic</code> or <code>xs:anyURI</code>, then <var>J</var> is cast to type <code>xs:string</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of this rule, when taken in conjunction with the rules above regarding atomization and choice item types, is that when the required type is based on an <a title="enumeration type" class="termref" href="#dt-enumeration-type">enumeration type</a>, for example <code>enum("red", "green", "blue")*</code>, the supplied value can be, in this example:</p><ul><li><p><span class="deltaxml-old" style="background:#FF5555">An</span><span class="deltaxml-new" style="background:#90EE90">The</span> empty sequence.</p></li><li><p>The string <code>"red"</code>.</p></li><li><p>An untyped node whose string value is <code>"red"</code>.</p></li><li><p>A list-valued node whose typed value contains zero or more strings (or <code>xs:anyURI</code> values), each of which is codepoint-equal to one of <code>"red"</code>, <code>"green"</code>, or <code>"blue"</code>.</p></li><li><p>The <code>xs:anyURI</code> value <code>"red"</code>.</p></li><li><p>An array with zero or more members each of which is codepoint-equal to one of <code>"red"</code>, <code>"green"</code>, or <code>"blue"</code>.</p></li><li><p>A JNode whose <b>·content·</b> property is any of the above.</p></li></ul></div></li><li><p>If <var>R</var> is derived from some primitive atomic type <var>P</var>, then <var>J</var> is <b>relabeled</b> as an instance of <var>R</var> if it satisfies all the following conditions:</p><ul><li><p><var>J</var> is an instance of <var>P</var>.</p></li><li><p><var>J</var> is not an instance of <var>R</var>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-datum">datum</a><sup><small>DM</small></sup> of <var>J</var> is within the value space of <var>R</var>.</p></li></ul><p>Relabeling an atomic item changes the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> but not the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-datum">datum</a><sup><small>DM</small></sup>. For example, the <code>xs:integer</code> value 3 can be relabeled as an instance of <code>xs:unsignedByte</code>, because the datum is within the value space of <code>xs:unsignedByte</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Relabeling is not the same as casting. For example, the <code>xs:decimal</code> value 10.1 can be cast to <code>xs:integer</code>, but it cannot be relabeled as <code>xs:integer</code>, because its datum not within the value space of <code>xs:integer</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of this rule is that if, for example, a function parameter is declared with an expected type of <code>xs:positiveInteger</code>, then a call that supplies the literal value 3 will succeed, whereas a call that supplies -3 will fail.</p><p>This differs from previous versions of this specification, where both these calls would fail.</p><p>This change allows the arguments of existing functions to be defined with a more precise type. For example, the <code>$position</code> argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-get"><code>array:get</code></a> could be defined as <code>xs:positiveInteger</code> rather than <code>xs:integer</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>If <var>T</var> is a union type with members <code>xs:negativeInteger</code> and <code>xs:positiveInteger</code> and the supplied value is the sequence <code>(20, -20)</code>, then the effect of these rules is that the first item <code>20</code> is relabeled as type <code>xs:positiveInteger</code> and the second item <code>-20</code>is relabeled as type <code>xs:negativeInteger</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Promotion (for example of <code>xs:float</code> to <code>xs:double</code>) occurs only when <var>T</var> is a primitive type. Relabeling occurs only when <var>T</var> is a derived type. Promotion and relabeling are therefore never combined.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>A <a title="singleton enumeration type" class="termref" href="#dt-singleton-enumeration-type">singleton enumeration type</a> such as <code>enum("green")</code> is treated as an atomic type derived by restriction from <code>xs:string</code>; so if the <code>xs:string</code> value <code>"green"</code> is supplied in a context where the required type is <code>enum("red", "green", "blue")</code>, the value will be accepted.</p></div></li><li><p>If <var>J</var> is a <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-JNode">JNode</a><sup><small>DM</small></sup> and does not match <var>R</var>, then each item in the <b>·content·</b> of <var>J</var> is coerced to type <var>R</var> by applying the coercion rules recursively.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, if <code>$A</code> is an array and the members of the array are maps, then <code>$A/child::*</code> returns a sequence of JNodes that encapsulate maps, and the average size of these maps can be obtained using the expression <code>avg($A/child::* ! map:size(.))</code>. The first argument of <code>map:size</code> does not accept a JNode directly, but it does (in effect) accept a JNode that encapsulates a map.</p></div></li><li><p>If <var>R</var> is an <a href="#doc-xquery40-ArrayType">ArrayType</a> other than <code>array(*)</code> and <var>J</var> is an array, then <var>J</var> is converted to a new array by converting each member to the required member type by applying the coercion rules recursively.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, if the required type is <code>array(xs:double)</code> and the supplied value is <code>[ 1, 2 ]</code>, the array is converted to <code>[ 1e0, 2e0 ]</code>.</p></div></li><li><p>If <var>R</var> is a <a href="#doc-xquery40-MapType">MapType</a> other than <code>map(*)</code> and <var>J</var> is a map, then <var>J</var> is converted to a new map as follows:</p><ol class="enumla"><li><p>Each key in the supplied map is converted to the required map key type by applying the coercion rules. If the resulting map would contain duplicate keys, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>The corresponding value is converted to the required map value type by applying the coercion rules recursively.</p></li><li><p>The order of entries in the map remains unchanged.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, if the required type is <code>map(xs:string, xs:double)</code> and the supplied value is <code>{ "x": 1, "y": 2 }</code>, the map is converted to <code>{ "x": 1e0, "y": 2e0 }</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Duplicate keys can occur if the value space of the target type is more restrictive than the original type. For example, an error is raised if the map <code>{ 1.2: 0, 1.2000001: 0 }</code>, which contains two keys of type <code>xs:decimal</code>, is coerced to the type <code>map(xs:float, xs:integer)</code>.</p></div></li><li><p>If <var>R</var> is a <a href="#doc-xquery40-RecordType">RecordType</a> and <var>J</var> is a map, then <var>J</var> is converted to a new map as follows:</p><ol class="enumla"><li><p>The keys in the supplied map are unchanged.</p></li><li><p>In any map entry whose key is equal to the name of one of the field declarations in <var>R</var> (under the rules of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-atomic-equal"><code>atomic-equal</code></a> function), the corresponding value is converted to the required type defined by that field declaration, by applying the coercion rules recursively (but with XPath 1.0 compatibility mode treated as false).</p></li><li><p>The order of entries in the map is changed: entries whose keys correspond to the names of field declarations in <var>R</var> appear first, in the order of the corresponding field declarations, and (if the record type is extensible) other entries then follow retaining their relative order in <var>J</var>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, if the required type is <code>record(longitude as xs:double, latitude as xs:double)</code> and the supplied value is <code>{ "latitude": 53.2, "longitude": 0 }</code>, then the map is converted to <code>{ "longitude": 0.0e0, "latitude": 53.2e0 }</code>.</p></div></li><li><p>If <var>R</var> is a <a href="#prod-xquery40-TypedFunctionType">TypedFunctionType</a> and <var>J</var> is a function item, then <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> is applied to <var>J</var>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Function coercion applies even if <var>J</var> is already an instance of <var>R</var>.</p><p>Maps and arrays are functions, so function coercion applies to them as well.</p></div></li><li><p> If, after the above conversions, the resulting item does not match the expected item type <var>R</var> according to the rules for <a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching">SequenceType Matching</a>, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Under the general rules for type errors (see <a href="#id-kinds-of-errors"><b>2.5.1 Kinds of Errors</b></a>), a processor <span class="verb">may</span> report a type error during static analysis if it will necessarily occur when the expression is evaluated. For example, the function call <code>fn:abs("beer")</code> will necessarily fail when evaluated, because the function requires a numeric value as its argument; this <span class="verb">may</span> be detected and reported as a static error.</p></div></li></ol></div><div class="_diffs div3"><h4><a id="id-implausible-coercions"></a>3.4.2 <a href="#id-implausible-coercions" style="text-decoration: none">Implausible Coercions</a></h4><p>An expression is deemed to be <a title="implausible" class="termref" href="#dt-implausible">implausible</a> [<a href="#ERRXPTY0006" title="err:XPTY0006">err:XPTY0006</a>] if the static type of the expression, after applying all necessary coercions, is <b>substantively disjoint</b> with the required type <var>T</var>.</p><p> [<a id="dt-substantively-disjoint" title="substantively disjoint">Definition</a>: Two <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a> are deemed to be <b>substantively disjoint</b> if (a) neither is a subtype of the other (see <a href="#id-seqtype-subtype"><b>3.3.1 Subtypes of Sequence Types</b></a>) and (b) the only values that are instances of both types are one or more of the following: </p><ul><li><p>The empty sequence, <code>()</code>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-map">empty map</a><sup><small>DM</small></sup>, <code>{}</code>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-array">empty array</a><sup><small>DM</small></sup>, <code>[]</code>.</p></li></ul><p>]</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Examples of pairs of sequence types that are substantively disjoint include:</p><ul><li><p><code>xs:integer*</code> and <code>xs:string*</code></p></li><li><p><code>map(xs:integer, node())</code> and <code>map(xs:string, node())</code></p></li><li><p><code>array(xs:integer)</code> and <code>array(xs:string)</code></p></li></ul></div><p><span style="display: none;" class="delete_version">For example, supplying a value whose static type is <code>xs:integer*</code> when the required type is <code>xs:string*</code> is <a title="implausible" class="termref" href="#dt-implausible">implausible</a>, because it can succeed only in the special case where the actual value supplied is an empty sequence.</span><span style="display: none;" class="add_version">For example, supplying a value whose static type is <code>xs:integer*</code> when the required type is <code>xs:string*</code> is <a title="implausible" class="termref" href="#dt-implausible">implausible</a>, because it can succeed only in the special case where the actual value supplied is the empty sequence.</span><span class="modify_version">For example, supplying a value whose static type is <code>xs:integer*</code> when the required type is <code>xs:string*</code> is <a title="implausible" class="termref" href="#dt-implausible">implausible</a>, because it can succeed only in the special case where the actual value supplied is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The case where the supplied type and the required type are completely disjoint (for example <code>map(*)</code> and <code>array(*)</code>) is covered by the general rules for type errors: that case can always be reported as a static error.</p></div><p>Examples of implausible coercions include the following:</p><ul><li><p><code>round(timezone-from-time($now))</code>. The result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-timezone-from-time"><code>fn:timezone-from-time</code></a> is of type <code>xs:dayTimeDuration?</code>, which is substantively disjoint with the required type of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-round"><code>fn:round</code></a>, namely <code>xs:numeric?</code>.</p></li><li><p><code>function($x as xs:integer) as array(xs:string) { array { 1 to $x } }</code>. The type of the function body is <code>array(xs:integer)</code>, which is substantively disjoint with the required type <code>array(xs:string)</code>: the function can succeed only in the exceptional case where the function body delivers an <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-array">empty array</a><sup><small>DM</small></sup>.</p></li></ul></div><div class="_diffs div3"><h4><a id="id-function-coercion"></a>3.4.3 <a href="#id-function-coercion" style="text-decoration: none">Function Coercion</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-numeric-literals">next</a> | <a href="#id-coercion-rules">previous</a>)</p><ol><li><p> Function coercion now allows a function with arity <var>N</var> to be supplied where a function of arity greater than <var>N</var> is expected. For example this allows the function <code>true#0</code> to be supplied where a predicate function is required. </p></li><li><p> It has been clarified that function coercion applies even when the supplied function item matches the required function type. This is to ensure that arguments supplied when calling the function are checked against the signature of the required function type, which might be stricter than the signature of the supplied function item. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1020">1020</a>&nbsp;PRs <a href="https://github.com/qt4cg/qtspecs/pull/1023">1023</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/pull/1128">1128</a>&nbsp;9 April 2024]</i></p></li></ol></div><p> Function coercion is a transformation applied to <a title="function item" class="termref" href="#dt-function-item">function items</a> during application of the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. [<a id="dt-function-coercion" title="function coercion">Definition</a>: <b>Function coercion</b> wraps a <a title="function item" class="termref" href="#dt-function-item">function item</a> in a new function whose signature is the same as the expected type. This effectively delays the checking of the argument and return types until the function is called.] </p><p>Given a function <var>F</var>, and an expected function type <var>T</var>, <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> proceeds as follows:</p><ol class="enumar"><li><p>If <var>F</var> has higher arity than <var>T</var>, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] </p></li><li><p>If <var>F</var> has lower arity than <var>T</var>, then <var>F</var> is wrapped in a new function that declares and ignores the additional argument; the following steps are then applied to this new function.</p><p>For example, if <var>T</var> is <code>function(node(), xs:boolean) as xs:string</code>, and the supplied function is <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-name"><code>fn:name#1</code></a>, then the supplied function is effectively replaced by <code>function($n as node(), $b as xs:boolean) as xs:string { fn:name($n) }</code></p><div class="note"><p class="prefix"><b>Note:</b></p><p>This mechanism makes it easier to design versatile and extensible higher-order functions. For example, in previous versions of this specification, the second argument of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-filter"><code>fn:filter</code></a> function expected an argument of type <code>function(item()) as xs:boolean</code>. This has now been extended to <code>function(item(), xs:integer) as xs:boolean</code>, but existing code continues to work, because callback functions that are not interested in the value of the second argument simply ignore it. </p></div></li><li><p>A type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] if, for any parameter type, or for the result type, the relevant type in the signature of the supplied function and the relevant type in the expected function type are <a title="substantively disjoint" class="termref" href="#dt-substantively-disjoint">substantively disjoint</a>. </p><p>For example, the types <code>xs:integer</code> and <code>xs:string</code> are substantively disjoint, so a function with signature <code>function(xs:integer) as xs:boolean</code> cannot be supplied where the expected type is <code>function(xs:string) as xs:boolean</code>.</p></li><li><p>Function coercion then returns a new <a title="function item" class="termref" href="#dt-function-item">function item</a> with the following properties (as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#function-items">8.1 Function Items</a>): </p><ul><li><p><b>name</b>: The name of <var>F</var><span>(if not absent)</span>. </p></li><li><p><b>identity</b>: A new function identity distinct from the identity of any other function item.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>See also <a href="#id-function-identity"><b>4.5.7 Function Identity</b></a>.</p></div></li><li><p><b>signature</b>: <code>Annotations</code> is set to the annotations of <var>F</var>. <code>TypedFunctionType</code> is set to the expected type. </p></li><li><p><b>implementation</b>: In effect, a <code>FunctionBody</code> that calls <var>F</var>, passing it the parameters of this new function, in order. </p></li><li><p><b>nonlocal variable bindings</b>: An empty mapping. </p></li></ul></li></ol><p> These rules have the following consequences: </p><ul><li><p>SequenceType matching of the function’s arguments and result are delayed until that function is called. </p></li><li><p>When the coerced function is called, the supplied arguments must match the parameter typed defined in <var>T</var>; it is not sufficient to match the parameter types defined in <var>F</var>.</p></li><li><p> The <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> rules applied to the function’s arguments and result are defined by the SequenceType it has most recently been coerced to. Additional coercion rules could apply when the wrapped function is called. </p></li><li><p> If an implementation has static type information about a function, that can be used to type check the function’s argument and return types during static analysis. </p></li><li><p>When function coercion is applied to a map or an array, the resulting function is not a map or array, and cannot be used as such. For example, the expression </p><div class="exampleInner"><pre xml:space="preserve">let $f as function(xs:integer) as xs:boolean := { 0: false(), 1: true() }
return $f?0</pre></div><p>raises a type error, because a lookup expression requires the left hand operand to be a map or array, and <code>$f</code> is neither.</p></li><li><p>When function types are used as alternatives in a <a title="choice item type" class="termref" href="#dt-choice-item-type">choice item type</a>, the supplied function is coerced to the first alternative for which coercion does not raise a type error. In this situation it is important to write the alternatives in order, with the most specific first. </p></li></ul><p class="xquery"> For instance, consider the following query: </p><div class="exampleInner"><pre xml:space="preserve">declare function local:filter(
  $s as item()*, 
  $p as function(xs:string) as xs:boolean
) as item()* {
  $s[$p(.)]
};
let $f := function($a) { starts-with($a, "E") }
return local:filter(("Ethel", "Enid", "Gertrude"), $f)</pre></div><p class="xquery"> The function <code>$f</code> has a static type of <code>function(item()*) as item()*</code>. When the <code>local:filter()</code> function is called, the following occurs to the function: </p><ol class="enumar"><li><p> The <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> result in applying <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> to <code>$f</code>, wrapping $f in a new function (<code>$p</code>) with the signature <code>function(xs:string) as xs:boolean</code>. </p></li><li><p><code>$p</code> is matched against the SequenceType of <code>function(xs:string) as xs:boolean</code>, and succeeds. </p></li><li><p> When <code>$p</code> is called inside the predicate, <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion</a> and SequenceType matching rules are applied to the context value argument, resulting in an <code>xs:string</code> value or a type error. </p></li><li><p><code>$f</code> is called with the <code>xs:string</code>, which returns an <code>xs:boolean</code>. </p></li><li><p><code>$p</code> applies <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to the result sequence from <code>$f</code>, which already matches its declared return type of <code>xs:boolean</code>. </p></li><li><p> The <code>xs:boolean</code> is returned as the result of <code>$p</code>. </p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p> The semantics of <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> are specified in terms of wrapping the functions. Static typing may be able to reduce the number of places where this is actually necessary. However, it cannot be assumed that because a supplied function is an instance of the required function type, no function coercion is necessary: the supplied function might not perform all required checks on the types of its arguments. </p></div><p>Since maps and arrays are also functions in XQuery 4.0, <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> applies to them as well. For instance, consider the following expression: </p><div class="exampleInner"><pre xml:space="preserve">let $m := {
  "Monday" : true(),
  "Wednesday" : false(),
  "Friday" : true()
}
let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
return filter($days, $m)</pre></div><p> The map <code>$m</code> is an instance of <code>function(xs:anyAtomicType?) as item()*</code>. When the <code>fn:filter()</code> function is called, the following occurs to the map: </p><ol class="enumar"><li><p>The map <code>$m</code> is treated as a function equivalent to <code>map:get($m, ?)</code>.</p></li><li><p>The <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> result in applying <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> to this function, wrapping it in a new function (<var>M′</var>) with the signature <code>function(item(), xs:integer) as xs:boolean</code>.</p></li><li><p>When <var>M′</var> is called by <code>fn:filter()</code>, <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion</a> and SequenceType matching rules are applied to the argument, resulting in an <code>item()</code> value (<code>$a</code>) or a type error.</p></li><li><p> The function <code>map:get($m, ?)</code> is called with <code>$a</code> as the argument; this returns either an <code>xs:boolean</code> or the empty sequence (call the result <var>R</var>).</p></li><li><p><span style="display: none;" class="delete_version"> The wrapper function <code>$p</code> applies the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to <var>R</var>. If <var>R</var> is an <code>xs:boolean</code> the matching succeeds. When it is an empty sequence (in particular, <code>$m</code> does not contain a key for <code>"Tuesday"</code>), a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>], since the expected type is <code>xs:boolean</code> and the actual type is an empty sequence.</span><span style="display: none;" class="add_version"> The wrapper function <code>$p</code> applies the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to <var>R</var>. If <var>R</var> is an <code>xs:boolean</code> the matching succeeds. When it is the empty sequence (in particular, <code>$m</code> does not contain a key for <code>"Tuesday"</code>), a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>], since the expected type is <code>xs:boolean</code>, which does not allow the empty sequence.</span><span class="modify_version"> The wrapper function <code>$p</code> applies the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to <var>R</var>. If <var>R</var> is an <code>xs:boolean</code> the matching succeeds. When it is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence (in particular, <code>$m</code> does not contain a key for <code>"Tuesday"</code>), a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>], since the expected type is <code>xs:boolean</code><span class="deltaxml-old" style="background:#FF5555"> and the actual type is an</span><span class="deltaxml-new" style="background:#90EE90">, which does not allow the</span> empty sequence.</span></p></li></ol><p>Consider the following expression: </p><div class="exampleInner"><pre xml:space="preserve">let $m := {
   "Monday" : true(),
   "Wednesday" : false(),
   "Friday" : true(),
}
let $days := ("Monday", "Wednesday", "Friday")
return filter($days, $m)</pre></div><p>In this case the result of the expression is the sequence <code>("Monday", "Friday")</code>. But if the input sequence included the string <code>"Tuesday"</code>, the filter operation would fail with a type error. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Function coercion applies even if the supplied function matches the required type.</p><p>For example, consider this case:</p><div class="exampleInner"><pre xml:space="preserve">declare function local:filter(
  $s as item()*, 
  $p as function(xs:string) as xs:boolean
) as item()* {
  $s[$p(.)]
};

let $f := function($a) { $a mod 2 = 0 }
return local:filter(1 to 10, $f)</pre></div><p>Here the supplied function <code>$f</code> is an instance of the required type, because its signature defaults the argument type to <code>item()*</code>, which is a supertype of <code>xs:string</code>. The expression <code>$s[$p(.)]</code> could in principle succeed. However, function coercion ensures that the supplied function is wrapped in a function that requires the argument to be of type <code>xs:string</code>, so the call fails with a type error when the wrapping function is invoked supplying an <code>xs:integer</code> as the argument.</p><p class="xquery">This has the consequence that in XQuery 4.0, there is a backwards incompatibility introduced because coercion rules now apply to global variable declarations (<code>declare variable</code>) and local variable bindings (for example <code>let</code> clauses). Previously the following would execute without error:</p><div class="exampleInner"><pre xml:space="preserve">let $f as function(xs:integer) as item()* := function($x) { $x + 1 }
return $f(12.3)</pre></div><p class="xquery">With XQuery 4.0, as a consequence of function coercion, this fails with a type error because the argument supplied in the function call is not of type <code>xs:integer</code>.</p></div></div><div class="_diffs div3"><h4><a id="id-coercion-examples"></a>3.4.4 <a href="#id-coercion-examples" style="text-decoration: none">Examples of Coercions</a></h4><p>This section illustrates the effect of the coercion rules with examples.</p><div class="example"><div class="exampleHeader"><a id="eg-coercion-to-string"></a>Example: Coercion to <code>xs:string</code></div><p>Consider the case where the required type (of a variable, or a function argument) is <code>xs:string</code>. For example, the second argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-matches"><code>fn:matches</code></a>, which expects a regular expression. The table below illustrates the values that might be supplied, and the coercions that are applied.</p><table class="medium"><thead><tr><th style="text-align:left">Supplied Value</th><th style="text-align:left">Coercion</th></tr></thead><tbody><tr><td style="vertical-align:top"><code>"[0-9]"</code></td><td style="vertical-align:top"><p>None; the supplied value is an instance of the required type.</p></td></tr><tr><td style="vertical-align:top"><code>default-language()</code></td><td style="vertical-align:top"><p>None; the supplied value is an instance of <code>xs:language</code>, which is a subtype of the required type <code>xs:string</code>.</p></td></tr><tr><td style="vertical-align:top"><code>&lt;a&gt;[0-9]&lt;/a&gt;</code></td><td style="vertical-align:top"><p>The supplied element node is atomized. Unless it has been schema-validated, the typed value will be an instance of <code>xs:untypedAtomic</code>, which is accepted when the required type is <code>xs:string</code>.</p><p>Supplying an element whose type annotation is (say) <code>xs:date</code> will fail with a type error.</p></td></tr><tr><td style="vertical-align:top"><code>xs:anyURI("urn:dummy")</code></td><td style="vertical-align:top"><p>Supplying an instance of <code>xs:anyURI</code> where the expected type is <code>xs:string</code> is permitted; this is one of the pairs of types where implicit casting is allowed.</p></td></tr><tr><td style="vertical-align:top"><code>["a|b"]</code></td><td style="vertical-align:top"><p>Supplying an array holding a single string succeeds, because the rules cause the array to be atomized, and the value after atomization is a single string.</p><p>Supplying an array holding multiple strings would fail.</p></td></tr></tbody></table></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="eg-coercion-to-decimal"></a>Example: Coercion to <code>xs:decimal?</code></div><p>Consider the case where the required type (of a variable, or a function argument) is <code>xs:decimal?</code>. For example, the first argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-seconds"><code>fn:seconds</code></a>, which expects a decimal number of seconds. The table below illustrates the values that might be supplied, and the coercions that are applied.</p><table class="medium"><thead><tr><th style="text-align:left">Supplied Value</th><th style="text-align:left">Coercion</th></tr></thead><tbody><tr><td style="vertical-align:top"><code>12.4</code></td><td style="vertical-align:top"><p>None; the supplied value is an instance of the required type.</p></td></tr><tr><td style="vertical-align:top"><code>()</code></td><td style="vertical-align:top"><p>None; <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence is an instance of the required type.</p></td></tr><tr><td style="vertical-align:top"><code>42</code></td><td style="vertical-align:top"><p>None; the supplied value is an instance of <code>xs:integer</code>, which is a subtype of the required type.</p></td></tr><tr><td style="vertical-align:top"><code>math:pi()</code></td><td style="vertical-align:top"><p>The supplied value is an instance of <code>xs:double</code>, which can be converted to <code>xs:decimal</code> under the coercion rules.</p></td></tr><tr><td style="vertical-align:top"><code>("a", "b")[.="c"]</code></td><td style="vertical-align:top"><p><span style="display: none;" class="delete_version">The supplied value is an empty sequence, which is a valid instance of the required type <code>xs:decimal?</code>. However, the processor may (optionally) reject this as an implausible coercion, on the grounds that it can only succeed in one special case, namely where the filter expression selects no values. </span><span style="display: none;" class="add_version">The supplied value is the empty sequence, which is a valid instance of the required type <code>xs:decimal?</code>. However, the processor may (optionally) reject this as an implausible coercion, on the grounds that it can only succeed in one special case, namely where the filter expression selects no values. </span><span class="modify_version">The supplied value is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, which is a valid instance of the required type <code>xs:decimal?</code>. However, the processor may (optionally) reject this as an implausible coercion, on the grounds that it can only succeed in one special case, namely where the filter expression selects no values. </span></p></td></tr><tr><td style="vertical-align:top"><code>(1.5, 2.5, 3.5)</code></td><td style="vertical-align:top"><p>A type error is raised.</p></td></tr><tr><td style="vertical-align:top"><code>&lt;a&gt;3.14159&lt;/a&gt;</code></td><td style="vertical-align:top"><p>The element node is atomized; unless it has been schema-validated, the result will be <code>"3.14159"</code> as an instance of <code>xs:untypedAtomic</code>. This is converted to an instance of <code>xs:decimal</code> following the rules of the <code>cast as</code> operator.</p></td></tr><tr><td style="vertical-align:top"><code>[1.5]</code></td><td style="vertical-align:top"><p>The array is atomized, and the result is a valid instance of the required type <code>xs:decimal?</code></p></td></tr><tr><td style="vertical-align:top"><code>[]</code></td><td style="vertical-align:top"><p><span style="display: none;" class="delete_version">The array is atomized, and the result is an empty sequence, which is a valid instance of the required type <code>xs:decimal?</code></span><span style="display: none;" class="add_version">The array is atomized, and the result is the empty sequence, which is a valid instance of the required type <code>xs:decimal?</code></span><span class="modify_version">The array is atomized, and the result is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, which is a valid instance of the required type <code>xs:decimal?</code></span></p></td></tr></tbody></table></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="eg-coercion-to-positive-integer"></a>Example: Coercion to <code>xs:positive-integer</code></div><p>Consider the case where the required type (of a variable, or a function argument) is <code>xs:positive-integer</code>. The table below illustrates the values that might be supplied, and the coercions that are applied.</p><table class="medium"><thead><tr><th style="text-align:left">Supplied Value</th><th style="text-align:left">Coercion</th></tr></thead><tbody><tr><td style="vertical-align:top"><code>12</code></td><td style="vertical-align:top"><p>The supplied value is of type <code>xs:integer</code>. Because the supplied value and the required type, <code>xs:positiveInteger</code>, both come under the primitive type <code>xs:decimal</code>, and the value <code>12</code> is within the value space of <code>xs:positiveInteger</code>, the value is relabeled as an <code>xs:positiveInteger</code> and the call succeeds.</p></td></tr><tr><td style="vertical-align:top"><code>12.1</code></td><td style="vertical-align:top"><p>This fails with a type error, because the <code>xs:decimal</code> value <code>12.1</code> is not a value in the value space of <code>xs:positiveInteger</code>. This is so even though casting to <code>xs:positiveInteger</code> would succeed.</p></td></tr><tr><td style="vertical-align:top"><code>math:pi()</code></td><td style="vertical-align:top"><p>This fails with a type error. A value of type <code>xs:double</code> is accepted where the required type is <code>xs:decimal</code> or <code>xs:float</code>, but not where it is <code>xs:positiveInteger</code>.</p></td></tr><tr><td style="vertical-align:top"><code>&lt;a&gt;1200&lt;/a&gt;</code></td><td style="vertical-align:top"><p>The supplied element node is atomized. If the element has not been schema-validated, the result will be an <code>xs:untypedAtomic</code> item, which is successfully cast to the required type <code>xs:positiveInteger</code>. If the element has been validated against a schema, then coercion succeeds if the typed value would itself be acceptable, for example if it is an <code>xs:positiveInteger</code>, or some other <code>xs:decimal</code> within the value space of <code>xs:positiveInteger</code>.</p></td></tr></tbody></table></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="eg-coercion-to-union"></a>Example: Coercion to a union type</div><p>Consider the first parameter of the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-char"><code>fn:char</code></a>, whose declared type is <code>(xs:string | xs:positiveInteger)</code>. The rules are the same as if it were a union typed declared in an imported schema.</p><table class="medium"><thead><tr><th style="text-align:left">Supplied Value</th><th style="text-align:left">Coercion</th></tr></thead><tbody><tr><td style="vertical-align:top"><code>"amp"</code></td><td style="vertical-align:top"><p>The supplied value is of type <code>xs:string</code>, which is one of the allowed types. The call therefore succeeds.</p></td></tr><tr><td style="vertical-align:top"><code>"#"</code></td><td style="vertical-align:top"><p>The supplied value is of type <code>xs:string</code>, which is one of the allowed types. As far as the coercion rules are concerned, the call therefore succeeds. Under the semantic rules for the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-char"><code>fn:char</code></a> function, however, this value is not accepted; a dynamic error (as distinct from a type error) is therefore raised.</p></td></tr><tr><td style="vertical-align:top"><code>0x25</code></td><td style="vertical-align:top"><p>The supplied value is of type <code>xs:integer</code>. Although this is not one of the allowed types, it is acceptable because coercion of the value to type <code>xs:positiveInteger</code> succeeds. The value is relabeled as an instance of <code>xs:positiveInteger</code>.</p></td></tr><tr><td style="vertical-align:top"><code>&lt;a&gt;0x25&lt;/a&gt;</code></td><td style="vertical-align:top"><p>The supplied element node is atomized. Assuming that the node has not been schema-validated, the result is an instance of <code>xs:untypedAtomic</code>. The member types of the choice are tested in order. Conversion to <code>xs:string</code> with the value "0x25" succeeds, so the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-char"><code>fn:char</code></a> function is called supplying this string; but the function rejects this string as semantically invalid. The same would happen if the value were, say, &lt;a&gt;37&lt;/a&gt;. Supplying such a value requires an explicit cast, for example <code>fn:char( xs:positiveInteger( ./a ))</code>.</p></td></tr></tbody></table></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="eg-coercion-to-choice"></a>Example: Coercion to a choice type</div><p>Suppose the required type is <code>(record(x as xs:decimal, y as xs:decimal, *) | record(size as enum("S", "M", "L", "XL"), *))</code>.</p><table class="medium"><thead><tr><th style="text-align:left">Supplied Value</th><th style="text-align:left">Coercion</th></tr></thead><tbody><tr><td style="vertical-align:top"><code>{ "x": 1, "y": 2, "z": 3 }</code></td><td style="vertical-align:top"><p>The supplied value is an instance of the first record type: no coercion is necessary.</p></td></tr><tr><td style="vertical-align:top"><code>{ "size": "M" }</code></td><td style="vertical-align:top"><p>The supplied value is an instance of the second record type: no coercion is necessary.</p></td></tr><tr><td style="vertical-align:top"><code>{ "x": 1, "y": 2, "size": "XL" }</code></td><td style="vertical-align:top"><p>The supplied value is an instance of both record types: no coercion is necessary.</p></td></tr><tr><td style="vertical-align:top"><code>{ "x": 1e0, "y": 2e0, "size": "XL" }</code></td><td style="vertical-align:top"><p>The supplied value is not an instance of the first record type because the fields are of type <code>xs:double</code> rather than <code>xs:decimal</code>. It is however an instance of the second record type. It is therefore accepted <em>as is</em>; the fields <code>x</code> and <code>y</code> are not converted from <code>xs:double</code> to <code>xs:decimal</code>.</p></td></tr><tr><td style="vertical-align:top"><code>{ "x": 1e0, "y": 2e0, "size": "XXL" }</code></td><td style="vertical-align:top"><p>The supplied value is not an instance of the first record type because the fields are of type <code>xs:double</code> rather than <code>xs:decimal</code>, and it is not an instance of the second record type because the <code>size</code> value does not match the enumeration type. Coercion is therefore attempted to the first record type, and succeeds. The <code>x</code> and <code>y</code> fields are coerced to <code>xs:decimal</code>, and the <code>size</code> field is accepted <em>as is</em>.</p></td></tr></tbody></table></div></div></div></div><div class="_diffs div1"><h2><a id="id-expressions"></a>4 <a href="#id-expressions" style="text-decoration: none">Expressions</a></h2><p>This section discusses each of the basic kinds of expression. Each kind of expression has a name such as <code>PathExpr</code>, which is introduced on the left side of the grammar production that defines the expression. Since XQuery 4.0 is a composable language, each kind of expression is defined in terms of other expressions whose operators have a higher precedence. In this way, the precedence of operators is represented explicitly in the grammar.</p><p>The order in which expressions are discussed in this document does not reflect the order of operator precedence. In general, this document introduces the simplest kinds of expressions first, followed by more complex expressions. For the complete grammar, see Appendix [<a href="#nt-bnf"><b>A XQuery 4.0 Grammar</b></a>].</p><p><span class="xquery"> [<a id="dt-query" title="query">Definition</a>: A <b>query</b> consists of one or more <a title="module" class="termref" href="#dt-module">modules</a>.] If a query is executable, one of its modules has a <a title="query body" class="termref" href="#dt-queryBody">Query Body</a> containing an expression whose value is the result of the query. An expression is represented in the XQuery grammar by the symbol <a href="#doc-xquery40-Expr">Expr</a>.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Expr"></a><code><a href="#prod-xquery40-Expr">Expr</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-Expr-ExprSingle">ExprSingle</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Expr-ExprSingle"></a><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-FLWORExpr">FLWORExpr</a><br>| <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xquery40-SwitchExpr">SwitchExpr</a><br>| <a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#doc-xquery40-IfExpr">IfExpr</a><br>| <a href="#doc-xquery40-TryCatchExpr">TryCatchExpr</a><br>| <a href="#doc-xquery40-OrExpr">OrExpr</a></code></td></tr></tbody></table><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ExprSingle"></a><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-ExprSingle-FLWORExpr">FLWORExpr</a><br>| <a href="#doc-xquery40-ExprSingle-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xquery40-ExprSingle-SwitchExpr">SwitchExpr</a><br>| <a href="#doc-xquery40-ExprSingle-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#doc-xquery40-ExprSingle-IfExpr">IfExpr</a><br>| <a href="#doc-xquery40-ExprSingle-TryCatchExpr">TryCatchExpr</a><br>| <a href="#doc-xquery40-ExprSingle-OrExpr">OrExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ExprSingle-FLWORExpr"></a><code><a href="#prod-xquery40-FLWORExpr">FLWORExpr</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-InitialClause">InitialClause</a><a href="#prod-xquery40-IntermediateClause">IntermediateClause</a>* <a href="#doc-xquery40-ReturnClause">ReturnClause</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ExprSingle-QuantifiedExpr"></a><code><a href="#prod-xquery40-QuantifiedExpr">QuantifiedExpr</a></code></td><td>::=</td><td><code>("some" | "every") (<a href="#prod-xquery40-QuantifierBinding">QuantifierBinding</a> ++ ",") "satisfies" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ExprSingle-SwitchExpr"></a><code><a href="#prod-xquery40-SwitchExpr">SwitchExpr</a></code></td><td>::=</td><td><code>"switch" <a href="#prod-xquery40-SwitchComparand">SwitchComparand</a> (<a href="#prod-xquery40-SwitchCases">SwitchCases</a> | <a href="#prod-xquery40-BracedSwitchCases">BracedSwitchCases</a>)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ExprSingle-TypeswitchExpr"></a><code><a href="#prod-xquery40-TypeswitchExpr">TypeswitchExpr</a></code></td><td>::=</td><td><code>"typeswitch" "(" <a href="#doc-xquery40-Expr">Expr</a> ")" (<a href="#prod-xquery40-TypeswitchCases">TypeswitchCases</a> | <a href="#prod-xquery40-BracedTypeswitchCases">BracedTypeswitchCases</a>)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ExprSingle-IfExpr"></a><code><a href="#prod-xquery40-IfExpr">IfExpr</a></code></td><td>::=</td><td><code>"if" "(" <a href="#doc-xquery40-Expr">Expr</a> ")" (<a href="#prod-xquery40-UnbracedActions">UnbracedActions</a> | <a href="#prod-xquery40-BracedAction">BracedAction</a>)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ExprSingle-TryCatchExpr"></a><code><a href="#prod-xquery40-TryCatchExpr">TryCatchExpr</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-TryClause">TryClause</a> ((<a href="#prod-xquery40-CatchClause">CatchClause</a>+ <a href="#prod-xquery40-FinallyClause">FinallyClause</a>?) | <a href="#prod-xquery40-FinallyClause">FinallyClause</a>)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ExprSingle-OrExpr"></a><code><a href="#prod-xquery40-OrExpr">OrExpr</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-AndExpr">AndExpr</a> ("or" <a href="#prod-xquery40-AndExpr">AndExpr</a>)*</code></td></tr></tbody></table><p>The XQuery 4.0 operator that has lowest precedence is the <a title="comma operator" class="termref" href="#dt-comma-operator">comma operator</a>, which is used to combine two operands to form a sequence. As shown in the grammar, a general expression (<a href="#doc-xquery40-Expr">Expr</a>) can consist of multiple <a href="#doc-xquery40-ExprSingle">ExprSingle</a> operands, separated by commas.</p><p>The name <a href="#doc-xquery40-ExprSingle">ExprSingle</a> denotes an expression that does not contain a top-level <a title="comma operator" class="termref" href="#dt-comma-operator">comma operator</a> (despite its name, an <a href="#doc-xquery40-ExprSingle">ExprSingle</a> may evaluate to a sequence containing more than one item.)</p><p>The symbol <a href="#doc-xquery40-ExprSingle">ExprSingle</a> is used in various places in the grammar where an expression is not allowed to contain a top-level comma. For example, each of the arguments of a function call must be a <a href="#doc-xquery40-ExprSingle">ExprSingle</a>, because commas are used to separate the arguments of a function call.</p><p>After the comma, the expressions that have next lowest precedence are <span class="xquery"><a href="#doc-xquery40-FLWORExpr">FLWORExpr</a>,</span><a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a>, <span class="xquery"><a href="#doc-xquery40-SwitchExpr">SwitchExpr</a>, <a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a>, </span><a href="#doc-xquery40-IfExpr">IfExpr</a>, <span class="xquery"><a href="#doc-xquery40-TryCatchExpr">TryCatchExpr</a>, </span> and <a href="#doc-xquery40-OrExpr">OrExpr</a>. Each of these expressions is described in a separate section of this document.</p><div class="_diffs div2"><h3><a id="id-primary-expressions"></a>4.2 <a href="#id-primary-expressions" style="text-decoration: none">Primary Expressions</a></h3><p> [<a id="dt-primary-expression" title="primary expression">Definition</a>: A <b>primary expression</b> is an instance of the production <a href="#doc-xquery40-PrimaryExpr">PrimaryExpr</a>. Primary expressions are the basic primitives of the language. They include literals, variable references, context value references, <span class="xquery">constructors, </span> and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.] <span class="xquery">Node Constructors are described in <a href="#id-constructors"><b>4.12 Node Constructors</b></a>.</span>Map and Array Constructors are described in <a href="#id-maps"><b>4.14.1 Maps</b></a> and <a href="#id-arrays"><b>4.14.2 Arrays</b></a>. <span class="xquery">String Constructors are described in <a href="#id-string-constructors"><b>4.9.3 String Constructors</b></a>.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr"></a><code><a href="#prod-xquery40-PrimaryExpr">PrimaryExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-PrimaryExpr-Literal">Literal</a><br>| <a href="#doc-xquery40-PrimaryExpr-VarRef">VarRef</a><br>| <a href="#doc-xquery40-PrimaryExpr-ParenthesizedExpr">ParenthesizedExpr</a><br>| <a href="#doc-xquery40-PrimaryExpr-ContextValueRef">ContextValueRef</a><br>| <a href="#doc-xquery40-PrimaryExpr-FunctionCall">FunctionCall</a><br>| <a href="#doc-xquery40-PrimaryExpr-OrderedExpr">OrderedExpr</a><br>| <a href="#doc-xquery40-PrimaryExpr-UnorderedExpr">UnorderedExpr</a><br>| <a href="#doc-xquery40-PrimaryExpr-NodeConstructor">NodeConstructor</a><br>| <a href="#doc-xquery40-PrimaryExpr-FunctionItemExpr">FunctionItemExpr</a><br>| <a href="#doc-xquery40-PrimaryExpr-MapConstructor">MapConstructor</a><br>| <a href="#doc-xquery40-PrimaryExpr-ArrayConstructor">ArrayConstructor</a><br>| <a href="#doc-xquery40-PrimaryExpr-StringTemplate">StringTemplate</a><br>| <a href="#doc-xquery40-PrimaryExpr-StringConstructor">StringConstructor</a><br>| <a href="#doc-xquery40-PrimaryExpr-UnaryLookup">UnaryLookup</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-Literal"></a><code><a href="#prod-xquery40-Literal">Literal</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-NumericLiteral">NumericLiteral</a> | <a href="#doc-xquery40-StringLiteral">StringLiteral</a> | <a href="#doc-xquery40-QNameLiteral">QNameLiteral</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-VarRef"></a><code><a href="#prod-xquery40-VarRef">VarRef</a></code></td><td>::=</td><td><code>"$" <a href="#doc-xquery40-EQName">EQName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-ParenthesizedExpr"></a><code><a href="#prod-xquery40-ParenthesizedExpr">ParenthesizedExpr</a></code></td><td>::=</td><td><code>"(" <a href="#doc-xquery40-Expr">Expr</a>? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-ContextValueRef"></a><code><a href="#prod-xquery40-ContextValueRef">ContextValueRef</a></code></td><td>::=</td><td><code>"."</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-FunctionCall"></a><code><a href="#prod-xquery40-FunctionCall">FunctionCall</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-EQName">EQName</a><a href="#prod-xquery40-ArgumentList">ArgumentList</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a> */</td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-parens">gn: parens</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-OrderedExpr"></a><code><a href="#prod-xquery40-OrderedExpr">OrderedExpr</a></code></td><td>::=</td><td><code>"ordered" <a href="#doc-xquery40-PrimaryExpr-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-UnorderedExpr"></a><code><a href="#prod-xquery40-UnorderedExpr">UnorderedExpr</a></code></td><td>::=</td><td><code>"unordered" <a href="#doc-xquery40-PrimaryExpr-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-EnclosedExpr"></a><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td>::=</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-NodeConstructor"></a><code><a href="#prod-xquery40-NodeConstructor">NodeConstructor</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-DirectConstructor">DirectConstructor</a><br>| <a href="#doc-xquery40-ComputedConstructor">ComputedConstructor</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-FunctionItemExpr"></a><code><a href="#prod-xquery40-FunctionItemExpr">FunctionItemExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-PrimaryExpr-NamedFunctionRef">NamedFunctionRef</a> | <a href="#doc-xquery40-PrimaryExpr-InlineFunctionExpr">InlineFunctionExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-NamedFunctionRef"></a><code><a href="#prod-xquery40-NamedFunctionRef">NamedFunctionRef</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-EQName">EQName</a> "#" <a href="#prod-xquery40-IntegerLiteral">IntegerLiteral</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-InlineFunctionExpr"></a><code><a href="#prod-xquery40-InlineFunctionExpr">InlineFunctionExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-Annotation">Annotation</a>* ("function" | "fn") <a href="#prod-xquery40-FunctionSignature">FunctionSignature</a>? <a href="#prod-xquery40-FunctionBody">FunctionBody</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-MapConstructor"></a><code><a href="#prod-xquery40-MapConstructor">MapConstructor</a></code></td><td>::=</td><td><code>"map"? "{" (<a href="#prod-xquery40-MapConstructorEntry">MapConstructorEntry</a> ** ",") "}"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-ArrayConstructor"></a><code><a href="#prod-xquery40-ArrayConstructor">ArrayConstructor</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-SquareArrayConstructor">SquareArrayConstructor</a> | <a href="#prod-xquery40-CurlyArrayConstructor">CurlyArrayConstructor</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-StringTemplate"></a><code><a href="#prod-xquery40-StringTemplate">StringTemplate</a></code></td><td>::=</td><td><code>"`" (<a href="#prod-xquery40-StringTemplateFixedPart">StringTemplateFixedPart</a> | <a href="#prod-xquery40-StringTemplateVariablePart">StringTemplateVariablePart</a>)* "`"</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-StringConstructor"></a><code><a href="#prod-xquery40-StringConstructor">StringConstructor</a></code></td><td>::=</td><td><code>"``[" <a href="#prod-xquery40-StringConstructorContent">StringConstructorContent</a> "]``"</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PrimaryExpr-UnaryLookup"></a><code><a href="#prod-xquery40-UnaryLookup">UnaryLookup</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-Lookup">Lookup</a></code></td></tr></tbody></table><div class="_diffs div3"><h4><a id="id-paren-expressions"></a>4.2.4 <a href="#id-paren-expressions" style="text-decoration: none">Parenthesized Expressions</a></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ParenthesizedExpr"></a><code><a href="#prod-xquery40-ParenthesizedExpr">ParenthesizedExpr</a></code></td><td>::=</td><td><code>"(" <a href="#doc-xquery40-ParenthesizedExpr-Expr">Expr</a>? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ParenthesizedExpr-Expr"></a><code><a href="#prod-xquery40-Expr">Expr</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-ExprSingle">ExprSingle</a> ++ ",")</code></td></tr></tbody></table><p>Parentheses may be used to override the precedence rules. For example, the expression <code>(2 + 4) * 5</code> evaluates to thirty, since the parenthesized expression <code>(2 + 4)</code> is evaluated first and its result is multiplied by five. Without parentheses, the expression <code>2 + 4 * 5</code> evaluates to twenty-two, because the multiplication operator has higher precedence than the addition operator.</p><p>Empty parentheses are used to denote <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, as described in <a href="#construct_seq"><b>4.7.1 Sequence Concatenation</b></a>.</p></div></div><div class="_diffs div2"><h3><a id="id-functions"></a>4.5 <a href="#id-functions" style="text-decoration: none">Functions</a></h3><p>Functions in XQuery 4.0 arise in two ways:</p><ul><li><p>A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> contains information about a family of functions with the same name and a defined arity range. These functions are in most cases known statically (they appear in the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a>), but there may be further function definitions that are known only dynamically (appearing in the <a title="dynamically known function definitions" class="termref" href="#dt-dynamically-known-function-definitions">dynamically known function definitions</a>).</p></li><li><p><a title="function item" class="termref" href="#dt-function-item">Function items</a> are XDM items that can be called using a <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a>. They are values that can be bound to variables, passed as arguments, returned as function results, and generally manipulated in the same way as other XDM values.</p></li></ul><p>The functions defined by a statically known <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> can be invoked using a <a title="static function call" class="termref" href="#dt-static-function-call">static function call</a>. <a title="function item" class="termref" href="#dt-function-item">Function items</a> corresponding to these definitions can also be obtained, as dynamic values, by evaluating a <a title="named function reference" class="termref" href="#dt-named-function-ref">named function reference</a>. <a title="function item" class="termref" href="#dt-function-item">Function items</a> can also be obtained using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>fn:function-lookup</code></a> function: in this case the function name and arity do not need to be known statically, and the function definition need not be present in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, so long as it is in the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a>.</p><p>Static and dynamic function calls are described in the following sections.</p><div class="_diffs div3"><h4><a id="id-static-functions"></a>4.5.1 <a href="#id-static-functions" style="text-decoration: none">Static Function Calls</a></h4><p>The <a title="static context" class="termref" href="#dt-static-context">static context</a> for an expression includes a set of <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a>. Every <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the static context has a name (which is an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>) and an <a title="arity range" class="termref" href="#dt-arity-range">arity range</a>, which is a range of permitted arities for calls on that function. Two <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> having the same name must not have overlapping arity ranges. This means that for a given static function call, it is possible to identify the target function definition in the static context unambiguously from knowledge of the function name and the number of supplied arguments.</p><p>A <a title="static function call" class="termref" href="#dt-static-function-call">static function call</a> is bound to a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the static context by matching the name and arity. If the function call has <var>P</var> positional arguments followed by <var>K</var> keyword arguments, then the required arity is <var>P+K</var>, and the static context must include a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> whose name matches the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> in the function call, and whose <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> includes this required arity. This is the function chosen to be called. The result of the function is obtained by evaluating the expression that forms its implementation, with a dynamic context that provides values for all the declared parameters, initialized as described in <a href="#id-eval-static-function-call"><b>4.5.1.2 Evaluating Static Function Calls</b></a> below.</p><p>Similarly, a <a title="named function reference" class="termref" href="#dt-named-function-ref">named function reference</a> of the form <code>f#N</code> binds to a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the static context whose name matches <var>f</var> where <code>MinP ≤ N and MaxP ≥ N</code>. The result of evaluating a function reference is a <a title="function item" class="termref" href="#dt-function-item">function item</a> which can be called using a dynamic function call. Function items are never variadic and their arguments are always supplied positionally. For example, the function reference <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-concat"><code>fn:concat#3</code></a> returns a function item with arity 3, which is always called by supplying three positional arguments, and whose effect is the same as a static call on <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-concat"><code>fn:concat</code></a> with three positional arguments. </p><p>The detailed rules for evaluating static function calls and function references are defined in subsequent sections.</p><div class="_diffs div4"><h5><a id="id-function-calls"></a>4.5.1.1 <a href="#id-function-calls" style="text-decoration: none">Static Function Call Syntax</a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-eval-dynamic-function-call">next</a> | <a href="#id-filter-expression">previous</a>)</p><ol><li><p> Keyword arguments are allowed on static function calls, as well as positional arguments. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/155">155</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/159">159</a>&nbsp;30 September 2020]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FunctionCall"></a><code><a href="#prod-xquery40-FunctionCall">FunctionCall</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-FunctionCall-EQName">EQName</a><a href="#doc-xquery40-FunctionCall-ArgumentList">ArgumentList</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a> */</td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-parens">gn: parens</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FunctionCall-EQName"></a><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-QName">QName</a> | <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FunctionCall-ArgumentList"></a><code><a href="#prod-xquery40-ArgumentList">ArgumentList</a></code></td><td>::=</td><td><code>"(" ((<a href="#doc-xquery40-FunctionCall-PositionalArguments">PositionalArguments</a> ("," <a href="#doc-xquery40-FunctionCall-KeywordArguments">KeywordArguments</a>)?) | <a href="#doc-xquery40-FunctionCall-KeywordArguments">KeywordArguments</a>)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FunctionCall-PositionalArguments"></a><code><a href="#prod-xquery40-PositionalArguments">PositionalArguments</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-FunctionCall-Argument">Argument</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FunctionCall-Argument"></a><code><a href="#prod-xquery40-Argument">Argument</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-FunctionCall-ExprSingle">ExprSingle</a> | <a href="#doc-xquery40-FunctionCall-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FunctionCall-ExprSingle"></a><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-FLWORExpr">FLWORExpr</a><br>| <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xquery40-SwitchExpr">SwitchExpr</a><br>| <a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#doc-xquery40-IfExpr">IfExpr</a><br>| <a href="#doc-xquery40-TryCatchExpr">TryCatchExpr</a><br>| <a href="#doc-xquery40-OrExpr">OrExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FunctionCall-ArgumentPlaceholder"></a><code><a href="#prod-xquery40-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td><td>::=</td><td><code>"?"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FunctionCall-KeywordArguments"></a><code><a href="#prod-xquery40-KeywordArguments">KeywordArguments</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-FunctionCall-KeywordArgument">KeywordArgument</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FunctionCall-KeywordArgument"></a><code><a href="#prod-xquery40-KeywordArgument">KeywordArgument</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-FunctionCall-EQName">EQName</a> ":=" <a href="#doc-xquery40-FunctionCall-Argument">Argument</a></code></td></tr></tbody></table><p> [<a id="dt-static-function-call" title="static function call">Definition</a>: A <b>static function call</b> is an instance of the production <a href="#doc-xquery40-FunctionCall">FunctionCall</a>: it consists of an EQName followed by a parenthesized list of zero or more arguments.].</p><p>The EQName is expanded using the <a title="default function namespace rule" class="termref" href="#dt-default-function-namespace-rule">default function namespace rule</a>.</p><p>The argument list consists of zero or more positional arguments, followed by zero or more keyword arguments.</p><p> [<a id="dt-arg-expr" title="argument expression">Definition</a>: An argument to a function call is either an <b>argument expression</b> or an <a href="#prod-xquery40-ArgumentPlaceholder">ArgumentPlaceholder</a> (<code>?</code>); in both cases it may either be supplied positionally, or identified by a name (called a keyword).] </p><p>This section is concerned with static function calls in which none of the arguments are <a href="#prod-xquery40-ArgumentPlaceholder">ArgumentPlaceholders</a>. Calls using one or more <a href="#prod-xquery40-ArgumentPlaceholder">ArgumentPlaceholders</a> are covered in the section <a href="#id-partial-function-application"><b>4.5.4 Partial Function Application</b></a>.</p><p>The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> used as the function name and the number of arguments used in the static function call (the required arity) must match the name and arity range of a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a><span> using the rules defined in the previous section</span>; if there is no match, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>]. </p><p>Evaluation of static function calls is described in <a href="#id-eval-static-function-call"><b>4.5.1.2 Evaluating Static Function Calls</b></a> .</p><p>Since the arguments of a function call are separated by commas, any <a title="argument expression" class="termref" href="#dt-arg-expr">argument expression</a> that contains a top-level <a title="comma operator" class="termref" href="#dt-comma-operator">comma operator</a> must be enclosed in parentheses. Here are some illustrative examples of static function calls:</p><ul><li><p><code>my:three-argument-function(1, 2, 3)</code> denotes a static function call with three <span>positional</span> arguments. <span>The corresponding function declaration must define at least three parameters, and may define more, provided they are optional.</span></p></li><li><p><code>my:two-argument-function((1, 2), 3)</code> denotes a static function call with two arguments, the first of which is a sequence of two values. <span>The corresponding function declaration must define at least two parameters, and may define more, provided they are optional.</span></p></li><li><p><span style="display: none;" class="delete_version"><code>my:two-argument-function(1, ())</code> denotes a static function call with two arguments, the second of which is an empty sequence.</span><span style="display: none;" class="add_version"><code>my:two-argument-function(1, ())</code> denotes a static function call with two arguments, the second of which is the empty sequence.</span><span class="modify_version"><code>my:two-argument-function(1, ())</code> denotes a static function call with two arguments, the second of which is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p><code>my:one-argument-function((1, 2, 3))</code> denotes a static function call with one argument that is a sequence of three values. </p></li><li><p><span style="display: none;" class="delete_version"><code>my:one-argument-function(( ))</code> denotes a static function call with one argument that is an empty sequence.</span><span style="display: none;" class="add_version"><code>my:one-argument-function(( ))</code> denotes a static function call with one argument that is the empty sequence.</span><span class="modify_version"><code>my:one-argument-function(( ))</code> denotes a static function call with one argument that is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p><code>my:zero-argument-function( )</code> denotes a static function call with zero arguments.</p></li><li><p><code>lang(node := $n, language := 'de')</code> is a static function call with two keyword arguments. The corresponding function declaration defines two parameters, a required parameter <code>language</code> and an optional parameter <code>node</code>. This call supplies values for both parameters. It is equivalent to the call <code>fn:lang('de', $n)</code>. Note that the keyword arguments are in a different order from the parameter declarations. </p></li><li><p><code>sort(//employee, key := fn($e) { xs:decimal($e/salary) })</code> is a static function call with one positional argument and one keyword argument. The corresponding function declaration defines three parameters, a required parameter <code>$input</code>, an optional parameter <code>$collation</code>, and an optional parameter <code>$key</code> This call supplies values for the first and third parameters, leaving the second parameter (<code>$collation</code>) to take its default value. The default value of the <code>$collation</code> parameter is given as <code>fn:default-collation()</code>, so the value supplied to the function is the default collation from the dynamic context of the caller. It is equivalent to the call <code>fn:sort(//employee, fn:default-collation(), fn($e) { xs:decimal($e/salary) })</code>. </p></li></ul><p>An <code>EQName</code> in a <code>KeywordArgument</code> is expanded using the <a title="no-namespace rule" class="termref" href="#dt-no-namespace-rule">no-namespace rule</a>. The keywords used in a function call (after expansion) must be distinct [<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>].</p></div></div><div class="_diffs div3"><h4><a id="id-dynamic-function-invocation"></a>4.5.3 <a href="#id-dynamic-function-invocation" style="text-decoration: none">Dynamic Function Calls</a></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DynamicFunctionCall"></a><code><a href="#prod-xquery40-DynamicFunctionCall">DynamicFunctionCall</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-DynamicFunctionCall-PostfixExpr">PostfixExpr</a><a href="#doc-xquery40-DynamicFunctionCall-PositionalArgumentList">PositionalArgumentList</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DynamicFunctionCall-PostfixExpr"></a><code><a href="#prod-xquery40-PostfixExpr">PostfixExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-PrimaryExpr">PrimaryExpr</a> | <a href="#doc-xquery40-FilterExpr">FilterExpr</a> | <a href="#doc-xquery40-DynamicFunctionCall">DynamicFunctionCall</a> | <a href="#doc-xquery40-LookupExpr">LookupExpr</a> | <a href="#doc-xquery40-MethodCall">MethodCall</a> | <a href="#doc-xquery40-FilterExprAM">FilterExprAM</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DynamicFunctionCall-PositionalArgumentList"></a><code><a href="#prod-xquery40-PositionalArgumentList">PositionalArgumentList</a></code></td><td>::=</td><td><code>"(" <a href="#doc-xquery40-DynamicFunctionCall-PositionalArguments">PositionalArguments</a>? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DynamicFunctionCall-PositionalArguments"></a><code><a href="#prod-xquery40-PositionalArguments">PositionalArguments</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-DynamicFunctionCall-Argument">Argument</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DynamicFunctionCall-Argument"></a><code><a href="#prod-xquery40-Argument">Argument</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-DynamicFunctionCall-ExprSingle">ExprSingle</a> | <a href="#doc-xquery40-DynamicFunctionCall-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DynamicFunctionCall-ExprSingle"></a><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-FLWORExpr">FLWORExpr</a><br>| <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xquery40-SwitchExpr">SwitchExpr</a><br>| <a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#doc-xquery40-IfExpr">IfExpr</a><br>| <a href="#doc-xquery40-TryCatchExpr">TryCatchExpr</a><br>| <a href="#doc-xquery40-OrExpr">OrExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-DynamicFunctionCall-ArgumentPlaceholder"></a><code><a href="#prod-xquery40-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td><td>::=</td><td><code>"?"</code></td></tr></tbody></table><p> A <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a> consists of a base expression that returns the function and a parenthesized list of zero or more arguments (<a title="argument expression" class="termref" href="#dt-arg-expr">argument expressions</a> or ArgumentPlaceholders). </p><p> A dynamic function call is evaluated as described in <a href="#id-eval-dynamic-function-call"><b>4.5.3.1 Evaluating Dynamic Function Calls</b></a>. </p><p>The following are examples of dynamic function calls:</p><ul><li><p>This example calls the function contained in <code>$f</code>, passing the arguments 2 and 3: </p><div class="exampleInner"><pre xml:space="preserve">$f(2, 3)</pre></div></li><li><p>This example fetches the second item from sequence <code>$f</code>, treats it as a function and calls it, passing an <code>xs:string</code> argument: </p><div class="exampleInner"><pre xml:space="preserve">$f[2]("Hi there")</pre></div></li><li><p>This example calls the function <code>$f</code> passing no arguments, and filters the result with a positional predicate: </p><div class="exampleInner"><pre xml:space="preserve">$f()[2]</pre></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>Arguments in a dynamic function call are always supplied positionally.</p></div><div class="_diffs div4"><h5><a id="id-eval-dynamic-function-call"></a>4.5.3.1 <a href="#id-eval-dynamic-function-call" style="text-decoration: none">Evaluating Dynamic Function Calls</a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-inline-func">next</a> | <a href="#id-function-calls">previous</a>)</p><ol><li><p><span style="display: none;" class="delete_version">A dynamic function call can now be applied to a sequence of functions, and in particular to an empty sequence. This makes it easier to chain a sequence of calls.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1240">1240</a>&nbsp;]</i></span><span style="display: none;" class="add_version">A dynamic function call can now be applied to a sequence of functions, and in particular to the empty sequence. This makes it easier to chain a sequence of calls.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1240">1240</a>&nbsp;]</i></span><span class="modify_version">A dynamic function call can now be applied to a sequence of functions, and in particular to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. This makes it easier to chain a sequence of calls.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1240">1240</a>&nbsp;]</i></span></p></li></ol></div><p>This section applies to dynamic function calls whose arguments do not include an <code>ArgumentPlaceholder</code>. For function calls that include a placeholder, see <a href="#id-partial-function-application"><b>4.5.4 Partial Function Application</b></a>.</p><p>A <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a> is an expression that is evaluated by calling a <a title="function item" class="termref" href="#dt-function-item">function item</a>, which is typically obtained dynamically.</p><p> When a dynamic function call <var>FC</var> is evaluated, the result is obtained as follows: </p><ol class="enumar"><li><p> The base expression of the function call is evaluated. If this is not of type <code>function(*)*</code> (a sequence of zero or more function items) then a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. </p></li><li><p>The result of the dynamic function call is the <a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation">sequence concatenation</a> of the results of applying each function item individually, retaining order. That is, the result of <code><var>F</var>(<var>X</var>, <var>Y</var>, ...)</code> is <code>for $FI in <var>F</var> return <var>$FI</var>(<var>X</var>, <var>Y</var>, ...)</code>. The result of a dynamic function call applied to a single function item <var>FI</var> is defined by the rules that follow. </p></li><li><p> [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. If the arity of <var>FI</var> does not match the number of arguments in the <code>ArgumentList</code>, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. </p></li><li><p><a title="argument expression" class="termref" href="#dt-arg-expr">Argument expressions</a> are evaluated, producing <b>argument values</b>. The order of argument evaluation is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> and an argument need not be evaluated if the function body can be evaluated without evaluating that argument.</p></li><li><p> Each argument value is converted to the corresponding parameter type in <var>FI</var>’s signature by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>, resulting in a <b>converted argument value</b></p></li><li><p>If <var>FI</var> is a map, it is evaluated as described in <a href="#id-map-lookup"><b>4.14.1.2 Maps as Functions</b></a>.</p></li><li><p>If <var>FI</var> is an array, it is evaluated as described in <a href="#id-array-lookup"><b>4.14.2.2 Arrays as Functions</b></a>.</p></li><li><p> If <var>FI</var>’s <span>body</span> is an XQuery 4.0 expression (for example, if <var>FI</var> is <span class="xquery">a <a title="user-defined function" class="termref" href="#dt-udf">user-defined function</a> or</span> an <a title="anonymous function" class="termref" href="#dt-anonymous-function">anonymous function</a>, or a <a title="partially applied function" class="termref" href="#dt-partially-applied-function">partial application</a> of such a function): </p><ol class="enumla"><li><p><var>FI</var>’s <span>body</span> is evaluated. The static context for this evaluation is the static context of the XQuery 4.0 expression. The dynamic context for this evaluation is obtained by taking the dynamic context of the <span class="xquery">module</span> that contains the <code>FunctionBody</code>, and making the following changes: </p><ul><li><p> The <a title="focus" class="termref" href="#dt-focus">focus</a> (context value, context position, and context size) is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM</small></sup>. </p></li><li><p> In the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a> component of the dynamic context, each converted argument value is bound to the corresponding parameter name. </p><p><span>When this is done, the converted argument values retain their <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic types</a>, even where these are <a title="subtype" class="termref" href="#dt-subtype">subtypes</a> of the declared parameter types.</span> For example, a function with a parameter <code>$p</code> of type <code>xs:decimal</code> can be called with an argument of type <code>xs:integer</code>, which is derived from <code>xs:decimal</code>. During the processing of this function call, the value of <code>$p</code> inside the body of the function retains its <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> of <code>xs:integer</code>. </p></li><li><p><var>FI</var>’s nonlocal variable bindings are also added to the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a>. (Note that the names of the nonlocal variables are by definition disjoint from the parameter names, so there can be no conflict.) </p></li></ul></li><li><p> The value returned by evaluating the function body is then converted to the declared return type of <var>FI</var> by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. The result is then the result of evaluating <var>FC</var>. </p><p> As with argument values, the value returned by a function retains its <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a>, which may be a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of the declared return type of <var>FI</var>. For example, a function that has a declared return type of <code>xs:decimal</code> may in fact return a value of dynamic type <code>xs:integer</code>. </p></li></ol></li><li><p> If the implementation of <var>FI</var> is not an XQuery 4.0 expression (for example, if <var>FI</var> is a <a title="system function" class="termref" href="#dt-system-function">system function</a><span class="xquery">or an <a title="external function" class="termref" href="#dt-external-function">external function</a></span>), the <span>body</span> of the function is evaluated, and the result is converted to the declared return type, in the same way as for a static function call (see <a href="#id-function-calls"><b>4.5.1.1 Static Function Call Syntax</b></a>).</p><p>Errors may be raised in the same way.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e20639"></a><a id="d2e20679"></a>Example: Derived Types and Nonlocal Variable Bindings</div><p><code>$incr</code> is a nonlocal variable that is available within the function because its variable binding has been added to the variable values of the function. Even though the parameter and return type of this function are both <code>xs:decimal</code>, the more specific type <code>xs:integer</code> is preserved in both cases.</p><div class="exampleInner"><pre xml:space="preserve">let $incr := 1
let $f := function($i as xs:decimal) as xs:decimal { $i + $incr }
return $f(5)</pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d2e20654"></a><a id="d2e20694"></a>Example: Using the Context Value in an Anonymous Function</div><p>The following example will raise a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a href="#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>]:</p><div class="exampleInner"><pre xml:space="preserve">let $vat := function() { @vat + @price }
return doc('wares.xml')/shop/article/$vat()</pre></div><p>Instead, the context value can be used as an argument to the anonymous function:</p><div class="exampleInner"><pre xml:space="preserve">let $vat := function($art) { $art/@vat + $art/@price }
return doc('wares.xml')/shop/article/$vat(.)</pre></div><p>Alternatively, the value can be referenced as a nonlocal variable binding:</p><div class="exampleInner"><pre xml:space="preserve">let $ctx := doc('wares.xml')/shop/article
let $vat := function() { for $a in $ctx return $a/@vat + $a/@price }
return $vat()</pre></div><p>Finally, a <a title="focus function" class="termref" href="#dt-focus-function">focus function</a> can be used. This binds the value of the argument to the context value within the function body:</p><div class="exampleInner"><pre xml:space="preserve">let $vat := function { @vat + @price }
return $vat(doc('wares.xml')/shop/article)</pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d2e20676"></a><a id="d2e20716"></a>Example: Applying multiple functions</div><p>A dynamic function call can call zero or more functions with the same arguments, returning the <a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation">sequence concatenation</a> of the result. For example:</p><div class="exampleInner"><pre xml:space="preserve">(abs#1, round#1, floor#1, ceiling#1)(3.2)</pre></div><p>returns the sequence <code>(3.2, 3, 3, 4)</code>.</p><p>A common case for supplying a sequence of functions arises when the functions are arrays. For example:</p><div class="exampleInner"><pre xml:space="preserve">csv-to-arrays( string-join(("a,b,c", "p,q,r", "x,y,z"), char(10)) ) (2)</pre></div><p>returns the sequence <code>("b", "q", "y")</code>.</p><p>If the base expression evaluates to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Keyword arguments are not allowed in a dynamic function call.</p></div></div></div></div><div class="_diffs div2"><h3><a id="id-path-expressions"></a>4.6 <a href="#id-path-expressions" style="text-decoration: none">Path Expressions</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#axes">next</a> | <a href="#id-inline-func">previous</a>)</p><ol><li><p> Path expressions are extended to handle JNodes (found in trees of maps and arrays) as well as XNodes (found in trees representing parsed XML). <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2054">2054</a>&nbsp;]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PathExpr"></a><code><a href="#prod-xquery40-PathExpr">PathExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-PathExpr-AbsolutePathExpr">AbsolutePathExpr</a><br>| <a href="#doc-xquery40-PathExpr-RelativePathExpr">RelativePathExpr</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-leading-lone-slash">xgc: leading-lone-slash</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PathExpr-AbsolutePathExpr"></a><code><a href="#prod-xquery40-AbsolutePathExpr">AbsolutePathExpr</a></code></td><td>::=</td><td><code>("/" <a href="#doc-xquery40-PathExpr-RelativePathExpr">RelativePathExpr</a>?) | ("//" <a href="#doc-xquery40-PathExpr-RelativePathExpr">RelativePathExpr</a>)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-PathExpr-RelativePathExpr"></a><code><a href="#prod-xquery40-RelativePathExpr">RelativePathExpr</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-StepExpr">StepExpr</a> (("/" | "//") <a href="#prod-xquery40-StepExpr">StepExpr</a>)*</code></td></tr></tbody></table><p> [<a id="dt-path-expression" title="path expression">Definition</a>: A <b>path expression</b> is either an <a title="absolute path expression" class="termref" href="#dt-absolute-path-expression">absolute path expression</a> or a <a title="relative path expression" class="termref" href="#dt-relative-path-expression">relative path expression</a> ] </p><p> [<a id="dt-absolute-path-expression" title="absolute path expression">Definition</a>: An <b>absolute path expression</b> is an instance of the production <a href="#prod-xquery40-AbsolutePathExpr">AbsolutePathExpr</a>: it consists of either (a) the operator <code>/</code> followed by zero or more operands separated by <code>/</code> or <code>//</code> operators, or (b) the operator <code>//</code> followed by one or more operands separated by <code>/</code> or <code>//</code> operators.] </p><p> [<a id="dt-relative-path-expression" title="relative path expression">Definition</a>: A <b>relative path expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production <a href="#doc-xquery40-RelativePathExpr">RelativePathExpr</a>: it consists of two or more operand expressions separated by <code>/</code> or <code>//</code> operators.] </p><p> [<a id="dt-step" title="step">Definition</a>: The operands of a path expression are conventionally referred to as <b>steps</b>.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The term <b>step</b> must not be confused with <a title="axis step" class="termref" href="#dt-axis-step">axis step</a>. A <b>step</b> can be any kind of expression, often but not necessarily an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a>, while an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a> can be used in any expression context, not necessarily as a <a title="step" class="termref" href="#dt-step">step</a> in a path expression.</p></div><p>A path expression is typically used to locate <a title="GNode" class="termref" href="#dt-GNode">GNodes</a> within <a title="GTree" class="termref" href="#dt-GTree">GTrees</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Note the terminology:</p><ul><li><p>A <a title="GNode" class="termref" href="#dt-GNode">GNode</a> is a generalized node, either an <a title="XNode" class="termref" href="#dt-XNode">XNode</a> or a <a title="JNode" class="termref" href="#dt-JNode">JNode</a>.</p></li><li><p>A <a title="GTree" class="termref" href="#dt-GTree">GTree</a> is a generalized tree, either an <a title="XTree" class="termref" href="#dt-XTree">XTree</a> or a <a title="JTree" class="termref" href="#dt-JTree">JTree</a>.</p></li></ul></div><p>The following definitions are copied from the data model specification, for convenience:</p><ul><li><p> [<a id="dt-JTree" title="JTree">Definition</a>: A tree that is rooted at a parentless <a title="JNode" class="termref" href="#dt-JNode">JNode</a> is referred to as a <b>JTree</b>.] </p></li><li><p> [<a id="dt-XTree" title="XTree">Definition</a>: A tree that is rooted at a parentless <a title="XNode" class="termref" href="#dt-XNode">XNode</a> is referred to as an <b>XTree</b>.] </p></li><li><p><span class="deltaxml-old" style="background:#FF5555"> [</span><a id="dt-GNode" title="GNode"><span class="deltaxml-old" style="background:#FF5555">Definition</span></a><span class="deltaxml-old" style="background:#FF5555">: The term </span><b><span class="deltaxml-old" style="background:#FF5555">generic node</span></b><span class="deltaxml-old" style="background:#FF5555"> or </span><b><span class="deltaxml-old" style="background:#FF5555">GNode</span></b><span class="deltaxml-old" style="background:#FF5555"> is a collective term for </span><a class="termref" title="XNode" href="#dt-XNode"><span class="deltaxml-old" style="background:#FF5555">XNodes</span></a><span class="deltaxml-old" style="background:#FF5555"> (more commonly called simply </span><a title="node" class="termref" href="#dt-node"><span class="deltaxml-old" style="background:#FF5555">nodes</span></a><span class="deltaxml-old" style="background:#FF5555">) representing the parts of an XML document, and </span><a title="JNode" class="termref" href="#dt-JNode"><span class="deltaxml-old" style="background:#FF5555">JNodes</span></a><span class="deltaxml-old" style="background:#FF5555">, often used to represent the parts of a JSON document.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-GTree" title="GTree"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The term </span><b><span class="deltaxml-new" style="background:#90EE90">GTree</span></b><span class="deltaxml-new" style="background:#90EE90"> means </span><a title="JTree" class="termref" href="#dt-JTree"><span class="deltaxml-new" style="background:#90EE90">JTree</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a class="termref" title="XTree" href="#dt-XTree"><span class="deltaxml-new" style="background:#90EE90">XTree</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p></li><li class="delete_version" style="display: none;"><p> [<a id="dt-JNode" title="JNode">Definition</a>: A <b>JNode</b> is a kind of <a title="item" class="termref" href="#dt-item">item</a> used to represent a value within the context of a tree of <a title="map" class="termref" href="#dt-map">maps</a> and <a title="array" class="termref" href="#dt-array">arrays</a>. A root <b>JNode</b> represents a map or array; a non-root <b>JNode</b> represents a <a title="member" class="termref" href="#dt-member">member</a> of an array or an <a title="entry" class="termref" href="#dt-entry">entry</a> in a map.] </p></li><li class="modify_version"><p><span class="deltaxml-old" style="background:#FF5555"> [</span><a id="dt-JNode" title="JNode"><span class="deltaxml-old" style="background:#FF5555">Definition</span></a><span class="deltaxml-old" style="background:#FF5555">: A </span><b><span class="deltaxml-old" style="background:#FF5555">JNode</span></b><span class="deltaxml-old" style="background:#FF5555"> is a kind of </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-old" style="background:#FF5555">item</span></a><span class="deltaxml-old" style="background:#FF5555"> used to represent a value within the context of a tree of </span><a title="map" class="termref" href="#dt-map"><span class="deltaxml-old" style="background:#FF5555">maps</span></a><span class="deltaxml-old" style="background:#FF5555"> and </span><a title="array" class="termref" href="#dt-array"><span class="deltaxml-old" style="background:#FF5555">arrays</span></a><span class="deltaxml-old" style="background:#FF5555">. A root </span><b><span class="deltaxml-old" style="background:#FF5555">JNode</span></b><span class="deltaxml-old" style="background:#FF5555"> represents a map or array; a non-root </span><b><span class="deltaxml-old" style="background:#FF5555">JNode</span></b><span class="deltaxml-old" style="background:#FF5555"> represents a </span><a title="member" class="termref" href="#dt-member"><span class="deltaxml-old" style="background:#FF5555">member</span></a><span class="deltaxml-old" style="background:#FF5555"> of an array or an </span><a title="entry" class="termref" href="#dt-entry"><span class="deltaxml-old" style="background:#FF5555">entry</span></a><span class="deltaxml-old" style="background:#FF5555"> in a map.] </span></p></li></ul><p><span class="deltaxml-old" style="background:#FF5555"> [</span><a id="dt-GTree" title="GTree"><span class="deltaxml-old" style="background:#FF5555">Definition</span></a><span class="deltaxml-old" style="background:#FF5555">: The term </span><b><span class="deltaxml-old" style="background:#FF5555">GTree</span></b><span class="deltaxml-old" style="background:#FF5555"> means </span><a title="JTree" class="termref" href="#dt-JTree"><span class="deltaxml-old" style="background:#FF5555">JTree</span></a><span class="deltaxml-old" style="background:#FF5555"> or </span><a title="XTree" class="termref" href="#dt-XTree"><span class="deltaxml-old" style="background:#FF5555">XTree</span></a><span class="deltaxml-old" style="background:#FF5555">.] </span></p><p><a title="absolute path expression" class="termref" href="#dt-absolute-path-expression">Absolute path expressions</a> (those starting with an initial <code>/</code> or <code>//</code>), start their selection from the root GNode of a GTree; relative path expressions (those without a leading <code>/</code> or <code>//</code>) start from the <a title="context value" class="termref" href="#dt-context-value">context value</a>.</p><div class="_diffs div3"><h4><a id="id-axis-steps"></a>4.6.5 <a href="#id-axis-steps" style="text-decoration: none">Axis Steps</a></h4><a id="d2e22833"></a><a id="d2e22831"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AxisStep"></a><code><a href="#prod-xquery40-AxisStep">AxisStep</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-AxisStep-AbbreviatedStep">AbbreviatedStep</a> | <a href="#doc-xquery40-AxisStep-FullStep">FullStep</a>) <a href="#doc-xquery40-AxisStep-Predicate">Predicate</a>*</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AxisStep-AbbreviatedStep"></a><code><a href="#prod-xquery40-AbbreviatedStep">AbbreviatedStep</a></code></td><td>::=</td><td><code>".." | ("@" <a href="#doc-xquery40-AxisStep-NodeTest">NodeTest</a>) | <a href="#prod-xquery40-SimpleNodeTest">SimpleNodeTest</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AxisStep-FullStep"></a><code><a href="#prod-xquery40-FullStep">FullStep</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-AxisStep-Axis">Axis</a><a href="#doc-xquery40-AxisStep-NodeTest">NodeTest</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AxisStep-Axis"></a><code><a href="#prod-xquery40-Axis">Axis</a></code></td><td>::=</td><td><code>("ancestor" | "ancestor-or-self" | "attribute" | "child" | "descendant" | "descendant-or-self" | "following" | "following-or-self" | "following-sibling" | "following-sibling-or-self" | "parent" | "preceding" | "preceding-or-self" | "preceding-sibling" | "preceding-sibling-or-self" | "self") "::"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AxisStep-NodeTest"></a><code><a href="#prod-xquery40-NodeTest">NodeTest</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-UnionNodeTest">UnionNodeTest</a> | <a href="#prod-xquery40-SimpleNodeTest">SimpleNodeTest</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AxisStep-Predicate"></a><code><a href="#prod-xquery40-Predicate">Predicate</a></code></td><td>::=</td><td><code>"[" <a href="#doc-xquery40-Expr">Expr</a> "]"</code></td></tr></tbody></table><p> [<a id="dt-axis-step" title="axis step">Definition</a>: An <b>axis step</b> is an instance of the production <a href="#doc-xquery40-AxisStep">AxisStep</a>: it is an expression that returns a sequence of GNodes that are reachable from a starting GNode via a specified axis. An axis step has three parts: an <b>axis</b>, which defines the direction of movement for the step, a <a title="node test" class="termref" href="#dt-node-test">node test</a>, which selects GNodes based on their properties, and zero or more predicates which are used to filter the results.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>An <a title="axis step" class="termref" href="#dt-axis-step">axis step</a> is an expression in its own right. While axis steps are often used as the operands of <a title="path expression" class="termref" href="#dt-path-expression">path expressions</a>, they can also appear in other contexts (without a <code>/</code> or <code>//</code> operator); equally, the operands of a path expression can be any expression, not restricted to an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a>.</p></div><p>If the context value for an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a> includes a map or array, this is implicitly converted to a JNode as if by applying the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-jtree"><code>fn:jtree</code></a> function. If, after this conversion, the sequence contains a value that is not a GNode, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0020" title="err:XPTY0020">err:XPTY0020</a>]. The result of evaluating the axis step is a sequence of zero or more GNodes.</p><p>The <a title="axis step" class="termref" href="#dt-axis-step">axis step</a><code>S</code> is equivalent to <code>./S</code>. Thus, if the context value is a sequence containing multiple GNodes, the semantics of a <a title="axis step" class="termref" href="#dt-axis-step">axis step</a> are equivalent to a <a title="path expression" class="termref" href="#dt-path-expression">path expression</a> in which the step is always applied to a single GNode. The following description therefore explains the semantics for the case where the context value is a single GNode, called the <b>origin</b>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The equivalence of a <a title="axis step" class="termref" href="#dt-axis-step">axis step</a><code>S</code> to the <a title="path expression" class="termref" href="#dt-path-expression">path expression</a><code>./S</code> means that the resulting GNode sequence is returned in <a title="document order" class="termref" href="#dt-document-order">document order</a>.</p></div><p>In the <b>abbreviated syntax</b> for a step, the axis can be omitted and other shorthand notations can be used as described in <a href="#abbrev"><b>4.6.8 Abbreviated Syntax</b></a>.</p><p>The unabbreviated syntax for an axis step consists of the axis name and node test separated by a double colon. The result of the step consists of the GNodes reachable from the origin via the specified axis that match the node test. For example, the step <code>child::para</code> selects the <code>para</code> element children of the origin XNode: <code>child</code> is the name of the axis, and <code>para</code> is the name of the element nodes to be selected on this axis. The available axes are described in <a href="#axes"><b>4.6.5.1 Axes</b></a>. The available node tests are described in <a href="#node-tests"><b>4.6.5.2 Node Tests</b></a>. Examples of steps are provided in <a href="#unabbrev"><b>4.6.7 Unabbreviated Syntax</b></a> and <a href="#abbrev"><b>4.6.8 Abbreviated Syntax</b></a>.</p><div class="_diffs div4"><h5><a id="axes"></a>4.6.5.1 <a href="#axes" style="text-decoration: none">Axes</a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#node-tests">next</a> | <a href="#id-path-expressions">previous</a>)</p><ol><li><p> Four new axes have been defined: <code>preceding-or-self</code>, <code>preceding-sibling-or-self</code>, <code>following-or-self</code>, and <code>following-sibling-or-self</code>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1519">1519</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1532">1532</a>&nbsp;29 October 2024]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-Axis"></a><code><a href="#prod-xquery40-Axis">Axis</a></code></td><td>::=</td><td><code>("ancestor" | "ancestor-or-self" | "attribute" | "child" | "descendant" | "descendant-or-self" | "following" | "following-or-self" | "following-sibling" | "following-sibling-or-self" | "parent" | "preceding" | "preceding-or-self" | "preceding-sibling" | "preceding-sibling-or-self" | "self") "::"</code></td></tr></tbody></table><p>An axis is essentially a function that takes a GNode (the origin) as input, and delivers a sequence of GNodes (always from within the same GTree as the origin) as its result.</p><p class="xquery">XQuery supports the following axes:</p><ul><li><p>The <code>child</code> axis contains the children of the origin.</p><p>If the origin is an XNode, these are the XNodes returned by the <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-children">7.6.3 children Accessor</a> accessor. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>In an XTree, only document nodes and element nodes have children. If the origin is any other kind of XNode, or if the origin is an empty document or element node, then the child axis returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. The children of a document node or element node may be element, processing instruction, comment, or text nodes. Attribute, namespace, and document nodes can never appear as children.</p></div><p>If the origin is a JNode, these are the JNodes returned by the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-j-children">j-children</a><sup><small>DM</small></sup> accessor.</p></li><li><p>The <code>descendant</code> axis is defined as the transitive closure of the child axis; it contains the descendants of the origin (the children, the children of the children, and so on).</p><p>More formally, <code>$node/descendant::gnode()</code> delivers the result of <code>fn:transitive-closure($node, fn { child::gnode() })</code>.</p></li><li><p>The <code>descendant-or-self</code> axis contains the origin and the descendants of the origin.</p><p>More formally, <code>$node/descendant-or-self::gnode()</code> delivers the result of <code>$node/(. | descendant::gnode())</code>.</p></li><li><p>The <code>parent</code> axis returns the parent of the origin.</p><p>If the origin is an XNode, this is the result of the <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-parent">7.6.11 parent Accessor</a> accessor.</p><p>If the origin is a JNode, this is the value of the <b>·parent·</b> property of the origin.</p><p>If the GNode has no parent, the axis returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An attribute node may have an element node as its parent, even though the attribute node is not a child of the element node.</p></div></li><li><p>The <code>ancestor</code> axis is defined as the transitive closure of the parent axis; it contains the ancestors of the origin (the parent, the parent of the parent, and so on).</p><p>More formally, <code>$node/ancestor::gnode()</code> delivers the result of <code>fn:transitive-closure($node, fn { parent::gnode() })</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The ancestor axis includes the root GNode of the GTree in which the origin is found, unless the origin is itself the root GNode.</p></div></li><li><p>The <code>ancestor-or-self</code> axis contains the origin and the ancestors of the origin; thus, the ancestor-or-self axis will always include the root.</p><p>More formally, <code>$node/ancestor-or-self::gnode()</code> delivers the result of <code>$node/(. | ancestor::gnode())</code>.</p></li><li><p>The <code>following-sibling</code> axis returns the origin’s following siblings, that is, those children of the origin’s parent that occur after the origin in <a title="document order" class="termref" href="#dt-document-order">document order</a>. If the origin is an attribute or namespace node, the <code>following-sibling</code> axis is empty.</p><p>More formally, <code>$node/following-sibling::gnode()</code> delivers the result of <code>fn:siblings($node)[. &gt;&gt; $node])</code>.</p></li><li><p>The <code>following-sibling-or-self</code> axis contains the origin, together with the contents of the <code>following-sibling</code> axis.</p><p>More formally, <code>$node/following-sibling-or-self::gnode()</code> delivers the result of <code>fn:siblings($node)[not(. &lt;&lt; $node)]</code></p></li><li><p>The <code>preceding-sibling</code> axis returns the origin’s preceding siblings, that is, those children of the origin’s parent that occur before the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a>. If the origin is an attribute or namespace node, the <code>preceding-sibling</code> axis is empty.</p><p>More formally, <code>$node/preceding-sibling::gnode()</code> delivers the result of <code>fn:siblings($node)[. &lt;&lt; $node]</code>.</p></li><li><p>The <code>preceding-sibling-or-self</code> axis contains the origin, together with the contents of the <code>preceding-sibling</code> axis.</p><p>More formally, <code>$node/preceding-sibling-or-self::gnode()</code> delivers the result of <code>fn:siblings($node)[not(. &gt;&gt; $node)</code>.</p></li><li><p>The <code>following</code> axis contains all descendants of the root of the GTree in which the origin is found, are not descendants of the origin, and occur after the origin in <a title="document order" class="termref" href="#dt-document-order">document order</a>. </p><p>More formally, <code>$node/following::gnode()</code> delivers the result of <code>$node/ancestor-or-self::gnode()/following-sibling::gnode()/descendant-or-self::gnode()</code></p></li><li><p>The <code>following-or-self</code> axis contains the origin, together with the contents of the <code>following</code> axis.</p><p>More formally, <code>$node/following-or-self::gnode()</code> delivers the result of <code>$node/(. | following::gnode())</code>.</p></li><li><p>The <code>preceding</code> axis returns all descendants of the root of the GTree in which the origin is found, are not ancestors of the origin, and occur before the origin in <a title="document order" class="termref" href="#dt-document-order">document order</a>. </p><p>More formally, <code>$node/preceding::gnode()</code> delivers the result of <code>$node/ancestor-or-self::gnode()/preceding-sibling::gnode()/descendant-or-self::gnode()</code>.</p></li><li><p>The <code>preceding-or-self</code> axis returns the origin, together with the contents of the <code>preceding</code> axis.</p><p>More formally, <code>$node/preceding-or-self::gnode()</code> delivers the result of <code>$node/(. | preceding::gnode())</code>.</p></li><li><p>The <code>attribute</code> axis is defined only for XNodes. It returns the attributes of the origin, which are the nodes returned by the <span><a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-attributes">7.6.1 attributes Accessor</a></span>; the axis will be empty unless the context node is an element.</p><p>If the <code>attribute</code> axis is applied to a JNode, a type error [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] is raised.</p></li><li><p>The <code>self</code> axis contains just the origin itself.</p><p>The <code>self</code> axis is primarily useful when testing whether the origin satisfies particular conditions, for example <code>if ($x[self::chapter])</code>.</p><p>More formally, <code>$node/self::gnode()</code> delivers the result of <code>$node</code>.</p></li></ul><p>Axes can be categorized as <b>forward axes</b> and <b>reverse axes</b>. An axis that only ever contains the origin or nodes that are after the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a> is a forward axis. An axis that only ever contains the context node or nodes that are before the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a> is a reverse axis.</p><p>The <code>parent</code>, <code>ancestor</code>, <code>ancestor-or-self</code>, <code>preceding</code>, <code>preceding-or-self</code>, <code>preceding-sibling</code>, and <code>preceding-sibling-or-self</code> axes are reverse axes; all other axes are forward axes.</p><p>The <code>ancestor</code>, <code>descendant</code>, <code>following</code>, <code>preceding</code> and <code>self</code> axes partition a GTree (ignoring attribute nodes): they do not overlap and together they contain all the GNodes in the GTree.</p><p> [<a id="dt-principal-node-kind" title="principal node kind">Definition</a>: Every axis has a <b>principal node kind</b>. If an axis can contain elements, then the principal node kind is element; otherwise, it is the kind of nodes that the axis can contain.] Thus:</p><ul><li><p>For the attribute axis, the principal node kind is attribute.</p></li><li><p>For all other axes, the principal node kind is element.</p></li></ul></div><div class="_diffs div4"><h5><a id="id-type-tests"></a>4.6.5.5 <a href="#id-type-tests" style="text-decoration: none">Type Tests</a></h5><p>A type test is a node test that selects JNodes or XNodes based on their type.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest"></a><code><a href="#prod-xquery40-TypeTest">TypeTest</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-TypeTest-NodeKindTest">NodeKindTest</a> | <a href="#doc-xquery40-TypeTest-JNodeType">JNodeType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-NodeKindTest"></a><code><a href="#prod-xquery40-NodeKindTest">NodeKindTest</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-TypeTest-DocumentTest">DocumentTest</a><br>| <a href="#doc-xquery40-TypeTest-ElementTest">ElementTest</a><br>| <a href="#doc-xquery40-TypeTest-AttributeTest">AttributeTest</a><br>| <a href="#doc-xquery40-TypeTest-SchemaElementTest">SchemaElementTest</a><br>| <a href="#doc-xquery40-TypeTest-SchemaAttributeTest">SchemaAttributeTest</a><br>| <a href="#doc-xquery40-TypeTest-PITest">PITest</a><br>| <a href="#doc-xquery40-TypeTest-CommentTest">CommentTest</a><br>| <a href="#doc-xquery40-TypeTest-TextTest">TextTest</a><br>| <a href="#doc-xquery40-TypeTest-NamespaceNodeTest">NamespaceNodeTest</a><br>| <a href="#doc-xquery40-TypeTest-AnyNodeKindTest">AnyNodeKindTest</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-DocumentTest"></a><code><a href="#prod-xquery40-DocumentTest">DocumentTest</a></code></td><td>::=</td><td><code>"document-node" "(" (<a href="#doc-xquery40-TypeTest-ElementTest">ElementTest</a> | <a href="#doc-xquery40-TypeTest-SchemaElementTest">SchemaElementTest</a> | <a href="#doc-xquery40-TypeTest-NameTestUnion">NameTestUnion</a>)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-ElementTest"></a><code><a href="#prod-xquery40-ElementTest">ElementTest</a></code></td><td>::=</td><td><code>"element" "(" (<a href="#doc-xquery40-TypeTest-NameTestUnion">NameTestUnion</a> ("," <a href="#prod-xquery40-TypeName">TypeName</a> "?"?)?)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-SchemaElementTest"></a><code><a href="#prod-xquery40-SchemaElementTest">SchemaElementTest</a></code></td><td>::=</td><td><code>"schema-element" "(" <a href="#prod-xquery40-ElementName">ElementName</a> ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-NameTestUnion"></a><code><a href="#prod-xquery40-NameTestUnion">NameTestUnion</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-TypeTest-NameTest">NameTest</a> ++ "|")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-NameTest"></a><code><a href="#prod-xquery40-NameTest">NameTest</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-TypeTest-EQName">EQName</a> | <a href="#doc-xquery40-TypeTest-Wildcard">Wildcard</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-EQName"></a><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-QName">QName</a> | <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-Wildcard"></a><code><a href="#prod-xquery40-Wildcard">Wildcard</a></code></td><td>::=</td><td><code>"*"<br>| (<a href="#prod-xquery40-NCName">NCName</a> ":*")<br>| ("*:" <a href="#prod-xquery40-NCName">NCName</a>)<br>| (<a href="#prod-xquery40-BracedURILiteral">BracedURILiteral</a> "*")</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-AttributeTest"></a><code><a href="#prod-xquery40-AttributeTest">AttributeTest</a></code></td><td>::=</td><td><code>"attribute" "(" (<a href="#doc-xquery40-TypeTest-NameTestUnion">NameTestUnion</a> ("," <a href="#prod-xquery40-TypeName">TypeName</a>)?)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-SchemaAttributeTest"></a><code><a href="#prod-xquery40-SchemaAttributeTest">SchemaAttributeTest</a></code></td><td>::=</td><td><code>"schema-attribute" "(" <a href="#prod-xquery40-AttributeName">AttributeName</a> ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-PITest"></a><code><a href="#prod-xquery40-PITest">PITest</a></code></td><td>::=</td><td><code>"processing-instruction" "(" (<a href="#prod-xquery40-NCName">NCName</a> | <a href="#doc-xquery40-TypeTest-StringLiteral">StringLiteral</a>)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-StringLiteral"></a><code><a href="#prod-xquery40-StringLiteral">StringLiteral</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-AposStringLiteral">AposStringLiteral</a> | <a href="#prod-xquery40-QuotStringLiteral">QuotStringLiteral</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-CommentTest"></a><code><a href="#prod-xquery40-CommentTest">CommentTest</a></code></td><td>::=</td><td><code>"comment" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-TextTest"></a><code><a href="#prod-xquery40-TextTest">TextTest</a></code></td><td>::=</td><td><code>"text" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-NamespaceNodeTest"></a><code><a href="#prod-xquery40-NamespaceNodeTest">NamespaceNodeTest</a></code></td><td>::=</td><td><code>"namespace-node" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-AnyNodeKindTest"></a><code><a href="#prod-xquery40-AnyNodeKindTest">AnyNodeKindTest</a></code></td><td>::=</td><td><code>"node" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TypeTest-JNodeType"></a><code><a href="#prod-xquery40-JNodeType">JNodeType</a></code></td><td>::=</td><td><code>"jnode" "(" (("*" | <a href="#prod-xquery40-NCName">NCName</a> | <a href="#doc-xquery40-Constant">Constant</a>) ("," ("*" | <a href="#doc-xquery40-SequenceType">SequenceType</a>))?)? ")"</code></td></tr></tbody></table><p>For example:</p><ul><li><p><code>element(N)</code> (short for <code>child::element(N)</code>) selects elements named <var>N</var>.</p></li><li><p><code>attribute(*, xs:integer)</code>selects attribute nodes whose type annotation is <code>xs:integer</code>.</p></li><li><p><code>text()</code> selects text nodes.</p></li><li><p><code>jnode("id")</code> selects JNodes having the <b>·selector·</b> property <code>"id"</code>.</p></li><li><p><code>jnode(*, map(*))</code> selects JNodes whose <b>·content·</b> property is an instance of the type <code>map(*)</code>.</p></li></ul><p>The syntax and semantics of <a href="#prod-xquery40-NodeKindTest">NodeKindTest</a> and <a href="#doc-xquery40-JNodeType">JNodeType</a> are described in <a href="#id-sequencetype-syntax"><b>3.1 Sequence Types</b></a> and <a href="#id-sequencetype-matching"><b>3.1.2 Sequence Type Matching</b></a>.</p><p>Shown below are further examples of type tests that might be used in path expressions selecting within an XTree:</p><ul><li><p><code>node()</code> matches any XNode.</p></li><li><p><code>text()</code> matches any text node.</p></li><li><p><code>comment()</code> matches any comment node.</p></li><li><p><code>namespace-node()</code> matches any namespace node.</p></li><li><p><code>element()</code> matches any element node.</p></li><li><p><code>schema-element(person)</code> matches any element node whose name is <code>person</code> (or is in the <a title="substitution group" class="termref" href="#dt-substitution-group">substitution group</a> headed by <code>person</code>), and whose type annotation is the same as (or is derived from) the declared type of the <code>person</code> element in the <a title="in-scope element declarations" class="termref" href="#dt-is-elems">in-scope element declarations</a>.</p></li><li><p><code>element(person)</code> matches any element node whose name is <code>person</code>, regardless of its type annotation.</p></li><li><p><code>element(doctor|nurse)</code> matches any element node whose name is <code>doctor</code> or <code>nurse</code>, regardless of its type annotation.</p></li><li><p><code>element(person, surgeon)</code> matches any non-nilled element node whose name is <code>person</code>, and whose type annotation is <code>surgeon</code> or is derived from <code>surgeon</code>.</p></li><li><p><code>element(doctor|nurse, medical-staff)</code> matches any non-nilled element node whose name is <code>doctor</code> or <code>nurse</code>, and whose type annotation is <code>medical-staff</code> or is derived from <code>medical-staff</code>.</p></li><li><p><code>element(*, surgeon)</code> matches any non-nilled element node whose type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</p></li><li><p><code>attribute()</code> matches any attribute node.</p></li><li><p><code>attribute(price)</code> matches any attribute whose name is <code>price</code>, regardless of its type annotation.</p></li><li><p><code>attribute(*, xs:decimal)</code> matches any attribute whose type annotation is <code>xs:decimal</code> (or is derived from <code>xs:decimal</code>), regardless of its name.</p></li><li><p><code>document-node()</code> matches any document node.</p></li><li><p><code>document-node(element(book))</code> matches any document node whose children consist of a single element node that satisfies the <a href="#doc-xquery40-ElementTest">ElementTest</a><code>element(book)</code>, interleaved with zero or more comments and processing instructions, and no text nodes.</p></li><li><p><code>document-node(book)</code> is an abbreviation for <code>document-node(element(book))</code>.</p></li></ul><p>The following examples show type type tests that might be used in path expressions selecting within a JTree:</p><ul><li><p><code>jnode(*, array(*))</code> matches any JNode whose <b>·content·</b> is an array.</p></li><li><p><code>jnode(*, record(longitude, latitude, *))</code> matches any JNode whose <b>·content·</b> is a map having entries with keys <code>"longitude"</code> and <code>"latitude"</code>.</p></li><li><p><span style="display: none;" class="delete_version"><code>jnode(*, empty-sequence())</code> matches any JNode whose <b>·content·</b> is an empty sequence.</span><span style="display: none;" class="add_version"><code>jnode(*, empty-sequence())</code> matches any JNode whose <b>·content·</b> is the empty sequence.</span><span class="modify_version"><code>jnode(*, empty-sequence())</code> matches any JNode whose <b>·content·</b> is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p><code>jnode(*, xs:date)</code> matches any JNode whose <b>·content·</b> is an instance of <code>xs:date</code>.</p></li></ul></div><div class="_diffs div4"><h5><a id="implausible-axis-steps"></a>4.6.5.6 <a href="#implausible-axis-steps" style="text-decoration: none">Implausible Axis Steps</a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-arithmetic">next</a> | <a href="#node-tests">previous</a>)</p><ol><li><p><span style="display: none;" class="delete_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return an empty sequence rather than an error. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/602">602</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/603">603</a>&nbsp;25 July 2023]</i></span><span style="display: none;" class="add_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return the empty sequence rather than an error. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/602">602</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/603">603</a>&nbsp;25 July 2023]</i></span><span class="modify_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence rather than an error. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/602">602</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/603">603</a>&nbsp;25 July 2023]</i></span></p></li></ol></div><p>Certain axis steps, given an inferred type for the context value, are classified as <a title="implausible" class="termref" href="#dt-implausible">implausible</a>. During the static analysis phase, a processor <span class="verb">may</span> (subject to the rules in <a href="#id-implausible-expressions"><b>2.5.6 Implausible Expressions</b></a>) report a static error when such axis steps are encountered: [<a href="#ERRXPTY0144" title="err:XPTY0144">err:XPTY0144</a>].</p><p>More specifically, an axis step is classified as <a title="implausible" class="termref" href="#dt-implausible">implausible</a> if any of the following conditions applies:</p><ol class="enumar"><li><p>The inferred item type of the context value is a node kind for which the specified axis is always empty: for example, the inferred item type of the context value is <code>attribute()</code> and the axis is <code>child</code>.</p></li><li><p>The node test exclusively selects node kinds that cannot appear on the specified axis: for example, the axis is <code>child</code> and the node test is <code>document-node()</code>.</p></li><li><p>In a schema-aware environment, when using the <code>child</code>, <code>descendant</code>, <code>descendant-or-self</code>, or <code>attribute</code> axes, the inferred item type of the context value has a content type that does not allow any node matching the node test to be present on the relevant axis. For example, if the inferred item type of the context value is <code>schema-element(list)</code> and the relevant element declaration (taking into account substitution group membership and wildcards) only allows <code>item</code> children, the axis step <code>child::li</code> will never select anything and is therefore classified as <a title="implausible" class="termref" href="#dt-implausible">implausible</a>.</p></li></ol><p>Examples of implausible axis steps include the following:</p><ul><li><p><code>@code/text()</code>: attributes cannot have text node children.</p></li><li><p><code>/@code</code>: document nodes cannot have attributes.</p></li><li><p><code>ancestor::text()</code>: the ancestor axis never returns text nodes.</p></li><li><p><code>element(*)/child::map</code>: the child axis starting at an element node will never select a map.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>Processors may choose not to classify the expression <code>/..</code> as implausible, since XSLT 1.0 users were sometimes advised to use this construct as an explicit way of denoting the empty sequence.</p></div></div></div><div class="_diffs div3"><h4><a id="unabbrev"></a>4.6.7 <a href="#unabbrev" style="text-decoration: none">Unabbreviated Syntax</a></h4><p>This section provides a number of examples of path expressions in which the axis is explicitly specified in each <a title="step" class="termref" href="#dt-step">step</a>. The syntax used in these examples is called the <b>unabbreviated syntax</b>. In many common cases, it is possible to write path expressions more concisely using an <b>abbreviated syntax</b>, as explained in <a href="#abbrev"><b>4.6.8 Abbreviated Syntax</b></a>.</p><p>These examples assume that the context value is a single node, referred to as the context node.</p><ul><li><p><code>child::para</code> selects the <code>para</code> element children of the context node.</p></li><li><p><code>child::(para|bullet)</code> selects the <code>para</code> and <code>bullet</code> element children of the context node.</p></li><li><p><code>child::*</code> selects all element children of the context node.</p></li><li><p><code>child::text()</code> selects all text node children of the context node.</p></li><li><p><code>child::(text()|comment())</code> selects all text node and comment node children of the context node.</p></li><li><p><code>child::node()</code> selects all the children of the context node. Note that no attribute nodes are returned, because attributes are not children.</p></li><li><p><code>attribute::name</code> selects the <code>name</code> attribute of the context node.</p></li><li><p><code>attribute::*</code> selects all the attributes of the context node.</p></li><li><p><code>parent::node()</code> selects the parent of the context node. If the context node is an attribute node, this expression returns the element node (if any) to which the attribute node is attached.</p></li><li><p><code>descendant::para</code> selects the <code>para</code> element descendants of the context node.</p></li><li><p><code>ancestor::div</code> selects all <code>div</code> ancestors of the context node.</p></li><li><p><code>ancestor-or-self::div</code> selects the <code>div</code> ancestors of the context node and, if the context node is a <code>div</code> element, the context node as well.</p></li><li><p><code>descendant-or-self::para</code> selects the <code>para</code> element descendants of the context node and, if the context node is a <code>para</code> element, the context node as well.</p></li><li><p><span style="display: none;" class="delete_version"><code>self::para</code> selects the context node if it is a <code>para</code> element, and otherwise returns an empty sequence.</span><span style="display: none;" class="add_version"><code>self::para</code> selects the context node if it is a <code>para</code> element, and otherwise returns the empty sequence.</span><span class="modify_version"><code>self::para</code> selects the context node if it is a <code>para</code> element, and otherwise returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p><span style="display: none;" class="delete_version"><code>self::(chapter|appendix)</code> selects the context node if it is a <code>chapter</code> or <code>appendix</code> element, and otherwise returns an empty sequence.</span><span style="display: none;" class="add_version"><code>self::(chapter|appendix)</code> selects the context node if it is a <code>chapter</code> or <code>appendix</code> element, and otherwise returns the empty sequence.</span><span class="modify_version"><code>self::(chapter|appendix)</code> selects the context node if it is a <code>chapter</code> or <code>appendix</code> element, and otherwise returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p><code>child::chapter/descendant::para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node.</p></li><li><p><code>child::*/child::para</code> selects all <code>para</code> grandchildren of the context node.</p></li><li><p><code>/</code> selects the root of the tree that contains the context node, but raises a dynamic error if this root is not a document node.</p></li><li><p><code>/descendant::para</code> selects all the <code>para</code> elements in the same document as the context node.</p></li><li><p><code>/descendant::list/child::member</code> selects all the <code>member</code> elements that have a <code>list</code> parent and that are in the same document as the context node.</p></li><li><p><code>child::para[position() = 1]</code> selects the first <code>para</code> child of the context node.</p></li><li><p><code>child::para[position() = last()]</code> selects the last <code>para</code> child of the context node.</p></li><li><p><code>child::para[position() = last()-1]</code> selects the last but one <code>para</code> child of the context node.</p></li><li><p><code>child::para[position() &gt; 1]</code> selects all the <code>para</code> children of the context node other than the first <code>para</code> child of the context node.</p></li><li><p><code>following-sibling::chapter[position() = 1]</code> selects the next <code>chapter</code> sibling of the context node.</p></li><li><p><code>following-sibling::(chapter|appendix)[position() = 1]</code> selects the next sibling of the context node that is either a <code>chapter</code> or an <code>appendix</code>.</p></li><li><p><code>preceding-sibling::chapter[position() = 1]</code> selects the previous <code>chapter</code> sibling of the context node.</p></li><li><p><code>/descendant::figure[position() = 42]</code> selects the forty-second <code>figure</code> element in the document containing the context node.</p></li><li><p><code>/child::book/child::chapter[position() = 5]/child::section[position() = 2]</code> selects the second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node.</p></li><li><p><code>child::para[attribute::type eq "warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code>. </p></li><li><p><code>child::para[attribute::type eq 'warning'][position() = 5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code>. </p></li><li><p><code>child::para[position() = 5][attribute::type eq "warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code>. </p></li><li><p><code>child::chapter[child::title = 'Introduction']</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children whose <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> is equal to the string <code>Introduction</code>. </p></li><li><p><code>child::chapter[child::title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children.</p></li><li><p><code>child::*[self::chapter or self::appendix]</code> selects the <code>chapter</code> and <code>appendix</code> children of the context node.</p></li><li><p><code>child::*[self::(chapter|appendix)][position() = last()]</code> selects the last <code>chapter</code> or <code>appendix</code> child of the context node.</p></li></ul></div><div class="_diffs div3"><h4><a id="abbrev"></a>4.6.8 <a href="#abbrev" style="text-decoration: none">Abbreviated Syntax</a></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AbbreviatedStep"></a><code><a href="#prod-xquery40-AbbreviatedStep">AbbreviatedStep</a></code></td><td>::=</td><td><code>".." | ("@" <a href="#doc-xquery40-AbbreviatedStep-NodeTest">NodeTest</a>) | <a href="#doc-xquery40-AbbreviatedStep-SimpleNodeTest">SimpleNodeTest</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AbbreviatedStep-NodeTest"></a><code><a href="#prod-xquery40-NodeTest">NodeTest</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-UnionNodeTest">UnionNodeTest</a> | <a href="#doc-xquery40-AbbreviatedStep-SimpleNodeTest">SimpleNodeTest</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AbbreviatedStep-SimpleNodeTest"></a><code><a href="#prod-xquery40-SimpleNodeTest">SimpleNodeTest</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-AbbreviatedStep-TypeTest">TypeTest</a> | <a href="#doc-xquery40-AbbreviatedStep-Selector">Selector</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AbbreviatedStep-TypeTest"></a><code><a href="#prod-xquery40-TypeTest">TypeTest</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-NodeKindTest">NodeKindTest</a> | <a href="#doc-xquery40-JNodeType">JNodeType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AbbreviatedStep-Selector"></a><code><a href="#prod-xquery40-Selector">Selector</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-AbbreviatedStep-EQName">EQName</a> | <a href="#doc-xquery40-AbbreviatedStep-Wildcard">Wildcard</a> | ("get" "(" <a href="#doc-xquery40-AbbreviatedStep-ExprSingle">ExprSingle</a> ")")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AbbreviatedStep-EQName"></a><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-QName">QName</a> | <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AbbreviatedStep-Wildcard"></a><code><a href="#prod-xquery40-Wildcard">Wildcard</a></code></td><td>::=</td><td><code>"*"<br>| (<a href="#prod-xquery40-NCName">NCName</a> ":*")<br>| ("*:" <a href="#prod-xquery40-NCName">NCName</a>)<br>| (<a href="#prod-xquery40-BracedURILiteral">BracedURILiteral</a> "*")</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AbbreviatedStep-ExprSingle"></a><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-FLWORExpr">FLWORExpr</a><br>| <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xquery40-SwitchExpr">SwitchExpr</a><br>| <a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#doc-xquery40-IfExpr">IfExpr</a><br>| <a href="#doc-xquery40-TryCatchExpr">TryCatchExpr</a><br>| <a href="#doc-xquery40-OrExpr">OrExpr</a></code></td></tr></tbody></table><p>The abbreviated syntax for a step permits the following abbreviations:</p><ol class="enumar"><li><p>The attribute axis <code>attribute::</code> can be abbreviated by <code>@</code>. For example, the expression <code>para[@type = "warning"]</code> is short for <code>child::para[attribute::type = "warning"]</code> and so selects <code>para</code> children with a <code>type</code> attribute with value equal to <code>warning</code>.</p></li><li><p>If the axis name is omitted from an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a>, the default axis is <code>child</code>, with two exceptions: (1) if the <a href="#doc-xquery40-NodeTest">NodeTest</a> in an axis step contains an <a href="#doc-xquery40-AttributeTest">AttributeTest</a> or <a href="#doc-xquery40-SchemaAttributeTest">SchemaAttributeTest</a> then the default axis is <code>attribute</code>; (2) if the <a href="#doc-xquery40-NodeTest">NodeTest</a> in an axis step is a <a href="#prod-xquery40-NamespaceNodeTest">NamespaceNodeTest</a><span class="xquery">then a static error is raised [<a href="#ERRXQST0134" title="err:XQST0134">err:XQST0134</a>].</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p> The namespace axis is deprecated as of XPath 2.0, but is required in some languages that use XPath, including XSLT.</p></div><p> For example, the path expression <code>section/para</code> is an abbreviation for <code>child::section/child::para</code>, and the path expression <code>section/@id</code> is an abbreviation for <code>child::section/attribute::id</code>. Similarly, <code>section/attribute(id)</code> is an abbreviation for <code>child::section/attribute::attribute(id)</code>. Note that the latter expression contains both an axis specification and a <a title="node test" class="termref" href="#dt-node-test">node test</a>.</p><p>Similarly, within a JTree rooted at an array, the expression <code>get(1)/parts/get(2)/part-no</code> gets the first member of the top-level array (presumably a map), then the <code>"parts"</code> entry within this map (presumably an array), then the second member of this array (presumably a map), and finally the <code>part-no</code> entry within this map.</p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">The same selection could be made using the lookup expression <code>?1?parts?2?part-no</code>. The main difference is that path expressions offer more flexibility in being able to navigate around the containing JTree. Also, the lookup expression <code>$a?1</code> fails if the array index is out of bounds; the path expression <code>$a/get(1)</code> (or <code>$a/*[1]</code>) instead returns an empty sequence.</span><span style="display: none;" class="add_version">The same selection could be made using the lookup expression <code>?1?parts?2?part-no</code>. The main difference is that path expressions offer more flexibility in being able to navigate around the containing JTree. Also, the lookup expression <code>$a?1</code> fails if the array index is out of bounds; the path expression <code>$a/get(1)</code> (or <code>$a/*[1]</code>) instead returns the empty sequence.</span><span class="modify_version">The same selection could be made using the lookup expression <code>?1?parts?2?part-no</code>. The main difference is that path expressions offer more flexibility in being able to navigate around the containing JTree. Also, the lookup expression <code>$a?1</code> fails if the array index is out of bounds; the path expression <code>$a/get(1)</code> (or <code>$a/*[1]</code>) instead returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>An abbreviated axis step that omits the axis name must use a <a href="#prod-xquery40-SimpleNodeTest">SimpleNodeTest</a> rather than a <a href="#prod-xquery40-UnionNodeTest">UnionNodeTest</a>. This means that a construct such as <code>(ul|ol)</code> is treated as an abbreviation for <code>(child::ul|child::ol)</code> rather than <code>child::(ul|ol)</code>. Since the two constructs have exactly the same semantics, this is not actually a restriction.</p></div></li><li><p>A step consisting of <code>..</code> is short for <code>parent::gnode()</code>. For example (assuming the context item is an XNode), <code>../title</code> is short for <code>parent::gnode()/child::title</code> and so will select the <code>title</code> children of the parent of the context node.</p><p>Similarly, if <code>$dateOfBirth</code> is a JNode resulting from the expression <code>$map/get("date of birth")</code>, then <code>$dateOfBirth/../gender</code> will select the entry having key <code>"gender"</code> within <code>$map</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The expression <code>.</code>, known as a <b>context value reference</b>, is a <a title="primary expression" class="termref" href="#dt-primary-expression">primary expression</a>, and is described in <a href="#id-context-value-references"><b>4.2.3 Context Value References</b></a>.</p></div></li></ol><p>Here are some examples of path expressions that use the abbreviated syntax. These examples assume that the context value is a single XNode, referred to as the context node:</p><ul><li><p><code>para</code> selects the <code>para</code> element children of the context node.</p></li><li><p><code>*</code> selects all element children of the context node.</p></li><li><p><code>text()</code> selects all text node children of the context node.</p></li><li><p><code>@name</code> selects the <code>name</code> attribute of the context node.</p></li><li><p><code>@(id|name)</code> selects the <code>id</code> and <code>name</code> attributes of the context node.</p></li><li><p><code>@*</code> selects all the attributes of the context node.</p></li><li><p><code>para[1]</code> selects the first <code>para</code> child of the context node.</p></li><li><p><code>para[last()]</code> selects the last <code>para</code> child of the context node.</p></li><li><p><code>*/para</code> selects all <code>para</code> grandchildren of the context node.</p></li><li><p><code>/book/chapter[5]/section[2]</code> selects the second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node.</p></li><li><p><code>chapter//para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node.</p></li><li><p><code>//para</code> selects all the <code>para</code> descendants of the root document node and thus selects all <code>para</code> elements in the same document as the context node.</p></li><li><p><code>//@version</code> selects all the <code>version</code> attribute nodes that are in the same document as the context node.</p></li><li><p><code>//list/member</code> selects all the <code>member</code> elements in the same document as the context node that have a <code>list</code> parent.</p></li><li><p><code>.//para</code> selects the <code>para</code> element descendants of the context node.</p></li><li><p><code>..</code> selects the parent of the context node.</p></li><li><p><code>../@lang</code> selects the <code>lang</code> attribute of the parent of the context node.</p></li><li><p><code>para[@type = "warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code>. </p></li><li><p><code>para[@type = "warning"][5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code>. </p></li><li><p><code>para[5][@type = "warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code>. </p></li><li><p><code>chapter[title = "Introduction"]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children whose <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> is equal to the string <code>Introduction</code>. </p></li><li><p><code>chapter[title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children.</p></li><li><p><code>employee[@secretary and @assistant]</code> selects all the <code>employee</code> children of the context node that have both a <code>secretary</code> attribute and an <code>assistant</code> attribute.</p></li><li><p><code>book/(chapter|appendix)/section</code> selects every <code>section</code> element that has a parent that is either a <code>chapter</code> or an <code>appendix</code> element, that in turn is a child of a <code>book</code> element that is a child of the context node.</p></li><li><p>If <code>E</code> is any expression that returns a sequence of nodes, then the expression <code>E/.</code> returns the same nodes in <a title="document order" class="termref" href="#dt-document-order">document order</a>, with duplicates eliminated based on node identity.</p></li></ul><p>The following examples use abbreviated paths to access data within the JTree obtained by parsing the JSON text:</p><div class="exampleInner"><pre xml:space="preserve">[
  { "first": "John", 
    "last": "Baker", 
    "date of birth": "2003-04-19", 
    "occupation": "cook"}, 
  { "first": "Mary", 
    "last": "Smith", 
    "date of birth": "2006-08-12", 
    "occupation": "teacher"},                 
]</pre></div><ul><li><p><code>get(1)/first</code> returns a JNode whose <b>·content·</b> is the string <code>"John"</code>.</p></li><li><p><code>//first[. = "Mary"]/../last</code> returns a JNode whose <b>·content·</b> is the string <code>"Smith"</code>.</p></li><li><p><code>//first[. = "Mary"]/../get("date of birth")</code> returns a JNode whose <b>·content·</b> is the string <code>"2006-08-12"</code>.</p></li><li><p><code>//*[occupation = "cook"]!`{first} {last}`</code> returns the string <code>"John Baker"</code>.</p></li><li><p><code>//*[occupation = "cook"]/following-sibling::*[1]!`{first} {last}`</code> returns the string <code>"Mary Smith"</code>.</p></li><li><p><code>//*[last = "Smith"]/../get(1)/last</code> returns the string <code>"Baker"</code>.</p></li><li><p><code>//record(first, last, *) ! string(last)</code> returns the sequence of two strings <code>"Baker"</code>, <code>"Smith"</code>.</p></li></ul></div></div><div class="_diffs div2"><h3><a id="id-sequence-expressions"></a>4.7 <a href="#id-sequence-expressions" style="text-decoration: none">Sequence Expressions</a></h3><p>XQuery 4.0 supports operators to construct, filter, and combine <a title="sequence" class="termref" href="#dt-sequence">sequences</a> of <a title="item" class="termref" href="#dt-item">items</a>. Sequences are never nested—for example, combining the values <code>1</code>, <code>(2, 3)</code>, and <code>( )</code> into a single sequence results in the sequence <code>(1, 2, 3)</code>.</p><div class="_diffs div3"><h4><a id="construct_seq"></a>4.7.1 <a href="#construct_seq" style="text-decoration: none">Sequence Concatenation</a></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="x2-x2-doc-xquery40-Expr"></a><code>Expr</code></td><td>::=</td><td><code>(<a href="#x2-x2-doc-xquery40-Expr-ExprSingle">ExprSingle</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="x2-x2-doc-xquery40-Expr-ExprSingle"></a><code>ExprSingle</code></td><td>::=</td><td><code><a href="#doc-xquery40-FLWORExpr">FLWORExpr</a><br>| <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xquery40-SwitchExpr">SwitchExpr</a><br>| <a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#doc-xquery40-IfExpr">IfExpr</a><br>| <a href="#doc-xquery40-TryCatchExpr">TryCatchExpr</a><br>| <a href="#doc-xquery40-OrExpr">OrExpr</a></code></td></tr></tbody></table><p> [<a id="dt-sequence-expression" title="sequence expression">Definition</a>: A <b>sequence expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production rule <a href="#doc-xquery40-Expr">Expr</a>, that is, an expression containing two or more instances of the production <a href="#doc-xquery40-ExprSingle">ExprSingle</a> separated by the comma operator.] </p><p>The result of a <a title="sequence expression" class="termref" href="#dt-sequence-expression">sequence expression</a> is the <a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation">sequence concatenation</a> of the values of its operands. See <a href="#doc-xquery40-Expr"></a></p><p> [<a id="dt-comma-operator" title="comma operator">Definition</a>: A <b>comma operator</b> is a comma used specifically as the operator in a <a title="sequence expression" class="termref" href="#dt-sequence-expression">sequence expression</a>.] </p><p>Empty parentheses can be used to denote <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p><p>A sequence may contain duplicate <a title="item" class="termref" href="#dt-item">items</a>, but a sequence is never an item in another sequence. When a new sequence is created by concatenating two or more input sequences, the new sequence contains all the items of the input sequences and its length is the sum of the lengths of the input sequences.</p><p> [<a id="dt-sequence-concatenation" title="sequence concatenation">Definition</a>: The <b>sequence concatenation</b> of a number of sequences <var>S<sub>1</sub></var>, <var>S<sub>2</sub></var>, ... <var>S<sub>n</sub></var> is defined to be the sequence formed from the items of <var>S<sub>1</sub></var>, followed by the items from <var>S<sub>2</sub></var>, and so on, retaining order.] The <a title="comma operator" class="termref" href="#dt-comma-operator">comma operator</a> returns the sequence concatenation of its two operands; repeated application (for example <code>$s1, $s2, $s3, $s4</code>) delivers the sequence concatenation of multiple sequences.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In places where the grammar calls for <a href="#doc-xquery40-ExprSingle">ExprSingle</a>, such as the arguments of a function call, any expression that contains a top-level comma operator must be enclosed in parentheses.</p></div><p>Here are some examples of expressions that construct sequences: </p><ul><li><p>The result of this expression is a sequence of five integers:</p><div class="exampleInner"><pre xml:space="preserve">(10, 1, 2, 3, 4)</pre></div></li><li><p>This expression combines four sequences of length one, two, zero, and two, respectively, into a single sequence of length five. The result of this expression is the sequence <code>10, 1, 2, 3, 4</code>.</p><div class="exampleInner"><pre xml:space="preserve">(10, (1, 2), (), (3, 4))</pre></div></li><li><p>The result of this expression is a sequence containing all <code>salary</code> children of the context node followed by all <code>bonus</code> children.</p><div class="exampleInner"><pre xml:space="preserve">(salary, bonus)</pre></div></li><li><p>Assuming that <code>$price</code> is bound to the value <code>10.50</code>, the result of this expression is the sequence <code>10.50, 10.50</code>.</p><div class="exampleInner"><pre xml:space="preserve">($price, $price)</pre></div></li></ul></div><div class="_diffs div3"><h4><a id="id-range-expressions"></a>4.7.2 <a href="#id-range-expressions" style="text-decoration: none">Range Expressions</a></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RangeExpr"></a><code><a href="#prod-xquery40-RangeExpr">RangeExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-RangeExpr-AdditiveExpr">AdditiveExpr</a> ("to" <a href="#doc-xquery40-RangeExpr-AdditiveExpr">AdditiveExpr</a>)?</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RangeExpr-AdditiveExpr"></a><code><a href="#prod-xquery40-AdditiveExpr">AdditiveExpr</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-MultiplicativeExpr">MultiplicativeExpr</a> (("+" | "-") <a href="#prod-xquery40-MultiplicativeExpr">MultiplicativeExpr</a>)*</code></td></tr></tbody></table><p><span style="display: none;" class="delete_version"> [<a id="dt-range-expression" title="range expression">Definition</a>: A <b>range expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production <a href="#doc-xquery40-RangeExpr">RangeExpr</a>. A range expression is used to construct a sequence of integers.] Each of the operands is converted as though it was an argument of a function with the expected parameter type <code>xs:integer?</code>. If either operand is an empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is an empty sequence. If the two operands convert to the same integer, the result of the range expression is that integer. Otherwise, the result is a sequence containing the two integer operands and every integer between the two operands, in increasing order. </span><span style="display: none;" class="add_version"> [<a id="dt-range-expression" title="range expression">Definition</a>: A <b>range expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production <a href="#doc-xquery40-RangeExpr">RangeExpr</a>. A range expression is used to construct a sequence of integers.] Each of the operands is converted as though it was an argument of a function with the expected parameter type <code>xs:integer?</code>. If either operand is the empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is the empty sequence. If the two operands convert to the same integer, the result of the range expression is that integer. Otherwise, the result is a sequence containing the two integer operands and every integer between the two operands, in increasing order. </span><span class="modify_version"> [<a id="dt-range-expression" title="range expression">Definition</a>: A <b>range expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production <a href="#doc-xquery40-RangeExpr">RangeExpr</a>. A range expression is used to construct a sequence of integers.] Each of the operands is converted as though it was an argument of a function with the expected parameter type <code>xs:integer?</code>. If either operand is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. If the two operands convert to the same integer, the result of the range expression is that integer. Otherwise, the result is a sequence containing the two integer operands and every integer between the two operands, in increasing order. </span></p><p>The following examples illustrate the semantics:</p><ul><li><p><code>1 to 4</code> returns the sequence <code>1, 2, 3, 4</code></p></li><li><p><code>10 to 10</code> returns the <a title="singleton" class="termref" href="#dt-singleton">singleton</a> sequence <code>10</code></p></li><li><p><code>10 to 1</code> returns the empty sequence</p></li><li><p><code>-13 to -10</code> returns the sequence <code>-13, -12, -11, -10</code></p></li></ul><p>More formally, a <a title="range expression" class="termref" href="#dt-range-expression">range expression</a> is evaluated as follows:</p><ol class="enumar"><li><p>Each of the operands of the <code>to</code> operator is converted as though it was an argument of a function with the expected parameter type <code>xs:integer?</code>.</p></li><li><p>If either operand is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p></li><li><p>If the two operands convert to the same integer, the result of the range expression is that integer.</p></li><li><p>Otherwise, the result is a sequence containing the two integer operands and every integer between the two operands, in increasing order.</p></li></ol><p>The following examples illustrate the use of <a title="range expression" class="termref" href="#dt-range-expression">range expressions</a>.</p><div class="example"><p>This example uses a range expression as one operand in constructing a sequence. It evaluates to the sequence <code>10, 1, 2, 3, 4</code>.</p><div class="exampleInner"><pre xml:space="preserve">(10, 1 to 4)</pre></div><p>This example selects the first four items from an input sequence:</p><div class="exampleInner"><pre xml:space="preserve">$input[1 to 4]</pre></div><p>This example returns the sequence <code>(0, 0.1, 0.2, 0.3, 0.5)</code>:</p><div class="exampleInner"><pre xml:space="preserve">$x = (1 to 5) ! . * 0.1</pre></div><p>This example constructs a sequence of length one containing the single integer 10.</p><div class="exampleInner"><pre xml:space="preserve">10 to 10</pre></div><p>The result of this example is a sequence of length zero.</p><div class="exampleInner"><pre xml:space="preserve">15 to 10</pre></div><p>This example uses the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-reverse"><code>fn:reverse</code></a> function to construct a sequence of six integers in decreasing order. It evaluates to the sequence 15, 14, 13, 12, 11, 10.</p><div class="exampleInner"><pre xml:space="preserve">reverse(10 to 15)</pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>To construct a sequence of integers based on steps other than 1, use the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-slice"><code>fn:slice</code></a> function, as defined in <a href="https://www.w3.org/TR/xpath-functions-31/#general-seq-funcs"> 14.1 General functions and operators on sequences </a><sup><small>FO31</small></sup>.</p></div></div></div><div class="_diffs div2"><h3><a id="id-arithmetic"></a>4.8 <a href="#id-arithmetic" style="text-decoration: none">Arithmetic Expressions</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-string-templates">next</a> | <a href="#implausible-axis-steps">previous</a>)</p><ol><li><p> The symbols <code>×</code> and <code>÷</code> can be used for multiplication and division. </p></li></ol></div><p>XQuery 4.0 provides binary arithmetic operators for addition, subtraction, multiplication, division, and modulus:</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AdditiveExpr"></a><code><a href="#prod-xquery40-AdditiveExpr">AdditiveExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-AdditiveExpr-MultiplicativeExpr">MultiplicativeExpr</a> (("+" | "-") <a href="#doc-xquery40-AdditiveExpr-MultiplicativeExpr">MultiplicativeExpr</a>)*</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AdditiveExpr-MultiplicativeExpr"></a><code><a href="#prod-xquery40-MultiplicativeExpr">MultiplicativeExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-AdditiveExpr-UnionExpr">UnionExpr</a> (("*" | "×" | "div" | "÷" | "idiv" | "mod") <a href="#doc-xquery40-AdditiveExpr-UnionExpr">UnionExpr</a>)*</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-AdditiveExpr-UnionExpr"></a><code><a href="#prod-xquery40-UnionExpr">UnionExpr</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-IntersectExceptExpr">IntersectExceptExpr</a> (("union" | "|") <a href="#prod-xquery40-IntersectExceptExpr">IntersectExceptExpr</a>)*</code></td></tr></tbody></table><p>In addition, unary operators are provided for addition and subtraction:</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-UnaryExpr"></a><code><a href="#prod-xquery40-UnaryExpr">UnaryExpr</a></code></td><td>::=</td><td><code>("-" | "+")* <a href="#doc-xquery40-UnaryExpr-ValueExpr">ValueExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-UnaryExpr-ValueExpr"></a><code><a href="#prod-xquery40-ValueExpr">ValueExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-UnaryExpr-ValidateExpr">ValidateExpr</a> | <a href="#doc-xquery40-UnaryExpr-ExtensionExpr">ExtensionExpr</a> | <a href="#doc-xquery40-UnaryExpr-SimpleMapExpr">SimpleMapExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-UnaryExpr-ValidateExpr"></a><code><a href="#prod-xquery40-ValidateExpr">ValidateExpr</a></code></td><td>::=</td><td><code>"validate" (<a href="#prod-xquery40-ValidationMode">ValidationMode</a> | ("type" <a href="#prod-xquery40-TypeName">TypeName</a>))? "{" <a href="#doc-xquery40-Expr">Expr</a> "}"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-UnaryExpr-ExtensionExpr"></a><code><a href="#prod-xquery40-ExtensionExpr">ExtensionExpr</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-Pragma">Pragma</a>+ "{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-UnaryExpr-SimpleMapExpr"></a><code><a href="#prod-xquery40-SimpleMapExpr">SimpleMapExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-PathExpr">PathExpr</a> ("!" <a href="#doc-xquery40-PathExpr">PathExpr</a>)*</code></td></tr></tbody></table><p>A subtraction operator must be preceded by whitespace if it could otherwise be interpreted as part of the previous token. For example, <code>a-b</code> will be interpreted as a name, but <code>a - b</code> and <code>a -b</code> will be interpreted as arithmetic expressions. (See <a href="#whitespace-rules"><b>A.3.4 Whitespace Rules</b></a> for further details on whitespace handling.)</p><p>The arithmetic operator symbols <code>*</code> and <span class="unicode-codepoint">U+00D7</span> (<span class="unicode-name">MULTIPLICATION SIGN</span>, <code>×</code>) are interchangeable, and denote multiplication.</p><p>The arithmetic operator symbols <code>div</code> and <span class="unicode-codepoint">U+00F7</span> (<span class="unicode-name">DIVISION SIGN</span>, <code>÷</code>) are interchangeable, and denote division.</p><p> If an <code>AdditiveExpr</code> contains more than two <code>MultiplicativeExprs</code>, they are grouped from left to right. So, for instance, </p><div class="exampleInner"><pre xml:space="preserve">A - B + C - D</pre></div><p> is equivalent to </p><div class="exampleInner"><pre xml:space="preserve">((A - B) + C) - D</pre></div><p> Similarly, the operands of a <code>MultiplicativeExpr</code> are grouped from left to right. </p><p>The first step in evaluating an arithmetic expression is to evaluate its operand (for a unary operator) or operands (for a binary operator). The order in which the operands are evaluated is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><p><span class="xquery">Each</span> operand is evaluated by applying the following steps, in order:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the operand. The result of this operation is called the <b>atomized operand</b>.</p></li><li><p>If the atomized operand is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result of the arithmetic expression is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, and the implementation need not evaluate the other operand or apply the operator. However, an implementation may choose to evaluate the other operand in order to determine whether it raises an error.</p></li><li><p> If the atomized operand is a sequence of length greater than one, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>If the atomized operand is of type <code>xs:untypedAtomic</code>, it is cast to <code>xs:double</code>. If the cast fails, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised. [<a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>]<sup><small>FO40</small></sup></p></li></ol><p>If, after this process, both operands of a binary arithmetic operator are instances of <code>xs:numeric</code> but have different primitive types, they are coerced to a common type by applying the following rules:</p><ol class="enumar"><li><p>If either of the items is of type <code>xs:double</code>, then both the values are cast to type <code>xs:double</code>.</p></li><li><p>Otherwise, if either of the items is of type <code>xs:float</code>, then both the values are cast to type <code>xs:float</code>.</p></li><li><p>Otherwise, no casting takes place: the values remain as <code>xs:decimal</code>.</p></li></ol><p>After this preparation, the arithmetic expression is evaluated by applying the appropriate function listed in the table below. The definitions of these functions are found in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>.</p><table style="border:1px solid" class="small"><caption>Unary Arithmetic Operators</caption><thead><tr><th>Expression</th><th>Type of A</th><th>Function</th><th>Result type</th></tr></thead><tbody><tr><td>+ A</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-numeric-unary-plus"><code>op:numeric-unary-plus</code></a><code>(A)</code></td><td>xs:numeric</td></tr><tr><td>- A</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-numeric-unary-minus"><code>op:numeric-unary-minus</code></a><code>(A)</code></td><td>xs:numeric</td></tr></tbody></table><table style="border:1px solid" class="small"><caption>Binary Arithmetic Operators</caption><tbody><tr><th>Expression</th><th>Type of A</th><th>Type of B</th><th>Function</th><th>Result type</th></tr><tr><td>A + B</td><td>xs:numeric</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-numeric-add"><code>op:numeric-add</code></a><code>(A, B)</code></td><td>xs:numeric</td></tr><tr><td>A + B</td><td>xs:date</td><td>xs:yearMonthDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-yearMonthDuration-to-date"><code>op:add-yearMonthDuration-to-date</code></a><code>(A, B)</code></td><td>xs:date</td></tr><tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:date</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-yearMonthDuration-to-date"><code>op:add-yearMonthDuration-to-date</code></a><code>(B, A)</code></td><td>xs:date</td></tr><tr><td>A + B</td><td>xs:date</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-dayTimeDuration-to-date"><code>op:add-dayTimeDuration-to-date</code></a><code>(A, B)</code></td><td>xs:date</td></tr><tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:date</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-dayTimeDuration-to-date"><code>op:add-dayTimeDuration-to-date</code></a><code>(B, A)</code></td><td>xs:date</td></tr><tr><td>A + B</td><td>xs:time</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-dayTimeDuration-to-time"><code>op:add-dayTimeDuration-to-time</code></a><code>(A, B)</code></td><td>xs:time</td></tr><tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:time</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-dayTimeDuration-to-time"><code>op:add-dayTimeDuration-to-time</code></a><code>(B, A)</code></td><td>xs:time</td></tr><tr><td>A + B</td><td>xs:dateTime</td><td>xs:yearMonthDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-yearMonthDuration-to-dateTime"><code>op:add-yearMonthDuration-to-dateTime</code></a><code>(A, B)</code></td><td>xs:dateTime</td></tr><tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:dateTime</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-yearMonthDuration-to-dateTime"><code>op:add-yearMonthDuration-to-dateTime</code></a><code>(B, A)</code></td><td>xs:dateTime</td></tr><tr><td>A + B</td><td>xs:dateTime</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-dayTimeDuration-to-dateTime"><code>op:add-dayTimeDuration-to-dateTime</code></a><code>(A, B)</code></td><td>xs:dateTime</td></tr><tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:dateTime</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-dayTimeDuration-to-dateTime"><code>op:add-dayTimeDuration-to-dateTime</code></a><code>(B, A)</code></td><td>xs:dateTime</td></tr><tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-yearMonthDurations"><code>op:add-yearMonthDurations</code></a><code>(A, B)</code></td><td>xs:yearMonthDuration</td></tr><tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-dayTimeDurations"><code>op:add-dayTimeDurations</code></a><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr><tr><td>A - B</td><td>xs:numeric</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-numeric-subtract"><code>op:numeric-subtract</code></a><code>(A, B)</code></td><td>xs:numeric</td></tr><tr><td>A - B</td><td>xs:date</td><td>xs:date</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-dates"><code>op:subtract-dates</code></a><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr><tr><td>A - B</td><td>xs:date</td><td>xs:yearMonthDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-yearMonthDuration-from-date"><code>op:subtract-yearMonthDuration-from-date</code></a><code>(A, B)</code></td><td>xs:date</td></tr><tr><td>A - B</td><td>xs:date</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-dayTimeDuration-from-date"><code>op:subtract-dayTimeDuration-from-date</code></a><code>(A, B)</code></td><td>xs:date</td></tr><tr><td>A - B</td><td>xs:time</td><td>xs:time</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-times"><code>op:subtract-times</code></a><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr><tr><td>A - B</td><td>xs:time</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-dayTimeDuration-from-time"><code>op:subtract-dayTimeDuration-from-time</code></a><code>(A, B)</code></td><td>xs:time</td></tr><tr><td>A - B</td><td>xs:dateTime</td><td>xs:dateTime</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-dateTimes"><code>op:subtract-dateTimes</code></a><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr><tr><td>A - B</td><td>xs:dateTime</td><td>xs:yearMonthDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-yearMonthDuration-from-dateTime"><code>op:subtract-yearMonthDuration-from-dateTime</code></a><code>(A, B)</code></td><td>xs:dateTime</td></tr><tr><td>A - B</td><td>xs:dateTime</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-dayTimeDuration-from-dateTime"><code>op:subtract-dayTimeDuration-from-dateTime</code></a><code>(A, B)</code></td><td>xs:dateTime</td></tr><tr><td>A - B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-yearMonthDurations"><code>op:subtract-yearMonthDurations</code></a><code>(A, B)</code></td><td>xs:yearMonthDuration</td></tr><tr><td>A - B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-dayTimeDurations"><code>op:subtract-dayTimeDurations</code></a><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr><tr><td>A * B</td><td>xs:numeric</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-numeric-multiply"><code>op:numeric-multiply</code></a><code>(A, B)</code></td><td>xs:numeric</td></tr><tr><td>A * B</td><td>xs:yearMonthDuration</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-multiply-yearMonthDuration"><code>op:multiply-yearMonthDuration</code></a><code>(A, B)</code></td><td>xs:yearMonthDuration</td></tr><tr><td>A * B</td><td>xs:numeric</td><td>xs:yearMonthDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-multiply-yearMonthDuration"><code>op:multiply-yearMonthDuration</code></a><code>(B, A)</code></td><td>xs:yearMonthDuration</td></tr><tr><td>A * B</td><td>xs:dayTimeDuration</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-multiply-dayTimeDuration"><code>op:multiply-dayTimeDuration</code></a><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr><tr><td>A * B</td><td>xs:numeric</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-multiply-dayTimeDuration"><code>op:multiply-dayTimeDuration</code></a><code>(B, A)</code></td><td>xs:dayTimeDuration</td></tr><tr><td>A idiv B</td><td>xs:numeric</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-numeric-integer-divide"><code>op:numeric-integer-divide</code></a><code>(A, B)</code></td><td>xs:integer</td></tr><tr><td>A div B</td><td>xs:numeric</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-numeric-divide"><code>op:numeric-divide</code></a><code>(A, B)</code></td><td>numeric; but xs:decimal if both operands are xs:integer</td></tr><tr><td>A div B</td><td>xs:yearMonthDuration</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-divide-yearMonthDuration"><code>op:divide-yearMonthDuration</code></a><code>(A, B)</code></td><td>xs:yearMonthDuration</td></tr><tr><td>A div B</td><td>xs:dayTimeDuration</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-divide-dayTimeDuration"><code>op:divide-dayTimeDuration</code></a><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr><tr><td>A div B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-divide-yearMonthDuration-by-yearMonthDuration"><code>op:divide-yearMonthDuration-by-yearMonthDuration</code></a><code>(A, B)</code></td><td>xs:decimal</td></tr><tr><td>A div B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-divide-dayTimeDuration-by-dayTimeDuration"><code>op:divide-dayTimeDuration-by-dayTimeDuration</code></a><code>(A, B)</code></td><td>xs:decimal</td></tr><tr><td>A mod B</td><td>xs:numeric</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-numeric-mod"><code>op:numeric-mod</code></a><code>(A, B)</code></td><td>xs:numeric</td></tr></tbody></table><div class="note"><p class="prefix"><b>Note:</b></p><p>The operator symbol <code>×</code> is a synonym of <code>*</code>, while <code>÷</code> is a synonym of <code>div</code>.</p></div><p>If there is no entry in the table for the combination of operator and operands, then a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p><p>Errors may also occur during coercion of the operands, or during evaluation of the identified function (for example, an error might result from dividing by zero).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>XQuery 4.0 provides three division operators:</p><ul><li><p>The <code>div</code> and <code>÷</code> operators are synonyms, and implement numeric division as well as division of duration values; the semantics are defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#func-numeric-divide">4.2.4 op:numeric-divide</a></p></li><li><p>The <code>idiv</code> operator implements integer division; the semantics are defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#func-numeric-integer-divide">4.2.5 op:numeric-integer-divide</a></p></li></ul></div><p>Here are some examples of arithmetic expressions:</p><ul><li><p>The first expression below returns the <code>xs:decimal</code> value <code>-1.5</code>, and the second expression returns the <code>xs:integer</code> value <code>-1</code>:</p><div class="exampleInner"><pre xml:space="preserve">-3 div 2
-3 idiv 2</pre></div></li><li><p>Subtraction of two date values results in a value of type <code>xs:dayTimeDuration</code>:</p><div class="exampleInner"><pre xml:space="preserve">$emp/hiredate - $emp/birthdate</pre></div></li><li><p>This example illustrates the difference between a subtraction operator and a hyphen:</p><div class="exampleInner"><pre xml:space="preserve">$unit-price - $unit-discount</pre></div></li><li><p>Unary operators have higher precedence than binary operators (other than <code>!</code>, <code>/</code>, and <code>[]</code>), subject of course to the use of parentheses. Therefore, the following two examples have different meanings:</p><div class="exampleInner"><pre xml:space="preserve">-$bellcost + $whistlecost
-($bellcost + $whistlecost)</pre></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p id="note-consecutive-unary-ops">Multiple consecutive unary arithmetic operators are permitted (though not useful).</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Negation is not the same as subtraction from zero: if <code>$x</code> is positive zero, then <code>-$x</code> returns negative zero, wheras <code>0 - $x</code> returns positive zero.</p></div></div><div class="_diffs div2"><h3><a id="id-string-expr"></a>4.9 <a href="#id-string-expr" style="text-decoration: none">String Expressions</a></h3><p>This section describes several ways of constructing strings.</p><div class="_diffs div3"><h4><a id="id-string-templates"></a>4.9.2 <a href="#id-string-templates" style="text-decoration: none">String Templates</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-value-comparisons">next</a> | <a href="#id-arithmetic">previous</a>)</p><ol><li><p> String templates provide a new way of constructing strings: for example <code>`{$greeting}, {$planet}!`</code> is equivalent to <code>$greeting || ', ' || $planet || '!'</code><i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/58">58</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/324">324</a>&nbsp;29 January 2023]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-StringTemplate"></a><code><a href="#prod-xquery40-StringTemplate">StringTemplate</a></code></td><td>::=</td><td><code>"`" (<a href="#doc-xquery40-StringTemplate-StringTemplateFixedPart">StringTemplateFixedPart</a> | <a href="#doc-xquery40-StringTemplate-StringTemplateVariablePart">StringTemplateVariablePart</a>)* "`"</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-StringTemplate-StringTemplateFixedPart"></a><code><a href="#prod-xquery40-StringTemplateFixedPart">StringTemplateFixedPart</a></code></td><td>::=</td><td><code>((<a href="#doc-xquery40-StringTemplate-Char">Char</a> - ('{' | '}' | '`')) | "{{" | "}}" | "``")+</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-StringTemplate-Char"></a><code><a href="#prod-xquery40-Char">Char</a></code></td><td>::=</td><td><code><a href="https://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-xml-version">xgc: xml-version</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-StringTemplate-StringTemplateVariablePart"></a><code><a href="#prod-xquery40-StringTemplateVariablePart">StringTemplateVariablePart</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-StringTemplate-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-StringTemplate-EnclosedExpr"></a><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td>::=</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td></tr></tbody></table><p>String templates provide an alternative way of constructing strings. For example, the expression <code>`Pi is { round(math:pi(), 4) }`</code> returns the string <code>"Pi is 3.1416"</code>.</p><p>A string template starts and ends with <span class="unicode-codepoint">U+0060</span> (<span class="unicode-name">GRAVE ACCENT, BACKTICK</span>, <code>`</code>) , popularly known as a back-tick. Between the back-ticks is a string consisting of an sequence of fixed parts and variable parts:</p><ul><li><p>A variable part consists of an optional XPath expression enclosed in curly brackets (<code>{}</code>): more specifically, a string conforming to the XPath production <code>Expr?</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An expression within a variable part may contain an unescaped <span class="unicode-codepoint">U+007B</span> (<span class="unicode-name">LEFT CURLY BRACKET</span>, <code>{</code>) or <span class="unicode-codepoint">U+007D</span> (<span class="unicode-name">RIGHT CURLY BRACKET</span>, <code>}</code>) within a <a href="#doc-xquery40-StringLiteral">StringLiteral</a> or within a comment.</p><p>The fact that the expression is optional means that the string contained between the curly brackets may be zero-length, may comprise whitespace only, or may contain XPath comments. The effective value in this case is a zero-length string, which is equivalent to omitting the variable part entirely, together with its curly-bracket delimiters. </p></div></li><li><p>A fixed part may contain any characters, except that:</p><ul><li><p>The character <span class="unicode-codepoint">U+007B</span> (<span class="unicode-name">LEFT CURLY BRACKET</span>, <code>{</code>) <span class="verb">must</span> be written as <code>{{</code>.</p></li><li><p>The character <span class="unicode-codepoint">U+007D</span> (<span class="unicode-name">RIGHT CURLY BRACKET</span>, <code>}</code>) <span class="verb">must</span> be written as <code>}}</code>.</p></li><li><p>The character <span class="unicode-codepoint">U+0060</span> (<span class="unicode-name">GRAVE ACCENT, BACKTICK</span>, <code>`</code>) <span class="verb">must</span> be written as <code>``</code>.</p></li></ul><p>Following the principles of the “longest token” rule, any occurrence of <code>{{</code> within the fixed part is interpreted as an escaped left curly bracket. This means that the enclosed expression must not start with <span class="unicode-codepoint">U+007B</span> (<span class="unicode-name">LEFT CURLY BRACKET</span>, <code>{</code>) : if this is required, the two left curly brackets can be separated by whitespace. For example the string template <code>`{{"key":"{ {1:"yes", 0:"no"}?$condition}"}}`</code> evaluates to the string <code>{"key":"yes"}</code> or <code>{"key":"no"}</code> depending on the value of <code>$condition</code>.</p><p>By contrast, if the enclosed expression ends with <span class="unicode-codepoint">U+007D</span> (<span class="unicode-name">RIGHT CURLY BRACKET</span>, <code>}</code>) , this can be immediately followed by the closing <span class="unicode-codepoint">U+007D</span> (<span class="unicode-name">RIGHT CURLY BRACKET</span>, <code>}</code>) delimiter without intervening whitespace.</p></li></ul><p> The result of evaluating a string template is the string obtained by concatenating the expansions of the fixed and variable parts:</p><ul><li><p>The expansion of a fixed part is obtained by replacing any double curly brackets (<code>{{</code> or <code>}}</code>) by the corresponding single curly bracket, and replacing doubled back-ticks (<code>``</code>) by a single back-tick.</p></li><li><p>The expansion of a variable part containing an expression is as follows:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the value of the enclosed expression, converting it to a sequence of atomic items.</p></li><li><p>If the result of atomization is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result is the zero-length string. Otherwise, each atomic item in the atomized sequence is cast into a string.</p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair.</p></li></ol></li><li><p>The expansion of <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty variable part (one that contains no expression) is a zero-length string.</p></li></ul><p>For example:</p><div class="exampleInner"><pre xml:space="preserve">let $greeting := "Hello", $planet := "Mars"
return `{ $greeting }, { $planet }!`</pre></div><p>returns <code>"Hello, Mars!"</code>.</p><p>The expression:</p><div class="exampleInner"><pre xml:space="preserve">let $long-months := (1, 3, 5, 7, 8, 10, 12)
return `The months with 31 days are: { $long-months }.`</pre></div><p>returns <code>"The months with 31 days are: 1 3 5 7 8 10 12."</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The rules for processing an enclosed expression are identical to the rules for attributes in XQuery direct element constructors. These rules differ slightly from the rules in XSLT attribute value templates, where adjacent text nodes are concatenated with no separator, prior to atomization.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>A string template containing no variable parts is effectively just another way of writing a string literal: <code>"Goethe"</code>, <code>'Goethe'</code>, and <code>`Goethe`</code> are interchangeable. This means that back-ticks can sometimes be a useful way of delimiting a string that contains both single and double quotes: <code>`He said: "I didn't."`</code>.</p><p>It is sometimes useful to use string templates in conjunction with the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-char"><code>fn:char</code></a> function to build strings containing special characters, for example <code>`Chapter{ fn:char("nbsp") }{ $chapNr }`</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>String literals containing an ampersand behave differently between XPath and XQuery: in XPath (unless first expanded by an XML parser) the string literal <code>"Bacon &amp; Eggs"</code> represents a string containing an ampersand, while in XQuery it is an error, because an ampersand is taken as introducing a character reference. This difference does not arise for string templates, since neither XPath nor XQuery recognizes entity or character references in a string template. This means that back-tick delimited strings (such as <code>`Bacon &amp; Eggs`</code>) may be useful in contexts where an XPath expression is required to have the same effect whether it is evaluated using an XPath or an XQuery processor.</p></div><p>In XQuery, the token <code>``[</code> is recognized as the start of a <a title="string constructor" class="termref" href="#dt-string-constructor">string constructor</a>, under the “longest token” rule (see <a href="#lexical-structure"><b>A.3 Lexical structure</b></a>). This means that the construct <code>``[1]</code> is not recognized as a <a href="#doc-xquery40-StringTemplate">StringTemplate</a> followed by a predicate. In the unlikely event that an empty <a href="#doc-xquery40-StringTemplate">StringTemplate</a> followed by a predicate is wanted, whitespace or parentheses can be used to avoid the tokenization problem.</p></div></div><div class="_diffs div2"><h3><a id="id-comparisons"></a>4.10 <a href="#id-comparisons" style="text-decoration: none">Comparison Expressions</a></h3><p>Comparison expressions allow two values to be compared. XQuery 4.0 provides three kinds of comparison expressions, called value comparisons, general comparisons, and GNode comparisons.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComparisonExpr"></a><code><a href="#prod-xquery40-ComparisonExpr">ComparisonExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-ComparisonExpr-OtherwiseExpr">OtherwiseExpr</a> ((<a href="#doc-xquery40-ComparisonExpr-ValueComp">ValueComp</a> | <a href="#doc-xquery40-ComparisonExpr-GeneralComp">GeneralComp</a> | <a href="#doc-xquery40-ComparisonExpr-NodeComp">NodeComp</a>) <a href="#doc-xquery40-ComparisonExpr-OtherwiseExpr">OtherwiseExpr</a>)?</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComparisonExpr-OtherwiseExpr"></a><code><a href="#prod-xquery40-OtherwiseExpr">OtherwiseExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-StringConcatExpr">StringConcatExpr</a> ("otherwise" <a href="#doc-xquery40-StringConcatExpr">StringConcatExpr</a>)*</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComparisonExpr-ValueComp"></a><code><a href="#prod-xquery40-ValueComp">ValueComp</a></code></td><td>::=</td><td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComparisonExpr-GeneralComp"></a><code><a href="#prod-xquery40-GeneralComp">GeneralComp</a></code></td><td>::=</td><td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;="</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComparisonExpr-NodeComp"></a><code><a href="#prod-xquery40-NodeComp">NodeComp</a></code></td><td>::=</td><td><code>"is" | "is-not" | <a href="#doc-xquery40-ComparisonExpr-NodePrecedes">NodePrecedes</a> | <a href="#doc-xquery40-ComparisonExpr-NodeFollows">NodeFollows</a> | "precedes-or-is" | "follows-or-is"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComparisonExpr-NodePrecedes"></a><code><a href="#prod-xquery40-NodePrecedes">NodePrecedes</a></code></td><td>::=</td><td><code>"&lt;&lt;" | "precedes"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComparisonExpr-NodeFollows"></a><code><a href="#prod-xquery40-NodeFollows">NodeFollows</a></code></td><td>::=</td><td><code>"&gt;&gt;" | "follows"</code></td></tr></tbody></table><p>For a summary of the differences between different ways of comparing atomic items in XQuery 4.0, see <a href="#id-atomic-comparisons"><b>H Atomic Comparisons: An Overview</b></a>.</p><div class="_diffs div3"><h4><a id="id-value-comparisons"></a>4.10.1 <a href="#id-value-comparisons" style="text-decoration: none">Value Comparisons</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-general-comparisons">next</a> | <a href="#id-string-templates">previous</a>)</p><ol><li><p> The rules for value comparisons when comparing values of different types (for example, decimal and double) have changed to be transitive. A decimal value is no longer converted to double, instead the double is converted to a decimal without loss of precision. This may affect compatibility in edge cases involving comparison of values that are numerically very close. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/986">986</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2218">2218</a>&nbsp;29 September 2025]</i></p></li><li><p> An ordering is now defined for all data types. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2216">2216</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2256">2256</a>&nbsp;1 December 2025]</i></p></li></ol></div><p>The value comparison operators are <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code>. Value comparisons are used for comparing single <a title="atomic item" class="termref" href="#dt-atomic-item">atomic items</a>.</p><p>The first step in evaluating a value comparison is to evaluate its operands. The order in which the operands are evaluated is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. Each operand is evaluated by applying the following steps, in order:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to each operand. The result of this operation is called the <b>atomized operand</b>.</p></li><li><p>If either or both of the atomized operands is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result of the value comparison is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, and the implementation need not evaluate the other operand or apply the operator. However, an implementation may choose to evaluate the other operand and may raise an error if evaluation fails.</p></li><li><p> If an atomized operand is a sequence of length greater than one, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>If both operands are instances of <code>xs:numeric</code>, and if either or both of the atomized operands is <code>NaN</code>, then the result is <code>false</code> if the operator is <code>eq</code>, <code>lt</code>, <code>gt</code>, <code>le</code>, or <code>ge</code>, but <code>true</code> if the operator is <code>ne</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>When an operand is <code>NaN</code>, the effect of a value comparison expression differs from the result of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-compare"><code>fn:compare</code></a> function.</p></div></li><li><p>The function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-compare"><code>fn:compare</code></a> is then called, supplying the two atomized operands as the first two arguments. The collation used by <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-compare"><code>fn:compare</code></a> is the default collation from the static context, and the implicit timezone used by the function is the implicit timezone from the dynamic context.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of this rule is that <code>xs:untypedAtomic</code> values (which typically result from atomizing a node) are treated as strings.</p></div></li><li><p>If <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-compare"><code>fn:compare</code></a> raises an error (typically because the two operands belong to different <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-type-family">type families</a><sup><small>DM</small></sup>), then the value comparison fails with that error.</p></li><li><p>The result of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-compare"><code>fn:compare</code></a> function determines the result of the value comparison, according to the following table:</p><table><caption>Result of a Value Comparison</caption><thead><tr><th>Result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-compare"><code>fn:compare</code></a></th><th><code>eq</code></th><th><code>ne</code></th><th><code>lt</code></th><th><code>le</code></th><th><code>gt</code></th><th><code>ge</code></th></tr></thead><tbody><tr><td><code>-1</code></td><td><code>false</code></td><td><code>true</code></td><td><code>true</code></td><td><code>true</code></td><td><code>false</code></td><td><code>false</code></td></tr><tr><td><code>0</code></td><td><code>true</code></td><td><code>false</code></td><td><code>false</code></td><td><code>true</code></td><td><code>false</code></td><td><code>true</code></td></tr><tr><td><code>+1</code></td><td><code>false</code></td><td><code>true</code></td><td><code>false</code></td><td><code>false</code></td><td><code>true</code></td><td><code>true</code></td></tr></tbody></table></li></ol><p>Here are some examples of value comparisons:</p><ul><li><p><span style="display: none;" class="delete_version">The following comparison atomizes the node(s) that are returned by the expression <code>$book/author</code>. The comparison is true only if the result of atomization is the value "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>. If the result of atomization is an empty sequence, the result of the comparison is an empty sequence. If the result of atomization is a sequence containing more than one value, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</span><span style="display: none;" class="add_version">The following comparison atomizes the node(s) that are returned by the expression <code>$book/author</code>. The comparison is true only if the result of atomization is the value "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>. If the result of atomization is the empty sequence, the result of the comparison is the empty sequence. If the result of atomization is a sequence containing more than one value, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</span><span class="modify_version">The following comparison atomizes the node(s) that are returned by the expression <code>$book/author</code>. The comparison is true only if the result of atomization is the value "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>. If the result of atomization is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result of the comparison is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. If the result of atomization is a sequence containing more than one value, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</span></p><div class="exampleInner"><pre xml:space="preserve">$book1/author eq "Kennedy"</pre></div></li><li><p>The following comparison is <code>true</code> because atomization converts an array to its member sequence:</p><div class="exampleInner"><pre xml:space="preserve">[ "Kennedy" ] eq "Kennedy"</pre></div></li><li><p>The following <a title="path expression" class="termref" href="#dt-path-expression">path expression</a> contains a predicate that selects products whose weight is greater than 100. For any product that does not have a <code>weight</code> subelement, the value of the predicate is the empty sequence, and the product is not selected. This example assumes that <code>weight</code> is a validated element with a numeric type.</p><div class="exampleInner"><pre xml:space="preserve">//product[weight gt 100]</pre></div></li><li class="xquery"><p>The following comparisons are true because, in each case, the two constructed nodes have the same value after atomization, even though they have different identities and/or names:</p><div class="exampleInner"><pre xml:space="preserve">&lt;a&gt;5&lt;/a&gt; eq &lt;a&gt;5&lt;/a&gt;</pre></div><div class="exampleInner"><pre xml:space="preserve">&lt;a&gt;5&lt;/a&gt; eq &lt;b&gt;5&lt;/b&gt;</pre></div></li><li><p>The following comparison is true if <code>my:hatsize</code> and <code>my:shoesize</code> are both user-defined types that are derived by restriction from a primitive <a title="numeric" class="termref" href="#dt-numeric">numeric</a> type:</p><div class="exampleInner"><pre xml:space="preserve">my:hatsize(5) eq my:shoesize(5)</pre></div></li><li><p>The following comparison is true. The <code>eq</code> operator compares two QNames by performing codepoint-comparisons of their namespace URIs and their local names, ignoring their namespace prefixes.</p><div class="exampleInner"><pre xml:space="preserve">QName("http://example.com/ns1", "this:color") eq
QName("http://example.com/ns1", "that:color")</pre></div></li><li><p>The following comparison is false. The <code>xs:double</code> value <code>1.1e0</code> is converted to type <code>xs:decimal</code>, giving the result <code>1.100000000000000088817841970012523233890533447265625</code>, which is not equal to the <code>xs:decimal</code> value <code>1.1</code>.</p><div class="exampleInner"><pre xml:space="preserve">1.1 eq 1.1e0</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>This is incompatible with previous versions, which converted both operands to <code>xs:double</code> before comparing them. This change has been made because there are contexts (such as sorting and grouping) where it is important that comparison results should be transitive, and this was not previously the case.</p></div></li></ul></div><div class="_diffs div3"><h4><a id="id-node-comparisons"></a>4.10.3 <a href="#id-node-comparisons" style="text-decoration: none">GNode Comparisons</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-logical-expressions">next</a> | <a href="#id-general-comparisons">previous</a>)</p><ol><li><p> Operator <code>is-not</code> is introduced, as a complement to the operator <code>is</code>. <i>&nbsp;&nbsp;[&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2130">2130</a>&nbsp;28 July 2025]</i></p></li><li><p> Operators <code>precedes</code> and <code>follows</code> are introduced as synonyms for operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code>. <i>&nbsp;&nbsp;[&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2130">2130</a>&nbsp;28 July 2025]</i></p></li><li><p> Operators <code>precedes-or-is</code> and <code>follows-or-is</code> are introduced as synonyms for the union of operators <code>&lt;&lt;</code> and <code>is</code> and for the union of operators <code>&gt;&gt;</code> and <code>is</code>, respectively. <i>&nbsp;&nbsp;[&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2176">2176</a>&nbsp;22 August 2025]</i></p></li></ol></div><p>GNode comparisons are used to compare two <a title="GNode" class="termref" href="#dt-GNode">GNodes</a> (that is, <a title="XNode" class="termref" href="#dt-XNode">XNodes</a> or <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-JNode">JNodes</a><sup><small>DM</small></sup>), by their identity or by their <a title="document order" class="termref" href="#dt-document-order">document order</a>. The result of a GNode comparison is defined by the following rules:</p><ol class="enumar"><li><p>The operands of a <a title="GNode" class="termref" href="#dt-GNode">GNode</a> comparison are evaluated in <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order.</p></li><li><p>If either operand is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result of the comparison is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, and the implementation need not evaluate the other operand or apply the operator. However, an implementation may choose to evaluate the other operand in order to determine whether it raises an error.</p></li><li><p> Each operand must be either a single <a title="GNode" class="termref" href="#dt-GNode">GNode</a> or <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence; otherwise a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>A comparison with the <code>is</code> operator is <code>true</code> if the values of two operands are the same GNode; otherwise it is <code>false</code>. See <a href="#xpath-datamodel-40">[XDM 4.0]</a> for the definition of GNode identity.</p></li><li><p>A comparison with the <code>is-not</code> operator is <code>false</code> if the values of two operands are the same GNode; otherwise it is <code>true</code>. See <a href="#xpath-datamodel-40">[XDM 4.0]</a> for the definition of GNode identity.</p></li><li><p>A comparison with the <code>&lt;&lt;</code> or <code>precedes</code> operator returns <code>true</code> if the left operand <a title="GNode" class="termref" href="#dt-GNode">GNode</a> precedes the right operand GNode in <a title="document order" class="termref" href="#dt-document-order">document order</a>; otherwise it returns <code>false</code>.</p></li><li><p>A comparison with the <code>&gt;&gt;</code> or <code>follows</code> operator returns <code>true</code> if the left operand GNode follows the right operand GNode in <a title="document order" class="termref" href="#dt-document-order">document order</a>; otherwise it returns <code>false</code>.</p></li><li><p>A comparison with the <code>precedes-or-is</code> operator returns <code>true</code> if the left operand <a title="GNode" class="termref" href="#dt-GNode">GNode</a> precedes the right operand GNode in <a title="document order" class="termref" href="#dt-document-order">document order</a> or if the values of two operands are the same GNode; otherwise it returns <code>false</code>.</p></li><li><p>A comparison with the <code>follows-or-is</code> operator returns <code>true</code> if the left operand <a title="GNode" class="termref" href="#dt-GNode">GNode</a> follows the right operand GNode in <a title="document order" class="termref" href="#dt-document-order">document order</a> or if the values of two operands are the same GNode; otherwise it returns <code>false</code>.</p></li></ol><p>Here are some examples of GNode comparisons:</p><ul><li><p>The following comparison is true only if the left and right sides each evaluate to exactly the same single node:</p><div class="exampleInner"><pre xml:space="preserve">/books/book[isbn = "1558604820"] is /books/book[call = "QA76.9 C3845"]</pre></div></li><li class="xquery"><p>The following comparison is false because each constructed node has its own identity:</p><div class="exampleInner"><pre xml:space="preserve">&lt;a&gt;5&lt;/a&gt; is &lt;a&gt;5&lt;/a&gt;</pre></div></li><li><p>The following comparison is true only if the node identified by the left side occurs before the node identified by the right side in document order:</p><div class="exampleInner"><pre xml:space="preserve">/transactions/purchase[parcel = "28-451"] &lt;&lt; /transactions/sale[parcel = "33-870"]</pre></div></li><li><p>The following comparison is true only if the first integer among the members of an array precedes the first string. This expression compares two JNodes:</p><div class="exampleInner"><pre xml:space="preserve">let $A := ["Q", 3, "E", "R", "T", 5, "Y"]
return $A ? child::type(xs:integer)[1] precedes $A ? child::type(xs:string)[1]</pre></div></li></ul></div></div><div class="_diffs div2 xquery"><h3><a id="id-constructors"></a>4.12 <a href="#id-constructors" style="text-decoration: none">Node Constructors</a></h3><p>XQuery provides node constructors that can create XML nodes within a query.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor"></a><code><a href="#prod-xquery40-NodeConstructor">NodeConstructor</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-NodeConstructor-DirectConstructor">DirectConstructor</a><br>| <a href="#doc-xquery40-NodeConstructor-ComputedConstructor">ComputedConstructor</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-DirectConstructor"></a><code><a href="#prod-xquery40-DirectConstructor">DirectConstructor</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-NodeConstructor-DirElemConstructor">DirElemConstructor</a><br>| <a href="#doc-xquery40-NodeConstructor-DirCommentConstructor">DirCommentConstructor</a><br>| <a href="#doc-xquery40-NodeConstructor-DirPIConstructor">DirPIConstructor</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-DirElemConstructor"></a><code><a href="#prod-xquery40-DirElemConstructor">DirElemConstructor</a></code></td><td>::=</td><td><code>"&lt;" <a href="#prod-xquery40-QName">QName</a><a href="#doc-xquery40-NodeConstructor-DirAttributeList">DirAttributeList</a> ("/&gt;" | ("&gt;" <a href="#doc-xquery40-NodeConstructor-DirElemContent">DirElemContent</a>* "&lt;/" <a href="#prod-xquery40-QName">QName</a><a href="#prod-xquery40-S">S</a>? "&gt;"))</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-DirAttributeList"></a><code><a href="#prod-xquery40-DirAttributeList">DirAttributeList</a></code></td><td>::=</td><td><code>(<a href="#prod-xquery40-S">S</a> (<a href="#prod-xquery40-QName">QName</a><a href="#prod-xquery40-S">S</a>? "=" <a href="#prod-xquery40-S">S</a>? <a href="#doc-xquery40-NodeConstructor-DirAttributeValue">DirAttributeValue</a>)?)*</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-DirAttributeValue"></a><code><a href="#prod-xquery40-DirAttributeValue">DirAttributeValue</a></code></td><td>::=</td><td><code>('"' (<a href="#prod-xquery40-EscapeQuot">EscapeQuot</a> | <a href="#doc-xquery40-NodeConstructor-QuotAttrValueContent">QuotAttrValueContent</a>)* '"')<br>| ("'" (<a href="#prod-xquery40-EscapeApos">EscapeApos</a> | <a href="#doc-xquery40-NodeConstructor-AposAttrValueContent">AposAttrValueContent</a>)* "'")</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-QuotAttrValueContent"></a><code><a href="#prod-xquery40-QuotAttrValueContent">QuotAttrValueContent</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-QuotAttrContentChar">QuotAttrContentChar</a><br>| <a href="#doc-xquery40-NodeConstructor-CommonContent">CommonContent</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-AposAttrValueContent"></a><code><a href="#prod-xquery40-AposAttrValueContent">AposAttrValueContent</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-AposAttrContentChar">AposAttrContentChar</a><br>| <a href="#doc-xquery40-NodeConstructor-CommonContent">CommonContent</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-DirElemContent"></a><code><a href="#prod-xquery40-DirElemContent">DirElemContent</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-NodeConstructor-DirectConstructor">DirectConstructor</a><br>| <a href="#doc-xquery40-NodeConstructor-CDataSection">CDataSection</a><br>| <a href="#doc-xquery40-NodeConstructor-CommonContent">CommonContent</a><br>| <a href="#doc-xquery40-NodeConstructor-ElementContentChar">ElementContentChar</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-DirCommentConstructor"></a><code><a href="#prod-xquery40-DirCommentConstructor">DirCommentConstructor</a></code></td><td>::=</td><td><code>"&lt;!--" <a href="#doc-xquery40-NodeConstructor-DirCommentContents">DirCommentContents</a> "--&gt;"</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-DirPIConstructor"></a><code><a href="#prod-xquery40-DirPIConstructor">DirPIConstructor</a></code></td><td>::=</td><td><code>"&lt;?" <a href="#prod-xquery40-PITarget">PITarget</a> (<a href="#prod-xquery40-S">S</a><a href="#prod-xquery40-DirPIContents">DirPIContents</a>)? "?&gt;"</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-CDataSection"></a><code><a href="#prod-xquery40-CDataSection">CDataSection</a></code></td><td>::=</td><td><code>"&lt;![CDATA[" <a href="#doc-xquery40-NodeConstructor-CDataSectionContents">CDataSectionContents</a> "]]&gt;"</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-CDataSectionContents"></a><code><a href="#prod-xquery40-CDataSectionContents">CDataSectionContents</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-NodeConstructor-Char">Char</a>* - (Char* ']]&gt;' Char*))</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-Char"></a><code><a href="#prod-xquery40-Char">Char</a></code></td><td>::=</td><td><code><a href="https://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-xml-version">xgc: xml-version</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-CommonContent"></a><code><a href="#prod-xquery40-CommonContent">CommonContent</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-PredefinedEntityRef">PredefinedEntityRef</a> | <a href="#prod-xquery40-CharRef">CharRef</a> | "{{" | "}}" | <a href="#doc-xquery40-NodeConstructor-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-EnclosedExpr"></a><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td>::=</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-ElementContentChar"></a><code><a href="#prod-xquery40-ElementContentChar">ElementContentChar</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-NodeConstructor-Char">Char</a> - [{}&lt;&amp;])</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-DirCommentContents"></a><code><a href="#prod-xquery40-DirCommentContents">DirCommentContents</a></code></td><td>::=</td><td><code>((<a href="#doc-xquery40-NodeConstructor-Char">Char</a> - '-') | ("-" (<a href="#doc-xquery40-NodeConstructor-Char">Char</a> - '-')))*</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-NodeConstructor-ComputedConstructor"></a><code><a href="#prod-xquery40-ComputedConstructor">ComputedConstructor</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-CompDocConstructor">CompDocConstructor</a><br>| <a href="#doc-xquery40-CompElemConstructor">CompElemConstructor</a><br>| <a href="#doc-xquery40-CompAttrConstructor">CompAttrConstructor</a><br>| <a href="#doc-xquery40-CompNamespaceConstructor">CompNamespaceConstructor</a><br>| <a href="#doc-xquery40-CompTextConstructor">CompTextConstructor</a><br>| <a href="#doc-xquery40-CompCommentConstructor">CompCommentConstructor</a><br>| <a href="#doc-xquery40-CompPIConstructor">CompPIConstructor</a></code></td></tr></tbody></table><p>Constructors are provided for element, attribute, document, text, comment, and processing instruction nodes. Two kinds of constructors are provided: <b>direct constructors</b>, which use an XML-like notation that can incorporate enclosed expressions, and <b>computed constructors</b>, which use a notation based on enclosed expressions. </p><p>The rest of this section contains a conceptual description of the semantics of various kinds of constructor expressions. An XQuery implementation is free to use any implementation technique that produces the same result as the processing steps described here.</p><div class="_diffs div3"><h4><a id="id-element-constructor"></a>4.12.1 <a href="#id-element-constructor" style="text-decoration: none">Direct Element Constructors</a></h4><p>An <b>element constructor</b> creates an element node. [<a id="dt-direct-elem-const" title="direct element constructor">Definition</a>: A <b>direct element constructor</b> is a form of element constructor in which the name of the constructed element is a constant.] Direct element constructors are based on standard XML notation. For example, the following expression is a direct element constructor that creates a <code>book</code> element containing an attribute and some nested elements:</p><div class="exampleInner"><pre xml:space="preserve">&lt;book isbn="isbn-0060229357"&gt;
  &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;
  &lt;author&gt;
    &lt;first&gt;Crockett&lt;/first&gt;
    &lt;last&gt;Johnson&lt;/last&gt;
  &lt;/author&gt;
&lt;/book&gt;</pre></div><p>The element name, written as a lexical QName, is expanded using the <a title="constructed element namespace rule" class="termref" href="#dt-constructed-element-namespace-rule">constructed element namespace rule</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The statically known namespaces may be affected by <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attributes</a> found inside the element constructor.</p></div><p>The namespace prefix of the element name is retained after expansion of the <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, as described in <a href="#xpath-datamodel-40">[XDM 4.0]</a>. The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> becomes the <code>node-name</code> property of the constructed element node.</p><p>The name used in the end tag must exactly match the name used in the corresponding start tag, including its prefix or absence of a prefix [<a href="#ERRXQST0118" title="err:XQST0118">err:XQST0118</a>].</p><p>In a direct element constructor, curly brackets (<span class="unicode-codepoint">U+007B</span> (<span class="unicode-name">LEFT CURLY BRACKET</span>, <code>{</code>) and <span class="unicode-codepoint">U+007D</span> (<span class="unicode-name">RIGHT CURLY BRACKET</span>, <code>}</code>) ) delimit <a title="enclosed expression" class="termref" href="#dt-enclosed-expression">enclosed expressions</a>, distinguishing them from literal text. Enclosed expressions are evaluated and replaced by their value, as illustrated by the following example:</p><div class="exampleInner"><pre xml:space="preserve">&lt;example&gt;
  &lt;p&gt; Here is a query. &lt;/p&gt;
  &lt;eg&gt; $b/title &lt;/eg&gt;
  &lt;p&gt; Here is the result of the query. &lt;/p&gt;
  &lt;eg&gt;{ $b/title }&lt;/eg&gt;
&lt;/example&gt;</pre></div><p>The above query might generate the following result (whitespace has been added for readability to this result and other result examples in this document):</p><div class="exampleInner"><pre xml:space="preserve">&lt;example&gt;
  &lt;p&gt; Here is a query. &lt;/p&gt;
  &lt;eg&gt; $b/title &lt;/eg&gt;
  &lt;p&gt; Here is the result of the query. &lt;/p&gt;
  &lt;eg&gt;&lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;&lt;/eg&gt;
&lt;/example&gt;</pre></div><p>Since XQuery uses <span class="unicode-codepoint">U+007B</span> (<span class="unicode-name">LEFT CURLY BRACKET</span>, <code>{</code>) and <span class="unicode-codepoint">U+007D</span> (<span class="unicode-name">RIGHT CURLY BRACKET</span>, <code>}</code>) to delimit enclosed expressions, some convention is needed to denote a curly bracket used as an ordinary character. For this purpose, a pair of identical curly bracket characters within the content of an element or attribute are interpreted by XQuery as a single curly bracket character (that is, the pair <code>"{{"</code> represents the character <span class="unicode-codepoint">U+007B</span> (<span class="unicode-name">LEFT CURLY BRACKET</span>, <code>{</code>) and the pair <code>"}}"</code> represents the character <span class="unicode-codepoint">U+007D</span> (<span class="unicode-name">RIGHT CURLY BRACKET</span>, <code>}</code>) .) Alternatively, the <a title="character reference" class="termref" href="#dt-character-reference">character references</a><code>&amp;#x7b;</code> and <code>&amp;#x7d;</code> can be used to denote curly bracket characters. A single <span class="unicode-codepoint">U+007B</span> (<span class="unicode-name">LEFT CURLY BRACKET</span>, <code>{</code>) is interpreted as the beginning delimiter for an enclosed expression. A single <span class="unicode-codepoint">U+007D</span> (<span class="unicode-name">RIGHT CURLY BRACKET</span>, <code>}</code>) without a matching left curly bracket is treated as a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXPST0003" title="err:XPST0003">err:XPST0003</a>].</p><p>Within an enclosed expression, the handling of expressions that start with <span class="unicode-codepoint">U+007B</span> (<span class="unicode-name">LEFT CURLY BRACKET</span>, <code>{</code>) or that end with <span class="unicode-codepoint">U+007D</span> (<span class="unicode-name">RIGHT CURLY BRACKET</span>, <code>}</code>) is the same as for <a href="#id-string-templates"><b>4.9.2 String Templates</b></a>.</p><p>The result of an element constructor is a new element node, with its own node identity. All the attribute and descendant nodes of the new element node are also new nodes with their own identities, even if they are copies of existing nodes.</p><div class="_diffs div4"><h5><a id="id-attributes"></a>4.12.1.1 <a href="#id-attributes" style="text-decoration: none">Attributes</a></h5><p>The start tag of a direct element constructor may contain one or more attributes. As in XML, each attribute is specified by a name and a value. In a direct element constructor, the name of each attribute is specified by a constant <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, and the value of the attribute is specified by a string of characters enclosed in single or double quotes. As in the main content of the element constructor, an attribute value may contain <a title="enclosed expression" class="termref" href="#dt-enclosed-expression">enclosed expressions</a>, which are evaluated and replaced by their value during processing of the element constructor.</p><p>Each attribute in a direct element constructor creates a new attribute node, with its own node identity, whose parent is the constructed element node. However, note that <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attributes</a> (see <a href="#id-namespaces"><b>4.12.1.2 Namespace Declaration Attributes</b></a>) do not create attribute nodes.</p><p>The attribute name, written as a lexical QName, is expanded using the <a title="no-namespace rule" class="termref" href="#dt-no-namespace-rule">no-namespace rule</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p> The <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> used in resolving an attribute name may be affected by <a title="namespace declaration attribute" class="termref" href="#dt-namespace-decl-attr">namespace declaration attributes</a> that are found inside the same element constructor. </p></div><p> The namespace prefix of the attribute name is retained after expansion of the <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>, as described in <a href="#xpath-datamodel-40">[XDM 4.0]</a>. The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> becomes the <code>node-name</code> property of the constructed attribute node.</p><p>If the attributes in a direct element constructor do not have distinct <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> as their respective <code>node-name</code> properties, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0040" title="err:XQST0040">err:XQST0040</a>].</p><p>Conceptually, an attribute (other than a namespace declaration attribute) in a direct element constructor is processed by the following steps:</p><ol class="enumar"><li><p>Each consecutive sequence of literal characters in the attribute content is processed as a string literal containing those characters, with the following exceptions:</p><ol class="enumla"><li><p>Each occurrence of two consecutive <code>{</code> characters is replaced by a single <code>{</code> character. </p></li><li><p>Each occurrence of two consecutive <code>}</code> characters is replaced by a single <code>}</code> character. </p></li><li><p>Each occurrence of <a href="#prod-xquery40-EscapeQuot">EscapeQuot</a> is replaced by a single <code>"</code> character. </p></li><li><p>Each occurrence of <a href="#prod-xquery40-EscapeApos">EscapeApos</a> is replaced by a single <code>'</code> character. </p></li></ol><p>Within an enclosed expression, the handling of expressions that start with <span class="unicode-codepoint">U+007B</span> (<span class="unicode-name">LEFT CURLY BRACKET</span>, <code>{</code>) or that end with <span class="unicode-codepoint">U+007D</span> (<span class="unicode-name">RIGHT CURLY BRACKET</span>, <code>}</code>) is the same as for <a href="#id-string-templates"><b>4.9.2 String Templates</b></a>.</p><p>Attribute value normalization is then applied to normalize whitespace and expand <a title="character reference" class="termref" href="#dt-character-reference">character references</a> and <a title="predefined entity reference" class="termref" href="#dt-predefined-entity-reference">predefined entity references</a>. The rules for attribute value normalization are the rules from Section 3.3.3 of [XML 1.0] or Section 3.3.3 of [XML 1.1] (it is implementation-defined which version is used). The rules are applied as though the type of the attribute were CDATA (leading and trailing whitespace characters are not stripped.) </p></li><li><p>Each enclosed expression is converted to a string as follows:</p><ol class="enumla"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the value of the enclosed expression, converting it to a sequence of atomic items.</p></li><li><p>If the result of atomization is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result is the zero-length string. Otherwise, each atomic item in the atomized sequence is cast into a string.</p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair.</p></li></ol></li><li><p>Adjacent strings resulting from the above steps are concatenated with no intervening blanks. The resulting string becomes the <code>string-value</code> property of the attribute node. The attribute node is given a <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of <code>xs:untypedAtomic</code> (this type annotation may change if the parent element is validated). The <code>typed-value</code> property of the attribute node is the same as its <code>string-value</code>, as an instance of <code>xs:untypedAtomic</code>.</p></li><li><p>The <code>parent</code> property of the attribute node is set to the element node constructed by the direct element constructor that contains this attribute.</p></li><li><p>If the attribute name is <code>xml:id</code>, then <code>xml:id</code> processing is performed as defined in <a href="#XMLID">[XML ID]</a>. This ensures that the attribute has the type <code>xs:ID</code> and that its value is properly normalized. If an error is encountered during <code>xml:id</code> processing, an implementation may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0091" title="err:XQDY0091">err:XQDY0091</a>].</p></li><li><p>If the attribute name is <code>xml:id</code>, the <code>is-id</code> property of the resulting attribute node is set to <code>true</code>; otherwise the <code>is-id</code> property is set to <code>false</code>. The <code>is-idrefs</code> property of the attribute node is unconditionally set to <code>false</code>.</p></li></ol><ul><li><p>Example:</p><div class="exampleInner"><pre xml:space="preserve">&lt;shoe size="7"/&gt;</pre></div><p>The string value of the <code>size</code> attribute is <code>"7"</code>.</p></li><li><p>Example:</p><div class="exampleInner"><pre xml:space="preserve">&lt;shoe size="{ 7 }"/&gt;</pre></div><p>The string value of the <code>size</code> attribute is <code>"7"</code>.</p></li><li><p>Example:</p><div class="exampleInner"><pre xml:space="preserve">&lt;shoe size="{ () }"/&gt;</pre></div><p>The string value of the <code>size</code> attribute is the zero-length string.</p></li><li><p>Example:</p><div class="exampleInner"><pre xml:space="preserve">&lt;chapter ref="[ { 1, 5 to 7, 9 } ]"/&gt;</pre></div><p>The string value of the <code>ref</code> attribute is <code>"[1 5 6 7 9]"</code>.</p></li><li><p>Example:</p><div class="exampleInner"><pre xml:space="preserve">&lt;shoe size="As big as { $hat/@size }"/&gt;</pre></div><p>The string value of the <code>size</code> attribute is the string <code>"As big as "</code>, concatenated with the string value of the node denoted by the expression <code>$hat/@size</code>.</p></li></ul></div></div><div class="_diffs div3"><h4><a id="id-computedConstructors"></a>4.12.3 <a href="#id-computedConstructors" style="text-decoration: none">Computed Constructors</a></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComputedConstructor"></a><code><a href="#prod-xquery40-ComputedConstructor">ComputedConstructor</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-ComputedConstructor-CompDocConstructor">CompDocConstructor</a><br>| <a href="#doc-xquery40-ComputedConstructor-CompElemConstructor">CompElemConstructor</a><br>| <a href="#doc-xquery40-ComputedConstructor-CompAttrConstructor">CompAttrConstructor</a><br>| <a href="#doc-xquery40-ComputedConstructor-CompNamespaceConstructor">CompNamespaceConstructor</a><br>| <a href="#doc-xquery40-ComputedConstructor-CompTextConstructor">CompTextConstructor</a><br>| <a href="#doc-xquery40-ComputedConstructor-CompCommentConstructor">CompCommentConstructor</a><br>| <a href="#doc-xquery40-ComputedConstructor-CompPIConstructor">CompPIConstructor</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComputedConstructor-CompDocConstructor"></a><code><a href="#prod-xquery40-CompDocConstructor">CompDocConstructor</a></code></td><td>::=</td><td><code>"document" <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComputedConstructor-CompElemConstructor"></a><code><a href="#prod-xquery40-CompElemConstructor">CompElemConstructor</a></code></td><td>::=</td><td><code>"element" <a href="#prod-xquery40-CompNodeName">CompNodeName</a><a href="#prod-xquery40-EnclosedContentExpr">EnclosedContentExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComputedConstructor-CompAttrConstructor"></a><code><a href="#prod-xquery40-CompAttrConstructor">CompAttrConstructor</a></code></td><td>::=</td><td><code>"attribute" <a href="#prod-xquery40-CompNodeName">CompNodeName</a><a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComputedConstructor-CompNamespaceConstructor"></a><code><a href="#prod-xquery40-CompNamespaceConstructor">CompNamespaceConstructor</a></code></td><td>::=</td><td><code>"namespace" <a href="#prod-xquery40-CompNodeNCName">CompNodeNCName</a><a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComputedConstructor-CompTextConstructor"></a><code><a href="#prod-xquery40-CompTextConstructor">CompTextConstructor</a></code></td><td>::=</td><td><code>"text" <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComputedConstructor-CompCommentConstructor"></a><code><a href="#prod-xquery40-CompCommentConstructor">CompCommentConstructor</a></code></td><td>::=</td><td><code>"comment" <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ComputedConstructor-CompPIConstructor"></a><code><a href="#prod-xquery40-CompPIConstructor">CompPIConstructor</a></code></td><td>::=</td><td><code>"processing-instruction" <a href="#prod-xquery40-CompNodeNCName">CompNodeNCName</a><a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody></table><p>An alternative way to create nodes is by using a <b>computed constructor</b>. A computed constructor begins with a keyword that identifies the type of node to be created: <code>element</code>, <code>attribute</code>, <code>document</code>, <code>text</code>, <code>processing-instruction</code>, <code>comment</code>, or <code>namespace</code>.</p><p>For those kinds of nodes that have names (element, attribute, processing instruction, and namespace nodes), the keyword that specifies the node kind is followed by the name of the node to be created. This name may be specified either as an EQName or as an expression enclosed in braces. [<a id="dt-name-expression" title="name expression">Definition</a>: When an expression is used to specify the name of a constructed node, that expression is called the <b>name expression</b> of the constructor.] </p><p>The following example illustrates the use of computed element and attribute constructors in a simple case where the names of the constructed nodes are constants. This example generates exactly the same result as the first example in <a href="#id-element-constructor"><b>4.12.1 Direct Element Constructors</b></a>:</p><div class="exampleInner"><pre xml:space="preserve">element book {
  attribute isbn { "isbn-0060229357" },
  element title { "Harold and the Purple Crayon" },
  element author {
    element first { "Crockett" },
    element last { "Johnson" }
  }
}</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>XQuery 4.0 allows the node name to be written in quotation marks (for example, <code>element "book" {}</code>, and at the same time it disallows the use of a defined set of language keywords without quotes: for example <code>element div {}</code> was allowed in XQuery 3.1 but must now be written <code>element #div {}</code> or <code>element { "div" } {}</code>. The reason for this incompatible change is that allowing map constructors to omit the <code>map</code> keyword would otherwise create an ambiguity: consider for example the expression <code>element otherwise {}</code>.</p><p>Because the list of reserved keywords may be extended in future versions of this specification, the safest strategy is to always use the <code>QNameLiteral</code> syntax (for example <code>element #div</code>). To avoid any dependency on the default namespace context, the form <code>element Q{}div</code> might also be used.</p><p>To write code that is portable between XQuery 3.1 and XQuery 4.0, the best advice is to use either the form <code>element { "div" }</code> or the form <code>element Q{}div</code>.</p></div><div class="_diffs div4"><h5><a id="id-computedElements"></a>4.12.3.1 <a href="#id-computedElements" style="text-decoration: none">Computed Element Constructors</a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-computedAttributes">next</a> | <a href="#id-namespaces">previous</a>)</p><ol><li><p> When the element name matches a language keyword such as <code>div</code> or <code>value</code>, it must now be written as a QName literal. This is a backwards incompatible change. <i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/1450">1450</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/1983">1983</a>&nbsp;PRs <a href="https://github.com/qt4cg/qtspecs/pull/1480">1480</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/pull/1989">1989</a>&nbsp;3 October 2024]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompElemConstructor"></a><code><a href="#prod-xquery40-CompElemConstructor">CompElemConstructor</a></code></td><td>::=</td><td><code>"element" <a href="#doc-xquery40-CompElemConstructor-CompNodeName">CompNodeName</a><a href="#doc-xquery40-CompElemConstructor-EnclosedContentExpr">EnclosedContentExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompElemConstructor-CompNodeName"></a><code><a href="#prod-xquery40-CompNodeName">CompNodeName</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-CompElemConstructor-QNameLiteral">QNameLiteral</a> | <a href="#doc-xquery40-CompElemConstructor-UnreservedName">UnreservedName</a> | ("{" <a href="#doc-xquery40-CompElemConstructor-Expr">Expr</a> "}")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompElemConstructor-QNameLiteral"></a><code><a href="#prod-xquery40-QNameLiteral">QNameLiteral</a></code></td><td>::=</td><td><code>"#" <a href="#doc-xquery40-CompElemConstructor-EQName">EQName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompElemConstructor-UnreservedName"></a><code><a href="#prod-xquery40-UnreservedName">UnreservedName</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-CompElemConstructor-EQName">EQName</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-unreserved-name">xgc: unreserved-name</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompElemConstructor-EQName"></a><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-QName">QName</a> | <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompElemConstructor-Expr"></a><code><a href="#prod-xquery40-Expr">Expr</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-ExprSingle">ExprSingle</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompElemConstructor-EnclosedContentExpr"></a><code><a href="#prod-xquery40-EnclosedContentExpr">EnclosedContentExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-CompElemConstructor-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompElemConstructor-EnclosedExpr"></a><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td>::=</td><td><code>"{" <a href="#doc-xquery40-CompElemConstructor-Expr">Expr</a>? "}"</code></td></tr></tbody></table><p> [<a id="dt-computed-elem-const" title="computed element constructor">Definition</a>: A <b>computed element constructor</b> creates an element node, allowing both the name and the content of the node to be computed.] </p><p>The element name is determined by the <a href="#prod-xquery40-CompNodeName">CompNodeName</a>, which may be provided in a number of ways:</p><ol class="enumar"><li><p>As a QName literal, for example:</p><blockquote><p><code>element #table {}</code><br><code>element #html:table {}</code><br><code>element #Q{}table {}</code><br><code>element #Q{http://http://www.w3.org/1999/xhtml}table {}</code><br><code>element #Q{http://http://www.w3.org/1999/xhtml}html:table {}</code></p></blockquote><p>A QName literal written as an unprefixed <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a> (the first form above) is resolved using the <a title="constructed element namespace rule" class="termref" href="#dt-constructed-element-namespace-rule">constructed element namespace rule</a>. This differs from the normal rules for evaluating a QName literal as an atomic item of type <code>xs:QName</code>.</p><p>Note that the third and fourth examples (<code>#Q{}table</code> and <code>#Q{http://http://www.w3.org/1999/xhtml}table</code>) will result in the name of the constructed element having no prefix, which may in turn trigger the generation of a default namespace declaration.</p></li><li><p>As a simple <a href="#doc-xquery40-EQName">EQName</a>, for example:</p><blockquote><p><code>element table {}</code><br><code>element html:table {}</code><br><code>element Q{}table {}</code><br><code>element Q{http://http://www.w3.org/1999/xhtml}table {}</code><br><code>element Q{http://http://www.w3.org/1999/xhtml}html:table {}</code></p></blockquote><p>In XQuery 4.0 the first form (using an unprefixed <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>) is allowed only if the element name is not a reserved keyword (such as <code>div</code> or <code>value</code>): see <a href="#parse-note-unreserved-name">unreserved-name</a>. In all other cases, the effect is exactly the same as when a leading <code>#</code> is added to turn the EQName into a QName literal.</p><p>This syntax is retained for compatibility, but is deprecated.</p></li><li><p>As an expression in curly brackets. This is processed as follows:</p><ol class="enumla"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the value of the <a title="name expression" class="termref" href="#dt-name-expression">name expression</a>. If the result of atomization is not a single atomic item of type <code>xs:QName</code>, <code>xs:string</code>, or <code>xs:untypedAtomic</code>, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>If the atomized value of the <a title="name expression" class="termref" href="#dt-name-expression">name expression</a> is of type <code>xs:QName</code>, that <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is used as the <code>node-name</code> property of the constructed element, retaining the prefix part of the QName.</p></li><li><p>If the atomized value of the <a title="name expression" class="termref" href="#dt-name-expression">name expression</a> is of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, that value is converted to an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a><span>as follows:</span></p><ol class="enumlr"><li><p>Leading and trailing whitespace is removed.</p></li><li><p>If the value is a lexical QName, it is expanded using the <a title="constructed element namespace rule" class="termref" href="#dt-constructed-element-namespace-rule">constructed element namespace rule</a>.</p></li><li><p>If the value is in the form of a <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a> (<code>Q{uri}local</code> or <code>Q{uri}prefix:local</code>), it is converted to an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> with the supplied namespace URI and local name, and with the specified prefix if present.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>This was under-specified in XQuery 3.1.</p></div></li><li><p>If conversion of the atomized <a title="name expression" class="termref" href="#dt-name-expression">name expression</a> to an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is not successful, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0074" title="err:XQDY0074">err:XQDY0074</a>].</p></li></ol></li></ol><p>The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is used as the <code>node-name</code> property of the constructed element, retaining the prefix part of the QName <span>(or its absence)</span>.</p><p>An error is raised [<a href="#ERRXQDY0096" title="err:XQDY0096">err:XQDY0096</a>] if the node-name of the constructed element node has any of the following properties: </p><ul><li><p>Its namespace prefix is <code>xmlns</code>. </p></li><li><p>Its namespace URI is <code>http://www.w3.org/2000/xmlns/</code>. </p></li><li><p>Its namespace prefix is <code>xml</code> and its namespace URI is not <code>http://www.w3.org/XML/1998/namespace</code>. </p></li><li><p>Its namespace prefix is other than <code>xml</code> and its namespace URI is <code>http://www.w3.org/XML/1998/namespace</code>. </p></li></ul><p>The above error <span class="verb">may</span> be raised as a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the element name is computed statically; in other cases it <span class="verb">must</span> be raised as a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>.</p><p><span style="display: none;" class="delete_version">The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a computed element constructor (if present) is processed in exactly the same way as an enclosed expression in the content of a <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructor</a>, as described in Step 1e of <a href="#id-content"><b>4.12.1.3 Content</b></a>. The result of processing the content expression is a sequence of nodes called the <b>content sequence</b>. If the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> is absent, the content sequence is an empty sequence.</span><span style="display: none;" class="add_version">The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a computed element constructor (if present) is processed in exactly the same way as an enclosed expression in the content of a <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructor</a>, as described in Step 1e of <a href="#id-content"><b>4.12.1.3 Content</b></a>. The result of processing the content expression is a sequence of nodes called the <b>content sequence</b>. If the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> is absent, the content sequence is the empty sequence.</span><span class="modify_version">The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a computed element constructor (if present) is processed in exactly the same way as an enclosed expression in the content of a <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructor</a>, as described in Step 1e of <a href="#id-content"><b>4.12.1.3 Content</b></a>. The result of processing the content expression is a sequence of nodes called the <b>content sequence</b>. If the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> is absent, the content sequence is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p><p>Processing of the computed element constructor proceeds as follows:</p><ol class="enumar"><li><p>If the content sequence contains a document node, the document node is replaced in the content sequence by its children.</p></li><li><p>Adjacent text nodes in the content sequence are merged into a single text node by concatenating their contents, with no intervening blanks. After concatenation, any text node whose content is a zero-length string is deleted from the content sequence.</p></li><li><p> If the content sequence contains an attribute node or a namespace node following a node that is not an attribute node or a namespace node, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXQTY0024" title="err:XQTY0024">err:XQTY0024</a>].</p></li><li><p>The properties of the newly constructed element node are determined as follows:</p><ol class="enumla"><li><p><code>node-name</code> is the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> resulting from processing the specified <a href="#prod-xquery40-CompNodeName">CompNodeName</a>, as described above.</p></li><li><p><code>parent</code> is empty.</p></li><li><p><code>attributes</code> consist of all the attribute nodes in the content sequence, in <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order. Note that the <code>parent</code> property of each of these attribute nodes has been set to the newly constructed element node. If two or more attributes have the same <code>node-name</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0025" title="err:XQDY0025">err:XQDY0025</a>]. If an attribute named <code>xml:space</code> has a value other than <code>preserve</code> or <code>default</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> may be raised [<a href="#ERRXQDY0092" title="err:XQDY0092">err:XQDY0092</a>].</p></li><li><p><code>children</code> consist of all the element, text, comment, and processing instruction nodes in the content sequence. Note that the <code>parent</code> property of each of these nodes has been set to the newly constructed element node.</p></li><li><p><code>base-uri</code> is set to the following value: </p><ol class="enumlr"><li><p>If the constructed node has an attribute named <code>xml:base</code>, then the value of this attribute, <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved (if it is relative)</a> against the <span><a title="Executable Base URI" class="termref" href="#dt-executable-base-uri">Executable Base URI</a></span>, as described in <a href="#id-resolve-relative-uri"><b>2.6.7 Resolving a Relative URI Reference</b></a>.</p></li><li><p>Otherwise, the <span><a title="Executable Base URI" class="termref" href="#dt-executable-base-uri">Executable Base URI</a></span>.</p></li></ol></li><li><p> The <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a> are computed as described in <a href="#id-ns-nodes-on-elements"><b>4.12.4 In-scope Namespaces of a Constructed Element</b></a>.</p></li><li><p>The <code>nilled</code> property is <code>false</code>.</p></li><li><p>The <code>string-value</code> property is equal to the concatenated contents of the text-node descendants in document order.</p></li><li><p>The <code>typed-value</code> property is equal to the <code>string-value</code> property, as an instance of <code>xs:untypedAtomic</code>.</p></li><li><p>If <a title="construction mode" class="termref" href="#dt-construction-mode">construction mode</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> is <code>strip</code>, the <code>type-name</code> property is <code>xs:untyped</code>. On the other hand, if construction mode is <code>preserve</code>, the <code>type-name</code> property is <code>xs:anyType</code>.</p></li><li><p>The <code>is-id</code> and <code>is-idrefs</code> properties are set to <code>false</code>.</p></li></ol></li></ol><p>A computed element constructor might be used to make a modified copy of an existing element. For example, if the variable <code>$e</code> is bound to an element with <a title="numeric" class="termref" href="#dt-numeric">numeric</a> content, the following constructor might be used to create a new element with the same name and attributes as <code>$e</code> and with numeric content equal to twice the value of <code>$e</code>:</p><div class="exampleInner"><pre xml:space="preserve">element { node-name($e) } { $e/@*, 2 * data($e) }</pre></div><p>In this example, if <code>$e</code> is bound by the expression <code>let $e := &lt;length units="inches"&gt;{ 5 }&lt;/length&gt;</code>, then the result of the example expression is the element <code>&lt;length units="inches"&gt;10&lt;/length&gt;</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a title="static type" class="termref" href="#dt-static-type">static type</a> of the expression <code>fn:node-name($e)</code> is <code>xs:QName?</code>, denoting zero or one QName. The example can be successfully evaluated as written provided that <code>$e</code> is bound to exactly one element node with numeric content.</p></div><p>One important purpose of computed constructors is to allow the name of a node to be computed. We will illustrate this feature by an expression that translates the name of an element from one language to another. Suppose that the variable <code>$dict</code> is bound to a <code>dictionary</code> element containing a sequence of <code>entry</code> elements, each of which encodes translations for a specific word. Here is an example entry that encodes the German and Italian variants of the word “address”:</p><div class="exampleInner"><pre xml:space="preserve">&lt;entry word="address"&gt;
  &lt;variant xml:lang="de"&gt;Adresse&lt;/variant&gt;
  &lt;variant xml:lang="it"&gt;indirizzo&lt;/variant&gt;
&lt;/entry&gt;</pre></div><p>Suppose further that the variable <code>$e</code> is bound to the following element:</p><div class="exampleInner"><pre xml:space="preserve">&lt;address&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/address&gt;</pre></div><p>Then the following expression generates a new element in which the name of <code>$e</code> has been translated into Italian and the content of <code>$e</code> (including its attributes, if any) has been preserved. The first enclosed expression after the <code>element</code> keyword generates the name of the element, and the second enclosed expression generates the content and attributes:</p><div class="exampleInner"><pre xml:space="preserve">element {
  $dict/entry[@word = name($e)]/variant[@xml:lang = "it"]
} {
  $e/@*, $e/node()
}</pre></div><p>The result of this expression is as follows:</p><div class="exampleInner"><pre xml:space="preserve">&lt;indirizzo&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/indirizzo&gt;</pre></div></div><div class="_diffs div4"><h5><a id="id-computedAttributes"></a>4.12.3.2 <a href="#id-computedAttributes" style="text-decoration: none">Computed Attribute Constructors</a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-computed-pis">next</a> | <a href="#id-computedElements">previous</a>)</p><ol><li><p> When the attribute name matches a language keyword such as <code>by</code> or <code>of</code>, it must now be written as a QName literal. This is a backwards incompatible change. <i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/1450">1450</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/1983">1983</a>&nbsp;PRs <a href="https://github.com/qt4cg/qtspecs/pull/1480">1480</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/pull/1989">1989</a>&nbsp;3 October 2024]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompAttrConstructor"></a><code><a href="#prod-xquery40-CompAttrConstructor">CompAttrConstructor</a></code></td><td>::=</td><td><code>"attribute" <a href="#doc-xquery40-CompAttrConstructor-CompNodeName">CompNodeName</a><a href="#doc-xquery40-CompAttrConstructor-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompAttrConstructor-CompNodeName"></a><code><a href="#prod-xquery40-CompNodeName">CompNodeName</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-CompAttrConstructor-QNameLiteral">QNameLiteral</a> | <a href="#doc-xquery40-CompAttrConstructor-UnreservedName">UnreservedName</a> | ("{" <a href="#doc-xquery40-CompAttrConstructor-Expr">Expr</a> "}")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompAttrConstructor-QNameLiteral"></a><code><a href="#prod-xquery40-QNameLiteral">QNameLiteral</a></code></td><td>::=</td><td><code>"#" <a href="#doc-xquery40-CompAttrConstructor-EQName">EQName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompAttrConstructor-UnreservedName"></a><code><a href="#prod-xquery40-UnreservedName">UnreservedName</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-CompAttrConstructor-EQName">EQName</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-unreserved-name">xgc: unreserved-name</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompAttrConstructor-EQName"></a><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-QName">QName</a> | <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompAttrConstructor-Expr"></a><code><a href="#prod-xquery40-Expr">Expr</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-ExprSingle">ExprSingle</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompAttrConstructor-EnclosedExpr"></a><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td>::=</td><td><code>"{" <a href="#doc-xquery40-CompAttrConstructor-Expr">Expr</a>? "}"</code></td></tr></tbody></table><p>A computed attribute constructor creates a new attribute node, with its own node identity.</p><p>Attributes have no default namespace. The rules that expand attribute names create an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> prefix if an attribute name has a namespace URI but no prefix is provided.</p><p>The attribute name may be provided in a number of ways:</p><ol class="enumar"><li><p>As a QName literal, for example:</p><blockquote><p><code>attribute #width {}</code><br><code>attribute #xsi:type {}</code><br><code>attribute #Q{}width {}</code><br><code>attribute #Q{http://www.w3.org/2001/XMLSchema-instance}xsi:type {}</code><br><code>attribute #Q{http://www.w3.org/2001/XMLSchema-instance}type {}</code></p></blockquote><p>A QName literal written as an unprefixed <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a> (the first form above) is resolved using the <b>no-namespace rule</b><a title="no-namespace rule" class="termref" href="#dt-no-namespace-rule">no-namespace rule</a>.</p><p>Note that the last example (<code>#Q{http://www.w3.org/2001/XMLSchema-instance}type</code>) will result in the name of the constructed attribute having a system-generated prefix.</p></li><li><p>As a simple <a href="#doc-xquery40-EQName">EQName</a>, for example:</p><blockquote><p><code>attribute width {}</code><br><code>attribute xsi:type {}</code><br><code>attribute Q{}width {}</code><br><code>attribute Q{http://www.w3.org/2001/XMLSchema-instance}xsi:type {}</code><br><code>attribute Q{http://www.w3.org/2001/XMLSchema-instance}type {}</code></p></blockquote><p>In XQuery 4.0 the first form (using an unprefixed <a title="lexical QName" class="termref" href="#dt-qname">lexical QName</a>) is allowed only if the attribute name is not a reserved keyword (such as <code>div</code> or <code>value</code>): see <a href="#parse-note-unreserved-name">unreserved-name</a>. In all other cases, the effect is exactly the same as when a leading <code>#</code> is added to turn the EQName into a QName literal.</p><p>This syntax is retained for compatibility, but is deprecated.</p></li><li><p>As an expression in curly brackets. This is processed as follows:</p><ol class="enumla"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the result of the <a title="name expression" class="termref" href="#dt-name-expression">name expression</a>. If the result of <a title="atomization" class="termref" href="#dt-atomization">atomization</a> is not a single atomic item of type <code>xs:QName</code>, <code>xs:string</code>, or <code>xs:untypedAtomic</code>, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>If the atomized value of the <a title="name expression" class="termref" href="#dt-name-expression">name expression</a> is of type <code>xs:QName</code>:</p><ol class="enumlr"><li><p>If the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> returned by the atomized name expression has a namespace URI but has no prefix, it is given an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> prefix.</p></li><li><p>The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (including its prefix) is used as the <code>node-name</code> property of the constructed attribute node.</p></li></ol></li><li><p>If the atomized value of the <a title="name expression" class="termref" href="#dt-name-expression">name expression</a> is of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, that value is converted to an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a><span>as follows:</span></p><ol class="enumlr"><li><p>Leading and trailing whitespace is removed.</p></li><li><p>If the value is a lexical QName, it is expanded using the <a title="no-namespace rule" class="termref" href="#dt-no-namespace-rule">no-namespace rule</a>.</p></li><li><p>If the value is in the form of a <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a> (<code>Q{uri}local</code> or <code>Q{uri}prefix:local</code>), it is converted to an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> with the supplied namespace URI, local name, and prefix, or with an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation dependent</a> prefix if none is supplied.</p></li><li><p>If conversion of the atomized name expression to an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is not successful, a dynamic error is raised [<a href="#ERRXQDY0074" title="err:XQDY0074">err:XQDY0074</a>].</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>This was under-specified in XQuery 3.1.</p></div></li></ol></li></ol><p>The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (including its prefix) is used as the <code>node-name</code> property of the constructed attribute node. If expansion of the QName is not successful, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>].</p><p>If the keyword <code>attribute</code> is followed by a <a title="name expression" class="termref" href="#dt-name-expression">name expression</a>, the name expression is processed as follows:</p><p>A <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0044" title="err:XQDY0044">err:XQDY0044</a>] if the node-name of the constructed attribute node has any of the following properties: </p><ul><li><p>Its namespace prefix is <code>xmlns</code>. </p></li><li><p>It has no namespace prefix and its local name is <code>xmlns</code>. </p></li><li><p>Its namespace URI is <code>http://www.w3.org/2000/xmlns/</code>. </p></li><li><p>Its namespace prefix is <code>xml</code> and its namespace URI is not <code>http://www.w3.org/XML/1998/namespace</code>. </p></li><li><p>Its namespace prefix is other than <code>xml</code> and its namespace URI is <code>http://www.w3.org/XML/1998/namespace</code>. </p></li></ul><p>The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a computed attribute constructor is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the result of the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a>, converting it to a sequence of atomic items. (If the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> is absent, the result of this step is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.)</p></li><li><p>If the result of atomization is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the value of the attribute is the zero-length string. Otherwise, each atomic item in the atomized sequence is cast into a string.</p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. The resulting string becomes the <code>string-value</code> property of the new attribute node. The <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> (<code>type-name</code> property) of the new attribute node is <code>xs:untypedAtomic</code>. The <code>typed-value</code> property of the attribute node is the same as its <code>string-value</code>, as an instance of <code>xs:untypedAtomic</code>.</p></li><li><p>The <code>parent</code> property of the attribute node is set to empty.</p></li><li><p>If the attribute name is <code>xml:id</code>, then <code>xml:id</code> processing is performed as defined in <a href="#XMLID">[XML ID]</a>. This ensures that the attribute node has the type <code>xs:ID</code> and that its value is properly normalized. If an error is encountered during <code>xml:id</code> processing, an implementation may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0091" title="err:XQDY0091">err:XQDY0091</a>].</p></li><li><p>If the attribute name is <code>xml:id</code>, the <code>is-id</code> property of the resulting attribute node is set to <code>true</code>; otherwise the <code>is-id</code> property is set to <code>false</code>. The <code>is-idrefs</code> property of the attribute node is unconditionally set to <code>false</code>.</p></li><li><p>If the attribute name is <code>xml:space</code> and the attribute value is other than <code>preserve</code> or <code>default</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> may be raised [<a href="#ERRXQDY0092" title="err:XQDY0092">err:XQDY0092</a>].</p></li></ol><ul><li><p>Example:</p><div class="exampleInner"><pre xml:space="preserve">attribute size { 4 + 3 }</pre></div><p>The <a title="string value" class="termref" href="#dt-string-value">string value</a> of the <code>size</code> attribute is <code>"7"</code> and its type is <code>xs:untypedAtomic</code>.</p></li><li><p>Example:</p><div class="exampleInner"><pre xml:space="preserve">attribute {
  if ($sex = "M") then "husband" else "wife"
} {
  &lt;a&gt;Hello&lt;/a&gt;, 1 to 3, &lt;b&gt;Goodbye&lt;/b&gt;
}</pre></div><p>The name of the constructed attribute is either <code>husband</code> or <code>wife</code>. Its <a title="string value" class="termref" href="#dt-string-value">string value</a> is "<code>Hello 1 2 3 Goodbye</code>".</p></li></ul></div><div class="_diffs div4"><h5><a id="id-textConstructors"></a>4.12.3.4 <a href="#id-textConstructors" style="text-decoration: none">Text Node Constructors</a></h5><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompTextConstructor"></a><code><a href="#prod-xquery40-CompTextConstructor">CompTextConstructor</a></code></td><td>::=</td><td><code>"text" <a href="#doc-xquery40-CompTextConstructor-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompTextConstructor-EnclosedExpr"></a><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td>::=</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td></tr></tbody></table><p>All text node constructors are computed constructors. The result of a text node constructor is a new text node, with its own node identity.</p><p>The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a text node constructor is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the value of the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a>, converting it to a sequence of atomic items.</p></li><li><p>If the result of atomization is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, no text node is constructed. Otherwise, each atomic item in the atomized sequence is cast into a string.</p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. The resulting string becomes the <code>content</code> property of the constructed text node.</p></li></ol><p>The <code>parent</code> property of the constructed text node is set to empty.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is possible for a text node constructor to construct a text node containing a zero-length string. However, if used in the content of a constructed element or document node, such a text node will be deleted or merged with another text node.</p></div><p>The following example illustrates a text node constructor:</p><div class="exampleInner"><pre xml:space="preserve">text { "Hello" }</pre></div></div><div class="_diffs div4"><h5><a id="id-computed-pis"></a>4.12.3.5 <a href="#id-computed-pis" style="text-decoration: none">Computed Processing Instruction Constructors</a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-computed-namespaces">next</a> | <a href="#id-computedAttributes">previous</a>)</p><ol><li><p> When the processing instruction name matches a language keyword such as <code>try</code> or <code>validate</code>, it must now be written with a preceding <code>#</code> character. This is a backwards incompatible change. <i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/1512">1512</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/2027">2027</a>&nbsp;PRs <a href="https://github.com/qt4cg/qtspecs/pull/1513">1513</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/pull/2028">2028</a>&nbsp;18 October 2024]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompPIConstructor"></a><code><a href="#prod-xquery40-CompPIConstructor">CompPIConstructor</a></code></td><td>::=</td><td><code>"processing-instruction" <a href="#doc-xquery40-CompPIConstructor-CompNodeNCName">CompNodeNCName</a><a href="#doc-xquery40-CompPIConstructor-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompPIConstructor-CompNodeNCName"></a><code><a href="#prod-xquery40-CompNodeNCName">CompNodeNCName</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-CompPIConstructor-MarkedNCName">MarkedNCName</a> | <a href="#doc-xquery40-CompPIConstructor-UnreservedNCName">UnreservedNCName</a> | ("{" <a href="#doc-xquery40-CompPIConstructor-Expr">Expr</a> "}")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompPIConstructor-MarkedNCName"></a><code><a href="#prod-xquery40-MarkedNCName">MarkedNCName</a></code></td><td>::=</td><td><code>"#" <a href="#prod-xquery40-NCName">NCName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompPIConstructor-UnreservedNCName"></a><code><a href="#prod-xquery40-UnreservedNCName">UnreservedNCName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-NCName">NCName</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-unreserved-name">xgc: unreserved-name</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompPIConstructor-Expr"></a><code><a href="#prod-xquery40-Expr">Expr</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-ExprSingle">ExprSingle</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompPIConstructor-EnclosedExpr"></a><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td>::=</td><td><code>"{" <a href="#doc-xquery40-CompPIConstructor-Expr">Expr</a>? "}"</code></td></tr></tbody></table><p>A computed processing instruction constructor (<a href="#doc-xquery40-CompPIConstructor">CompPIConstructor</a>) constructs a new processing instruction node with its own node identity. </p><p>The name of a processing instruction node is always an NCName, and may be provided in a number of ways:</p><ol class="enumar"><li><p>As an <code>NCName</code> with a preceding <code>#</code> sign, for example <code>processing-instruction #xref {}</code>. </p></li><li><p>As a simple <code>NCName</code> without the preceding <code>#</code>, for example <code>processing-instruction xref {}</code>. This form is allowed only if the name is not a reserved keyword: see <a href="#parse-note-unreserved-name">unreserved-name</a>.</p></li><li><p>As an expression in curly braces. This is processed as follows:</p><ol class="enumla"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the value of the <a title="name expression" class="termref" href="#dt-name-expression">name expression</a>. If the result of <a title="atomization" class="termref" href="#dt-atomization">atomization</a> is not a single atomic item of type <code>xs:NCName</code>, <code>xs:string</code>, or <code>xs:untypedAtomic</code>, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>If the atomized value of the <a title="name expression" class="termref" href="#dt-name-expression">name expression</a> is of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, that value is cast to the type <code>xs:NCName</code>. If the value cannot be cast to <code>xs:NCName</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0041" title="err:XQDY0041">err:XQDY0041</a>].</p></li><li><p>The resulting NCName is then used as the <code>target</code> property of the newly constructed processing instruction node. However, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised if the NCName is equal to <code>"XML"</code> (in any combination of upper and lower case) [<a href="#ERRXQDY0064" title="err:XQDY0064">err:XQDY0064</a>].</p></li></ol></li></ol><p>The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a computed processing instruction constructor is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the value of the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a>, converting it to a sequence of atomic items. (If the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> is absent, the result of this step is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.)</p></li><li><p><span style="display: none;" class="delete_version">If the result of atomization is an empty sequence, it is replaced by a zero-length string. Otherwise, each atomic item in the atomized sequence is cast into a string. If any of the resulting strings contains the string <code>"?&gt;"</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0026" title="err:XQDY0026">err:XQDY0026</a>] is raised.</span><span style="display: none;" class="add_version">If the result of atomization is the empty sequence, it is replaced by a zero-length string. Otherwise, each atomic item in the atomized sequence is cast into a string. If any of the resulting strings contains the string <code>"?&gt;"</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0026" title="err:XQDY0026">err:XQDY0026</a>] is raised.</span><span class="modify_version">If the result of atomization is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, it is replaced by a zero-length string. Otherwise, each atomic item in the atomized sequence is cast into a string. If any of the resulting strings contains the string <code>"?&gt;"</code>, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0026" title="err:XQDY0026">err:XQDY0026</a>] is raised.</span></p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. Leading whitespace is removed from the resulting string. The resulting string then becomes the <code>content</code> property of the constructed processing instruction node.</p></li></ol><p>The remaining properties of the new processing instruction node are determined as follows:</p><ol class="enumar"><li><p>The <code>parent</code> property is empty.</p></li><li><p>The <code>base-uri</code> property is empty.</p></li></ol><p>The following example illustrates a computed processing instruction constructor:</p><div class="exampleInner"><pre xml:space="preserve">let $target := "audio-output",
return processing-instruction { $target } { "beep" }</pre></div><p>The processing instruction node constructed by this example might be serialized as follows:</p><div class="exampleInner"><pre xml:space="preserve">&lt;?audio-output beep?&gt;</pre></div></div><div class="_diffs div4"><h5><a id="id-computed-comments"></a>4.12.3.6 <a href="#id-computed-comments" style="text-decoration: none">Computed Comment Constructors</a></h5><a id="d2e33323"></a><a id="d2e33320"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompCommentConstructor"></a><code><a href="#prod-xquery40-CompCommentConstructor">CompCommentConstructor</a></code></td><td>::=</td><td><code>"comment" <a href="#doc-xquery40-CompCommentConstructor-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompCommentConstructor-EnclosedExpr"></a><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td>::=</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td></tr></tbody></table><p>A computed comment constructor (<a href="#doc-xquery40-CompCommentConstructor">CompCommentConstructor</a>) constructs a new comment node with its own node identity. The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a computed comment constructor is processed as follows:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the value of the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a>, converting it to a sequence of atomic items.</p></li><li><p>If the result of atomization is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, it is replaced by a zero-length string. Otherwise, each atomic item in the atomized sequence is cast into a string.</p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair. The resulting string becomes the <code>content</code> property of the constructed comment node.</p></li><li><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0072" title="err:XQDY0072">err:XQDY0072</a>] if the result of the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of a computed comment constructor contains two adjacent hyphens or ends with a hyphen.</p></li></ol><p>The <code>parent</code> property of the constructed comment node is set to empty.</p><p>The following example illustrates a computed comment constructor:</p><div class="exampleInner"><pre xml:space="preserve">let $homebase := "Houston"
return comment { concat($homebase, ", we have a problem.") }</pre></div><p>The comment node constructed by this example might be serialized as follows:</p><div class="exampleInner"><pre xml:space="preserve">&lt;!--Houston, we have a problem.--&gt;</pre></div></div><div class="_diffs div4"><h5><a id="id-computed-namespaces"></a>4.12.3.7 <a href="#id-computed-namespaces" style="text-decoration: none">Computed Namespace Constructors</a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-xquery-for-clause">next</a> | <a href="#id-computed-pis">previous</a>)</p><ol><li><p> When the namespace prefix matches a language keyword such as <code>as</code> or <code>at</code>, it must now be written with a preceding <code>#</code> character. This is a backwards incompatible change. <i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/1512">1512</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/2027">2027</a>&nbsp;PRs <a href="https://github.com/qt4cg/qtspecs/pull/1513">1513</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/pull/2028">2028</a>&nbsp;18 October 2024]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompNamespaceConstructor"></a><code><a href="#prod-xquery40-CompNamespaceConstructor">CompNamespaceConstructor</a></code></td><td>::=</td><td><code>"namespace" <a href="#doc-xquery40-CompNamespaceConstructor-CompNodeNCName">CompNodeNCName</a><a href="#doc-xquery40-CompNamespaceConstructor-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompNamespaceConstructor-CompNodeNCName"></a><code><a href="#prod-xquery40-CompNodeNCName">CompNodeNCName</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-CompNamespaceConstructor-MarkedNCName">MarkedNCName</a> | <a href="#doc-xquery40-CompNamespaceConstructor-UnreservedNCName">UnreservedNCName</a> | ("{" <a href="#doc-xquery40-CompNamespaceConstructor-Expr">Expr</a> "}")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompNamespaceConstructor-MarkedNCName"></a><code><a href="#prod-xquery40-MarkedNCName">MarkedNCName</a></code></td><td>::=</td><td><code>"#" <a href="#prod-xquery40-NCName">NCName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompNamespaceConstructor-UnreservedNCName"></a><code><a href="#prod-xquery40-UnreservedNCName">UnreservedNCName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-NCName">NCName</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-unreserved-name">xgc: unreserved-name</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompNamespaceConstructor-Expr"></a><code><a href="#prod-xquery40-Expr">Expr</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-ExprSingle">ExprSingle</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CompNamespaceConstructor-EnclosedExpr"></a><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td>::=</td><td><code>"{" <a href="#doc-xquery40-CompNamespaceConstructor-Expr">Expr</a>? "}"</code></td></tr></tbody></table><p>A computed namespace constructor creates a new namespace node, with its own node identity. The parent of the newly created namespace node is absent.</p><p>The name of a namespace node is always an <code>NCName</code>, and represents the namespace prefix.</p><p>The string value of a namespace node should be a <code>URI</code>, and represents the namespace URI.</p><p>The namespace prefix may be provided in a number of ways:</p><ol class="enumar"><li><p>As an <code>NCName</code> with a preceding <code>#</code> sign, for example <code>namespace #xlink { "http://www.w3.org/1999/xlink" }</code>. </p></li><li><p>As a simple <code>NCName</code> with no preceding <code>#</code> sign, for example <code>namespace xlink { "http://www.w3.org/1999/xlink" }</code>. This form is allowed only if the namespace prefix is not a reserved keyword: see <a href="#parse-note-unreserved-name">unreserved-name</a>.</p></li><li><p>As an expression in curly braces. This is processed as follows:</p><ol class="enumla"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the result of the enclosed expression.</p></li><li><p><span style="display: none;" class="delete_version"> If the result of <a title="atomization" class="termref" href="#dt-atomization">atomization</a> is an empty sequence or a single atomic item of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, then the following rules are applied in order:</span><span style="display: none;" class="add_version"> If the result of <a title="atomization" class="termref" href="#dt-atomization">atomization</a> is the empty sequence or a single atomic item of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, then the following rules are applied in order:</span><span class="modify_version"> If the result of <a title="atomization" class="termref" href="#dt-atomization">atomization</a> is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence or a single atomic item of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, then the following rules are applied in order:</span></p><ol class="enumlr"><li><p>If the result is castable to <code>xs:NCName</code>, then it is used as the local name of the newly constructed namespace node. (The local name of a namespace node represents the prefix part of the <a title="namespace binding" class="termref" href="#dt-namespace-binding">namespace binding</a>.)</p></li><li><p>If the result is the empty sequence or a zero-length <code>xs:string</code> or <code>xs:untypedAtomic</code> item, the new namespace node has no name (such a namespace node represents a binding for the default namespace).</p></li><li><p>Otherwise, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised [<a href="#ERRXQDY0074" title="err:XQDY0074">err:XQDY0074</a>].</p></li></ol></li><li><p><span style="display: none;" class="delete_version">If the result of atomization is not an empty sequence or a single atomic item of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</span><span style="display: none;" class="add_version">If the result of atomization is not the empty sequence or a single atomic item of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</span><span class="modify_version">If the result of atomization is not <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence or a single atomic item of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</span></p></li></ol></li></ol><p>The <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> is evaluated, and the result is cast to <code>xs:anyURI</code> to create the <code>URI</code> property for the newly created node. An implementation may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> [<a href="#ERRXQDY0074" title="err:XQDY0074">err:XQDY0074</a>] if the <code>URIExpr</code> of a computed namespace constructor is not a valid instance of <code>xs:anyURI</code>.</p><p>An error [<a href="#ERRXQDY0101" title="err:XQDY0101">err:XQDY0101</a>] is raised if a computed namespace constructor attempts to do any of the following:</p><ul><li><p>Bind the prefix <code>xml</code> to some namespace URI other than <code>http://www.w3.org/XML/1998/namespace</code>. </p></li><li><p>Bind a prefix other than <code>xml</code> to the namespace URI <code>http://www.w3.org/XML/1998/namespace</code>. </p></li><li><p>Bind the prefix <code>xmlns</code> to any namespace URI. </p></li><li><p>Bind a prefix to the namespace URI <code>http://www.w3.org/2000/xmlns/</code>. </p></li><li><p>Bind any prefix (including the empty prefix) to a zero-length namespace URI.</p></li></ul><p>By itself, a computed namespace constructor has no effect on the <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a> of any element, but if an element constructor’s content sequence contains a namespace node, the <a title="namespace binding" class="termref" href="#dt-namespace-binding">namespace binding</a> it represents is added to that element’s <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a>.</p><p>A computed namespace constructor has no effect on the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The newly created namespace node has all properties defined for a namespace node in the data model, but its parent is always absent. As defined in the data model, the name of the node is the prefix, the string value of the node is the URI. Since the nodes are parentless, their relative order is implementation dependent.</p></div><p>Examples:</p><ul><li><p>A computed namespace constructor with a prefix:</p><div class="exampleInner"><pre xml:space="preserve">namespace a { "http://a.example.com" }</pre></div></li><li><p>A computed namespace constructor with a prefix expression:</p><div class="exampleInner"><pre xml:space="preserve">namespace { "a" } { "http://a.example.com" }</pre></div></li><li><p>A computed namespace constructor with <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty prefix:</p><div class="exampleInner"><pre xml:space="preserve">namespace "" { "http://a.example.com" }</pre></div></li></ul><p>Computed namespace constructors are generally used to add to the <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a> of elements created with element constructors:</p><div class="exampleInner"><pre xml:space="preserve">&lt;age xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; {
  namespace xs { "http://www.w3.org/2001/XMLSchema" },
  attribute xsi:type { "xs:integer" },
  23
}&lt;/age&gt;</pre></div><p>In the above example, note that the <code>xsi</code><a title="namespace binding" class="termref" href="#dt-namespace-binding">namespace binding</a> is created for the element because it is used in an attribute name. The attribute’s content is simply character data, and has no effect on namespace bindings. The computed namespace constructor ensures that the <code>xs</code> binding is created.</p><p>Computed namespace constructors have no effect on the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>. If the prefix a is not already defined in the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>, the following expression results in a static error [<a href="#ERRXPST0081" title="err:XPST0081">err:XPST0081</a>].</p><div class="exampleInner"><pre xml:space="preserve">&lt;a:form&gt;{
  namespace a { "http://a.example.com" }
}&lt;/a:form&gt;</pre></div></div></div></div><div class="_diffs div2"><h3><a id="id-flwor-expressions"></a>4.13 <a href="#id-flwor-expressions" style="text-decoration: none"><span class="xquery">FLWOR Expressions</span></a></h3><p class="xquery">XQuery provides a versatile expression called a FLWOR expression that may contain multiple clauses. The FLWOR expression can be used for many purposes, including iterating over sequences, joining multiple documents, and performing grouping and aggregation. The name FLWOR, pronounced "flower", is suggested by the keywords <code>for</code>, <code>let</code>, <code>where</code>, <code>order by</code>, and <code>return</code>, which introduce some of the clauses used in FLWOR expressions (but this is not a complete list of such clauses.)</p><p class="xquery">The overall syntax of a FLWOR expression is shown here, and relevant parts of the syntax are expanded in subsequent sections.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FLWORExpr"></a><code><a href="#prod-xquery40-FLWORExpr">FLWORExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-FLWORExpr-InitialClause">InitialClause</a><a href="#doc-xquery40-FLWORExpr-IntermediateClause">IntermediateClause</a>* <a href="#doc-xquery40-FLWORExpr-ReturnClause">ReturnClause</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FLWORExpr-InitialClause"></a><code><a href="#prod-xquery40-InitialClause">InitialClause</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-FLWORExpr-ForClause">ForClause</a> | <a href="#doc-xquery40-FLWORExpr-LetClause">LetClause</a> | <a href="#doc-xquery40-FLWORExpr-WindowClause">WindowClause</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FLWORExpr-ForClause"></a><code><a href="#prod-xquery40-ForClause">ForClause</a></code></td><td>::=</td><td><code>"for" (<a href="#prod-xquery40-ForBinding">ForBinding</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FLWORExpr-LetClause"></a><code><a href="#prod-xquery40-LetClause">LetClause</a></code></td><td>::=</td><td><code>"let" (<a href="#prod-xquery40-LetBinding">LetBinding</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FLWORExpr-WindowClause"></a><code><a href="#prod-xquery40-WindowClause">WindowClause</a></code></td><td>::=</td><td><code>"for" (<a href="#prod-xquery40-TumblingWindowClause">TumblingWindowClause</a> | <a href="#prod-xquery40-SlidingWindowClause">SlidingWindowClause</a>)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FLWORExpr-IntermediateClause"></a><code><a href="#prod-xquery40-IntermediateClause">IntermediateClause</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-FLWORExpr-InitialClause">InitialClause</a> | <a href="#doc-xquery40-FLWORExpr-WhereClause">WhereClause</a> | <a href="#doc-xquery40-FLWORExpr-WhileClause">WhileClause</a> | <a href="#doc-xquery40-FLWORExpr-GroupByClause">GroupByClause</a> | <a href="#doc-xquery40-FLWORExpr-OrderByClause">OrderByClause</a> | <a href="#doc-xquery40-FLWORExpr-CountClause">CountClause</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FLWORExpr-WhereClause"></a><code><a href="#prod-xquery40-WhereClause">WhereClause</a></code></td><td>::=</td><td><code>"where" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FLWORExpr-WhileClause"></a><code><a href="#prod-xquery40-WhileClause">WhileClause</a></code></td><td>::=</td><td><code>"while" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FLWORExpr-GroupByClause"></a><code><a href="#prod-xquery40-GroupByClause">GroupByClause</a></code></td><td>::=</td><td><code>"group" "by" (<a href="#prod-xquery40-GroupingSpec">GroupingSpec</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FLWORExpr-OrderByClause"></a><code><a href="#prod-xquery40-OrderByClause">OrderByClause</a></code></td><td>::=</td><td><code>"stable"? "order" "by" (<a href="#prod-xquery40-OrderSpec">OrderSpec</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FLWORExpr-CountClause"></a><code><a href="#prod-xquery40-CountClause">CountClause</a></code></td><td>::=</td><td><code>"count" <a href="#prod-xquery40-VarName">VarName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FLWORExpr-ReturnClause"></a><code><a href="#prod-xquery40-ReturnClause">ReturnClause</a></code></td><td>::=</td><td><code>"return" <a href="#doc-xquery40-ExprSingle">ExprSingle</a></code></td></tr></tbody></table><p class="xquery">The semantics of FLWOR expressions are based on a concept called a <b>tuple stream</b>. [<a id="id-tuple-stream-foobar" title="tuple stream">Definition</a>: A <b>tuple stream</b> is an ordered sequence of zero or more <b>tuples</b>.] [<a id="id-tuple-foobar" title="tuple">Definition</a>: A <b>tuple</b> is a set of zero or more named variables, each of which is bound to a value that is an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a>.] Each tuple stream is homogeneous in the sense that all its tuples contain variables with the same names and the same <a title="static type" class="termref" href="#dt-static-type">static types</a>. The following example illustrates a tuple stream consisting of four tuples, each containing three variables named <code>$x</code>, <code>$y</code>, and <code>$z</code>:</p><div class="exampleInner"><pre xml:space="preserve">($x = 1003, $y = "Fred", $z = &lt;age&gt;21&lt;/age&gt;)
($x = 1017, $y = "Mary", $z = &lt;age&gt;35&lt;/age&gt;)
($x = 1020, $y = "Bill", $z = &lt;age&gt;18&lt;/age&gt;)
($x = 1024, $y = "John", $z = &lt;age&gt;29&lt;/age&gt;)</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In this section, tuple streams are represented as shown in the above example. Each tuple is on a separate line and is enclosed in parentheses, and the variable bindings inside each tuple are separated by commas. This notation does not represent XQuery syntax, but is simply a representation of a tuple stream for the purpose of defining the semantics of FLWOR expressions.</p></div><p class="xquery">Tuples and tuple streams are not part of the <a title="data model" class="termref" href="#dt-datamodel">data model</a>. They exist only as conceptual intermediate results during the processing of a FLWOR expression.</p><p class="xquery">Conceptually, the first clause generates a tuple stream. Each clause between the first clause and the return clause takes the tuple stream generated by the previous clause as input and generates a (possibly different) tuple stream as output. The return clause takes a tuple stream as input and, for each tuple in this tuple stream, generates an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a>; the final result of the FLWOR expression is the ordered concatenation of these <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instances</a>.</p><p class="xquery">The initial clause in a FLWOR expression may be a <code>for</code>, <code>let</code>, or <code>window</code> clause. Intermediate clauses may be <code>for</code>, <code>let</code>, <code>window</code>, <code>count</code>, <code>where</code>, <code>group by</code>, or <code>order by</code> clauses. These intermediate clauses may be repeated as many times as desired, in any order. The final clause of the FLWOR expression must be a <code>return</code> clause. The semantics of the various clauses are described in the following sections.</p><div class="_diffs div3 xquery"><h4><a id="id-xquery-for-clause"></a>4.13.2 <a href="#id-xquery-for-clause" style="text-decoration: none">For Clause</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-xquery-let-clause">next</a> | <a href="#id-computed-namespaces">previous</a>)</p><ol><li><p>A <code>for member</code> clause is added to FLWOR expressions to allow iteration over an array. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/49">49</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/344">344</a>&nbsp;10 February 2023]</i></p></li><li><p>A <code>for key/value</code> clause is added to FLWOR expressions to allow iteration over a map. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/31">31</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1249">1249</a>&nbsp;1 June 2024]</i></p></li><li><p> The value bound to a variable in a <code>for</code> clause is now converted to the declared type by applying the coercion rules. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/189">189</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/820">820</a>&nbsp;8 November 2023]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForClause"></a><code><a href="#prod-xquery40-ForClause">ForClause</a></code></td><td>::=</td><td><code>"for" (<a href="#doc-xquery40-ForClause-ForBinding">ForBinding</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForClause-ForBinding"></a><code><a href="#prod-xquery40-ForBinding">ForBinding</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-ForClause-ForItemBinding">ForItemBinding</a> | <a href="#doc-xquery40-ForClause-ForMemberBinding">ForMemberBinding</a> | <a href="#doc-xquery40-ForClause-ForEntryBinding">ForEntryBinding</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForClause-ForItemBinding"></a><code><a href="#prod-xquery40-ForItemBinding">ForItemBinding</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-ForClause-VarNameAndType">VarNameAndType</a><a href="#doc-xquery40-ForClause-AllowingEmpty">AllowingEmpty</a>? <a href="#doc-xquery40-ForClause-PositionalVar">PositionalVar</a>? "in" <a href="#doc-xquery40-ForClause-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForClause-VarNameAndType"></a><code><a href="#prod-xquery40-VarNameAndType">VarNameAndType</a></code></td><td>::=</td><td><code>"$" <a href="#doc-xquery40-ForClause-EQName">EQName</a><a href="#doc-xquery40-ForClause-TypeDeclaration">TypeDeclaration</a>?</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForClause-EQName"></a><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-QName">QName</a> | <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForClause-TypeDeclaration"></a><code><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a></code></td><td>::=</td><td><code>"as" <a href="#doc-xquery40-ForClause-SequenceType">SequenceType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForClause-SequenceType"></a><code><a href="#prod-xquery40-SequenceType">SequenceType</a></code></td><td>::=</td><td><code>("empty-sequence" "(" ")")<br>| (<a href="#doc-xquery40-ItemType">ItemType</a><a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForClause-AllowingEmpty"></a><code><a href="#prod-xquery40-AllowingEmpty">AllowingEmpty</a></code></td><td>::=</td><td><code>"allowing" "empty"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForClause-PositionalVar"></a><code><a href="#prod-xquery40-PositionalVar">PositionalVar</a></code></td><td>::=</td><td><code>"at" <a href="#doc-xquery40-ForClause-VarName">VarName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForClause-VarName"></a><code><a href="#prod-xquery40-VarName">VarName</a></code></td><td>::=</td><td><code>"$" <a href="#doc-xquery40-ForClause-EQName">EQName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForClause-ExprSingle"></a><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-FLWORExpr">FLWORExpr</a><br>| <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xquery40-SwitchExpr">SwitchExpr</a><br>| <a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#doc-xquery40-IfExpr">IfExpr</a><br>| <a href="#doc-xquery40-TryCatchExpr">TryCatchExpr</a><br>| <a href="#doc-xquery40-OrExpr">OrExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForClause-ForMemberBinding"></a><code><a href="#prod-xquery40-ForMemberBinding">ForMemberBinding</a></code></td><td>::=</td><td><code>"member" <a href="#doc-xquery40-ForClause-VarNameAndType">VarNameAndType</a><a href="#doc-xquery40-ForClause-PositionalVar">PositionalVar</a>? "in" <a href="#doc-xquery40-ForClause-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForClause-ForEntryBinding"></a><code><a href="#prod-xquery40-ForEntryBinding">ForEntryBinding</a></code></td><td>::=</td><td><code>((<a href="#doc-xquery40-ForClause-ForEntryKeyBinding">ForEntryKeyBinding</a><a href="#doc-xquery40-ForClause-ForEntryValueBinding">ForEntryValueBinding</a>?) | <a href="#doc-xquery40-ForClause-ForEntryValueBinding">ForEntryValueBinding</a>) <a href="#doc-xquery40-ForClause-PositionalVar">PositionalVar</a>? "in" <a href="#doc-xquery40-ForClause-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForClause-ForEntryKeyBinding"></a><code><a href="#prod-xquery40-ForEntryKeyBinding">ForEntryKeyBinding</a></code></td><td>::=</td><td><code>"key" <a href="#doc-xquery40-ForClause-VarNameAndType">VarNameAndType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ForClause-ForEntryValueBinding"></a><code><a href="#prod-xquery40-ForEntryValueBinding">ForEntryValueBinding</a></code></td><td>::=</td><td><code>"value" <a href="#doc-xquery40-ForClause-VarNameAndType">VarNameAndType</a></code></td></tr></tbody></table><p>A <code>for</code> clause is used for iteration. Each variable in a <code>for</code> clause iterates over a sequence, an array, or a map.</p><p>The expression following the keyword <code>in</code> is evaluated; we refer to the resulting sequence, array, or map generically as the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>, and to its items, members, or entries as the <code>components</code> of the collection.</p><ul><li><p>When a <a href="#prod-xquery40-ForItemBinding">ForItemBinding</a> is used (that is, when none of the keywords <code>member</code>, <code>key</code>, or <code>value</code> is used), the range variable is bound in turn to each item in the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>, which is treated as a sequence of items.</p></li><li><p>When a <a href="#prod-xquery40-ForItemBinding">ForMemberBinding</a> is used (that is, when the keyword <code>member</code> is used), the range variable is bound in turn to each member of the array.</p><p>In this case the corresponding <code>ExprSingle</code> must evaluate to a single array, otherwise a type error is raised [<a href="#ERRXPTY0141" title="err:XPTY0141">err:XPTY0141</a>]. However, the coercion rules also allow a JNode whose <b>·content·</b> is an array to be supplied.</p></li><li><p>When a <a href="#prod-xquery40-ForItemBinding">ForEntryBinding</a> is used (that is, when either or both of the keywords <code>key</code> and <code>value</code> are used), the <code>key</code> range variable (if present) is bound in turn to each key in the map (in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-entry-order">entry order</a><sup><small>DM</small></sup>), and the <code>value</code> range variable (if present) is bound to the corresponding value.</p><p>In this case the corresponding <code>ExprSingle</code> must evaluate to a single map, otherwise a type error is raised [<a href="#ERRXPTY0141" title="err:XPTY0141">err:XPTY0141</a>]. However, the coercion rules also allow a JNode whose <b>·content·</b> is a map to be supplied.</p><p>If both the <code>key</code> and <code>value</code> variables are declared, their <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> must be distinct [<a href="#ERRXQST0089" title="err:XQST0089">err:XQST0089</a>].</p></li></ul><p>If a <code>for</code> clause contains multiple bindings separated by commas it is semantically equivalent to multiple <code>for</code> clauses, each containing one of the bindings in the original <code>for</code> clause.</p><p>Example:</p><ul><li><p>The clause</p><div class="exampleInner"><pre xml:space="preserve">for $x in $expr1, $y in $expr2</pre></div><p>is semantically equivalent to:</p><div class="exampleInner"><pre xml:space="preserve">for $x in $expr1
for $y in $expr2</pre></div></li><li><p>The clause</p><div class="exampleInner"><pre xml:space="preserve">for member $x in $expr1, member $y in $expr2</pre></div><p>is semantically equivalent to:</p><div class="exampleInner"><pre xml:space="preserve">for member $x in $expr1
for member $y in $expr2</pre></div></li></ul><p>In the remainder of this section, we define the semantics of a <code>for</code> clause containing a single variable and an associated expression (following the keyword <code>in</code>) whose value is the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> for that variable.</p><p>If a single-variable <code>for</code> clause is the initial clause in a FLWOR expression, it iterates over its <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>, binding the variable(s) to each component in turn. The resulting sequence of variable bindings becomes the initial tuple stream that serves as input to the next clause of the FLWOR expression. The order of tuples in the tuple stream preserves the order of the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>.</p><p><span style="display: none;" class="delete_version">If the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding collection</a> is empty, the output tuple stream depends on whether <code>allowing empty</code> is specified. If <code>allowing empty</code> is specified, the output tuple stream consists of one tuple in which the variable is bound to an empty sequence. This option is not available when the keywords <code>member</code>, <code>key</code>, or <code>value</code> are used. If <code>allowing empty</code> is not specified, the output tuple stream consists of zero tuples.</span><span style="display: none;" class="add_version">If the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding collection</a> is empty, the output tuple stream depends on whether <code>allowing empty</code> is specified. If <code>allowing empty</code> is specified, the output tuple stream consists of one tuple in which the variable is bound to the empty sequence. This option is not available when the keywords <code>member</code>, <code>key</code>, or <code>value</code> are used. If <code>allowing empty</code> is not specified, the output tuple stream consists of zero tuples.</span><span class="modify_version">If the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding collection</a> is empty, the output tuple stream depends on whether <code>allowing empty</code> is specified. If <code>allowing empty</code> is specified, the output tuple stream consists of one tuple in which the variable is bound to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. This option is not available when the keywords <code>member</code>, <code>key</code>, or <code>value</code> are used. If <code>allowing empty</code> is not specified, the output tuple stream consists of zero tuples.</span></p><p>The following examples illustrates tuple streams that are generated by initial <code>for</code> clauses:</p><ul><li><p>Initial clause:</p><div class="exampleInner"><pre xml:space="preserve">for $x in (100, 200, 300)</pre></div><p>or (equivalently):</p><div class="exampleInner"><pre xml:space="preserve">for $x allowing empty in (100, 200, 300)</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre xml:space="preserve">($x = 100)
($x = 200)
($x = 300)</pre></div></li><li><p>Initial clause:</p><div class="exampleInner"><pre xml:space="preserve">for $x in ()</pre></div><p>Output tuple stream contains no tuples.</p></li><li><p>Initial clause:</p><div class="exampleInner"><pre xml:space="preserve">for $x allowing empty in ()</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre xml:space="preserve">($x = ())</pre></div></li><li><p>Initial clause:</p><div class="exampleInner"><pre xml:space="preserve">for member $x in [ 1, 2, (5 to 10) ]</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre xml:space="preserve">($x = (1))
($x = (2))
($x = (5, 6, 7, 8, 9, 10)</pre></div></li><li><p>Initial clause:</p><div class="exampleInner"><pre xml:space="preserve">for member $x in []</pre></div><p>Output tuple stream contains no tuples.</p></li><li><p>Initial clause:</p><div class="exampleInner"><pre xml:space="preserve">for key $k value $v in { 'x': 1, 'y': 2 }</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre xml:space="preserve">($k = 'x', $v = 1)
($k = 'y', $v = 2)</pre></div></li></ul><p> [<a id="dt-positional-variable" title="positional variable">Definition</a>: A <b>positional variable</b> is a variable that is preceded by the keyword <code>at</code>.] A positional variable may be associated with the range variable(s) that are bound in a <code>for</code> clause. In this case, as the main range variable(s) iterate over the components of its <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>, the positional variable iterates over the integers that represent the ordinal numbers of these component in the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>, starting with one. Each tuple in the output tuple stream contains bindings for both the main variable and the positional variable. If the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> is empty and <code>allowing empty</code> is specified, the positional variable in the output tuple is bound to the integer zero. Positional variables have the implied type <code>xs:integer</code>.</p><p>The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of a positional variable must be distinct from the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the main variable with which it is associated [<a href="#ERRXQST0089" title="err:XQST0089">err:XQST0089</a>].</p><p>The following examples illustrate how a positional variable would have affected the results of the previous examples that generated tuples:</p><ul><li><p>Initial clause:</p><div class="exampleInner"><pre xml:space="preserve">for $x at $i in (100, 200, 300)</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre xml:space="preserve">($x = 100, $i = 1)
($x = 200, $i = 2)
($x = 300, $i = 3)</pre></div></li><li><p>Initial clause:</p><div class="exampleInner"><pre xml:space="preserve">for $x at $i in [1 to 3, 11 to 13, 21 to 23</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre xml:space="preserve">($x = (1, 2, 3), $i = 1)
($x = (11, 12, 13), $i = 2)
($x = (21, 22, 23), $i = 3)</pre></div></li><li><p>Initial clause:</p><div class="exampleInner"><pre xml:space="preserve">for $x allowing empty at $i in ()</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre xml:space="preserve">($x = (), $i = 0)</pre></div></li></ul><p>If a single-variable <code>for</code> clause is an intermediate clause in a FLWOR expression, its <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> is evaluated for each input tuple, given the bindings in that input tuple. Each input tuple generates zero or more tuples in the output tuple stream. Each of these output tuples consists of the original variable bindings of the input tuple plus a binding of the new variable to one of the items in its <a title="binding collection" class="termref" href="#dt-binding-collection">binding collecction</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Although the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> is conceptually evaluated independently for each input tuple, an optimized implementation may sometimes be able to avoid re-evaluating the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> if it can show that the variables that the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> depends on have the same values as in a previous evaluation.</p></div><p><span style="display: none;" class="delete_version">For a given input tuple, if the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> for the new variable in the <code>for</code> clause <span>is empty (that is, it is an empty sequence or an <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-array">empty array</a><sup><small>DM</small></sup> depending on whether <code>member</code> is specified)</span>, and if <code>allowing empty</code> is not specified, the input tuple generates zero output tuples (it is not represented in the output tuple stream.)</span><span style="display: none;" class="add_version">For a given input tuple, if the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> for the new variable in the <code>for</code> clause <span>is empty (that is, it is the empty sequence or an <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-array">empty array</a><sup><small>DM</small></sup> depending on whether <code>member</code> is specified)</span>, and if <code>allowing empty</code> is not specified, the input tuple generates zero output tuples (it is not represented in the output tuple stream.)</span><span class="modify_version">For a given input tuple, if the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> for the new variable in the <code>for</code> clause <span>is empty (that is, it is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence or an <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-array">empty array</a><sup><small>DM</small></sup> depending on whether <code>member</code> is specified)</span>, and if <code>allowing empty</code> is not specified, the input tuple generates zero output tuples (it is not represented in the output tuple stream.)</span></p><p><span style="display: none;" class="delete_version">The <code>allowing empty</code> option is available only when processing sequences, not when processing arrays or maps. The effect is that if the binding collection is an empty sequence, the input tuple generates one output tuple, with the original variable bindings plus a binding of the new variable to an empty sequence.</span><span style="display: none;" class="add_version">The <code>allowing empty</code> option is available only when processing sequences, not when processing arrays or maps. The effect is that if the binding collection is the empty sequence, the input tuple generates one output tuple, with the original variable bindings plus a binding of the new variable to the empty sequence.</span><span class="modify_version">The <code>allowing empty</code> option is available only when processing sequences, not when processing arrays or maps. The effect is that if the binding collection is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the input tuple generates one output tuple, with the original variable bindings plus a binding of the new variable to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>If a type declaration is present and <code>allowing empty</code> is specified, the type declaration should include an occurrence indicator of <code>"?"</code> to indicate that the variable may be bound to an empty sequence.</p></div><p>If the new variable introduced by a <code>for</code> clause has an associated <a title="positional variable" class="termref" href="#dt-positional-variable">positional variable</a>, the output tuples generated by the <code>for</code> clause also contain bindings for the <a title="positional variable" class="termref" href="#dt-positional-variable">positional variable</a>. In this case, as the new variable is bound to each item in its <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>, the <a title="positional variable" class="termref" href="#dt-positional-variable">positional variable</a> is bound to the ordinal position of that item within the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>, starting with one. Note that, since the <a title="positional variable" class="termref" href="#dt-positional-variable">positional variable</a> represents a position within a <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a>, the output tuples corresponding to each input tuple are independently numbered, starting with one. For a given input tuple, if the <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> is empty and <code>allowing empty</code> is specified, the <a title="positional variable" class="termref" href="#dt-positional-variable">positional variable</a> in the output tuple is bound to the integer zero.</p><p>The tuples in the output tuple stream are ordered primarily by the order of the input tuples from which they are derived, and secondarily by the order of the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> for the new variable; otherwise the order of the output tuple stream is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><p>The following examples illustrates the effects of intermediate <code>for</code> clauses:</p><ul><li><p>Input tuple stream:</p><div class="exampleInner"><pre xml:space="preserve">($x = 1)
($x = 2)
($x = 3)
($x = 4)</pre></div><p>Intermediate <code>for</code> clause:</p><div class="exampleInner"><pre xml:space="preserve">for $y in ($x to 3)</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre xml:space="preserve">($x = 1, $y = 1)
($x = 1, $y = 2)
($x = 1, $y = 3)
($x = 2, $y = 2)
($x = 2, $y = 3)
($x = 3, $y = 3)</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In this example, there is no output tuple that corresponds to the input tuple <code>($x = 4)</code> because, when the <code>for</code> clause is evaluated with the bindings in this input tuple, the resulting <a title="binding collection" class="termref" href="#dt-binding-collection">binding collection</a> for <code>$y</code> is empty.</p></div></li><li><p>This example shows how the previous example would have been affected by a <a title="positional variable" class="termref" href="#dt-positional-variable">positional variable</a> (assuming the same input tuple stream):</p><div class="exampleInner"><pre xml:space="preserve">for $y at $j in ($x to 3)</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre xml:space="preserve">($x = 1, $y = 1, $j = 1)
($x = 1, $y = 2, $j = 2)
($x = 1, $y = 3, $j = 3)
($x = 2, $y = 2, $j = 1)
($x = 2, $y = 3, $j = 2)
($x = 3, $y = 3, $j = 1)</pre></div></li><li><p>This example shows how the previous example would have been affected by <code>allowing empty</code>. Note that <code>allowing empty</code> causes the input tuple <code>($x = 4)</code> to be represented in the output tuple stream, even though the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a> for <code>$y</code> contains no items for this input tuple. This example illustrates that <code>allowing empty</code> in a <code>for</code> clause serves a purpose similar to that of an “outer join” in a relational database query. (Assume the same input tuple stream as in the previous example.)</p><div class="exampleInner"><pre xml:space="preserve">for $y allowing empty at $j in ($x to 3)</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre xml:space="preserve">($x = 1, $y = 1, $j = 1)
($x = 1, $y = 2, $j = 2)
($x = 1, $y = 3, $j = 3)
($x = 2, $y = 2, $j = 1)
($x = 2, $y = 3, $j = 2)
($x = 3, $y = 3, $j = 1)
($x = 4, $y = (), $j = 0)</pre></div></li><li><p>This example illustrates processing of arrays:</p><p>Input tuple stream:</p><div class="exampleInner"><pre xml:space="preserve">($x = 1)
($x = 2)
($x = 3)</pre></div><p>Intermediate <code>for</code> clause:</p><div class="exampleInner"><pre xml:space="preserve">for member $y in [[$x+1, $x+2], [[$x+3, $x+4]]</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre xml:space="preserve">($x = 1, $y = [ 2, 3 ])
($x = 1, $y = [ 4, 5 ])
($x = 2, $y = [ 3, 4 ])
($x = 2, $y = [ 5, 6 ])
($x = 3, $y = [ 4, 5 ])
($x = 3, $y = [ 6, 7 ])</pre></div></li><li><p>This example shows how a <code>for</code> clause that binds two variables is semantically equivalent to two <code>for</code> clauses that bind one variable each. We assume that this <code>for</code> clause occurs at the beginning of a FLWOR expression. It is equivalent to an initial single-variable <code>for</code> clause that provides an input tuple stream to an intermediate single-variable <code>for</code> clause.</p><div class="exampleInner"><pre xml:space="preserve">for $x in (1, 2, 3, 4), $y in ($x to 3)</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre xml:space="preserve">($x = 1, $y = 1)
($x = 1, $y = 2)
($x = 1, $y = 3)
($x = 2, $y = 2)
($x = 2, $y = 3)
($x = 3, $y = 3)</pre></div></li></ul><p>A <code>for</code> clause may contain one or more <a title="type declaration" class="termref" href="#dt-type-declaration">type declarations</a>, identified by the keyword <code>as</code>. The semantics of <a title="type declaration" class="termref" href="#dt-type-declaration">type declarations</a> are defined in <a href="#id-binding-rules"><b>4.13.1 Variable Bindings</b></a>.</p></div><div class="_diffs div3 xquery"><h4><a id="id-xquery-let-clause"></a>4.13.3 <a href="#id-xquery-let-clause" style="text-decoration: none">Let Clause</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-windows">next</a> | <a href="#id-xquery-for-clause">previous</a>)</p><ol><li><p> The value bound to a variable in a <code>let</code> clause is now converted to the declared type by applying the coercion rules. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/189">189</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/254">254</a>&nbsp;29 November 2022]</i></p></li><li><p> Sequences, arrays, and maps can be destructured in a <code>let</code> clause to extract their components into multiple variables. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/37">37</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2055">2055</a>&nbsp;17 June 2025]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LetClause"></a><code><a href="#prod-xquery40-LetClause">LetClause</a></code></td><td>::=</td><td><code>"let" (<a href="#doc-xquery40-LetClause-LetBinding">LetBinding</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LetClause-LetBinding"></a><code><a href="#prod-xquery40-LetBinding">LetBinding</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-LetClause-LetValueBinding">LetValueBinding</a> | <a href="#doc-xquery40-LetClause-LetSequenceBinding">LetSequenceBinding</a> | <a href="#doc-xquery40-LetClause-LetArrayBinding">LetArrayBinding</a> | <a href="#doc-xquery40-LetClause-LetMapBinding">LetMapBinding</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LetClause-LetValueBinding"></a><code><a href="#prod-xquery40-LetValueBinding">LetValueBinding</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-LetClause-VarNameAndType">VarNameAndType</a> ":=" <a href="#doc-xquery40-LetClause-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LetClause-VarNameAndType"></a><code><a href="#prod-xquery40-VarNameAndType">VarNameAndType</a></code></td><td>::=</td><td><code>"$" <a href="#doc-xquery40-LetClause-EQName">EQName</a><a href="#doc-xquery40-LetClause-TypeDeclaration">TypeDeclaration</a>?</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LetClause-EQName"></a><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-QName">QName</a> | <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LetClause-TypeDeclaration"></a><code><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a></code></td><td>::=</td><td><code>"as" <a href="#doc-xquery40-LetClause-SequenceType">SequenceType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LetClause-SequenceType"></a><code><a href="#prod-xquery40-SequenceType">SequenceType</a></code></td><td>::=</td><td><code>("empty-sequence" "(" ")")<br>| (<a href="#doc-xquery40-ItemType">ItemType</a><a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LetClause-ExprSingle"></a><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-FLWORExpr">FLWORExpr</a><br>| <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xquery40-SwitchExpr">SwitchExpr</a><br>| <a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#doc-xquery40-IfExpr">IfExpr</a><br>| <a href="#doc-xquery40-TryCatchExpr">TryCatchExpr</a><br>| <a href="#doc-xquery40-OrExpr">OrExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LetClause-LetSequenceBinding"></a><code><a href="#prod-xquery40-LetSequenceBinding">LetSequenceBinding</a></code></td><td>::=</td><td><code>"$" "(" (<a href="#doc-xquery40-LetClause-VarNameAndType">VarNameAndType</a> ++ ",") ")" <a href="#doc-xquery40-LetClause-TypeDeclaration">TypeDeclaration</a>? ":=" <a href="#doc-xquery40-LetClause-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LetClause-LetArrayBinding"></a><code><a href="#prod-xquery40-LetArrayBinding">LetArrayBinding</a></code></td><td>::=</td><td><code>"$" "[" (<a href="#doc-xquery40-LetClause-VarNameAndType">VarNameAndType</a> ++ ",") "]" <a href="#doc-xquery40-LetClause-TypeDeclaration">TypeDeclaration</a>? ":=" <a href="#doc-xquery40-LetClause-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-LetClause-LetMapBinding"></a><code><a href="#prod-xquery40-LetMapBinding">LetMapBinding</a></code></td><td>::=</td><td><code>"$" "{" (<a href="#doc-xquery40-LetClause-VarNameAndType">VarNameAndType</a> ++ ",") "}" <a href="#doc-xquery40-LetClause-TypeDeclaration">TypeDeclaration</a>? ":=" <a href="#doc-xquery40-LetClause-ExprSingle">ExprSingle</a></code></td></tr></tbody></table><p>The purpose of a <code>let</code> clause is to bind values to one or more variables. Each variable is bound to the result of evaluating an expression.</p><p>If a <code>let</code> clause declares multiple variables separated by commas, it is semantically equivalent to multiple <code>let</code> clauses, each containing a single variable. For example, the clause</p><div class="exampleInner"><pre xml:space="preserve">let $x := $expr1, $y := $expr2</pre></div><p>is semantically equivalent to the following sequence of clauses:</p><div class="exampleInner"><pre xml:space="preserve">let $x := $expr1
let $y := $expr2</pre></div><p>After performing this expansion, the effect of a <code>let</code> clause is as follows:</p><ol class="enumar"><li><p>If the let expression uses multiple variables, it is first expanded to a set of nested let expressions, each of which uses only one variable. Specifically, any separating comma is replaced by <code>let</code>.</p><div class="example"><div class="exampleHeader"><a id="d2e35269"></a><a id="d2e35266"></a>Example:</div><p>The expression:</p><div class="exampleInner"><pre xml:space="preserve">let $x := 4, $y := 3 return $x + $y</pre></div><p>is expanded to:</p><div class="exampleInner"><pre xml:space="preserve">let $x := 4 let $y := 3 return $x + $y</pre></div></div></li><li><p>In a <a href="#prod-xquery40-LetValueBinding">LetValueBinding</a> such as <code>let $<var>V</var> as <var>T</var> := <var>EXPR</var></code>:</p><ol class="enumla"><li><p>The variable <var>V</var> is declared as a <b>range variable</b>.</p></li><li><p>The sequence type <var>T</var> is called the <b>declared type</b>. If there is no declared type, then <code>item()*</code> is assumed.</p></li><li><p>The expression <var>EXPR</var> is evaluated, and its value is converted to the declared type by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. The resulting value forms the <b>binding sequence</b> for the range variable.</p></li></ol></li><li><p>In a <a href="#prod-xquery40-LetSequenceBinding">LetSequenceBinding</a> such as <code>let $( $<var>A<sub>1</sub></var> as <var>T<sub>1</sub></var>, $<var>A<sub>2</sub></var> as <var>T<sub>2</sub></var>, ... , $<var>A<sub>n</sub></var> as <var>T<sub>n</sub></var> ) as <var>ST</var> := <var>EXPR</var></code>:</p><ol class="enumla"><li><p>The sequence type <var>ST</var> is called the <b>declared sequence type</b>. If there is no declared sequence type, then <code>item()*</code> is assumed.</p></li><li><p>The expression <var>EXPR</var> is evaluated, and its value is converted to the declared sequence type <var>ST</var> by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. Call the resulting (coerced) value <var>V</var>.</p></li><li><p>Each variable <var>A<sub>i</sub></var> (for <var>i</var> in 1 to <var>n</var>-1) is effectively replaced by a <a href="#prod-xquery40-LetValueBinding">LetValueBinding</a> of the form <code>let <var>A<sub>i</sub></var> as <var>T<sub>i</sub></var> := items-at(<var>V</var>, <var>i</var>)</code>. That is, a <b>range variable</b> named <var>A<sub>i</sub></var> is declared, whose <b>binding sequence</b> is the item <var>V[ i ]</var>, after coercion to the type <var>T<sub>i</sub></var> if specified. If <var>T<sub>i</sub></var> is absent, no further coercion takes place (the default is effectively <code>item()?</code>).</p></li><li><p>The last variable <var>A<sub>n</sub></var> is effectively replaced by a <a href="#prod-xquery40-LetValueBinding">LetValueBinding</a> of the form <code>let <var>A<sub>n</sub></var> as <var>T<sub>n</sub></var> := subsequence(<var>V</var>, <var>n</var>)</code>. That is, the last variable is bound to the rest of the binding sequence (or to the empty sequence if the binding sequence has fewer items than the number of variables). </p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">For any variable <var>A<sub>i</sub></var>, including the last, if <var>i</var> exceeds the length of the sequence <var>V</var>, then <var>A<sub>i</sub></var> is bound to an empty sequence. This will cause a type error if type <var>T<sub>i</sub></var> does not permit an empty sequence.</span><span style="display: none;" class="add_version">For any variable <var>A<sub>i</sub></var>, including the last, if <var>i</var> exceeds the length of the sequence <var>V</var>, then <var>A<sub>i</sub></var> is bound to the empty sequence. This will cause a type error if type <var>T<sub>i</sub></var> does not permit the empty sequence.</span><span class="modify_version">For any variable <var>A<sub>i</sub></var>, including the last, if <var>i</var> exceeds the length of the sequence <var>V</var>, then <var>A<sub>i</sub></var> is bound to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. This will cause a type error if type <var>T<sub>i</sub></var> does not permit <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>It is permissible to bind several variables with the same name; all but the last are occluded. A useful convention is therefore to bind items in the sequence that are of no interest to the variable <code>$_</code>: for example <code>let $( $_, $_, $x ) := <var>EXPR</var></code> effectively binds <code>$x</code> to the subsequence starting at the third item, while causing the first two items to be ignored.</p></div><div class="example"><div class="exampleHeader"><a id="d2e35457"></a><a id="d2e35454"></a>Example:</div><p>The expression:</p><div class="exampleInner"><pre xml:space="preserve">let $( $a, $b as xs:integer, $local:c ) := (2, 4, 6)
return $a + $b + $local:c</pre></div><p>is expanded to:</p><div class="exampleInner"><pre xml:space="preserve">let $temp := (2, 4, 6)
let $a := fn:items-at($temp, 1)
let $b as xs:integer := fn:items-at($temp, 2)
let $local:c := fn:subsequence($temp, 3)
return $a + $b + $local:c</pre></div><p>where <code>$temp</code> is some variable name that is otherwise unused.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d2e35470"></a><a id="d2e35467"></a>Example:</div><p>Consider the element <var>$E</var> := <code>&lt;e A="p q r" B="x y z"/&gt;</code>.</p><p>Then consider the expression:</p><div class="exampleInner"><pre xml:space="preserve">let $( $a, $b ) := $E!(@A, @B)</pre></div><p>Here the binding sequence is a sequence of two attribute nodes, so <code>$a</code> is bound to the attribute <code>@A</code>, and <code>$b</code> is bound to the attribute node <code>@B</code>.</p><p>If the operator <code>"!"</code> were replaced by <code>"/"</code>, or if <code>","</code> were replaced by <code>"|"</code>, then the binding sequence would be sorted into document order, and since the order of attributes is not defined, this would make it unpredictable which variable is bound to which attribute node.</p><p>Now consider what happens when a declared sequence type is added:</p><div class="exampleInner"><pre xml:space="preserve">let $( $a, $b ) as xs:string* := $E!(@A, @B)</pre></div><p>The sequence of two attribute nodes is now atomized to form a sequence of strings. The first string in this sequence is bound to <code>$a</code>, and the remainder of the sequence is bound to <code>$b</code>. If the element <code>$E</code> is untyped, this will result in <code>$a</code> being bound to the <code>xs:untypedAtomic</code> value <code>"p q r"</code>, while <code>$b</code> is bound to the <code>xs:untypedAtomic</code> value <code>"x y z"</code>.</p><p>However, suppose that the element <code>$E</code> has been validated against a schema that defines both attributes <code>@A</code> and <code>@B</code> as list types with item type <code>xs:string</code>. In this case, the atomized value of <code>$E</code> will be a sequence of six strings. The variable <code>$a</code> is bound to the first of these strings (that is, <code>"p"</code>), while <code>$b</code> is bound to a sequence containing the remaining five strings (that is, <code>("q", "r", "x", "y", "z")</code>).</p><p>By contrast, if the expression is written as:</p><div class="exampleInner"><pre xml:space="preserve">let $( $a as xs:string*, $b as xs:string* ) := $E!(@A, @B)</pre></div><p>then <code>$a</code> is bound to the result of atomizing the first attribute (the <code>untypedAtomic</code> value <code>"p q r"</code> in the untyped case, or the sequence of three strings <code>("p", "q", "r")</code> in the schema-validated case), while <code>$b</code> is similarly bound to the result of atomizing the second attribute.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d2e35594"></a><a id="d2e35591"></a>Example:</div><p>Consider transforming the string <code>"Nf3 Nf6 c4 g6 Nc3 Bg7 d4 O-O Bf4 d5"</code> (notation for the start of a chess game) to the form <code>(["Nf3", "Nf6",] ["c4", "g6"], [ "Nc3", "Bg7"], [ "d4", "O-O"], ["Bf4", "d5"])</code>. This can be achieved as follows:</p><div class="exampleInner"><pre xml:space="preserve">declare function local:grouped-moves($moves) {
   if (exists($moves)) {
     let $($m1, $m2, $rest) := $moves
     return [$m1, $m2], local:grouped-moves($rest)
  }
};
local:grouped-moves(tokenize("Nf3 Nf6 c4 g6 Nc3 Bg7 d4 O-O Bf4 d5"))</pre></div></div></li><li><p>In a <a href="#prod-xquery40-LetArrayBinding">LetArrayBinding</a> such as <code>let $[ $<var>A<sub>1</sub></var> as <var>T<sub>1</sub></var>, $<var>A<sub>2</sub></var> as <var>T<sub>2</sub></var>, ... , $<var>A<sub>n</sub></var> as <var>T<sub>n</sub></var> ] as <var>AT</var> := <var>EXPR</var></code>:</p><ol class="enumla"><li><p>The sequence type <var>AT</var> is called the <b>declared array type</b>. If there is no declared array type, then <code>array(*)</code> is assumed.</p></li><li><p>The expression <var>EXPR</var> is evaluated, and its value is converted to the declared array type <var>AT</var> by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. A type error [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] is raised if the result is not a <a title="singleton" class="termref" href="#dt-singleton">singleton</a> array. Call the resulting (coerced) value <var>V</var>.</p></li><li><p>Each variable <var>A<sub>i</sub></var> (for <var>i</var> in 1 to <var>n</var>) is effectively replaced by a <a href="#prod-xquery40-LetValueBinding">LetValueBinding</a> of the form <code>let <var>A<sub>i</sub></var> as <var>T<sub>i</sub></var> := array:get(<var>V</var>, <var>i</var>)</code>. That is, a <b>range variable</b> named <var>A<sub>i</sub></var> is declared, whose <b>binding sequence</b> is the array member <var>V ? i</var>, after coercion to the type <var>T<sub>i</sub></var> if specified. If <var>T<sub>i</sub></var> is absent, no further coercion takes place (the default is effectively <code>item()*</code>).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If <var>i</var> exceeds the length of the array <var>V</var>, then an error [<a href="https://www.w3.org/TR/xpath-functions/#ERRFOAR0001" title="err:FOAR0001">err:FOAR0001</a>]<sup><small>FO</small></sup> is raised.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>It is permissible to bind several variables with the same name; all but the last are occluded. A useful convention is therefore to bind items in the sequence that are of no interest to the variable <code>$_</code>: for example <code>let $( $_, $_, $x ) := <var>EXPR</var></code> effectively binds <code>$x</code> to the third item in the sequence and causes the first two items to be ignored.</p></div><div class="example"><div class="exampleHeader"><a id="d2e35724"></a><a id="d2e35721"></a>Example:</div><p>The expression:</p><div class="exampleInner"><pre xml:space="preserve">let $[ $a, $b as xs:integer, $local:c ] := [ 2, 4, 6 ]
return $a + $b + $local:c</pre></div><p>is expanded to:</p><div class="exampleInner"><pre xml:space="preserve">let $temp := [ 2, 4, 6 ]
let $a := array:get($temp, 1, ())
let $b as xs:integer := array:get($temp, 2)
let $local:c := array:get($temp, 3, ())
return $a + $b + $local:c</pre></div><p>where <code>$temp</code> is some variable name that is otherwise unused.</p></div></li></ol></li><li><p>In a <a href="#prod-xquery40-LetMapBinding">LetMapBinding</a> such as <code>let ${ $<var>A<sub>1</sub></var> as <var>T<sub>1</sub></var>, $<var>A<sub>2</sub></var> as <var>T<sub>2</sub></var>, ... , $<var>A<sub>n</sub></var> as <var>T<sub>n</sub></var> } as <var>MT</var> := <var>EXPR</var></code>:</p><ol class="enumla"><li><p>The sequence type <var>MT</var> is called the <b>declared map type</b>. If there is no declared map type, then <code>map(*)</code> is assumed.</p></li><li><p>The expression <var>EXPR</var> is evaluated, and its value is converted to the declared map type <var>MT</var> by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. A type error [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] is raised if the result is not a <a title="singleton" class="termref" href="#dt-singleton">singleton</a> map. Call the resulting (coerced) value <var>V</var>.</p></li><li><p>Each variable <var>A<sub>i</sub></var> (for <var>i</var> in 1 to <var>n</var>) is effectively replaced by a <a href="#prod-xquery40-LetValueBinding">LetValueBinding</a> of the form <code>let <var>A<sub>i</sub></var> as <var>T<sub>i</sub></var> := map:get(<var>V</var>, "<var>N<sub>i</sub></var>", ())</code>, where <var>N<sub>i</sub></var> is the local part of the name of the variable <var>A<sub>i</sub></var>. That is, a <b>range variable</b> named <var>A<sub>i</sub></var> is declared, whose <b>binding sequence</b> is the value of the map entry in <var>V</var> whose key is an <code>xs:string</code> (or <code>xs:anyURI</code> or <code>xs:untypedAtomic</code>) equal to the local part of the variable name, after coercion to the type <var>T<sub>i</sub></var> if specified. If <var>T<sub>i</sub></var> is absent, no further coercion takes place (the default is effectively <code>item()*</code>).</p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">If there is no entry in the map with a key corresponding to the variable name, then the variable <var>A<sub>i</sub></var> is bound to an empty sequence. This will cause a type error if type <var>T<sub>i</sub></var> does not permit an empty sequence.</span><span style="display: none;" class="add_version">If there is no entry in the map with a key corresponding to the variable name, then the variable <var>A<sub>i</sub></var> is bound to the empty sequence. This will cause a type error if type <var>T<sub>i</sub></var> does not permit the empty sequence.</span><span class="modify_version">If there is no entry in the map with a key corresponding to the variable name, then the variable <var>A<sub>i</sub></var> is bound to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. This will cause a type error if type <var>T<sub>i</sub></var> does not permit <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>It is not possible to use this mechanism to bind variables to values in a map unless the keys in the map are strings in the form of <code>NCNames</code>.</p></div><div class="example"><div class="exampleHeader"><a id="d2e35858"></a><a id="d2e35855"></a>Example:</div><p>The expression:</p><div class="exampleInner"><pre xml:space="preserve">let ${ $a, $b as xs:integer, $local:c } := { "a": 2, "b": 4, "c": 6, "d": 8 }
return $a + $b + $local:c</pre></div><p>is expanded to:</p><div class="exampleInner"><pre xml:space="preserve">let $temp := { "a": 2, "b": 4, "c": 6 }
let $a := map:get($temp, "a", ())
let $b as xs:integer := map:get($temp, "b", ())
let $local:c := map:get($temp, "c", ())
return $a + $b + $local:c</pre></div><p>where <code>$temp</code> is some variable name that is otherwise unused.</p></div></li></ol></li><li><p>The effect of the <a href="#doc-xquery40-LetClause">LetClause</a> is to add one or more variable bindings to the tuple stream. Specifically, each <b>range variable</b> declared within the <code>LetClause</code> is bound to its corresponding <b>binding sequence</b>, and the resulting variable binding is added to the current tuple, replacing any existing variable binding with the same variable name.</p><p>If the <code>LetClause</code> is the initial clause in a FLWOR expression, it creates an initial tuple for the tuple stream, containing these variable bindings. This tuple stream serves as input to the next clause in the FLWOR expression.</p><p>If the <code>LetClause</code> is an intermediate clause in a FLWOR expression, it adds the relevant variable bindings to each tuple in the input tuple stream. The resulting tuples become the output tuple stream of the <code>let</code> clause.</p><p>The number of tuples in the output tuple stream of an intermediate <code>let</code> clause is the same as the number of tuples in the input tuple stream. The number of variable bindings in the output tuples is always greater than the number of variable bindings in the input tuples, unless the input tuples already contain bindings for every variable binding created by the <code>LetClause</code>; in this case, the new binding for any given variable name occludes (replaces) an earlier binding for that variable name, and the number of bindings is unchanged.</p></li></ol><p>The semantics of type declarations are further defined in <a href="#id-binding-rules"><b>4.13.1 Variable Bindings</b></a>.</p><p>The following code fragment illustrates how a <code>for</code> clause and a <code>let</code> clause can be used together. The <code>for</code> clause produces an initial tuple stream containing a binding for variable <code>$d</code> to each department number found in a given input document. The <code>let</code> clause adds an additional binding to each tuple, binding variable <code>$e</code> to a sequence of employees whose department number matches the value of <code>$d</code> in that tuple.</p><div class="exampleInner"><pre xml:space="preserve">for $d in doc("depts.xml")/depts/deptno
let $e := doc("emps.xml")/emps/emp[deptno eq $d]</pre></div></div><div class="_diffs div3 xquery"><h4><a id="id-group-by"></a>4.13.8 <a href="#id-group-by" style="text-decoration: none">Group By Clause</a></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-GroupByClause"></a><code><a href="#prod-xquery40-GroupByClause">GroupByClause</a></code></td><td>::=</td><td><code>"group" "by" (<a href="#doc-xquery40-GroupByClause-GroupingSpec">GroupingSpec</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-GroupByClause-GroupingSpec"></a><code><a href="#prod-xquery40-GroupingSpec">GroupingSpec</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-GroupByClause-VarName">VarName</a> (<a href="#doc-xquery40-GroupByClause-TypeDeclaration">TypeDeclaration</a>? ":=" <a href="#doc-xquery40-GroupByClause-ExprSingle">ExprSingle</a>)? ("collation" <a href="#doc-xquery40-GroupByClause-URILiteral">URILiteral</a>)?</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-GroupByClause-VarName"></a><code><a href="#prod-xquery40-VarName">VarName</a></code></td><td>::=</td><td><code>"$" <a href="#doc-xquery40-GroupByClause-EQName">EQName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-GroupByClause-EQName"></a><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-QName">QName</a> | <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-GroupByClause-TypeDeclaration"></a><code><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a></code></td><td>::=</td><td><code>"as" <a href="#doc-xquery40-GroupByClause-SequenceType">SequenceType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-GroupByClause-SequenceType"></a><code><a href="#prod-xquery40-SequenceType">SequenceType</a></code></td><td>::=</td><td><code>("empty-sequence" "(" ")")<br>| (<a href="#doc-xquery40-ItemType">ItemType</a><a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-GroupByClause-ExprSingle"></a><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-FLWORExpr">FLWORExpr</a><br>| <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xquery40-SwitchExpr">SwitchExpr</a><br>| <a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#doc-xquery40-IfExpr">IfExpr</a><br>| <a href="#doc-xquery40-TryCatchExpr">TryCatchExpr</a><br>| <a href="#doc-xquery40-OrExpr">OrExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-GroupByClause-URILiteral"></a><code><a href="#prod-xquery40-URILiteral">URILiteral</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-GroupByClause-StringLiteral">StringLiteral</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-GroupByClause-StringLiteral"></a><code><a href="#prod-xquery40-StringLiteral">StringLiteral</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-AposStringLiteral">AposStringLiteral</a> | <a href="#prod-xquery40-QuotStringLiteral">QuotStringLiteral</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody></table><p>A <code>group by</code> clause generates an output tuple stream in which each tuple represents a group of tuples from the input tuple stream that have equivalent grouping keys. We will refer to the tuples in the input tuple stream as <b>pre-grouping tuples</b>, and the tuples in the output tuple stream as <b>post-grouping tuples</b>.</p><p>The <code>group by</code> clause assigns each pre-grouping tuple to a group, and generates one post-grouping tuple for each group. In the post-grouping tuple for a group, each grouping key is represented by a variable that was specified in a <a href="#prod-xquery40-GroupingSpec">GroupingSpec</a>, and every variable that appears in the pre-grouping tuples that were assigned to that group is represented by a variable of the same name, bound to a sequence of all values bound to the variable in any of these pre-grouping tuples. Subsequent clauses in the FLWOR expression see only the variable bindings in the post-grouping tuples; they no longer have access to the variable bindings in the pre-grouping tuples. The number of post-grouping tuples is less than or equal to the number of pre-grouping tuples.</p><p>A <code>group by</code> clause contains one or more <a href="#prod-xquery40-GroupingSpec">grouping specifications</a>, as shown in the grammar. [<a id="dt-grouping-variable" title="grouping variable">Definition</a>: Each grouping specification specifies one <b>grouping variable</b>, which refers to variable bindings in the pre-grouping tuples. The values of the grouping variables are used to assign pre-grouping tuples to groups.] Each grouping specification may optionally provide an expression to which its grouping variable is bound. If no expression is provided, the grouping variable name must be equal (by the <code>eq</code> operator on <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a>) to the name of a variable in the input tuple stream, and it refers to that variable; otherwise a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXQST0094" title="err:XQST0094">err:XQST0094</a>]. For each grouping specification that contains a binding expression, a <code>let</code> binding is created in the pre-grouping tuples, and the grouping variable refers to that <code>let</code> binding. For example, the clause:</p><div class="exampleInner"><pre xml:space="preserve">group by $g1, $g2 := $expr1, $g3 := $expr2 collation "Spanish"</pre></div><p>is semantically equivalent to the following sequence of clauses:</p><div class="exampleInner"><pre xml:space="preserve">let $g2 := $expr1
let $g3 := $expr2
group by $g1, $g2, $g3 collation "Spanish"</pre></div><p>The process of group formation proceeds as follows: </p><ol class="enumar"><li><p> [<a id="dt-grouping-key" title="grouping key">Definition</a>: The atomized value of a <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variable</a> is called a <b>grouping key</b>.] For each pre-grouping tuple, the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping keys</a> are created by <a title="atomization" class="termref" href="#dt-atomization">atomizing</a> the values of the <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variables</a> (in the post-grouping tuples, each grouping variable is set to the value of the corresponding grouping key, as discussed below). If the value of any <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variable</a> consists of more than one item, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. If a type declaration is present and the resulting atomized value is not an instance of the specified type, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>The input tuple stream is partitioned into groups of tuples whose grouping keys are <a title="equivalent grouping keys" class="termref" href="#dt-equivalent-grouping-keys">equivalent</a>. [<a id="dt-equivalent-grouping-keys" title="equivalent grouping keys">Definition</a>: Two tuples <var>T<sub>1</sub></var> and <var>T<sub>2</sub></var> have <b>equivalent grouping keys</b> if and only if, for each grouping variable <var>GV</var>, the atomized value of <var>GV</var> in <var>T<sub>1</sub></var> is deep-equal to the atomized value of <var>GV</var> in <var>T<sub>2</sub></var>, as defined by applying the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-deep-equal"><code>fn:deep-equal</code></a> using the appropriate collation.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-deep-equal"><code>fn:deep-equal</code></a> function has been changed in XQuery 4.0 so that it is now transitive; the problem that existed in earlier versions when comparing numeric values of different types has thereby been resolved.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">The atomized grouping key will always be either an empty sequence or a single atomic item. Defining equivalence by reference to the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-deep-equal"><code>fn:deep-equal</code></a> function ensures that the empty sequence is equivalent only to the empty sequence, that <code>NaN</code> is equivalent to <code>NaN</code>, that <code>xs:untypedAtomic</code> items are compared as strings, and that values from different <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-type-family">atomic type families</a><sup><small>DM</small></sup> are considered non-equivalent.</span><span style="display: none;" class="add_version">The atomized grouping key will always be either the empty sequence or a single atomic item. Defining equivalence by reference to the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-deep-equal"><code>fn:deep-equal</code></a> function ensures that the empty sequence is equivalent only to the empty sequence, that <code>NaN</code> is equivalent to <code>NaN</code>, that <code>xs:untypedAtomic</code> items are compared as strings, and that values from different <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-type-family">atomic type families</a><sup><small>DM</small></sup> are considered non-equivalent.</span><span class="modify_version">The atomized grouping key will always be either <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence or a single atomic item. Defining equivalence by reference to the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-deep-equal"><code>fn:deep-equal</code></a> function ensures that the empty sequence is equivalent only to the empty sequence, that <code>NaN</code> is equivalent to <code>NaN</code>, that <code>xs:untypedAtomic</code> items are compared as strings, and that values from different <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-type-family">atomic type families</a><sup><small>DM</small></sup> are considered non-equivalent.</span></p></div></li><li><p>The appropriate collation for comparing two grouping keys is the collation specified in the pertinent <a href="#prod-xquery40-GroupingSpec">GroupingSpec</a> if present, or the default collation from the <span>dynamic</span> context otherwise. If the collation is specified by a relative URI, that relative URI is <a title="resolve" class="termref" href="#dt-resolve-relative-uri">resolved to an absolute URI</a> using the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a>. If the specified collation is not found in statically known collations, a static error is raised [<a href="#ERRXQST0076" title="err:XQST0076">err:XQST0076</a>].</p></li></ol><p>Each group of tuples produced by the above process results in one post-grouping tuple. The pre-grouping tuples from which the group is derived have <em>equivalent</em><a title="grouping key" class="termref" href="#dt-grouping-key">grouping keys</a>, but these keys are not necessarily identical (for example, the strings <code>"Frog"</code> and <code>"frog"</code> might be <em>equivalent</em> according to the collation in use.) In the post-grouping tuple, each <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variable</a> is bound to the value of the corresponding grouping key. </p><p>In the post-grouping tuple generated for a given group, each non-grouping variable is bound to a sequence containing the concatenated values of that variable in all the pre-grouping tuples that were assigned to that group. The values derived from individual tuples are concatenated in a way that preserves the order of the pre-grouping tuple stream.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This behavior may be surprising to SQL programmers, since SQL reduces the equivalent of a non-grouping variable to one representative value. Consider the following query:</p><div class="exampleInner"><pre xml:space="preserve">let $x := 64000
for $c in //customer
where $c/salary &gt; $x
group by $d := $c/department
return &lt;department name="{ $d }"&gt;
  Number of employees earning more than ${ $x } is { count($c) }
&lt;/department&gt;</pre></div><p>If there are three qualifying customers in the sales department this evaluates to:</p><div class="exampleInner"><pre xml:space="preserve">&lt;department name="sales"&gt;
  Number of employees earning more than $64000 64000 64000 is 3
&lt;/department&gt;</pre></div><p>In XQuery, each group is a sequence of items that match the group by criteria—in a tree-structured language like XQuery, this is convenient, because further structures can be built based on the items in this sequence. Because there are three items in the group, <code>$x</code> evaluates to a sequence of three items. To reduce this to one item, use <code>fn:distinct-values()</code>:</p><div class="exampleInner"><pre xml:space="preserve">let $x := 64000
for $c in //customer
let $d := $c/department
where $c/salary &gt; $x
group by $d
return &lt;department name="{ $d }"&gt;
  Number of employees earning more than ${ distinct-values($x) } is { count($c) }
&lt;/department&gt;</pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In general, the <a title="static type" class="termref" href="#dt-static-type">static type</a> of a variable in a post-grouping tuple is different from the <a title="static type" class="termref" href="#dt-static-type">static type</a> of the variable with the same name in the pre-grouping tuples.</p></div><p>The order in which tuples appear in the post-grouping tuple stream is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An <code>order by</code> clause can be used to impose a value-based ordering on the post-grouping tuple stream. Similarly, if it is desired to impose a value-based ordering within a group (i.e., on the sequence of items bound to a non-grouping variable), this can be accomplished by a nested FLWOR expression that iterates over these items and applies an <code>order by</code> clause. In some cases, a value-based ordering within groups can be accomplished by applying an <code>order by</code> clause on a non-grouping variable before applying the <code>group by</code> clause.</p></div><p>A <code>group by</code> clause rebinds all the variables in the input tuple stream. The scopes of these variables are not affected by the <code>group by</code> clause, but in post-grouping tuples the values of the variables represent group properties rather than properties of individual pre-grouping tuples.</p><p>Examples:</p><ul><li><p>This example illustrates the effect of a <code>group by</code> clause on a tuple stream.</p><p>Input tuple stream:</p><div class="exampleInner"><pre xml:space="preserve">($storeno = &lt;storeno&gt;S101&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P78395&lt;/itemno&gt;)
($storeno = &lt;storeno&gt;S102&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P94738&lt;/itemno&gt;)
($storeno = &lt;storeno&gt;S101&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P41653&lt;/itemno&gt;)
($storeno = &lt;storeno&gt;S102&lt;/storeno&gt;, $itemno = &lt;itemno&gt;P70421&lt;/itemno&gt;)</pre></div><p><code>group by</code> clause:</p><div class="exampleInner"><pre xml:space="preserve">group by $storeno</pre></div><p>Output tuple stream:</p><div class="exampleInner"><pre xml:space="preserve">($storeno = S101, $itemno = (&lt;itemno&gt;P78395&lt;/itemno&gt;, &lt;itemno&gt;P41653&lt;/itemno&gt;))
($storeno = S102, $itemno = (&lt;itemno&gt;P94738&lt;/itemno&gt;, &lt;itemno&gt;P70421&lt;/itemno&gt;))</pre></div></li></ul><ul><li><p>This example and the ones that follow are based on two separate sequences of elements, named <code>$sales</code> and <code>$products</code>. We assume that the variable <code>$sales</code> is bound to a sequence of elements with the following structure:</p><div class="exampleInner"><pre xml:space="preserve">&lt;sales&gt;
  &lt;storeno&gt;S101&lt;/storeno&gt;
  &lt;itemno&gt;P78395&lt;/itemno&gt;
  &lt;qty&gt;125&lt;/qty&gt;
&lt;/sales&gt;</pre></div><p>We also assume that the variable <code>$products</code> is bound to a sequence of elements with the following structure:</p><div class="exampleInner"><pre xml:space="preserve">&lt;product&gt;
  &lt;itemno&gt;P78395&lt;/itemno&gt;
  &lt;price&gt;25.00&lt;/price&gt;
  &lt;category&gt;Men's Wear&lt;/category&gt;
&lt;/product&gt;</pre></div><p>The simplest kind of grouping query has a single <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variable</a>. The query in this example finds the total quantity of items sold by each store:</p><div class="exampleInner"><pre xml:space="preserve">for $s in $sales
let $storeno := $s/storeno
group by $storeno
return &lt;store number="{ $storeno }" total-qty="{ sum($s/qty) }"/&gt;</pre></div><p>The result of this query is a sequence of elements with the following structure:</p><div class="exampleInner"><pre xml:space="preserve">&lt;store number="S101" total-qty="1550" /&gt;
&lt;store number="S102" total-qty="2125" /&gt;</pre></div></li><li><p>In a more realistic example, a user might be interested in the total revenue generated by each store for each product category. Revenue depends on both the quantity sold of various items and the price of each item. The following query joins the two input sequences and groups the resulting tuples by two <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variables</a>:</p><div class="exampleInner"><pre xml:space="preserve">for $s in $sales
for $p in $products[itemno = $s/itemno]
let $revenue := $s/qty * $p/price
group by $storeno := $s/storeno, 
         $category := $p/category
return &lt;summary storeno="{ $storeno }"
                category="{ $category }"
                revenue="{ sum($revenue) }"/&gt;</pre></div><p>The result of this query is a sequence of elements with the following structure:</p><div class="exampleInner"><pre xml:space="preserve">&lt;summary storeno="S101" category="Men's Wear" revenue="10185"/&gt;
&lt;summary storeno="S101" category="Stationery" revenue="4520"/&gt;
&lt;summary storeno="S102" category="Men's Wear" revenue="9750"/&gt;
&lt;summary storeno="S102" category="Appliances" revenue="22650"/&gt;
&lt;summary storeno="S102" category="Jewelry" revenue="30750"/&gt;</pre></div></li><li><p>The result of the previous example was a “flat” list of elements. A user might prefer the query result to be presented in the form of a hierarchical report, grouped primarily by store (in order by store number) and secondarily by product category. Within each store, the user might want to see only those product categories whose total revenue exceeds $10,000, presented in descending order by their total revenue. This report is generated by the following query:</p><div class="exampleInner"><pre xml:space="preserve">for $s1 in $sales
let $storeno := $s1/storeno
group by $storeno
order by $storeno
return &lt;store storeno="{ $storeno }"&gt;{
  for $s2 in $s1
  for $p in $products[itemno = $s2/itemno]
  let $category := $p/category
  let $revenue := $s2/qty * $p/price
  group by $category
  let $group-revenue := sum($revenue)
  where $group-revenue &gt; 10000
  order by $group-revenue descending
  return &lt;category name="{ $category }" revenue="{ $group-revenue }"/&gt;
}&lt;/store&gt;</pre></div><p>The result of this example query has the following structure:</p><div class="exampleInner"><pre xml:space="preserve">&lt;store storeno="S101"&gt;
  &lt;category name="Men's Wear" revenue="10185"/&gt;
&lt;/store&gt;
&lt;store storeno="S102"&gt;
  &lt;category name="Jewelry" revenue="30750"/&gt;
  &lt;category name="Appliances" revenue="22650"/&gt;
&lt;/store&gt;</pre></div></li><li><p>The following example illustrates how to avoid a possible pitfall in writing grouping queries.</p><p>In each post-grouping tuple, all variables except for the grouping variable are bound to sequences of items derived from all the pre-grouping tuples from which the group was formed. For instance, in the following query, <code>$high-price</code> is bound to a sequence of items in the post-grouping tuple.</p><div class="exampleInner"><pre xml:space="preserve">let $high-price := 1000
for $p in $products[price &gt; $high-price]
let $category := $p/category
group by $category
return &lt;category name="{ $category }"&gt;{
  count($p) || ' products have price greater than ' || $high-price || '.'
}&lt;/category&gt;</pre></div><p>If three products in the “Men’s Wear” category have prices greater than 1000, the result of this query might look (in part) like this:</p><div class="exampleInner"><pre xml:space="preserve">&lt;category name="Men’s Wear"&gt;
  3 products have price greater than 1000 1000 1000.
&lt;/category&gt;</pre></div><p>The repetition of "1000" in this query result is due to the fact that <code>$high-price</code> is not a <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variable</a>. One way to avoid this repetition is to move the binding of <code>$high-price</code> to an outer-level FLWOR expression, as follows:</p><div class="exampleInner"><pre xml:space="preserve">let $high-price := 1000
return (
  for $p in $products[price &gt; $high-price]
  let $category := $p/category
  group by $category
  return &lt;category name="{ $category }"&gt;{
    count($p) || ' products have price greater than ' || $high-price || '.'
  }&lt;/category&gt;  
)</pre></div><p>The result of the revised query might contain the following element:</p><div class="exampleInner"><pre xml:space="preserve">&lt;category name="Men's Wear"&gt;
  3 products have price greater than 1000.
&lt;/category&gt;</pre></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>If a collation name is specified, it must be supplied as a literal string; it cannot be computed dynamically. A workaround in such cases is to use the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collation-key"><code>fn:collation-key</code></a> function. For example:</p><div class="exampleInner"><pre xml:space="preserve">for $p in $products
group by collation-key($p/description, $collation)
return $product/@code</pre></div><p>Note however that the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collation-key"><code>fn:collation-key</code></a> function might not work for all collations.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Grouping can also be achieved by constructing a map. For example, the function call <code>map:build(//employee, fn { department })</code> constructs a map in which employees are grouped by department.</p></div></div></div><div class="_diffs div2"><h3><a id="id-maps-and-arrays"></a>4.14 <a href="#id-maps-and-arrays" style="text-decoration: none">Maps and Arrays</a></h3><p>Most modern programming languages have support for collections of key/value pairs, which may be called maps, dictionaries, associative arrays, hash tables, keyed lists, or objects (these are not the same thing as objects in object-oriented systems). In XQuery 4.0, we call these maps. Most modern programming languages also support ordered lists of values, which may be called arrays, vectors, or sequences. In XQuery 4.0, we have both sequences and arrays. Unlike sequences, an array is an item, and can appear as an item in a sequence.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The XQuery 4.0 specification focuses on syntax provided for maps and arrays, especially constructors and lookup.</p><p>Some of the functionality typically needed for maps and arrays is provided by functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#maps">14 Processing maps</a> and <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#arrays">15 Processing arrays</a>, including functions used to read JSON to create maps and arrays, serialize maps and arrays to JSON, combine maps to create a new map, remove map entries to create a new map, iterate over the keys of a map, convert an array to create a sequence, combine arrays to form a new array, and iterate over arrays in various ways.</p></div><div class="_diffs div3"><h4><a id="id-lookup"></a>4.14.3 <a href="#id-lookup" style="text-decoration: none">Lookup Expressions</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-methods">next</a> | <a href="#id-map-constructors">previous</a>)</p><ol><li><p> The lookup operator <code>?</code> can now be followed by an arbitrary literal, for cases where keys are items other than integers or NCNames. It can also be followed by a variable reference or a context value reference. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1996">1996</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2134">2134</a>&nbsp;29 July 2025]</i></p></li></ol></div><p>The operator "?", known as the lookup operator, returns values found in the operand map or array.</p><div class="_diffs div4"><h5><a id="id-lookup-vs-path-expressions"></a>4.14.3.3 <a href="#id-lookup-vs-path-expressions" style="text-decoration: none">Comparing Lookup and Path Expressions</a></h5><p>Lookup expressions are retained in this specification with only minor changes from the previous version 3.1. They remain a convenient solution for simple lookups of entries in maps and arrays.</p><p>For more complex queries into trees of maps and arrays, XQuery 4.0 introduces a generalization of path expressions (see <a href="#id-path-expressions"><b>4.6 Path Expressions</b></a>) which can now handle <a title="JTree" class="termref" href="#dt-JTree">JTrees</a> as well as <a title="XTree" class="termref" href="#dt-XTree">XTrees</a>.</p><p>For simple expressions, the capabilities of the two constructs overlap. For example, if <code>$m</code> is a map, then the expressions <code>$m?code = 3</code> and <code>$m/code = 3</code> have the same effect. Path expressions, however, have more power, and with it, more complexity. The expression <code>$m/code = 3</code> (unless simplified by an optimizer) effectively expands the expression to <code>(jtree($m)/child::get("code") =&gt; jnode-content()) = 3</code>: that is, the supplied map is wrapped in a JNode, the child axis returns a sequence of JNodes, and the <b>·content·</b> properties of these JNodes are compared with the supplied value <code>3</code>.</p><p>Whereas simple lookups of specific entries in maps and arrays work well, experience has shown that the <code>?*</code> wildcard lookup can be problematic. This is because of the flattening effect: for example, given the array <code>let $A := [(1,2), (3,4), (), 5]</code> the result of the expression <code>$A?*</code> is the sequence <code>(1, 2, 3, 4, 5)</code> which loses information that might be needed for further processing. By contrast, the path expression <code>$A/*</code> (or <code>$A/child::*</code>) returns a sequence of four JNodes, whose <b>·content·</b> properties are respectively <code>(1,2)</code>, <code>(3,4)</code>, <code>()</code>, and <code>5</code>.</p><p>The result of a lookup expression is a simple value (the value of an entry in a map or a member of an array, or the <a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation">sequence concatenation</a> of several such values). By contrast, the result of a path expression applied to maps or arrays is always a sequence of JNodes. These JNodes can be used for further navigation. If only the <b>·content·</b> properties of the JNodes are needed, these will usually be extracted automatically by virtue of the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>: for example if the value is used in an arithmetic expression or a value comparison, atomization of the JNode automatically extracts its <b>·content·</b>. In other cases the value can be extracted explicitly by a call of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-jnode-content"><code>jnode-content</code></a> function.</p><p><span style="display: none;" class="delete_version">Lookup expressions on arrays result in a dynamic error if the subscript is out of bounds, whereas the equivalent path expression succeeds, returning an empty sequence. For example <code>array{1 to 5}?10</code> raises [<a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOAY0001" title="err:FOAY0001">err:FOAY0001</a>]<sup><small>FO40</small></sup>, whereas <code>array{1 to 5}/get(10)</code> returns a empty sequence. </span><span style="display: none;" class="add_version">Lookup expressions on arrays result in a dynamic error if the subscript is out of bounds, whereas the equivalent path expression succeeds, returning the empty sequence. For example <code>array{1 to 5}?10</code> raises [<a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOAY0001" title="err:FOAY0001">err:FOAY0001</a>]<sup><small>FO40</small></sup>, whereas <code>array{1 to 5}/get(10)</code> returns a empty sequence. </span><span class="modify_version">Lookup expressions on arrays result in a dynamic error if the subscript is out of bounds, whereas the equivalent path expression succeeds, returning <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. For example <code>array{1 to 5}?10</code> raises [<a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOAY0001" title="err:FOAY0001">err:FOAY0001</a>]<sup><small>FO40</small></sup>, whereas <code>array{1 to 5}/get(10)</code> returns a empty sequence. </span></p></div></div><div class="_diffs div3"><h4><a id="id-filter-maps-and-arrays"></a>4.14.5 <a href="#id-filter-maps-and-arrays" style="text-decoration: none">Filter Expressions for Maps and Arrays</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-unordered-expressions">next</a> | <a href="#id-methods">previous</a>)</p><ol><li><p> Filter expressions for maps and arrays are introduced. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1159">1159</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1163">1163</a>&nbsp;20 April 2024]</i></p></li><li><p> Predicates in filter expressions for maps and arrays can now be numeric. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1207">1207</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1217">1217</a>&nbsp;15 May 2024]</i></p></li><li><p> The group is considering removing or substantially changing this feature, it is considered <a href="#at-risk">at risk</a>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2351">2351</a>&nbsp;]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FilterExprAM"></a><code><a href="#prod-xquery40-FilterExprAM">FilterExprAM</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-FilterExprAM-PostfixExpr">PostfixExpr</a> "?[" <a href="#doc-xquery40-FilterExprAM-Expr">Expr</a> "]"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FilterExprAM-PostfixExpr"></a><code><a href="#prod-xquery40-PostfixExpr">PostfixExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-PrimaryExpr">PrimaryExpr</a> | <a href="#doc-xquery40-FilterExpr">FilterExpr</a> | <a href="#doc-xquery40-DynamicFunctionCall">DynamicFunctionCall</a> | <a href="#doc-xquery40-LookupExpr">LookupExpr</a> | <a href="#doc-xquery40-MethodCall">MethodCall</a> | <a href="#doc-xquery40-FilterExprAM">FilterExprAM</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-FilterExprAM-Expr"></a><code><a href="#prod-xquery40-Expr">Expr</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-ExprSingle">ExprSingle</a> ++ ",")</code></td></tr></tbody></table><p>Maps and arrays can be filtered using the construct <code><var>INPUT</var>?[<var>FILTER</var>]</code>. For example, <code>$array?[count(.)=1]</code> filters an array to retain only those members that are single items.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The character-pair <code>?[</code> forms a single token; no intervening whitespace or comment is allowed.</p></div><p><span style="display: none;" class="delete_version">The required type of the left-hand operand <code><var>INPUT</var></code> is <code>(map(*)|array(*))?</code>: that is, it must be either an empty sequence, a single map, or a single array [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. However, the coercion rules also allow a JNode whose <b>·content·</b> is a map or array to be supplied. If the value is an empty sequence, the result of the expression is an empty sequence.</span><span style="display: none;" class="add_version">The required type of the left-hand operand <code><var>INPUT</var></code> is <code>(map(*)|array(*))?</code>: that is, it must be either the empty sequence, a single map, or a single array [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. However, the coercion rules also allow a JNode whose <b>·content·</b> is a map or array to be supplied. If the value is the empty sequence, the result of the expression is the empty sequence.</span><span class="modify_version">The required type of the left-hand operand <code><var>INPUT</var></code> is <code>(map(*)|array(*))?</code>: that is, it must be either <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, a single map, or a single array [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. However, the coercion rules also allow a JNode whose <b>·content·</b> is a map or array to be supplied. If the value is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result of the expression is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p><p>If the value of <code><var>INPUT</var></code> is an array, then the <code><var>FILTER</var></code> expression is evaluated for each member of the array, with that member as the context value, with its position in the array as the context position, and with the size of the array as the context size. The result of the expression is an array containing those members of the input array for which the <a title="predicate truth value" class="termref" href="#dt-predicate-truth-value">predicate truth value</a> of the <code><var>FILTER</var></code> expression is true. The order of retained members is preserved.</p><p>For example, the following expression:</p><div class="exampleInner"><pre xml:space="preserve">let $array := [ (), 1, (2, 3), (4, 5, 6) ]
return $array?[count(.) ge 2]</pre></div><p>returns:</p><div class="exampleInner"><pre xml:space="preserve">[ (2, 3), (4, 5, 6) ]</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Numeric predicates are handled in the same way as with filter expressions for sequences. However, the result is always an array, even if only one member is selected. For example, given the <code>$array</code> shown above, the result of <code>$array?[3]</code> is the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-single-member-array">single-member array</a><sup><small>DM</small></sup><code>[ (2, 3) ]</code>. Contrast this with <code>$array?3</code> which delivers the sequence <code>2, 3</code>.</p></div><p>If the value of <code><var>INPUT</var></code> is a map, then the <code><var>FILTER</var></code> expression is evaluated for each entry in the map, with the context value set to an item of type <code>record(key as xs:anyAtomicType, value as item()*)</code>, in which the <code>key</code> and <code>value</code> fields represent the key and value of the map entry. The context position is the position of the entry in the map (in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-entry-order">entry order</a><sup><small>DM</small></sup>), and the context size is the number of entries in the map. The result of the expression is a map containing those entries of the input map for which the <a title="predicate truth value" class="termref" href="#dt-predicate-truth-value">predicate truth value</a> of the <code><var>FILTER</var></code> expression is true. The relative order of entries in the result retains the relative order of entries in the input. </p><p>For example, the following expression:</p><div class="exampleInner"><pre xml:space="preserve">let $map := { 1: "alpha", 2: "beta", 3: "gamma" }
return $map?[?key ge 2]</pre></div><p>returns:</p><div class="exampleInner"><pre xml:space="preserve">{ 2: "beta", 3: "gamma" }</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>A filter expression such as <code>$map?[last()-1, last()]</code> might be used to return the last two entries of a map in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-entry-order">entry order</a><sup><small>DM</small></sup>.</p></div></div></div><div class="_diffs div2"><h3><a id="id-otherwise"></a>4.17 <a href="#id-otherwise" style="text-decoration: none">Otherwise Expressions</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-switch">next</a> | <a href="#id-conditionals">previous</a>)</p><ol><li><p><span style="display: none;" class="delete_version"> An <code>otherwise</code> operator is introduced: <code>A otherwise B</code> returns the value of <code>A</code>, unless it is an empty sequence, in which case it returns the value of <code>B</code>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1024">1024</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1031">1031</a>&nbsp;27 February 2024]</i></span><span style="display: none;" class="add_version"> An <code>otherwise</code> operator is introduced: <code>A otherwise B</code> returns the value of <code>A</code>, unless it is the empty sequence, in which case it returns the value of <code>B</code>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1024">1024</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1031">1031</a>&nbsp;27 February 2024]</i></span><span class="modify_version"> An <code>otherwise</code> operator is introduced: <code>A otherwise B</code> returns the value of <code>A</code>, unless it is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, in which case it returns the value of <code>B</code>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1024">1024</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1031">1031</a>&nbsp;27 February 2024]</i></span></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-OtherwiseExpr"></a><code><a href="#prod-xquery40-OtherwiseExpr">OtherwiseExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-OtherwiseExpr-StringConcatExpr">StringConcatExpr</a> ("otherwise" <a href="#doc-xquery40-OtherwiseExpr-StringConcatExpr">StringConcatExpr</a>)*</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-OtherwiseExpr-StringConcatExpr"></a><code><a href="#prod-xquery40-StringConcatExpr">StringConcatExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-RangeExpr">RangeExpr</a> ("||" <a href="#doc-xquery40-RangeExpr">RangeExpr</a>)*</code></td></tr></tbody></table><p><span style="display: none;" class="delete_version">The <code>otherwise</code> expression returns the value of its first operand, unless this is an empty sequence, in which case it returns the value of its second operand.</span><span style="display: none;" class="add_version">The <code>otherwise</code> expression returns the value of its first operand, unless this is the empty sequence, in which case it returns the value of its second operand.</span><span class="modify_version">The <code>otherwise</code> expression returns the value of its first operand, unless this is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, in which case it returns the value of its second operand.</span></p><p>For example, <code>@price - (@discount otherwise 0)</code> returns the value of <code>@price - @discount</code>, if the attribute <code>@discount</code> exists, or the value of <code>@price</code> if the <code>@discount</code> attribute is absent.</p><p>To prevent spurious errors, the right hand operand is <a title="guarded" class="termref" href="#dt-guarded">guarded</a>: it cannot throw any dynamic error unless the left-hand operand returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The operator is associative (even under error conditions): <code>A otherwise (B otherwise C)</code> returns the same result as <code>(A otherwise B) otherwise C</code>.</p><p>The <code>otherwise</code> operator binds more tightly than comparison operators such as <code>=</code>, but less tightly than string concatenation (<code>||</code>) or arithemetic operators. The expression <code>$a = @x otherwise @y + 1</code> parses as <code>$a = (@x otherwise (@y + 1))</code>.</p></div></div><div class="_diffs div2 xquery"><h3><a id="id-switch"></a>4.18 <a href="#id-switch" style="text-decoration: none">Switch Expressions</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-quantified-expressions">next</a> | <a href="#id-otherwise">previous</a>)</p><ol><li><p> Switch expressions now allow a <code>case</code> clause to match multiple atomic items. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/328">328</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/364">364</a>&nbsp;7 March 2023]</i></p></li><li><p> Switch and typeswitch expressions can now be written with curly brackets, to improve readability. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/365">365</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/587">587</a>&nbsp;7 November 2023]</i></p></li><li><p> The comparand expression in a switch expression can be omitted, allowing the switch cases to be provided as arbitrary boolean expressions. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/671">671</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/678">678</a>&nbsp;12 September 2023]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SwitchExpr"></a><code><a href="#prod-xquery40-SwitchExpr">SwitchExpr</a></code></td><td>::=</td><td><code>"switch" <a href="#doc-xquery40-SwitchExpr-SwitchComparand">SwitchComparand</a> (<a href="#doc-xquery40-SwitchExpr-SwitchCases">SwitchCases</a> | <a href="#doc-xquery40-SwitchExpr-BracedSwitchCases">BracedSwitchCases</a>)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SwitchExpr-SwitchComparand"></a><code><a href="#prod-xquery40-SwitchComparand">SwitchComparand</a></code></td><td>::=</td><td><code>"(" <a href="#doc-xquery40-SwitchExpr-Expr">Expr</a>? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SwitchExpr-Expr"></a><code><a href="#prod-xquery40-Expr">Expr</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-SwitchExpr-ExprSingle">ExprSingle</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SwitchExpr-SwitchCases"></a><code><a href="#prod-xquery40-SwitchCases">SwitchCases</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-SwitchExpr-SwitchCaseClause">SwitchCaseClause</a>+ "default" "return" <a href="#doc-xquery40-SwitchExpr-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SwitchExpr-SwitchCaseClause"></a><code><a href="#prod-xquery40-SwitchCaseClause">SwitchCaseClause</a></code></td><td>::=</td><td><code>("case" <a href="#doc-xquery40-SwitchExpr-SwitchCaseOperand">SwitchCaseOperand</a>)+ "return" <a href="#doc-xquery40-SwitchExpr-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SwitchExpr-SwitchCaseOperand"></a><code><a href="#prod-xquery40-SwitchCaseOperand">SwitchCaseOperand</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-SwitchExpr-Expr">Expr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SwitchExpr-ExprSingle"></a><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-FLWORExpr">FLWORExpr</a><br>| <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xquery40-SwitchExpr">SwitchExpr</a><br>| <a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#doc-xquery40-IfExpr">IfExpr</a><br>| <a href="#doc-xquery40-TryCatchExpr">TryCatchExpr</a><br>| <a href="#doc-xquery40-OrExpr">OrExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-SwitchExpr-BracedSwitchCases"></a><code><a href="#prod-xquery40-BracedSwitchCases">BracedSwitchCases</a></code></td><td>::=</td><td><code>"{" <a href="#doc-xquery40-SwitchExpr-SwitchCases">SwitchCases</a> "}"</code></td></tr></tbody></table><p> The <b>switch expression</b> chooses one of several expressions to evaluate based on the input value. </p><p> In a <code>switch</code> expression, the <code>switch</code> keyword is followed by an expression enclosed in parentheses, called the <b>switch comparand</b>. This is the expression whose value is being compared. <span>This expression is optional, and defaults to <code>true</code>.</span> The remainder of the <code>switch</code> expression consists of one or more <code>case</code> clauses, with one or more <code>case operand expressions</code> each, and a <code>default</code> clause. </p><p>The first step in evaluating a switch expression is to apply atomization to the value of the switch comparand. <span>Call the result the <b>switch value</b>. If the <b>switch value</b></span> is a sequence of length greater than one, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. In the absence of a switch comparand, the switch value is the <code>xs:boolean</code> value <code>true</code>.</p><p>The <span><b>switch value</b> is compared to</span> each <a href="#prod-xquery40-SwitchCaseOperand">SwitchCaseOperand</a> in turn until a match is found or the list is exhausted. The matching is performed as follows:</p><ol class="enumar"><li><p>The <a href="#prod-xquery40-SwitchCaseOperand">SwitchCaseOperand</a> is evaluated.</p></li><li><p>The resulting value is atomized: call this the <b>case value</b>.</p></li><li><p><span style="display: none;" class="delete_version">If the <b>case value</b> is an empty sequence, then a match occurs if and only if the <b>switch value</b> is an empty sequence.</span><span style="display: none;" class="add_version">If the <b>case value</b> is the empty sequence, then a match occurs if and only if the <b>switch value</b> is the empty sequence.</span><span class="modify_version">If the <b>case value</b> is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, then a match occurs if and only if the <b>switch value</b> is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p>Otherwise, the <a title="singleton" class="termref" href="#dt-singleton">singleton</a><b>switch value</b> is compared individually with each item in the <b>case value</b> in turn, and a match occurs if and only if these two atomic items are <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-contextually-equal">contextually equal</a><sup><small>FO</small></sup>, using the default collation in the static context.</p></li></ol><p> [<a id="id-effective-case-switch-expression" title="effective case">Definition</a>: The <b>effective case</b> of a switch expression is the first case clause that matches, using the rules given above, or the default clause if no such case clause exists.] The value of the switch expression is the value of the return expression in the effective case.</p><p>Switch expressions have rules regarding the propagation of dynamic errors: <span>see <a href="#id-guarded-expressions"><b>2.5.5 Guarded Expressions</b></a>. These rules mean that</span> the return clauses of a switch expression must not raise any dynamic errors except in the effective case. Dynamic errors raised in the operand expressions of the switch or the case clauses are propagated; however, an implementation must not raise dynamic errors in the operand expressions of case clauses that occur after the effective case. An implementation is permitted to raise dynamic errors in the operand expressions of case clauses that occur before the effective case, but not required to do so.</p><p>The following example shows how a switch expression might be used:</p><div class="exampleInner"><pre xml:space="preserve">switch ($animal) {
  case "Cow" return "Moo"
  case "Cat" return "Meow"
  case "Duck", "Goose" return "Quack"
  default return "What's that odd noise?"
}</pre></div><p>The curly brackets in a switch expression are optional. The above example can equally be written:</p><div class="exampleInner"><pre xml:space="preserve">switch ($animal) 
  case "Cow" return "Moo"
  case "Cat" return "Meow"
  case "Duck", "Goose" return "Quack"
  default return "What's that odd noise?"</pre></div><p>The following example illustrates a switch expression where the comparand is defaulted to <code>true</code>:</p><div class="exampleInner"><pre xml:space="preserve">switch () {
  case ($a le $b) return "lesser"
  case ($a ge $b) return "greater"
  case ($a eq $b) return "equal"
  default return "not comparable"
}</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The comparisons are performed using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-deep-equal"><code>fn:deep-equal</code></a> function, after atomization. This means that a case expression such as <code>@married</code> tests <code>fn:data(@married)</code> rather than <code>fn:boolean(@married)</code>. If the effective boolean value of the expression is wanted, this can be achieved with an explicit call of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a>.</p></div></div><div class="_diffs div2"><h3><a id="id-quantified-expressions"></a>4.19 <a href="#id-quantified-expressions" style="text-decoration: none">Quantified Expressions</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-try-catch">next</a> | <a href="#id-switch">previous</a>)</p><ol><li><p> If a type declaration is present, the supplied values in the input sequence are now coerced to the required type. Type declarations are now permitted in XPath as well as XQuery. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1316">1316</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1384">1384</a>&nbsp;13 August 2024]</i></p></li></ol></div><p>Quantified expressions support existential and universal quantification. The value of a quantified expression is always <code>true</code> or <code>false</code>.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-QuantifiedExpr"></a><code><a href="#prod-xquery40-QuantifiedExpr">QuantifiedExpr</a></code></td><td>::=</td><td><code>("some" | "every") (<a href="#doc-xquery40-QuantifiedExpr-QuantifierBinding">QuantifierBinding</a> ++ ",") "satisfies" <a href="#doc-xquery40-QuantifiedExpr-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-QuantifiedExpr-QuantifierBinding"></a><code><a href="#prod-xquery40-QuantifierBinding">QuantifierBinding</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-QuantifiedExpr-VarNameAndType">VarNameAndType</a> "in" <a href="#doc-xquery40-QuantifiedExpr-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-QuantifiedExpr-VarNameAndType"></a><code><a href="#prod-xquery40-VarNameAndType">VarNameAndType</a></code></td><td>::=</td><td><code>"$" <a href="#doc-xquery40-QuantifiedExpr-EQName">EQName</a><a href="#doc-xquery40-QuantifiedExpr-TypeDeclaration">TypeDeclaration</a>?</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-QuantifiedExpr-EQName"></a><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-QName">QName</a> | <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-QuantifiedExpr-TypeDeclaration"></a><code><a href="#prod-xquery40-TypeDeclaration">TypeDeclaration</a></code></td><td>::=</td><td><code>"as" <a href="#doc-xquery40-QuantifiedExpr-SequenceType">SequenceType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-QuantifiedExpr-SequenceType"></a><code><a href="#prod-xquery40-SequenceType">SequenceType</a></code></td><td>::=</td><td><code>("empty-sequence" "(" ")")<br>| (<a href="#doc-xquery40-ItemType">ItemType</a><a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-QuantifiedExpr-ExprSingle"></a><code><a href="#prod-xquery40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-FLWORExpr">FLWORExpr</a><br>| <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xquery40-SwitchExpr">SwitchExpr</a><br>| <a href="#doc-xquery40-TypeswitchExpr">TypeswitchExpr</a><br>| <a href="#doc-xquery40-IfExpr">IfExpr</a><br>| <a href="#doc-xquery40-TryCatchExpr">TryCatchExpr</a><br>| <a href="#doc-xquery40-OrExpr">OrExpr</a></code></td></tr></tbody></table><p>A <b>quantified expression</b> begins with a <b>quantifier</b>, which is the keyword <code>some</code> or <code>every</code>, followed by one or more in-clauses that are used to bind variables, followed by the keyword <code>satisfies</code> and a test expression. Each in-clause associates a variable with an expression that returns a sequence of items, called the binding sequence for that variable. The value of the quantified expression is defined by the following rules:</p><ol class="enumar"><li><p>If the <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a> contains more than one <a href="#prod-xquery40-QuantifierBinding">QuantifierBinding</a>, then it is equivalent to the expression obtained by replacing each comma with <code>satisfies some</code> or <code>satisfies every</code> respectively. For example, the expression <code>some $x in X, $y in Y satisfies $x = $y</code> is equivalent to <code>some $x in X satisfies some $y in Y satisfies $x = $y</code>, while the expression <code>every $x in X, $y in Y satisfies $x lt $y</code> is equivalent to <code>every $x in X satisfies every $y in Y satisfies $x lt $y</code></p></li><li><p>If the quantifier is <code>some</code>, the <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a> returns <code>true</code> if at least one evaluation of the test expression has the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a><code>true</code>; otherwise it returns <code>false</code>. In consequence, if the binding sequence is empty, the result of the <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a> is <code>false</code>.</p></li><li><p>If the quantifier is <code>every</code>, the <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a> returns <code>true</code> if every evaluation of the test expression has the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a><code>true</code>; otherwise it returns <code>false</code>. In consequence, if the binding sequence is empty, the result of the <a href="#doc-xquery40-QuantifiedExpr">QuantifiedExpr</a> is <code>true</code>.</p></li></ol><p>The scope of a variable bound in a quantified expression comprises all subexpressions of the quantified expression that appear after the variable binding. The scope does not include the expression to which the variable is bound. </p><p>Each variable binding may be accompanied by a <b>type declaration</b>, which consists of the keyword <code>as</code> followed by the static type of the variable, declared using the syntax in <a href="#id-sequencetype-syntax"><b>3.1 Sequence Types</b></a>. The type declaration defines a required type for the value. At run-time, the supplied value for the variable is converted to the required type by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. If conversion is not possible, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p><p>The order in which test expressions are evaluated for the various items in the binding sequence is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. If the quantifier is <code>some</code>, an implementation may return <code>true</code> as soon as it finds one item for which the test expression has an <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of <code>true</code>, and it may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> as soon as it finds one item for which the test expression raises an error. Similarly, if the quantifier is <code>every</code>, an implementation may return <code>false</code> as soon as it finds one item for which the test expression has an <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of <code>false</code>, and it may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> as soon as it finds one item for which the test expression raises an error. As a result of these rules, the value of a quantified expression is not deterministic in the presence of errors, as illustrated in the examples below.</p><p>Here are some examples of quantified expressions:</p><ul><li><p>This expression is <code>true</code> if every <code>part</code> element has a <code>discounted</code> attribute (regardless of the values of these attributes):</p><div class="exampleInner"><pre xml:space="preserve">every $part in /parts/part satisfies $part/@discounted</pre></div></li><li><p>This expression is <code>true</code> if at least one <code>employee</code> element satisfies the given comparison expression:</p><div class="exampleInner"><pre xml:space="preserve">some $emp in /emps/employee satisfies $emp/bonus &gt; 0.25 * $emp/salary</pre></div></li><li><p>This expression is <code>true</code> if every <code>employee</code> element has at least one <code>salary</code> child with the attribute <code>current="true"</code>:</p><div class="exampleInner"><pre xml:space="preserve">every $emp in /emps/employee satisfies (
  some $sal in $emp/salary satisfies $sal/@current = 'true'
)</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Like many quantified expressions, this can be simplified. This example can be written <code>every $emp in /emps/employee satisfies $emp/salary[@current = 'true']</code>, or even more concisely as <code>empty(/emps/employee[not(salary/@current = 'true')]</code>.</p><p>Another alternative in XQuery 4.0 is to use the higher-order functions <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-some"><code>fn:some</code></a> and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-every"><code>fn:every</code></a>. This example can be written <code>every(/emps/employee, fn { salary/@current = 'true' })</code></p></div></li><li><p>In the following examples, each quantified expression evaluates its test expression over nine pairs of items, formed from the Cartesian product of the sequences <code>(1, 2, 3)</code> and <code>(2, 3, 4)</code>. The expression beginning with <code>some</code> evaluates to <code>true</code>, and the expression beginning with <code>every</code> evaluates to <code>false</code>.</p><div class="exampleInner"><pre xml:space="preserve">some $x in (1, 2, 3), $y in (2, 3, 4) satisfies $x + $y = 4</pre></div><div class="exampleInner"><pre xml:space="preserve">every $x in (1, 2, 3), $y in (2, 3, 4) satisfies $x + $y = 4</pre></div></li><li><p>This quantified expression may either return <code>true</code> or raise a <a title="type error" class="termref" href="#dt-type-error">type error</a>, since its test expression returns <code>true</code> for one item and raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> for another:</p><div class="exampleInner"><pre xml:space="preserve">some $x in (1, 2, "cat") satisfies $x * 2 = 4</pre></div></li><li><p>This quantified expression may either return <code>false</code> or raise a <a title="type error" class="termref" href="#dt-type-error">type error</a>, since its test expression returns <code>false</code> for one item and raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> for another:</p><div class="exampleInner"><pre xml:space="preserve">every $x in (1, 2, "cat") satisfies $x * 2 = 4</pre></div></li><li><p>This quantified expression returns <code>true</code>, because the binding sequence is empty, despite the fact that the condition can never be satisfied:</p><div class="exampleInner"><pre xml:space="preserve">every $x in () satisfies ($x lt 0 and $x gt 0)</pre></div></li><li><p><span style="display: none;" class="delete_version">This quantified expression is <a title="implausible" class="termref" href="#dt-implausible">implausible</a> because it will always fail with a type error except in the case where <code>$input</code> is an empty sequence. If <code>$input</code> contains one or more <code>xs:date</code> values, a processor <span class="verb">must</span> raise a type error on the grounds that an <code>xs:date</code> cannot be compared to an <code>xs:integer</code>. If <code>$input</code> is empty, the processor <span class="verb">may</span> (or may not) report this error:</span><span style="display: none;" class="add_version">This quantified expression is <a title="implausible" class="termref" href="#dt-implausible">implausible</a> because it will always fail with a type error except in the case where <code>$input</code> is the empty sequence. If <code>$input</code> contains one or more <code>xs:date</code> values, a processor <span class="verb">must</span> raise a type error on the grounds that an <code>xs:date</code> cannot be compared to an <code>xs:integer</code>. If <code>$input</code> is empty, the processor <span class="verb">may</span> (or may not) report this error:</span><span class="modify_version">This quantified expression is <a title="implausible" class="termref" href="#dt-implausible">implausible</a> because it will always fail with a type error except in the case where <code>$input</code> is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. If <code>$input</code> contains one or more <code>xs:date</code> values, a processor <span class="verb">must</span> raise a type error on the grounds that an <code>xs:date</code> cannot be compared to an <code>xs:integer</code>. If <code>$input</code> is empty, the processor <span class="verb">may</span> (or may not) report this error:</span></p><div class="exampleInner"><pre xml:space="preserve">every $x as xs:date in $input satisfies ($x lt 0)</pre></div></li><li><p>This quantified expression contains a <a href="#prod-xquery40-TypeDeclaration">type declaration</a> that is not satisfied by every item in the test expression. The expression may either return <code>true</code> or raise a <a title="type error" class="termref" href="#dt-type-error">type error</a>.</p><div class="exampleInner"><pre xml:space="preserve">some $x as xs:integer in (1, 2, "cat") satisfies $x * 2 = 4</pre></div></li></ul></div><div class="_diffs div2 xquery"><h3><a id="id-try-catch"></a>4.20 <a href="#id-try-catch" style="text-decoration: none">Try/Catch Expressions</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-typeswitch">next</a> | <a href="#id-quantified-expressions">previous</a>)</p><ol><li><p> A new variable <code>$err:map</code> is available, capturing all error information in one place. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/32">32</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/493">493</a>&nbsp;16 May 2023]</i></p></li><li><p><code>$err:stack-trace</code> provides information about the current state of execution. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/689">689</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1470">1470</a>&nbsp;1 October 2024]</i></p></li><li><p> A <code>finally</code> clause can be supplied, which will always be evaluated after the expressions of the try/catch clauses. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/501">501</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1914">1914</a>&nbsp;4 April 2025]</i></p></li></ol></div><p>The try/catch expression provides error handling for dynamic errors and type errors raised during dynamic evaluation, including errors raised by the XQuery implementation and errors explicitly raised in a query using the <code>fn:error()</code> function.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TryCatchExpr"></a><code><a href="#prod-xquery40-TryCatchExpr">TryCatchExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-TryCatchExpr-TryClause">TryClause</a> ((<a href="#doc-xquery40-TryCatchExpr-CatchClause">CatchClause</a>+ <a href="#doc-xquery40-TryCatchExpr-FinallyClause">FinallyClause</a>?) | <a href="#doc-xquery40-TryCatchExpr-FinallyClause">FinallyClause</a>)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TryCatchExpr-TryClause"></a><code><a href="#prod-xquery40-TryClause">TryClause</a></code></td><td>::=</td><td><code>"try" <a href="#doc-xquery40-TryCatchExpr-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TryCatchExpr-EnclosedExpr"></a><code><a href="#prod-xquery40-EnclosedExpr">EnclosedExpr</a></code></td><td>::=</td><td><code>"{" <a href="#doc-xquery40-Expr">Expr</a>? "}"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TryCatchExpr-CatchClause"></a><code><a href="#prod-xquery40-CatchClause">CatchClause</a></code></td><td>::=</td><td><code>"catch" <a href="#doc-xquery40-TryCatchExpr-NameTestUnion">NameTestUnion</a><a href="#doc-xquery40-TryCatchExpr-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TryCatchExpr-NameTestUnion"></a><code><a href="#prod-xquery40-NameTestUnion">NameTestUnion</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-TryCatchExpr-NameTest">NameTest</a> ++ "|")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TryCatchExpr-NameTest"></a><code><a href="#prod-xquery40-NameTest">NameTest</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-TryCatchExpr-EQName">EQName</a> | <a href="#doc-xquery40-TryCatchExpr-Wildcard">Wildcard</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TryCatchExpr-EQName"></a><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-QName">QName</a> | <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TryCatchExpr-Wildcard"></a><code><a href="#prod-xquery40-Wildcard">Wildcard</a></code></td><td>::=</td><td><code>"*"<br>| (<a href="#prod-xquery40-NCName">NCName</a> ":*")<br>| ("*:" <a href="#prod-xquery40-NCName">NCName</a>)<br>| (<a href="#prod-xquery40-BracedURILiteral">BracedURILiteral</a> "*")</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-TryCatchExpr-FinallyClause"></a><code><a href="#prod-xquery40-FinallyClause">FinallyClause</a></code></td><td>::=</td><td><code>"finally" <a href="#doc-xquery40-TryCatchExpr-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody></table><p>A try/catch expression catches <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a> and <a title="type error" class="termref" href="#dt-type-error">type errors</a> raised by the evaluation of the target expression of the <code>try</code> clause. If the <a title="content expression" class="termref" href="#dt-content-expression">content expression</a> of the try clause does not raise a dynamic error or a type error, the result of the try/catch expression is the result of the content expression.</p><p>If the target expression raises a dynamic error or a type error, the result of the try/catch expression is obtained by evaluating the first <code>catch</code> clause that “matches” the error value, as described below. If no catch clause “matches” the error value, then the try/catch expression raises the error that was raised by the target expression. A <code>catch</code> clause with one or more NameTests matches any error whose error code matches one of these NameTests. For instance, if the error code is <code>err:FOER0000</code>, then it matches a <code>catch</code> clause whose ErrorList is <code>err:FOER0000 | err:FOER0001</code>. Wildcards may be used in NameTests; thus, the error code <code>err:FOER0000</code> also matches a <code>catch</code> clause whose ErrorList is <code>err:*</code> or <code>*:FOER0000</code> or <code>*</code>.</p><p>Within the scope of the <code>catch</code> clause, a number of variables are implicitly declared, giving information about the error that occurred. These variables are initialized as described in the following table:</p><table class="medium"><thead><tr><th style="text-align:left">Variable</th><th style="text-align:left">Type</th><th style="text-align:left">Value</th></tr></thead><tbody><tr><td style="vertical-align:top"><code>$err:code</code></td><td style="vertical-align:top"><code>xs:QName</code></td><td style="vertical-align:top">The error code</td></tr><tr><td style="vertical-align:top"><code>$err:description</code></td><td style="vertical-align:top"><code>xs:string?</code></td><td style="vertical-align:top">A description of the error condition; <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence if no description is available (for example, if the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-error"><code>error</code></a> function was called with one argument).</td></tr><tr><td style="vertical-align:top"><code>$err:value</code></td><td style="vertical-align:top"><code>item()*</code></td><td style="vertical-align:top">Value associated with the error. For an error raised by calling the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-error"><code>error</code></a> function, this is the value of the third argument (if supplied).</td></tr><tr><td style="vertical-align:top"><code>$err:module</code></td><td style="vertical-align:top"><code>xs:string?</code></td><td style="vertical-align:top">The URI (or system ID) of the module containing the expression where the error occurred, or <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence if the information is not available.</td></tr><tr><td style="vertical-align:top"><code>$err:line-number</code></td><td style="vertical-align:top"><code>xs:integer?</code></td><td style="vertical-align:top"><span style="display: none;" class="delete_version">The line number within the module where the error occurred, or an empty sequence if the information is not available. The value <span class="verb">may</span> be approximate.</span><span style="display: none;" class="add_version">The line number within the module where the error occurred, or the empty sequence if the information is not available. The value <span class="verb">may</span> be approximate.</span><span class="modify_version">The line number within the module where the error occurred, or <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence if the information is not available. The value <span class="verb">may</span> be approximate.</span></td></tr><tr><td style="vertical-align:top"><code>$err:column-number</code></td><td style="vertical-align:top"><code>xs:integer?</code></td><td style="vertical-align:top"><span style="display: none;" class="delete_version">The column number within the module where the error occurred, or an empty sequence if the information is not available. The value <span class="verb">may</span> be approximate.</span><span style="display: none;" class="add_version">The column number within the module where the error occurred, or the empty sequence if the information is not available. The value <span class="verb">may</span> be approximate.</span><span class="modify_version">The column number within the module where the error occurred, or <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence if the information is not available. The value <span class="verb">may</span> be approximate.</span></td></tr><tr><td style="vertical-align:top"><code>$err:stack-trace</code></td><td style="vertical-align:top"><code>xs:string?</code></td><td style="vertical-align:top"><a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">Implementation-dependent</a> information about the current state of execution, or <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence if no stack trace is available. The variable must be bound so that a query can reference it without raising an error.</td></tr><tr><td style="vertical-align:top"><code>$err:additional</code></td><td style="vertical-align:top"><code>item()*</code></td><td style="vertical-align:top"><a title="implementation defined" class="termref" href="#dt-implementation-defined">Implementation-defined</a>. Allows implementations to provide any additional information that might be useful. The variable must be bound so that a query can reference it without raising an error.</td></tr><tr><td style="vertical-align:top"><code>$err:map</code></td><td style="vertical-align:top"><code>map(*)</code></td><td style="vertical-align:top">A map with entries for all values that are bound to the variables above. The local names of the variables are assigned as keys. No map entries are created for those values that are empty sequences. The variable can be used to pass on all error information to another function.</td></tr></tbody></table><p>Try/catch expressions have a special rule for propagating dynamic errors. The try/catch expression ignores any dynamic errors encountered in catch clauses other than the first catch clause that matches an error raised by the try clause, and these catch clause expressions need not be evaluated.</p><p>Static errors are not caught by the try/catch expression.</p><p>If a function call occurs within a <code>try</code> clause, errors raised by evaluating the corresponding function are caught by the try/catch expression. If a variable reference is used in a <code>try</code> clause, errors raised by binding a value to the variable are not caught unless the binding expression occurs within the <code>try</code> clause.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The presence of a try/catch expression does not prevent an implementation from using a lazy evaluation strategy, nor does it prevent an optimizer performing expression rewrites. However, if the evaluation of an expression inside a try/catch is rewritten or deferred in this way, it must take its try/catch context with it. Similarly, expressions that were written outside the try/catch expression may be evaluated inside the try/catch, but only if they retain their original try/catch behavior. The presence of a try/catch does not change the rules that allow the processor to evaluate expressions in such a way that may avoid the detection of some errors. </p></div><p><span style="display: none;" class="delete_version">If a concluding <code>finally</code> clause exists, its expression will be evaluated after the expressions of the <code>try</code> clause and a possibly evaluated <code>catch</code> clause. If it raises an error, this error is returned instead of a result or an error that resulted from a <code>try</code> or <code>catch</code> expression. If it raises no error, it must yield an empty sequence; otherwise, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXQTY0153" title="err:XQTY0153">err:XQTY0153</a>].</span><span style="display: none;" class="add_version">If a concluding <code>finally</code> clause exists, its expression will be evaluated after the expressions of the <code>try</code> clause and a possibly evaluated <code>catch</code> clause. If it raises an error, this error is returned instead of a result or an error that resulted from a <code>try</code> or <code>catch</code> expression. If it raises no error, it must yield the empty sequence; otherwise, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXQTY0153" title="err:XQTY0153">err:XQTY0153</a>].</span><span class="modify_version">If a concluding <code>finally</code> clause exists, its expression will be evaluated after the expressions of the <code>try</code> clause and a possibly evaluated <code>catch</code> clause. If it raises an error, this error is returned instead of a result or an error that resulted from a <code>try</code> or <code>catch</code> expression. If it raises no error, it must yield <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence; otherwise, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXQTY0153" title="err:XQTY0153">err:XQTY0153</a>].</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>A <code>finally</code> clause can be used to ensure that an expression will always be evaluated, no matter if the <code>try</code> expression is successful or if it fails. For example, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-message"><code>fn:message</code></a> can be called in the <code>finally</code> clause to ensure that an expression has been evaluated even if an error is raised.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>If <code>try</code> and <code>finally</code> clauses are specified, <code>catch</code> clauses can be omitted.</p></div><p>Here are some examples of try/catch expressions.</p><ul><li><p>A try/catch expression without name tests catches any error:</p><div class="exampleInner"><pre xml:space="preserve">try {
  $x cast as xs:integer
} catch * {
  0
}</pre></div></li><li><p>With the following catch clause, only <code>err:FORG0001</code> is caught:</p><div class="exampleInner"><pre xml:space="preserve">try {
  $x cast as xs:integer
} catch err:FORG0001 {
  0
}</pre></div></li><li><p>This try/catch expression specifies that errors <code>err:FORG0001</code> and <code>err:XPTY0004</code> are caught:</p><div class="exampleInner"><pre xml:space="preserve">try {
  $x cast as xs:integer
} catch err:FORG0001 | err:XPTY0004 {
  0
}</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In some implementations, <code>err:XPTY0004</code> is detected during static evaluation; it can only be caught if it is raised during dynamic evaluation.</p></div></li><li><p>This try/catch expression shows how to return information about the error using implicitly defined error variables:</p><div class="exampleInner"><pre xml:space="preserve">try {
  error(#err:FOER0000)
} catch * {
  $err:code, $err:value, " module: ",
  $err:module, "(", $err:line-number, ",", $err:column-number, ")"
}</pre></div></li><li><p>Errors raised by using the result of a try/catch expression are not caught, since they are outside the scope of the <code>try</code> expression.</p><div class="exampleInner"><pre xml:space="preserve">declare function local:thrice($x as xs:integer) as xs:integer {
  3 * $x
};

local:thrice(try { "oops" } catch * { 3 } )</pre></div><p>In this example, the try block succeeds, returning the string <code>"oops"</code>, which is not a valid argument to the function.</p></li><li><p>All available information about the error is serialized:</p><div class="exampleInner"><pre xml:space="preserve">try {
  1 + &lt;empty/&gt;
} catch * {
  serialize($err:map, { 'method': 'adaptive' })
}</pre></div></li><li><p><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-message"><code>fn:message</code></a> will always be called, no matter if the division succeeds:</p><div class="exampleInner"><pre xml:space="preserve">for $i in 0 to 2
return try {
  1 div $i
} catch err:FOAR0001 {
  'division error'
} finally {
  message('1 was divided by ' || $i)
}</pre></div></li></ul></div><div class="_diffs div2"><h3><a id="id-expressions-on-datatypes"></a>4.21 <a href="#id-expressions-on-datatypes" style="text-decoration: none">Expressions on SequenceTypes</a></h3><p> The <code>instance of</code>, <code>cast</code>, <code>castable</code>, and <code>treat</code> expressions are used to test whether a value conforms to a given type or to convert it to an instance of a given type. </p><div class="_diffs div3"><h4><a id="id-cast"></a>4.21.3 <a href="#id-cast" style="text-decoration: none">Cast</a></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CastExpr"></a><code><a href="#prod-xquery40-CastExpr">CastExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-CastExpr-PipelineExpr">PipelineExpr</a> ("cast" "as" <a href="#doc-xquery40-CastExpr-CastTarget">CastTarget</a> "?"?)?</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CastExpr-PipelineExpr"></a><code><a href="#prod-xquery40-PipelineExpr">PipelineExpr</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-ArrowExpr">ArrowExpr</a> ("-&gt;" <a href="#doc-xquery40-ArrowExpr">ArrowExpr</a>)*</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CastExpr-CastTarget"></a><code><a href="#prod-xquery40-CastTarget">CastTarget</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-CastExpr-TypeName">TypeName</a> | <a href="#doc-xquery40-CastExpr-ChoiceItemType">ChoiceItemType</a> | <a href="#doc-xquery40-CastExpr-EnumerationType">EnumerationType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CastExpr-TypeName"></a><code><a href="#prod-xquery40-TypeName">TypeName</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-CastExpr-EQName">EQName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CastExpr-EQName"></a><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-QName">QName</a> | <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CastExpr-ChoiceItemType"></a><code><a href="#prod-xquery40-ChoiceItemType">ChoiceItemType</a></code></td><td>::=</td><td><code>"(" (<a href="#doc-xquery40-CastExpr-ItemType">ItemType</a> ++ "|") ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CastExpr-ItemType"></a><code><a href="#prod-xquery40-ItemType">ItemType</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-RegularItemType">RegularItemType</a> | <a href="#doc-xquery40-FunctionType">FunctionType</a> | <a href="#doc-xquery40-CastExpr-TypeName">TypeName</a> | <a href="#doc-xquery40-CastExpr-ChoiceItemType">ChoiceItemType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-CastExpr-EnumerationType"></a><code><a href="#prod-xquery40-EnumerationType">EnumerationType</a></code></td><td>::=</td><td><code>"enum" "(" (<a href="#doc-xquery40-StringLiteral">StringLiteral</a> ++ ",") ")"</code></td></tr></tbody></table><p>Sometimes it is necessary to convert a value to a specific datatype. For this purpose, XQuery 4.0 provides a <code>cast</code> expression that creates a new value of a specific type based on an existing value. A <code>cast</code> expression takes two operands: an <b>input expression</b> and a <b>target type</b>. The type of the atomized value of the input expression is called the <b>input type</b>. The target type must be a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a>. In practice this means it may be any of:</p><ul><li><p>The name of an <a title="named item type" class="termref" href="#dt-named-item-type">named item type</a> defined in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, which in turn must refer to an item type in one of the following categories.</p></li><li><p>The name of a type defined in the <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a>, which must be a simple type (of variety atomic, list or union) [<a href="#ERRXQST0052" title="err:XQST0052">err:XQST0052</a>] . In addition, the target type cannot be <code>xs:NOTATION</code>, <code>xs:anySimpleType</code>, or <code>xs:anyAtomicType</code></p></li><li><p>A <code>ChoiceItemType</code> representing a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a> (such as <code>(xs:date | xs:dateTime)</code>).</p></li><li><p>An <code>EnumerationType</code> such as <code>enum("red", "green", "blue")</code>.</p></li></ul><p>Otherwise, a static error is raised [<a href="#ERRXPST0080" title="err:XPST0080">err:XPST0080</a>].</p><p><span style="display: none;" class="delete_version">The optional occurrence indicator <code>?</code> denotes that an empty sequence is permitted.</span><span style="display: none;" class="add_version">The optional occurrence indicator <code>?</code> denotes that the empty sequence is permitted.</span><span class="modify_version">The optional occurrence indicator <code>?</code> denotes that <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence is permitted.</span></p><p>Casting a node to <code>xs:QName</code> can cause surprises because it uses the <a title="static context" class="termref" href="#dt-static-context">static context</a> of the cast expression to provide the <a title="namespace binding" class="termref" href="#dt-namespace-binding">namespace bindings</a> for this operation. Instead of casting to <code>xs:QName</code>, it is generally preferable to use the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-QName"><code>fn:QName</code></a> function, which allows the namespace context to be taken from the document containing the QName.</p><p>The semantics of the <code>cast</code> expression are as follows:</p><ol class="enumar"><li><p>The input expression is evaluated.</p></li><li><p>The result of the first step is <a title="atomization" class="termref" href="#dt-atomization">atomized</a>.</p></li><li><p> If the result of atomization is a sequence of more than one atomic item, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>If the result of atomization is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence:</p><ol class="enumla"><li><p><span style="display: none;" class="delete_version">If <code>?</code> is specified after the target type, the result of the <code>cast</code> expression is an empty sequence.</span><span style="display: none;" class="add_version">If <code>?</code> is specified after the target type, the result of the <code>cast</code> expression is the empty sequence.</span><span class="modify_version">If <code>?</code> is specified after the target type, the result of the <code>cast</code> expression is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p> If <code>?</code> is not specified after the target type, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li></ol></li><li><p>If the result of atomization is a single atomic item, the result of the cast expression is determined by casting to the target type as described in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#casting">23 Casting</a>. When casting, an implementation may need to determine whether one type is derived by restriction from another. An implementation can determine this either by examining the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> or by using an alternative, <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> mechanism such as a data dictionary. The result of a cast expression is one of the following: </p><ol class="enumla"><li><p> A value of the target type (or, in the case of list types, a sequence of values that are instances of the item type of the list type). </p></li><li><p> A type error, if casting from the source type to the target type is not supported (for example attempting to convert an integer to a date). </p></li><li><p> A dynamic error, if the particular input value cannot be converted to the target type (for example, attempting to convert the string <code>"three"</code> to an integer). </p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Casting to an enumeration type relies on the fact that an enumeration type is a generalized atomic type. So the expression <code>cast $x as enum("red", "green")</code> has the following effect:</p><ul><li><p>If <code>$x</code> is an instance of <code>xs:string</code>, the expression returns <code>$x</code> unchanged if it is one of the permitted strings, and raises a dynamic error otherwise;</p></li><li><p>In other cases, the expression first casts <code>$x</code> to <code>xs:string</code>, and then proceeds as above.</p></li></ul></div></li></ol></div></div></div></div><div class="back"><div class="_diffs div1"><h2><a id="id-glossary"></a>G <a href="#id-glossary" style="text-decoration: none">Glossary</a> (Non-Normative)</h2><dl><dt><a href="#dt-absolute-path-expression">absolute path expression</a></dt><dd><p> An <b>absolute path expression</b> is an instance of the production <a href="#prod-xquery40-AbsolutePathExpr">AbsolutePathExpr</a>: it consists of either (a) the operator <code>/</code> followed by zero or more operands separated by <code>/</code> or <code>//</code> operators, or (b) the operator <code>//</code> followed by one or more operands separated by <code>/</code> or <code>//</code> operators.</p></dd><dt><a href="#dt-and-expression">and expression</a></dt><dd><p>An <b>and expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production <a href="#prod-xquery40-AndExpr">AndExpr</a>.</p></dd><dt><a href="#dt-anonymous-function">anonymous function</a></dt><dd><p> An <b>anonymous function</b> is a <a title="function item" class="termref" href="#dt-function-item">function item</a> with no name. Anonymous functions may be created, for example, by evaluating an inline function expression or by partial function application.</p></dd><dt><a href="#dt-application-function">application function</a></dt><dd><p><b>Application functions</b> are function definitions written in a host language such as XQuery or XSLT whose syntax and semantics are defined in this family of specifications. Their behavior (including the rules determining the static and dynamic context) follows the rules for such functions in the relevant host language specification.</p></dd><dt><a href="#dt-arg-expr">argument expression</a></dt><dd><p>An argument to a function call is either an <b>argument expression</b> or an <a href="#prod-xquery40-ArgumentPlaceholder">ArgumentPlaceholder</a> (<code>?</code>); in both cases it may either be supplied positionally, or identified by a name (called a keyword).</p></dd><dt><a href="#dt-arity-range">arity range</a></dt><dd><p>A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> has an <b>arity range</b>, which is a range of consecutive non-negative integers. If the function definition has <var>M</var> required parameters and <var>N</var> optional parameters, then its arity range is from <var>M</var> to <var>M</var>+<var>N</var> inclusive.</p></dd><dt><a href="#dt-array">array</a></dt><dd><p>An <b>array</b> is a <a title="function item" class="termref" href="#dt-function-item">function item</a> that associates a set of positions, represented as positive integer keys, with values.</p></dd><dt><a href="#dt-associated-value">associated value</a></dt><dd><p>The value associated with a given key is called the <b>associated value</b> of the key.</p></dd><dt><a href="#dt-atomic-item">atomic item</a></dt><dd><p>An <b>atomic item</b> is a value in the value space of an <b>atomic type</b>, as defined in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.</p></dd><dt><a href="#dt-atomic-type">atomic type</a></dt><dd><p>An <b>atomic type</b> is a simple <a title="schema type" class="termref" href="#dt-schema-type">schema type</a> whose <a href="https://www.w3.org/TR/xmlschema11-1/#std-variety">{variety}<sup><small>XS11-1</small></sup></a> is <code>atomic</code>.</p></dd><dt><a href="#dt-atomization">atomization</a></dt><dd><p><b>Atomization</b> of a sequence is defined as the result of invoking the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-data"><code>fn:data</code></a> function, as defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#func-data">12.1.6 fn:data</a>.</p></dd><dt><a href="#dt-available-docs">available documents</a></dt><dd><p>The term <b>available documents</b> refers (TODO: for the time being) to the set of XML documents that an application is able to access by URI.</p></dd><dt><a href="#dt-axis-step">axis step</a></dt><dd><p>An <b>axis step</b> is an instance of the production <a href="#doc-xquery40-AxisStep">AxisStep</a>: it is an expression that returns a sequence of GNodes that are reachable from a starting GNode via a specified axis. An axis step has three parts: an <b>axis</b>, which defines the direction of movement for the step, a <a title="node test" class="termref" href="#dt-node-test">node test</a>, which selects GNodes based on their properties, and zero or more predicates which are used to filter the results.</p></dd><dt><a href="#dt-base-uri-decl">base URI declaration</a></dt><dd><p>A <b>base URI declaration</b> specifies the <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property. The <a title="Static Base URI" class="termref" href="#dt-static-base-uri">Static Base URI</a> property is used when resolving relative URI references.</p></dd><dt><a href="#dt-binding-collection">binding collection</a></dt><dd><p>In a <code>for</code> clause, when an expression is preceded by the keyword <code>in</code>, the value of that expression is called a <b>binding collection</b>.</p></dd><dt><a href="#dt-binding-sequence">binding sequence</a></dt><dd><p>In a <code>window</code> clause, when an expression is preceded by the keyword <code>in</code>, the value of that expression is called a <b>binding sequence</b>.</p></dd><dt><a href="#dt-boundary-space-decl">boundary-space declaration</a></dt><dd><p>A <b>boundary-space declaration</b> sets the <a title="boundary-space policy" class="termref" href="#dt-boundary-space-policy">boundary-space policy</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default. Boundary-space policy controls whether <a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace">boundary whitespace</a> is preserved by element constructors during processing of the query.</p></dd><dt><a href="#dt-boundary-space-policy">boundary-space policy</a></dt><dd><p><b>Boundary-space policy.</b> This component controls the processing of <a title="boundary whitespace" class="termref" href="#dt-boundary-whitespace">boundary whitespace</a> by <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructors</a>, as described in <a href="#id-whitespace"><b>4.12.1.4 Boundary Whitespace</b></a>.</p></dd><dt><a href="#dt-boundary-whitespace">boundary whitespace</a></dt><dd><p><b>Boundary whitespace</b> is a sequence of consecutive whitespace characters within the content of a <a title="direct element constructor" class="termref" href="#dt-direct-elem-const">direct element constructor</a>, that is delimited at each end either by the start or end of the content, or by a <a href="#prod-xquery40-DirectConstructor">DirectConstructor</a>, or by an <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a>. For this purpose, characters generated by <a title="character reference" class="termref" href="#dt-character-reference">character references</a> such as <code>&amp;#x20;</code> or by <a href="#prod-xquery40-CDataSection">CDataSections</a> are not considered to be whitespace characters.</p></dd><dt><a href="#dt-character-reference">character reference</a></dt><dd><p>A <b>character reference</b> is an XML-style reference to a <a href="#Unicode">[Unicode]</a> character, identified by its decimal or hexadecimal codepoint.</p></dd><dt><a href="#dt-choice-item-type">choice item type</a></dt><dd><p>A <b>choice item type</b> defines an item type that is the union of a number of alternatives. For example the type <code>(xs:hexBinary | xs:base64Binary)</code> defines the union of these two primitive <a title="atomic type" class="termref" href="#dt-atomic-type">atomic types</a>, while the type <code>(map(*) | array(*))</code> matches any item that is either a map or an array.</p></dd><dt><a href="#dt-coercion-rules">coercion rules</a></dt><dd><p>The <b>coercion rules</b> are rules used to convert a supplied value to a required type, for example when converting an argument of a function call to the declared type of the function parameter. </p></dd><dt><a href="#dt-collation">collation</a></dt><dd><p>A <b>collation</b> is a specification of the manner in which strings and URIs are compared and, by extension, ordered. For a more complete definition of collation, see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#string-compare">5.3 Comparison of strings</a>.</p></dd><dt><a href="#dt-comma-operator">comma operator</a></dt><dd><p>A <b>comma operator</b> is a comma used specifically as the operator in a <a title="sequence expression" class="termref" href="#dt-sequence-expression">sequence expression</a>.</p></dd><dt><a href="#dt-complex-terminal">complex terminal</a></dt><dd><p>A <b>complex terminal</b> is a <a title="variable terminal" class="termref" href="#dt-variable-terminal">variable terminal</a> whose production rule references, directly or indirectly, an <a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule">ordinary production rule</a>.</p></dd><dt><a href="#dt-computed-elem-const">computed element constructor</a></dt><dd><p>A <b>computed element constructor</b> creates an element node, allowing both the name and the content of the node to be computed.</p></dd><dt><a href="#dt-constructed-element-namespace-rule">constructed element namespace rule</a></dt><dd><p> When an unprefixed lexical QName is expanded using the <b>constructed element namespace rule</b>, then it uses the namespace URI that is bound to the empty (zero-length) prefix in the <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a> of the <a title="static context" class="termref" href="#dt-static-context">static context</a>. If there is no such <a title="namespace binding" class="termref" href="#dt-namespace-binding">namespace binding</a> then it uses the <a title="no-namespace rule" class="termref" href="#dt-no-namespace-rule">no-namespace rule</a>.</p></dd><dt><a href="#dt-construction-decl">construction declaration</a></dt><dd><p>A <b>construction declaration</b> sets the <a title="construction mode" class="termref" href="#dt-construction-mode">construction mode</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default.</p></dd><dt><a href="#dt-construction-mode">construction mode</a></dt><dd><p><b>Construction mode.</b> The construction mode governs the behavior of element and document node constructors. If construction mode is <code>preserve</code>, the type of a constructed element node is <code>xs:anyType</code>, and all attribute and element nodes copied during node construction retain their original types. If construction mode is <code>strip</code>, the type of a constructed element node is <code>xs:untyped</code>; all element nodes copied during node construction receive the type <code>xs:untyped</code>, and all attribute nodes copied during node construction receive the type <code>xs:untypedAtomic</code>.</p></dd><dt><a href="#dt-constructor-function">constructor function</a></dt><dd><p>The <b>constructor function</b> for a given simple type is used to convert instances of other simple types into the given type. The semantics of the constructor function call <code>T($arg)</code> are defined to be equivalent to the expression <code>$arg cast as T?</code>.</p></dd><dt><a href="#dt-content-expression">content expression</a></dt><dd><p>In an <a title="enclosed expression" class="termref" href="#dt-enclosed-expression">enclosed expression</a>, the optional expression enclosed in curly brackets is called the <b>content expression</b>.</p></dd><dt><a href="#dt-context-dependent">context dependent</a></dt><dd><p>A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> is said to be <b>context dependent</b> if its result depends on the static or dynamic context of its caller. A function definition may be context-dependent for some arities in its arity range, and context-independent for others: for example <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-name"><code>fn:name#0</code></a> is context-dependent while <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-name"><code>fn:name#1</code></a> is context-independent.</p></dd><dt><a href="#dt-context-node">context node</a></dt><dd><p>When the context value is a single item, it can also be referred to as the <b>context item</b>; when it is a single node, it can also be referred to as the <b>context node</b>.</p></dd><dt><a href="#dt-context-position">context position</a></dt><dd><p>The <b>context position</b> is the position of the context value within the series of values currently being processed.</p></dd><dt><a href="#dt-context-size">context size</a></dt><dd><p>The <b>context size</b> is the number of values in the series of values currently being processed.</p></dd><dt><a href="#dt-context-value">context value</a></dt><dd><p>The <b>context value</b> is the <a title="value" class="termref" href="#dt-value">value</a> currently being processed.</p></dd><dt><a href="#dt-copy-namespaces-decl">copy-namespaces declaration</a></dt><dd><p>A <b>copy-namespaces declaration</b> sets the value of <a title="copy-namespaces mode" class="termref" href="#dt-copy-namespaces-mode">copy-namespaces mode</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default. Copy-namespaces mode controls the namespace bindings that are assigned when an existing element node is copied by an element constructor or document constructor.</p></dd><dt><a href="#dt-copy-namespaces-mode">copy-namespaces mode</a></dt><dd><p><b>Copy-namespaces mode.</b> This component controls the <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a> property that is assigned when an existing element node is copied by an element constructor, as described in <a href="#id-element-constructor"><b>4.12.1 Direct Element Constructors</b></a>. Its value consists of two parts: <code>preserve</code> or <code>no-preserve</code>, and <code>inherit</code> or <code>no-inherit</code>.</p></dd><dt><a href="#dt-date-time">current dateTime</a></dt><dd><p><b>Current dateTime.</b> This information represents an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> point in time during the processing of <span class="xquery">a query</span> , and includes an explicit timezone. It can be retrieved by the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-current-dateTime"><code>fn:current-dateTime</code></a> function. If called multiple times during the execution of <span class="xquery">a query</span> , this function always returns the same result.</p></dd><dt><a href="#dt-datamodel">data model</a></dt><dd><p>XQuery 4.0 operates on the abstract, logical structure of an XML document or JSON object rather than its surface syntax. This logical structure, known as the <b>data model</b>, is defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>.</p></dd><dt><a href="#dt-decimal-format-decl">decimal-format declaration</a></dt><dd><p>A <b>decimal format declaration</b> adds a decimal format to the <a title="statically known decimal formats" class="termref" href="#dt-static-decimal-formats">statically known decimal formats</a>, which define the properties used to format numbers using the <code>fn:format-number()</code> function</p></dd><dt><a href="#id-static-decimal-format-decimal-separator">decimal-separator</a></dt><dd><p><b>decimal-separator</b><em>(<var>M</var>, <var>R</var>)</em> is used to separate the integer part of the number from the fractional part. The default value for both the marker and the rendition is <span class="unicode-codepoint">U+002E</span> (<span class="unicode-name">FULL STOP, PERIOD</span>, <code>.</code>) .</p></dd><dt><a href="#dt-default-annotation-namespace-rule">default annotation namespace rule</a></dt><dd><p> When an unprefixed lexical QName is expanded using the <b>annotation namespace rule</b>, then it uses the namespace URI <code>http://www.w3.org/2012/xquery</code>.</p></dd><dt><a href="#dt-default-calendar">default calendar</a></dt><dd><p><b>Default calendar.</b> This is the calendar used when formatting dates in human-readable output (for example, by the functions <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-date"><code>fn:format-date</code></a> and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-dateTime"><code>fn:format-dateTime</code></a>) if no other calendar is requested. The value is a string.</p></dd><dt><a href="#dt-def-collation">default collation</a></dt><dd><p><b>Default collation.</b> This identifies one of the collations in <a title="statically known collations" class="termref" href="#dt-static-collations">statically known collations</a> as the collation to be used by functions and operators for comparing and ordering values of type <code>xs:string</code> and <code>xs:anyURI</code> (and types derived from them) when no explicit collation is specified.</p></dd><dt><a href="#dt-default-collation-decl">default collation declaration</a></dt><dd><p>A <b>default collation declaration</b> sets the value of the <a title="default collation" class="termref" href="#dt-def-collation">default collation</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, overriding any implementation-defined default.</p></dd><dt><a href="#dt-default-collection">default collection</a></dt><dd><p><b>Default collection.</b> This is the sequence of items that would result from calling the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>fn:collection</code></a> function with no arguments.</p></dd><dt><a href="#dt-default-element-namespace-rule">default element namespace rule</a></dt><dd><p>When an unprefixed lexical QName is expanded using the <b>default element namespace rule</b>, then it uses the <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a>. If this is absent, or if it takes the special value <code>##any</code>, then the <a title="no-namespace rule" class="termref" href="#dt-no-namespace-rule">no-namespace rule</a> is used.</p></dd><dt><a href="#dt-default-function-namespace">default function namespace</a></dt><dd><p><b>Default function namespace.</b> This determines how unprefixed lexical QNames appearing in a <a title="static function call" class="termref" href="#dt-static-function-call">static function call</a> or a <a title="named function reference" class="termref" href="#dt-named-function-ref">named function reference</a> are interpreted.</p></dd><dt><a href="#dt-default-function-namespace-rule">default function namespace rule</a></dt><dd><p>When an unprefixed lexical QName is expanded using the <b>default function namespace rule</b>, the processor searches for a matching function definition as follows: first, if the static context includes a no-namespace function definition with the required local name and arity, then that function definition is used; otherwise, the name is expanded using the <a title="default function namespace" class="termref" href="#dt-default-function-namespace">default function namespace</a> from the <a title="static context" class="termref" href="#dt-static-context">static context</a>.</p></dd><dt><a href="#dt-default-in-scope-namespace">default in-scope namespace</a></dt><dd><p>The <b>default in-scope namespace</b> of an element node</p></dd><dt><a href="#dt-default-language">default language</a></dt><dd><p><b>Default language.</b> This is the natural language used when creating human-readable output (for example, by the functions <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-date"><code>fn:format-date</code></a> and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-integer"><code>fn:format-integer</code></a>) if no other language is requested. The value is a language code as defined by the type <code>xs:language</code>.</p></dd><dt><a href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a></dt><dd><p><b>Default namespace for elements and types.</b> This is either a namespace URI, or the special value <code>"##any"</code>, or <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM</small></sup>. This indicates how unprefixed QNames are interpreted when they appear in a position where an element name or type name is expected.</p></dd><dt><a href="#dt-default-empty-order">default order for empty sequences</a></dt><dd><p><b>Default order for empty sequences.</b> This component controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression, as described in <a href="#id-order-by-clause"><b>4.13.9 Order By Clause</b></a>.</p></dd><dt><a href="#dt-default-place">default place</a></dt><dd><p><b>Default place.</b> This is a geographical location used to identify the place where events happened (or will happen) when processing dates and times using functions such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-date"><code>fn:format-date</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-dateTime"><code>fn:format-dateTime</code></a>, and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-civil-timezone"><code>fn:civil-timezone</code></a>, if no other place is specified. It is used when translating timezone offsets to civil timezone names, and when using calendars where the translation from ISO dates/times to a local representation is dependent on geographical location. Possible representations of this information are an ISO country code or an Olson timezone name, but implementations are free to use other representations from which the above information can be derived. The only requirement is that it should uniquely identify a civil timezone, which means that country codes for countries with multiple timezones, such as the United States, are inadequate.</p></dd><dt><a href="#dt-default-type-namespace-rule">default type namespace rule</a></dt><dd><p>When an unprefixed lexical QName is expanded using the <b>default type namespace rule</b>, it uses the <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a>. If this is absent, the <a title="no-namespace rule" class="termref" href="#dt-no-namespace-rule">no-namespace rule</a> is used. If the <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a> has the special value <code>##any</code>, then the lexical QName refers to a name in the namespace <code>http://www.w3.org/2001/XMLSchema</code>.</p></dd><dt><a href="#dt-default-uri-collection">default URI collection</a></dt><dd><p><b>Default URI collection.</b> This is the sequence of URIs that would result from calling the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-uri-collection"><code>fn:uri-collection</code></a> function with no arguments.</p></dd><dt><a href="#delimiting-token">delimiting terminal symbol</a></dt><dd><p>The <b>delimiting terminal symbols</b> are: <code>!</code><code>!=</code><code>#</code><code>#)</code><code>$</code><code>%</code><code>(</code><code>(#</code><code>)</code><code>*</code><code>*:</code><code>+</code><code>,</code><code>-</code><code>--&gt;</code><code>-&gt;</code><code>.</code><code>..</code><code>/</code><code>//</code><code>/&gt;</code><code>:</code><code>:*</code><code>::</code><code>:=</code><code>;</code><code>&lt;</code><code>&lt;!--</code><code>&lt;![CDATA[</code><code>&lt;/</code><code>&lt;&lt;</code><code>&lt;=</code><code>&lt;?</code><code>=</code><code>=!&gt;</code><code>=&gt;</code><code>=?&gt;</code><code>&gt;</code><code>&gt;=</code><code>&gt;&gt;</code><code>?</code><code>?&gt;</code><code>?[</code><code>@</code><code>[</code><code>]</code><code>]]&gt;</code><code>]``</code><code>`</code><code>``</code><code>``[</code><code>`{</code><code>{</code><code>{{</code><code>|</code><code>||</code><code>}</code><code>}`</code><code>}}</code><code>×</code><code>÷</code><a href="#prod-xquery40-AposStringLiteral">AposStringLiteral</a><a href="#prod-xquery40-BracedURILiteral">BracedURILiteral</a><a href="#prod-xquery40-QuotStringLiteral">QuotStringLiteral</a><a href="#prod-xquery40-S">S</a><a href="#prod-xquery40-StringLiteral">StringLiteral</a><a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></p></dd><dt><a href="#dt-depends-on">depends on</a></dt><dd><p>A variable value (or the context value) <b>depends on</b> another variable value (or the context value) if, during the evaluation of the initializing expression of the former, the latter is accessed through the module context.</p></dd><dt><a href="#dt-derives-from">derives from</a></dt><dd><p>A <a title="schema type" class="termref" href="#dt-schema-type">schema type</a><var>S<sub>1</sub></var> is said to <b>derive from</b><a title="schema type" class="termref" href="#dt-schema-type">schema type</a><var>S<sub>2</sub></var> if any of the following conditions is true:</p><ul><li><p><var>S<sub>1</sub></var> is the same type as <var>S<sub>2</sub></var>.</p></li><li><p><var>S<sub>2</sub></var> is the base type of <var>S<sub>1</sub></var>.</p></li><li><p><var>S<sub>2</sub></var> is a <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a> of which <var>S<sub>1</sub></var> is a member type.</p></li><li><p>There is a <a title="schema type" class="termref" href="#dt-schema-type">schema type</a><var>M</var> such that <var>S<sub>1</sub></var><a title="derives from" class="termref" href="#dt-derives-from">derives from</a><var>M</var> and <var>M</var><a title="derives from" class="termref" href="#dt-derives-from">derives from</a><var>S<sub>2</sub></var>.</p></li></ul></dd><dt><a href="#id-static-decimal-format-digit">digit</a></dt><dd><p><b>digit</b><em>(<var>M</var>)</em> is a character used in the picture string to represent an optional digit; the default value is <span class="unicode-codepoint">U+0023</span> (<span class="unicode-name">NUMBER SIGN</span>, <code>#</code>) .</p></dd><dt><a href="#dt-direct-elem-const">direct element constructor</a></dt><dd><p>A <b>direct element constructor</b> is a form of element constructor in which the name of the constructed element is a constant.</p></dd><dt><a href="#dt-document-order">document order</a></dt><dd><p>Informally, <b>document order</b> is the order in which nodes appear in the XML serialization of a document.</p></dd><dt><a href="#dt-dynamically-known-function-definitions">dynamically known function definitions</a></dt><dd><p><b>Dynamically known function definitions</b>. This is a set of <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a>. It includes the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a> as a subset, but may include other function definitions that are not known statically. </p></dd><dt><a href="#dt-dynamic-context">dynamic context</a></dt><dd><p>The <b>dynamic context</b> of an expression is defined as information that is needed for the dynamic evaluation of an expression, beyond any information that is needed from the <a title="static context" class="termref" href="#dt-static-context">static context</a>.</p></dd><dt><a href="#dt-dynamic-error">dynamic error</a></dt><dd><p>A <b>dynamic error</b> is an error that must be detected during the dynamic evaluation phase and may be detected during the static analysis phase.</p></dd><dt><a href="#dt-dynamic-evaluation">dynamic evaluation phase</a></dt><dd><p>The <b>dynamic evaluation phase</b> is the phase during which the value of an expression is computed.</p></dd><dt><a href="#dt-dynamic-function-call">dynamic function call</a></dt><dd><p>A <b>dynamic function call</b> is an instance of the construct <a href="#doc-xquery40-DynamicFunctionCall">DynamicFunctionCall</a>: that is, it is an expression in the form <code><var>E<sub>1</sub></var>(<var>E<sub>2</sub></var>, <var>E<sub>3</sub></var>, ...)</code> in which <var>E<sub>1</sub></var> identifies a <a title="function item" class="termref" href="#dt-function-item">function item</a> to be called, and the parenthesized argument list <code>(<var>E<sub>2</sub></var>, <var>E<sub>3</sub></var>, ...)</code>) identifies the arguments supplied to the function.</p></dd><dt><a href="#dt-dynamic-type">dynamic type</a></dt><dd><p> Every value matches one or more <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a>. A value is said to have a <b>dynamic type</b><var>T</var> if it matches (or <b>is an instance of</b>) the sequence type <var>T</var>.</p></dd><dt><a href="#dt-ebv">effective boolean value</a></dt><dd><p>The <b>effective boolean value</b> of a value is defined as the result of applying the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> function to the value.</p></dd><dt><a href="#id-effective-case-switch-expression">effective case</a></dt><dd><p> The <b>effective case</b> of a switch expression is the first case clause that matches, using the rules given above, or the default clause if no such case clause exists.</p></dd><dt><a href="#dt-effective-case">effective case</a></dt><dd><p>The <b>effective case</b> in a <code>typeswitch</code> expression is the first <code>case</code> clause in which the value of the operand expression matches a <a href="#doc-xquery40-SequenceType">SequenceType</a> in the <a href="#doc-xquery40-SequenceType">SequenceTypeUnion</a> of the <code>case</code> clause, using the rules of <a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching">SequenceType matching</a>. </p></dd><dt><a href="#dt-element-name-matching-rule">element name matching rule</a></dt><dd><p>When an unprefixed lexical QName is expanded using the <b>element name matching rule</b> rule, then it uses the <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a>. If this is absent, then it uses the <a title="no-namespace rule" class="termref" href="#dt-no-namespace-rule">no-namespace rule</a>. But if it takes the special value <code>##any</code>, then the name is taken as matching any <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> with the corresponding local part, regardless of namespace: that is, the unprefixed name <code>local</code> is interpreted as <code>*:local</code>.</p></dd><dt><a href="#dt-empty-order-decl">empty order declaration</a></dt><dd><p>An <b>empty order declaration</b> sets the <a title="default order for empty sequences" class="termref" href="#dt-default-empty-order">default order for empty sequences</a> in the <a title="static context" class="termref" href="#dt-static-context">static context,</a> overriding any implementation-defined default. This declaration controls the processing of empty sequences and <code>NaN</code> values as ordering keys in an <code>order by</code> clause in a FLWOR expression.</p></dd><dt><a href="#dt-empty-sequence">empty sequence</a></dt><dd><p><span style="display: none;" class="delete_version">A sequence containing zero items is called an <b>empty sequence</b>.</span><span style="display: none;" class="add_version">The sequence containing zero items is called the <b>empty sequence</b>.</span><span class="modify_version"><span class="deltaxml-old" style="background:#FF5555">A</span><span class="deltaxml-new" style="background:#90EE90">The</span> sequence containing zero items is called <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> <b>empty sequence</b>.</span></p></dd><dt><a href="#dt-enclosed-expression">enclosed expression</a></dt><dd><p>An <b>enclosed expression</b> is an instance of the <a href="#doc-xquery40-EnclosedExpr">EnclosedExpr</a> production, which allows an optional expression within curly brackets.</p></dd><dt><a href="#dt-encoding-declaration">encoding declaration</a></dt><dd><p>If present, a version declaration may optionally include an <b>encoding declaration</b>. The value of the string literal following the keyword <code>encoding</code> is an encoding name, and must conform to the definition of <code>EncName</code> specified in <a href="#XML">[XML 1.0]</a> [<a href="#ERRXQST0087" title="err:XQST0087">err:XQST0087</a>]. The purpose of an encoding declaration is to allow the writer of a query to provide a string that indicates how the query is encoded, such as <code>"UTF-8"</code>, <code>"UTF-16"</code>, or <code>"US-ASCII"</code>.</p></dd><dt><a href="#dt-entry">entry</a></dt><dd><p>Each key / value pair in a map is called an <b>entry</b>.</p></dd><dt><a href="#dt-enumeration-type">enumeration type</a></dt><dd><p>An <b>EnumerationType</b> accepts a fixed set of string values.</p></dd><dt><a href="#dt-environment-variables">environment variables</a></dt><dd><p><b>Environment variables.</b> This is a mapping from names to values. Both the names and the values are strings. The names are compared using an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> collation, and are unique under this collation. The set of environment variables is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> and <span class="verb">may</span> be empty.</p></dd><dt><a href="#dt-equivalent-grouping-keys">equivalent grouping keys</a></dt><dd><p>Two tuples <var>T<sub>1</sub></var> and <var>T<sub>2</sub></var> have <b>equivalent grouping keys</b> if and only if, for each grouping variable <var>GV</var>, the atomized value of <var>GV</var> in <var>T<sub>1</sub></var> is deep-equal to the atomized value of <var>GV</var> in <var>T<sub>2</sub></var>, as defined by applying the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-deep-equal"><code>fn:deep-equal</code></a> using the appropriate collation.</p></dd><dt><a href="#dt-error-value">error value</a></dt><dd><p>In addition to its identifying QName, a dynamic error may also carry a descriptive string and one or more additional values called <b>error values</b>.</p></dd><dt><a href="#dt-executable-base-uri">Executable Base URI</a></dt><dd><p><b>Executable Base URI.</b> This is an absolute URI used to resolve relative URIs during the evaluation of expressions; it is used, for example, to resolve a relative URI supplied to the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>fn:doc</code></a> or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-unparsed-text"><code>fn:unparsed-text</code></a> functions. </p></dd><dt><a href="#dt-expanded-qname">expanded QName</a></dt><dd><p>An <b>expanded QName</b> is a triple: its components are a prefix, a local name, and a namespace URI. In the case of a name in no namespace, the namespace URI and prefix are both absent. In the case of a name in the default namespace, the prefix is absent.</p></dd><dt><a href="#id-static-decimal-format-exponent-separator">exponent-separator</a></dt><dd><p><b>exponent-separator</b><em>(<var>M</var>, <var>R</var>)</em> is used to separate the mantissa from the exponent in scientific notation. The default value for both the marker and the rendition is <span class="unicode-codepoint">U+0065</span> (<span class="unicode-name">LATIN SMALL LETTER E</span>, <code>e</code>) .</p></dd><dt><a href="#dt-expression-context">expression context</a></dt><dd><p>The <b>expression context</b> for a given expression consists of all the information that can affect the result of the expression.</p></dd><dt><a href="#dt-extension-expression">extension expression</a></dt><dd><p>An <b>extension expression</b> is an expression whose semantics are <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p></dd><dt><a href="#dt-external-function">external function</a></dt><dd><p><b>External functions</b> can be characterized as functions that are neither part of the processor implementation, nor written in a language whose semantics are under the control of this family of specifications. The semantics of external functions, including any context dependencies, are entirely implementation-defined. In XSLT, external functions are called <a href="https://www.w3.org/TR/xslt-30/#extension-functions"> 24.1 Extension Functions </a><sup><small>XT30</small></sup>. </p></dd><dt><a href="#dt-filter-expression">filter expression</a></dt><dd><p> A <b>filter expression</b> is an instance of the construct <a href="#doc-xquery40-FilterExpr">FilterExpr</a>: that is, it is an expression in the form <code><var>E<sub>1</sub></var>[<var>E<sub>2</sub></var>]</code>. Its effect is to return those items from the value of <var>E<sub>1</sub></var> that satisfy the predicate in <var>E<sub>2</sub></var>.</p></dd><dt><a href="#dt-filter-expression-ma">filter expression for maps and arrays</a></dt><dd><p> A <b>filter expression for maps and arrays</b> is an instance of the construct <a href="#doc-xquery40-FilterExprAM">FilterExprAM</a>: that is, it is an expression in the form <code><var>E<sub>1</sub></var>?[<var>E<sub>2</sub></var>]</code>. Its effect is to evaluate <var>E<sub>1</sub></var> to return an array or map, and to select members of the array, or entries from the map, that satisfy the predicate in <var>E<sub>2</sub></var>.</p></dd><dt><a href="#dt-fixed-focus">fixed focus</a></dt><dd><p>A <b>fixed focus</b> is a focus for an expression that is evaluated once, rather than being applied to a series of values; in a fixed focus, the context value is set to one specific value, the context position is 1, and the context size is 1.</p></dd><dt><a href="#dt-focus">focus</a></dt><dd><p>The first three components of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> (context value, context position, and context size) are called the <b>focus</b> of the expression. </p></dd><dt><a href="#dt-focus-function">focus function</a></dt><dd><p>A <b>focus function</b> is an inline function expression in which the function signature is implicit: the function takes a single argument of type <code>item()*</code> (that is, any value), and binds this to the context value when evaluating the function body, which returns a result of type <code>item()*</code>.</p></dd><dt><a href="#dt-function-assertion">function assertion</a></dt><dd><p> A <b>function assertion</b> is a predicate that restricts the set of functions matched by a FunctionType. It uses the same syntax as <a href="#id-annotations"><b>5.15 Annotations</b></a>.</p></dd><dt><a href="#dt-function-coercion">function coercion</a></dt><dd><p><b>Function coercion</b> wraps a <a title="function item" class="termref" href="#dt-function-item">function item</a> in a new function whose signature is the same as the expected type. This effectively delays the checking of the argument and return types until the function is called.</p></dd><dt><a href="#dt-function-definition">function definition</a></dt><dd><p>A <b>function definition</b> contains information used to evaluate a static function call, including the name, parameters, and return type of the function.</p></dd><dt><a href="#dt-function-item">function item</a></dt><dd><p>A <b>function item</b> is an item that can be called using a <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a>.</p></dd><dt><a href="#dt-generalized-atomic-type">generalized atomic type</a></dt><dd><p>A <b>generalized atomic type</b> is an <a title="item type" class="termref" href="#dt-item-type">item type</a> whose instances are all atomic items. Generalized atomic types include (a) <a title="atomic type" class="termref" href="#dt-atomic-type">atomic types</a>, either built-in (for example <code>xs:integer</code>) or imported from a schema, (b) <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union types</a>, either built-in (<code>xs:numeric</code> and <code>xs:error</code>) or imported from a schema, (c) <a title="choice item type" class="termref" href="#dt-choice-item-type">choice item types</a> if their alternatives are all generalized atomic types, and (d) <a title="enumeration type" class="termref" href="#dt-enumeration-type">enumeration types</a>. </p></dd><dt><a href="#dt-GNode">GNode</a></dt><dd><p><span class="deltaxml-old" style="background:#FF5555">The term </span><b><span class="deltaxml-old" style="background:#FF5555">generic node</span></b><span class="deltaxml-old" style="background:#FF5555"> or </span><b><span class="deltaxml-old" style="background:#FF5555">GNode</span></b><span class="deltaxml-old" style="background:#FF5555"> is a collective term for </span><a title="XNode" class="termref" href="#dt-XNode"><span class="deltaxml-old" style="background:#FF5555">XNodes</span></a><span class="deltaxml-old" style="background:#FF5555"> (more commonly called simply </span><a title="node" class="termref" href="#dt-node"><span class="deltaxml-old" style="background:#FF5555">nodes</span></a><span class="deltaxml-old" style="background:#FF5555">) representing the parts of an XML document, and </span><a title="JNode" class="termref" href="#dt-JNode"><span class="deltaxml-old" style="background:#FF5555">JNodes</span></a><span class="deltaxml-old" style="background:#FF5555">, often used to represent the parts of a JSON document.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">GNode</span></b><span class="deltaxml-new" style="background:#90EE90"> (for </span><em><span class="deltaxml-new" style="background:#90EE90">generalized node</span></em><span class="deltaxml-new" style="background:#90EE90">) is either an </span><a title="XNode" class="termref" href="#dt-XNode"><span class="deltaxml-new" style="background:#90EE90">XNode</span></a><span class="deltaxml-new" style="background:#90EE90"> or a </span><a title="JNode" class="termref" href="#dt-JNode"><span class="deltaxml-new" style="background:#90EE90">JNode</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#dt-grouping-key">grouping key</a></dt><dd><p>The atomized value of a <a title="grouping variable" class="termref" href="#dt-grouping-variable">grouping variable</a> is called a <b>grouping key</b>.</p></dd><dt><a href="#id-static-decimal-format-grouping-separator">grouping-separator</a></dt><dd><p><b>grouping-separator</b><em>(<var>M</var>, <var>R</var>)</em> is used to separate groups of digits (for example as a thousands separator). The default value for both the marker and the rendition is <span class="unicode-codepoint">U+002C</span> (<span class="unicode-name">COMMA</span>, <code>,</code>) .</p></dd><dt><a href="#dt-grouping-variable">grouping variable</a></dt><dd><p>Each grouping specification specifies one <b>grouping variable</b>, which refers to variable bindings in the pre-grouping tuples. The values of the grouping variables are used to assign pre-grouping tuples to groups.</p></dd><dt><a href="#dt-GTree">GTree</a></dt><dd><p>The term <b>GTree</b> means <a title="JTree" class="termref" href="#dt-JTree">JTree</a> or <a title="XTree" class="termref" href="#dt-XTree">XTree</a>.</p></dd><dt><a href="#dt-guarded">guarded</a></dt><dd><p>An expression <var>E</var> is said to be <b>guarded</b> by some governing condition <var>C</var> if evaluation of <var>E</var> is not allowed to fail with a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> except when <var>C</var> applies.</p></dd><dt><a href="#IgnorableWhitespace">ignorable whitespace</a></dt><dd><p><b>Ignorable whitespace</b> consists of any <a title="whitespace" class="termref" href="#Whitespace">whitespace</a> characters that may occur between <a title="terminal" class="termref" href="#terminal">terminals</a>, unless these characters occur in the context of a production marked with a <a href="#ExplicitWhitespaceHandling"> ws:explicit</a> annotation, in which case they can occur only where explicitly specified (see <a href="#ExplicitWhitespaceHandling"><b>A.3.4.2 Explicit Whitespace Handling</b></a>).</p></dd><dt><a href="#dt-implausible">implausible</a></dt><dd><p>Certain expressions, while not erroneous, are classified as being <b>implausible</b>, because they achieve no useful effect.</p></dd><dt><a href="#dt-implementation-defined">implementation defined</a></dt><dd><p><b>Implementation-defined</b> indicates an aspect that may differ between implementations, but must be specified by the implementer for each particular implementation.</p></dd><dt><a href="#dt-implementation-dependent">implementation dependent</a></dt><dd><p><b>Implementation-dependent</b> indicates an aspect that may differ between implementations, is not specified by this or any W3C specification, and is not required to be specified by the implementer for any particular implementation.</p></dd><dt><a href="#dt-timezone">implicit timezone</a></dt><dd><p><b>Implicit timezone.</b> This is the timezone to be used when a date, time, or dateTime value that does not have a timezone is used in a comparison or arithmetic operation. The implicit timezone is an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> value of type <code>xs:dayTimeDuration</code>. See <a href="https://www.w3.org/TR/xmlschema-2/#dateTime-timezones"> 3.2.7.3 Timezones </a><sup><small>XS1-2</small></sup> or <a href="https://www.w3.org/TR/xmlschema11-2/#dateTime"> 3.3.7 dateTime </a><sup><small>XS11-2</small></sup> for the range of valid values of a timezone.</p></dd><dt><a href="#id-static-decimal-format-infinity">infinity</a></dt><dd><p><b>infinity</b><em>(<var>R</var>)</em> is the string used to represent the double value infinity (<code>INF</code>); the default value is the string <code>"Infinity"</code></p></dd><dt><a href="#dt-initial-context-value">initial context value</a></dt><dd><p> In the dynamic context of every module in a query, the context value component must have the same setting. If this shared setting is not <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM</small></sup>, it is referred to as the <b>initial context value</b>. </p></dd><dt><a href="#dt-initializing-expression">initializing expression</a></dt><dd><p>If a variable declaration includes an expression (<code>VarValue</code> or <code>VarDefaultValue</code>), the expression is called an <b>initializing expression.</b> The static context for an initializing expression includes all functions, variables, and namespaces that are declared or imported anywhere in the Prolog.</p></dd><dt><a href="#dt-inline-func">inline function expression</a></dt><dd><p>An <b>inline function expression</b> is an instance of the construct <a href="#doc-xquery40-InlineFunctionExpr">InlineFunctionExpr</a>. When evaluated, an inline function expression creates an <a title="anonymous function" class="termref" href="#dt-anonymous-function">anonymous function</a> whose properties are defined directly in the inline function expression.</p></dd><dt><a href="#dt-is-attrs">in-scope attribute declarations</a></dt><dd><p><b>In-scope attribute declarations.</b> Each attribute declaration is identified either by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (for a top-level attribute declaration) or by an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> attribute identifier (for a local attribute declaration). <span class="xquery">If the <a title="schema aware feature" class="termref" href="#dt-schema-aware-feature">Schema Aware Feature</a> is supported, in-scope attribute declarations include all attribute declarations found in imported schemas.</span></p></dd><dt><a href="#dt-is-elems">in-scope element declarations</a></dt><dd><p><b>In-scope element declarations.</b> Each element declaration is identified either by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (for a top-level element declaration) or by an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> element identifier (for a local element declaration). <span class="xquery"> If the <a title="schema aware feature" class="termref" href="#dt-schema-aware-feature">Schema Aware Feature</a> is supported, in-scope element declarations include all element declarations found in imported schemas. </span></p></dd><dt><a href="#dt-in-scope-named-item-types">in-scope named item types</a></dt><dd><p><b>In-scope named item types.</b> This is a mapping from <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> to <a title="named item type" class="termref" href="#dt-named-item-type">named item types</a>.</p></dd><dt><a href="#dt-in-scope-namespaces">in-scope namespaces</a></dt><dd><p>The <b>in-scope namespaces</b> property of an element node is a set of <a title="namespace binding" class="termref" href="#dt-namespace-binding">namespace bindings</a>, each of which associates a namespace prefix with a URI.</p></dd><dt><a href="#dt-issd">in-scope schema definitions</a></dt><dd><p><b>In-scope schema definitions</b> is a generic term for all the element declarations, attribute declarations, and schema type definitions that are in scope during static analysis of an expression.</p></dd><dt><a href="#dt-is-types">in-scope schema type</a></dt><dd><p><b>In-scope schema types.</b> Each schema type definition is identified either by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (for a <b>named type</b>) or by an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> type identifier (for an <b>anonymous type</b>). The in-scope schema types include the predefined schema types described in <a href="#id-predefined-types"><b>3.5 Schema Types</b></a>. <span class="xquery">If the <a title="schema aware feature" class="termref" href="#dt-schema-aware-feature">Schema Aware Feature</a> is supported, in-scope schema types also include all type definitions found in imported schemas.</span></p></dd><dt><a href="#dt-in-scope-variables">in-scope variables</a></dt><dd><p><b>In-scope variables.</b> This is a mapping from <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> to sequence types. It defines the set of variables that are available for reference within an expression. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is the name of the variable, and the type is the <a title="static type" class="termref" href="#dt-static-type">static type</a> of the variable.</p></dd><dt><a href="#dt-item">item</a></dt><dd><p> An <b>item</b> is either an <a title="atomic item" class="termref" href="#dt-atomic-item">atomic item</a>, a <a title="node" class="termref" href="#dt-node">node</a>, or a <a title="function item" class="termref" href="#dt-function-item">function item</a>.</p></dd><dt><a href="#dt-item-type">item type</a></dt><dd><p>An <b>item type</b> is a type that can be expressed using the <a href="#doc-xquery40-ItemType">ItemType</a> syntax, which forms part of the <a href="#doc-xquery40-SequenceType">SequenceType</a> syntax. Item types match individual <a title="item" class="termref" href="#dt-item">items</a>.</p></dd><dt><a href="#dt-item-type-designator">item type designator</a></dt><dd><p>An <b>item type designator</b> is a syntactic construct conforming to the grammar rule <a href="#doc-xquery40-ItemType">ItemType</a>. An item type designator is said to <b>designate</b> an <a title="item type" class="termref" href="#dt-item-type">item type</a>.</p></dd><dt><a href="#dt-JNode">JNode</a></dt><dd><p><span class="deltaxml-old" style="background:#FF5555">A </span><b><span class="deltaxml-old" style="background:#FF5555">JNode</span></b><span class="deltaxml-old" style="background:#FF5555"> is a kind of </span><a href="#dt-item" title="item" class="termref"><span class="deltaxml-old" style="background:#FF5555">item</span></a><span class="deltaxml-old" style="background:#FF5555"> used to represent a value within the context of a tree of </span><a title="map" class="termref" href="#dt-map"><span class="deltaxml-old" style="background:#FF5555">maps</span></a><span class="deltaxml-old" style="background:#FF5555"> and </span><a title="array" class="termref" href="#dt-array"><span class="deltaxml-old" style="background:#FF5555">arrays</span></a><span class="deltaxml-old" style="background:#FF5555">. A root </span><b><span class="deltaxml-old" style="background:#FF5555">JNode</span></b><span class="deltaxml-old" style="background:#FF5555"> represents a map or array; a non-root </span><b><span class="deltaxml-old" style="background:#FF5555">JNode</span></b><span class="deltaxml-old" style="background:#FF5555"> represents a </span><a title="member" class="termref" href="#dt-member"><span class="deltaxml-old" style="background:#FF5555">member</span></a><span class="deltaxml-old" style="background:#FF5555"> of an array or an </span><a title="entry" class="termref" href="#dt-entry"><span class="deltaxml-old" style="background:#FF5555">entry</span></a><span class="deltaxml-old" style="background:#FF5555"> in a map.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">JNode</span></b><span class="deltaxml-new" style="background:#90EE90"> (see also </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XDM 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> section </span><a href="../xpath-datamodel-40/#id-JNodes"><span class="deltaxml-new" style="background:#90EE90">8.4 JNodes</span></a><span class="deltaxml-new" style="background:#90EE90">) is an encapsulation of a value as it appears within a tree of maps and arrays, typically (but not necessarily) obtained by parsing JSON texts.</span></p></dd><dt><a href="#dt-JTree">JTree</a></dt><dd><p>A tree that is rooted at a parentless <a title="JNode" class="termref" href="#dt-JNode">JNode</a> is referred to as a <b>JTree</b>.</p></dd><dt><a href="#dt-qname">lexical QName</a></dt><dd><p>A <b>lexical QName</b> is a name that conforms to the syntax of the <a href="#prod-xquery40-QName">QName</a> production</p></dd><dt><a href="#dt-library-module">library module</a></dt><dd><p>A module that does not contain a <a title="query body" class="termref" href="#dt-queryBody">Query Body</a> is called a <b>library module</b>. A library module consists of a <a title="module declaration" class="termref" href="#dt-module-declaration">module declaration</a> followed by a <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a>.</p></dd><dt><a href="#dt-literal">literal</a></dt><dd><p>A <b>literal</b> is a direct syntactic representation of an atomic item.</p></dd><dt><a href="#dt-literal-terminal">literal terminal</a></dt><dd><p>A <b>literal terminal</b> is a token appearing as a string in quotation marks on the right-hand side of an <a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule">ordinary production rule</a>.</p></dd><dt><a href="#dt-logical-expression">logical expression</a></dt><dd><p> A <b>logical expression</b> is either an <a title="and expression" class="termref" href="#dt-and-expression">and expression</a> or an <a title="or expression" class="termref" href="#dt-or-expression">or expression</a>. If a logical expression does not raise an error, its value is always one of the boolean values <code>true</code> or <code>false</code>.</p></dd><dt><a href="#dt-lookup-expression">lookup expression</a></dt><dd><p> A <b>lookup expression</b> is an instance of the production <a href="#doc-xquery40-LookupExpr">LookupExpr</a>: that is, an expression in the form <code><var>E<sub>1</sub></var>?<var>KS</var></code>, where <var>E<sub>1</sub></var> is an expression returning a sequence of maps or arrays, and <var>KS</var> is a key specifier, which indicates which entries in a map, or members in an array, should be selected.</p></dd><dt><a href="#dt-main-module">main module</a></dt><dd><p>A <b>main module</b> consists of a <a title="Prolog" class="termref" href="#dt-prolog">Prolog</a> followed by a <a title="query body" class="termref" href="#dt-queryBody">Query Body</a>.</p></dd><dt><a href="#dt-map">map</a></dt><dd><p>A <b>map</b> is a function that associates a set of keys with values, resulting in a collection of key / value pairs.</p></dd><dt><a href="#dt-mapping-arrow-operator">mapping arrow operator</a></dt><dd><p> The <b>mapping arrow operator</b><code>=!&gt;</code> applies a function to each item in a sequence.</p></dd><dt><a href="#may">may</a></dt><dd><p><b>MAY</b> means that an item is truly optional.</p></dd><dt><a href="#dt-member">member</a></dt><dd><p>The values of an array are called its <b>members</b>.</p></dd><dt><a href="#id-static-decimal-format-minus-sign">minus-sign</a></dt><dd><p><b>minus-sign</b><em>(<var>R</var>)</em> is the string used to mark negative numbers; the default value is <span class="unicode-codepoint">U+002D</span> (<span class="unicode-name">HYPHEN-MINUS</span>, <code>-</code>) .</p></dd><dt><a href="#dt-module">module</a></dt><dd><p>A <b>module</b> is a fragment of XQuery code that conforms to the <a href="#doc-xquery40-Module">Module</a> grammar and can independently undergo the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a> described in <a href="#id-expression-processing"><b>2.4.3 Expression Processing</b></a>. Each module is either a <a title="main module" class="termref" href="#dt-main-module">main module</a> or a <a title="library module" class="termref" href="#dt-library-module">library module</a>.</p></dd><dt><a href="#dt-module-declaration">module declaration</a></dt><dd><p>A <b>module declaration</b> serves to identify a <a title="module" class="termref" href="#dt-module">module</a> as a <a title="library module" class="termref" href="#dt-library-module">library module</a>. A module declaration begins with the keyword <code>module</code> and contains a namespace prefix and a <a href="#prod-xquery40-URILiteral">URILiteral</a>.</p></dd><dt><a href="#dt-module-import">module import</a></dt><dd><p>A <b>module import</b> imports the public variable declarations, public function declarations<span>, and public item type declarations</span> from one or more <a title="library module" class="termref" href="#dt-library-module">library modules</a> into the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a>, <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a><span>, or <a title="in-scope named item types" class="termref" href="#dt-in-scope-named-item-types">in-scope named item types</a></span> of the importing <a title="module" class="termref" href="#dt-module">module</a>.</p></dd><dt><a href="#must">must</a></dt><dd><p><b>MUST</b> means that the item is an absolute requirement of the specification.</p></dd><dt><a href="#mustnot">must not</a></dt><dd><p><b>MUST NOT</b> means that the item is an absolute prohibition of the specification.</p></dd><dt><a href="#dt-named-function-ref">named function reference</a></dt><dd><p> A <b>named function reference</b> is an instance of the production <a href="#doc-xquery40-NamedFunctionRef">NamedFunctionRef</a>: it is an expression (written <code>name#arity</code>) which evaluates to a <a title="function item" class="termref" href="#dt-function-item">function item</a>, the details of the function item being based on the properties of a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>.</p></dd><dt><a href="#dt-named-item-type">named item type</a></dt><dd><p>A <b>named item type</b> is an <code>ItemType</code> identified by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p></dd><dt><a href="#dt-name-expression">name expression</a></dt><dd><p>When an expression is used to specify the name of a constructed node, that expression is called the <b>name expression</b> of the constructor.</p></dd><dt><a href="#dt-namespace-binding">namespace binding</a></dt><dd><p>A <b>namespace binding</b> is a pair comprising a namespace prefix (which is either an <code>xs:NCName</code> or empty), and a namespace URI.</p></dd><dt><a href="#dt-namespace-declaration">namespace declaration</a></dt><dd><p>A <b>namespace declaration</b> declares a namespace prefix and associates it with a namespace URI, adding the (prefix, URI) pair to the set of <a title="statically known namespaces" class="termref" href="#dt-static-namespaces">statically known namespaces</a>.</p></dd><dt><a href="#dt-namespace-decl-attr">namespace declaration attribute</a></dt><dd><p>A <b>namespace declaration attribute</b> is used inside a direct element constructor. Its purpose is to bind a namespace prefix <span>(including the zero-length prefix)</span> for the constructed element node, including its attributes.</p></dd><dt><a href="#dt-namespace-sensitive">namespace-sensitive</a></dt><dd><p>The <b>namespace-sensitive</b> types are <code>xs:QName</code>, <code>xs:NOTATION</code>, types derived by restriction from <code>xs:QName</code> or <code>xs:NOTATION</code>, list types that have a namespace-sensitive item type, and union types with a namespace-sensitive type in their transitive membership.</p></dd><dt><a href="#dt-name-test">name test</a></dt><dd><p>A node test that consists only of an EQName or a Wildcard is called a <b>name test</b>.</p></dd><dt><a href="#id-static-decimal-format-NaN">NaN</a></dt><dd><p><b>NaN</b><em>(<var>R</var>)</em> is the string used to represent the double value <code>NaN</code> (not a number); the default value is the string <code>"NaN"</code></p></dd><dt><a href="#dt-node">node</a></dt><dd><p>Except where the context indicates otherwise, the term <b>node</b> is used as a synonym for <a title="XNode" class="termref" href="#dt-XNode">XNode</a>.</p></dd><dt><a href="#dt-node-test">node test</a></dt><dd><p>A <b>node test</b> is a condition on the properties of a <a title="GNode" class="termref" href="#dt-GNode">GNode</a>. A node test determines which GNodes returned by an axis are selected by a <a title="step" class="termref" href="#dt-step">step</a>.</p></dd><dt><a href="#dt-no-namespace-rule">no-namespace rule</a></dt><dd><p>When an unprefixed lexical QName is expanded using the <b>no-namespace rule</b>, it is interpreted as having an absent namespace URI.</p></dd><dt><a href="#non-delimiting-token">non-delimiting terminal symbol</a></dt><dd><p>The <b>non-delimiting terminal symbols</b> are: <code>allowing</code><code>ancestor</code><code>ancestor-or-self</code><code>and</code><code>array</code><code>as</code><code>ascending</code><code>at</code><code>attribute</code><code>base-uri</code><code>boundary-space</code><code>by</code><code>case</code><code>cast</code><code>castable</code><code>catch</code><code>child</code><code>collation</code><code>comment</code><code>construction</code><code>context</code><code>copy-namespaces</code><code>count</code><code>decimal-format</code><code>decimal-separator</code><code>declare</code><code>default</code><code>descendant</code><code>descendant-or-self</code><code>descending</code><code>digit</code><code>div</code><code>document</code><code>document-node</code><code>element</code><code>else</code><code>empty</code><code>empty-sequence</code><code>encoding</code><code>end</code><code>enum</code><code>eq</code><code>every</code><code>except</code><code>exponent-separator</code><code>external</code><code>false</code><code>finally</code><code>fixed</code><code>fn</code><code>following</code><code>following-or-self</code><code>following-sibling</code><code>following-sibling-or-self</code><code>follows</code><code>follows-or-is</code><code>for</code><code>function</code><code>ge</code><code>get</code><code>gnode</code><code>greatest</code><code>group</code><code>grouping-separator</code><code>gt</code><code>idiv</code><code>if</code><code>import</code><code>in</code><code>infinity</code><code>inherit</code><code>instance</code><code>intersect</code><code>is</code><code>is-not</code><code>item</code><code>jnode</code><code>key</code><code>lax</code><code>le</code><code>least</code><code>let</code><code>lt</code><code>map</code><code>member</code><code>minus-sign</code><code>mod</code><code>module</code><code>namespace</code><code>namespace-node</code><code>NaN</code><code>ne</code><code>next</code><code>no-inherit</code><code>no-preserve</code><code>node</code><code>of</code><code>only</code><code>option</code><code>or</code><code>order</code><code>ordered</code><code>ordering</code><code>otherwise</code><code>parent</code><code>pattern-separator</code><code>per-mille</code><code>percent</code><code>precedes</code><code>precedes-or-is</code><code>preceding</code><code>preceding-or-self</code><code>preceding-sibling</code><code>preceding-sibling-or-self</code><code>preserve</code><code>previous</code><code>processing-instruction</code><code>record</code><code>return</code><code>satisfies</code><code>schema</code><code>schema-attribute</code><code>schema-element</code><code>self</code><code>sliding</code><code>some</code><code>stable</code><code>start</code><code>strict</code><code>strip</code><code>switch</code><code>text</code><code>then</code><code>to</code><code>treat</code><code>true</code><code>try</code><code>tumbling</code><code>type</code><code>typeswitch</code><code>union</code><code>unordered</code><code>validate</code><code>value</code><code>variable</code><code>version</code><code>when</code><code>where</code><code>while</code><code>window</code><code>xquery</code><code>zero-digit</code><a href="#prod-xquery40-BinaryIntegerLiteral">BinaryIntegerLiteral</a><a href="#prod-xquery40-DecimalLiteral">DecimalLiteral</a><a href="#prod-xquery40-DoubleLiteral">DoubleLiteral</a><a href="#prod-xquery40-HexIntegerLiteral">HexIntegerLiteral</a><a href="#prod-xquery40-IntegerLiteral">IntegerLiteral</a><a href="#prod-xquery40-NCName">NCName</a><a href="#prod-xquery40-QName">QName</a></p></dd><dt><a href="#dt-non-trivial">non-trivial</a></dt><dd><p>A construct is said to be a <b>non-trivial</b> instance of a grammatical production if it is not also an instance of one of its sub-productions.</p></dd><dt><a href="#dt-numeric">numeric</a></dt><dd><p>The type <code>xs:numeric</code> is defined as a union type with member types <code>xs:double</code>, <code>xs:float</code>, and <code>xs:decimal</code>. An item that is an instance of any of these types is referred to as a <b>numeric value</b>, and a type that is a subtype of <code>xs:numeric</code> is referred to as a <b>numeric type</b>.</p></dd><dt><a href="#dt-numeric-predicate">numeric predicate</a></dt><dd><p>A predicate whose predicate expression returns a value of type <code>xs:numeric+</code> is called a <b>numeric predicate</b>.</p></dd><dt><a href="#dt-option-declaration">option declaration</a></dt><dd><p>An <b>option declaration</b> declares an option that affects the behavior of a particular implementation. Each option consists of an identifying EQName and a StringLiteral.</p></dd><dt><a href="#dt-ordinary-production-rule">ordinary production rule</a></dt><dd><p>An <b>ordinary production rule</b> is a production rule in <a href="#id-grammar"><b>A.1 EBNF</b></a> that is not annotated <code>ws:explicit</code>.</p></dd><dt><a href="#dt-or-expression">or expression</a></dt><dd><p>An <b>or expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production <a href="#doc-xquery40-OrExpr">OrExpr</a>.</p></dd><dt><a href="#dt-output-declaration">output declaration</a></dt><dd><p>An <b>output declaration</b> is an option declaration in the namespace <code>http://www.w3.org/2010/xslt-xquery-serialization</code>; it is used to declare serialization parameters.</p></dd><dt><a href="#dt-partial-function-application">partial function application</a></dt><dd><p> A <a title="static function call" class="termref" href="#dt-static-function-call">static</a> or <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic</a> function call is a <b>partial function application</b> if one or more arguments is an <a href="#prod-xquery40-ArgumentPlaceholder">ArgumentPlaceholder</a>.</p></dd><dt><a href="#dt-partially-applied-function">partially applied function</a></dt><dd><p>A <b>partially applied function</b> is a function created by <a title="partial function application" class="termref" href="#dt-partial-function-application">partial function application</a>.</p></dd><dt><a href="#dt-path-expression">path expression</a></dt><dd><p>A <b>path expression</b> is either an <a title="absolute path expression" class="termref" href="#dt-absolute-path-expression">absolute path expression</a> or a <a title="relative path expression" class="termref" href="#dt-relative-path-expression">relative path expression</a></p></dd><dt><a href="#id-static-decimal-format-pattern-separator">pattern-separator</a></dt><dd><p><b>pattern-separator</b><em>(<var>M</var>)</em> is a character used to separate positive and negative sub-pictures in a picture string; the default value is <span class="unicode-codepoint">U+003B</span> (<span class="unicode-name">SEMICOLON</span>, <code>;</code>) .</p></dd><dt><a href="#id-static-decimal-format-percent">percent</a></dt><dd><p><b>percent</b><em>(<var>M</var>, <var>R</var>)</em> is used to indicate that the number is written as a per-hundred fraction; the default value for both the marker and the rendition is <span class="unicode-codepoint">U+0025</span> (<span class="unicode-name">PERCENT SIGN</span>, <code>%</code>) .</p></dd><dt><a href="#id-static-decimal-format-per-mille">per-mille</a></dt><dd><p><b>per-mille</b><em>(<var>M</var>, <var>R</var>)</em> is used to indicate that the number is written as a per-thousand fraction; the default value for both the marker and the rendition is <span class="unicode-codepoint">U+2030</span> (<span class="unicode-name">PER MILLE SIGN</span>, <code>‰</code>) .</p></dd><dt><a href="#dt-pipeline-operator">pipeline operator</a></dt><dd><p> The <b>pipeline operator</b><code>-&gt;</code> evaluates an expression and binds the result to the context value before evaluating another expression.</p></dd><dt><a href="#dt-positional-variable">positional variable</a></dt><dd><p>A <b>positional variable</b> is a variable that is preceded by the keyword <code>at</code>.</p></dd><dt><a href="#dt-pragma">pragma</a></dt><dd><p>A <b>pragma</b> is denoted by the delimiters <code>(#</code> and <code>#)</code>, and consists of an identifying EQName followed by <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> content.</p></dd><dt><a href="#dt-predefined-entity-reference">predefined entity reference</a></dt><dd><p>A <b>predefined entity reference</b> is a short sequence of characters, beginning with an ampersand, that represents a single character that might otherwise have syntactic significance.</p></dd><dt><a href="#dt-predicate-truth-value">predicate truth value</a></dt><dd><p>The <b>predicate truth value</b> of a value <code>$V</code> is the result of the expression <code>if ($V instance of xs:numeric+) then ($V = position()) else fn:boolean($V)</code>.</p></dd><dt><a href="#dt-primary-expression">primary expression</a></dt><dd><p> A <b>primary expression</b> is an instance of the production <a href="#doc-xquery40-PrimaryExpr">PrimaryExpr</a>. Primary expressions are the basic primitives of the language. They include literals, variable references, context value references, <span class="xquery">constructors, </span> and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.</p></dd><dt><a href="#dt-principal-node-kind">principal node kind</a></dt><dd><p>Every axis has a <b>principal node kind</b>. If an axis can contain elements, then the principal node kind is element; otherwise, it is the kind of nodes that the axis can contain.</p></dd><dt><a href="#dt-private-function">private function</a></dt><dd><p>A <b>private function</b> is a function with a <code>%private</code> annotation. A private function is hidden from <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can not import it into the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a> of another module. </p></dd><dt><a href="#dt-private-item-type">private item type</a></dt><dd><p>A <b>private item type</b> is a named item type with a <code>%private</code> annotation. A private item type is hidden from <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can not import it into the <a title="in-scope named item types" class="termref" href="#dt-in-scope-named-item-types">in-scope named item types</a> of another module. </p></dd><dt><a href="#dt-private-variable">private variable</a></dt><dd><p>A <b>private variable</b> is a variable with a <code>%private</code> annotation. A private variable is hidden from <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can not import it into the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a> of another module.</p></dd><dt><a href="#dt-prolog">Prolog</a></dt><dd><p>A <b>Prolog</b> is a series of declarations and imports that define the processing environment for the <a title="module" class="termref" href="#dt-module">module</a> that contains the Prolog.</p></dd><dt><a href="#dt-public-function">public function</a></dt><dd><p>A <b>public function</b> is a function without a <code>%private</code> annotation. A public function is accessible to <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can import it into the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a> of another module. </p></dd><dt><a href="#dt-public-item-type">public item type</a></dt><dd><p>A <b>public item type</b> is an item type declaration without a <code>%private</code> annotation. A public item type is accessible to <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can import it into the <a title="in-scope named item types" class="termref" href="#dt-in-scope-named-item-types">in-scope named item types</a> of another module. </p></dd><dt><a href="#dt-public-variable">public variable</a></dt><dd><p>A <b>public variable</b> is a variable without a <code>%private</code> annotation. A public variable is accessible to <a title="module import" class="termref" href="#dt-module-import">module import</a>, which can import it into the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a> of another module. Using <code>%public</code> and <code>%private</code> annotations in a main module is not an error, but it does not affect module imports, since a main module cannot be imported. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXQST0116" title="err:XQST0116">err:XQST0116</a>] if a variable declaration contains both a <code>%private</code> and a <code>%public</code> annotation, more than one <code>%private</code> annotation, or more than one <code>%public</code> annotation.</p></dd><dt><a href="#dt-pure-union-type">pure union type</a></dt><dd><p>A <b>pure union type</b> is a <span><b>simple type</b></span> that satisfies the following constraints: (a) <a href="https://www.w3.org/TR/xmlschema11-1/#std-variety">{variety}<sup><small>XS11-1</small></sup></a> is <code>union</code>, (b) the <a href="https://www.w3.org/TR/xmlschema11-1/#std-facets">{facets}<sup><small>XS11-1</small></sup></a> property is empty, (c) no type in the transitive membership of the union type has <a href="https://www.w3.org/TR/xmlschema11-1/#std-variety">{variety}<sup><small>XS11-1</small></sup></a><code>list</code>, and (d) no type in the transitive membership of the union type is a type with <a href="https://www.w3.org/TR/xmlschema11-1/#std-variety">{variety}<sup><small>XS11-1</small></sup></a><code>union</code> having a non-empty <a href="https://www.w3.org/TR/xmlschema11-1/#std-facets">{facets}<sup><small>XS11-1</small></sup></a> property</p></dd><dt><a href="#dt-query">query</a></dt><dd><p>A <b>query</b> consists of one or more <a title="module" class="termref" href="#dt-module">modules</a>.</p></dd><dt><a href="#dt-queryBody">query body</a></dt><dd><p>The <b>Query Body</b>, if present, consists of an expression that defines the result of the query.</p></dd><dt><a href="#dt-range-expression">range expression</a></dt><dd><p>A <b>range expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production <a href="#doc-xquery40-RangeExpr">RangeExpr</a>. A range expression is used to construct a sequence of integers.</p></dd><dt><a href="#dt-relative-path-expression">relative path expression</a></dt><dd><p> A <b>relative path expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production <a href="#doc-xquery40-RelativePathExpr">RelativePathExpr</a>: it consists of two or more operand expressions separated by <code>/</code> or <code>//</code> operators.</p></dd><dt><a href="#dt-reserved-namespaces">reserved namespaces</a></dt><dd><p>A <b>reserved namespace</b> is a namespace that must not be used in the name of a function declaration.</p></dd><dt><a href="#dt-resolve-relative-uri">resolve</a></dt><dd><p>To <b>resolve a relative URI</b><code>$rel</code> against a base URI <code>$base</code> is to expand it to an absolute URI, as if by calling the function <code>fn:resolve-uri($rel, $base)</code>.</p></dd><dt><a href="#dt-reverse-document-order">reverse document order</a></dt><dd><p>The node ordering that is the reverse of document order is called <b>reverse document order</b>.</p></dd><dt><a href="#dt-same-key">same key</a></dt><dd><p>Two atomic items <var>K<sub>1</sub></var> and <var>K<sub>2</sub></var> have the <b>same key value</b> if <code>fn:atomic-equal(<var>K<sub>1</sub></var>, <var>K<sub>2</sub></var>)</code> returns <code>true</code>, as specified in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#func-atomic-equal">2.2.1 fn:atomic-equal</a></p></dd><dt><a href="#dt-schema-aware-feature">schema aware feature</a></dt><dd><p>The <b>Schema Aware Feature</b> permits the query Prolog to contain a <a title="schema import" class="termref" href="#dt-schema-import">schema import</a>, and permits a query to contain a <code>validate</code> expression (see <a href="#id-validate"><b>4.25 Validate Expressions</b></a>). </p></dd><dt><a href="#dt-schema-import">schema import</a></dt><dd><p>A <b>schema import</b> imports the element declarations, attribute declarations, and type definitions from a schema into the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a>. For each named user-defined simple type in the schema, schema import also adds a corresponding <a title="constructor function" class="termref" href="#dt-constructor-function">constructor function</a>. </p></dd><dt><a href="#dt-schema-type">schema type</a></dt><dd><p>A <b>schema type</b> is a complex type or simple type as defined in the <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> specifications, including built-in types as well as user-defined types.</p></dd><dt><a href="#dt-sequence">sequence</a></dt><dd><p>A <b>sequence</b> is an ordered collection of zero or more <a title="item" class="termref" href="#dt-item">items</a>.</p></dd><dt><a href="#dt-sequence-arrow-operator">sequence arrow operator</a></dt><dd><p> The <b>sequence arrow operator</b><code>=&gt;</code> applies a function to a supplied sequence.</p></dd><dt><a href="#dt-sequence-concatenation">sequence concatenation</a></dt><dd><p>The <b>sequence concatenation</b> of a number of sequences <var>S<sub>1</sub></var>, <var>S<sub>2</sub></var>, ... <var>S<sub>n</sub></var> is defined to be the sequence formed from the items of <var>S<sub>1</sub></var>, followed by the items from <var>S<sub>2</sub></var>, and so on, retaining order.</p></dd><dt><a href="#dt-sequence-expression">sequence expression</a></dt><dd><p>A <b>sequence expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production rule <a href="#doc-xquery40-Expr">Expr</a>, that is, an expression containing two or more instances of the production <a href="#doc-xquery40-ExprSingle">ExprSingle</a> separated by the comma operator.</p></dd><dt><a href="#dt-sequence-type">sequence type</a></dt><dd><p>A <b>sequence type</b> is a type that can be expressed using the <a href="#doc-xquery40-SequenceType">SequenceType</a> syntax. Sequence types are used whenever it is necessary to refer to a type in an XQuery 4.0 expression. Since all values are sequences, every value matches one or more <b>sequence types</b>.</p></dd><dt><a href="#dt-sequence-type-designator">sequence type designator</a></dt><dd><p>A <b>sequence type designator</b> is a syntactic construct conforming to the grammar rule <a href="#doc-xquery40-SequenceType">SequenceType</a>. A sequence type designator is said to <b>designate</b> a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>.</p></dd><dt><a href="#dt-sequencetype-matching">SequenceType matching</a></dt><dd><p><b>SequenceType matching</b> compares a value with an expected <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>. </p></dd><dt><a href="#dt-serialization">serialization</a></dt><dd><p><b>Serialization</b> is the process of converting an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> to a sequence of octets (step DM4 in Figure 1.), as described in <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a>.</p></dd><dt><a href="#dt-serialization-feature">serialization feature</a></dt><dd><p>The <b>Serialization Feature</b> provides means for serializing the result of a query as specified in <a href="#id-serialization"><b>2.4.5 Serialization</b></a>.</p></dd><dt><a href="#dt-setter">setter</a></dt><dd><p><b>Setters</b> are declarations that set the value of some property that affects query processing, such as construction mode or default collation.</p></dd><dt><a href="#should">should</a></dt><dd><p><b>SHOULD</b> means that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course.</p></dd><dt><a href="#dt-singleton">singleton</a></dt><dd><p>A sequence containing exactly one item is called a <b>singleton</b>.</p></dd><dt><a href="#dt-singleton-enumeration-type">singleton enumeration type</a></dt><dd><p>An enumeration type with a single enumerated value <var>E</var> (such as <code>enum("red")</code>) matches an item <var>S</var> if and only if (a) <var>S</var> is an instance of <code>xs:string</code>, and (b) <var>S</var> is equal to <var>E</var> when compared using Unicode codepoint collation. This is referred to as a <b>singleton enumeration type</b>.</p></dd><dt><a href="#dt-singleton-focus">singleton focus</a></dt><dd><p>A <b>singleton focus</b> is a <a title="fixed focus" class="termref" href="#dt-fixed-focus">fixed focus</a> in which the <a title="context value" class="termref" href="#dt-context-value">context value</a> is a <a title="singleton" class="termref" href="#dt-singleton">singleton</a> item.</p></dd><dt><a href="#stable">stable</a></dt><dd><p>Document order is <b>stable</b>, which means that the relative order of two nodes will not change during the processing of a given <span class="xquery">query</span> , even if this order is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p></dd><dt><a href="#dt-static-collations">statically known collations</a></dt><dd><p><b>Statically known collations.</b> This is an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> mapping from URI to collation. It defines the names of the collations that are available for use in processing <span class="xquery">queries and</span> expressions.</p></dd><dt><a href="#dt-static-decimal-formats">statically known decimal formats</a></dt><dd><p><b>Statically known decimal formats.</b> This is a mapping from QNames to decimal formats, with one default format that has no visible name, referred to as the unnamed decimal format. Each format is available for use when formatting numbers using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-number"><code>fn:format-number</code></a> function.</p></dd><dt><a href="#dt-statically-known-function-definitions">statically known function definitions</a></dt><dd><p><b>Statically known function definitions.</b> This is a set of <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a>.</p></dd><dt><a href="#dt-static-namespaces">statically known namespaces</a></dt><dd><p><b>Statically known namespaces.</b> This is a mapping from prefix to namespace URI that defines all the namespaces that are known during static processing of a given expression.</p></dd><dt><a href="#dt-static-analysis">static analysis phase</a></dt><dd><p>The <b>static analysis phase</b> depends on the expression itself and on the <a title="static context" class="termref" href="#dt-static-context">static context</a>. The <b>static analysis phase</b> does not depend on input data (other than schemas).</p></dd><dt><a href="#dt-static-base-uri">Static Base URI</a></dt><dd><p><b>Static Base URI.</b> This is an absolute URI, used to resolve relative URIs during static analysis. </p></dd><dt><a href="#dt-static-context">static context</a></dt><dd><p>The <b>static context</b> of an expression is the information that is available during static analysis of the expression, prior to its evaluation.</p></dd><dt><a href="#dt-static-error">static error</a></dt><dd><p> An error that can be detected during the static analysis phase, and is not a type error, is a <b>static error</b>.</p></dd><dt><a href="#dt-static-function-call">static function call</a></dt><dd><p>A <b>static function call</b> is an instance of the production <a href="#doc-xquery40-FunctionCall">FunctionCall</a>: it consists of an EQName followed by a parenthesized list of zero or more arguments.</p></dd><dt><a href="#dt-static-type">static type</a></dt><dd><p>The <b>static type</b> of an expression is the best inference that the processor is able to make statically about the type of the result of the expression.</p></dd><dt><a href="#dt-step">step</a></dt><dd><p>The operands of a path expression are conventionally referred to as <b>steps</b>.</p></dd><dt><a href="#dt-string-constructor">string constructor</a></dt><dd><p>A <b>string constructor</b> is an instance of the production <a href="#doc-xquery40-StringConstructor">StringConstructor</a>: it is an expression that creates a string from literal text and interpolated subexpressions. </p></dd><dt><a href="#dt-string-value">string value</a></dt><dd><p>The <b>string value</b> of a node is a string and can be extracted by applying the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-string"><code>string</code></a> function to the node.</p></dd><dt><a href="#dt-substantively-disjoint">substantively disjoint</a></dt><dd><p>Two <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a> are deemed to be <b>substantively disjoint</b> if (a) neither is a subtype of the other (see <a href="#id-seqtype-subtype"><b>3.3.1 Subtypes of Sequence Types</b></a>) and (b) the only values that are instances of both types are one or more of the following:</p><ul><li><p>The empty sequence, <code>()</code>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-map">empty map</a><sup><small>DM</small></sup>, <code>{}</code>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-array">empty array</a><sup><small>DM</small></sup>, <code>[]</code>.</p></li></ul></dd><dt><a href="#dt-substitution-group">substitution group</a></dt><dd><p><b>Substitution groups</b> are defined in <a href="https://www.w3.org/TR/xmlschema-1/#Element_Equivalence_Class"> 2.2.2.2 Element Substitution Group </a><sup><small>XS1-1</small></sup> and <a href="https://www.w3.org/TR/xmlschema11-1/#Element_Equivalence_Class"> 2.2.2.2 Element Substitution Group </a><sup><small>XS11-1</small></sup>. Informally, the substitution group headed by a given element (called the <b>head element</b>) consists of the set of elements that can be substituted for the head element without affecting the outcome of schema validation.</p></dd><dt><a href="#dt-subtype">subtype</a></dt><dd><p>Given two <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a> or <a title="item type" class="termref" href="#dt-item-type">item types</a>, the rules in this section determine if one is a <b>subtype</b> of the other. If a type <var>A</var> is a subtype of type <var>B</var>, it follows that every value matched by <var>A</var> is also matched by <var>B</var>.</p></dd><dt><a href="#dt-subtype-substitution">subtype substitution</a></dt><dd><p>The use of a value that has a <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> that is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of the expected type is known as <b>subtype substitution</b>.</p></dd><dt><a href="#symbol">symbol</a></dt><dd><p>Each rule in the grammar defines one <b>symbol</b>, using the following format: </p><div class="exampleInner"><pre xml:space="preserve">symbol ::= expression</pre></div></dd><dt><a href="#symbolseparators">symbol separators</a></dt><dd><p><a title="whitespace" class="termref" href="#Whitespace">Whitespace</a> and <a href="#doc-xquery40-Comment">Comments</a> function as <b>symbol separators</b>. For the most part, they are not mentioned in the grammar, and may occur between any two terminal symbols mentioned in the grammar, except where that is forbidden by the <a href="#ws-explicit">/* ws: explicit */</a> annotation in the EBNF, or by the <a href="#parse-note-xml-version">/* xgc: xml-version */</a> annotation.</p></dd><dt><a href="#dt-system-function">system function</a></dt><dd><p><b>System functions</b> include the functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>, functions defined by the specifications of a host language, <a title="constructor function" class="termref" href="#dt-constructor-function">constructor functions</a> for atomic types, and any additional functions provided by the implementation. System functions are sometimes called built-in functions.</p></dd><dt><a href="#dt-target-namespace">target namespace</a></dt><dd><p> The <b>target namespace</b> of a module is the namespace of the objects (such as elements or functions) that it defines. </p></dd><dt><a href="#terminal">terminal</a></dt><dd><p>A <b>terminal</b> is a symbol or string or pattern that can appear in the right-hand side of a rule, but never appears on the left-hand side in the main grammar, although it may appear on the left-hand side of a rule in the grammar for terminals.</p></dd><dt><a href="#dt-trusted">trusted</a></dt><dd><p>The static context includes a boolean property called <b>trusted</b> that determines whether external resources are available.</p></dd><dt><a href="#id-tuple-foobar">tuple</a></dt><dd><p>A <b>tuple</b> is a set of zero or more named variables, each of which is bound to a value that is an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a>.</p></dd><dt><a href="#id-tuple-stream-foobar">tuple stream</a></dt><dd><p>A <b>tuple stream</b> is an ordered sequence of zero or more <b>tuples</b>.</p></dd><dt><a href="#dt-type-annotation">type annotation</a></dt><dd><p>Each element node and attribute node in an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> has a <b>type annotation</b> (described in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#types">4.1 Schema Information</a>). The type annotation of a node is a reference to a <a title="schema type" class="termref" href="#dt-schema-type">schema type</a>. </p></dd><dt><a href="#dt-typed-data-feature">typed data feature</a></dt><dd><p>The <b>Typed Data Feature</b> permits an XDM instance to contain element node types other than <code>xs:untyped</code> and attributes node types other than <code>xs:untypedAtomic</code>.</p></dd><dt><a href="#dt-type-declaration">type declaration</a></dt><dd><p>A variable binding may be accompanied by a <b>type declaration</b>, which consists of the keyword <code>as</code> followed by the static type of the variable, declared using the syntax in <a href="#id-sequencetype-syntax"><b>3.1 Sequence Types</b></a>.</p></dd><dt><a href="#dt-typed-value">typed value</a></dt><dd><p>The <b>typed value</b> of a node is a sequence of atomic items and can be extracted by applying the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-data"><code>data</code></a> function to the node.</p></dd><dt><a href="#dt-type-error">type error</a></dt><dd><p>A <b>type error</b> may be raised during the static analysis phase or the dynamic evaluation phase. During the static analysis phase, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs when the <a title="static type" class="termref" href="#dt-static-type">static type</a> of an expression does not match the expected type of the context in which the expression occurs. During the dynamic evaluation phase, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs when the <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> of a value does not match the expected type of the context in which the value occurs.</p></dd><dt><a href="#dt-untrusted">untrusted</a></dt><dd></dd><dt><a href="#dt-URI">URI</a></dt><dd><p>Within this specification, the term <b>URI</b> refers to a Universal Resource Identifier as defined in <a href="#RFC3986">[RFC3986]</a> and extended in <a href="#RFC3987">[RFC3987]</a> with the new name <b>IRI</b>.</p></dd><dt><a href="#dt-udf">user-defined function</a></dt><dd><p><b>User defined functions</b> are functions that contain a <b>function body</b>, which provides the implementation of the function as a <a title="content expression" class="termref" href="#dt-content-expression">content expression</a>.</p></dd><dt><a href="#dt-value">value</a></dt><dd><p>In the <a title="data model" class="termref" href="#dt-datamodel">data model</a>, a <b>value</b> is always a <a title="sequence" class="termref" href="#dt-sequence">sequence</a>.</p></dd><dt><a href="#dt-variable-declaration">variable declaration</a></dt><dd><p>A <b>variable declaration</b> in the XQuery prolog defines the name and <a title="static type" class="termref" href="#dt-static-type">static type</a> of a variable, and optionally a value for the variable. It adds to the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, and may also add to the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a> in the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a>.</p></dd><dt><a href="#dt-variable-reference">variable reference</a></dt><dd><p>A <b>variable reference</b> is an EQName preceded by a $-sign.</p></dd><dt><a href="#dt-variable-terminal">variable terminal</a></dt><dd><p>A <b>variable terminal</b> is an instance of a production rule that is not itself an <a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule">ordinary production rule</a> but that is named (directly) on the right-hand side of an <a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule">ordinary production rule</a>.</p></dd><dt><a href="#dt-variable-values">variable values</a></dt><dd><p><b>Variable values</b>. This is a mapping from <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> to values. It contains the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> as the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> for the expression. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is the name of the variable and the value is the dynamic value of the variable, which includes its <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a>.</p></dd><dt><a href="#dt-version-declaration">version declaration</a></dt><dd><p> A <b>version declaration</b> can identify the applicable XQuery syntax and semantics for a <a title="module" class="termref" href="#dt-module">module</a>, as well as its encoding.</p></dd><dt><a href="#dt-warning">warning</a></dt><dd><p>In addition to <a title="static error" class="termref" href="#dt-static-error">static errors</a>, <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a>, and <a title="type error" class="termref" href="#dt-type-error">type errors</a>, an XQuery 4.0 implementation may raise <b>warnings</b>, either during the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a> or the <a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation">dynamic evaluation phase</a>. The circumstances in which warnings are raised, and the ways in which warnings are handled, are <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p></dd><dt><a href="#Whitespace">whitespace</a></dt><dd><p>A <b>whitespace</b> character is any of the characters defined by <a href="http://www.w3.org/TR/REC-xml/#NT-S"> [http://www.w3.org/TR/REC-xml/#NT-S]</a>.</p></dd><dt><a href="#dt-wildcard-matches">wildcard-matches</a></dt><dd><p>In these rules, if <var>MU</var> and <var>NU</var> are <a href="#prod-xquery40-NameTestUnion">NameTestUnions</a>, then <var>MU</var><b>wildcard-matches</b><var>NU</var> is true if every name that matches <var>MU</var> also matches <var>NU</var>.</p></dd><dt><a href="#dt-window">window</a></dt><dd><p>A <b>window</b> is a sequence of consecutive items drawn from the <a title="binding sequence" class="termref" href="#dt-binding-sequence">binding sequence</a>.</p></dd><dt><a href="#dt-data-model-instance">XDM instance</a></dt><dd><p>The term <b>XDM instance</b> is used, synonymously with the term <a title="value" class="termref" href="#dt-value">value</a>, to denote an unconstrained <a title="sequence" class="termref" href="#dt-sequence">sequence</a> of <a title="item" class="termref" href="#dt-item">items</a>.</p></dd><dt><a href="#dt-XNode">XNode</a></dt><dd><p>An <b>XNode</b> is an instance of one of the <b>node kinds</b> defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#nodes">7.1 XML Nodes</a>.</p></dd><dt><a href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a></dt><dd><p><b>XPath 1.0 compatibility mode.</b><span class="xquery">This component must be set by all host languages that include XPath 3.1 as a subset, indicating whether rules for compatibility with XPath 1.0 are in effect. XQuery sets the value of this component to <code>false</code>. </span></p></dd><dt><a href="#dt-xquery-10-processor">XQuery 1.0 Processor</a></dt><dd><p> An <b>XQuery 1.0 Processor</b> processes a query according to the XQuery 1.0 specification. </p></dd><dt><a href="#dt-xquery-30-processor">XQuery 3.0 Processor</a></dt><dd><p> An <b>XQuery 3.0 Processor</b> processes a query according to the XQuery 3.0 specification. </p></dd><dt><a href="#dt-xquery-31-processor">XQuery 3.1 Processor</a></dt><dd><p> An <b>XQuery 3.1 Processor</b> processes a query according to the XQuery 3.1 specification. </p></dd><dt><a href="#dt-xquery-40-processor">XQuery 4.0 Processor</a></dt><dd><p> An <b>XQuery 4.0 Processor</b> processes a query according to the XQuery 4.0 specification. </p></dd><dt><a href="#dt-version-number">XQuery version number</a></dt><dd><p>An <b>XQuery version number</b> consists of two integers, referred to as the <b>major version number</b> and the <b>minor version number</b>.</p></dd><dt><a href="#dt-anyAtomicType">xs:anyAtomicType</a></dt><dd><p><code>xs:anyAtomicType</code> is an <a title="atomic type" class="termref" href="#dt-atomic-type">atomic type</a> that includes all atomic items (and no values that are not atomic). Its base type is <code>xs:anySimpleType</code> from which all simple types, including atomic, list, and union types, are derived. All primitive atomic types, such as <code>xs:decimal</code> and <code>xs:string</code>, have <code>xs:anyAtomicType</code> as their base type.</p></dd><dt><a href="#dt-dayTimeDuration">xs:dayTimeDuration</a></dt><dd><p><code>xs:dayTimeDuration</code> is derived by restriction from <code>xs:duration</code>. The lexical representation of <code>xs:dayTimeDuration</code> is restricted to contain only day, hour, minute, and second components.</p></dd><dt><a href="#dt-xs-error">xs:error</a></dt><dd><p><code>xs:error</code> is a simple type with no value space. It is defined in <a href="https://www.w3.org/TR/xmlschema11-1/#xsd-error"> 3.16.7.3 xs:error </a><sup><small>XS11-1</small></sup> and can be used in the <a href="#id-sequencetype-syntax"><b>3.1 Sequence Types</b></a> to raise errors.</p></dd><dt><a href="#dt-untyped">xs:untyped</a></dt><dd><p><code>xs:untyped</code> is used as the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of an element node that has not been validated, or has been validated in <code>skip</code> mode.</p></dd><dt><a href="#dt-untypedAtomic">xs:untypedAtomic</a></dt><dd><p><code>xs:untypedAtomic</code> is an <a title="atomic type" class="termref" href="#dt-atomic-type">atomic type</a> that is used to denote untyped atomic data, such as text that has not been assigned a more specific type.</p></dd><dt><a href="#dt-yearMonthDuration">xs:yearMonthDuration</a></dt><dd><p><code>xs:yearMonthDuration</code> is derived by restriction from <code>xs:duration</code>. The lexical representation of <code>xs:yearMonthDuration</code> is restricted to contain only year and month components.</p></dd><dt><a href="#dt-XTree">XTree</a></dt><dd><p>A tree that is rooted at a parentless <a title="XNode" class="termref" href="#dt-XNode">XNode</a> is referred to as an <b>XTree</b>.</p></dd><dt><a href="#id-static-decimal-format-zero-digit">zero-digit</a></dt><dd><p><b>zero-digit</b><em>(<var>M</var>)</em> is the character used in the picture string to represent the digit zero; the default value is <span class="unicode-codepoint">U+0030</span> (<span class="unicode-name">DIGIT ZERO</span>, <code>0</code>) . This character must be a digit (category Nd in the Unicode property database), and it must have the numeric value zero. This property implicitly defines the ten Unicode characters that are used to represent the values 0 to 9 in the function output: Unicode is organized so that each set of decimal digits forms a contiguous block of characters in numerical sequence. Within the picture string any of these ten character can be used (interchangeably) as a place-holder for a mandatory digit. Within the final result string, these ten characters are used to represent the digits zero to nine.</p></dd></dl></div><div class="_diffs div1"><h2><a id="id-revision-log"></a>J <a href="#id-revision-log" style="text-decoration: none">Change Log</a> (Non-Normative)</h2><ol><li><p>If a section of this specification has been updated since version 3.1, an overview of the changes is provided, along with links to navigate to the next or previous change.</p><p>See <a href="#id-introduction"><b>1 Introduction</b></a></p></li><li><p>Sections with significant changes are marked with a ✭ symbol in the table of contents.</p><p>See <a href="#id-introduction"><b>1 Introduction</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/691 2154">691 2154&nbsp;</a></p><p>Enumeration types are added as a new kind of <code>ItemType</code>, constraining the value space of strings.</p><p>See <a href="#id-enumeration-types"><b>3.2.6 Enumeration Types</b></a></p></li><li><p> Setting the default namespace for elements and types to the special value <code>##any</code> causes an unprefixed element name to act as a wildcard, matching by local name regardless of namespace. </p><p>See <a href="#id-element-test"><b>3.2.7.2 Element Types</b></a></p></li><li><p>The terms <b>FunctionType</b>, <b>ArrayType</b>, <b>MapType</b>, and <b>RecordType</b> replace <b>FunctionTest</b>, <b>ArrayTest</b>, <b>MapTest</b>, and <b>RecordTest</b>, with no change in meaning.</p><p>See <a href="#id-function-test"><b>3.2.8.1 Function Types</b></a></p></li><li><p> Record types are added as a new kind of <code>ItemType</code>, constraining the value space of maps. </p><p>See <a href="#id-record-test"><b>3.2.8.3 Record Types</b></a></p></li><li><p> Function coercion now allows a function with arity <var>N</var> to be supplied where a function of arity greater than <var>N</var> is expected. For example this allows the function <code>true#0</code> to be supplied where a predicate function is required. </p><p>See <a href="#id-function-coercion"><b>3.4.3 Function Coercion</b></a></p></li><li><p> The symbols <code>×</code> and <code>÷</code> can be used for multiplication and division. </p><p>See <a href="#id-arithmetic"><b>4.8 Arithmetic Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1480 1989">1480 1989&nbsp;</a></p><p> When the element name matches a language keyword such as <code>div</code> or <code>value</code>, it must now be written as a QName literal. This is a backwards incompatible change. </p><p>See <a href="#id-computedElements"><b>4.12.3.1 Computed Element Constructors</b></a></p><p> When the attribute name matches a language keyword such as <code>by</code> or <code>of</code>, it must now be written as a QName literal. This is a backwards incompatible change. </p><p>See <a href="#id-computedAttributes"><b>4.12.3.2 Computed Attribute Constructors</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1513 2028">1513 2028&nbsp;</a></p><p> When the processing instruction name matches a language keyword such as <code>try</code> or <code>validate</code>, it must now be written with a preceding <code>#</code> character. This is a backwards incompatible change. </p><p>See <a href="#id-computed-pis"><b>4.12.3.5 Computed Processing Instruction Constructors</b></a></p><p> When the namespace prefix matches a language keyword such as <code>as</code> or <code>at</code>, it must now be written with a preceding <code>#</code> character. This is a backwards incompatible change. </p><p>See <a href="#id-computed-namespaces"><b>4.12.3.7 Computed Namespace Constructors</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1763 1830">1763 1830&nbsp;</a></p><p>The syntax on the right-hand side of an arrow operator has been relaxed; a dynamic function call no longer needs to start with a variable reference or a parenthesized expression, it can also be (for example) an inline function expression or a map or array constructor.</p><p>See <a href="#id-arrow-operator"><b>4.24 Arrow Expressions</b></a></p></li><li><p> The arrow operator <code>=&gt;</code> is now complemented by a “mapping arrow” operator <code>=!&gt;</code> which applies the supplied function to each item in the input sequence independently. </p><p>See <a href="#id-mapping-arrow-expression"><b>4.24.2 Mapping Arrow Expressions</b></a></p></li><li><p> All implementations must now predeclare the namespace prefixes <code>math</code>, <code>map</code>, <code>array</code>, and <code>err</code>. In XQuery 3.1 it was permitted but not required to predeclare these namespaces. </p><p>See <a href="#id-namespace-declaration"><b>5.13 Namespace Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2200 2236">2200 2236&nbsp;</a></p><p> The effect of not declaring a default function namespace has changed: user-defined functions can now be in no namespace, and a search for an unprefixed function name will be resolved first against functions in no namespace, and only then against functions in the standard function namespace. </p><p>See <a href="#id-default-namespace"><b>5.14 Default Namespace Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/254 2050">254 2050&nbsp;</a></p><p> The supplied context value is now coerced to the required type specified in the main module using the coercion rules. </p><p>See <a href="#id-context-value-declarations"><b>5.17 Context Value Declaration</b></a></p></li><li><p> Function definitions in the static context may now have optional parameters, provided this does not cause ambiguity across multiple function definitions with the same name. Optional parameters are given a default value, which can be any expression, including one that depends on the context of the caller (so an argument can default to the context value). </p><p>See <a href="#FunctionDeclns"><b>5.18 Function Declarations</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/682 TODO">682 TODO&nbsp;</a></p><p> The values <code>true()</code> and <code>false()</code> are allowed in function annotations, as well as negated numeric literals and QName literals. </p><p>See <a href="#id-function-annotations"><b>5.18.4 Function Annotations</b></a></p></li><li><p> A user-defined function whose name is given as an unprefixed QName is now in no namespace. In previous versions of the language, it represented a name in the <a title="default function namespace" class="termref" href="#dt-default-function-namespace">default function namespace</a> (which only worked if the <a title="default function namespace" class="termref" href="#dt-default-function-namespace">default function namespace</a> was explicitly set to an unreserved namespace, which was rarely done because it caused other problems). </p><p>See <a href="#FunctionDeclns"><b>5.18 Function Declarations</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1023 1128">1023 1128&nbsp;</a></p><p> It has been clarified that function coercion applies even when the supplied function item matches the required function type. This is to ensure that arguments supplied when calling the function are checked against the signature of the required function type, which might be stricter than the signature of the supplied function item. </p><p>See <a href="#id-function-coercion"><b>3.4.3 Function Coercion</b></a></p></li><li><p>A dynamic function call can now be applied to a sequence of functions, and in particular to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. This makes it easier to chain a sequence of calls.</p><p>See <a href="#id-eval-dynamic-function-call"><b>4.5.3.1 Evaluating Dynamic Function Calls</b></a></p></li><li><p> Parts of the static context that were there purely to assist in static typing, such as the statically known documents, were no longer referenced and have therefore been dropped. </p><p>See <a href="#id-xq-static-context-components"><b>B.1 Static Context Components</b></a></p></li><li><p> The syntax <code>document-node(<var>N</var>)</code>, where <var>N</var> is a <code>NameTestUnion</code>, is introduced as an abbreviation for <code>document-node(element(<var>N</var>))</code>. For example, <code>document-node(*)</code> matches any well-formed XML document (as distinct from a document fragment). </p><p>See <a href="#node-types"><b>3.2.7 Node Types</b></a></p></li><li><p>QName literals are new in 4.0.</p><p>See <a href="#id-qname-literals"><b>4.2.1.3 QName Literals</b></a></p></li><li><p> Path expressions are extended to handle JNodes (found in trees of maps and arrays) as well as XNodes (found in trees representing parsed XML). </p><p>See <a href="#id-path-expressions"><b>4.6 Path Expressions</b></a></p></li><li><p>A method call invokes a function held as the value of an entry in a map, supplying the map implicitly as the value of the first argument.</p><p>See <a href="#id-methods"><b>4.14.4 Method Calls</b></a></p></li><li><p>The <code>treat as</code> expression now raises a type error rather than a dynamic error when it fails.</p><p>See <a href="#id-treat"><b>4.21.6 Treat</b></a></p></li><li><p> The group is considering removing or substantially changing this feature, it is considered <a href="#at-risk">at risk</a>. </p><p>See <a href="#id-filter-maps-and-arrays"><b>4.14.5 Filter Expressions for Maps and Arrays</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/159">159&nbsp;</a></p><p> Keyword arguments are allowed on static function calls, as well as positional arguments. </p><p>See <a href="#id-function-calls"><b>4.5.1.1 Static Function Call Syntax</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/202">202&nbsp;</a></p><p>The presentation of the rules for the subtype relationship between sequence types and item types has been substantially rewritten to improve clarity; no change to the semantics is intended.</p><p>See <a href="#id-sequencetype-subtype"><b>3.3 Subtype Relationships</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/230">230&nbsp;</a></p><p> The rules for “errors and optimization” have been tightened up to disallow many cases of optimizations that alter error behavior. In particular there are restrictions on reordering the operands of <code>and</code> and <code>or</code>, and of predicates in filter expressions, in a way that might allow the processor to raise dynamic errors that the author intended to prevent. </p><p>See <a href="#id-guarded-expressions"><b>2.5.5 Guarded Expressions</b></a></p><p>See <a href="#id-logical-expressions"><b>4.11 Logical Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/254">254&nbsp;</a></p><p> The term "function conversion rules" used in 3.1 has been replaced by the term "coercion rules". </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p><p> The coercion rules allow “relabeling” of a supplied atomic item where the required type is a derived atomic type: for example, it is now permitted to supply the value 3 when calling a function that expects an instance of <code>xs:positiveInteger</code>. </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p><p> The value bound to a variable in a <code>let</code> clause is now converted to the declared type by applying the coercion rules. </p><p>See <a href="#id-xquery-let-clause"><b>4.13.3 Let Clause</b></a></p><p> The coercion rules are now used when binding values to variables (both global variable declarations and local variable bindings). This aligns XQuery with XSLT, and means that the rules for binding to variables are the same as the rules for binding to function parameters. </p><p>See <a href="#id-variable-declarations"><b>5.16 Variable Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/284">284&nbsp;</a></p><p> Alternative syntax for conditional expressions is available: <code>if (condition) { X }</code>. </p><p>See <a href="#id-conditionals"><b>4.16 Conditional Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/286">286&nbsp;</a></p><p> Element and attribute tests can include alternative names: <code>element(chapter|section)</code>, <code>attribute(role|class)</code>. </p><p>See <a href="#node-types"><b>3.2.7 Node Types</b></a></p><p> The <code>NodeTest</code> in an <code>AxisStep</code> now allows alternatives: <code>ancestor::(section|appendix)</code></p><p>See <a href="#node-types"><b>3.2.7 Node Types</b></a></p><p> Element and attribute tests of the form <code>element(N)</code> and <code>attribute(N)</code> now allow <code>N</code> to be any <code>NameTest</code>, including a wildcard. </p><p>See <a href="#id-element-test"><b>3.2.7.2 Element Types</b></a></p><p>See <a href="#id-attribute-test"><b>3.2.7.3 Attribute Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/324">324&nbsp;</a></p><p> String templates provide a new way of constructing strings: for example <code>`{$greeting}, {$planet}!`</code> is equivalent to <code>$greeting || ', ' || $planet || '!'</code></p><p>See <a href="#id-string-templates"><b>4.9.2 String Templates</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/326">326&nbsp;</a></p><p> Support for higher-order functions is now a mandatory feature (in 3.1 it was optional). </p><p>See <a href="#id-conformance"><b>6 Conformance</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/344">344&nbsp;</a></p><p>A <code>for member</code> clause is added to FLWOR expressions to allow iteration over an array. </p><p>See <a href="#id-xquery-for-clause"><b>4.13.2 For Clause</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/364">364&nbsp;</a></p><p> Switch expressions now allow a <code>case</code> clause to match multiple atomic items. </p><p>See <a href="#id-switch"><b>4.18 Switch Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/368">368&nbsp;</a></p><p> The concept of the context item has been generalized, so it is now a context value. That is, it is no longer constrained to be a single item. </p><p>See <a href="#eval_context"><b>2.2.2 Dynamic Context</b></a></p><p>See <a href="#id-context-value-declarations"><b>5.17 Context Value Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/433">433&nbsp;</a></p><p> Numeric literals can now be written in hexadecimal or binary notation; and underscores can be included for readability. </p><p>See <a href="#id-numeric-literals"><b>4.2.1.1 Numeric Literals</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/483">483&nbsp;</a></p><p> The <code>start</code> clause in window expressions has become optional, as well as the <code>when</code> keyword and its associated expression. </p><p>See <a href="#id-windows"><b>4.13.4 Window Clause</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/487">487&nbsp;</a></p><p>In XQuery 4.0, an initial set of namespace bindings is prescribed for the static context.</p><p>See <a href="#id-namespaces-and-qnames"><b>2.1.4 Namespaces and QNames</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/493">493&nbsp;</a></p><p> A new variable <code>$err:map</code> is available, capturing all error information in one place. </p><p>See <a href="#id-try-catch"><b>4.20 Try/Catch Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/519">519&nbsp;</a></p><p> The rules for tokenization have been largely rewritten. In some cases the revised specification may affect edge cases that were handled in different ways by different 3.1 processors, which could lead to incompatible behavior. </p><p>See <a href="#lexical-structure"><b>A.3 Lexical structure</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/521">521&nbsp;</a></p><p>New abbreviated syntax is introduced (<a title="focus function" class="termref" href="#dt-focus-function">focus function</a>) for simple inline functions taking a single argument. An example is <code>fn { ../@code }</code></p><p>See <a href="#id-inline-func"><b>4.5.6 Inline Function Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/587">587&nbsp;</a></p><p> Switch and typeswitch expressions can now be written with curly brackets, to improve readability. </p><p>See <a href="#id-switch"><b>4.18 Switch Expressions</b></a></p><p>See <a href="#id-typeswitch"><b>4.21.2 Typeswitch</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/603">603&nbsp;</a></p><p><span style="display: none;" class="delete_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return an empty sequence rather than an error. </span><span style="display: none;" class="add_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return the empty sequence rather than an error. </span><span class="modify_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence rather than an error. </span></p><p>See <a href="#id-implausible-expressions"><b>2.5.6 Implausible Expressions</b></a></p><p>See <a href="#implausible-axis-steps"><b>4.6.5.6 Implausible Axis Steps</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/606">606&nbsp;</a></p><p> Element and attribute tests of the form <code>element(A|B)</code> and <code>attribute(A|B)</code> are now allowed. </p><p>See <a href="#id-element-test"><b>3.2.7.2 Element Types</b></a></p><p>See <a href="#id-attribute-test"><b>3.2.7.3 Attribute Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/635">635&nbsp;</a></p><p>The rules for the consistency of schemas imported by different query modules, and for consistency between imported schemas and those used for validating input documents, have been defined with greater precision. It is now recognized that these schemas will not always be identical, and that validation with respect to different schemas may produce different outcomes, even if the components of one are a subset of the components of the other.</p><p>See <a href="#id-schema-import"><b>5.11 Schema Import</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/659">659&nbsp;</a></p><p>In previous versions the interpretation of location hints in <code>import schema</code> declarations was entirely at the discretion of the processor. To improve interoperability, XQuery 4.0 recommends (but does not mandate) a specific strategy for interpreting these hints.</p><p>See <a href="#id-schema-import"><b>5.11 Schema Import</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/678">678&nbsp;</a></p><p> The comparand expression in a switch expression can be omitted, allowing the switch cases to be provided as arbitrary boolean expressions. </p><p>See <a href="#id-switch"><b>4.18 Switch Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/728">728&nbsp;</a></p><p> The syntax <code>record(*)</code> is allowed; it matches any map. </p><p>See <a href="#id-record-test"><b>3.2.8.3 Record Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/753">753&nbsp;</a></p><p> The <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a> can now be declared to be fixed for a query module, meaning it is unaffected by a namespace declaration appearing on a direct element constructor. </p><p>See <a href="#id-namespaces"><b>4.12.1.2 Namespace Declaration Attributes</b></a></p><p>See <a href="#id-default-namespace"><b>5.14 Default Namespace Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/815">815&nbsp;</a></p><p> The coercion rules now allow conversion in either direction between <code>xs:hexBinary</code> and <code>xs:base64Binary</code>. </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/820">820&nbsp;</a></p><p> The value bound to a variable in a <code>for</code> clause is now converted to the declared type by applying the coercion rules. </p><p>See <a href="#id-xquery-for-clause"><b>4.13.2 For Clause</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/911">911&nbsp;</a></p><p> The coercion rules now allow any numeric type to be implicitly converted to any other, for example an <code>xs:double</code> is accepted where the required type is <code>xs:decimal</code>. </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/943">943&nbsp;</a></p><p> A FLWOR expression may now include a <code>while</code> clause, which causes early exit from the iteration when a condition is encountered. </p><p>See <a href="#id-while"><b>4.13.6 While Clause</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/996">996&nbsp;</a></p><p> The value of a predicate in a filter expression can now be a sequence of integers. </p><p>See <a href="#id-filter-expression"><b>4.4 Filter Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1031">1031&nbsp;</a></p><p><span style="display: none;" class="delete_version"> An <code>otherwise</code> operator is introduced: <code>A otherwise B</code> returns the value of <code>A</code>, unless it is an empty sequence, in which case it returns the value of <code>B</code>. </span><span style="display: none;" class="add_version"> An <code>otherwise</code> operator is introduced: <code>A otherwise B</code> returns the value of <code>A</code>, unless it is the empty sequence, in which case it returns the value of <code>B</code>. </span><span class="modify_version"> An <code>otherwise</code> operator is introduced: <code>A otherwise B</code> returns the value of <code>A</code>, unless it is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, in which case it returns the value of <code>B</code>. </span></p><p>See <a href="#id-otherwise"><b>4.17 Otherwise Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1071">1071&nbsp;</a></p><p> In map constructors, the keyword <code>map</code> is now optional, so <code>map { 0: false(), 1: true() }</code> can now be written <code>{ 0: false(), 1: true() }</code>, provided it is used in a context where this creates no ambiguity. </p><p>See <a href="#id-map-constructors"><b>4.14.1.1 Map Constructors</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1132">1132&nbsp;</a></p><p> Choice item types (an item type allowing a set of alternative item types) are introduced. </p><p>See <a href="#id-choice-item-types"><b>3.2.5 Choice Item Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1163">1163&nbsp;</a></p><p> Filter expressions for maps and arrays are introduced. </p><p>See <a href="#id-filter-maps-and-arrays"><b>4.14.5 Filter Expressions for Maps and Arrays</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1181">1181&nbsp;</a></p><p> The <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a> can be set to the value <code>##any</code>, allowing unprefixed names in axis steps to match elements with a given local name in any namespace. </p><p>See <a href="#static_context"><b>2.2.1 Static Context</b></a></p><p> If the default namespace for elements and types has the special value <code>##any</code>, then an unprefixed name in a <code>NameTest</code> acts as a wildcard, matching names in any namespace or none. </p><p>See <a href="#node-tests"><b>4.6.5.2 Node Tests</b></a></p><p> The <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a> can be set to the value <code>##any</code>, allowing unprefixed names in axis steps to match elements with a given local name in any namespace. </p><p>See <a href="#id-default-namespace"><b>5.14 Default Namespace Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1197">1197&nbsp;</a></p><p>The keyword <code>fn</code> is allowed as a synonym for <code>function</code> in function types, to align with changes to inline function declarations.</p><p>See <a href="#id-function-test"><b>3.2.8.1 Function Types</b></a></p><p> In inline function expressions, the keyword <code>function</code> may be abbreviated as <code>fn</code>. </p><p>See <a href="#id-inline-func"><b>4.5.6 Inline Function Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1212">1212&nbsp;</a></p><p> New keywords introducing item types, such as <code>record</code>, <code>item</code>, and <code>enum</code>, have been added to the list of reserved function names. </p><p>See <a href="#id-reserved-fn-names"><b>A.4 Reserved Function Names</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1217">1217&nbsp;</a></p><p> Predicates in filter expressions for maps and arrays can now be numeric. </p><p>See <a href="#id-filter-maps-and-arrays"><b>4.14.5 Filter Expressions for Maps and Arrays</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1249">1249&nbsp;</a></p><p>A <code>for key/value</code> clause is added to FLWOR expressions to allow iteration over a map. </p><p>See <a href="#id-xquery-for-clause"><b>4.13.2 For Clause</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1250">1250&nbsp;</a></p><p> Several decimal format properties, including minus sign, exponent separator, percent, and per-mille, can now be rendered as arbitrary strings rather than being confined to a single character. </p><p>See <a href="#id-decimal-formats"><b>2.2.1.2 Decimal Formats</b></a></p><p>See <a href="#id-decimal-format-decl"><b>5.10 Decimal Format Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1254">1254&nbsp;</a></p><p> The rules concerning the interpretation of <code>xsi:schemaLocation</code> and <code>xsi:noNamespaceSchemaLocation</code> attributes have been tightened up. </p><p>See <a href="#id-validate"><b>4.25 Validate Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1265">1265&nbsp;</a></p><p> The rules regarding the <code>document-uri</code> property of nodes returned by the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>fn:collection</code></a> function have been relaxed. </p><p>See <a href="#eval_context"><b>2.2.2 Dynamic Context</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1342">1342&nbsp;</a></p><p> The <code>ordered { E }</code> and <code>unordered { E }</code> expressions are retained for backwards compatibility reasons, but in XQuery 4.0 they are deprecated and have no useful effect. </p><p>See <a href="#id-unordered-expressions"><b>4.15 Ordered and Unordered Expressions</b></a></p><p> The ordering mode declaration is retained for backwards compatibility reasons, but in XQuery 4.0 it is deprecated and has no useful effect. </p><p>See <a href="#id-default-ordering-decl"><b>5.7 Ordering Mode Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1344">1344&nbsp;</a></p><p> Parts of the static context that were there purely to assist in static typing, such as the statically known documents, were no longer referenced and have therefore been dropped. </p><p>See <a href="#static_context"><b>2.2.1 Static Context</b></a></p><p> The static typing option has been dropped. </p><p>See <a href="#id-processing-model"><b>2.4 Processing Model</b></a></p><p> The static typing feature has been dropped. </p><p>See <a href="#id-conformance"><b>6 Conformance</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1361">1361&nbsp;</a></p><p> The term <b>atomic value</b> has been replaced by <a title="atomic item" class="termref" href="#dt-atomic-item">atomic item</a>. </p><p>See <a href="#id-values"><b>2.1.3 Values</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1384">1384&nbsp;</a></p><p> If a type declaration is present, the supplied values in the input sequence are now coerced to the required type. Type declarations are now permitted in XPath as well as XQuery. </p><p>See <a href="#id-quantified-expressions"><b>4.19 Quantified Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1432">1432&nbsp;</a></p><p> In earlier versions, the static context for the <a title="initializing expression" class="termref" href="#dt-initializing-expression">initializing expression</a> excluded the variable being declared. This restriction has been lifted. </p><p>See <a href="#id-variable-declarations"><b>5.16 Variable Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1470">1470&nbsp;</a></p><p><code>$err:stack-trace</code> provides information about the current state of execution. </p><p>See <a href="#id-try-catch"><b>4.20 Try/Catch Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1496">1496&nbsp;</a></p><p> The context value static type, which was there purely to assist in static typing, has been dropped. </p><p>See <a href="#static_context"><b>2.2.1 Static Context</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1498">1498&nbsp;</a></p><p>The EBNF operators <code>++</code> and <code>**</code> have been introduced, for more concise representation of sequences using a character such as <code>","</code> as a separator. The notation is borrowed from Invisible XML.</p><p>See <a href="#id-terminology"><b>2.1 Terminology</b></a></p><p> The EBNF notation has been extended to allow the constructs <code>(A ++ ",")</code> (one or more occurrences of <code>A</code>, comma-separated, and <code>(A ** ",")</code> (zero or more occurrences of <code>A</code>, comma-separated. </p><p>See <a href="#id-ebnf-introduction"><b>2.1.1 Grammar Notation</b></a></p><p>The EBNF operators <code>++</code> and <code>**</code> have been introduced, for more concise representation of sequences using a character such as <code>","</code> as a separator. The notation is borrowed from Invisible XML.</p><p>See <a href="#id-grammar"><b>A.1 EBNF</b></a></p><p>See <a href="#EBNFNotation"><b>A.1.1 Notation</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1501">1501&nbsp;</a></p><p> The coercion rules now apply recursively to the members of an array and the entries in a map. </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1532">1532&nbsp;</a></p><p> Four new axes have been defined: <code>preceding-or-self</code>, <code>preceding-sibling-or-self</code>, <code>following-or-self</code>, and <code>following-sibling-or-self</code>. </p><p>See <a href="#axes"><b>4.6.5.1 Axes</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1577">1577&nbsp;</a></p><p><span style="display: none;" class="delete_version"> The syntax <code>record()</code> is allowed; the only thing it matches is an empty map. </span><span style="display: none;" class="add_version"> The syntax <code>record()</code> is allowed; the only thing it matches is the empty map. </span><span class="modify_version"> The syntax <code>record()</code> is allowed; the only thing it matches is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty map. </span></p><p>See <a href="#id-record-test"><b>3.2.8.3 Record Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1686">1686&nbsp;</a></p><p> With the pipeline operator <code>-&gt;</code>, the result of an expression can be bound to the context value before evaluating another expression. </p><p>See <a href="#id-pipeline-operator"><b>4.22 Pipeline operator</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1696">1696&nbsp;</a></p><p> Parameter names may be included in a function signature; they are purely documentary. </p><p>See <a href="#id-function-test"><b>3.2.8.1 Function Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1703">1703&nbsp;</a></p><p>Ordered maps are introduced.</p><p>See <a href="#id-maps"><b>4.14.1 Maps</b></a></p><p>The order of key-value pairs in the map constructor is now retained in the constructed map.</p><p>See <a href="#id-map-constructors"><b>4.14.1.1 Map Constructors</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1874">1874&nbsp;</a></p><p> The coercion rules now reorder the entries in a map when the required type is a record type. </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1898">1898&nbsp;</a></p><p>The rules for subtyping of document node types have been refined.</p><p>See <a href="#id-item-subtype-documents"><b>3.3.2.5.2 Subtyping Nodes: Document Nodes</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1914">1914&nbsp;</a></p><p> A <code>finally</code> clause can be supplied, which will always be evaluated after the expressions of the try/catch clauses. </p><p>See <a href="#id-try-catch"><b>4.20 Try/Catch Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1956">1956&nbsp;</a></p><p> Private variables declared in a library module are no longer required to be in the module namespace. </p><p>See <a href="#id-variable-declarations"><b>5.16 Variable Declaration</b></a></p><p> Private functions declared in a library module are no longer required to be in the module namespace. </p><p>See <a href="#id-function-names"><b>5.18.2 Function Names</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1982">1982&nbsp;</a></p><p> Whitespace is now required after the opening <code>(#</code> of a pragma. This is an incompatible change, made to ensure that an expression such as <code>error(#err:XPTY0004)</code> can be parsed as a function call taking a QName literal as its argument value. </p><p>See <a href="#id-extension-expressions"><b>4.26 Extension Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1991">1991&nbsp;</a></p><p> Named record types used in the signatures of built-in functions are now available as standard in the static context. </p><p>See <a href="#static_context"><b>2.2.1 Static Context</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2026">2026&nbsp;</a></p><p> The module feature is no longer an optional feature; processing of library modules is now required. </p><p>See <a href="#id-conformance"><b>6 Conformance</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2030">2030&nbsp;</a></p><p> The technical details of how validation works have been moved to the <em>Functions and Operators</em> specification. The XQuery <code>validate</code> expression is now defined in terms of the new <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-xsd-validator"><code>xsd-validator</code></a> function. </p><p>See <a href="#id-validate"><b>4.25 Validate Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2031">2031&nbsp;</a></p><p> The terms <b>XNode</b> and <code>JNode</code> are introduced; the existing term <b>node</b> remains in use as a synonym for <b>XNode</b> where the context does not specify otherwise. </p><p>See <a href="#id-values"><b>2.1.3 Values</b></a></p><p> JNodes are introduced </p><p>See <a href="#id-jnode-types"><b>3.2.9 JNode Types</b></a></p><p>See <a href="#id-generalized-node-types"><b>3.2.10 Generalized Node Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2055">2055&nbsp;</a></p><p> Sequences, arrays, and maps can be destructured in a <code>let</code> clause to extract their components into multiple variables. </p><p>See <a href="#id-xquery-let-clause"><b>4.13.3 Let Clause</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2094">2094&nbsp;</a></p><p>A general expression is allowed within a map constructor; this facilitates the creation of maps in which the presence or absence of particular keys is decided dynamically.</p><p>See <a href="#id-map-constructors"><b>4.14.1.1 Map Constructors</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2115">2115&nbsp;</a></p><p> This section describes and formalizes a convention that was already in use, but not explicitly stated, in earlier versions of the specification. </p><p>See <a href="#id-expression-names"><b>2.1.2 Expression Names</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2130">2130&nbsp;</a></p><p> Operator <code>is-not</code> is introduced, as a complement to the operator <code>is</code>. </p><p>See <a href="#id-node-comparisons"><b>4.10.3 GNode Comparisons</b></a></p><p> Operators <code>precedes</code> and <code>follows</code> are introduced as synonyms for operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code>. </p><p>See <a href="#id-node-comparisons"><b>4.10.3 GNode Comparisons</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2134">2134&nbsp;</a></p><p> The lookup operator <code>?</code> can now be followed by an arbitrary literal, for cases where keys are items other than integers or NCNames. It can also be followed by a variable reference or a context value reference. </p><p>See <a href="#id-lookup"><b>4.14.3 Lookup Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2176">2176&nbsp;</a></p><p> Operators <code>precedes-or-is</code> and <code>follows-or-is</code> are introduced as synonyms for the union of operators <code>&lt;&lt;</code> and <code>is</code> and for the union of operators <code>&gt;&gt;</code> and <code>is</code>, respectively. </p><p>See <a href="#id-node-comparisons"><b>4.10.3 GNode Comparisons</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2202">2202&nbsp;</a></p><p>The type <code>schema-element(N)</code> is now defined to be a subtype of <code>element()</code> and of various other element tests.</p><p>See <a href="#id-item-subtype-elements"><b>3.3.2.5.3 Subtyping Nodes: Elements</b></a></p><p>The type <code>schema-attribute(N)</code> is now defined to be a subtype of <code>attribute()</code> and of various other attribute tests.</p><p>See <a href="#id-item-subtype-attributes"><b>3.3.2.5.4 Subtyping Nodes: Attributes</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2213">2213&nbsp;</a></p><p>This section (“External Resources and Security”) is new.</p><p>See <a href="#id-security-resources"><b>2.3 External Resources and Security</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2218">2218&nbsp;</a></p><p> The rules for value comparisons when comparing values of different types (for example, decimal and double) have changed to be transitive. A decimal value is no longer converted to double, instead the double is converted to a decimal without loss of precision. This may affect compatibility in edge cases involving comparison of values that are numerically very close. </p><p>See <a href="#id-value-comparisons"><b>4.10.1 Value Comparisons</b></a></p><p>The rules for comparing untyped atomic items with numeric values have changed. Rather than converting an untyped atomic item unconditionally to <code>xs:double</code>, it is now converted to the type of the numeric operand. This is designed to ensure that comparisons such as <code>&lt;a&gt;1.1&lt;/a&gt; = 1.1</code> succeed, given that the values will now be compared as decimals rather than as doubles.</p><p>See <a href="#id-general-comparisons"><b>4.10.2 General Comparisons</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2227">2227&nbsp;</a></p><p>A <code>URIQualifiedName</code> may now supply a prefix as well as a URI and local name.</p><p>See <a href="#id-namespaces-and-qnames"><b>2.1.4 Namespaces and QNames</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2236">2236&nbsp;</a></p><p> In the absence of a default namespace declaration, a user-defined function whose name is given as an unprefixed QName is now in no namespace. In previous versions of the language, this would generally be an error. </p><p>See <a href="#id-function-names"><b>5.18.2 Function Names</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2256">2256&nbsp;</a></p><p> An ordering is now defined for all data types. </p><p>See <a href="#id-value-comparisons"><b>4.10.1 Value Comparisons</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2259">2259&nbsp;</a></p><p> A new parameter <code>canonical</code> is available to give control over serialization of XML, XHTML, and JSON. </p><p>See <a href="#id-output-declarations"><b>5.22 Output Declarations</b></a></p></li></ol></div></div><script src="js/toc.js"></script><script src="/js/scroll.js"></script></body></html>