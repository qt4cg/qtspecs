<!DOCTYPE HTML><html xmlns="http://www.w3.org/1999/xhtml" lang="EN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>XML Path Language (XPath) 4.0 WG Review Draft</title><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link rel="stylesheet" type="text/css" href="css/w3c-base.css"><link rel="stylesheet" href="css/qtspecs.css"><link rel="stylesheet" href="css/xpath-40.css"><style type="text/css">
          body { margin-top: 50px }
          a.button { background: #DDD; border: 2px outset black; padding: 2px; margin: 2px; font-family: sans-serif; font-size: small;}
          a.button:hover { cursor:pointer; }
          a.button:active { border-style: inset; }
        </style><link rel="stylesheet" href="/css/autodiff.css"></head><body class="toc-inline"><div style="position:fixed; clear:both; top:0px" id="_autodiff_buttons"><p><a class="button" onclick="view('old')">
              View Old
            </a><a class="button" onclick="view('new')">
              View New
            </a><a class="button" onclick="view('both')">
              View Both
            </a><a class="button" onclick="view('only')">
              View Only
            </a><a class="button" onclick="scroll_to('prev')">
              Previous
            </a><a class="button" onclick="scroll_to('next')">
              Next
            </a><span id="__autodiff__"></span></p><p>This draft contains only sections that have differences from the version that it modified.</p></div><div class="head"><p><a href="https://www.w3.org/"><img src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C" alt="W3C" height="48" width="72"></a></p><h1><a id="title"></a>XML Path Language (XPath) 4.0 WG Review Draft</h1><h2><a id="w3c-doctype"></a>W3C Editor's Draft <span class="deltaxml-old" style="background:#FF5555">30&nbsp;January</span><span class="deltaxml-new" style="background:#90EE90">2&nbsp;February</span>&nbsp;2026</h2><dl><dt>This version:</dt><dd><a href="https://qt4cg.org/specifications/xpath-40/">https://qt4cg.org/specifications/xpath-40/</a></dd><dt>Most recent version of XPath:</dt><dd><a href="https://qt4cg.org/specifications/xpath-40/">https://qt4cg.org/specifications/xpath-40/</a></dd><dt>Most recent Recommendation of XPath:</dt><dd><a href="https://www.w3.org/TR/2017/REC-xpath-31-20170321/">https://www.w3.org/TR/2017/REC-xpath-31-20170321/</a></dd><dt>Editor:</dt><dd>Michael Kay, Saxonica <a href="http://www.saxonica.com/">&lt;http://www.saxonica.com/&gt;</a></dd></dl><p>This document is also available in these non-normative formats: <a href="xpath-40.xml">XML</a>.</p><p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;©&nbsp;2000&nbsp;<a href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="https://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="https://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="https://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p><hr></div><div><h2><a id="abstract"></a>Abstract</h2><p class="xpath"> XPath 4.0 is an expression language that allows the processing of values conforming to the data model defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>. The name of the language derives from its most distinctive feature, the path expression, which provides a means of hierarchic addressing of the nodes in an XML tree. As well as modeling the tree structure of XML, the data model also includes atomic items, function items, maps, arrays, and sequences. This version of XPath supports JSON as well as XML, and adds many new functions in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>.</p><p class="xpath">XPath 4.0 is a superset of XPath 3.1. A detailed list of changes made since XPath 3.1 can be found in <a href="#id-revision-log"><b>I Change Log</b></a>. </p></div><div><h2><a id="status"></a>Status of this Document</h2><p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document.</em></p><p>This document is a working draft developed and maintained by a W3C Community Group, the <a href="https://www.w3.org/community/xslt-40/">XQuery and XSLT Extensions Community Group</a> unofficially known as QT4CG (where "QT" denotes Query and Transformation). This draft is work in progress and should not be considered either stable or complete. Standard W3C copyright and patent conditions apply.</p><p>The community group welcomes comments on the specification. Comments are best submitted as issues on the group's <a href="https://github.com/qt4cg/qtspecs/issues">GitHub repository</a>.</p><p id="at-risk">As the Community Group moves towards publishing dated, stable drafts, some features that the group thinks may likely be removed or substantially changed are marked “at risk” in their changes section. In this draft:</p><ul><li><a href="#id-filter-maps-and-arrays">Filter Expressions for Maps and Arrays</a></li></ul><p>The community group maintains two extensive test suites, one oriented to XQuery and XPath, the other to XSLT. These can be found at <a href="https://github.com/qt4cg/qt4tests">qt4tests</a> and <a href="https://github.com/qt4cg/xslt40-test">xslt40-test</a> respectively. New tests, or suggestions for correcting existing tests, are welcome. The test suites include extensive metadata describing the conditions for applicability of each test case as well as the expected results. They do not include any test drivers for executing the tests: each implementation is expected to provide its own test driver.</p><div class="dedication" id="dedication"><h3>Dedication</h3><p class="xpath">The publications of this community group are dedicated to our co-chair, Michael Sperberg-McQueen&nbsp;(1954–2024).</p><p class="xpath">Michael was central to the development of XML and many related technologies. He brought a polymathic breadth of knowledge and experience to everything he did. This, combined with his indefatigable curiosity and appetite for learning, made him an invaluable contributor to our project, along with many others. We have lost a brilliant thinker, a patient teacher, and a loyal friend.</p></div></div><hr><div class="body"><div class="_diffs div1"><h2><a id="id-basics"></a>2 <a href="#id-basics" style="text-decoration: none">Basics</a></h2><div class="_diffs div2"><h3><a id="id-terminology"></a>2.1 <a href="#id-terminology" style="text-decoration: none">Terminology</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-ebnf-introduction">next</a> | <a href="#id-introduction">previous</a>)</p><ol><li><p>The EBNF operators <code>++</code> and <code>**</code> have been introduced, for more concise representation of sequences using a character such as <code>","</code> as a separator. The notation is borrowed from Invisible XML.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1366">1366</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1498">1498</a>]</i></p></li></ol></div><p>The basic building block of XPath 4.0 is the <b>expression</b>, which is a string of <a href="#Unicode">[Unicode]</a> characters; the version of Unicode to be used is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The language provides several kinds of expressions which may be constructed from keywords, symbols, and operands. In general, the operands of an expression are other expressions. XPath 4.0 allows expressions to be nested with full generality. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>This specification contains no assumptions or requirements regarding the character set encoding of strings of <a href="#Unicode">[Unicode]</a> characters.</p></div><p>Like XML, XPath 4.0 is a case-sensitive language. Keywords in XPath 4.0 use lower-case characters and are not reserved—that is, names in XPath 4.0 expressions are allowed to be the same as language keywords, except for certain unprefixed function-names listed in <a href="#id-reserved-fn-names"><b>A.4 Reserved Function Names</b></a>.</p><p>In this specification the phrases <span class="verb">must</span>, <span class="verb">must not</span>, <span class="verb">should</span>, <span class="verb">should not</span>, <span class="verb">may</span>, <span class="verb">required</span>, and <span class="verb">recommended</span>, when used in normative text and rendered in small capitals, are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p><p>Certain aspects of language processing are described in this specification as <b>implementation-defined</b> or <b>implementation-dependent</b>.</p><ul><li><p> [<a id="dt-implementation-defined" title="implementation defined">Definition</a>: <b>Implementation-defined</b> indicates an aspect that may differ between implementations, but must be specified by the implementer for each particular implementation.] </p></li><li><p> [<a id="dt-implementation-dependent" title="implementation   dependent">Definition</a>: <b>Implementation-dependent</b> indicates an aspect that may differ between implementations, is not specified by this or any W3C specification, and is not required to be specified by the implementer for any particular implementation.] </p></li></ul><p class="xpath">A language aspect described in this specification as <b>implementation-defined</b> or <b>implementation dependent</b> may be further constrained by the specifications of a host language in which XPath is embedded.</p><div class="_diffs div3"><h4><a id="id-values"></a>2.1.3 <a href="#id-values" style="text-decoration: none">Values</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-namespaces-and-qnames">next</a> | <a href="#id-expression-names">previous</a>)</p><ol><li><p> The term <b>atomic value</b> has been replaced by <a title="atomic item" class="termref" href="#dt-atomic-item">atomic item</a>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1337">1337</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1361">1361</a>&nbsp;2 August 2024]</i></p></li><li><p> The terms <b>XNode</b> and <code>JNode</code> are introduced; the existing term <b>node</b> remains in use as a synonym for <b>XNode</b> where the context does not specify otherwise. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2025">2025</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2031">2031</a>&nbsp;13 June 2025]</i></p></li></ol></div><p> [<a id="dt-value" title="value">Definition</a>: In the <a title="data model" class="termref" href="#dt-datamodel">data model</a>, a <b>value</b> is always a <a title="sequence" class="termref" href="#dt-sequence">sequence</a>.] </p><p> [<a id="dt-sequence" title="sequence">Definition</a>: A <b>sequence</b> is an ordered collection of zero or more <a title="item" class="termref" href="#dt-item">items</a>.] </p><p> [<a id="dt-item" title="item">Definition</a>: An <b>item</b> is either an <a title="atomic item" class="termref" href="#dt-atomic-item">atomic item</a>, a <a title="node" class="termref" href="#dt-node">node</a>, or a <a title="function item" class="termref" href="#dt-function-item">function item</a>.] </p><p> [<a id="dt-atomic-item" title="atomic item">Definition</a>: An <b>atomic item</b> is a value in the value space of an <b>atomic type</b>, as defined in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.] </p><p> [<a id="dt-XNode" title="XNode">Definition</a>: An <b>XNode</b> is an instance of one of the <b>node kinds</b> defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#nodes">7.1 XML Nodes</a>.] Each XNode has a unique <b>node identity</b>, a <b>typed value</b>, and a <b>string value</b>. In addition, some XNodes have a <b>name</b>. The <b>typed value</b> of an XNode is a sequence of zero or more atomic items. The <b>string value</b> of an XNode is a value of type <code>xs:string</code>. The <b>name</b> of an XNode is a value of type <code>xs:QName</code>.</p><p> [<a id="dt-node" title="node">Definition</a>: Except where the context indicates otherwise, the term <b>node</b> is used as a synonym for <a title="XNode" class="termref" href="#dt-XNode">XNode</a>.] </p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-JNode" title="JNode"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">JNode</span></b><span class="deltaxml-new" style="background:#90EE90"> (see also </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XDM 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> section </span><a href="../xpath-datamodel-40/#id-JNodes"><span class="deltaxml-new" style="background:#90EE90">8.4 JNodes</span></a><span class="deltaxml-new" style="background:#90EE90">) is an encapsulation of a value as it appears within a tree of maps and arrays, typically (but not necessarily) obtained by parsing JSON texts.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-GNode" title="GNode"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: A </span><b><span class="deltaxml-new" style="background:#90EE90">GNode</span></b><span class="deltaxml-new" style="background:#90EE90"> (for </span><em><span class="deltaxml-new" style="background:#90EE90">generalized node</span></em><span class="deltaxml-new" style="background:#90EE90">) is either an </span><a title="XNode" class="termref" href="#dt-XNode"><span class="deltaxml-new" style="background:#90EE90">XNode</span></a><span class="deltaxml-new" style="background:#90EE90"> or a </span><a title="JNode" class="termref" href="#dt-JNode"><span class="deltaxml-new" style="background:#90EE90">JNode</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p><p> [<a id="dt-function-item" title="function item">Definition</a>: A <b>function item</b> is an item that can be called using a <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a>.] </p><p>Maps (see <a href="#id-maps"><b>4.14.1 Maps</b></a>) and arrays (see <a href="#id-arrays"><b>4.14.2 Arrays</b></a>) are specific kinds of <a title="function item" class="termref" href="#dt-function-item">function item</a>s.</p><p><span style="display: none;" class="delete_version"> [<a id="dt-singleton" title="singleton">Definition</a>: A sequence containing exactly one item is called a <b>singleton</b>.] An item is identical to a singleton sequence containing that item. Sequences are never nested—for example, combining the values 1, (2, 3), and ( ) into a single sequence results in the sequence (1, 2, 3). [<a id="dt-empty-sequence" title="empty sequence">Definition</a>: A sequence containing zero items is called an <b>empty sequence</b>.] </span><span style="display: none;" class="add_version"> [<a id="dt-singleton" title="singleton">Definition</a>: A sequence containing exactly one item is called a <b>singleton</b>.] An item is identical to a singleton sequence containing that item. Sequences are never nested—for example, combining the values 1, (2, 3), and ( ) into a single sequence results in the sequence (1, 2, 3). [<a id="dt-empty-sequence" title="empty sequence">Definition</a>: The sequence containing zero items is called the <b>empty sequence</b>.] </span><span class="modify_version"> [<a id="dt-singleton" title="singleton">Definition</a>: A sequence containing exactly one item is called a <b>singleton</b>.] An item is identical to a singleton sequence containing that item. Sequences are never nested—for example, combining the values 1, (2, 3), and ( ) into a single sequence results in the sequence (1, 2, 3). [<a id="dt-empty-sequence" title="empty sequence">Definition</a>: <span class="deltaxml-old" style="background:#FF5555">A</span><span class="deltaxml-new" style="background:#90EE90">The</span> sequence containing zero items is called <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> <b>empty sequence</b>.] </span></p><p> [<a id="dt-data-model-instance" title="XDM instance">Definition</a>: The term <b>XDM instance</b> is used, synonymously with the term <a title="value" class="termref" href="#dt-value">value</a>, to denote an unconstrained <a title="sequence" class="termref" href="#dt-sequence">sequence</a> of <a title="item" class="termref" href="#dt-item">items</a>.] </p></div></div><div class="_diffs div2"><h3><a id="id-security-resources"></a>2.3 <a href="#id-security-resources" style="text-decoration: none">External Resources and Security</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-processing-model">next</a> | <a href="#eval_context">previous</a>)</p><ol><li><p>This section (“External Resources and Security”) is new.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2047">2047</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2213">2213</a>&nbsp;23 October 2025]</i></p></li></ol></div><p>The XPath, XQuery, and XSLT languages provide a number of capabilities to access external resources. These include:</p><ul><li><p>Functions such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc-available"><code>doc-available</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-unparsed-text"><code>unparsed-text</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-unparsed-text-lines"><code>unparsed-text-lines</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-unparsed-text-available"><code>unparsed-text-available</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-uri-collection"><code>uri-collection</code></a>, and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-unparsed-binary"><code>unparsed-binary</code></a>, and in XSLT, the <code>document</code> function and the <code>xsl:source-document</code> and <code>xsl:merge</code> instructions.</p></li><li><p>Static inclusion of code using <code>import module</code> in XQuery, or <code>xsl:include</code>, <code>xsl:import</code>, and <code>xsl:use-package</code> in XSLT.</p></li><li><p>Dynamic inclusion and execution of external code using the functions <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-transform"><code>transform</code></a> and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-load-xquery-module"><code>load-xquery-module</code></a>, and in XSLT, the <code>xsl:evaluate</code> instruction.</p></li><li><p>The ability to write to external resources using the <code>xsl:result-document</code> instruction in XSLT, or the <code>put</code> function in the XQuery Update Facility.</p></li><li><p>The ability to invoke arbitrary user-defined external functions (called extension functions in XSLT).</p></li><li><p>The ability to invoke vendor-defined external/extension functions; a notable example being the EXPath File library.</p></li><li><p>Access to environment variables and system properties using functions such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-environment-variable"><code>environment-variable</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-available-environment-variables"><code>available-environment-variables</code></a>, and (in XSLT) <code>system-property</code>.</p></li><li><p>Static inclusion of XSD schemas and schema documents using <code>import schema</code>in XQuery or <code>xsl:import-schema</code> in XSLT, or indirectly using <code>xs:import</code>, <code>xs:include</code>, <code>xs:redefine</code>, or <code>xs:override</code> in XSD schema documents.</p></li><li><p>Dynamic loading of XSD schema documents (directly or indirectly) using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-xsd-validator"><code>xsd-validator</code></a> function.</p></li><li><p>The ability to parse XML or HTML documents that contain references to external entities, for example by using the <code>parse-xml</code> and <code>parse-html</code> functions.</p></li><li><p>The ability to parse XML documents in a way that causes other external resources to be fetched, for example by activating XInclude, or by performing XSD validation using <code>xsi:schema-location</code>.</p></li><li><p>Implicit access to third-party libraries supporting (for example) collations or localization.</p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">External resources are always referenced by means of a URI. The way in which a URI is dereferenced to obtain a resource is </span><a title="implementation defined" class="termref" href="#dt-implementation-defined"><span class="deltaxml-new" style="background:#90EE90">implementation defined</span></a><span class="deltaxml-new" style="background:#90EE90">. It is </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">recommended</span></span><span class="deltaxml-new" style="background:#90EE90"> that popular URI schemes such as </span><code><span class="deltaxml-new" style="background:#90EE90">http</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">https</span></code><span class="deltaxml-new" style="background:#90EE90">, and </span><code><span class="deltaxml-new" style="background:#90EE90">file</span></code><span class="deltaxml-new" style="background:#90EE90"> should be supported, but this </span><span class="verb"><span class="deltaxml-new" style="background:#90EE90">may</span></span><span class="deltaxml-new" style="background:#90EE90"> be subject to user configuration and security constraints. Implementations are free to support indirection mechanisms such as catalogs and resolver callbacks, as well as supporting additional URI schemes and protocols, whether standardized or not.</span></p><p> [<a id="dt-trusted" title="trusted">Definition</a>: The static context includes a boolean property called <b>trusted</b> that determines whether external resources are available.] This may take the following values:</p><ol class="enumar"><li><p><b>false</b>: No external resources are available other than resources explicitly made available by the caller through some trusted implementation-defined mechanism.</p><p> [<a id="dt-untrusted" title="untrusted">Definition</a>: ]Code executing with <a title="trusted" class="termref" href="#dt-trusted">trusted</a> set to <code>false</code> is said to be <b>untrusted</b>. </p></li><li><p><b>true</b>: Trusted code has access to all the resources available to its immediate caller.</p></li></ol><p>The functions <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-transform"><code>transform</code></a> and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-load-xquery-module"><code>load-xquery-module</code></a>, and the XSLT instruction <code>xsl:evaluate</code>, have an option allowing the trust level of the executed code to be set:</p><ol class="enumar"><li><p>If <code>trusted</code> is set to <code>true</code>, the invoked code executes with the same trust level as its caller.</p></li><li><p>If <code>trusted</code> is set to <code>false</code>, the invoked code is not able to access any external resources other than resources explicitly made available using an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation defined</a> mechanism under the control of the caller.</p></li></ol><p>Some resources, such as XML documents, may themselves contain references to other resources. For example, an XML document may reference external entities (including an external DTD). External entity expansion is recognized as a known security risk. Functions that invoke XML parsing (such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-parse-xml"><code>parse-xml</code></a>, <code>doc</code>, or <code>collection</code>) therefore have a <code>trusted</code> option indicating whether the document being parsed is trusted to access external entities. Such access is allowed only if (a) the <code>trusted</code> option is set to <code>true</code>, or (b) access to the external entity in question is explicitly enabled by the caller.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The term <b>explicitly enabled</b> is not intended to mean that every resource to which access is permitted must be individually listed. The mechanism for enabling access might provide access to a class of resources (for example, all resources accessible using the HTTPS protocol, or all resources within the containing XML database having particular access permissions). The mechanism might also take account of other criteria, for example it might impose limits on the size or other characteristics of the resources accessed.</p></div><p>It is <span class="verb">recommended</span> that any external API used to invoke XPath, XQuery, or XSLT processing should similarly offer the ability to indicate whether the code being executed is <a title="trusted" class="termref" href="#dt-trusted">trusted</a>.</p><p>In the interests of security, the default for these options is <b>false</b>. However, for backwards compatibility reasons, processors <span class="verb">may</span> provide an option whereby a trusted user can change the default.</p><p>In general, when an application requests access to an external resource which is not available because the application is untrusted, the processor <span class="verb">should</span> behave in the same way as if the resource did not exist. However, the processor <span class="verb">may</span> choose to disclose in its diagnostics why the request was unsuccessful.</p><p>A processor <span class="verb">may</span> (but is not <span class="verb">required</span> to) limit an application’s consumption of resources such as CPU cycles and memory when the application is untrusted.</p><p> [<a id="dt-available-docs" title="available documents">Definition</a>: The term <b>available documents</b> refers (TODO: for the time being) to the set of XML documents that an application is able to access by URI.] </p></div><div class="_diffs div2"><h3><a id="id-processing-model"></a>2.4 <a href="#id-processing-model" style="text-decoration: none">Processing Model</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-guarded-expressions">next</a> | <a href="#id-security-resources">previous</a>)</p><ol><li><p> The static typing option has been dropped. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1343">1343</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1344">1344</a>&nbsp;3 September 2024]</i></p></li></ol></div><p>The semantics of XPath 4.0 are defined in terms of the <a title="data model" class="termref" href="#dt-datamodel">data model</a> and the <a title="expression context" class="termref" href="#dt-expression-context">expression context</a>.</p><div class="svg-image"><svg xmlns="http://www.w3.org/2000/svg" width="592pt" height="667pt" viewBox="0.00 0.00 591.62 666.50" preserveAspectRatio="xMidYMid meet" zoomAndPan="magnify" version="1.1" contentscripttype="text/ecmascript" contentstyletype="text/css"><g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 662.5)"><title>Processing_Model</title><g id="a_graph0"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="XPath Processing Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="white" stroke="none" points="-4,4 -4,-662.5 587.62,-662.5 587.62,4 -4,4"/></a></g><g id="clust1" class="cluster"><title>clusterQT4</title><g id="a_clust1"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="XPath Expression Processing" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="none" stroke="black" points="260,-80.5 260,-575 488,-575 488,-80.5 260,-80.5"/><text text-anchor="middle" x="374" y="-557.7" font-family="Times,serif" font-size="14.00">XPath Expression Processing</text></a></g></g><g id="clust2" class="cluster"><title>clusterEP</title><g id="a_clust2"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="External processing" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="none" stroke="black" points="8,-174 8,-349 252,-349 252,-174 8,-174"/><text text-anchor="middle" x="130" y="-331.7" font-family="Times,serif" font-size="14.00">External processing</text></a></g></g><g id="node1" class="node"><title>Exec</title><g id="a_node1"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="Execution Engine" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M332.38,-223C332.38,-223 285.62,-223 285.62,-223 279.62,-223 273.62,-217 273.62,-211 273.62,-211 273.62,-194 273.62,-194 273.62,-188 279.62,-182 285.62,-182 285.62,-182 332.38,-182 332.38,-182 338.38,-182 344.38,-188 344.38,-194 344.38,-194 344.38,-211 344.38,-211 344.38,-217 338.38,-223 332.38,-223"/><text text-anchor="middle" x="309" y="-205.7" font-family="Times,serif" font-size="14.00">Execution</text><text text-anchor="middle" x="309" y="-189.2" font-family="Times,serif" font-size="14.00">Engine</text></a></g></g><g id="node2" class="node"><title>XDM</title><g id="a_node2"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#dt-data-model-instance" xlink:title="XPath Data Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="none" stroke="black" points="347.5,-129.5 268.5,-129.5 268.5,-88.5 347.5,-88.5 347.5,-129.5"/><text text-anchor="middle" x="308" y="-112.2" font-family="Times,serif" font-size="14.00" fill="blue">XPath Data</text><text text-anchor="middle" x="308" y="-95.7" font-family="Times,serif" font-size="14.00" fill="blue">Model</text></a></g></g><g id="edge8" class="edge"><title>Exec-&gt;XDM</title><g id="a_edge8"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title=" DQ4" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M308.66,-170.46C308.56,-161.01 308.44,-150.62 308.34,-141.16"/><polygon fill="black" stroke="black" points="305.16,-170.17 308.77,-180.13 312.16,-170.09 305.16,-170.17"/><polygon fill="black" stroke="black" points="311.84,-141.29 308.23,-131.33 304.84,-141.37 311.84,-141.29"/></a></g><g id="a_edge8-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title="Access and create" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="323.59" y="-150.7" font-family="Times,serif" font-size="14.00" fill="blue"> DQ4</text></a></g></g><g id="node15" class="node"><title>Serialize</title><polygon fill="none" stroke="black" points="333.62,-36 276.38,-36 276.38,0 339.62,0 339.62,-30 333.62,-36"/><polyline fill="none" stroke="black" points="333.62,-36 333.62,-30"/><polyline fill="none" stroke="black" points="339.62,-30 333.62,-30"/><text text-anchor="middle" x="308" y="-12.95" font-family="Times,serif" font-size="14.00">Serialize</text></g><g id="edge17" class="edge"><title>XDM-&gt;Serialize</title><g id="a_edge17"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#id-serialization" xlink:title=" DM4" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M308,-88.25C308,-76.33 308,-60.94 308,-47.69"/><polygon fill="black" stroke="black" points="311.5,-47.81 308,-37.81 304.5,-47.81 311.5,-47.81"/></a></g><g id="a_edge17-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#id-serialization" xlink:title="Serialize" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="324.5" y="-57.2" font-family="Times,serif" font-size="14.00" fill="blue"> DM4</text></a></g></g><g id="node3" class="node"><title>AST</title><g id="a_node3"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ5" xlink:title="Abstract Syntax Tree (AST)" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M337.62,-316.5C337.62,-316.5 280.38,-316.5 280.38,-316.5 274.38,-316.5 268.38,-310.5 268.38,-304.5 268.38,-304.5 268.38,-287.5 268.38,-287.5 268.38,-281.5 274.38,-275.5 280.38,-275.5 280.38,-275.5 337.62,-275.5 337.62,-275.5 343.62,-275.5 349.62,-281.5 349.62,-287.5 349.62,-287.5 349.62,-304.5 349.62,-304.5 349.62,-310.5 343.62,-316.5 337.62,-316.5"/><text text-anchor="middle" x="309" y="-299.2" font-family="Times,serif" font-size="14.00" fill="blue">Abstract</text><text text-anchor="middle" x="309" y="-282.7" font-family="Times,serif" font-size="14.00" fill="blue">Syntax Tree</text></a></g></g><g id="edge3" class="edge"><title>AST-&gt;Exec</title><g id="a_edge3"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title=" DQ1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M309,-275.15C309,-263.28 309,-247.94 309,-234.5"/><polygon fill="black" stroke="black" points="312.5,-234.83 309,-224.83 305.5,-234.83 312.5,-234.83"/></a></g><g id="a_edge3-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title="Access AST" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="324" y="-244.2" font-family="Times,serif" font-size="14.00" fill="blue"> DQ1</text></a></g></g><g id="edge2" class="edge"><title>AST-&gt;AST</title><g id="a_edge2"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ5" xlink:title=" SQ5" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M350.09,-304.63C360.14,-303.99 367.62,-301.11 367.62,-296 367.62,-293.12 365.26,-290.96 361.4,-289.49"/><polygon fill="black" stroke="black" points="362.05,-286.06 351.58,-287.65 360.76,-292.94 362.05,-286.06"/></a></g><g id="a_edge2-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ5" xlink:title="Normalize" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="381.5" y="-290.95" font-family="Times,serif" font-size="14.00" fill="blue"> SQ5</text></a></g></g><g id="node4" class="node"><title>Static</title><g id="a_node4"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#dt-static-context" xlink:title="Static Context" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="none" stroke="black" points="473.38,-432.5 418.62,-432.5 414.62,-428.5 414.62,-391.5 469.38,-391.5 473.38,-395.5 473.38,-432.5"/><polyline fill="none" stroke="black" points="469.38,-428.5 414.62,-428.5"/><polyline fill="none" stroke="black" points="469.38,-428.5 469.38,-391.5"/><polyline fill="none" stroke="black" points="469.38,-428.5 473.38,-432.5"/><text text-anchor="middle" x="444" y="-415.2" font-family="Times,serif" font-size="14.00" fill="blue">Static</text><text text-anchor="middle" x="444" y="-398.7" font-family="Times,serif" font-size="14.00" fill="blue">Context</text></a></g></g><g id="edge5" class="edge"><title>Static-&gt;AST</title><g id="a_edge5"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ1234" xlink:title=" SQ4" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M420.48,-391.14C398.42,-372.51 365.24,-344.49 340.81,-323.86"/><polygon fill="black" stroke="black" points="343.3,-321.38 333.4,-317.61 338.78,-326.73 343.3,-321.38"/></a></g><g id="a_edge5-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ1234" xlink:title="Resolve names" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="410.36" y="-360.2" font-family="Times,serif" font-size="14.00" fill="blue"> SQ4</text></a></g></g><g id="node5" class="node"><title>Dynamic</title><g id="a_node5"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#dt-dynamic-context" xlink:title="Dynamic Context" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="none" stroke="black" points="480.12,-316.5 417.88,-316.5 413.88,-312.5 413.88,-275.5 476.12,-275.5 480.12,-279.5 480.12,-316.5"/><polyline fill="none" stroke="black" points="476.12,-312.5 413.88,-312.5"/><polyline fill="none" stroke="black" points="476.12,-312.5 476.12,-275.5"/><polyline fill="none" stroke="black" points="476.12,-312.5 480.12,-316.5"/><text text-anchor="middle" x="447" y="-299.2" font-family="Times,serif" font-size="14.00" fill="blue">Dynamic</text><text text-anchor="middle" x="447" y="-282.7" font-family="Times,serif" font-size="14.00" fill="blue">Context</text></a></g></g><g id="edge6" class="edge"><title>Static-&gt;Dynamic</title><g id="a_edge6"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title=" DQ2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M444.52,-391.14C444.98,-373.73 445.65,-348.14 446.18,-328.03"/><polygon fill="black" stroke="black" points="449.68,-328.23 446.44,-318.14 442.68,-328.05 449.68,-328.23"/></a></g><g id="a_edge6-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title="Provide access" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="460.41" y="-360.2" font-family="Times,serif" font-size="14.00" fill="blue"> DQ2</text></a></g></g><g id="edge7" class="edge"><title>Dynamic-&gt;Exec</title><g id="a_edge7"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title=" DQ5" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M407.71,-268.95C389.08,-256.6 366.88,-241.88 348.26,-229.53"/><polygon fill="black" stroke="black" points="405.53,-271.7 415.79,-274.31 409.39,-265.87 405.53,-271.7"/><polygon fill="black" stroke="black" points="350.42,-226.76 340.15,-224.15 346.55,-232.59 350.42,-226.76"/></a></g><g id="a_edge7-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title="Access and change" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="405.36" y="-244.2" font-family="Times,serif" font-size="14.00" fill="blue"> DQ5</text></a></g></g><g id="node6" class="node"><title>Schema</title><g id="a_node6"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#dt-issd" xlink:title="In-Scope Schema Definitions" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="none" stroke="black" points="478.38,-542.5 401.62,-542.5 401.62,-485 478.38,-485 478.38,-542.5"/><text text-anchor="middle" x="440" y="-525.2" font-family="Times,serif" font-size="14.00" fill="blue">In-Scope</text><text text-anchor="middle" x="440" y="-508.7" font-family="Times,serif" font-size="14.00" fill="blue">Schema</text><text text-anchor="middle" x="440" y="-492.2" font-family="Times,serif" font-size="14.00" fill="blue">Definitions</text></a></g></g><g id="edge4" class="edge"><title>Schema-&gt;Static</title><path fill="none" stroke="black" d="M441.12,-484.7C441.63,-472.08 442.23,-457.14 442.75,-444.17"/><polygon fill="black" stroke="black" points="446.24,-444.59 443.14,-434.46 439.24,-444.31 446.24,-444.59"/></g><g id="node7" class="node"><title>XPath</title><path fill="none" stroke="black" d="M324,-430C324,-430 294,-430 294,-430 288,-430 282,-424 282,-418 282,-418 282,-406 282,-406 282,-400 288,-394 294,-394 294,-394 324,-394 324,-394 330,-394 336,-400 336,-406 336,-406 336,-418 336,-418 336,-424 330,-430 324,-430"/><text text-anchor="middle" x="309" y="-406.95" font-family="Times,serif" font-size="14.00">XPath</text></g><g id="edge1" class="edge"><title>XPath-&gt;AST</title><g id="a_edge1"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ1234" xlink:title=" SQ1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M309,-393.69C309,-376.32 309,-349.19 309,-328.09"/><polygon fill="black" stroke="black" points="312.5,-328.29 309,-318.29 305.5,-328.29 312.5,-328.29"/></a></g><g id="a_edge1-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ1234" xlink:title="Parse expression" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="322.88" y="-360.2" font-family="Times,serif" font-size="14.00" fill="blue"> SQ1</text></a></g></g><g id="node8" class="node"><title>XML</title><polygon fill="none" stroke="black" points="64,-314 16,-314 16,-278 70,-278 70,-308 64,-314"/><polyline fill="none" stroke="black" points="64,-314 64,-308"/><polyline fill="none" stroke="black" points="70,-308 64,-308"/><text text-anchor="middle" x="43" y="-290.95" font-family="Times,serif" font-size="14.00">XML</text></g><g id="node10" class="node"><title>PSVI</title><g id="a_node10"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#id-data-model-generation" xlink:title="Infoset/PSVI" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="none" stroke="black" points="84.62,-223 33.38,-223 33.38,-182 90.62,-182 90.62,-217 84.62,-223"/><polyline fill="none" stroke="black" points="84.62,-223 84.62,-217"/><polyline fill="none" stroke="black" points="90.62,-217 84.62,-217"/><text text-anchor="middle" x="62" y="-205.7" font-family="Times,serif" font-size="14.00" fill="blue">Infoset/</text><text text-anchor="middle" x="62" y="-189.2" font-family="Times,serif" font-size="14.00" fill="blue">PSVI</text></a></g></g><g id="edge9" class="edge"><title>XML-&gt;PSVI</title><g id="a_edge9"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DM1" xlink:title=" DM1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M46.57,-277.79C49.12,-265.54 52.61,-248.73 55.62,-234.21"/><polygon fill="black" stroke="black" points="59,-235.16 57.61,-224.66 52.15,-233.74 59,-235.16"/></a></g><g id="a_edge9-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DM1" xlink:title="Parse and optionally validate" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="70.7" y="-244.2" font-family="Times,serif" font-size="14.00" fill="blue"> DM1</text></a></g></g><g id="node9" class="node"><title>JSON</title><polygon fill="none" stroke="black" points="136,-314 88,-314 88,-278 142,-278 142,-308 136,-314"/><polyline fill="none" stroke="black" points="136,-314 136,-308"/><polyline fill="none" stroke="black" points="142,-308 136,-308"/><text text-anchor="middle" x="115" y="-290.95" font-family="Times,serif" font-size="14.00">JSON</text></g><g id="edge10" class="edge"><title>JSON-&gt;XDM</title><g id="a_edge10"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DM2" xlink:title=" DM2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M119.66,-277.61C127.32,-251.97 144.81,-203.83 175,-174 197.93,-151.34 230.44,-135.5 257.58,-125.24"/><polygon fill="black" stroke="black" points="258.43,-128.66 266.64,-121.96 256.05,-122.07 258.43,-128.66"/></a></g><g id="a_edge10-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DM2" xlink:title="Generate Data Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="191.5" y="-197.45" font-family="Times,serif" font-size="14.00" fill="blue"> DM2</text></a></g></g><g id="edge11" class="edge"><title>PSVI-&gt;XDM</title><g id="a_edge11"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DM2" xlink:title=" DM2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M64.37,-181.68C66.83,-170 71.82,-155.9 82,-147.5 108.02,-126.01 198.84,-116.54 257.12,-112.59"/><polygon fill="black" stroke="black" points="257.05,-116.1 266.81,-111.97 256.61,-109.11 257.05,-116.1"/></a></g><g id="a_edge11-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DM2" xlink:title="Generate Data Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="98.5" y="-150.7" font-family="Times,serif" font-size="14.00" fill="blue"> DM2</text></a></g></g><g id="node11" class="node"><title>Direct</title><g id="a_node11"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="Other/Direct Generation" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M232.12,-316.5C232.12,-316.5 171.88,-316.5 171.88,-316.5 165.88,-316.5 159.88,-310.5 159.88,-304.5 159.88,-304.5 159.88,-287.5 159.88,-287.5 159.88,-281.5 165.88,-275.5 171.88,-275.5 171.88,-275.5 232.12,-275.5 232.12,-275.5 238.12,-275.5 244.12,-281.5 244.12,-287.5 244.12,-287.5 244.12,-304.5 244.12,-304.5 244.12,-310.5 238.12,-316.5 232.12,-316.5"/><text text-anchor="middle" x="202" y="-299.2" font-family="Times,serif" font-size="14.00">Other/Direct</text><text text-anchor="middle" x="202" y="-282.7" font-family="Times,serif" font-size="14.00">Generation</text></a></g></g><g id="edge12" class="edge"><title>Direct-&gt;XDM</title><g id="a_edge12"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DM3" xlink:title=" DM3" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M203.17,-275.11C205.47,-249.87 212.21,-205.78 232,-174 240.96,-159.6 254.25,-146.83 267.22,-136.55"/><polygon fill="black" stroke="black" points="269.02,-139.58 274.88,-130.75 264.8,-133.99 269.02,-139.58"/></a></g><g id="a_edge12-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DM3" xlink:title="Other/Direct Generation" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="248.5" y="-197.45" font-family="Times,serif" font-size="14.00" fill="blue"> DM3</text></a></g></g><g id="node12" class="node"><title>XSD</title><g id="a_node12"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="XML Schema" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><polygon fill="none" stroke="black" points="418.75,-658.5 365.25,-658.5 365.25,-617.5 424.75,-617.5 424.75,-652.5 418.75,-658.5"/><polyline fill="none" stroke="black" points="418.75,-658.5 418.75,-652.5"/><polyline fill="none" stroke="black" points="424.75,-652.5 418.75,-652.5"/><text text-anchor="middle" x="395" y="-641.2" font-family="Times,serif" font-size="14.00">XML</text><text text-anchor="middle" x="395" y="-624.7" font-family="Times,serif" font-size="14.00">Schema</text></a></g></g><g id="edge13" class="edge"><title>XSD-&gt;Schema</title><g id="a_edge13"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#id-schema-import-processing" xlink:title=" SI1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M402.33,-617.09C408.65,-599.92 417.96,-574.63 425.74,-553.49"/><polygon fill="black" stroke="black" points="428.96,-554.89 429.13,-544.29 422.39,-552.47 428.96,-554.89"/></a></g><g id="a_edge13-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#id-schema-import-processing" xlink:title="XML Schema Import" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="426.06" y="-586.2" font-family="Times,serif" font-size="14.00" fill="blue"> SI1</text></a></g></g><g id="node13" class="node"><title>DirectXSD</title><g id="a_node13"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="Other/Direct Generation" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M515.12,-658.5C515.12,-658.5 454.88,-658.5 454.88,-658.5 448.88,-658.5 442.88,-652.5 442.88,-646.5 442.88,-646.5 442.88,-629.5 442.88,-629.5 442.88,-623.5 448.88,-617.5 454.88,-617.5 454.88,-617.5 515.12,-617.5 515.12,-617.5 521.12,-617.5 527.12,-623.5 527.12,-629.5 527.12,-629.5 527.12,-646.5 527.12,-646.5 527.12,-652.5 521.12,-658.5 515.12,-658.5"/><text text-anchor="middle" x="485" y="-641.2" font-family="Times,serif" font-size="14.00">Other/Direct</text><text text-anchor="middle" x="485" y="-624.7" font-family="Times,serif" font-size="14.00">Generation</text></a></g></g><g id="edge14" class="edge"><title>DirectXSD-&gt;Schema</title><g id="a_edge14"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SI2" xlink:title=" SI2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M477.67,-617.09C471.35,-599.92 462.04,-574.63 454.26,-553.49"/><polygon fill="black" stroke="black" points="457.61,-552.47 450.87,-544.29 451.04,-554.89 457.61,-552.47"/></a></g><g id="a_edge14-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SI2" xlink:title="Other/Direct Generation" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="481.69" y="-586.2" font-family="Times,serif" font-size="14.00" fill="blue"> SI2</text></a></g></g><g id="node14" class="node"><title>Host</title><g id="a_node14"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:title="Host Environment" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M571.62,-534.25C571.62,-534.25 508.38,-534.25 508.38,-534.25 502.38,-534.25 496.38,-528.25 496.38,-522.25 496.38,-522.25 496.38,-505.25 496.38,-505.25 496.38,-499.25 502.38,-493.25 508.38,-493.25 508.38,-493.25 571.62,-493.25 571.62,-493.25 577.62,-493.25 583.62,-499.25 583.62,-505.25 583.62,-505.25 583.62,-522.25 583.62,-522.25 583.62,-528.25 577.62,-534.25 571.62,-534.25"/><text text-anchor="middle" x="540" y="-516.95" font-family="Times,serif" font-size="14.00">Host</text><text text-anchor="middle" x="540" y="-500.45" font-family="Times,serif" font-size="14.00">Environment</text></a></g></g><g id="edge15" class="edge"><title>Host-&gt;Static</title><g id="a_edge15"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ1234" xlink:title=" SQ2" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M505.43,-492.87C490.4,-483.73 474.92,-473.5 469.25,-467 463.24,-460.11 458.38,-451.55 454.58,-443.29"/><polygon fill="black" stroke="black" points="457.85,-442.05 450.78,-434.17 451.39,-444.74 457.85,-442.05"/></a></g><g id="a_edge15-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#SQ1234" xlink:title="Initialize from host environment" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="483.12" y="-453.7" font-family="Times,serif" font-size="14.00" fill="blue"> SQ2</text></a></g></g><g id="edge16" class="edge"><title>Host-&gt;Dynamic</title><g id="a_edge16"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title=" DQ3" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><path fill="none" stroke="black" d="M533.02,-492.77C522.38,-462.83 500.99,-404.74 479,-357 474.39,-347 468.9,-336.32 463.77,-326.79"/><polygon fill="black" stroke="black" points="467,-325.4 459.14,-318.31 460.86,-328.76 467,-325.4"/></a></g><g id="a_edge16-label"><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#DQ12345" xlink:title="Initialize from host environment" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest"><text text-anchor="middle" x="525.43" y="-406.95" font-family="Times,serif" font-size="14.00" fill="blue"> DQ3</text></a></g></g></g></svg></div><p>Figure 1: Processing Model Overview</p><p>Figure 1 provides a schematic overview of the processing steps that are discussed in detail below. Some of these steps are completely outside the domain of XPath 4.0; in Figure 1, these are depicted outside the line that represents the boundaries of the language, an area labeled <b>external processing</b>. The external processing domain includes generation of <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instances</a> that represent the data to be queried (see <a href="#id-data-model-generation"><b>2.4.1 Data Model Generation</b></a>), schema import processing (see <a href="#id-schema-import-processing"><b>2.4.2 Schema Import Processing</b></a>), and serialization. The area inside the boundaries of the language is known as the <span class="xpath"><b>XPath processing domain</b></span>, which includes the static analysis and dynamic evaluation phases (see <a href="#id-expression-processing"><b>2.4.3 Expression Processing</b></a>). Consistency constraints on the <span class="xpath">XPath</span> processing domain are defined in <a href="#id-consistency-constraints"><b>2.4.6 Consistency Constraints</b></a>.</p><div class="_diffs div3"><h4><a id="id-expression-processing"></a>2.4.3 <a href="#id-expression-processing" style="text-decoration: none">Expression Processing</a></h4><p>XPath 4.0 defines two phases of processing called the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a> and the <a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation">dynamic evaluation phase</a> (see Figure 1). During the static analysis phase, <a title="static error" class="termref" href="#dt-static-error">static errors</a>, <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a>, or <a title="type error" class="termref" href="#dt-type-error">type errors</a> may be raised. During the dynamic evaluation phase, only <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a> or <a title="type error" class="termref" href="#dt-type-error">type errors</a> may be raised. These kinds of errors are defined in <a href="#id-kinds-of-errors"><b>2.5.1 Kinds of Errors</b></a>. </p><p>Within each phase, an implementation is free to use any strategy or algorithm whose result conforms to the specifications in this document.</p><div class="_diffs div4"><h5><a id="id-static-analysis"></a>2.4.3.1 <a href="#id-static-analysis" style="text-decoration: none">Static Analysis Phase</a></h5><p> [<a id="dt-static-analysis" title="static analysis phase">Definition</a>: The <b>static analysis phase</b> depends on the expression itself and on the <a title="static context" class="termref" href="#dt-static-context">static context</a>. The <b>static analysis phase</b> does not depend on input data (other than schemas).] </p><p id="SQ1234">During the static analysis phase, the <span class="xpath">XPath expression</span> is typically parsed into an internal representation called the <b>operation tree</b> (step SQ1 in Figure 1). A parse error is raised as a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXPST0003" title="err:XPST0003">err:XPST0003</a>]. The <a title="static context" class="termref" href="#dt-static-context">static context</a> is initialized by the implementation (step SQ2). The <a title="static context" class="termref" href="#dt-static-context">static context</a> is used to resolve schema type names, function names, namespace prefixes, and variable names (step SQ4). If a name of one of these kinds in the <b>operation tree</b> is not found in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, a <a title="static error" class="termref" href="#dt-static-error">static error</a> ([<a href="#ERRXPST0008" title="err:XPST0008">err:XPST0008</a>] or [<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>]) is raised (however, see exceptions to this rule in <a href="#id-element-test"><b>3.2.7.2 Element Types</b></a> and <a href="#id-attribute-test"><b>3.2.7.3 Attribute Types</b></a>.)</p><p id="SQ5">The <b>operation tree</b> is then typically normalized by making explicit the implicit operations such as <a title="atomization" class="termref" href="#dt-atomization">atomization</a> and extraction of <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean values</a> (step SQ5).</p><p>During the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a>, a processor may perform type analysis. The effect of type analysis is to assign a <a title="static type" class="termref" href="#dt-static-type">static type</a> to each expression in the operation tree. [<a id="dt-static-type" title="static type">Definition</a>: The <b>static type</b> of an expression is the best inference that the processor is able to make statically about the type of the result of the expression.] This specification does not define the rules for type analysis nor the static types that are assigned to particular expressions: the only constraint is that the inferred type must match all possible values that the expression is capable of returning.</p><p>Examples of inferred static types might be:</p><ul><li><p>For the expression <code>concat(a,b)</code> the inferred static type is <code>xs:string</code></p></li><li><p>For the expression <code>$a = $v</code> the inferred static type is <code>xs:boolean</code></p></li><li><p><span style="display: none;" class="delete_version">For the expression <code>$s[exp]</code> the inferred static type has the same item type as the static type of <code>$s</code>, but a cardinality that allows the empty sequence even if the static type of <code>$s</code> does not allow an empty sequence.</span><span style="display: none;" class="add_version">For the expression <code>$s[exp]</code> the inferred static type has the same item type as the static type of <code>$s</code>, but a cardinality that allows the empty sequence even if the static type of <code>$s</code> does not allow the empty sequence.</span><span class="modify_version">For the expression <code>$s[exp]</code> the inferred static type has the same item type as the static type of <code>$s</code>, but a cardinality that allows the empty sequence even if the static type of <code>$s</code> does not allow <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p>The inferred static type of the expression <code>data($x)</code> (whether written explicitly or inserted into the operation tree in places where atomization is implicit) depends on the inferred static type of <code>$x</code>: for example, if <code>$x</code> has type <code>element(*, xs:integer)</code> then <code>data($x)</code> has static type <code>xs:integer</code>.</p></li></ul><p>In XQuery 1.0 and XPath 2.0, rules for static type inferencing were published normatively in <a href="#xquery-semantics">[XQuery 1.0 and XPath 2.0 Formal Semantics]</a>, but implementations were allowed to refine these rules to infer a more precise type where possible. In subsequent versions, the rules for static type inferencing are entirely implementation-dependent.</p><p>Every kind of expression also imposes requirements on the type of its operands. For example, with the expression <code>substring($a, $b, $c)</code>, <code>$a</code> must be of type <code>xs:string</code> (or something that can be converted to <code>xs:string</code> by the function calling rules), while <code>$b</code> and <code>$c</code> must be numeric.</p><p>A processor <span class="verb">may</span> raise a type error during static analysis if the inferred static type of an expression has no overlap (intersection) with the required type, and cannot be converted to the required type using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. For example, given the call <code>fn:upper-case($s)</code>, the processor <span class="verb">may</span> raise an error if the declared or inferred type of <code>$s</code> is <code>xs:integer</code>, but not if it is <code>xs:anyAtomicType</code>. </p><p>In addition, type analysis <span class="verb">may</span> conclude that an expression is <a title="implausible" class="termref" href="#dt-implausible">implausible</a>. Implausible expressions may be considered erroneous unless such checks have been disabled. For example, the expression <code>round(tokenize($input))</code> is implausible because the required type for <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-round"><code>fn:round</code></a> is <code>xs:numeric?</code>, while the static type of <code>tokenize($input)</code> is <code>xs:string*</code>, and these two sequence types are <a title="substantively disjoint" class="termref" href="#dt-substantively-disjoint">substantively disjoint</a>. This topic is described further in <a href="#id-implausible-expressions"><b>2.5.6 Implausible Expressions</b></a>.</p><p>Alternatively, the processor <span class="verb">may</span> defer all type checking until the dynamic evaluation phase.</p></div></div></div><div class="_diffs div2"><h3><a id="errors"></a>2.5 <a href="#errors" style="text-decoration: none">Error Handling</a></h3><div class="_diffs div3"><h4><a id="id-errors-and-opt"></a>2.5.4 <a href="#id-errors-and-opt" style="text-decoration: none">Errors and Optimization</a></h4><p>Because different implementations may choose to evaluate or optimize an expression in different ways, certain aspects of raising <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a> are <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>, as described in this section.</p><p>An implementation is always free to evaluate the operands of an operator in any order.</p><p>In some cases, a processor can determine the result of an expression without accessing all the data that would be implied by the formal expression semantics. For example, the formal description of <a title="filter expression" class="termref" href="#dt-filter-expression">filter expressions</a> suggests that <code>$s[1]</code> should be evaluated by examining all the items in sequence <code>$s</code>, and selecting all those that satisfy the predicate <code>position()=1</code>. In practice, many implementations will recognize that they can evaluate this expression by taking the first item in the sequence and then exiting. If <code>$s</code> is defined by an expression such as <code>//book[author eq 'Berners-Lee']</code>, then this strategy may avoid a complete scan of a large document and may therefore greatly improve performance. However, a consequence of this strategy is that a dynamic error or type error that would be detected if the expression semantics were followed literally might not be detected at all if the evaluation exits early. In this example, such an error might occur if there is a <code>book</code> element in the input data with more than one <code>author</code> subelement.</p><p>The extent to which a processor may optimize its access to data, at the cost of not raising errors, is defined by the following rules.</p><p>Consider an expression <em>Q</em> that has an operand (sub-expression) <em>E</em>. In general the value of <em>E</em> is a sequence. At an intermediate stage during evaluation of the sequence, some of its items will be known and others will be unknown. If, at such an intermediate stage of evaluation, a processor is able to establish that there are only two possible outcomes of evaluating <em>Q</em>, namely the value <em>V</em> or an error, then the processor may deliver the result <em>V</em> without evaluating further items in the operand <em>E</em>. For this purpose, two values are considered to represent the same outcome if their items are pairwise the same, where nodes are the same if they have the same identity, and values are the same if they are equal and have exactly the same type.</p><p>There is an exception to this rule: If a processor evaluates an operand <em>E</em> (wholly or in part), then it is required to establish that the actual value of the operand <em>E</em> does not violate any constraints on its cardinality. For example, the expression <code>$e eq 0</code> results in a type error if the value of <code>$e</code> contains two or more items. A processor is not allowed to decide, after evaluating the first item in the value of <code>$e</code> and finding it equal to zero, that the only possible outcomes are the value <code>true</code> or a type error caused by the cardinality violation. It must establish that the value of <code>$e</code> contains no more than one item.</p><p>These rules apply to all the operands of an expression considered in combination: thus if an expression has two operands <em>E1</em> and <em>E2</em>, it may be evaluated using any samples of the respective sequences that satisfy the above rules.</p><p>The rules cascade: if <em>A</em> is an operand of <em>B</em> and <em>B</em> is an operand of <em>C</em>, then the processor needs to evaluate only a sufficient sample of <em>B</em> to determine the value of <em>C</em>, and needs to evaluate only a sufficient sample of <em>A</em> to determine this sample of <em>B</em>.</p><p>The effect of these rules is that the processor is free to stop examining further items in a sequence as soon as it can establish that further items would not affect the result except possibly by causing an error. For example, the processor may return <code>true</code> as the result of the expression <code>S1 = S2</code> as soon as it finds a pair of equal values from the two sequences.</p><p>Another consequence of these rules is that where none of the items in a sequence contributes to the result of an expression, the processor is not obliged to evaluate any part of the sequence. Again, however, the processor cannot dispense with a required cardinality check: if <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence is not permitted in the relevant context, then the processor must ensure that the operand is not <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p><p>Examples:</p><ul><li><p>If an implementation can find (for example, by using an index) that at least one item returned by <code>$expr1</code> in the following example has the value <code>47</code>, it is allowed to return <code>true</code> as the result of the <code>some</code> expression, without searching for another item returned by <code>$expr1</code> that would raise an error if it were evaluated. </p><div class="exampleInner"><pre xml:space="preserve">some $x in $expr1 satisfies $x = 47</pre></div></li><li><p>In the following example, if an implementation can find (for example, by using an index) the <code>product</code> element-nodes that have an <code>id</code> child with the value <code>47</code>, it is allowed to return these nodes as the result of the <a title="path expression" class="termref" href="#dt-path-expression">path expression</a>, without searching for another <code>product</code> node that would raise an error because it has an <code>id</code> child whose value is not an integer.</p><div class="exampleInner"><pre xml:space="preserve">//product[id = 47]</pre></div></li></ul><p>For a variety of reasons, including optimization, implementations may rewrite expressions into a different form. There are a number of rules that limit the extent of this freedom: </p><ul><li><p> Other than the raising or not raising of errors, the result of evaluating a rewritten expression must conform to the semantics defined in this specification for the original expression. </p><div class="note"><p class="prefix"><b>Note:</b></p><p> This allows an implementation to return a result in cases where the original expression would have raised an error, or to raise an error in cases where the original expression would have returned a result. The main cases where this is likely to arise in practice are (a) where a rewrite changes the order of evaluation, such that a subexpression causing an error is evaluated when the expression is written one way and is not evaluated when the expression is written a different way, and (b) where intermediate results of the evaluation cause overflow or other out-of-range conditions. </p></div><div class="note"><p class="prefix"><b>Note:</b></p><p> This rule does not mean that the result of the expression will always be the same in non-error cases as if it had not been rewritten, because there are many cases where the result of an expression is to some degree <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> or <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. </p></div></li><li><p> The rules described in <a href="#id-guarded-expressions"><b>2.5.5 Guarded Expressions</b></a> ensure that for certain kinds of expression (for example conditional expressions), changing the order of evaluation of subexpressions does not result in dynamic errors that would not otherwise occur.</p></li><li><p> Expressions must not be rewritten in such a way as to create or remove static errors. The static errors in this specification are defined for the original expression, and must be preserved if the expression is rewritten.</p></li><li><p> As stated earlier, an expression must not be rewritten to dispense with a required cardinality check: for example, <code>string-length(//title)</code> must raise an error if the document contains more than one title element. </p></li></ul></div><div class="_diffs div3"><h4><a id="id-guarded-expressions"></a>2.5.5 <a href="#id-guarded-expressions" style="text-decoration: none">Guarded Expressions</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-implausible-expressions">next</a> | <a href="#id-processing-model">previous</a>)</p><ol><li><p> The rules for “errors and optimization” have been tightened up to disallow many cases of optimizations that alter error behavior. In particular there are restrictions on reordering the operands of <code>and</code> and <code>or</code>, and of predicates in filter expressions, in a way that might allow the processor to raise dynamic errors that the author intended to prevent. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/71">71</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/230">230</a>&nbsp;15 November 2022]</i></p></li></ol></div><p> [<a id="dt-guarded" title="guarded">Definition</a>: An expression <var>E</var> is said to be <b>guarded</b> by some governing condition <var>C</var> if evaluation of <var>E</var> is not allowed to fail with a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> except when <var>C</var> applies.] </p><p>For example, in a conditional expression <code>if (P) then T else F</code>, the subexpression <var>T</var> is guarded by <var>P</var>, and the subexpression <var>F</var> is guarded by <code>not(P)</code>. One way an implementation can satisfy this rule is by not evaluating <var>T</var> unless <var>P</var> is true, and likewise not evaluating <var>F</var> unless <var>P</var> is false. Another way of satisfying the rule is for the implementation to evaluate all the subexpressions, but to catch any errors that occur in a guarded subexpression so they are not propagated. </p><p>The existence of this rule enables errors to be prevented by writing expressions such as <code>if ($y eq 0) then "N/A" else ($x div $y)</code>. This example will never fail with a divide-by-zero error because the <code>else</code> branch of the conditional is <a title="guarded" class="termref" href="#dt-guarded">guarded</a>.</p><p>Similarly, in the mapping expression <code><var>E<sub>1</sub></var>!<var>E<sub>2</sub></var></code>, the subexpression <var>E<sub>2</sub></var> is guarded by the existence of an item from <var>E<sub>1</sub></var>. This means, for example, that the expression <code>(1 to $n)!doc('bad.xml')</code> must not raise a dynamic error if <code>$n</code> is zero. The rule governing evaluation of guarded expressions is phrased so as not to disallow “loop-lifting” or “constant-folding” optimizations whose aim is to avoid repeated evaluation of a common subexpression; but such optimizations must not result in errors that would not otherwise occur.</p><p>The complete list of expressions that have guarded subexpressions is as follows:</p><ul><li><p>In a conditional expression (<a href="#doc-xpath40-IfExpr">IfExpr</a>) the <code>then</code> branch is guarded by the condition being true, and the <code>else</code> branch is guarded by the condition being false.</p></li><li><p>In an <a title="and expression" class="termref" href="#dt-and-expression">and expression</a>, the second operand is guarded by the value of the first operand being true.</p></li><li><p>In an <a title="or expression" class="termref" href="#dt-or-expression">or expression</a>, the second operand is guarded by the value of the first operand being false.</p></li><li><p><span style="display: none;" class="delete_version">In an <code>otherwise</code> expression (<a href="#doc-xpath40-OtherwiseExpr">OtherwiseExpr</a>), the second operand is guarded by the value of the first operand being an empty sequence.</span><span style="display: none;" class="add_version">In an <code>otherwise</code> expression (<a href="#doc-xpath40-OtherwiseExpr">OtherwiseExpr</a>), the second operand is guarded by the value of the first operand being the empty sequence.</span><span class="modify_version">In an <code>otherwise</code> expression (<a href="#doc-xpath40-OtherwiseExpr">OtherwiseExpr</a>), the second operand is guarded by the value of the first operand being <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p>In a path expression of the form <code><var>E<sub>1</sub></var>/<var>E<sub>2</sub></var></code> or <code><var>E<sub>1</sub></var>//<var>E<sub>2</sub></var></code>, and in a mapping expression of the form <code><var>E<sub>1</sub></var>!<var>E<sub>2</sub></var></code>, the right-hand operand <var>E<sub>2</sub></var> is guarded by the existence of at least one item in the result of evaluating <var>E<sub>1</sub></var>.</p><p>This rule applies even if <var>E<sub>2</sub></var> does not reference the context value. For example, no dynamic error can be thrown by the expression <code>(1 to $n)!doc('bad.xml')</code> in the case where <code>$n</code> is zero.</p></li><li><p>In a filter expression of the form <code><var>E</var>[<var>P</var>]</code>, the predicate <var>P</var> is guarded by the existence of at least one item in the result of evaluating <var>E</var>.</p><p>This rule has the consequence that in a filter expression with multiple predicates, such as <code><var>E</var>[<var>P<sub>1</sub></var>][<var>P<sub>2</sub></var>]</code>, evaluation of <var>P<sub>2</sub></var> must not raise a dynamic error unless <var>P<sub>1</sub></var> returns <code>true</code>. This rule does not prevent reordering of predicates (for example, to take advantage of indexes), but it does require that any such reordering must not result in errors that would not otherwise occur.</p></li><li><p class="xpath">In a <code>for</code> expression (<a href="#doc-xpath40-ForExpr">ForExpr</a>) such as <code>for $x in <var>S</var> return <var>E</var></code>, the expression <var>E</var> is guarded by the existence of an item bound to <code>$x</code>.</p><p>This means that the expression <code>for $x in 1 to $n return doc('bad.xml')</code> must not raise a dynamic error in the case where <code>$n</code> is zero.</p></li><li><p>In a <code>quantified</code> expression (<a href="#doc-xpath40-QuantifiedExpr">QuantifiedExpr</a>) such as <code>some $x in <var>S</var> satisfies <var>P</var></code>, the expression <var>P</var> is guarded by the existence of an item bound to <code>$x</code>.</p></li></ul><p>The fact that an expression is <a title="guarded" class="termref" href="#dt-guarded">guarded</a> does not remove the obligation to report <a title="static error" class="termref" href="#dt-static-error">static errors</a> in the expression; nor does it remove the option to report statically detectable <a title="type error" class="termref" href="#dt-type-error">type errors</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>These rules do not constrain the order of evaluation of subexpressions. For example, given an expression such as <code>//person[@first = "Winston"][@last = "Churchill"]</code>, or equivalently <code>//person[@first = "Winston" and @last = "Churchill"]</code>, an implementation might use an index on the value of <code>@last</code> to select items that satisfy the second condition, and then filter these items on the value of the first condition. Alternatively, it might evaluate both predicates in parallel. Or it might interpose an additional redundant condition: <code>//person[string-length(@first) + string-length(@last) = 16][@first = "Winston"][@last = "Churchill"]</code>. But implementations must ensure that such rewrites do not result in dynamic errors being reported that would not occur if the predicates were evaluated in order as written.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Although the rules for guarded expressions prevent optimizations resulting in spurious errors, they do not prevent optimizations whose effect is to mask errors. For example, the rules guarantee that <code>("A", 3)[. instance of xs:integer][. eq 3]</code> will not raise an error caused by the comparison <code>("A" eq 3)</code>, but they do not guarantee the converse: the expression <code>("A", 3)[. eq 3][. instance of xs:integer]</code> may or may not raise a dynamic error.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The rules in this section do not disallow all expression rewrites that might result in dynamic errors. For example, rewriting <code>($x - $y + $z)</code> as <code>($x + $z - $y)</code> is permitted even though it might result in an arithmetic overflow.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Some implementations allow calls on external functions that have side-effects. The semantics of such function calls are entirely <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation defined</a>. Processors <span class="verb">may</span> choose to reference the rules for <a title="guarded" class="termref" href="#dt-guarded">guarded</a> expressions when defining the behavior of such function calls, but this is outside the scope of the language specification.</p></div></div><div class="_diffs div3"><h4><a id="id-implausible-expressions"></a>2.5.6 <a href="#id-implausible-expressions" style="text-decoration: none">Implausible Expressions</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-choice-item-types">next</a> | <a href="#id-guarded-expressions">previous</a>)</p><ol><li><p><span style="display: none;" class="delete_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return an empty sequence rather than an error. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/602">602</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/603">603</a>&nbsp;25 July 2023]</i></span><span style="display: none;" class="add_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return the empty sequence rather than an error. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/602">602</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/603">603</a>&nbsp;25 July 2023]</i></span><span class="modify_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence rather than an error. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/602">602</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/603">603</a>&nbsp;25 July 2023]</i></span></p></li></ol></div><p> [<a id="dt-implausible" title="implausible">Definition</a>: Certain expressions, while not erroneous, are classified as being <b>implausible</b>, because they achieve no useful effect.] </p><p><span style="display: none;" class="delete_version">An example of an implausible expression is <code>@code/text()</code>. This expression will always evaluate to an empty sequence, because attribute nodes cannot have text node children. The semantics of the expression are well defined, but it is likely that the user writing this expression intended something different: if they wanted to write an expression that evaluated to an empty sequence, there would be easier ways to write it.</span><span style="display: none;" class="add_version">An example of an implausible expression is <code>@code/text()</code>. This expression will always evaluate to the empty sequence, because attribute nodes cannot have text node children. The semantics of the expression are well defined, but it is likely that the user writing this expression intended something different: if they wanted to write an expression that evaluated to the empty sequence, there would be easier ways to write it.</span><span class="modify_version">An example of an implausible expression is <code>@code/text()</code>. This expression will always evaluate to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, because attribute nodes cannot have text node children. The semantics of the expression are well defined, but it is likely that the user writing this expression intended something different: if they wanted to write an expression that evaluated to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, there would be easier ways to write it.</span></p><p>Where an expression is classified (by rules in this specification) as being <a title="implausible" class="termref" href="#dt-implausible">implausible</a>, a processor <span class="verb">may</span> (but is not <span class="verb">required</span> to) raise a static error.</p><p>For reasons of backwards compatibility and interoperability, and to facilitate automatic generation of XPath 4.0 code, a processor <span class="verb">must</span> provide a mode of operation in which <a title="implausible" class="termref" href="#dt-implausible">implausible</a> expressions are not treated as static errors, but are evaluated with the defined semantics for the expression.</p><p>Some other examples of implausible expressions include:</p><ul><li><p><span style="display: none;" class="delete_version"><code>round(tokenize($input))</code>. The result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-tokenize"><code>fn:tokenize</code></a> is a sequence of strings (<code>xs:string*</code>), while the required type for the first argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-round"><code>fn:round</code></a> is optional numeric (<code>xs:numeric?</code>). The expression can succeed only in the exceptional case where the result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-tokenize"><code>fn:tokenize</code></a> is an empty sequence, in which case the result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-round"><code>fn:round</code></a> will also be an empty sequence; it is therefore highly likely that the expression was written in error.</span><span style="display: none;" class="add_version"><code>round(tokenize($input))</code>. The result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-tokenize"><code>fn:tokenize</code></a> is a sequence of strings (<code>xs:string*</code>), while the required type for the first argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-round"><code>fn:round</code></a> is optional numeric (<code>xs:numeric?</code>). The expression can succeed only in the exceptional case where the result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-tokenize"><code>fn:tokenize</code></a> is the empty sequence, in which case the result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-round"><code>fn:round</code></a> will also be the empty sequence; it is therefore highly likely that the expression was written in error.</span><span class="modify_version"><code>round(tokenize($input))</code>. The result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-tokenize"><code>fn:tokenize</code></a> is a sequence of strings (<code>xs:string*</code>), while the required type for the first argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-round"><code>fn:round</code></a> is optional numeric (<code>xs:numeric?</code>). The expression can succeed only in the exceptional case where the result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-tokenize"><code>fn:tokenize</code></a> is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, in which case the result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-round"><code>fn:round</code></a> will also be <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence; it is therefore highly likely that the expression was written in error.</span></p></li><li><p><span style="display: none;" class="delete_version"><code>parse-csv($input)?column-names</code>. The signature of the <code>parse-csv</code> function declares its return type as <code>record(columns, rows)</code>. There is no field in this record named <code>column-names</code>, and therefore the lookup expression will always return an empty sequence. Again, there is no good reason that a user would write this, so it is likely that it was written in error.</span><span style="display: none;" class="add_version"><code>parse-csv($input)?column-names</code>. The signature of the <code>parse-csv</code> function declares its return type as <code>record(columns, rows)</code>. There is no field in this record named <code>column-names</code>, and therefore the lookup expression will always return the empty sequence. Again, there is no good reason that a user would write this, so it is likely that it was written in error.</span><span class="modify_version"><code>parse-csv($input)?column-names</code>. The signature of the <code>parse-csv</code> function declares its return type as <code>record(columns, rows)</code>. There is no field in this record named <code>column-names</code>, and therefore the lookup expression will always return <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. Again, there is no good reason that a user would write this, so it is likely that it was written in error.</span></p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The specification is deliberately conservative in the choice of constructs that have been classified as implausible. Constructs have not been classified as implausible merely because there are better ways of writing the same thing, but only in cases where it is considered that no user in full understanding of the specification would intentionally write such a construct. All these cases correspond to situations that would be classed as errors in a language with stricter static typing rules.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In many cases the classification of constructs as implausible is designed to protect users from usability problems that have been found with earlier versions of the language. without introducing backwards incompatibilities.</p></div></div></div><div class="_diffs div2"><h3><a id="id-important-concepts"></a>2.6 <a href="#id-important-concepts" style="text-decoration: none">Concepts</a></h3><p>This section explains some concepts that are important to the processing of XPath 4.0 expressions.</p><div class="_diffs div3"><h4><a id="id-document-order"></a>2.6.1 <a href="#id-document-order" style="text-decoration: none">Document Order</a></h4><p>An ordering called <b>document order</b> is defined among all the nodes accessible during processing of a given <span class="xpath">expression</span>, which may consist of one or more <b>trees</b> (documents or fragments).</p><p><span style="display: none;" class="delete_version">Document order applies both to <a title="XNode" class="termref" href="#dt-XNode">XNodes</a> (typically corresponding to nodes in an XML document, and generally referred to simply as <b>nodes</b>), and also to <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-JNode">JNodes</a><sup><small>DM</small></sup>, often corresponding to the contents of a JSON source text. These are known collectively as <a title="GNode" class="termref" href="#dt-GNode">GNodes</a> (for "generalized node").</span><span style="display: none;" class="add_version">Document order applies both to <a title="XNode" class="termref" href="#dt-XNode">XNodes</a> (typically corresponding to nodes in an XML document, and generally referred to simply as <b>nodes</b>), and also to <a href="#dt-JNode" title="JNode" class="termref">JNodes</a>, often corresponding to the contents of a JSON source text. These are known collectively as <a title="GNode" class="termref" href="#dt-GNode">GNodes</a> (for "generalized node").</span><span class="modify_version">Document order applies both to <a title="XNode" class="termref" href="#dt-XNode">XNodes</a> (typically corresponding to nodes in an XML document, and generally referred to simply as <b>nodes</b>), and also to <a href="#dt-JNode" title="JNode" class="termref">JNodes</a><span class="deltaxml-old" style="background:#FF5555">DM</span>, often corresponding to the contents of a JSON source text. These are known collectively as <a title="GNode" class="termref" href="#dt-GNode">GNodes</a> (for "generalized node").</span></p><p>Document order is defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#document-order">6.2 Document Order</a>, and its definition is repeated here for convenience. Document order is a total ordering, although the relative order of some nodes is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. [<a id="dt-document-order" title="document order">Definition</a>: Informally, <b>document order</b> is the order in which nodes appear in the XML serialization of a document.] [<a id="stable" title="stable">Definition</a>: Document order is <b>stable</b>, which means that the relative order of two nodes will not change during the processing of a given <span class="xpath">expression</span>, even if this order is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.] [<a id="dt-reverse-document-order" title="reverse document order">Definition</a>: The node ordering that is the reverse of document order is called <b>reverse document order</b>.] </p><p>Within an <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-XTree">XTree</a><sup><small>DM</small></sup>, (that is, a tree consisting of XNodes), document order satisfies the following constraints:</p><ol class="enumar"><li><p>The root node precedes all other nodes.</p></li><li><p>A parent node precedes its children (and therefore its descendants).</p></li><li><p>The children of a node <var>N</var> precede the following siblings of <var>N</var>.</p></li><li class="xpath"><p>Namespace nodes immediately follow the element node with which they are associated. The relative order of namespace nodes is stable but <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p></li><li><p>Attribute nodes immediately follow the namespace nodes of the element node with which they are associated. The relative order of attribute nodes is stable but <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p></li><li><p>The relative order of siblings is the order in which they occur in the <code>children</code> property of their parent node.</p></li></ol><p>Similarly, within an <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-JTree">JTree</a><sup><small>DM</small></sup>, (that is, a tree consisting of JNodes), document order satisfies the following constraints:</p><ol class="enumar"><li><p>The root JNode precedes all other JNodes.</p></li><li><p>A parent JNode precedes its children (and therefore its descendants).</p></li><li><p>The children of a JNode <var>N</var> precede the following siblings of <var>N</var>.</p></li><li><p>The children of a JNode that wraps an array follow the ordering of the members of the array.</p></li><li><p>The children of a JNode that wraps a map follow the ordering of the entries in the map.</p></li></ol><p>The relative order of nodes in distinct trees is stable but <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>, subject to the following constraint: If any node in a given tree T1 is before any node in a different tree T2, then all nodes in tree T1 are before all nodes in tree T2.</p></div><div class="_diffs div3"><h4><a id="id-ebv"></a>2.6.4 <a href="#id-ebv" style="text-decoration: none">Effective Boolean Value</a></h4><p>Under certain circumstances (some of which are listed below), it is necessary to find the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of a value. [<a id="dt-ebv" title="effective boolean value">Definition</a>: The <b>effective boolean value</b> of a value is defined as the result of applying the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> function to the value.] </p><p>The dynamic semantics of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> are repeated here for convenience:</p><ol class="enumar"><li><p><span style="display: none;" class="delete_version">If its operand is an empty sequence, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> returns <code>false</code>.</span><span style="display: none;" class="add_version">If its operand is the empty sequence, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> returns <code>false</code>.</span><span class="modify_version">If its operand is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> returns <code>false</code>.</span></p></li><li><p>If its operand is a sequence whose first item is a <a title="GNode" class="termref" href="#dt-GNode">GNode</a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> returns <code>true</code>.</p></li><li><p>If its operand is a <a title="singleton" class="termref" href="#dt-singleton">singleton</a> value of type <code>xs:boolean</code> or derived from <code>xs:boolean</code>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> returns the value of its operand unchanged.</p></li><li><p>If its operand is a <a title="singleton" class="termref" href="#dt-singleton">singleton</a> value of type <code>xs:string</code>, <code>xs:anyURI</code>, <code>xs:untypedAtomic</code>, or a type derived from one of these, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> returns <code>false</code> if the operand value has zero length; otherwise it returns <code>true</code>.</p></li><li><p>If its operand is a <a title="singleton" class="termref" href="#dt-singleton">singleton</a> value of any <a title="numeric" class="termref" href="#dt-numeric">numeric</a> type or derived from a numeric type, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> returns <code>false</code> if the operand value is <code>NaN</code> or is numerically equal to zero; otherwise it returns <code>true</code>.</p></li><li><p>In all other cases, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> raises a type error [<a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFORG0006" title="err:FORG0006">err:FORG0006</a>]<sup><small>FO40</small></sup>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For instance, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> raises a type error if the operand is a function, a map, or an array.</p></div></li></ol><p>The <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of a sequence is computed implicitly during processing of the following types of expressions: </p><ul><li><p>Logical expressions (<code>and</code>, <code>or</code>)</p></li><li><p>The <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-not"><code>fn:not</code></a> function</p></li><li><p>Certain types of <a title="" class="termref" href="#dt-predicate">predicates</a>, such as <code>a[b]</code></p></li><li><p>Conditional expressions (<code>if</code>)</p></li><li><p>Quantified expressions (<code>some</code>, <code>every</code>)</p></li><li class="xpath"><p>General comparisons, in <a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a>.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The definition of <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> is <em>not</em> used when casting a value to the type <code>xs:boolean</code>, for example in a <code>cast</code> expression. It also plays no role in the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> used when passing a value to a function whose signature declares a parameter of type <code>xs:boolean</code>.</p></div></div></div></div><div class="_diffs div1"><h2><a id="id-types"></a>3 <a href="#id-types" style="text-decoration: none">Types</a></h2><p>As noted in <a href="#id-values"><b>2.1.3 Values</b></a>, every value in XPath 4.0 is regarded as a <a title="sequence" class="termref" href="#dt-sequence">sequence</a> of zero, one, or more <a title="item" class="termref" href="#dt-item">items</a>. The type system of XPath 4.0, described in this section, classifies the kinds of value that the language can handle, and the operations permitted on different kinds of value.</p><p>The type system of XPath 4.0 is related to the type system of <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> in two ways:</p><ul><li><p>atomic items in XPath 4.0 (which are one kind of <a title="item" class="termref" href="#dt-item">item</a>) have <a title="atomic type" class="termref" href="#dt-atomic-type">atomic types</a> such as <code>xs:string</code>, <code>xs:boolean</code>, and <code>xs:integer</code>. These types are taken directly from their definitions in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.</p></li><li><p><a title="XNode" class="termref" href="#dt-XNode">XNodes</a> (which are another kind of <a title="item" class="termref" href="#dt-item">item</a>) have a property called a <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> which determines the type of their content. The type annotation is a <a title="schema type" class="termref" href="#dt-schema-type">schema type</a>. The type annotation of a node must not be confused with the item type of the node. For example, an element <code>&lt;age&gt;23&lt;/age&gt;</code> might have been validated against a schema that defines this element as having <code>xs:integer</code> content. If this is the case, the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of the node will be <code>xs:integer</code>, and in the XPath 4.0 type system, the node will match the <a title="item type" class="termref" href="#dt-item-type">item type</a><code>element(age, xs:integer)</code>. </p></li></ul><p>This chapter of the specification starts by defining <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a> and <a title="item type" class="termref" href="#dt-item-type">item types</a>, which describe the range of <a title="value" class="termref" href="#dt-value">values</a> that can be bound to variables, used in expressions, or passed to functions. It then describes how these relate to <a title="schema type" class="termref" href="#dt-schema-type">schema types</a>, that is, the simple and complex types defined in an XSD schema.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In many situations the terms <b>item type</b> and <b>sequence type</b> are used interchangeably to refer either to the type itself, or to the syntactic construct that designates the type: so in the expression <code>$x instance of xs:string*</code>, the construct <code>xs:string*</code> uses the <a href="#doc-xpath40-SequenceType">SequenceType</a> syntax to designate a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> whose instances are sequences of strings. When more precision is required, the specification is careful to use the terms <a title="item type" class="termref" href="#dt-item-type">item type</a> and <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> to refer to the actual types, while using the production names <a href="#doc-xpath40-ItemType">ItemType</a> and <a href="#doc-xpath40-SequenceType">SequenceType</a> to refer to the syntactic designators of these types.</p></div><div class="_diffs div2"><h3><a id="id-sequencetype-syntax"></a>3.1 <a href="#id-sequencetype-syntax" style="text-decoration: none">Sequence Types</a></h3><p> [<a id="dt-sequence-type" title="sequence type">Definition</a>: A <b>sequence type</b> is a type that can be expressed using the <a href="#doc-xpath40-SequenceType">SequenceType</a> syntax. Sequence types are used whenever it is necessary to refer to a type in an XPath 4.0 expression. Since all values are sequences, every value matches one or more <b>sequence types</b>.] </p><p>Whenever it is necessary to refer to a <b>sequence type</b> in an XPath 4.0 expression, the <a href="#doc-xpath40-SequenceType">SequenceType</a> syntax is used.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-SequenceType"></a><code><a href="#prod-xpath40-SequenceType">SequenceType</a></code></td><td>::=</td><td><code>("empty-sequence" "(" ")")<br>| (<a href="#doc-xpath40-SequenceType-ItemType">ItemType</a><a href="#doc-xpath40-SequenceType-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-SequenceType-ItemType"></a><code><a href="#prod-xpath40-ItemType">ItemType</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-RegularItemType">RegularItemType</a> | <a href="#doc-xpath40-FunctionType">FunctionType</a> | <a href="#prod-xpath40-TypeName">TypeName</a> | <a href="#prod-xpath40-ChoiceItemType">ChoiceItemType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-SequenceType-OccurrenceIndicator"></a><code><a href="#prod-xpath40-OccurrenceIndicator">OccurrenceIndicator</a></code></td><td>::=</td><td><code>"?" | "*" | "+"</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-occurrence-indicators">xgc: occurrence-indicators</a> */</td></tr></tbody></table><p> [<a id="dt-sequence-type-designator" title="sequence type designator">Definition</a>: A <b>sequence type designator</b> is a syntactic construct conforming to the grammar rule <a href="#doc-xpath40-SequenceType">SequenceType</a>. A sequence type designator is said to <b>designate</b> a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>.] </p><p>With the exception of the special type <code>empty-sequence()</code>, a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> consists of an <a title="item type" class="termref" href="#dt-item-type">item type</a> that constrains the type of each item in the sequence, and a <b>cardinality</b> that constrains the number of items in the sequence. Apart from the item type <code>item()</code>, which permits any kind of item, item types divide into <b>node types</b> (such as <code>element()</code>), <b>generalized atomic types</b> (such as <code>xs:integer</code>) and function types (such as <code>function() as item()*</code>).</p><p>The cardinality of a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> is represented in the <a title="sequence type designator" class="termref" href="#dt-sequence-type-designator">sequence type designator</a> syntax by an <a href="#prod-xpath40-OccurrenceIndicator">OccurrenceIndicator</a>. The occurrence indicators <code>+</code>, <code>*</code>, and <code>?</code> bind to the last <a href="#doc-xpath40-ItemType">ItemType</a> in the <a href="#doc-xpath40-SequenceType">SequenceType</a>, as described in the <a href="#parse-note-occurrence-indicators">occurrence-indicators</a> constraint.</p><div class="_diffs div3"><h4><a id="id-sequencetype-matching"></a>3.1.2 <a href="#id-sequencetype-matching" style="text-decoration: none">Sequence Type Matching</a></h4><p> [<a id="dt-sequencetype-matching" title="SequenceType matching">Definition</a>: <b>SequenceType matching</b> compares a value with an expected <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>. ] For example, an <code>instance of</code> expression returns <code>true</code> if a given value matches a given <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>, and <code>false</code> if it does not.</p><p>An XPath 4.0 implementation must be able to determine relationships among the types in type annotations in an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> and the types in the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> (ISSD). </p><p> [<a id="dt-subtype-substitution" title="subtype substitution">Definition</a>: The use of a value that has a <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> that is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of the expected type is known as <b>subtype substitution</b>.] Subtype substitution does not change the actual type of a value. For example, if an <code>xs:integer</code> value is used where an <code>xs:decimal</code> value is expected, the value retains its type as <code>xs:integer</code>.</p><p>The rules for <a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching">SequenceType matching</a> are given below, with examples (the examples are for purposes of illustration, and do not cover all possible cases).</p><ul><li><p>The <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a><code>empty-sequence()</code> matches a value that is the empty sequence.</p></li><li><p>An <a href="#doc-xpath40-ItemType">ItemType</a> with no <a href="#prod-xpath40-OccurrenceIndicator">OccurrenceIndicator</a> matches any value that contains exactly one item if the <a href="#doc-xpath40-ItemType">ItemType</a> matches that item (see <a href="#id-matching-item"><b>3.2 Item Types</b></a>).</p></li><li><p>An <a href="#doc-xpath40-ItemType">ItemType</a> with an <a href="#prod-xpath40-OccurrenceIndicator">OccurrenceIndicator</a> matches a value if the number of items in the value matches the <a href="#prod-xpath40-OccurrenceIndicator">OccurrenceIndicator</a> and the <a href="#doc-xpath40-ItemType">ItemType</a> matches each of the items in the value.</p></li></ul><p>An <a href="#prod-xpath40-OccurrenceIndicator">OccurrenceIndicator</a> specifies the number of items in a sequence, as follows:</p><ul><li><p><code>?</code> matches zero or one items</p></li><li><p><code>*</code> matches zero or more items</p></li><li><p><code>+</code> matches one or more items</p></li></ul><p><span style="display: none;" class="delete_version">As a consequence of these rules, any <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> whose <a href="#prod-xpath40-OccurrenceIndicator">OccurrenceIndicator</a> is <code>*</code> or <code>?</code> matches a value that is an empty sequence.</span><span style="display: none;" class="add_version">As a consequence of these rules, any <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> whose <a href="#prod-xpath40-OccurrenceIndicator">OccurrenceIndicator</a> is <code>*</code> or <code>?</code> matches a value that is the empty sequence.</span><span class="modify_version">As a consequence of these rules, any <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> whose <a href="#prod-xpath40-OccurrenceIndicator">OccurrenceIndicator</a> is <code>*</code> or <code>?</code> matches a value that is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></div></div><div class="_diffs div2"><h3><a id="id-matching-item"></a>3.2 <a href="#id-matching-item" style="text-decoration: none">Item Types</a></h3><p> [<a id="dt-item-type" title="item type">Definition</a>: An <b>item type</b> is a type that can be expressed using the <a href="#doc-xpath40-ItemType">ItemType</a> syntax, which forms part of the <a href="#doc-xpath40-SequenceType">SequenceType</a> syntax. Item types match individual <a title="item" class="termref" href="#dt-item">items</a>.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>While this definition is adequate for the purpose of defining the syntax of XPath 4.0, it ignores the fact that there are also item types that cannot be expressed using XPath 4.0 syntax: specifically, item types that reference an anonymous simple type or complex type defined in a schema. Such types can appear as type annotations on nodes following schema validation.</p></div><p>In most cases, the set of items matched by an item type consists either exclusively of <a title="atomic item" class="termref" href="#dt-atomic-item">atomic items</a>, exclusively of <a title="node" class="termref" href="#dt-node">nodes</a>, or exclusively of <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-function-item">function items</a><sup><small>DM</small></sup>. Exceptions include the generic types <code>item()</code>, which matches all items, <code>xs:error</code>, which matches no items, and <a title="choice item type" class="termref" href="#dt-choice-item-type">choice item types</a>, which can match any combination of types. </p><p> [<a id="dt-item-type-designator" title="item type designator">Definition</a>: An <b>item type designator</b> is a syntactic construct conforming to the grammar rule <a href="#doc-xpath40-ItemType">ItemType</a>. An item type designator is said to <b>designate</b> an <a title="item type" class="termref" href="#dt-item-type">item type</a>.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Two <a title="item type designator" class="termref" href="#dt-item-type-designator">item type designators</a> may designate the same item type. For example, <code>element()</code> and <code>element(*)</code> are equivalent, as are <code>attribute(A)</code> and <code>attribute(A, xs:anySimpleType)</code>.</p></div><p><a title="lexical QName" class="termref" href="#dt-qname">Lexical QNames</a> appearing in an <a title="item type designator" class="termref" href="#dt-item-type-designator">item type designator</a> are expanded using the <a title="default type namespace rule" class="termref" href="#dt-default-type-namespace-rule">default type namespace rule</a>. Equality of QNames is defined by the <code>eq</code> operator.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType"></a><code><a href="#prod-xpath40-ItemType">ItemType</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-ItemType-RegularItemType">RegularItemType</a> | <a href="#doc-xpath40-ItemType-FunctionType">FunctionType</a> | <a href="#doc-xpath40-ItemType-TypeName">TypeName</a> | <a href="#doc-xpath40-ItemType-ChoiceItemType">ChoiceItemType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-RegularItemType"></a><code><a href="#prod-xpath40-RegularItemType">RegularItemType</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-ItemType-AnyItemTest">AnyItemTest</a> | <a href="#doc-xpath40-ItemType-NodeKindTest">NodeKindTest</a> | <a href="#doc-xpath40-ItemType-GNodeType">GNodeType</a> | <a href="#doc-xpath40-ItemType-JNodeType">JNodeType</a> | <a href="#doc-xpath40-ItemType-MapType">MapType</a> | <a href="#doc-xpath40-ItemType-ArrayType">ArrayType</a> | <a href="#doc-xpath40-ItemType-RecordType">RecordType</a> | <a href="#doc-xpath40-ItemType-EnumerationType">EnumerationType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-AnyItemTest"></a><code><a href="#prod-xpath40-AnyItemTest">AnyItemTest</a></code></td><td>::=</td><td><code>"item" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-NodeKindTest"></a><code><a href="#prod-xpath40-NodeKindTest">NodeKindTest</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-ItemType-DocumentTest">DocumentTest</a><br>| <a href="#doc-xpath40-ItemType-ElementTest">ElementTest</a><br>| <a href="#doc-xpath40-ItemType-AttributeTest">AttributeTest</a><br>| <a href="#doc-xpath40-ItemType-SchemaElementTest">SchemaElementTest</a><br>| <a href="#doc-xpath40-ItemType-SchemaAttributeTest">SchemaAttributeTest</a><br>| <a href="#doc-xpath40-ItemType-PITest">PITest</a><br>| <a href="#doc-xpath40-ItemType-CommentTest">CommentTest</a><br>| <a href="#doc-xpath40-ItemType-TextTest">TextTest</a><br>| <a href="#doc-xpath40-ItemType-NamespaceNodeTest">NamespaceNodeTest</a><br>| <a href="#doc-xpath40-ItemType-AnyNodeKindTest">AnyNodeKindTest</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-DocumentTest"></a><code><a href="#prod-xpath40-DocumentTest">DocumentTest</a></code></td><td>::=</td><td><code>"document-node" "(" (<a href="#doc-xpath40-ItemType-ElementTest">ElementTest</a> | <a href="#doc-xpath40-ItemType-SchemaElementTest">SchemaElementTest</a> | <a href="#doc-xpath40-ItemType-NameTestUnion">NameTestUnion</a>)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-ElementTest"></a><code><a href="#prod-xpath40-ElementTest">ElementTest</a></code></td><td>::=</td><td><code>"element" "(" (<a href="#doc-xpath40-ItemType-NameTestUnion">NameTestUnion</a> ("," <a href="#doc-xpath40-ItemType-TypeName">TypeName</a> "?"?)?)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-SchemaElementTest"></a><code><a href="#prod-xpath40-SchemaElementTest">SchemaElementTest</a></code></td><td>::=</td><td><code>"schema-element" "(" <a href="#prod-xpath40-ElementName">ElementName</a> ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-NameTestUnion"></a><code><a href="#prod-xpath40-NameTestUnion">NameTestUnion</a></code></td><td>::=</td><td><code>(<a href="#doc-xpath40-ItemType-NameTest">NameTest</a> ++ "|")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-NameTest"></a><code><a href="#prod-xpath40-NameTest">NameTest</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-ItemType-EQName">EQName</a> | <a href="#prod-xpath40-Wildcard">Wildcard</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-AttributeTest"></a><code><a href="#prod-xpath40-AttributeTest">AttributeTest</a></code></td><td>::=</td><td><code>"attribute" "(" (<a href="#doc-xpath40-ItemType-NameTestUnion">NameTestUnion</a> ("," <a href="#doc-xpath40-ItemType-TypeName">TypeName</a>)?)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-SchemaAttributeTest"></a><code><a href="#prod-xpath40-SchemaAttributeTest">SchemaAttributeTest</a></code></td><td>::=</td><td><code>"schema-attribute" "(" <a href="#prod-xpath40-AttributeName">AttributeName</a> ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-PITest"></a><code><a href="#prod-xpath40-PITest">PITest</a></code></td><td>::=</td><td><code>"processing-instruction" "(" (<a href="#prod-xpath40-NCName">NCName</a> | <a href="#doc-xpath40-ItemType-StringLiteral">StringLiteral</a>)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-StringLiteral"></a><code><a href="#prod-xpath40-StringLiteral">StringLiteral</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-AposStringLiteral">AposStringLiteral</a> | <a href="#prod-xpath40-QuotStringLiteral">QuotStringLiteral</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-CommentTest"></a><code><a href="#prod-xpath40-CommentTest">CommentTest</a></code></td><td>::=</td><td><code>"comment" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-TextTest"></a><code><a href="#prod-xpath40-TextTest">TextTest</a></code></td><td>::=</td><td><code>"text" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-NamespaceNodeTest"></a><code><a href="#prod-xpath40-NamespaceNodeTest">NamespaceNodeTest</a></code></td><td>::=</td><td><code>"namespace-node" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-AnyNodeKindTest"></a><code><a href="#prod-xpath40-AnyNodeKindTest">AnyNodeKindTest</a></code></td><td>::=</td><td><code>"node" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-GNodeType"></a><code><a href="#prod-xpath40-GNodeType">GNodeType</a></code></td><td>::=</td><td><code>"gnode" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-JNodeType"></a><code><a href="#prod-xpath40-JNodeType">JNodeType</a></code></td><td>::=</td><td><code>"jnode" "(" (("*" | <a href="#prod-xpath40-NCName">NCName</a> | <a href="#doc-xpath40-Constant">Constant</a>) ("," ("*" | <a href="#doc-xpath40-SequenceType">SequenceType</a>))?)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-MapType"></a><code><a href="#prod-xpath40-MapType">MapType</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-AnyMapType">AnyMapType</a> | <a href="#prod-xpath40-TypedMapType">TypedMapType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-ArrayType"></a><code><a href="#prod-xpath40-ArrayType">ArrayType</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-AnyArrayType">AnyArrayType</a> | <a href="#prod-xpath40-TypedArrayType">TypedArrayType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-RecordType"></a><code><a href="#prod-xpath40-RecordType">RecordType</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-AnyRecordType">AnyRecordType</a> | <a href="#prod-xpath40-TypedRecordType">TypedRecordType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-EnumerationType"></a><code><a href="#prod-xpath40-EnumerationType">EnumerationType</a></code></td><td>::=</td><td><code>"enum" "(" (<a href="#doc-xpath40-ItemType-StringLiteral">StringLiteral</a> ++ ",") ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-FunctionType"></a><code><a href="#prod-xpath40-FunctionType">FunctionType</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-AnyFunctionType">AnyFunctionType</a><br>| <a href="#prod-xpath40-TypedFunctionType">TypedFunctionType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-TypeName"></a><code><a href="#prod-xpath40-TypeName">TypeName</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-ItemType-EQName">EQName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-EQName"></a><code><a href="#prod-xpath40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-QName">QName</a> | <a href="#prod-xpath40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ItemType-ChoiceItemType"></a><code><a href="#prod-xpath40-ChoiceItemType">ChoiceItemType</a></code></td><td>::=</td><td><code>"(" (<a href="#doc-xpath40-ItemType">ItemType</a> ++ "|") ")"</code></td></tr></tbody></table><p>This section defines the syntax and semantics of different <code>ItemTypes</code> in terms of the values that they match.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For an explanation of the EBNF grammar notation (and in particular, the operators <code>++</code> and <code>**</code>), see <a href="#id-grammar"><b>A.1 EBNF</b></a>.</p></div><p>An <a title="item type designator" class="termref" href="#dt-item-type-designator">item type designator</a> written simply as an <code>EQName</code> (that is, a <code>TypeName</code>) is interpreted as follows:</p><ol class="enumar"><li><p>If the name is written as a lexical QName, then it is expanded using the <a title="default type namespace rule" class="termref" href="#dt-default-type-namespace-rule">default type namespace rule</a>.</p></li><li><p>If the expanded name matches a <a title="named item type" class="termref" href="#dt-named-item-type">named item type</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, then it is taken as a reference to the corresponding item type. The rules that apply are the rules for the expanded item type definition.</p></li><li><p>Otherwise, it must match the name of a type in the <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>: specifically, an <a title="atomic type" class="termref" href="#dt-atomic-type">atomic type</a> or a <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a>. See <a href="#id-predefined-types"><b>3.5 Schema Types</b></a> for details. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>A name in the <code>xs</code> namespace will always fall into this category, since the namespace is reserved. See <a href="#id-namespaces-and-qnames"><b>2.1.4 Namespaces and QNames</b></a>.</p></div></li><li><p>If the name cannot be resolved to a type, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0051" title="err:XPST0051">err:XPST0051</a>].</p></li></ol><div class="_diffs div3"><h4><a id="id-function-map-array-tests"></a>3.2.8 <a href="#id-function-map-array-tests" style="text-decoration: none">Function, Map, and Array Types</a></h4><p>The following sections describe the syntax for <a title="item type" class="termref" href="#dt-item-type">item types</a> for functions, including arrays and maps.</p><p>The <a title="subtype" class="termref" href="#dt-subtype">subtype</a> relation among these types is described in the various subsections of <a href="#id-itemtype-subtype"><b>3.3.2 Subtypes of Item Types</b></a>.</p><div class="_diffs div4"><h5><a id="id-map-test"></a>3.2.8.2 <a href="#id-map-test" style="text-decoration: none">Map Types</a></h5><p>A <a href="#doc-xpath40-MapType">MapType</a> designates an item type that either matches any map, or that matches maps whose keys and values are constrained to specific types.</p><a id="d2e9196"></a><a id="d2e9236"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-MapType"></a><code><a href="#prod-xpath40-MapType">MapType</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-MapType-AnyMapType">AnyMapType</a> | <a href="#doc-xpath40-MapType-TypedMapType">TypedMapType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-MapType-AnyMapType"></a><code><a href="#prod-xpath40-AnyMapType">AnyMapType</a></code></td><td>::=</td><td><code>"map" "(" "*" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-MapType-TypedMapType"></a><code><a href="#prod-xpath40-TypedMapType">TypedMapType</a></code></td><td>::=</td><td><code>"map" "(" <a href="#doc-xpath40-MapType-ItemType">ItemType</a> "," <a href="#doc-xpath40-MapType-SequenceType">SequenceType</a> ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-MapType-ItemType"></a><code><a href="#prod-xpath40-ItemType">ItemType</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-RegularItemType">RegularItemType</a> | <a href="#doc-xpath40-FunctionType">FunctionType</a> | <a href="#prod-xpath40-TypeName">TypeName</a> | <a href="#prod-xpath40-ChoiceItemType">ChoiceItemType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-MapType-SequenceType"></a><code><a href="#prod-xpath40-SequenceType">SequenceType</a></code></td><td>::=</td><td><code>("empty-sequence" "(" ")")<br>| (<a href="#doc-xpath40-MapType-ItemType">ItemType</a><a href="#prod-xpath40-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody></table><p>An <a href="#prod-xpath40-AnyMapType">AnyMapType</a><code>map(*)</code> matches any map.</p><p>The <a href="#doc-xpath40-MapType">MapType</a><code>map(K, V)</code> matches any map where every key is an instance of <code>K</code> and every value is an instance of <code>V</code>.</p><p>The <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-entry-order">entry-order</a><sup><small>DM</small></sup> of a map has no effect on whether the map matches a particular map type.</p><p>Although the grammar for <code>TypedMapType</code> allows the key to be described using the full <code>ItemType</code> syntax, the item type used must be a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a> [<a href="#ERRXPST0152" title="err:XPST0152">err:XPST0152</a>].</p><p>For example, given a map <code>$M</code> whose keys are integers and whose results are strings, such as <code>{ 0: "no", 1: "yes" }</code>, the following following expressions deliver the result shown: </p><ul><li><p><code>$M instance of map(*)</code> returns <code>true</code></p></li><li><p><code>$M instance of map(xs:integer, xs:string)</code> returns <code>true</code></p></li><li><p><code>$M instance of map(xs:decimal, xs:anyAtomicType)</code> returns <code>true</code></p></li><li><p><code>$M instance of map(xs:int, xs:string)</code> returns <code>false</code></p></li><li><p><code>$M instance of map(xs:integer, xs:token))</code> returns <code>false</code></p></li></ul><p>A map is also a function item, and therefore matches certain function types. Specifically, a map that matches <code>map(K, V)</code> also matches a function type of the form <code>function(xs:anyAtomicType) as R</code> provided that both the following conditions are satisfied:</p><ul><li><p><var>V</var> is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of <var>R</var></p></li><li><p><code>empty-sequence()</code> is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of <var>R</var></p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">To understand this rule, consider the use of a map <code>$M</code> in a function call <code>$M($K)</code>, which is equivalent to the function call <code>map:get($M, $K)</code>. This function accepts any atomic item for the argument <code>$K</code>, and hence matches a function type that requires an argument type of <code>xs:anyAtomicType</code>. If the key <code>$K</code> is present in the map, the result of the function will be a value of type <var>V</var>; if not, it will be an empty sequence. The map is therefore substitutable for the function type provided that the function type allows both a value of type <var>V</var> and the empty sequence as possible results.</span><span style="display: none;" class="add_version">To understand this rule, consider the use of a map <code>$M</code> in a function call <code>$M($K)</code>, which is equivalent to the function call <code>map:get($M, $K)</code>. This function accepts any atomic item for the argument <code>$K</code>, and hence matches a function type that requires an argument type of <code>xs:anyAtomicType</code>. If the key <code>$K</code> is present in the map, the result of the function will be a value of type <var>V</var>; if not, it will be the empty sequence. The map is therefore substitutable for the function type provided that the function type allows both a value of type <var>V</var> and the empty sequence as possible results.</span><span class="modify_version">To understand this rule, consider the use of a map <code>$M</code> in a function call <code>$M($K)</code>, which is equivalent to the function call <code>map:get($M, $K)</code>. This function accepts any atomic item for the argument <code>$K</code>, and hence matches a function type that requires an argument type of <code>xs:anyAtomicType</code>. If the key <code>$K</code> is present in the map, the result of the function will be a value of type <var>V</var>; if not, it will be <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. The map is therefore substitutable for the function type provided that the function type allows both a value of type <var>V</var> and the empty sequence as possible results.</span></p><p>The key type <var>K</var> does not enter into this rule. That is because in the function call <code>$M($K)</code>, the sought key <code>$K</code> does not have to be of the same type as the keys actually present in the map.</p><p>The transitivity rules for item type matching mean that if an item <var>M</var> matches a type <var>T</var>, and <var>T</var> is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of <var>U</var>, then <var>M</var> also matches type <var>U</var>. So the fact that a map from integers to strings (<code>map(xs:integer, xs:string)</code>) matches <code>function(xs:anyAtomicType) as xs:string?</code> means that it will also match other function types such as <code>function(xs:integer) as xs:string?</code> and <code>function(xs:decimal) as xs:anyAtomicType?</code></p><p><span style="display: none;" class="delete_version">Furthermore, the rules for <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> mean that any map can be supplied as a value in a context where it does not actually match the required function type, but can be coerced to a function that does. For example a map of type <code>map(xs:integer, xs:string)</code> can be coerced to a function of type <code>function(xs:integer) as xs:string</code>; in this situation a type error will occur only if a call on the function actually returns an empty sequence. </span><span style="display: none;" class="add_version">Furthermore, the rules for <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> mean that any map can be supplied as a value in a context where it does not actually match the required function type, but can be coerced to a function that does. For example a map of type <code>map(xs:integer, xs:string)</code> can be coerced to a function of type <code>function(xs:integer) as xs:string</code>; in this situation a type error will occur only if a call on the function actually returns the empty sequence. </span><span class="modify_version">Furthermore, the rules for <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> mean that any map can be supplied as a value in a context where it does not actually match the required function type, but can be coerced to a function that does. For example a map of type <code>map(xs:integer, xs:string)</code> can be coerced to a function of type <code>function(xs:integer) as xs:string</code>; in this situation a type error will occur only if a call on the function actually returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. </span></p></div><p>Examples:</p><ul><li><p><code>$M instance of fn(*)</code> returns <code>true</code></p></li><li><p><code>$M instance of fn(xs:anyAtomicType) as item()*</code> returns <code>true</code></p></li><li><p><code>$M instance of fn(xs:integer) as item()*</code> returns <code>true</code></p></li><li><p><code>$M instance of fn(xs:int) as item()*</code> returns <code>true</code></p></li><li><p><code>$M instance of fn(xs:string) as item()*</code> returns <code>true</code></p></li><li><p><code>not($M instance of fn(xs:integer) as xs:string)</code> returns <code>true</code></p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The last case might seem surprising; however, <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> ensures that <code>$M</code> can be used successfully anywhere that the required type is <code>fn(xs:integer) as xs:string</code>.</p></div><p>Rules defining whether one map type is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of another are given in <a href="#id-item-subtype-maps"><b>3.3.2.7 Subtyping Maps</b></a>.</p></div><div class="_diffs div4"><h5><a id="id-record-test"></a>3.2.8.3 <a href="#id-record-test" style="text-decoration: none">Record Types</a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-jnode-types">next</a> | <a href="#id-function-test">previous</a>)</p><ol><li><p> Record types are added as a new kind of <code>ItemType</code>, constraining the value space of maps. </p></li><li><p> The syntax <code>record(*)</code> is allowed; it matches any map. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/52">52</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/728">728</a>&nbsp;10 October 2023]</i></p></li><li><p><span style="display: none;" class="delete_version"> The syntax <code>record()</code> is allowed; the only thing it matches is an empty map. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1491">1491</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1577">1577</a>&nbsp;17 October 2024]</i></span><span style="display: none;" class="add_version"> The syntax <code>record()</code> is allowed; the only thing it matches is the empty map. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1491">1491</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1577">1577</a>&nbsp;17 October 2024]</i></span><span class="modify_version"> The syntax <code>record()</code> is allowed; the only thing it matches is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty map. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1491">1491</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1577">1577</a>&nbsp;17 October 2024]</i></span></p></li></ol></div><p>A <a href="#doc-xpath40-RecordType">RecordType</a> matches maps that meet specific criteria.</p><p>For example, the <code>RecordType</code><code>record(r as xs:double, i as xs:double)</code> matches a map if the map has exactly two entries: an entry with key <code>"r"</code> whose value is a <a title="singleton" class="termref" href="#dt-singleton">singleton</a><code>xs:double</code> value, and an entry with key <code>"i"</code> whose value is also a <a title="singleton" class="termref" href="#dt-singleton">singleton</a><code>xs:double</code> value.</p><p>Record types describe a subset of the value space of maps. They do not define any new kinds of values, or any additional operations. They are useful in many cases to describe more accurately the type of a variable, function parameter, or function result, giving benefits both in the readability of the code, and in the ability of the processor to detect and diagnose type errors and to optimize execution.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-RecordType"></a><code><a href="#prod-xpath40-RecordType">RecordType</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-RecordType-AnyRecordType">AnyRecordType</a> | <a href="#doc-xpath40-RecordType-TypedRecordType">TypedRecordType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-RecordType-AnyRecordType"></a><code><a href="#prod-xpath40-AnyRecordType">AnyRecordType</a></code></td><td>::=</td><td><code>"record" "(" "*" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-RecordType-TypedRecordType"></a><code><a href="#prod-xpath40-TypedRecordType">TypedRecordType</a></code></td><td>::=</td><td><code>"record" "(" (<a href="#doc-xpath40-RecordType-FieldDeclaration">FieldDeclaration</a> ** ",") <a href="#doc-xpath40-RecordType-ExtensibleFlag">ExtensibleFlag</a>? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-RecordType-FieldDeclaration"></a><code><a href="#prod-xpath40-FieldDeclaration">FieldDeclaration</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-RecordType-FieldName">FieldName</a> "?"? ("as" <a href="#doc-xpath40-RecordType-SequenceType">SequenceType</a>)?</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-RecordType-FieldName"></a><code><a href="#prod-xpath40-FieldName">FieldName</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-NCName">NCName</a> | <a href="#doc-xpath40-RecordType-StringLiteral">StringLiteral</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-RecordType-StringLiteral"></a><code><a href="#prod-xpath40-StringLiteral">StringLiteral</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-AposStringLiteral">AposStringLiteral</a> | <a href="#prod-xpath40-QuotStringLiteral">QuotStringLiteral</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-RecordType-SequenceType"></a><code><a href="#prod-xpath40-SequenceType">SequenceType</a></code></td><td>::=</td><td><code>("empty-sequence" "(" ")")<br>| (<a href="#doc-xpath40-ItemType">ItemType</a><a href="#prod-xpath40-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-RecordType-ExtensibleFlag"></a><code><a href="#prod-xpath40-ExtensibleFlag">ExtensibleFlag</a></code></td><td>::=</td><td><code>"," "*"</code></td></tr></tbody></table><p>If the list of fields ends with <code>",*"</code> then the record type is said to be <b>extensible</b>. For example, the <code>RecordType</code><code>record(e as element(Employee), *)</code> matches a map if it has an entry with key <code>"e"</code> whose value matches <code>element(Employee)</code>, regardless what other entries the map might contain.</p><p>For generality:</p><ul><li><p>The syntax <code>record()</code> defines a record type that has no explicit fields and that is not extensible. The only thing it matches is an <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-map">empty map</a><sup><small>DM</small></sup>.</p></li><li><p>The syntax <code>record(*)</code> defines an extensible record type that has no explicit field declarations. It is equivalent to the item type <code>map(*)</code>: that is, it matches any map.</p></li></ul><p>A record type can constrain only those entries whose keys are strings, but when the record type is marked as extensible, then other entries may be present in the map with either string or non-string keys. Entries whose key is a string can be expressed using an (unquoted) NCName if the key conforms to NCName syntax, or using a (quoted) string literal otherwise.</p><p>Although constructors for named record types produce a map in which the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-entry-order">entry order</a><sup><small>DM</small></sup> reflects the order of field definitions in the record type definition, the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-entry-order">entry order</a><sup><small>DM</small></sup> of a map has no effect on whether the map matches a particular record type: the entries in a map do not have to be in any particular order.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Lookup expressions have been extended in 4.0 so that non-NCName keys can be used without parentheses: <code>employee?"middle name"</code></p></div><p>If the type declaration for a field is omitted, then <code>item()*</code> is assumed: that is, the map entry may have any type.</p><p>If the field name is followed by a question mark, then the value must have the specified type if it is present, but it may also be absent. For example, the <code>RecordType</code><code>record(first as xs:string, middle? as xs:string, last as xs:string, *)</code> requires the map to have string-valued entries with keys <code>"first"</code> and <code>"last"</code>; it also declares that if the map has an entry with key <code>"middle"</code>, the value of that entry must be a single <code>xs:string</code>. Declaring the type as <code>record(first as xs:string, middle? as xs:string?, last as xs:string, *)</code> also allows the entry with key <code>"middle"</code> to be present but empty.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Within an extensible record type, a <code>FieldDeclaration</code> that is marked optional and has no declared type does not constrain the map in any way, so it serves no practical purpose, but it is permitted because it may have documentary value.</p></div><p>The names of the fields in a record type must be distinct [<a href="#ERRXPST0021" title="err:XPST0021">err:XPST0021</a>].</p><p>If a variable <code>$rec</code> is known to conform to a particular record type, then when a lookup expression <code>$rec?field</code> is used, (a) the processor can report a type error if <code>$rec</code> cannot contain an entry with name <code>field</code> (see <a href="#id-implausible-lookup-expressions"><b>4.14.3.4 Implausible Lookup Expressions</b></a>), and (b) the processor can make static type inferences about the type of value returned by <code>$rec?field</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>(TODO: change function signatures as suggested here!) A number of functions in the standard function library use maps as function arguments; this is a useful technique where the information to be supplied across the interface is highly variable. However, the type signature for such functions typically declares the argument type as <code>map(*)</code>, which gives very little information (and places very few constraints) on the values that are actually passed across. Using record types offers the possibility of improving this: for example, the options argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-parse-json"><code>fn:parse-json</code></a>, previously given as <code>map(*)</code>, can now be expressed as <code>record(liberal? as xs:boolean, duplicates? as xs:string, escape? as xs:boolean, fallback as fn(xs:string) as xs:string, *)</code>. In principle the <code>xs:string</code> type used to describe the <code>duplicates</code> option could also be replaced by a schema-defined subtype of <code>xs:string</code> that enumerates the permitted values (<code>"reject"</code>, <code>"use-first"</code>, <code>"use-last"</code>). </p><p>The use of a record type in the signature of such a function causes the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to be invoked. So, for example, if the function expects an entry in the map to be an <code>xs:double</code> value, it becomes possible to supply a map in which the corresponding entry has type <code>xs:integer</code>.</p><p>Greater precision in defining the types of such arguments also enables better type checking, better diagnostics, better optimization, better documentation, and better syntax-directed editing tools.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>One of the motivations for introducing record types is to enable better pattern matching in XSLT when processing JSON input. With XML input, patterns are often based around XML element names. JSON has no direct equivalent of XML’s element names; matching a JSON object such as <code>{longitude: 130.2, latitude: 53.4}</code> relies instead on recognizing the property names appearing in the object. XSLT 4.0, by integrating record types into pattern matching syntax, allows such an object to be matched with a pattern of the form <code>match="record(longitude, latitude)"</code></p></div><p>Rules defining whether one record type is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of another are given in <a href="#id-item-subtype-records"><b>3.3.2.9 Subtyping Records</b></a>.</p></div></div></div><div class="_diffs div2"><h3><a id="id-sequencetype-subtype"></a>3.3 <a href="#id-sequencetype-subtype" style="text-decoration: none">Subtype Relationships</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-item-subtype-documents">next</a> | <a href="#id-generalized-node-types">previous</a>)</p><ol><li><p>The presentation of the rules for the subtype relationship between sequence types and item types has been substantially rewritten to improve clarity; no change to the semantics is intended.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/196">196</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/202">202</a>&nbsp;25 October 2022]</i></p></li></ol></div><p> [<a id="dt-subtype" title="subtype">Definition</a>: Given two <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a> or <a title="item type" class="termref" href="#dt-item-type">item types</a>, the rules in this section determine if one is a <b>subtype</b> of the other. If a type <var>A</var> is a subtype of type <var>B</var>, it follows that every value matched by <var>A</var> is also matched by <var>B</var>.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The relationship <code>subtype(A, A)</code> is always true: every type is a subtype of itself.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The converse is not necessarily true: we cannot infer that if every value matched by <var>A</var> is also matched by <var>B</var>, then <var>A</var> is a subtype of type <var>B</var>. For example, <var>A</var> might be defined as the set of strings matching the regular expression <code>[A-Z]*</code>, while <var>B</var> is the set of strings matching the regular expression <code>[A-Za-z]*</code>; no subtype relationship holds between these types.</p></div><p>The rules for deciding whether one <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> is a subtype of another are given in <a href="#id-seqtype-subtype"><b>3.3.1 Subtypes of Sequence Types</b></a>. The rules for deciding whether one <a title="item type" class="termref" href="#dt-item-type">item type</a> is a subtype of another are given in <a href="#id-itemtype-subtype"><b>3.3.2 Subtypes of Item Types</b></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The subtype relationship is not acyclic. There are cases where <code>subtype(A, B)</code> and <code>subtype(B, A)</code> are both true. This implies that <var>A</var> and <var>B</var> have the same value space, but they can still be different types. For example this applies when <var>A</var> is a union type with member types <code>xs:string</code> and <code>xs:integer</code>, while <var>B</var> is a union type with member types <code>xs:integer</code> and <code>xs:string</code>. These are different types (<code>"23" cast as A</code> produces a string, while <code>"23" cast as B</code> produces an integer, because casting is attempted to each member type in order) but both types have the same value space. </p></div><div class="_diffs div3"><h4><a id="id-itemtype-subtype"></a>3.3.2 <a href="#id-itemtype-subtype" style="text-decoration: none">Subtypes of Item Types</a></h4><p>We use the notation <code>A ⊆ B</code>, or <code>itemtype-subtype(A, B)</code> to indicate that an <a title="item type" class="termref" href="#dt-item-type">item type</a><code>A</code> is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of an item type <code>B</code>. This section defines the rules for deciding whether any two item types have this relationship.</p><p>The rules in this section apply to <a title="item type" class="termref" href="#dt-item-type">item types</a>, not to <a title="item type designator" class="termref" href="#dt-item-type-designator">item type designators</a>. For example, if the name <code>STR</code> has been defined in the static context as a <a title="named item type" class="termref" href="#dt-named-item-type">named item type</a> referring to the type <code>xs:string</code>, then anything said here about the type <code>xs:string</code> applies equally whether it is designated as <code>xs:string</code> or as <code>STR</code>, or indeed as the parenthesized forms <code>(xs:string)</code> or <code>(STR)</code>.</p><p>References to <a title="named item type" class="termref" href="#dt-named-item-type">named item types</a> are handled as described in <a href="#id-itemtype-subtype-aliases"><b>3.3.2.10 Subtyping of Named Item Types</b></a>.</p><p>The relationship <code>A ⊆ B</code> is true if and only if at least one of the conditions listed in the following subsections applies:</p><div class="_diffs div4"><h5><a id="id-item-subtype-maps"></a>3.3.2.7 <a href="#id-item-subtype-maps" style="text-decoration: none">Subtyping Maps</a></h5><p>Given item types <var>A</var> and <var>B</var>, <code><var>A</var> ⊆ <var>B</var></code> is true if any of the following apply:</p><ol class="enumar"><li><p>Both of the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>map(<var>K</var>, <var>V</var>)</code>, for any <var>K</var> and <var>V</var></p></li><li><p><var>B</var> is <code>map(*)</code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e12972"></a><a id="d2e13012"></a>Example:</div><p><code>map(xs:integer, item()*) ⊆ map(*)</code></p></div></li><li><p>All the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>map(<var>K<sub>a</sub></var>, <var>V<sub>a</sub></var>)</code></p></li><li><p><var>B</var> is <code>map(<var>K<sub>b</sub></var>, <var>V<sub>b</sub></var>)</code></p></li><li><p><code><var>K<sub>a</sub></var> ⊆ <var>K<sub>b</sub></var></code></p></li><li><p><code><var>V<sub>a</sub></var> ⊑ <var>V<sub>b</sub></var></code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e13026"></a><a id="d2e13066"></a>Example:</div><p><code>map(xs:long, item()) ⊆ map(xs:integer, item()+)</code></p></div></li><li><p>Both the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>map(*)</code> (or, because of the transitivity rules, any other map type)</p></li><li><p><var>B</var> is <code>function(*)</code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e13052"></a><a id="d2e13092"></a>Example:</div><p><code>map(xs:long, xs:string?) ⊆ function(*)</code></p></div></li><li><p>Both the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>map(*)</code> (or, because of the transitivity rules, any other map type)</p></li><li><p><var>B</var> is <code>function(xs:anyAtomicType) as item()*</code></p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e13078"></a><a id="d2e13118"></a>Example:</div><p><code>map(xs:long, xs:string?) ⊆ function(xs:anyAtomicType) as item()*</code></p></div></li><li><p>All the following are true:</p><ol class="enumla"><li><p><var>A</var> is <code>map(<var>K</var>, <var>V</var>)</code></p></li><li><p><var>B</var> is <code>function(xs:anyAtomicType) as <var>R</var></code></p></li><li><p><var>V</var> ⊆ <var>R</var></p></li><li><p><code>empty-sequence()</code> ⊆ <var>R</var></p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e13125"></a><a id="d2e13165"></a>Examples:</div><ul><li><p><code>map(xs:int, node()) ⊆ function(xs:anyAtomicType) as node()?</code></p></li><li><p><code>map(xs:int, node()+) ⊆ function(xs:anyAtomicType) as node()*</code></p></li></ul><p>The function accepts type <code>xs:anyAtomicType</code> rather than <code>xs:int</code>, because <code>$M("xyz")</code> is a valid call on a map (treated as a function) even when all the keys in the map are integers.</p><p><span style="display: none;" class="delete_version">The return type of the function is extended from <code>node()</code> or <code>node()+</code> to allow an empty sequence because <code>$M("xyz")</code> can return an empty sequence even if none of the entries in the map contains an empty sequence.</span><span style="display: none;" class="add_version">The return type of the function is extended from <code>node()</code> or <code>node()+</code> to allow the empty sequence because <code>$M("xyz")</code> can return the empty sequence even if none of the entries in the map contains the empty sequence.</span><span class="modify_version">The return type of the function is extended from <code>node()</code> or <code>node()+</code> to allow <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence because <code>$M("xyz")</code> can return <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence even if none of the entries in the map contains <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></div></li></ol></div></div></div><div class="_diffs div2"><h3><a id="id-coercion-rules"></a>3.4 <a href="#id-coercion-rules" style="text-decoration: none">Coercion Rules</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-function-coercion">next</a> | <a href="#id-item-subtype-attributes">previous</a>)</p><ol><li><p> The term "function conversion rules" used in 3.1 has been replaced by the term "coercion rules". <i>&nbsp;&nbsp;[&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/254">254</a>&nbsp;29 November 2022]</i></p></li><li><p> The coercion rules allow “relabeling” of a supplied atomic item where the required type is a derived atomic type: for example, it is now permitted to supply the value 3 when calling a function that expects an instance of <code>xs:positiveInteger</code>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/117">117</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/254">254</a>&nbsp;29 November 2022]</i></p></li><li><p> The coercion rules now allow any numeric type to be implicitly converted to any other, for example an <code>xs:double</code> is accepted where the required type is <code>xs:decimal</code>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/980">980</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/911">911</a>&nbsp;30 January 2024]</i></p></li><li><p> The coercion rules now allow conversion in either direction between <code>xs:hexBinary</code> and <code>xs:base64Binary</code>. <i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/130">130</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/480">480</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/815">815</a>&nbsp;7 November 2023]</i></p></li><li><p> The coercion rules now apply recursively to the members of an array and the entries in a map. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1318">1318</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1501">1501</a>&nbsp;29 October 2024]</i></p></li><li><p> The coercion rules now reorder the entries in a map when the required type is a record type. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1862">1862</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1874">1874</a>&nbsp;25 March 2025]</i></p></li></ol></div><p> [<a id="dt-coercion-rules" title="coercion rules">Definition</a>: The <b>coercion rules</b> are rules used to convert a supplied value to a required type, for example when converting an argument of a function call to the declared type of the function parameter. ] The required type is expressed as a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>. The effect of the coercion rules may be to accept the value as supplied, to convert it to a value that matches the required type, or to reject it with a type error.</p><p>This section defines how the coercion rules operate; the situations in which the rules apply are defined elsewhere, by reference to this section.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In previous versions of this specification, the coercion rules were referred to as the <em>function conversion</em> rules. The terminology has changed because the rules are not exclusively associated with functions or function calling.</p></div><p><span style="display: none;" class="delete_version">If the required type is <code>empty-sequence()</code>, no coercion takes place (the supplied value must be an empty sequence, or a type error occurs).</span><span style="display: none;" class="add_version">If the required type is <code>empty-sequence()</code>, no coercion takes place (the supplied value must be the empty sequence, or a type error occurs).</span><span class="modify_version">If the required type is <code>empty-sequence()</code>, no coercion takes place (the supplied value must be <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, or a type error occurs).</span></p><p>In all other cases, the required <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a><var>T</var> comprises a required <a title="item type" class="termref" href="#dt-item-type">item type</a><var>R</var> and an optional occurrence indicator. The coercion rules are then applied to a supplied value <var>V</var> and the required type <var>T</var> as follows:</p><ol class="enumar"><li class="xpath"><p>If <a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code> and <var>V</var> is not an instance of the required type <var>T</var>, then the conversions defined in <a href="#id-xpath-10-compatibility"><b>3.4.1 XPath 1.0 Compatibility Rules</b></a> are applied to <var>V</var>. Then:</p></li><li><p>Each item in <var>V</var> is processed against the required item type <var>R</var> using the item coercion rules defined in <a href="#id-item-coercion-rules"><b>3.4.2 Item Coercion Rules</b></a>, and the results are sequence-concatenated into a single sequence <var>V′</var>.</p></li><li><p>A type error is raised if the cardinality of <var>V′</var> does not match the required cardinality of <var>T</var> [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li></ol><div class="_diffs div3"><h4><a id="id-item-coercion-rules"></a>3.4.2 <a href="#id-item-coercion-rules" style="text-decoration: none">Item Coercion Rules</a></h4><p>The rules in this section are used to process each item <var>J</var> in a supplied sequence, given a required <a title="item type" class="termref" href="#dt-item-type">item type</a><var>R</var>.</p><ol class="enumar"><li><p>If <var>R</var> is a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a> (for example, if it is an <a title="atomic type" class="termref" href="#dt-atomic-type">atomic type</a>, a <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a>, or an <a title="enumeration type" class="termref" href="#dt-enumeration-type">enumeration type</a>), and <var>J</var> is not an atomic item, then: </p><ol class="enumla"><li><p><var>J</var> is <a title="atomization" class="termref" href="#dt-atomization">atomized</a> to produce a sequence of atomic items <var>JJ</var>.</p></li><li><p>Each atomic item in <var>JJ</var> is coerced to the required type <var>R</var> by recursive application of the item coercion rules (the rules in this section) to produce a value <var>V</var>.</p></li><li><p>The result is the <a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation">sequence concatenation</a> of the <var>V</var> values.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, if <code>J</code> is an element with type annotation <code>xs:integer</code>, and <code>R</code> is the union type <code>xs:numeric</code>, then the effect is to atomize the element to an <code>xs:integer</code>, and then to coerce the resulting <code>xs:integer</code> to <code>xs:numeric</code> (which leaves the integer unchanged). This is not the same as attempting to coerce the element to each of the alternatives of the union type in turn, which would deliver an instance of <code>xs:double</code>.</p></div></li><li><p>Otherwise, if <var>R</var> is a <a title="choice item type" class="termref" href="#dt-choice-item-type">choice item type</a> or a <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a> (which includes the case where it is an <a title="enumeration type" class="termref" href="#dt-enumeration-type">enumeration type</a>), then:</p><ol class="enumla"><li><p>If <var>J</var> matches (is an instance of) one of the alternatives in <var>R</var>, then <var>J</var> is coerced to the first alternative in <var>R</var> that <var>J</var> matches.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>There are two situations where coercing an item to a type that it already matches does not simply return the item unchanged:</p><ul><li><p>When the required type is a typed function type (see <a href="#id-function-test"><b>3.2.8.1 Function Types</b></a>), then function coercion is applied to coerce <var>J</var> to that function type, as described in <a href="#id-function-coercion"><b>3.4.4 Function Coercion</b></a>.</p></li><li><p>When the required type is a record type and the supplied value is a map, then coercion may change the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-entry-order">entry order</a><sup><small>DM</small></sup> of the entries in the map.</p></li></ul></div></li><li><p>Otherwise, the item coercion rules (the rules in this section) are applied to <var>J</var> recursively with <var>R</var> set to each of the alternatives in the choice or union item type, in order, until an alternative is found that does not result in a type error; a type error is raised only if all alternatives fail.</p><p>The error code used in the event of failure should be the error code arising from the first unsuccessful matching attempt. (The diagnostic information associated with the error may also describe how further attempts failed.)</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Suppose the required type is <code>(xs:integer | element(e))*</code> and the supplied value is the sequence <code>(&lt;e&gt;22&lt;/e&gt;, 23, &lt;f&gt;24&lt;/f&gt;)</code>. Item coercion is applied independently to each of the three items in this sequence. The first item matches one of the alternatives, namely <code>element(e)</code>, so it is returned unchanged as an element node. The second item (the integer 23) also matches one of the alternatives, and is returned unchanged as an integer. The third item does not match any of the alternatives, so coercion is attempted to each one in turn. Coercion to type <code>xs:integer</code> succeeds (by virtue of atomization and untyped atomic conversion), so the final result is the sequence <code>(&lt;e&gt;22&lt;/e&gt;, 23, 24)</code></p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Suppose the required type is <code>enum("red", "green", "blue")</code> and the supplied value is <code>"green"</code>. The enumeration type is defined as a choice item type whose alternatives are singleton enumerations, so the rules are applied first to the type <code>enum("red")</code> (which fails), and then to the type <code>enum("green")</code> (which succeeds). The strings in an enumeration type are required to be distinct so the order of checking is in this case immaterial. The supplied value will be accepted, and will be relabeled if necessary as an instance of <code>xs:string</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Schema-defined union types behave in exactly the same way as <a title="choice item type" class="termref" href="#dt-choice-item-type">choice item types.</a></p></div></li><li><p>If <var>R</var> is an <a title="atomic type" class="termref" href="#dt-atomic-type">atomic type</a> and <var>J</var> is an <a title="atomic item" class="termref" href="#dt-atomic-item">atomic item</a>, then:</p><ol class="enumla"><li><p>If <var>J</var> is an instance of <var>R</var> then it is used unchanged.</p></li><li><p>If <var>J</var> is an instance of type <code>xs:untypedAtomic</code> then:</p><ol class="enumlr"><li><p>If <var>R</var> is <a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive">namespace-sensitive</a> then a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a href="#ERRXPTY0117" title="err:XPTY0117">err:XPTY0117</a>] is raised.</p></li><li><p>Otherwise, <var>J</var> is cast to type <var>R</var>.</p></li></ol></li></ol></li><li><p>If there is an entry (<var>from</var>, <var>to</var>) in the following table such that <var>J</var> is an instance of <var>from</var>, and <var>to</var> is <var>R</var>, then <var>J</var> is cast to type <var>R</var>.</p><table style="border:1px solid" class="medium"><caption>Implicit Casting</caption><thead><tr><th>from</th><th>to</th></tr></thead><tbody><tr><td><code>xs:decimal</code></td><td><code>xs:double</code></td></tr><tr><td><code>xs:double</code></td><td><code>xs:decimal</code></td></tr><tr><td><code>xs:decimal</code></td><td><code>xs:float</code></td></tr><tr><td><code>xs:float</code></td><td><code>xs:decimal</code></td></tr><tr><td><code>xs:float</code></td><td><code>xs:double</code></td></tr><tr><td><code>xs:double</code></td><td><code>xs:float</code></td></tr><tr><td><code>xs:string</code></td><td><code>xs:anyURI</code></td></tr><tr><td><code>xs:anyURI</code></td><td><code>xs:string</code></td></tr><tr><td><code>xs:hexBinary</code></td><td><code>xs:base64Binary</code></td></tr><tr><td><code>xs:base64Binary</code></td><td><code>xs:hexBinary</code></td></tr></tbody></table><div class="note"><p class="prefix"><b>Note:</b></p><p>The item type in the <var>to</var> column must match <var>R</var> exactly; however, <var>J</var> may belong to a subtype of the type in the <var>from</var> column.</p><p>For example, an <code>xs:NCName</code> will be cast to type <code>xs:anyURI</code>, but an <code>xs:anyURI</code> will not be cast to type <code>xs:NCName</code>.</p><p>Similarly, an <code>xs:integer</code> will be cast to type <code>xs:double</code>, but an <code>xs:double</code> will not be cast to type <code>xs:integer</code>.</p></div></li><li><p>If <var>R</var> is an <a title="singleton enumeration type" class="termref" href="#dt-singleton-enumeration-type">singleton enumeration type</a> and <var>J</var> is an instance of <code>xs:untypedAtomic</code> or <code>xs:anyURI</code>, then <var>J</var> is cast to type <code>xs:string</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of this rule, when taken in conjunction with the rules above regarding atomization and choice item types, is that when the required type is based on an <a title="enumeration type" class="termref" href="#dt-enumeration-type">enumeration type</a>, for example <code>enum("red", "green", "blue")*</code>, the supplied value can be, in this example:</p><ul><li><p><span class="deltaxml-old" style="background:#FF5555">An</span><span class="deltaxml-new" style="background:#90EE90">The</span> empty sequence.</p></li><li><p>The string <code>"red"</code>.</p></li><li><p>An untyped node whose string value is <code>"red"</code>.</p></li><li><p>A list-valued node whose typed value contains zero or more strings (or <code>xs:anyURI</code> values), each of which is codepoint-equal to one of <code>"red"</code>, <code>"green"</code>, or <code>"blue"</code>.</p></li><li><p>The <code>xs:anyURI</code> value <code>"red"</code>.</p></li><li><p>An array with zero or more members each of which is codepoint-equal to one of <code>"red"</code>, <code>"green"</code>, or <code>"blue"</code>.</p></li><li><p>A JNode whose <b>·content·</b> property is any of the above.</p></li></ul></div></li><li><p>If <var>R</var> is derived from some primitive atomic type <var>P</var>, then <var>J</var> is <b>relabeled</b> as an instance of <var>R</var> if it satisfies all the following conditions:</p><ul><li><p><var>J</var> is an instance of <var>P</var>.</p></li><li><p><var>J</var> is not an instance of <var>R</var>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-datum">datum</a><sup><small>DM</small></sup> of <var>J</var> is within the value space of <var>R</var>.</p></li></ul><p>Relabeling an atomic item changes the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> but not the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-datum">datum</a><sup><small>DM</small></sup>. For example, the <code>xs:integer</code> value 3 can be relabeled as an instance of <code>xs:unsignedByte</code>, because the datum is within the value space of <code>xs:unsignedByte</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Relabeling is not the same as casting. For example, the <code>xs:decimal</code> value 10.1 can be cast to <code>xs:integer</code>, but it cannot be relabeled as <code>xs:integer</code>, because its datum not within the value space of <code>xs:integer</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of this rule is that if, for example, a function parameter is declared with an expected type of <code>xs:positiveInteger</code>, then a call that supplies the literal value 3 will succeed, whereas a call that supplies -3 will fail.</p><p>This differs from previous versions of this specification, where both these calls would fail.</p><p>This change allows the arguments of existing functions to be defined with a more precise type. For example, the <code>$position</code> argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-get"><code>array:get</code></a> could be defined as <code>xs:positiveInteger</code> rather than <code>xs:integer</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>If <var>T</var> is a union type with members <code>xs:negativeInteger</code> and <code>xs:positiveInteger</code> and the supplied value is the sequence <code>(20, -20)</code>, then the effect of these rules is that the first item <code>20</code> is relabeled as type <code>xs:positiveInteger</code> and the second item <code>-20</code>is relabeled as type <code>xs:negativeInteger</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Promotion (for example of <code>xs:float</code> to <code>xs:double</code>) occurs only when <var>T</var> is a primitive type. Relabeling occurs only when <var>T</var> is a derived type. Promotion and relabeling are therefore never combined.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>A <a title="singleton enumeration type" class="termref" href="#dt-singleton-enumeration-type">singleton enumeration type</a> such as <code>enum("green")</code> is treated as an atomic type derived by restriction from <code>xs:string</code>; so if the <code>xs:string</code> value <code>"green"</code> is supplied in a context where the required type is <code>enum("red", "green", "blue")</code>, the value will be accepted.</p></div></li><li><p>If <var>J</var> is a <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-JNode">JNode</a><sup><small>DM</small></sup> and does not match <var>R</var>, then each item in the <b>·content·</b> of <var>J</var> is coerced to type <var>R</var> by applying the coercion rules recursively.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, if <code>$A</code> is an array and the members of the array are maps, then <code>$A/child::*</code> returns a sequence of JNodes that encapsulate maps, and the average size of these maps can be obtained using the expression <code>avg($A/child::* ! map:size(.))</code>. The first argument of <code>map:size</code> does not accept a JNode directly, but it does (in effect) accept a JNode that encapsulates a map.</p></div></li><li><p>If <var>R</var> is an <a href="#doc-xpath40-ArrayType">ArrayType</a> other than <code>array(*)</code> and <var>J</var> is an array, then <var>J</var> is converted to a new array by converting each member to the required member type by applying the coercion rules recursively.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, if the required type is <code>array(xs:double)</code> and the supplied value is <code>[ 1, 2 ]</code>, the array is converted to <code>[ 1e0, 2e0 ]</code>.</p></div></li><li><p>If <var>R</var> is a <a href="#doc-xpath40-MapType">MapType</a> other than <code>map(*)</code> and <var>J</var> is a map, then <var>J</var> is converted to a new map as follows:</p><ol class="enumla"><li><p>Each key in the supplied map is converted to the required map key type by applying the coercion rules. If the resulting map would contain duplicate keys, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>The corresponding value is converted to the required map value type by applying the coercion rules recursively.</p></li><li><p>The order of entries in the map remains unchanged.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, if the required type is <code>map(xs:string, xs:double)</code> and the supplied value is <code>{ "x": 1, "y": 2 }</code>, the map is converted to <code>{ "x": 1e0, "y": 2e0 }</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Duplicate keys can occur if the value space of the target type is more restrictive than the original type. For example, an error is raised if the map <code>{ 1.2: 0, 1.2000001: 0 }</code>, which contains two keys of type <code>xs:decimal</code>, is coerced to the type <code>map(xs:float, xs:integer)</code>.</p></div></li><li><p>If <var>R</var> is a <a href="#doc-xpath40-RecordType">RecordType</a> and <var>J</var> is a map, then <var>J</var> is converted to a new map as follows:</p><ol class="enumla"><li><p>The keys in the supplied map are unchanged.</p></li><li><p>In any map entry whose key is equal to the name of one of the field declarations in <var>R</var> (under the rules of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-atomic-equal"><code>atomic-equal</code></a> function), the corresponding value is converted to the required type defined by that field declaration, by applying the coercion rules recursively (but with XPath 1.0 compatibility mode treated as false).</p></li><li><p>The order of entries in the map is changed: entries whose keys correspond to the names of field declarations in <var>R</var> appear first, in the order of the corresponding field declarations, and (if the record type is extensible) other entries then follow retaining their relative order in <var>J</var>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, if the required type is <code>record(longitude as xs:double, latitude as xs:double)</code> and the supplied value is <code>{ "latitude": 53.2, "longitude": 0 }</code>, then the map is converted to <code>{ "longitude": 0.0e0, "latitude": 53.2e0 }</code>.</p></div></li><li><p>If <var>R</var> is a <a href="#prod-xpath40-TypedFunctionType">TypedFunctionType</a> and <var>J</var> is a function item, then <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> is applied to <var>J</var>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Function coercion applies even if <var>J</var> is already an instance of <var>R</var>.</p><p>Maps and arrays are functions, so function coercion applies to them as well.</p></div></li><li><p> If, after the above conversions, the resulting item does not match the expected item type <var>R</var> according to the rules for <a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching">SequenceType Matching</a>, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Under the general rules for type errors (see <a href="#id-kinds-of-errors"><b>2.5.1 Kinds of Errors</b></a>), a processor <span class="verb">may</span> report a type error during static analysis if it will necessarily occur when the expression is evaluated. For example, the function call <code>fn:abs("beer")</code> will necessarily fail when evaluated, because the function requires a numeric value as its argument; this <span class="verb">may</span> be detected and reported as a static error.</p></div></li></ol></div><div class="_diffs div3"><h4><a id="id-implausible-coercions"></a>3.4.3 <a href="#id-implausible-coercions" style="text-decoration: none">Implausible Coercions</a></h4><p>An expression is deemed to be <a title="implausible" class="termref" href="#dt-implausible">implausible</a> [<a href="#ERRXPTY0006" title="err:XPTY0006">err:XPTY0006</a>] if the static type of the expression, after applying all necessary coercions, is <b>substantively disjoint</b> with the required type <var>T</var>.</p><p> [<a id="dt-substantively-disjoint" title="substantively disjoint">Definition</a>: Two <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a> are deemed to be <b>substantively disjoint</b> if (a) neither is a subtype of the other (see <a href="#id-seqtype-subtype"><b>3.3.1 Subtypes of Sequence Types</b></a>) and (b) the only values that are instances of both types are one or more of the following: </p><ul><li><p>The empty sequence, <code>()</code>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-map">empty map</a><sup><small>DM</small></sup>, <code>{}</code>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-array">empty array</a><sup><small>DM</small></sup>, <code>[]</code>.</p></li></ul><p>]</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Examples of pairs of sequence types that are substantively disjoint include:</p><ul><li><p><code>xs:integer*</code> and <code>xs:string*</code></p></li><li><p><code>map(xs:integer, node())</code> and <code>map(xs:string, node())</code></p></li><li><p><code>array(xs:integer)</code> and <code>array(xs:string)</code></p></li></ul></div><p><span style="display: none;" class="delete_version">For example, supplying a value whose static type is <code>xs:integer*</code> when the required type is <code>xs:string*</code> is <a title="implausible" class="termref" href="#dt-implausible">implausible</a>, because it can succeed only in the special case where the actual value supplied is an empty sequence.</span><span style="display: none;" class="add_version">For example, supplying a value whose static type is <code>xs:integer*</code> when the required type is <code>xs:string*</code> is <a title="implausible" class="termref" href="#dt-implausible">implausible</a>, because it can succeed only in the special case where the actual value supplied is the empty sequence.</span><span class="modify_version">For example, supplying a value whose static type is <code>xs:integer*</code> when the required type is <code>xs:string*</code> is <a title="implausible" class="termref" href="#dt-implausible">implausible</a>, because it can succeed only in the special case where the actual value supplied is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The case where the supplied type and the required type are completely disjoint (for example <code>map(*)</code> and <code>array(*)</code>) is covered by the general rules for type errors: that case can always be reported as a static error.</p></div><p>Examples of implausible coercions include the following:</p><ul><li><p><code>round(timezone-from-time($now))</code>. The result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-timezone-from-time"><code>fn:timezone-from-time</code></a> is of type <code>xs:dayTimeDuration?</code>, which is substantively disjoint with the required type of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-round"><code>fn:round</code></a>, namely <code>xs:numeric?</code>.</p></li><li><p><code>function($x as xs:integer) as array(xs:string) { array { 1 to $x } }</code>. The type of the function body is <code>array(xs:integer)</code>, which is substantively disjoint with the required type <code>array(xs:string)</code>: the function can succeed only in the exceptional case where the function body delivers an <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-array">empty array</a><sup><small>DM</small></sup>.</p></li></ul></div><div class="_diffs div3"><h4><a id="id-function-coercion"></a>3.4.4 <a href="#id-function-coercion" style="text-decoration: none">Function Coercion</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#namespace-declarations">next</a> | <a href="#id-coercion-rules">previous</a>)</p><ol><li><p> Function coercion now allows a function with arity <var>N</var> to be supplied where a function of arity greater than <var>N</var> is expected. For example this allows the function <code>true#0</code> to be supplied where a predicate function is required. </p></li><li><p> It has been clarified that function coercion applies even when the supplied function item matches the required function type. This is to ensure that arguments supplied when calling the function are checked against the signature of the required function type, which might be stricter than the signature of the supplied function item. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1020">1020</a>&nbsp;PRs <a href="https://github.com/qt4cg/qtspecs/pull/1023">1023</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/pull/1128">1128</a>&nbsp;9 April 2024]</i></p></li></ol></div><p> Function coercion is a transformation applied to <a title="function item" class="termref" href="#dt-function-item">function items</a> during application of the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. [<a id="dt-function-coercion" title="function coercion">Definition</a>: <b>Function coercion</b> wraps a <a title="function item" class="termref" href="#dt-function-item">function item</a> in a new function whose signature is the same as the expected type. This effectively delays the checking of the argument and return types until the function is called.] </p><p>Given a function <var>F</var>, and an expected function type <var>T</var>, <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> proceeds as follows:</p><ol class="enumar"><li><p>If <var>F</var> has higher arity than <var>T</var>, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] </p></li><li><p>If <var>F</var> has lower arity than <var>T</var>, then <var>F</var> is wrapped in a new function that declares and ignores the additional argument; the following steps are then applied to this new function.</p><p>For example, if <var>T</var> is <code>function(node(), xs:boolean) as xs:string</code>, and the supplied function is <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-name"><code>fn:name#1</code></a>, then the supplied function is effectively replaced by <code>function($n as node(), $b as xs:boolean) as xs:string { fn:name($n) }</code></p><div class="note"><p class="prefix"><b>Note:</b></p><p>This mechanism makes it easier to design versatile and extensible higher-order functions. For example, in previous versions of this specification, the second argument of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-filter"><code>fn:filter</code></a> function expected an argument of type <code>function(item()) as xs:boolean</code>. This has now been extended to <code>function(item(), xs:integer) as xs:boolean</code>, but existing code continues to work, because callback functions that are not interested in the value of the second argument simply ignore it. </p></div></li><li><p>A type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] if, for any parameter type, or for the result type, the relevant type in the signature of the supplied function and the relevant type in the expected function type are <a title="substantively disjoint" class="termref" href="#dt-substantively-disjoint">substantively disjoint</a>. </p><p>For example, the types <code>xs:integer</code> and <code>xs:string</code> are substantively disjoint, so a function with signature <code>function(xs:integer) as xs:boolean</code> cannot be supplied where the expected type is <code>function(xs:string) as xs:boolean</code>.</p></li><li><p>Function coercion then returns a new <a title="function item" class="termref" href="#dt-function-item">function item</a> with the following properties (as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#function-items">8.1 Function Items</a>): </p><ul><li><p><b>name</b>: The name of <var>F</var><span>(if not absent)</span>. </p></li><li><p><b>identity</b>: A new function identity distinct from the identity of any other function item.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>See also <a href="#id-function-identity"><b>4.6.7 Function Identity</b></a>.</p></div></li><li><p><b>signature</b>: <code>Annotations</code> is set to the annotations of <var>F</var>. <code>TypedFunctionType</code> is set to the expected type. </p></li><li><p><b>implementation</b>: In effect, a <code>FunctionBody</code> that calls <var>F</var>, passing it the parameters of this new function, in order. </p></li><li><p><b>nonlocal variable bindings</b>: An empty mapping. </p></li></ul></li></ol><p> These rules have the following consequences: </p><ul><li><p>SequenceType matching of the function’s arguments and result are delayed until that function is called. </p></li><li><p>When the coerced function is called, the supplied arguments must match the parameter typed defined in <var>T</var>; it is not sufficient to match the parameter types defined in <var>F</var>.</p></li><li><p> The <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> rules applied to the function’s arguments and result are defined by the SequenceType it has most recently been coerced to. Additional coercion rules could apply when the wrapped function is called. </p></li><li><p> If an implementation has static type information about a function, that can be used to type check the function’s argument and return types during static analysis. </p></li><li><p>When function coercion is applied to a map or an array, the resulting function is not a map or array, and cannot be used as such. For example, the expression </p><div class="exampleInner"><pre xml:space="preserve">let $f as function(xs:integer) as xs:boolean := { 0: false(), 1: true() }
return $f?0</pre></div><p>raises a type error, because a lookup expression requires the left hand operand to be a map or array, and <code>$f</code> is neither.</p></li><li><p>When function types are used as alternatives in a <a title="choice item type" class="termref" href="#dt-choice-item-type">choice item type</a>, the supplied function is coerced to the first alternative for which coercion does not raise a type error. In this situation it is important to write the alternatives in order, with the most specific first. </p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p> The semantics of <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> are specified in terms of wrapping the functions. Static typing may be able to reduce the number of places where this is actually necessary. However, it cannot be assumed that because a supplied function is an instance of the required function type, no function coercion is necessary: the supplied function might not perform all required checks on the types of its arguments. </p></div><p>Since maps and arrays are also functions in XPath 4.0, <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> applies to them as well. For instance, consider the following expression: </p><div class="exampleInner"><pre xml:space="preserve">let $m := {
  "Monday" : true(),
  "Wednesday" : false(),
  "Friday" : true()
}
let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
return filter($days, $m)</pre></div><p> The map <code>$m</code> is an instance of <code>function(xs:anyAtomicType?) as item()*</code>. When the <code>fn:filter()</code> function is called, the following occurs to the map: </p><ol class="enumar"><li><p>The map <code>$m</code> is treated as a function equivalent to <code>map:get($m, ?)</code>.</p></li><li><p>The <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> result in applying <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> to this function, wrapping it in a new function (<var>M′</var>) with the signature <code>function(item(), xs:integer) as xs:boolean</code>.</p></li><li><p>When <var>M′</var> is called by <code>fn:filter()</code>, <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion</a> and SequenceType matching rules are applied to the argument, resulting in an <code>item()</code> value (<code>$a</code>) or a type error.</p></li><li><p> The function <code>map:get($m, ?)</code> is called with <code>$a</code> as the argument; this returns either an <code>xs:boolean</code> or the empty sequence (call the result <var>R</var>).</p></li><li><p><span style="display: none;" class="delete_version"> The wrapper function <code>$p</code> applies the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to <var>R</var>. If <var>R</var> is an <code>xs:boolean</code> the matching succeeds. When it is an empty sequence (in particular, <code>$m</code> does not contain a key for <code>"Tuesday"</code>), a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>], since the expected type is <code>xs:boolean</code> and the actual type is an empty sequence.</span><span style="display: none;" class="add_version"> The wrapper function <code>$p</code> applies the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to <var>R</var>. If <var>R</var> is an <code>xs:boolean</code> the matching succeeds. When it is the empty sequence (in particular, <code>$m</code> does not contain a key for <code>"Tuesday"</code>), a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>], since the expected type is <code>xs:boolean</code>, which does not allow the empty sequence.</span><span class="modify_version"> The wrapper function <code>$p</code> applies the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to <var>R</var>. If <var>R</var> is an <code>xs:boolean</code> the matching succeeds. When it is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence (in particular, <code>$m</code> does not contain a key for <code>"Tuesday"</code>), a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>], since the expected type is <code>xs:boolean</code><span class="deltaxml-old" style="background:#FF5555"> and the actual type is an</span><span class="deltaxml-new" style="background:#90EE90">, which does not allow the</span> empty sequence.</span></p></li></ol><p>Consider the following expression: </p><div class="exampleInner"><pre xml:space="preserve">let $m := {
   "Monday" : true(),
   "Wednesday" : false(),
   "Friday" : true(),
}
let $days := ("Monday", "Wednesday", "Friday")
return filter($days, $m)</pre></div><p>In this case the result of the expression is the sequence <code>("Monday", "Friday")</code>. But if the input sequence included the string <code>"Tuesday"</code>, the filter operation would fail with a type error. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Function coercion applies even if the supplied function matches the required type.</p><p>For example, consider this case:</p><div class="exampleInner"><pre xml:space="preserve">declare function local:filter(
  $s as item()*, 
  $p as function(xs:string) as xs:boolean
) as item()* {
  $s[$p(.)]
};

let $f := function($a) { $a mod 2 = 0 }
return local:filter(1 to 10, $f)</pre></div><p>Here the supplied function <code>$f</code> is an instance of the required type, because its signature defaults the argument type to <code>item()*</code>, which is a supertype of <code>xs:string</code>. The expression <code>$s[$p(.)]</code> could in principle succeed. However, function coercion ensures that the supplied function is wrapped in a function that requires the argument to be of type <code>xs:string</code>, so the call fails with a type error when the wrapping function is invoked supplying an <code>xs:integer</code> as the argument.</p></div></div><div class="_diffs div3"><h4><a id="id-coercion-examples"></a>3.4.5 <a href="#id-coercion-examples" style="text-decoration: none">Examples of Coercions</a></h4><p>This section illustrates the effect of the coercion rules with examples.</p><div class="example"><div class="exampleHeader"><a id="eg-coercion-to-string"></a>Example: Coercion to <code>xs:string</code></div><p>Consider the case where the required type (of a variable, or a function argument) is <code>xs:string</code>. For example, the second argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-matches"><code>fn:matches</code></a>, which expects a regular expression. The table below illustrates the values that might be supplied, and the coercions that are applied.</p><table class="medium"><thead><tr><th style="text-align:left">Supplied Value</th><th style="text-align:left">Coercion</th></tr></thead><tbody><tr><td style="vertical-align:top"><code>"[0-9]"</code></td><td style="vertical-align:top"><p>None; the supplied value is an instance of the required type.</p></td></tr><tr><td style="vertical-align:top"><code>default-language()</code></td><td style="vertical-align:top"><p>None; the supplied value is an instance of <code>xs:language</code>, which is a subtype of the required type <code>xs:string</code>.</p></td></tr><tr><td style="vertical-align:top"><code>&lt;a&gt;[0-9]&lt;/a&gt;</code></td><td style="vertical-align:top"><p>The supplied element node is atomized. Unless it has been schema-validated, the typed value will be an instance of <code>xs:untypedAtomic</code>, which is accepted when the required type is <code>xs:string</code>.</p><p>Supplying an element whose type annotation is (say) <code>xs:date</code> will fail with a type error.</p><p class="xpath">The effect is subtly different if XPath 1.0 compatibility mode is enabled. In this case coercion takes the string value of the element node. This differs from the typed value only in the case where the element has been schema-validated and has a type annotation other than <code>xs:string</code>.</p></td></tr><tr><td style="vertical-align:top"><code>xs:anyURI("urn:dummy")</code></td><td style="vertical-align:top"><p>Supplying an instance of <code>xs:anyURI</code> where the expected type is <code>xs:string</code> is permitted; this is one of the pairs of types where implicit casting is allowed.</p></td></tr><tr class="xpath"><td style="vertical-align:top"><code>17.2</code></td><td style="vertical-align:top"><p>Supplying a number where a string is expected raises a type error.</p><p class="xpath">However, if XPath 1.0 compatibility mode is enabled, the number is converted to a string as if by the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-string"><code>fn:string</code></a> function.</p></td></tr><tr class="xpath"><td style="vertical-align:top"><code>//author/@id</code></td><td style="vertical-align:top"><p>Supplying a sequence of nodes where a single string is expected will raise a type error unless either there is only one node in the sequence. In this case the typed value of the node will be used (this must be of type <code>xs:string</code>, <code>xs:untypedAtomic</code>, or <code>xs:anyURI</code>).</p><p class="xpath">If XPath 1.0 compatibility mode is enabled, however, all strings after the first are discarded, and the string value of the first node is used; if the sequence is empty, a zero-length string is supplied.</p></td></tr><tr class="xpath"><td style="vertical-align:top"><code>("red", "green", "blue")</code></td><td style="vertical-align:top"><p>Supplying a sequence of strings where a single string is expected raises a type error.</p><p class="xpath">If XPath 1.0 compatibility mode is enabled, however, all strings after the first are discarded; the effect is as if the supplied value were <code>"red"</code>.</p></td></tr><tr class="xpath"><td style="vertical-align:top"><code>()</code></td><td style="vertical-align:top"><p>Supplying <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence where a single string is expected will fail.</p><p class="xpath">If XPath 1.0 compatibility mode is enabled, however, the value is coerced by applying the function <code>fn:string(())</code>, which delivers the zero-length string.</p></td></tr><tr><td style="vertical-align:top"><code>["a|b"]</code></td><td style="vertical-align:top"><p>Supplying an array holding a single string succeeds, because the rules cause the array to be atomized, and the value after atomization is a single string.</p><p>Supplying an array holding multiple strings would fail.</p><p class="xpath">In XPath 1.0 compatibility mode, supplying an array will fail, regardless of the array contents, because the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-string"><code>fn:string</code></a> function does not accept arrays.</p></td></tr></tbody></table></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="eg-coercion-to-decimal"></a>Example: Coercion to <code>xs:decimal?</code></div><p>Consider the case where the required type (of a variable, or a function argument) is <code>xs:decimal?</code>. For example, the first argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-seconds"><code>fn:seconds</code></a>, which expects a decimal number of seconds. The table below illustrates the values that might be supplied, and the coercions that are applied.</p><table class="medium"><thead><tr><th style="text-align:left">Supplied Value</th><th style="text-align:left">Coercion</th></tr></thead><tbody><tr><td style="vertical-align:top"><code>12.4</code></td><td style="vertical-align:top"><p>None; the supplied value is an instance of the required type.</p></td></tr><tr><td style="vertical-align:top"><code>()</code></td><td style="vertical-align:top"><p>None; <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence is an instance of the required type.</p></td></tr><tr><td style="vertical-align:top"><code>42</code></td><td style="vertical-align:top"><p>None; the supplied value is an instance of <code>xs:integer</code>, which is a subtype of the required type.</p></td></tr><tr><td style="vertical-align:top"><code>math:pi()</code></td><td style="vertical-align:top"><p>The supplied value is an instance of <code>xs:double</code>, which can be converted to <code>xs:decimal</code> under the coercion rules.</p></td></tr><tr><td style="vertical-align:top"><code>("a", "b")[.="c"]</code></td><td style="vertical-align:top"><p><span style="display: none;" class="delete_version">The supplied value is an empty sequence, which is a valid instance of the required type <code>xs:decimal?</code>. However, the processor may (optionally) reject this as an implausible coercion, on the grounds that it can only succeed in one special case, namely where the filter expression selects no values. </span><span style="display: none;" class="add_version">The supplied value is the empty sequence, which is a valid instance of the required type <code>xs:decimal?</code>. However, the processor may (optionally) reject this as an implausible coercion, on the grounds that it can only succeed in one special case, namely where the filter expression selects no values. </span><span class="modify_version">The supplied value is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, which is a valid instance of the required type <code>xs:decimal?</code>. However, the processor may (optionally) reject this as an implausible coercion, on the grounds that it can only succeed in one special case, namely where the filter expression selects no values. </span></p></td></tr><tr><td style="vertical-align:top"><code>(1.5, 2.5, 3.5)</code></td><td style="vertical-align:top"><p>A type error is raised<span class="xpath">, except in the case where XPath 1.0 compatibility is enabled, in which case all values after the first are discarded</span>.</p></td></tr><tr><td style="vertical-align:top"><code>&lt;a&gt;3.14159&lt;/a&gt;</code></td><td style="vertical-align:top"><p>The element node is atomized; unless it has been schema-validated, the result will be <code>"3.14159"</code> as an instance of <code>xs:untypedAtomic</code>. This is converted to an instance of <code>xs:decimal</code> following the rules of the <code>cast as</code> operator.</p></td></tr><tr class="xpath"><td style="vertical-align:top"><code>"12.2"</code></td><td style="vertical-align:top"><p>Supplying a string where an <code>xs:decimal</code> is a type error<span class="xpath">, even if XPath 1.0 compatibility mode is enabled. The rules for compatibility mode would allow conversion if the required type were <code>xs:double</code>, but not for <code>xs:decimal</code></span>. </p></td></tr><tr><td style="vertical-align:top"><code>[1.5]</code></td><td style="vertical-align:top"><p>The array is atomized, and the result is a valid instance of the required type <code>xs:decimal?</code></p></td></tr><tr><td style="vertical-align:top"><code>[]</code></td><td style="vertical-align:top"><p><span style="display: none;" class="delete_version">The array is atomized, and the result is an empty sequence, which is a valid instance of the required type <code>xs:decimal?</code></span><span style="display: none;" class="add_version">The array is atomized, and the result is the empty sequence, which is a valid instance of the required type <code>xs:decimal?</code></span><span class="modify_version">The array is atomized, and the result is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, which is a valid instance of the required type <code>xs:decimal?</code></span></p></td></tr></tbody></table></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="eg-coercion-to-positive-integer"></a>Example: Coercion to <code>xs:positive-integer</code></div><p>Consider the case where the required type (of a variable, or a function argument) is <code>xs:positive-integer</code>. The table below illustrates the values that might be supplied, and the coercions that are applied.</p><table class="medium"><thead><tr><th style="text-align:left">Supplied Value</th><th style="text-align:left">Coercion</th></tr></thead><tbody><tr><td style="vertical-align:top"><code>12</code></td><td style="vertical-align:top"><p>The supplied value is of type <code>xs:integer</code>. Because the supplied value and the required type, <code>xs:positiveInteger</code>, both come under the primitive type <code>xs:decimal</code>, and the value <code>12</code> is within the value space of <code>xs:positiveInteger</code>, the value is relabeled as an <code>xs:positiveInteger</code> and the call succeeds.</p></td></tr><tr><td style="vertical-align:top"><code>12.1</code></td><td style="vertical-align:top"><p>This fails with a type error, because the <code>xs:decimal</code> value <code>12.1</code> is not a value in the value space of <code>xs:positiveInteger</code>. This is so even though casting to <code>xs:positiveInteger</code> would succeed.</p></td></tr><tr><td style="vertical-align:top"><code>math:pi()</code></td><td style="vertical-align:top"><p>This fails with a type error. A value of type <code>xs:double</code> is accepted where the required type is <code>xs:decimal</code> or <code>xs:float</code>, but not where it is <code>xs:positiveInteger</code>.</p></td></tr><tr><td style="vertical-align:top"><code>&lt;a&gt;1200&lt;/a&gt;</code></td><td style="vertical-align:top"><p>The supplied element node is atomized. If the element has not been schema-validated, the result will be an <code>xs:untypedAtomic</code> item, which is successfully cast to the required type <code>xs:positiveInteger</code>. If the element has been validated against a schema, then coercion succeeds if the typed value would itself be acceptable, for example if it is an <code>xs:positiveInteger</code>, or some other <code>xs:decimal</code> within the value space of <code>xs:positiveInteger</code>.</p></td></tr></tbody></table></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="eg-coercion-to-union"></a>Example: Coercion to a union type</div><p>Consider the first parameter of the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-char"><code>fn:char</code></a>, whose declared type is <code>(xs:string | xs:positiveInteger)</code>. The rules are the same as if it were a union typed declared in an imported schema.</p><table class="medium"><thead><tr><th style="text-align:left">Supplied Value</th><th style="text-align:left">Coercion</th></tr></thead><tbody><tr><td style="vertical-align:top"><code>"amp"</code></td><td style="vertical-align:top"><p>The supplied value is of type <code>xs:string</code>, which is one of the allowed types. The call therefore succeeds.</p></td></tr><tr><td style="vertical-align:top"><code>"#"</code></td><td style="vertical-align:top"><p>The supplied value is of type <code>xs:string</code>, which is one of the allowed types. As far as the coercion rules are concerned, the call therefore succeeds. Under the semantic rules for the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-char"><code>fn:char</code></a> function, however, this value is not accepted; a dynamic error (as distinct from a type error) is therefore raised.</p></td></tr><tr><td style="vertical-align:top"><code>0x25</code></td><td style="vertical-align:top"><p>The supplied value is of type <code>xs:integer</code>. Although this is not one of the allowed types, it is acceptable because coercion of the value to type <code>xs:positiveInteger</code> succeeds. The value is relabeled as an instance of <code>xs:positiveInteger</code>.</p></td></tr><tr><td style="vertical-align:top"><code>&lt;a&gt;0x25&lt;/a&gt;</code></td><td style="vertical-align:top"><p>The supplied element node is atomized. Assuming that the node has not been schema-validated, the result is an instance of <code>xs:untypedAtomic</code>. The member types of the choice are tested in order. Conversion to <code>xs:string</code> with the value "0x25" succeeds, so the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-char"><code>fn:char</code></a> function is called supplying this string; but the function rejects this string as semantically invalid. The same would happen if the value were, say, &lt;a&gt;37&lt;/a&gt;. Supplying such a value requires an explicit cast, for example <code>fn:char( xs:positiveInteger( ./a ))</code>.</p></td></tr></tbody></table></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="eg-coercion-to-choice"></a>Example: Coercion to a choice type</div><p>Suppose the required type is <code>(record(x as xs:decimal, y as xs:decimal, *) | record(size as enum("S", "M", "L", "XL"), *))</code>.</p><table class="medium"><thead><tr><th style="text-align:left">Supplied Value</th><th style="text-align:left">Coercion</th></tr></thead><tbody><tr><td style="vertical-align:top"><code>{ "x": 1, "y": 2, "z": 3 }</code></td><td style="vertical-align:top"><p>The supplied value is an instance of the first record type: no coercion is necessary.</p></td></tr><tr><td style="vertical-align:top"><code>{ "size": "M" }</code></td><td style="vertical-align:top"><p>The supplied value is an instance of the second record type: no coercion is necessary.</p></td></tr><tr><td style="vertical-align:top"><code>{ "x": 1, "y": 2, "size": "XL" }</code></td><td style="vertical-align:top"><p>The supplied value is an instance of both record types: no coercion is necessary.</p></td></tr><tr><td style="vertical-align:top"><code>{ "x": 1e0, "y": 2e0, "size": "XL" }</code></td><td style="vertical-align:top"><p>The supplied value is not an instance of the first record type because the fields are of type <code>xs:double</code> rather than <code>xs:decimal</code>. It is however an instance of the second record type. It is therefore accepted <em>as is</em>; the fields <code>x</code> and <code>y</code> are not converted from <code>xs:double</code> to <code>xs:decimal</code>.</p></td></tr><tr><td style="vertical-align:top"><code>{ "x": 1e0, "y": 2e0, "size": "XXL" }</code></td><td style="vertical-align:top"><p>The supplied value is not an instance of the first record type because the fields are of type <code>xs:double</code> rather than <code>xs:decimal</code>, and it is not an instance of the second record type because the <code>size</code> value does not match the enumeration type. Coercion is therefore attempted to the first record type, and succeeds. The <code>x</code> and <code>y</code> fields are coerced to <code>xs:decimal</code>, and the <code>size</code> field is accepted <em>as is</em>.</p></td></tr></tbody></table></div></div></div></div><div class="_diffs div1"><h2><a id="id-expressions"></a>4 <a href="#id-expressions" style="text-decoration: none">Expressions</a></h2><p>This section discusses each of the basic kinds of expression. Each kind of expression has a name such as <code>PathExpr</code>, which is introduced on the left side of the grammar production that defines the expression. Since XPath 4.0 is a composable language, each kind of expression is defined in terms of other expressions whose operators have a higher precedence. In this way, the precedence of operators is represented explicitly in the grammar.</p><p>The order in which expressions are discussed in this document does not reflect the order of operator precedence. In general, this document introduces the simplest kinds of expressions first, followed by more complex expressions. For the complete grammar, see Appendix [<a href="#nt-bnf"><b>A XPath 4.0 Grammar</b></a>].</p><p><span class="xpath">The highest-level symbol in the XPath grammar is XPath.</span></p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-XPath"></a><code><a href="#prod-xpath40-XPath">XPath</a></code></td><td>::=</td><td><code>(<a href="#doc-xpath40-XPath-DefaultElementNamespaceDecl">DefaultElementNamespaceDecl</a> ";")? (<a href="#doc-xpath40-XPath-NamespaceDecl">NamespaceDecl</a> ";")* <a href="#doc-xpath40-XPath-Expr">Expr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-XPath-DefaultElementNamespaceDecl"></a><code><a href="#prod-xpath40-DefaultElementNamespaceDecl">DefaultElementNamespaceDecl</a></code></td><td>::=</td><td><code>"declare" "default" "element" "namespace" <a href="#prod-xpath40-URILiteral">URILiteral</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-XPath-NamespaceDecl"></a><code><a href="#prod-xpath40-NamespaceDecl">NamespaceDecl</a></code></td><td>::=</td><td><code>"declare" "namespace" <a href="#prod-xpath40-NCName">NCName</a> "=" <a href="#prod-xpath40-URILiteral">URILiteral</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-XPath-Expr"></a><code><a href="#prod-xpath40-Expr">Expr</a></code></td><td>::=</td><td><code>(<a href="#doc-xpath40-ExprSingle">ExprSingle</a> ++ ",")</code></td></tr></tbody></table><p class="xpath">The effect of a <a href="#doc-xpath40-DefaultElementNamespaceDecl">DefaultElementNamespaceDecl</a> or <a href="#doc-xpath40-NamespaceDecl">NamespaceDecl</a> is described in <a href="#namespace-declarations"><b>4.1 Namespace Declarations</b></a>.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ExprSingle"></a><code><a href="#prod-xpath40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-ExprSingle-ForExpr">ForExpr</a><br>| <a href="#doc-xpath40-ExprSingle-LetExpr">LetExpr</a><br>| <a href="#doc-xpath40-ExprSingle-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xpath40-ExprSingle-IfExpr">IfExpr</a><br>| <a href="#doc-xpath40-ExprSingle-OrExpr">OrExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ExprSingle-ForExpr"></a><code><a href="#prod-xpath40-ForExpr">ForExpr</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-ForClause">ForClause</a><a href="#prod-xpath40-ForLetReturn">ForLetReturn</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ExprSingle-LetExpr"></a><code><a href="#prod-xpath40-LetExpr">LetExpr</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-LetClause">LetClause</a><a href="#prod-xpath40-ForLetReturn">ForLetReturn</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ExprSingle-QuantifiedExpr"></a><code><a href="#prod-xpath40-QuantifiedExpr">QuantifiedExpr</a></code></td><td>::=</td><td><code>("some" | "every") (<a href="#prod-xpath40-QuantifierBinding">QuantifierBinding</a> ++ ",") "satisfies" <a href="#doc-xpath40-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ExprSingle-IfExpr"></a><code><a href="#prod-xpath40-IfExpr">IfExpr</a></code></td><td>::=</td><td><code>"if" "(" <a href="#doc-xpath40-Expr">Expr</a> ")" (<a href="#prod-xpath40-UnbracedActions">UnbracedActions</a> | <a href="#prod-xpath40-BracedAction">BracedAction</a>)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ExprSingle-OrExpr"></a><code><a href="#prod-xpath40-OrExpr">OrExpr</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-AndExpr">AndExpr</a> ("or" <a href="#prod-xpath40-AndExpr">AndExpr</a>)*</code></td></tr></tbody></table><p>The XPath 4.0 operator that has lowest precedence is the <a title="comma operator" class="termref" href="#dt-comma-operator">comma operator</a>, which is used to combine two operands to form a sequence. As shown in the grammar, a general expression (<a href="#doc-xpath40-Expr">Expr</a>) can consist of multiple <a href="#doc-xpath40-ExprSingle">ExprSingle</a> operands, separated by commas.</p><p>The name <a href="#doc-xpath40-ExprSingle">ExprSingle</a> denotes an expression that does not contain a top-level <a title="comma operator" class="termref" href="#dt-comma-operator">comma operator</a> (despite its name, an <a href="#doc-xpath40-ExprSingle">ExprSingle</a> may evaluate to a sequence containing more than one item.)</p><p>The symbol <a href="#doc-xpath40-ExprSingle">ExprSingle</a> is used in various places in the grammar where an expression is not allowed to contain a top-level comma. For example, each of the arguments of a function call must be a <a href="#doc-xpath40-ExprSingle">ExprSingle</a>, because commas are used to separate the arguments of a function call.</p><p>After the comma, the expressions that have next lowest precedence are <span class="xpath"><a href="#doc-xpath40-ForExpr">ForExpr</a>, <a href="#doc-xpath40-LetExpr">LetExpr</a>, </span><a href="#doc-xpath40-QuantifiedExpr">QuantifiedExpr</a>, <a href="#doc-xpath40-IfExpr">IfExpr</a>, and <a href="#doc-xpath40-OrExpr">OrExpr</a>. Each of these expressions is described in a separate section of this document.</p><div class="_diffs div2"><h3><a id="id-primary-expressions"></a>4.3 <a href="#id-primary-expressions" style="text-decoration: none">Primary Expressions</a></h3><p> [<a id="dt-primary-expression" title="primary expression">Definition</a>: A <b>primary expression</b> is an instance of the production <a href="#doc-xpath40-PrimaryExpr">PrimaryExpr</a>. Primary expressions are the basic primitives of the language. They include literals, variable references, context value references, and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.] Map and Array Constructors are described in <a href="#id-maps"><b>4.14.1 Maps</b></a> and <a href="#id-arrays"><b>4.14.2 Arrays</b></a>. </p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-PrimaryExpr"></a><code><a href="#prod-xpath40-PrimaryExpr">PrimaryExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-PrimaryExpr-Literal">Literal</a><br>| <a href="#doc-xpath40-PrimaryExpr-VarRef">VarRef</a><br>| <a href="#doc-xpath40-PrimaryExpr-ParenthesizedExpr">ParenthesizedExpr</a><br>| <a href="#doc-xpath40-PrimaryExpr-ContextValueRef">ContextValueRef</a><br>| <a href="#doc-xpath40-PrimaryExpr-FunctionCall">FunctionCall</a><br>| <a href="#doc-xpath40-PrimaryExpr-FunctionItemExpr">FunctionItemExpr</a><br>| <a href="#doc-xpath40-PrimaryExpr-MapConstructor">MapConstructor</a><br>| <a href="#doc-xpath40-PrimaryExpr-ArrayConstructor">ArrayConstructor</a><br>| <a href="#doc-xpath40-PrimaryExpr-StringTemplate">StringTemplate</a><br>| <a href="#doc-xpath40-PrimaryExpr-UnaryLookup">UnaryLookup</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-PrimaryExpr-Literal"></a><code><a href="#prod-xpath40-Literal">Literal</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-NumericLiteral">NumericLiteral</a> | <a href="#doc-xpath40-StringLiteral">StringLiteral</a> | <a href="#doc-xpath40-QNameLiteral">QNameLiteral</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-PrimaryExpr-VarRef"></a><code><a href="#prod-xpath40-VarRef">VarRef</a></code></td><td>::=</td><td><code>"$" <a href="#doc-xpath40-EQName">EQName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-PrimaryExpr-ParenthesizedExpr"></a><code><a href="#prod-xpath40-ParenthesizedExpr">ParenthesizedExpr</a></code></td><td>::=</td><td><code>"(" <a href="#doc-xpath40-Expr">Expr</a>? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-PrimaryExpr-ContextValueRef"></a><code><a href="#prod-xpath40-ContextValueRef">ContextValueRef</a></code></td><td>::=</td><td><code>"."</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-PrimaryExpr-FunctionCall"></a><code><a href="#prod-xpath40-FunctionCall">FunctionCall</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-EQName">EQName</a><a href="#prod-xpath40-ArgumentList">ArgumentList</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a> */</td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-parens">gn: parens</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-PrimaryExpr-FunctionItemExpr"></a><code><a href="#prod-xpath40-FunctionItemExpr">FunctionItemExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-PrimaryExpr-NamedFunctionRef">NamedFunctionRef</a> | <a href="#doc-xpath40-PrimaryExpr-InlineFunctionExpr">InlineFunctionExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-PrimaryExpr-NamedFunctionRef"></a><code><a href="#prod-xpath40-NamedFunctionRef">NamedFunctionRef</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-EQName">EQName</a> "#" <a href="#prod-xpath40-IntegerLiteral">IntegerLiteral</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-PrimaryExpr-InlineFunctionExpr"></a><code><a href="#prod-xpath40-InlineFunctionExpr">InlineFunctionExpr</a></code></td><td>::=</td><td><code>("function" | "fn") <a href="#prod-xpath40-FunctionSignature">FunctionSignature</a>? <a href="#prod-xpath40-FunctionBody">FunctionBody</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-PrimaryExpr-MapConstructor"></a><code><a href="#prod-xpath40-MapConstructor">MapConstructor</a></code></td><td>::=</td><td><code>"map"? "{" (<a href="#prod-xpath40-MapConstructorEntry">MapConstructorEntry</a> ** ",") "}"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-PrimaryExpr-ArrayConstructor"></a><code><a href="#prod-xpath40-ArrayConstructor">ArrayConstructor</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-SquareArrayConstructor">SquareArrayConstructor</a> | <a href="#prod-xpath40-CurlyArrayConstructor">CurlyArrayConstructor</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-PrimaryExpr-StringTemplate"></a><code><a href="#prod-xpath40-StringTemplate">StringTemplate</a></code></td><td>::=</td><td><code>"`" (<a href="#prod-xpath40-StringTemplateFixedPart">StringTemplateFixedPart</a> | <a href="#prod-xpath40-StringTemplateVariablePart">StringTemplateVariablePart</a>)* "`"</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-PrimaryExpr-UnaryLookup"></a><code><a href="#prod-xpath40-UnaryLookup">UnaryLookup</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-Lookup">Lookup</a></code></td></tr></tbody></table><div class="_diffs div3"><h4><a id="id-paren-expressions"></a>4.3.4 <a href="#id-paren-expressions" style="text-decoration: none">Parenthesized Expressions</a></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ParenthesizedExpr"></a><code><a href="#prod-xpath40-ParenthesizedExpr">ParenthesizedExpr</a></code></td><td>::=</td><td><code>"(" <a href="#doc-xpath40-ParenthesizedExpr-Expr">Expr</a>? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ParenthesizedExpr-Expr"></a><code><a href="#prod-xpath40-Expr">Expr</a></code></td><td>::=</td><td><code>(<a href="#doc-xpath40-ExprSingle">ExprSingle</a> ++ ",")</code></td></tr></tbody></table><p>Parentheses may be used to override the precedence rules. For example, the expression <code>(2 + 4) * 5</code> evaluates to thirty, since the parenthesized expression <code>(2 + 4)</code> is evaluated first and its result is multiplied by five. Without parentheses, the expression <code>2 + 4 * 5</code> evaluates to twenty-two, because the multiplication operator has higher precedence than the addition operator.</p><p>Empty parentheses are used to denote <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, as described in <a href="#construct_seq"><b>4.8.1 Sequence Concatenation</b></a>.</p></div></div><div class="_diffs div2"><h3><a id="id-functions"></a>4.6 <a href="#id-functions" style="text-decoration: none">Functions</a></h3><p>Functions in XPath 4.0 arise in two ways:</p><ul><li><p>A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> contains information about a family of functions with the same name and a defined arity range. These functions are in most cases known statically (they appear in the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a>), but there may be further function definitions that are known only dynamically (appearing in the <a title="dynamically known function definitions" class="termref" href="#dt-dynamically-known-function-definitions">dynamically known function definitions</a>).</p></li><li><p><a title="function item" class="termref" href="#dt-function-item">Function items</a> are XDM items that can be called using a <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a>. They are values that can be bound to variables, passed as arguments, returned as function results, and generally manipulated in the same way as other XDM values.</p></li></ul><p>The functions defined by a statically known <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> can be invoked using a <a title="static function call" class="termref" href="#dt-static-function-call">static function call</a>. <a title="function item" class="termref" href="#dt-function-item">Function items</a> corresponding to these definitions can also be obtained, as dynamic values, by evaluating a <a title="named function reference" class="termref" href="#dt-named-function-ref">named function reference</a>. <a title="function item" class="termref" href="#dt-function-item">Function items</a> can also be obtained using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>fn:function-lookup</code></a> function: in this case the function name and arity do not need to be known statically, and the function definition need not be present in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, so long as it is in the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a>.</p><p>Static and dynamic function calls are described in the following sections.</p><div class="_diffs div3"><h4><a id="id-static-functions"></a>4.6.1 <a href="#id-static-functions" style="text-decoration: none">Static Function Calls</a></h4><p>The <a title="static context" class="termref" href="#dt-static-context">static context</a> for an expression includes a set of <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a>. Every <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the static context has a name (which is an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>) and an <a title="arity range" class="termref" href="#dt-arity-range">arity range</a>, which is a range of permitted arities for calls on that function. Two <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> having the same name must not have overlapping arity ranges. This means that for a given static function call, it is possible to identify the target function definition in the static context unambiguously from knowledge of the function name and the number of supplied arguments.</p><p>A <a title="static function call" class="termref" href="#dt-static-function-call">static function call</a> is bound to a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the static context by matching the name and arity. If the function call has <var>P</var> positional arguments followed by <var>K</var> keyword arguments, then the required arity is <var>P+K</var>, and the static context must include a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> whose name matches the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> in the function call, and whose <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> includes this required arity. This is the function chosen to be called. The result of the function is obtained by evaluating the expression that forms its implementation, with a dynamic context that provides values for all the declared parameters, initialized as described in <a href="#id-eval-static-function-call"><b>4.6.1.2 Evaluating Static Function Calls</b></a> below.</p><p>Similarly, a <a title="named function reference" class="termref" href="#dt-named-function-ref">named function reference</a> of the form <code>f#N</code> binds to a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the static context whose name matches <var>f</var> where <code>MinP ≤ N and MaxP ≥ N</code>. The result of evaluating a function reference is a <a title="function item" class="termref" href="#dt-function-item">function item</a> which can be called using a dynamic function call. Function items are never variadic and their arguments are always supplied positionally. For example, the function reference <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-concat"><code>fn:concat#3</code></a> returns a function item with arity 3, which is always called by supplying three positional arguments, and whose effect is the same as a static call on <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-concat"><code>fn:concat</code></a> with three positional arguments. </p><p>The detailed rules for evaluating static function calls and function references are defined in subsequent sections.</p><div class="_diffs div4"><h5><a id="id-function-calls"></a>4.6.1.1 <a href="#id-function-calls" style="text-decoration: none">Static Function Call Syntax</a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-eval-dynamic-function-call">next</a> | <a href="#id-filter-expression">previous</a>)</p><ol><li><p> Keyword arguments are allowed on static function calls, as well as positional arguments. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/155">155</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/159">159</a>&nbsp;30 September 2020]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-FunctionCall"></a><code><a href="#prod-xpath40-FunctionCall">FunctionCall</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-FunctionCall-EQName">EQName</a><a href="#doc-xpath40-FunctionCall-ArgumentList">ArgumentList</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-reserved-function-names">xgc: reserved-function-names</a> */</td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-parens">gn: parens</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-FunctionCall-EQName"></a><code><a href="#prod-xpath40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-QName">QName</a> | <a href="#prod-xpath40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-FunctionCall-ArgumentList"></a><code><a href="#prod-xpath40-ArgumentList">ArgumentList</a></code></td><td>::=</td><td><code>"(" ((<a href="#doc-xpath40-FunctionCall-PositionalArguments">PositionalArguments</a> ("," <a href="#doc-xpath40-FunctionCall-KeywordArguments">KeywordArguments</a>)?) | <a href="#doc-xpath40-FunctionCall-KeywordArguments">KeywordArguments</a>)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-FunctionCall-PositionalArguments"></a><code><a href="#prod-xpath40-PositionalArguments">PositionalArguments</a></code></td><td>::=</td><td><code>(<a href="#doc-xpath40-FunctionCall-Argument">Argument</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-FunctionCall-Argument"></a><code><a href="#prod-xpath40-Argument">Argument</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-FunctionCall-ExprSingle">ExprSingle</a> | <a href="#doc-xpath40-FunctionCall-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-FunctionCall-ExprSingle"></a><code><a href="#prod-xpath40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-ForExpr">ForExpr</a><br>| <a href="#doc-xpath40-LetExpr">LetExpr</a><br>| <a href="#doc-xpath40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xpath40-IfExpr">IfExpr</a><br>| <a href="#doc-xpath40-OrExpr">OrExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-FunctionCall-ArgumentPlaceholder"></a><code><a href="#prod-xpath40-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td><td>::=</td><td><code>"?"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-FunctionCall-KeywordArguments"></a><code><a href="#prod-xpath40-KeywordArguments">KeywordArguments</a></code></td><td>::=</td><td><code>(<a href="#doc-xpath40-FunctionCall-KeywordArgument">KeywordArgument</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-FunctionCall-KeywordArgument"></a><code><a href="#prod-xpath40-KeywordArgument">KeywordArgument</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-FunctionCall-EQName">EQName</a> ":=" <a href="#doc-xpath40-FunctionCall-Argument">Argument</a></code></td></tr></tbody></table><p> [<a id="dt-static-function-call" title="static function call">Definition</a>: A <b>static function call</b> is an instance of the production <a href="#doc-xpath40-FunctionCall">FunctionCall</a>: it consists of an EQName followed by a parenthesized list of zero or more arguments.].</p><p>The EQName is expanded using the <a title="default function namespace rule" class="termref" href="#dt-default-function-namespace-rule">default function namespace rule</a>.</p><p>The argument list consists of zero or more positional arguments, followed by zero or more keyword arguments.</p><p> [<a id="dt-arg-expr" title="argument expression">Definition</a>: An argument to a function call is either an <b>argument expression</b> or an <a href="#prod-xpath40-ArgumentPlaceholder">ArgumentPlaceholder</a> (<code>?</code>); in both cases it may either be supplied positionally, or identified by a name (called a keyword).] </p><p>This section is concerned with static function calls in which none of the arguments are <a href="#prod-xpath40-ArgumentPlaceholder">ArgumentPlaceholders</a>. Calls using one or more <a href="#prod-xpath40-ArgumentPlaceholder">ArgumentPlaceholders</a> are covered in the section <a href="#id-partial-function-application"><b>4.6.4 Partial Function Application</b></a>.</p><p>The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> used as the function name and the number of arguments used in the static function call (the required arity) must match the name and arity range of a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a><span> using the rules defined in the previous section</span>; if there is no match, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>]. </p><p>Evaluation of static function calls is described in <a href="#id-eval-static-function-call"><b>4.6.1.2 Evaluating Static Function Calls</b></a> .</p><p>Since the arguments of a function call are separated by commas, any <a title="argument expression" class="termref" href="#dt-arg-expr">argument expression</a> that contains a top-level <a title="comma operator" class="termref" href="#dt-comma-operator">comma operator</a> must be enclosed in parentheses. Here are some illustrative examples of static function calls:</p><ul><li><p><code>my:three-argument-function(1, 2, 3)</code> denotes a static function call with three <span>positional</span> arguments. <span>The corresponding function declaration must define at least three parameters, and may define more, provided they are optional.</span></p></li><li><p><code>my:two-argument-function((1, 2), 3)</code> denotes a static function call with two arguments, the first of which is a sequence of two values. <span>The corresponding function declaration must define at least two parameters, and may define more, provided they are optional.</span></p></li><li><p><span style="display: none;" class="delete_version"><code>my:two-argument-function(1, ())</code> denotes a static function call with two arguments, the second of which is an empty sequence.</span><span style="display: none;" class="add_version"><code>my:two-argument-function(1, ())</code> denotes a static function call with two arguments, the second of which is the empty sequence.</span><span class="modify_version"><code>my:two-argument-function(1, ())</code> denotes a static function call with two arguments, the second of which is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p><code>my:one-argument-function((1, 2, 3))</code> denotes a static function call with one argument that is a sequence of three values. </p></li><li><p><span style="display: none;" class="delete_version"><code>my:one-argument-function(( ))</code> denotes a static function call with one argument that is an empty sequence.</span><span style="display: none;" class="add_version"><code>my:one-argument-function(( ))</code> denotes a static function call with one argument that is the empty sequence.</span><span class="modify_version"><code>my:one-argument-function(( ))</code> denotes a static function call with one argument that is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p><code>my:zero-argument-function( )</code> denotes a static function call with zero arguments.</p></li><li><p><code>lang(node := $n, language := 'de')</code> is a static function call with two keyword arguments. The corresponding function declaration defines two parameters, a required parameter <code>language</code> and an optional parameter <code>node</code>. This call supplies values for both parameters. It is equivalent to the call <code>fn:lang('de', $n)</code>. Note that the keyword arguments are in a different order from the parameter declarations. </p></li><li><p><code>sort(//employee, key := fn($e) { xs:decimal($e/salary) })</code> is a static function call with one positional argument and one keyword argument. The corresponding function declaration defines three parameters, a required parameter <code>$input</code>, an optional parameter <code>$collation</code>, and an optional parameter <code>$key</code> This call supplies values for the first and third parameters, leaving the second parameter (<code>$collation</code>) to take its default value. The default value of the <code>$collation</code> parameter is given as <code>fn:default-collation()</code>, so the value supplied to the function is the default collation from the dynamic context of the caller. It is equivalent to the call <code>fn:sort(//employee, fn:default-collation(), fn($e) { xs:decimal($e/salary) })</code>. </p></li></ul><p>An <code>EQName</code> in a <code>KeywordArgument</code> is expanded using the <a title="no-namespace rule" class="termref" href="#dt-no-namespace-rule">no-namespace rule</a>. The keywords used in a function call (after expansion) must be distinct [<a href="#ERRXPST0017" title="err:XPST0017">err:XPST0017</a>].</p></div></div><div class="_diffs div3"><h4><a id="id-dynamic-function-invocation"></a>4.6.3 <a href="#id-dynamic-function-invocation" style="text-decoration: none">Dynamic Function Calls</a></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-DynamicFunctionCall"></a><code><a href="#prod-xpath40-DynamicFunctionCall">DynamicFunctionCall</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-DynamicFunctionCall-PostfixExpr">PostfixExpr</a><a href="#doc-xpath40-DynamicFunctionCall-PositionalArgumentList">PositionalArgumentList</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-DynamicFunctionCall-PostfixExpr"></a><code><a href="#prod-xpath40-PostfixExpr">PostfixExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-PrimaryExpr">PrimaryExpr</a> | <a href="#doc-xpath40-FilterExpr">FilterExpr</a> | <a href="#doc-xpath40-DynamicFunctionCall">DynamicFunctionCall</a> | <a href="#doc-xpath40-LookupExpr">LookupExpr</a> | <a href="#doc-xpath40-MethodCall">MethodCall</a> | <a href="#doc-xpath40-FilterExprAM">FilterExprAM</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-DynamicFunctionCall-PositionalArgumentList"></a><code><a href="#prod-xpath40-PositionalArgumentList">PositionalArgumentList</a></code></td><td>::=</td><td><code>"(" <a href="#doc-xpath40-DynamicFunctionCall-PositionalArguments">PositionalArguments</a>? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-DynamicFunctionCall-PositionalArguments"></a><code><a href="#prod-xpath40-PositionalArguments">PositionalArguments</a></code></td><td>::=</td><td><code>(<a href="#doc-xpath40-DynamicFunctionCall-Argument">Argument</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-DynamicFunctionCall-Argument"></a><code><a href="#prod-xpath40-Argument">Argument</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-DynamicFunctionCall-ExprSingle">ExprSingle</a> | <a href="#doc-xpath40-DynamicFunctionCall-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-DynamicFunctionCall-ExprSingle"></a><code><a href="#prod-xpath40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-ForExpr">ForExpr</a><br>| <a href="#doc-xpath40-LetExpr">LetExpr</a><br>| <a href="#doc-xpath40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xpath40-IfExpr">IfExpr</a><br>| <a href="#doc-xpath40-OrExpr">OrExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-DynamicFunctionCall-ArgumentPlaceholder"></a><code><a href="#prod-xpath40-ArgumentPlaceholder">ArgumentPlaceholder</a></code></td><td>::=</td><td><code>"?"</code></td></tr></tbody></table><p> A <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a> consists of a base expression that returns the function and a parenthesized list of zero or more arguments (<a title="argument expression" class="termref" href="#dt-arg-expr">argument expressions</a> or ArgumentPlaceholders). </p><p> A dynamic function call is evaluated as described in <a href="#id-eval-dynamic-function-call"><b>4.6.3.1 Evaluating Dynamic Function Calls</b></a>. </p><p>The following are examples of dynamic function calls:</p><ul><li><p>This example calls the function contained in <code>$f</code>, passing the arguments 2 and 3: </p><div class="exampleInner"><pre xml:space="preserve">$f(2, 3)</pre></div></li><li><p>This example fetches the second item from sequence <code>$f</code>, treats it as a function and calls it, passing an <code>xs:string</code> argument: </p><div class="exampleInner"><pre xml:space="preserve">$f[2]("Hi there")</pre></div></li><li><p>This example calls the function <code>$f</code> passing no arguments, and filters the result with a positional predicate: </p><div class="exampleInner"><pre xml:space="preserve">$f()[2]</pre></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>Arguments in a dynamic function call are always supplied positionally.</p></div><div class="_diffs div4"><h5><a id="id-eval-dynamic-function-call"></a>4.6.3.1 <a href="#id-eval-dynamic-function-call" style="text-decoration: none">Evaluating Dynamic Function Calls</a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-inline-func">next</a> | <a href="#id-function-calls">previous</a>)</p><ol><li><p><span style="display: none;" class="delete_version">A dynamic function call can now be applied to a sequence of functions, and in particular to an empty sequence. This makes it easier to chain a sequence of calls.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1240">1240</a>&nbsp;]</i></span><span style="display: none;" class="add_version">A dynamic function call can now be applied to a sequence of functions, and in particular to the empty sequence. This makes it easier to chain a sequence of calls.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1240">1240</a>&nbsp;]</i></span><span class="modify_version">A dynamic function call can now be applied to a sequence of functions, and in particular to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. This makes it easier to chain a sequence of calls.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1240">1240</a>&nbsp;]</i></span></p></li></ol></div><p>This section applies to dynamic function calls whose arguments do not include an <code>ArgumentPlaceholder</code>. For function calls that include a placeholder, see <a href="#id-partial-function-application"><b>4.6.4 Partial Function Application</b></a>.</p><p>A <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a> is an expression that is evaluated by calling a <a title="function item" class="termref" href="#dt-function-item">function item</a>, which is typically obtained dynamically.</p><p> When a dynamic function call <var>FC</var> is evaluated, the result is obtained as follows: </p><ol class="enumar"><li><p> The base expression of the function call is evaluated. If this is not of type <code>function(*)*</code> (a sequence of zero or more function items) then a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. </p></li><li><p>The result of the dynamic function call is the <a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation">sequence concatenation</a> of the results of applying each function item individually, retaining order. That is, the result of <code><var>F</var>(<var>X</var>, <var>Y</var>, ...)</code> is <code>for $FI in <var>F</var> return <var>$FI</var>(<var>X</var>, <var>Y</var>, ...)</code>. The result of a dynamic function call applied to a single function item <var>FI</var> is defined by the rules that follow. </p></li><li><p> [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. If the arity of <var>FI</var> does not match the number of arguments in the <code>ArgumentList</code>, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. </p></li><li><p><a title="argument expression" class="termref" href="#dt-arg-expr">Argument expressions</a> are evaluated, producing <b>argument values</b>. The order of argument evaluation is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> and an argument need not be evaluated if the function body can be evaluated without evaluating that argument.</p></li><li><p> Each argument value is converted to the corresponding parameter type in <var>FI</var>’s signature by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>, resulting in a <b>converted argument value</b></p></li><li><p>If <var>FI</var> is a map, it is evaluated as described in <a href="#id-map-lookup"><b>4.14.1.2 Maps as Functions</b></a>.</p></li><li><p>If <var>FI</var> is an array, it is evaluated as described in <a href="#id-array-lookup"><b>4.14.2.2 Arrays as Functions</b></a>.</p></li><li><p> If <var>FI</var>’s <span>body</span> is an XPath 4.0 expression (for example, if <var>FI</var> is an <a title="anonymous function" class="termref" href="#dt-anonymous-function">anonymous function</a>, or a <a title="partially applied function" class="termref" href="#dt-partially-applied-function">partial application</a> of such a function): </p><ol class="enumla"><li><p><var>FI</var>’s <span>body</span> is evaluated. The static context for this evaluation is the static context of the XPath 4.0 expression. The dynamic context for this evaluation is obtained by taking the dynamic context of the <span class="xpath"><code>InlineFunctionExpr</code></span> that contains the <code>FunctionBody</code>, and making the following changes: </p><ul><li><p> The <a title="focus" class="termref" href="#dt-focus">focus</a> (context value, context position, and context size) is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM</small></sup>. </p></li><li><p> In the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a> component of the dynamic context, each converted argument value is bound to the corresponding parameter name. </p><p><span>When this is done, the converted argument values retain their <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic types</a>, even where these are <a title="subtype" class="termref" href="#dt-subtype">subtypes</a> of the declared parameter types.</span> For example, a function with a parameter <code>$p</code> of type <code>xs:decimal</code> can be called with an argument of type <code>xs:integer</code>, which is derived from <code>xs:decimal</code>. During the processing of this function call, the value of <code>$p</code> inside the body of the function retains its <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> of <code>xs:integer</code>. </p></li><li><p><var>FI</var>’s nonlocal variable bindings are also added to the <a title="variable values" class="termref" href="#dt-variable-values">variable values</a>. (Note that the names of the nonlocal variables are by definition disjoint from the parameter names, so there can be no conflict.) </p></li></ul></li><li><p> The value returned by evaluating the function body is then converted to the declared return type of <var>FI</var> by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. The result is then the result of evaluating <var>FC</var>. </p><p> As with argument values, the value returned by a function retains its <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a>, which may be a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of the declared return type of <var>FI</var>. For example, a function that has a declared return type of <code>xs:decimal</code> may in fact return a value of dynamic type <code>xs:integer</code>. </p></li></ol></li><li><p> If the implementation of <var>FI</var> is not an XPath 4.0 expression (for example, if <var>FI</var> is a <a title="system function" class="termref" href="#dt-system-function">system function</a> ), the <span>body</span> of the function is evaluated, and the result is converted to the declared return type, in the same way as for a static function call (see <a href="#id-function-calls"><b>4.6.1.1 Static Function Call Syntax</b></a>).</p><p>Errors may be raised in the same way.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e19680"></a><a id="d2e19720"></a>Example: Derived Types and Nonlocal Variable Bindings</div><p><code>$incr</code> is a nonlocal variable that is available within the function because its variable binding has been added to the variable values of the function. Even though the parameter and return type of this function are both <code>xs:decimal</code>, the more specific type <code>xs:integer</code> is preserved in both cases.</p><div class="exampleInner"><pre xml:space="preserve">let $incr := 1
let $f := function($i as xs:decimal) as xs:decimal { $i + $incr }
return $f(5)</pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d2e19695"></a><a id="d2e19735"></a>Example: Using the Context Value in an Anonymous Function</div><p>The following example will raise a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a href="#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>]:</p><div class="exampleInner"><pre xml:space="preserve">let $vat := function() { @vat + @price }
return doc('wares.xml')/shop/article/$vat()</pre></div><p>Instead, the context value can be used as an argument to the anonymous function:</p><div class="exampleInner"><pre xml:space="preserve">let $vat := function($art) { $art/@vat + $art/@price }
return doc('wares.xml')/shop/article/$vat(.)</pre></div><p>Alternatively, the value can be referenced as a nonlocal variable binding:</p><div class="exampleInner"><pre xml:space="preserve">let $ctx := doc('wares.xml')/shop/article
let $vat := function() { for $a in $ctx return $a/@vat + $a/@price }
return $vat()</pre></div><p>Finally, a <a title="focus function" class="termref" href="#dt-focus-function">focus function</a> can be used. This binds the value of the argument to the context value within the function body:</p><div class="exampleInner"><pre xml:space="preserve">let $vat := function { @vat + @price }
return $vat(doc('wares.xml')/shop/article)</pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d2e19717"></a><a id="d2e19757"></a>Example: Applying multiple functions</div><p>A dynamic function call can call zero or more functions with the same arguments, returning the <a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation">sequence concatenation</a> of the result. For example:</p><div class="exampleInner"><pre xml:space="preserve">(abs#1, round#1, floor#1, ceiling#1)(3.2)</pre></div><p>returns the sequence <code>(3.2, 3, 3, 4)</code>.</p><p>A common case for supplying a sequence of functions arises when the functions are arrays. For example:</p><div class="exampleInner"><pre xml:space="preserve">csv-to-arrays( string-join(("a,b,c", "p,q,r", "x,y,z"), char(10)) ) (2)</pre></div><p>returns the sequence <code>("b", "q", "y")</code>.</p><p>If the base expression evaluates to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Keyword arguments are not allowed in a dynamic function call.</p></div></div></div></div><div class="_diffs div2"><h3><a id="id-path-expressions"></a>4.7 <a href="#id-path-expressions" style="text-decoration: none">Path Expressions</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#axes">next</a> | <a href="#id-inline-func">previous</a>)</p><ol><li><p> Path expressions are extended to handle JNodes (found in trees of maps and arrays) as well as XNodes (found in trees representing parsed XML). <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2054">2054</a>&nbsp;]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-PathExpr"></a><code><a href="#prod-xpath40-PathExpr">PathExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-PathExpr-AbsolutePathExpr">AbsolutePathExpr</a><br>| <a href="#doc-xpath40-PathExpr-RelativePathExpr">RelativePathExpr</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-leading-lone-slash">xgc: leading-lone-slash</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-PathExpr-AbsolutePathExpr"></a><code><a href="#prod-xpath40-AbsolutePathExpr">AbsolutePathExpr</a></code></td><td>::=</td><td><code>("/" <a href="#doc-xpath40-PathExpr-RelativePathExpr">RelativePathExpr</a>?) | ("//" <a href="#doc-xpath40-PathExpr-RelativePathExpr">RelativePathExpr</a>)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-PathExpr-RelativePathExpr"></a><code><a href="#prod-xpath40-RelativePathExpr">RelativePathExpr</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-StepExpr">StepExpr</a> (("/" | "//") <a href="#prod-xpath40-StepExpr">StepExpr</a>)*</code></td></tr></tbody></table><p> [<a id="dt-path-expression" title="path expression">Definition</a>: A <b>path expression</b> is either an <a title="absolute path expression" class="termref" href="#dt-absolute-path-expression">absolute path expression</a> or a <a title="relative path expression" class="termref" href="#dt-relative-path-expression">relative path expression</a> ] </p><p> [<a id="dt-absolute-path-expression" title="absolute path expression">Definition</a>: An <b>absolute path expression</b> is an instance of the production <a href="#prod-xpath40-AbsolutePathExpr">AbsolutePathExpr</a>: it consists of either (a) the operator <code>/</code> followed by zero or more operands separated by <code>/</code> or <code>//</code> operators, or (b) the operator <code>//</code> followed by one or more operands separated by <code>/</code> or <code>//</code> operators.] </p><p> [<a id="dt-relative-path-expression" title="relative path expression">Definition</a>: A <b>relative path expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production <a href="#doc-xpath40-RelativePathExpr">RelativePathExpr</a>: it consists of two or more operand expressions separated by <code>/</code> or <code>//</code> operators.] </p><p> [<a id="dt-step" title="step">Definition</a>: The operands of a path expression are conventionally referred to as <b>steps</b>.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The term <b>step</b> must not be confused with <a title="axis step" class="termref" href="#dt-axis-step">axis step</a>. A <b>step</b> can be any kind of expression, often but not necessarily an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a>, while an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a> can be used in any expression context, not necessarily as a <a title="step" class="termref" href="#dt-step">step</a> in a path expression.</p></div><p>A path expression is typically used to locate <a title="GNode" class="termref" href="#dt-GNode">GNodes</a> within <a title="GTree" class="termref" href="#dt-GTree">GTrees</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Note the terminology:</p><ul><li><p>A <a title="GNode" class="termref" href="#dt-GNode">GNode</a> is a generalized node, either an <a title="XNode" class="termref" href="#dt-XNode">XNode</a> or a <a title="JNode" class="termref" href="#dt-JNode">JNode</a>.</p></li><li><p>A <a title="GTree" class="termref" href="#dt-GTree">GTree</a> is a generalized tree, either an <a title="XTree" class="termref" href="#dt-XTree">XTree</a> or a <a title="JTree" class="termref" href="#dt-JTree">JTree</a>.</p></li></ul></div><p>The following definitions are copied from the data model specification, for convenience:</p><ul><li><p> [<a id="dt-JTree" title="JTree">Definition</a>: A tree that is rooted at a parentless <a title="JNode" class="termref" href="#dt-JNode">JNode</a> is referred to as a <b>JTree</b>.] </p></li><li><p> [<a id="dt-XTree" title="XTree">Definition</a>: A tree that is rooted at a parentless <a title="XNode" class="termref" href="#dt-XNode">XNode</a> is referred to as an <b>XTree</b>.] </p></li><li><p><span class="deltaxml-old" style="background:#FF5555"> [</span><a id="dt-GNode" title="GNode"><span class="deltaxml-old" style="background:#FF5555">Definition</span></a><span class="deltaxml-old" style="background:#FF5555">: The term </span><b><span class="deltaxml-old" style="background:#FF5555">generic node</span></b><span class="deltaxml-old" style="background:#FF5555"> or </span><b><span class="deltaxml-old" style="background:#FF5555">GNode</span></b><span class="deltaxml-old" style="background:#FF5555"> is a collective term for </span><a class="termref" title="XNode" href="#dt-XNode"><span class="deltaxml-old" style="background:#FF5555">XNodes</span></a><span class="deltaxml-old" style="background:#FF5555"> (more commonly called simply </span><a title="node" class="termref" href="#dt-node"><span class="deltaxml-old" style="background:#FF5555">nodes</span></a><span class="deltaxml-old" style="background:#FF5555">) representing the parts of an XML document, and </span><a title="JNode" class="termref" href="#dt-JNode"><span class="deltaxml-old" style="background:#FF5555">JNodes</span></a><span class="deltaxml-old" style="background:#FF5555">, often used to represent the parts of a JSON document.] </span></p><p><span class="deltaxml-new" style="background:#90EE90"> [</span><a id="dt-GTree" title="GTree"><span class="deltaxml-new" style="background:#90EE90">Definition</span></a><span class="deltaxml-new" style="background:#90EE90">: The term </span><b><span class="deltaxml-new" style="background:#90EE90">GTree</span></b><span class="deltaxml-new" style="background:#90EE90"> means </span><a title="JTree" class="termref" href="#dt-JTree"><span class="deltaxml-new" style="background:#90EE90">JTree</span></a><span class="deltaxml-new" style="background:#90EE90"> or </span><a class="termref" title="XTree" href="#dt-XTree"><span class="deltaxml-new" style="background:#90EE90">XTree</span></a><span class="deltaxml-new" style="background:#90EE90">.] </span></p></li><li class="delete_version" style="display: none;"><p> [<a id="dt-JNode" title="JNode">Definition</a>: A <b>JNode</b> is a kind of <a title="item" class="termref" href="#dt-item">item</a> used to represent a value within the context of a tree of <a title="map" class="termref" href="#dt-map">maps</a> and <a title="array" class="termref" href="#dt-array">arrays</a>. A root <b>JNode</b> represents a map or array; a non-root <b>JNode</b> represents a <a title="member" class="termref" href="#dt-member">member</a> of an array or an <a title="entry" class="termref" href="#dt-entry">entry</a> in a map.] </p></li><li class="modify_version"><p><span class="deltaxml-old" style="background:#FF5555"> [</span><a id="dt-JNode" title="JNode"><span class="deltaxml-old" style="background:#FF5555">Definition</span></a><span class="deltaxml-old" style="background:#FF5555">: A </span><b><span class="deltaxml-old" style="background:#FF5555">JNode</span></b><span class="deltaxml-old" style="background:#FF5555"> is a kind of </span><a title="item" class="termref" href="#dt-item"><span class="deltaxml-old" style="background:#FF5555">item</span></a><span class="deltaxml-old" style="background:#FF5555"> used to represent a value within the context of a tree of </span><a title="map" class="termref" href="#dt-map"><span class="deltaxml-old" style="background:#FF5555">maps</span></a><span class="deltaxml-old" style="background:#FF5555"> and </span><a title="array" class="termref" href="#dt-array"><span class="deltaxml-old" style="background:#FF5555">arrays</span></a><span class="deltaxml-old" style="background:#FF5555">. A root </span><b><span class="deltaxml-old" style="background:#FF5555">JNode</span></b><span class="deltaxml-old" style="background:#FF5555"> represents a map or array; a non-root </span><b><span class="deltaxml-old" style="background:#FF5555">JNode</span></b><span class="deltaxml-old" style="background:#FF5555"> represents a </span><a title="member" class="termref" href="#dt-member"><span class="deltaxml-old" style="background:#FF5555">member</span></a><span class="deltaxml-old" style="background:#FF5555"> of an array or an </span><a title="entry" class="termref" href="#dt-entry"><span class="deltaxml-old" style="background:#FF5555">entry</span></a><span class="deltaxml-old" style="background:#FF5555"> in a map.] </span></p></li></ul><p><span class="deltaxml-old" style="background:#FF5555"> [</span><a id="dt-GTree" title="GTree"><span class="deltaxml-old" style="background:#FF5555">Definition</span></a><span class="deltaxml-old" style="background:#FF5555">: The term </span><b><span class="deltaxml-old" style="background:#FF5555">GTree</span></b><span class="deltaxml-old" style="background:#FF5555"> means </span><a title="JTree" class="termref" href="#dt-JTree"><span class="deltaxml-old" style="background:#FF5555">JTree</span></a><span class="deltaxml-old" style="background:#FF5555"> or </span><a title="XTree" class="termref" href="#dt-XTree"><span class="deltaxml-old" style="background:#FF5555">XTree</span></a><span class="deltaxml-old" style="background:#FF5555">.] </span></p><p><a title="absolute path expression" class="termref" href="#dt-absolute-path-expression">Absolute path expressions</a> (those starting with an initial <code>/</code> or <code>//</code>), start their selection from the root GNode of a GTree; relative path expressions (those without a leading <code>/</code> or <code>//</code>) start from the <a title="context value" class="termref" href="#dt-context-value">context value</a>.</p><div class="_diffs div3"><h4><a id="id-axis-steps"></a>4.7.5 <a href="#id-axis-steps" style="text-decoration: none">Axis Steps</a></h4><a id="d2e21847"></a><a id="d2e21845"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AxisStep"></a><code><a href="#prod-xpath40-AxisStep">AxisStep</a></code></td><td>::=</td><td><code>(<a href="#doc-xpath40-AxisStep-AbbreviatedStep">AbbreviatedStep</a> | <a href="#doc-xpath40-AxisStep-FullStep">FullStep</a>) <a href="#doc-xpath40-AxisStep-Predicate">Predicate</a>*</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AxisStep-AbbreviatedStep"></a><code><a href="#prod-xpath40-AbbreviatedStep">AbbreviatedStep</a></code></td><td>::=</td><td><code>".." | ("@" <a href="#doc-xpath40-AxisStep-NodeTest">NodeTest</a>) | <a href="#prod-xpath40-SimpleNodeTest">SimpleNodeTest</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AxisStep-FullStep"></a><code><a href="#prod-xpath40-FullStep">FullStep</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-AxisStep-Axis">Axis</a><a href="#doc-xpath40-AxisStep-NodeTest">NodeTest</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AxisStep-Axis"></a><code><a href="#prod-xpath40-Axis">Axis</a></code></td><td>::=</td><td><code>("ancestor" | "ancestor-or-self" | "attribute" | "child" | "descendant" | "descendant-or-self" | "following" | "following-or-self" | "following-sibling" | "following-sibling-or-self" | "namespace" | "parent" | "preceding" | "preceding-or-self" | "preceding-sibling" | "preceding-sibling-or-self" | "self") "::"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AxisStep-NodeTest"></a><code><a href="#prod-xpath40-NodeTest">NodeTest</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-UnionNodeTest">UnionNodeTest</a> | <a href="#prod-xpath40-SimpleNodeTest">SimpleNodeTest</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AxisStep-Predicate"></a><code><a href="#prod-xpath40-Predicate">Predicate</a></code></td><td>::=</td><td><code>"[" <a href="#doc-xpath40-Expr">Expr</a> "]"</code></td></tr></tbody></table><p> [<a id="dt-axis-step" title="axis step">Definition</a>: An <b>axis step</b> is an instance of the production <a href="#doc-xpath40-AxisStep">AxisStep</a>: it is an expression that returns a sequence of GNodes that are reachable from a starting GNode via a specified axis. An axis step has three parts: an <b>axis</b>, which defines the direction of movement for the step, a <a title="node test" class="termref" href="#dt-node-test">node test</a>, which selects GNodes based on their properties, and zero or more predicates which are used to filter the results.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>An <a title="axis step" class="termref" href="#dt-axis-step">axis step</a> is an expression in its own right. While axis steps are often used as the operands of <a title="path expression" class="termref" href="#dt-path-expression">path expressions</a>, they can also appear in other contexts (without a <code>/</code> or <code>//</code> operator); equally, the operands of a path expression can be any expression, not restricted to an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a>.</p></div><p>If the context value for an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a> includes a map or array, this is implicitly converted to a JNode as if by applying the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-jtree"><code>fn:jtree</code></a> function. If, after this conversion, the sequence contains a value that is not a GNode, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0020" title="err:XPTY0020">err:XPTY0020</a>]. The result of evaluating the axis step is a sequence of zero or more GNodes.</p><p>The <a title="axis step" class="termref" href="#dt-axis-step">axis step</a><code>S</code> is equivalent to <code>./S</code>. Thus, if the context value is a sequence containing multiple GNodes, the semantics of a <a title="axis step" class="termref" href="#dt-axis-step">axis step</a> are equivalent to a <a title="path expression" class="termref" href="#dt-path-expression">path expression</a> in which the step is always applied to a single GNode. The following description therefore explains the semantics for the case where the context value is a single GNode, called the <b>origin</b>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The equivalence of a <a title="axis step" class="termref" href="#dt-axis-step">axis step</a><code>S</code> to the <a title="path expression" class="termref" href="#dt-path-expression">path expression</a><code>./S</code> means that the resulting GNode sequence is returned in <a title="document order" class="termref" href="#dt-document-order">document order</a>.</p></div><p>In the <b>abbreviated syntax</b> for a step, the axis can be omitted and other shorthand notations can be used as described in <a href="#abbrev"><b>4.7.8 Abbreviated Syntax</b></a>.</p><p>The unabbreviated syntax for an axis step consists of the axis name and node test separated by a double colon. The result of the step consists of the GNodes reachable from the origin via the specified axis that match the node test. For example, the step <code>child::para</code> selects the <code>para</code> element children of the origin XNode: <code>child</code> is the name of the axis, and <code>para</code> is the name of the element nodes to be selected on this axis. The available axes are described in <a href="#axes"><b>4.7.5.1 Axes</b></a>. The available node tests are described in <a href="#node-tests"><b>4.7.5.2 Node Tests</b></a>. Examples of steps are provided in <a href="#unabbrev"><b>4.7.7 Unabbreviated Syntax</b></a> and <a href="#abbrev"><b>4.7.8 Abbreviated Syntax</b></a>.</p><div class="_diffs div4"><h5><a id="axes"></a>4.7.5.1 <a href="#axes" style="text-decoration: none">Axes</a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#node-tests">next</a> | <a href="#id-path-expressions">previous</a>)</p><ol><li><p> Four new axes have been defined: <code>preceding-or-self</code>, <code>preceding-sibling-or-self</code>, <code>following-or-self</code>, and <code>following-sibling-or-self</code>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1519">1519</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1532">1532</a>&nbsp;29 October 2024]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-Axis"></a><code><a href="#prod-xpath40-Axis">Axis</a></code></td><td>::=</td><td><code>("ancestor" | "ancestor-or-self" | "attribute" | "child" | "descendant" | "descendant-or-self" | "following" | "following-or-self" | "following-sibling" | "following-sibling-or-self" | "namespace" | "parent" | "preceding" | "preceding-or-self" | "preceding-sibling" | "preceding-sibling-or-self" | "self") "::"</code></td></tr></tbody></table><p>An axis is essentially a function that takes a GNode (the origin) as input, and delivers a sequence of GNodes (always from within the same GTree as the origin) as its result.</p><p class="xpath">XPath defines a set of <b>axes</b> for traversing documents, but a <b>host language</b> may define a subset of these axes. The following axes are defined:</p><ul><li><p>The <code>child</code> axis contains the children of the origin.</p><p>If the origin is an XNode, these are the XNodes returned by the <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-children">7.6.3 children Accessor</a> accessor. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>In an XTree, only document nodes and element nodes have children. If the origin is any other kind of XNode, or if the origin is an empty document or element node, then the child axis returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. The children of a document node or element node may be element, processing instruction, comment, or text nodes. Attribute, namespace, and document nodes can never appear as children.</p></div><p>If the origin is a JNode, these are the JNodes returned by the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-j-children">j-children</a><sup><small>DM</small></sup> accessor.</p></li><li><p>The <code>descendant</code> axis is defined as the transitive closure of the child axis; it contains the descendants of the origin (the children, the children of the children, and so on).</p><p>More formally, <code>$node/descendant::gnode()</code> delivers the result of <code>fn:transitive-closure($node, fn { child::gnode() })</code>.</p></li><li><p>The <code>descendant-or-self</code> axis contains the origin and the descendants of the origin.</p><p>More formally, <code>$node/descendant-or-self::gnode()</code> delivers the result of <code>$node/(. | descendant::gnode())</code>.</p></li><li><p>The <code>parent</code> axis returns the parent of the origin.</p><p>If the origin is an XNode, this is the result of the <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-parent">7.6.11 parent Accessor</a> accessor.</p><p>If the origin is a JNode, this is the value of the <b>·parent·</b> property of the origin.</p><p>If the GNode has no parent, the axis returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An attribute node may have an element node as its parent, even though the attribute node is not a child of the element node.</p></div></li><li><p>The <code>ancestor</code> axis is defined as the transitive closure of the parent axis; it contains the ancestors of the origin (the parent, the parent of the parent, and so on).</p><p>More formally, <code>$node/ancestor::gnode()</code> delivers the result of <code>fn:transitive-closure($node, fn { parent::gnode() })</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The ancestor axis includes the root GNode of the GTree in which the origin is found, unless the origin is itself the root GNode.</p></div></li><li><p>The <code>ancestor-or-self</code> axis contains the origin and the ancestors of the origin; thus, the ancestor-or-self axis will always include the root.</p><p>More formally, <code>$node/ancestor-or-self::gnode()</code> delivers the result of <code>$node/(. | ancestor::gnode())</code>.</p></li><li><p>The <code>following-sibling</code> axis returns the origin’s following siblings, that is, those children of the origin’s parent that occur after the origin in <a title="document order" class="termref" href="#dt-document-order">document order</a>. If the origin is an attribute or namespace node, the <code>following-sibling</code> axis is empty.</p><p>More formally, <code>$node/following-sibling::gnode()</code> delivers the result of <code>fn:siblings($node)[. &gt;&gt; $node])</code>.</p></li><li><p>The <code>following-sibling-or-self</code> axis contains the origin, together with the contents of the <code>following-sibling</code> axis.</p><p>More formally, <code>$node/following-sibling-or-self::gnode()</code> delivers the result of <code>fn:siblings($node)[not(. &lt;&lt; $node)]</code></p></li><li><p>The <code>preceding-sibling</code> axis returns the origin’s preceding siblings, that is, those children of the origin’s parent that occur before the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a>. If the origin is an attribute or namespace node, the <code>preceding-sibling</code> axis is empty.</p><p>More formally, <code>$node/preceding-sibling::gnode()</code> delivers the result of <code>fn:siblings($node)[. &lt;&lt; $node]</code>.</p></li><li><p>The <code>preceding-sibling-or-self</code> axis contains the origin, together with the contents of the <code>preceding-sibling</code> axis.</p><p>More formally, <code>$node/preceding-sibling-or-self::gnode()</code> delivers the result of <code>fn:siblings($node)[not(. &gt;&gt; $node)</code>.</p></li><li><p>The <code>following</code> axis contains all descendants of the root of the GTree in which the origin is found, are not descendants of the origin, and occur after the origin in <a title="document order" class="termref" href="#dt-document-order">document order</a>. </p><p>More formally, <code>$node/following::gnode()</code> delivers the result of <code>$node/ancestor-or-self::gnode()/following-sibling::gnode()/descendant-or-self::gnode()</code></p></li><li><p>The <code>following-or-self</code> axis contains the origin, together with the contents of the <code>following</code> axis.</p><p>More formally, <code>$node/following-or-self::gnode()</code> delivers the result of <code>$node/(. | following::gnode())</code>.</p></li><li><p>The <code>preceding</code> axis returns all descendants of the root of the GTree in which the origin is found, are not ancestors of the origin, and occur before the origin in <a title="document order" class="termref" href="#dt-document-order">document order</a>. </p><p>More formally, <code>$node/preceding::gnode()</code> delivers the result of <code>$node/ancestor-or-self::gnode()/preceding-sibling::gnode()/descendant-or-self::gnode()</code>.</p></li><li><p>The <code>preceding-or-self</code> axis returns the origin, together with the contents of the <code>preceding</code> axis.</p><p>More formally, <code>$node/preceding-or-self::gnode()</code> delivers the result of <code>$node/(. | preceding::gnode())</code>.</p></li><li><p>The <code>attribute</code> axis is defined only for XNodes. It returns the attributes of the origin, which are the nodes returned by the <span><a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-attributes">7.6.1 attributes Accessor</a></span>; the axis will be empty unless the context node is an element.</p><p>If the <code>attribute</code> axis is applied to a JNode, a type error [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] is raised.</p></li><li><p>The <code>self</code> axis contains just the origin itself.</p><p>The <code>self</code> axis is primarily useful when testing whether the origin satisfies particular conditions, for example <code>if ($x[self::chapter])</code>.</p><p>More formally, <code>$node/self::gnode()</code> delivers the result of <code>$node</code>.</p></li><li class="xpath"><p>The <code>namespace</code> axis is defined only for XNodes. It returns the namespace nodes of the origin, which are the nodes returned by the <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-namespace-nodes">7.6.7 namespace-nodes Accessor</a>; this axis is empty unless the origin is an element node. The <code>namespace</code> axis is deprecated as of XPath 2.0. If <a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code>, the <code>namespace</code> axis must be supported. If <a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>false</code>, then support for the <code>namespace</code> axis is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. An implementation that does not support the <code>namespace</code> axis when <a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>false</code> must raise a <a title="static error" class="termref" href="#dt-static-error">static error</a> [<a href="#ERRXPST0010" title="err:XPST0010">err:XPST0010</a>] if it is used. Applications needing information about the <a title="in-scope namespaces" class="termref" href="#dt-in-scope-namespaces">in-scope namespaces</a> of an element should use the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-in-scope-namespaces"><code>fn:in-scope-namespaces</code></a>. </p><p>If the <code>namespace</code> axis is applied to a JNode, a type error [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] is raised.</p></li></ul><p>Axes can be categorized as <b>forward axes</b> and <b>reverse axes</b>. An axis that only ever contains the origin or nodes that are after the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a> is a forward axis. An axis that only ever contains the context node or nodes that are before the context node in <a title="document order" class="termref" href="#dt-document-order">document order</a> is a reverse axis.</p><p>The <code>parent</code>, <code>ancestor</code>, <code>ancestor-or-self</code>, <code>preceding</code>, <code>preceding-or-self</code>, <code>preceding-sibling</code>, and <code>preceding-sibling-or-self</code> axes are reverse axes; all other axes are forward axes.</p><p>The <code>ancestor</code>, <code>descendant</code>, <code>following</code>, <code>preceding</code> and <code>self</code> axes partition a GTree (ignoring attribute <span class="xpath">and namespace</span> nodes): they do not overlap and together they contain all the GNodes in the GTree.</p><p> [<a id="dt-principal-node-kind" title="principal node kind">Definition</a>: Every axis has a <b>principal node kind</b>. If an axis can contain elements, then the principal node kind is element; otherwise, it is the kind of nodes that the axis can contain.] Thus:</p><ul><li><p>For the attribute axis, the principal node kind is attribute.</p></li><li class="xpath"><p>For the namespace axis, the principal node kind is namespace.</p></li><li><p>For all other axes, the principal node kind is element.</p></li></ul></div><div class="_diffs div4"><h5><a id="id-type-tests"></a>4.7.5.5 <a href="#id-type-tests" style="text-decoration: none">Type Tests</a></h5><p>A type test is a node test that selects JNodes or XNodes based on their type.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest"></a><code><a href="#prod-xpath40-TypeTest">TypeTest</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-TypeTest-NodeKindTest">NodeKindTest</a> | <a href="#doc-xpath40-TypeTest-JNodeType">JNodeType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-NodeKindTest"></a><code><a href="#prod-xpath40-NodeKindTest">NodeKindTest</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-TypeTest-DocumentTest">DocumentTest</a><br>| <a href="#doc-xpath40-TypeTest-ElementTest">ElementTest</a><br>| <a href="#doc-xpath40-TypeTest-AttributeTest">AttributeTest</a><br>| <a href="#doc-xpath40-TypeTest-SchemaElementTest">SchemaElementTest</a><br>| <a href="#doc-xpath40-TypeTest-SchemaAttributeTest">SchemaAttributeTest</a><br>| <a href="#doc-xpath40-TypeTest-PITest">PITest</a><br>| <a href="#doc-xpath40-TypeTest-CommentTest">CommentTest</a><br>| <a href="#doc-xpath40-TypeTest-TextTest">TextTest</a><br>| <a href="#doc-xpath40-TypeTest-NamespaceNodeTest">NamespaceNodeTest</a><br>| <a href="#doc-xpath40-TypeTest-AnyNodeKindTest">AnyNodeKindTest</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-DocumentTest"></a><code><a href="#prod-xpath40-DocumentTest">DocumentTest</a></code></td><td>::=</td><td><code>"document-node" "(" (<a href="#doc-xpath40-TypeTest-ElementTest">ElementTest</a> | <a href="#doc-xpath40-TypeTest-SchemaElementTest">SchemaElementTest</a> | <a href="#doc-xpath40-TypeTest-NameTestUnion">NameTestUnion</a>)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-ElementTest"></a><code><a href="#prod-xpath40-ElementTest">ElementTest</a></code></td><td>::=</td><td><code>"element" "(" (<a href="#doc-xpath40-TypeTest-NameTestUnion">NameTestUnion</a> ("," <a href="#prod-xpath40-TypeName">TypeName</a> "?"?)?)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-SchemaElementTest"></a><code><a href="#prod-xpath40-SchemaElementTest">SchemaElementTest</a></code></td><td>::=</td><td><code>"schema-element" "(" <a href="#prod-xpath40-ElementName">ElementName</a> ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-NameTestUnion"></a><code><a href="#prod-xpath40-NameTestUnion">NameTestUnion</a></code></td><td>::=</td><td><code>(<a href="#doc-xpath40-TypeTest-NameTest">NameTest</a> ++ "|")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-NameTest"></a><code><a href="#prod-xpath40-NameTest">NameTest</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-TypeTest-EQName">EQName</a> | <a href="#doc-xpath40-TypeTest-Wildcard">Wildcard</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-EQName"></a><code><a href="#prod-xpath40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-QName">QName</a> | <a href="#prod-xpath40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-Wildcard"></a><code><a href="#prod-xpath40-Wildcard">Wildcard</a></code></td><td>::=</td><td><code>"*"<br>| (<a href="#prod-xpath40-NCName">NCName</a> ":*")<br>| ("*:" <a href="#prod-xpath40-NCName">NCName</a>)<br>| (<a href="#prod-xpath40-BracedURILiteral">BracedURILiteral</a> "*")</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-AttributeTest"></a><code><a href="#prod-xpath40-AttributeTest">AttributeTest</a></code></td><td>::=</td><td><code>"attribute" "(" (<a href="#doc-xpath40-TypeTest-NameTestUnion">NameTestUnion</a> ("," <a href="#prod-xpath40-TypeName">TypeName</a>)?)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-SchemaAttributeTest"></a><code><a href="#prod-xpath40-SchemaAttributeTest">SchemaAttributeTest</a></code></td><td>::=</td><td><code>"schema-attribute" "(" <a href="#prod-xpath40-AttributeName">AttributeName</a> ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-PITest"></a><code><a href="#prod-xpath40-PITest">PITest</a></code></td><td>::=</td><td><code>"processing-instruction" "(" (<a href="#prod-xpath40-NCName">NCName</a> | <a href="#doc-xpath40-TypeTest-StringLiteral">StringLiteral</a>)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-StringLiteral"></a><code><a href="#prod-xpath40-StringLiteral">StringLiteral</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-AposStringLiteral">AposStringLiteral</a> | <a href="#prod-xpath40-QuotStringLiteral">QuotStringLiteral</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-CommentTest"></a><code><a href="#prod-xpath40-CommentTest">CommentTest</a></code></td><td>::=</td><td><code>"comment" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-TextTest"></a><code><a href="#prod-xpath40-TextTest">TextTest</a></code></td><td>::=</td><td><code>"text" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-NamespaceNodeTest"></a><code><a href="#prod-xpath40-NamespaceNodeTest">NamespaceNodeTest</a></code></td><td>::=</td><td><code>"namespace-node" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-AnyNodeKindTest"></a><code><a href="#prod-xpath40-AnyNodeKindTest">AnyNodeKindTest</a></code></td><td>::=</td><td><code>"node" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-TypeTest-JNodeType"></a><code><a href="#prod-xpath40-JNodeType">JNodeType</a></code></td><td>::=</td><td><code>"jnode" "(" (("*" | <a href="#prod-xpath40-NCName">NCName</a> | <a href="#doc-xpath40-Constant">Constant</a>) ("," ("*" | <a href="#doc-xpath40-SequenceType">SequenceType</a>))?)? ")"</code></td></tr></tbody></table><p>For example:</p><ul><li><p><code>element(N)</code> (short for <code>child::element(N)</code>) selects elements named <var>N</var>.</p></li><li><p><code>attribute(*, xs:integer)</code>selects attribute nodes whose type annotation is <code>xs:integer</code>.</p></li><li><p><code>text()</code> selects text nodes.</p></li><li><p><code>jnode("id")</code> selects JNodes having the <b>·selector·</b> property <code>"id"</code>.</p></li><li><p><code>jnode(*, map(*))</code> selects JNodes whose <b>·content·</b> property is an instance of the type <code>map(*)</code>.</p></li></ul><p>The syntax and semantics of <a href="#prod-xpath40-NodeKindTest">NodeKindTest</a> and <a href="#doc-xpath40-JNodeType">JNodeType</a> are described in <a href="#id-sequencetype-syntax"><b>3.1 Sequence Types</b></a> and <a href="#id-sequencetype-matching"><b>3.1.2 Sequence Type Matching</b></a>.</p><p>Shown below are further examples of type tests that might be used in path expressions selecting within an XTree:</p><ul><li><p><code>node()</code> matches any XNode.</p></li><li><p><code>text()</code> matches any text node.</p></li><li><p><code>comment()</code> matches any comment node.</p></li><li><p><code>namespace-node()</code> matches any namespace node.</p></li><li><p><code>element()</code> matches any element node.</p></li><li><p><code>schema-element(person)</code> matches any element node whose name is <code>person</code> (or is in the <a title="substitution group" class="termref" href="#dt-substitution-group">substitution group</a> headed by <code>person</code>), and whose type annotation is the same as (or is derived from) the declared type of the <code>person</code> element in the <a title="in-scope element declarations" class="termref" href="#dt-is-elems">in-scope element declarations</a>.</p></li><li><p><code>element(person)</code> matches any element node whose name is <code>person</code>, regardless of its type annotation.</p></li><li><p><code>element(doctor|nurse)</code> matches any element node whose name is <code>doctor</code> or <code>nurse</code>, regardless of its type annotation.</p></li><li><p><code>element(person, surgeon)</code> matches any non-nilled element node whose name is <code>person</code>, and whose type annotation is <code>surgeon</code> or is derived from <code>surgeon</code>.</p></li><li><p><code>element(doctor|nurse, medical-staff)</code> matches any non-nilled element node whose name is <code>doctor</code> or <code>nurse</code>, and whose type annotation is <code>medical-staff</code> or is derived from <code>medical-staff</code>.</p></li><li><p><code>element(*, surgeon)</code> matches any non-nilled element node whose type annotation is <code>surgeon</code> (or is derived from <code>surgeon</code>), regardless of its name.</p></li><li><p><code>attribute()</code> matches any attribute node.</p></li><li><p><code>attribute(price)</code> matches any attribute whose name is <code>price</code>, regardless of its type annotation.</p></li><li><p><code>attribute(*, xs:decimal)</code> matches any attribute whose type annotation is <code>xs:decimal</code> (or is derived from <code>xs:decimal</code>), regardless of its name.</p></li><li><p><code>document-node()</code> matches any document node.</p></li><li><p><code>document-node(element(book))</code> matches any document node whose children consist of a single element node that satisfies the <a href="#doc-xpath40-ElementTest">ElementTest</a><code>element(book)</code>, interleaved with zero or more comments and processing instructions, and no text nodes.</p></li><li><p><code>document-node(book)</code> is an abbreviation for <code>document-node(element(book))</code>.</p></li></ul><p>The following examples show type type tests that might be used in path expressions selecting within a JTree:</p><ul><li><p><code>jnode(*, array(*))</code> matches any JNode whose <b>·content·</b> is an array.</p></li><li><p><code>jnode(*, record(longitude, latitude, *))</code> matches any JNode whose <b>·content·</b> is a map having entries with keys <code>"longitude"</code> and <code>"latitude"</code>.</p></li><li><p><span style="display: none;" class="delete_version"><code>jnode(*, empty-sequence())</code> matches any JNode whose <b>·content·</b> is an empty sequence.</span><span style="display: none;" class="add_version"><code>jnode(*, empty-sequence())</code> matches any JNode whose <b>·content·</b> is the empty sequence.</span><span class="modify_version"><code>jnode(*, empty-sequence())</code> matches any JNode whose <b>·content·</b> is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p><code>jnode(*, xs:date)</code> matches any JNode whose <b>·content·</b> is an instance of <code>xs:date</code>.</p></li></ul></div><div class="_diffs div4"><h5><a id="implausible-axis-steps"></a>4.7.5.6 <a href="#implausible-axis-steps" style="text-decoration: none">Implausible Axis Steps</a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-arithmetic">next</a> | <a href="#node-tests">previous</a>)</p><ol><li><p><span style="display: none;" class="delete_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return an empty sequence rather than an error. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/602">602</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/603">603</a>&nbsp;25 July 2023]</i></span><span style="display: none;" class="add_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return the empty sequence rather than an error. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/602">602</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/603">603</a>&nbsp;25 July 2023]</i></span><span class="modify_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence rather than an error. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/602">602</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/603">603</a>&nbsp;25 July 2023]</i></span></p></li></ol></div><p>Certain axis steps, given an inferred type for the context value, are classified as <a title="implausible" class="termref" href="#dt-implausible">implausible</a>. During the static analysis phase, a processor <span class="verb">may</span> (subject to the rules in <a href="#id-implausible-expressions"><b>2.5.6 Implausible Expressions</b></a>) report a static error when such axis steps are encountered: [<a href="#ERRXPTY0144" title="err:XPTY0144">err:XPTY0144</a>].</p><p>More specifically, an axis step is classified as <a title="implausible" class="termref" href="#dt-implausible">implausible</a> if any of the following conditions applies:</p><ol class="enumar"><li><p>The inferred item type of the context value is a node kind for which the specified axis is always empty: for example, the inferred item type of the context value is <code>attribute()</code> and the axis is <code>child</code>.</p></li><li><p>The node test exclusively selects node kinds that cannot appear on the specified axis: for example, the axis is <code>child</code> and the node test is <code>document-node()</code>.</p></li><li><p>In a schema-aware environment, when using the <code>child</code>, <code>descendant</code>, <code>descendant-or-self</code>, or <code>attribute</code> axes, the inferred item type of the context value has a content type that does not allow any node matching the node test to be present on the relevant axis. For example, if the inferred item type of the context value is <code>schema-element(list)</code> and the relevant element declaration (taking into account substitution group membership and wildcards) only allows <code>item</code> children, the axis step <code>child::li</code> will never select anything and is therefore classified as <a title="implausible" class="termref" href="#dt-implausible">implausible</a>.</p></li></ol><p>Examples of implausible axis steps include the following:</p><ul><li><p><code>@code/text()</code>: attributes cannot have text node children.</p></li><li><p><code>/@code</code>: document nodes cannot have attributes.</p></li><li><p><code>ancestor::text()</code>: the ancestor axis never returns text nodes.</p></li><li><p><code>element(*)/child::map</code>: the child axis starting at an element node will never select a map.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>Processors may choose not to classify the expression <code>/..</code> as implausible, since XSLT 1.0 users were sometimes advised to use this construct as an explicit way of denoting the empty sequence.</p></div></div></div><div class="_diffs div3"><h4><a id="unabbrev"></a>4.7.7 <a href="#unabbrev" style="text-decoration: none">Unabbreviated Syntax</a></h4><p>This section provides a number of examples of path expressions in which the axis is explicitly specified in each <a title="step" class="termref" href="#dt-step">step</a>. The syntax used in these examples is called the <b>unabbreviated syntax</b>. In many common cases, it is possible to write path expressions more concisely using an <b>abbreviated syntax</b>, as explained in <a href="#abbrev"><b>4.7.8 Abbreviated Syntax</b></a>.</p><p>These examples assume that the context value is a single node, referred to as the context node.</p><ul><li><p><code>child::para</code> selects the <code>para</code> element children of the context node.</p></li><li><p><code>child::(para|bullet)</code> selects the <code>para</code> and <code>bullet</code> element children of the context node.</p></li><li><p><code>child::*</code> selects all element children of the context node.</p></li><li><p><code>child::text()</code> selects all text node children of the context node.</p></li><li><p><code>child::(text()|comment())</code> selects all text node and comment node children of the context node.</p></li><li><p><code>child::node()</code> selects all the children of the context node. Note that no attribute nodes are returned, because attributes are not children.</p></li><li><p><code>attribute::name</code> selects the <code>name</code> attribute of the context node.</p></li><li><p><code>attribute::*</code> selects all the attributes of the context node.</p></li><li><p><code>parent::node()</code> selects the parent of the context node. If the context node is an attribute node, this expression returns the element node (if any) to which the attribute node is attached.</p></li><li><p><code>descendant::para</code> selects the <code>para</code> element descendants of the context node.</p></li><li><p><code>ancestor::div</code> selects all <code>div</code> ancestors of the context node.</p></li><li><p><code>ancestor-or-self::div</code> selects the <code>div</code> ancestors of the context node and, if the context node is a <code>div</code> element, the context node as well.</p></li><li><p><code>descendant-or-self::para</code> selects the <code>para</code> element descendants of the context node and, if the context node is a <code>para</code> element, the context node as well.</p></li><li><p><span style="display: none;" class="delete_version"><code>self::para</code> selects the context node if it is a <code>para</code> element, and otherwise returns an empty sequence.</span><span style="display: none;" class="add_version"><code>self::para</code> selects the context node if it is a <code>para</code> element, and otherwise returns the empty sequence.</span><span class="modify_version"><code>self::para</code> selects the context node if it is a <code>para</code> element, and otherwise returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p><span style="display: none;" class="delete_version"><code>self::(chapter|appendix)</code> selects the context node if it is a <code>chapter</code> or <code>appendix</code> element, and otherwise returns an empty sequence.</span><span style="display: none;" class="add_version"><code>self::(chapter|appendix)</code> selects the context node if it is a <code>chapter</code> or <code>appendix</code> element, and otherwise returns the empty sequence.</span><span class="modify_version"><code>self::(chapter|appendix)</code> selects the context node if it is a <code>chapter</code> or <code>appendix</code> element, and otherwise returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p><code>child::chapter/descendant::para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node.</p></li><li><p><code>child::*/child::para</code> selects all <code>para</code> grandchildren of the context node.</p></li><li><p><code>/</code> selects the root of the tree that contains the context node, but raises a dynamic error if this root is not a document node.</p></li><li><p><code>/descendant::para</code> selects all the <code>para</code> elements in the same document as the context node.</p></li><li><p><code>/descendant::list/child::member</code> selects all the <code>member</code> elements that have a <code>list</code> parent and that are in the same document as the context node.</p></li><li><p><code>child::para[position() = 1]</code> selects the first <code>para</code> child of the context node.</p></li><li><p><code>child::para[position() = last()]</code> selects the last <code>para</code> child of the context node.</p></li><li><p><code>child::para[position() = last()-1]</code> selects the last but one <code>para</code> child of the context node.</p></li><li><p><code>child::para[position() &gt; 1]</code> selects all the <code>para</code> children of the context node other than the first <code>para</code> child of the context node.</p></li><li><p><code>following-sibling::chapter[position() = 1]</code> selects the next <code>chapter</code> sibling of the context node.</p></li><li><p><code>following-sibling::(chapter|appendix)[position() = 1]</code> selects the next sibling of the context node that is either a <code>chapter</code> or an <code>appendix</code>.</p></li><li><p><code>preceding-sibling::chapter[position() = 1]</code> selects the previous <code>chapter</code> sibling of the context node.</p></li><li><p><code>/descendant::figure[position() = 42]</code> selects the forty-second <code>figure</code> element in the document containing the context node.</p></li><li><p><code>/child::book/child::chapter[position() = 5]/child::section[position() = 2]</code> selects the second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node.</p></li><li><p><code>child::para[attribute::type eq "warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code>. </p></li><li><p><code>child::para[attribute::type eq 'warning'][position() = 5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code>. </p></li><li><p><code>child::para[position() = 5][attribute::type eq "warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code>. </p></li><li><p><code>child::chapter[child::title = 'Introduction']</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children whose <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> is equal to the string <code>Introduction</code>. </p></li><li><p><code>child::chapter[child::title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children.</p></li><li><p><code>child::*[self::chapter or self::appendix]</code> selects the <code>chapter</code> and <code>appendix</code> children of the context node.</p></li><li><p><code>child::*[self::(chapter|appendix)][position() = last()]</code> selects the last <code>chapter</code> or <code>appendix</code> child of the context node.</p></li></ul></div><div class="_diffs div3"><h4><a id="abbrev"></a>4.7.8 <a href="#abbrev" style="text-decoration: none">Abbreviated Syntax</a></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AbbreviatedStep"></a><code><a href="#prod-xpath40-AbbreviatedStep">AbbreviatedStep</a></code></td><td>::=</td><td><code>".." | ("@" <a href="#doc-xpath40-AbbreviatedStep-NodeTest">NodeTest</a>) | <a href="#doc-xpath40-AbbreviatedStep-SimpleNodeTest">SimpleNodeTest</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AbbreviatedStep-NodeTest"></a><code><a href="#prod-xpath40-NodeTest">NodeTest</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-UnionNodeTest">UnionNodeTest</a> | <a href="#doc-xpath40-AbbreviatedStep-SimpleNodeTest">SimpleNodeTest</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AbbreviatedStep-SimpleNodeTest"></a><code><a href="#prod-xpath40-SimpleNodeTest">SimpleNodeTest</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-AbbreviatedStep-TypeTest">TypeTest</a> | <a href="#doc-xpath40-AbbreviatedStep-Selector">Selector</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AbbreviatedStep-TypeTest"></a><code><a href="#prod-xpath40-TypeTest">TypeTest</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-NodeKindTest">NodeKindTest</a> | <a href="#doc-xpath40-JNodeType">JNodeType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AbbreviatedStep-Selector"></a><code><a href="#prod-xpath40-Selector">Selector</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-AbbreviatedStep-EQName">EQName</a> | <a href="#doc-xpath40-AbbreviatedStep-Wildcard">Wildcard</a> | ("get" "(" <a href="#doc-xpath40-AbbreviatedStep-ExprSingle">ExprSingle</a> ")")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AbbreviatedStep-EQName"></a><code><a href="#prod-xpath40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-QName">QName</a> | <a href="#prod-xpath40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AbbreviatedStep-Wildcard"></a><code><a href="#prod-xpath40-Wildcard">Wildcard</a></code></td><td>::=</td><td><code>"*"<br>| (<a href="#prod-xpath40-NCName">NCName</a> ":*")<br>| ("*:" <a href="#prod-xpath40-NCName">NCName</a>)<br>| (<a href="#prod-xpath40-BracedURILiteral">BracedURILiteral</a> "*")</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AbbreviatedStep-ExprSingle"></a><code><a href="#prod-xpath40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-ForExpr">ForExpr</a><br>| <a href="#doc-xpath40-LetExpr">LetExpr</a><br>| <a href="#doc-xpath40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xpath40-IfExpr">IfExpr</a><br>| <a href="#doc-xpath40-OrExpr">OrExpr</a></code></td></tr></tbody></table><p>The abbreviated syntax for a step permits the following abbreviations:</p><ol class="enumar"><li><p>The attribute axis <code>attribute::</code> can be abbreviated by <code>@</code>. For example, the expression <code>para[@type = "warning"]</code> is short for <code>child::para[attribute::type = "warning"]</code> and so selects <code>para</code> children with a <code>type</code> attribute with value equal to <code>warning</code>.</p></li><li><p>If the axis name is omitted from an <a title="axis step" class="termref" href="#dt-axis-step">axis step</a>, the default axis is <code>child</code>, with two exceptions: (1) if the <a href="#doc-xpath40-NodeTest">NodeTest</a> in an axis step contains an <a href="#doc-xpath40-AttributeTest">AttributeTest</a> or <a href="#doc-xpath40-SchemaAttributeTest">SchemaAttributeTest</a> then the default axis is <code>attribute</code>; (2) if the <a href="#doc-xpath40-NodeTest">NodeTest</a> in an axis step is a <a href="#prod-xpath40-NamespaceNodeTest">NamespaceNodeTest</a><span class="xpath">then the default axis is <code>namespace</code>, but in an implementation that does not support the namespace axis, an error is raised [<a href="#ERRXQST0134" title="err:XQST0134">err:XQST0134</a>].</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p> The namespace axis is deprecated as of XPath 2.0, but is required in some languages that use XPath, including XSLT.</p></div><p> For example, the path expression <code>section/para</code> is an abbreviation for <code>child::section/child::para</code>, and the path expression <code>section/@id</code> is an abbreviation for <code>child::section/attribute::id</code>. Similarly, <code>section/attribute(id)</code> is an abbreviation for <code>child::section/attribute::attribute(id)</code>. Note that the latter expression contains both an axis specification and a <a title="node test" class="termref" href="#dt-node-test">node test</a>.</p><p>Similarly, within a JTree rooted at an array, the expression <code>get(1)/parts/get(2)/part-no</code> gets the first member of the top-level array (presumably a map), then the <code>"parts"</code> entry within this map (presumably an array), then the second member of this array (presumably a map), and finally the <code>part-no</code> entry within this map.</p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">The same selection could be made using the lookup expression <code>?1?parts?2?part-no</code>. The main difference is that path expressions offer more flexibility in being able to navigate around the containing JTree. Also, the lookup expression <code>$a?1</code> fails if the array index is out of bounds; the path expression <code>$a/get(1)</code> (or <code>$a/*[1]</code>) instead returns an empty sequence.</span><span style="display: none;" class="add_version">The same selection could be made using the lookup expression <code>?1?parts?2?part-no</code>. The main difference is that path expressions offer more flexibility in being able to navigate around the containing JTree. Also, the lookup expression <code>$a?1</code> fails if the array index is out of bounds; the path expression <code>$a/get(1)</code> (or <code>$a/*[1]</code>) instead returns the empty sequence.</span><span class="modify_version">The same selection could be made using the lookup expression <code>?1?parts?2?part-no</code>. The main difference is that path expressions offer more flexibility in being able to navigate around the containing JTree. Also, the lookup expression <code>$a?1</code> fails if the array index is out of bounds; the path expression <code>$a/get(1)</code> (or <code>$a/*[1]</code>) instead returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>An abbreviated axis step that omits the axis name must use a <a href="#prod-xpath40-SimpleNodeTest">SimpleNodeTest</a> rather than a <a href="#prod-xpath40-UnionNodeTest">UnionNodeTest</a>. This means that a construct such as <code>(ul|ol)</code> is treated as an abbreviation for <code>(child::ul|child::ol)</code> rather than <code>child::(ul|ol)</code>. Since the two constructs have exactly the same semantics, this is not actually a restriction.</p></div></li><li><p>A step consisting of <code>..</code> is short for <code>parent::gnode()</code>. For example (assuming the context item is an XNode), <code>../title</code> is short for <code>parent::gnode()/child::title</code> and so will select the <code>title</code> children of the parent of the context node.</p><p>Similarly, if <code>$dateOfBirth</code> is a JNode resulting from the expression <code>$map/get("date of birth")</code>, then <code>$dateOfBirth/../gender</code> will select the entry having key <code>"gender"</code> within <code>$map</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The expression <code>.</code>, known as a <b>context value reference</b>, is a <a title="primary expression" class="termref" href="#dt-primary-expression">primary expression</a>, and is described in <a href="#id-context-value-references"><b>4.3.3 Context Value References</b></a>.</p></div></li></ol><p>Here are some examples of path expressions that use the abbreviated syntax. These examples assume that the context value is a single XNode, referred to as the context node:</p><ul><li><p><code>para</code> selects the <code>para</code> element children of the context node.</p></li><li><p><code>*</code> selects all element children of the context node.</p></li><li><p><code>text()</code> selects all text node children of the context node.</p></li><li><p><code>@name</code> selects the <code>name</code> attribute of the context node.</p></li><li><p><code>@(id|name)</code> selects the <code>id</code> and <code>name</code> attributes of the context node.</p></li><li><p><code>@*</code> selects all the attributes of the context node.</p></li><li><p><code>para[1]</code> selects the first <code>para</code> child of the context node.</p></li><li><p><code>para[last()]</code> selects the last <code>para</code> child of the context node.</p></li><li><p><code>*/para</code> selects all <code>para</code> grandchildren of the context node.</p></li><li><p><code>/book/chapter[5]/section[2]</code> selects the second <code>section</code> of the fifth <code>chapter</code> of the <code>book</code> whose parent is the document node that contains the context node.</p></li><li><p><code>chapter//para</code> selects the <code>para</code> element descendants of the <code>chapter</code> element children of the context node.</p></li><li><p><code>//para</code> selects all the <code>para</code> descendants of the root document node and thus selects all <code>para</code> elements in the same document as the context node.</p></li><li><p><code>//@version</code> selects all the <code>version</code> attribute nodes that are in the same document as the context node.</p></li><li><p><code>//list/member</code> selects all the <code>member</code> elements in the same document as the context node that have a <code>list</code> parent.</p></li><li><p><code>.//para</code> selects the <code>para</code> element descendants of the context node.</p></li><li><p><code>..</code> selects the parent of the context node.</p></li><li><p><code>../@lang</code> selects the <code>lang</code> attribute of the parent of the context node.</p></li><li><p><code>para[@type = "warning"]</code> selects all <code>para</code> children of the context node that have a <code>type</code> attribute with value <code>warning</code>. </p></li><li><p><code>para[@type = "warning"][5]</code> selects the fifth <code>para</code> child of the context node that has a <code>type</code> attribute with value <code>warning</code>. </p></li><li><p><code>para[5][@type = "warning"]</code> selects the fifth <code>para</code> child of the context node if that child has a <code>type</code> attribute with value <code>warning</code>. </p></li><li><p><code>chapter[title = "Introduction"]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children whose <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> is equal to the string <code>Introduction</code>. </p></li><li><p><code>chapter[title]</code> selects the <code>chapter</code> children of the context node that have one or more <code>title</code> children.</p></li><li><p><code>employee[@secretary and @assistant]</code> selects all the <code>employee</code> children of the context node that have both a <code>secretary</code> attribute and an <code>assistant</code> attribute.</p></li><li><p><code>book/(chapter|appendix)/section</code> selects every <code>section</code> element that has a parent that is either a <code>chapter</code> or an <code>appendix</code> element, that in turn is a child of a <code>book</code> element that is a child of the context node.</p></li><li><p>If <code>E</code> is any expression that returns a sequence of nodes, then the expression <code>E/.</code> returns the same nodes in <a title="document order" class="termref" href="#dt-document-order">document order</a>, with duplicates eliminated based on node identity.</p></li></ul><p>The following examples use abbreviated paths to access data within the JTree obtained by parsing the JSON text:</p><div class="exampleInner"><pre xml:space="preserve">[
  { "first": "John", 
    "last": "Baker", 
    "date of birth": "2003-04-19", 
    "occupation": "cook"}, 
  { "first": "Mary", 
    "last": "Smith", 
    "date of birth": "2006-08-12", 
    "occupation": "teacher"},                 
]</pre></div><ul><li><p><code>get(1)/first</code> returns a JNode whose <b>·content·</b> is the string <code>"John"</code>.</p></li><li><p><code>//first[. = "Mary"]/../last</code> returns a JNode whose <b>·content·</b> is the string <code>"Smith"</code>.</p></li><li><p><code>//first[. = "Mary"]/../get("date of birth")</code> returns a JNode whose <b>·content·</b> is the string <code>"2006-08-12"</code>.</p></li><li><p><code>//*[occupation = "cook"]!`{first} {last}`</code> returns the string <code>"John Baker"</code>.</p></li><li><p><code>//*[occupation = "cook"]/following-sibling::*[1]!`{first} {last}`</code> returns the string <code>"Mary Smith"</code>.</p></li><li><p><code>//*[last = "Smith"]/../get(1)/last</code> returns the string <code>"Baker"</code>.</p></li><li><p><code>//record(first, last, *) ! string(last)</code> returns the sequence of two strings <code>"Baker"</code>, <code>"Smith"</code>.</p></li></ul></div></div><div class="_diffs div2"><h3><a id="id-sequence-expressions"></a>4.8 <a href="#id-sequence-expressions" style="text-decoration: none">Sequence Expressions</a></h3><p>XPath 4.0 supports operators to construct, filter, and combine <a title="sequence" class="termref" href="#dt-sequence">sequences</a> of <a title="item" class="termref" href="#dt-item">items</a>. Sequences are never nested—for example, combining the values <code>1</code>, <code>(2, 3)</code>, and <code>( )</code> into a single sequence results in the sequence <code>(1, 2, 3)</code>.</p><div class="_diffs div3"><h4><a id="construct_seq"></a>4.8.1 <a href="#construct_seq" style="text-decoration: none">Sequence Concatenation</a></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-Expr"></a><code><a href="#prod-xpath40-Expr">Expr</a></code></td><td>::=</td><td><code>(<a href="#doc-xpath40-Expr-ExprSingle">ExprSingle</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-Expr-ExprSingle"></a><code><a href="#prod-xpath40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-ForExpr">ForExpr</a><br>| <a href="#doc-xpath40-LetExpr">LetExpr</a><br>| <a href="#doc-xpath40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xpath40-IfExpr">IfExpr</a><br>| <a href="#doc-xpath40-OrExpr">OrExpr</a></code></td></tr></tbody></table><p> [<a id="dt-sequence-expression" title="sequence expression">Definition</a>: A <b>sequence expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production rule <a href="#doc-xpath40-Expr">Expr</a>, that is, an expression containing two or more instances of the production <a href="#doc-xpath40-ExprSingle">ExprSingle</a> separated by the comma operator.] </p><p>The result of a <a title="sequence expression" class="termref" href="#dt-sequence-expression">sequence expression</a> is the <a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation">sequence concatenation</a> of the values of its operands. See <a href="#doc-xpath40-Expr"></a></p><p> [<a id="dt-comma-operator" title="comma operator">Definition</a>: A <b>comma operator</b> is a comma used specifically as the operator in a <a title="sequence expression" class="termref" href="#dt-sequence-expression">sequence expression</a>.] </p><p>Empty parentheses can be used to denote <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p><p>A sequence may contain duplicate <a title="item" class="termref" href="#dt-item">items</a>, but a sequence is never an item in another sequence. When a new sequence is created by concatenating two or more input sequences, the new sequence contains all the items of the input sequences and its length is the sum of the lengths of the input sequences.</p><p> [<a id="dt-sequence-concatenation" title="sequence concatenation">Definition</a>: The <b>sequence concatenation</b> of a number of sequences <var>S<sub>1</sub></var>, <var>S<sub>2</sub></var>, ... <var>S<sub>n</sub></var> is defined to be the sequence formed from the items of <var>S<sub>1</sub></var>, followed by the items from <var>S<sub>2</sub></var>, and so on, retaining order.] The <a title="comma operator" class="termref" href="#dt-comma-operator">comma operator</a> returns the sequence concatenation of its two operands; repeated application (for example <code>$s1, $s2, $s3, $s4</code>) delivers the sequence concatenation of multiple sequences.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In places where the grammar calls for <a href="#doc-xpath40-ExprSingle">ExprSingle</a>, such as the arguments of a function call, any expression that contains a top-level comma operator must be enclosed in parentheses.</p></div><p>Here are some examples of expressions that construct sequences: </p><ul><li><p>The result of this expression is a sequence of five integers:</p><div class="exampleInner"><pre xml:space="preserve">(10, 1, 2, 3, 4)</pre></div></li><li><p>This expression combines four sequences of length one, two, zero, and two, respectively, into a single sequence of length five. The result of this expression is the sequence <code>10, 1, 2, 3, 4</code>.</p><div class="exampleInner"><pre xml:space="preserve">(10, (1, 2), (), (3, 4))</pre></div></li><li><p>The result of this expression is a sequence containing all <code>salary</code> children of the context node followed by all <code>bonus</code> children.</p><div class="exampleInner"><pre xml:space="preserve">(salary, bonus)</pre></div></li><li><p>Assuming that <code>$price</code> is bound to the value <code>10.50</code>, the result of this expression is the sequence <code>10.50, 10.50</code>.</p><div class="exampleInner"><pre xml:space="preserve">($price, $price)</pre></div></li></ul></div><div class="_diffs div3"><h4><a id="id-range-expressions"></a>4.8.2 <a href="#id-range-expressions" style="text-decoration: none">Range Expressions</a></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-RangeExpr"></a><code><a href="#prod-xpath40-RangeExpr">RangeExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-RangeExpr-AdditiveExpr">AdditiveExpr</a> ("to" <a href="#doc-xpath40-RangeExpr-AdditiveExpr">AdditiveExpr</a>)?</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-RangeExpr-AdditiveExpr"></a><code><a href="#prod-xpath40-AdditiveExpr">AdditiveExpr</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-MultiplicativeExpr">MultiplicativeExpr</a> (("+" | "-") <a href="#prod-xpath40-MultiplicativeExpr">MultiplicativeExpr</a>)*</code></td></tr></tbody></table><p><span style="display: none;" class="delete_version"> [<a id="dt-range-expression" title="range expression">Definition</a>: A <b>range expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production <a href="#doc-xpath40-RangeExpr">RangeExpr</a>. A range expression is used to construct a sequence of integers.] Each of the operands is converted as though it was an argument of a function with the expected parameter type <code>xs:integer?</code>. If either operand is an empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is an empty sequence. If the two operands convert to the same integer, the result of the range expression is that integer. Otherwise, the result is a sequence containing the two integer operands and every integer between the two operands, in increasing order. </span><span style="display: none;" class="add_version"> [<a id="dt-range-expression" title="range expression">Definition</a>: A <b>range expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production <a href="#doc-xpath40-RangeExpr">RangeExpr</a>. A range expression is used to construct a sequence of integers.] Each of the operands is converted as though it was an argument of a function with the expected parameter type <code>xs:integer?</code>. If either operand is the empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is the empty sequence. If the two operands convert to the same integer, the result of the range expression is that integer. Otherwise, the result is a sequence containing the two integer operands and every integer between the two operands, in increasing order. </span><span class="modify_version"> [<a id="dt-range-expression" title="range expression">Definition</a>: A <b>range expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production <a href="#doc-xpath40-RangeExpr">RangeExpr</a>. A range expression is used to construct a sequence of integers.] Each of the operands is converted as though it was an argument of a function with the expected parameter type <code>xs:integer?</code>. If either operand is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. If the two operands convert to the same integer, the result of the range expression is that integer. Otherwise, the result is a sequence containing the two integer operands and every integer between the two operands, in increasing order. </span></p><p>The following examples illustrate the semantics:</p><ul><li><p><code>1 to 4</code> returns the sequence <code>1, 2, 3, 4</code></p></li><li><p><code>10 to 10</code> returns the <a title="singleton" class="termref" href="#dt-singleton">singleton</a> sequence <code>10</code></p></li><li><p><code>10 to 1</code> returns the empty sequence</p></li><li><p><code>-13 to -10</code> returns the sequence <code>-13, -12, -11, -10</code></p></li></ul><p>More formally, a <a title="range expression" class="termref" href="#dt-range-expression">range expression</a> is evaluated as follows:</p><ol class="enumar"><li><p>Each of the operands of the <code>to</code> operator is converted as though it was an argument of a function with the expected parameter type <code>xs:integer?</code>.</p></li><li><p>If either operand is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, or if the integer derived from the first operand is greater than the integer derived from the second operand, the result of the range expression is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p></li><li><p>If the two operands convert to the same integer, the result of the range expression is that integer.</p></li><li><p>Otherwise, the result is a sequence containing the two integer operands and every integer between the two operands, in increasing order.</p></li></ol><p>The following examples illustrate the use of <a title="range expression" class="termref" href="#dt-range-expression">range expressions</a>.</p><div class="example"><p>This example uses a range expression as one operand in constructing a sequence. It evaluates to the sequence <code>10, 1, 2, 3, 4</code>.</p><div class="exampleInner"><pre xml:space="preserve">(10, 1 to 4)</pre></div><p>This example selects the first four items from an input sequence:</p><div class="exampleInner"><pre xml:space="preserve">$input[1 to 4]</pre></div><p>This example returns the sequence <code>(0, 0.1, 0.2, 0.3, 0.5)</code>:</p><div class="exampleInner"><pre xml:space="preserve">$x = (1 to 5) ! . * 0.1</pre></div><p>This example constructs a sequence of length one containing the single integer 10.</p><div class="exampleInner"><pre xml:space="preserve">10 to 10</pre></div><p>The result of this example is a sequence of length zero.</p><div class="exampleInner"><pre xml:space="preserve">15 to 10</pre></div><p>This example uses the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-reverse"><code>fn:reverse</code></a> function to construct a sequence of six integers in decreasing order. It evaluates to the sequence 15, 14, 13, 12, 11, 10.</p><div class="exampleInner"><pre xml:space="preserve">reverse(10 to 15)</pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>To construct a sequence of integers based on steps other than 1, use the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-slice"><code>fn:slice</code></a> function, as defined in <a href="https://www.w3.org/TR/xpath-functions-31/#general-seq-funcs"> 14.1 General functions and operators on sequences </a><sup><small>FO31</small></sup>.</p></div></div></div><div class="_diffs div2"><h3><a id="id-arithmetic"></a>4.9 <a href="#id-arithmetic" style="text-decoration: none">Arithmetic Expressions</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-string-templates">next</a> | <a href="#implausible-axis-steps">previous</a>)</p><ol><li><p> The symbols <code>×</code> and <code>÷</code> can be used for multiplication and division. </p></li></ol></div><p>XPath 4.0 provides binary arithmetic operators for addition, subtraction, multiplication, division, and modulus:</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AdditiveExpr"></a><code><a href="#prod-xpath40-AdditiveExpr">AdditiveExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-AdditiveExpr-MultiplicativeExpr">MultiplicativeExpr</a> (("+" | "-") <a href="#doc-xpath40-AdditiveExpr-MultiplicativeExpr">MultiplicativeExpr</a>)*</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AdditiveExpr-MultiplicativeExpr"></a><code><a href="#prod-xpath40-MultiplicativeExpr">MultiplicativeExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-AdditiveExpr-UnionExpr">UnionExpr</a> (("*" | "×" | "div" | "÷" | "idiv" | "mod") <a href="#doc-xpath40-AdditiveExpr-UnionExpr">UnionExpr</a>)*</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-AdditiveExpr-UnionExpr"></a><code><a href="#prod-xpath40-UnionExpr">UnionExpr</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-IntersectExceptExpr">IntersectExceptExpr</a> (("union" | "|") <a href="#prod-xpath40-IntersectExceptExpr">IntersectExceptExpr</a>)*</code></td></tr></tbody></table><p>In addition, unary operators are provided for addition and subtraction:</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-UnaryExpr"></a><code><a href="#prod-xpath40-UnaryExpr">UnaryExpr</a></code></td><td>::=</td><td><code>("-" | "+")* <a href="#doc-xpath40-UnaryExpr-ValueExpr">ValueExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-UnaryExpr-ValueExpr"></a><code><a href="#prod-xpath40-ValueExpr">ValueExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-UnaryExpr-SimpleMapExpr">SimpleMapExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-UnaryExpr-SimpleMapExpr"></a><code><a href="#prod-xpath40-SimpleMapExpr">SimpleMapExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-PathExpr">PathExpr</a> ("!" <a href="#doc-xpath40-PathExpr">PathExpr</a>)*</code></td></tr></tbody></table><p>A subtraction operator must be preceded by whitespace if it could otherwise be interpreted as part of the previous token. For example, <code>a-b</code> will be interpreted as a name, but <code>a - b</code> and <code>a -b</code> will be interpreted as arithmetic expressions. (See <a href="#whitespace-rules"><b>A.3.4 Whitespace Rules</b></a> for further details on whitespace handling.)</p><p>The arithmetic operator symbols <code>*</code> and <span class="unicode-codepoint">U+00D7</span> (<span class="unicode-name">MULTIPLICATION SIGN</span>, <code>×</code>) are interchangeable, and denote multiplication.</p><p>The arithmetic operator symbols <code>div</code> and <span class="unicode-codepoint">U+00F7</span> (<span class="unicode-name">DIVISION SIGN</span>, <code>÷</code>) are interchangeable, and denote division.</p><p> If an <code>AdditiveExpr</code> contains more than two <code>MultiplicativeExprs</code>, they are grouped from left to right. So, for instance, </p><div class="exampleInner"><pre xml:space="preserve">A - B + C - D</pre></div><p> is equivalent to </p><div class="exampleInner"><pre xml:space="preserve">((A - B) + C) - D</pre></div><p> Similarly, the operands of a <code>MultiplicativeExpr</code> are grouped from left to right. </p><p>The first step in evaluating an arithmetic expression is to evaluate its operand (for a unary operator) or operands (for a binary operator). The order in which the operands are evaluated is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><p class="xpath">If <a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>true</code>, each operand is evaluated by applying the following steps, in order:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the operand. The result of this operation is called the <b>atomized operand</b>.</p></li><li><p><span style="display: none;" class="delete_version">If the atomized operand is an empty sequence, the result of the arithmetic expression is the <code>xs:double</code> value <code>NaN</code>, and the implementation need not evaluate the other operand or apply the operator. However, an implementation may choose to evaluate the other operand in order to determine whether it raises an error.</span><span style="display: none;" class="add_version">If the atomized operand is the empty sequence, the result of the arithmetic expression is the <code>xs:double</code> value <code>NaN</code>, and the implementation need not evaluate the other operand or apply the operator. However, an implementation may choose to evaluate the other operand in order to determine whether it raises an error.</span><span class="modify_version">If the atomized operand is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result of the arithmetic expression is the <code>xs:double</code> value <code>NaN</code>, and the implementation need not evaluate the other operand or apply the operator. However, an implementation may choose to evaluate the other operand in order to determine whether it raises an error.</span></p></li><li><p>If the atomized operand is a sequence of length greater than one, any items after the first item in the sequence are discarded.</p></li><li><p>If the atomized operand is now an instance of type <code>xs:boolean</code>, <code>xs:string</code>, <code>xs:decimal</code> (including <code>xs:integer</code>), <code>xs:float</code>, or <code>xs:untypedAtomic</code>, then it is converted to the type <code>xs:double</code> by applying the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-number"><code>fn:number</code></a> function. (Note that <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-number"><code>fn:number</code></a> returns the value <code>NaN</code> if its operand cannot be converted to a number.)</p></li></ol><p><span class="xpath">If <a title="XPath 1.0 compatibility     mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is <code>false</code>, each</span> operand is evaluated by applying the following steps, in order:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the operand. The result of this operation is called the <b>atomized operand</b>.</p></li><li><p>If the atomized operand is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result of the arithmetic expression is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, and the implementation need not evaluate the other operand or apply the operator. However, an implementation may choose to evaluate the other operand in order to determine whether it raises an error.</p></li><li><p> If the atomized operand is a sequence of length greater than one, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>If the atomized operand is of type <code>xs:untypedAtomic</code>, it is cast to <code>xs:double</code>. If the cast fails, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is raised. [<a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>]<sup><small>FO40</small></sup></p></li></ol><p>If, after this process, both operands of a binary arithmetic operator are instances of <code>xs:numeric</code> but have different primitive types, they are coerced to a common type by applying the following rules:</p><ol class="enumar"><li><p>If either of the items is of type <code>xs:double</code>, then both the values are cast to type <code>xs:double</code>.</p></li><li><p>Otherwise, if either of the items is of type <code>xs:float</code>, then both the values are cast to type <code>xs:float</code>.</p></li><li><p>Otherwise, no casting takes place: the values remain as <code>xs:decimal</code>.</p></li></ol><p>After this preparation, the arithmetic expression is evaluated by applying the appropriate function listed in the table below. The definitions of these functions are found in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>.</p><table style="border:1px solid" class="small"><caption>Unary Arithmetic Operators</caption><thead><tr><th>Expression</th><th>Type of A</th><th>Function</th><th>Result type</th></tr></thead><tbody><tr><td>+ A</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-numeric-unary-plus"><code>op:numeric-unary-plus</code></a><code>(A)</code></td><td>xs:numeric</td></tr><tr><td>- A</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-numeric-unary-minus"><code>op:numeric-unary-minus</code></a><code>(A)</code></td><td>xs:numeric</td></tr></tbody></table><table style="border:1px solid" class="small"><caption>Binary Arithmetic Operators</caption><tbody><tr><th>Expression</th><th>Type of A</th><th>Type of B</th><th>Function</th><th>Result type</th></tr><tr><td>A + B</td><td>xs:numeric</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-numeric-add"><code>op:numeric-add</code></a><code>(A, B)</code></td><td>xs:numeric</td></tr><tr><td>A + B</td><td>xs:date</td><td>xs:yearMonthDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-yearMonthDuration-to-date"><code>op:add-yearMonthDuration-to-date</code></a><code>(A, B)</code></td><td>xs:date</td></tr><tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:date</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-yearMonthDuration-to-date"><code>op:add-yearMonthDuration-to-date</code></a><code>(B, A)</code></td><td>xs:date</td></tr><tr><td>A + B</td><td>xs:date</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-dayTimeDuration-to-date"><code>op:add-dayTimeDuration-to-date</code></a><code>(A, B)</code></td><td>xs:date</td></tr><tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:date</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-dayTimeDuration-to-date"><code>op:add-dayTimeDuration-to-date</code></a><code>(B, A)</code></td><td>xs:date</td></tr><tr><td>A + B</td><td>xs:time</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-dayTimeDuration-to-time"><code>op:add-dayTimeDuration-to-time</code></a><code>(A, B)</code></td><td>xs:time</td></tr><tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:time</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-dayTimeDuration-to-time"><code>op:add-dayTimeDuration-to-time</code></a><code>(B, A)</code></td><td>xs:time</td></tr><tr><td>A + B</td><td>xs:dateTime</td><td>xs:yearMonthDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-yearMonthDuration-to-dateTime"><code>op:add-yearMonthDuration-to-dateTime</code></a><code>(A, B)</code></td><td>xs:dateTime</td></tr><tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:dateTime</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-yearMonthDuration-to-dateTime"><code>op:add-yearMonthDuration-to-dateTime</code></a><code>(B, A)</code></td><td>xs:dateTime</td></tr><tr><td>A + B</td><td>xs:dateTime</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-dayTimeDuration-to-dateTime"><code>op:add-dayTimeDuration-to-dateTime</code></a><code>(A, B)</code></td><td>xs:dateTime</td></tr><tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:dateTime</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-dayTimeDuration-to-dateTime"><code>op:add-dayTimeDuration-to-dateTime</code></a><code>(B, A)</code></td><td>xs:dateTime</td></tr><tr><td>A + B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-yearMonthDurations"><code>op:add-yearMonthDurations</code></a><code>(A, B)</code></td><td>xs:yearMonthDuration</td></tr><tr><td>A + B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-add-dayTimeDurations"><code>op:add-dayTimeDurations</code></a><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr><tr><td>A - B</td><td>xs:numeric</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-numeric-subtract"><code>op:numeric-subtract</code></a><code>(A, B)</code></td><td>xs:numeric</td></tr><tr><td>A - B</td><td>xs:date</td><td>xs:date</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-dates"><code>op:subtract-dates</code></a><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr><tr><td>A - B</td><td>xs:date</td><td>xs:yearMonthDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-yearMonthDuration-from-date"><code>op:subtract-yearMonthDuration-from-date</code></a><code>(A, B)</code></td><td>xs:date</td></tr><tr><td>A - B</td><td>xs:date</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-dayTimeDuration-from-date"><code>op:subtract-dayTimeDuration-from-date</code></a><code>(A, B)</code></td><td>xs:date</td></tr><tr><td>A - B</td><td>xs:time</td><td>xs:time</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-times"><code>op:subtract-times</code></a><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr><tr><td>A - B</td><td>xs:time</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-dayTimeDuration-from-time"><code>op:subtract-dayTimeDuration-from-time</code></a><code>(A, B)</code></td><td>xs:time</td></tr><tr><td>A - B</td><td>xs:dateTime</td><td>xs:dateTime</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-dateTimes"><code>op:subtract-dateTimes</code></a><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr><tr><td>A - B</td><td>xs:dateTime</td><td>xs:yearMonthDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-yearMonthDuration-from-dateTime"><code>op:subtract-yearMonthDuration-from-dateTime</code></a><code>(A, B)</code></td><td>xs:dateTime</td></tr><tr><td>A - B</td><td>xs:dateTime</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-dayTimeDuration-from-dateTime"><code>op:subtract-dayTimeDuration-from-dateTime</code></a><code>(A, B)</code></td><td>xs:dateTime</td></tr><tr><td>A - B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-yearMonthDurations"><code>op:subtract-yearMonthDurations</code></a><code>(A, B)</code></td><td>xs:yearMonthDuration</td></tr><tr><td>A - B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-subtract-dayTimeDurations"><code>op:subtract-dayTimeDurations</code></a><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr><tr><td>A * B</td><td>xs:numeric</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-numeric-multiply"><code>op:numeric-multiply</code></a><code>(A, B)</code></td><td>xs:numeric</td></tr><tr><td>A * B</td><td>xs:yearMonthDuration</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-multiply-yearMonthDuration"><code>op:multiply-yearMonthDuration</code></a><code>(A, B)</code></td><td>xs:yearMonthDuration</td></tr><tr><td>A * B</td><td>xs:numeric</td><td>xs:yearMonthDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-multiply-yearMonthDuration"><code>op:multiply-yearMonthDuration</code></a><code>(B, A)</code></td><td>xs:yearMonthDuration</td></tr><tr><td>A * B</td><td>xs:dayTimeDuration</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-multiply-dayTimeDuration"><code>op:multiply-dayTimeDuration</code></a><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr><tr><td>A * B</td><td>xs:numeric</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-multiply-dayTimeDuration"><code>op:multiply-dayTimeDuration</code></a><code>(B, A)</code></td><td>xs:dayTimeDuration</td></tr><tr><td>A idiv B</td><td>xs:numeric</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-numeric-integer-divide"><code>op:numeric-integer-divide</code></a><code>(A, B)</code></td><td>xs:integer</td></tr><tr><td>A div B</td><td>xs:numeric</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-numeric-divide"><code>op:numeric-divide</code></a><code>(A, B)</code></td><td>numeric; but xs:decimal if both operands are xs:integer</td></tr><tr><td>A div B</td><td>xs:yearMonthDuration</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-divide-yearMonthDuration"><code>op:divide-yearMonthDuration</code></a><code>(A, B)</code></td><td>xs:yearMonthDuration</td></tr><tr><td>A div B</td><td>xs:dayTimeDuration</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-divide-dayTimeDuration"><code>op:divide-dayTimeDuration</code></a><code>(A, B)</code></td><td>xs:dayTimeDuration</td></tr><tr><td>A div B</td><td>xs:yearMonthDuration</td><td>xs:yearMonthDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-divide-yearMonthDuration-by-yearMonthDuration"><code>op:divide-yearMonthDuration-by-yearMonthDuration</code></a><code>(A, B)</code></td><td>xs:decimal</td></tr><tr><td>A div B</td><td>xs:dayTimeDuration</td><td>xs:dayTimeDuration</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-divide-dayTimeDuration-by-dayTimeDuration"><code>op:divide-dayTimeDuration-by-dayTimeDuration</code></a><code>(A, B)</code></td><td>xs:decimal</td></tr><tr><td>A mod B</td><td>xs:numeric</td><td>xs:numeric</td><td><a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-numeric-mod"><code>op:numeric-mod</code></a><code>(A, B)</code></td><td>xs:numeric</td></tr></tbody></table><div class="note"><p class="prefix"><b>Note:</b></p><p>The operator symbol <code>×</code> is a synonym of <code>*</code>, while <code>÷</code> is a synonym of <code>div</code>.</p></div><p>If there is no entry in the table for the combination of operator and operands, then a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p><p>Errors may also occur during coercion of the operands, or during evaluation of the identified function (for example, an error might result from dividing by zero).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>XPath 4.0 provides three division operators:</p><ul><li><p>The <code>div</code> and <code>÷</code> operators are synonyms, and implement numeric division as well as division of duration values; the semantics are defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#func-numeric-divide">4.2.4 op:numeric-divide</a></p></li><li><p>The <code>idiv</code> operator implements integer division; the semantics are defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#func-numeric-integer-divide">4.2.5 op:numeric-integer-divide</a></p></li></ul></div><p>Here are some examples of arithmetic expressions:</p><ul><li><p>The first expression below returns the <code>xs:decimal</code> value <code>-1.5</code>, and the second expression returns the <code>xs:integer</code> value <code>-1</code>:</p><div class="exampleInner"><pre xml:space="preserve">-3 div 2
-3 idiv 2</pre></div></li><li><p>Subtraction of two date values results in a value of type <code>xs:dayTimeDuration</code>:</p><div class="exampleInner"><pre xml:space="preserve">$emp/hiredate - $emp/birthdate</pre></div></li><li><p>This example illustrates the difference between a subtraction operator and a hyphen:</p><div class="exampleInner"><pre xml:space="preserve">$unit-price - $unit-discount</pre></div></li><li><p>Unary operators have higher precedence than binary operators (other than <code>!</code>, <code>/</code>, and <code>[]</code>), subject of course to the use of parentheses. Therefore, the following two examples have different meanings:</p><div class="exampleInner"><pre xml:space="preserve">-$bellcost + $whistlecost
-($bellcost + $whistlecost)</pre></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p id="note-consecutive-unary-ops">Multiple consecutive unary arithmetic operators are permitted (though not useful).</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Negation is not the same as subtraction from zero: if <code>$x</code> is positive zero, then <code>-$x</code> returns negative zero, wheras <code>0 - $x</code> returns positive zero.</p></div></div><div class="_diffs div2"><h3><a id="id-string-expr"></a>4.10 <a href="#id-string-expr" style="text-decoration: none">String Expressions</a></h3><p>This section describes several ways of constructing strings.</p><div class="_diffs div3"><h4><a id="id-string-templates"></a>4.10.2 <a href="#id-string-templates" style="text-decoration: none">String Templates</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-value-comparisons">next</a> | <a href="#id-arithmetic">previous</a>)</p><ol><li><p> String templates provide a new way of constructing strings: for example <code>`{$greeting}, {$planet}!`</code> is equivalent to <code>$greeting || ', ' || $planet || '!'</code><i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/58">58</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/324">324</a>&nbsp;29 January 2023]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-StringTemplate"></a><code><a href="#prod-xpath40-StringTemplate">StringTemplate</a></code></td><td>::=</td><td><code>"`" (<a href="#doc-xpath40-StringTemplate-StringTemplateFixedPart">StringTemplateFixedPart</a> | <a href="#doc-xpath40-StringTemplate-StringTemplateVariablePart">StringTemplateVariablePart</a>)* "`"</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-StringTemplate-StringTemplateFixedPart"></a><code><a href="#prod-xpath40-StringTemplateFixedPart">StringTemplateFixedPart</a></code></td><td>::=</td><td><code>((<a href="#doc-xpath40-StringTemplate-Char">Char</a> - ('{' | '}' | '`')) | "{{" | "}}" | "``")+</code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-StringTemplate-Char"></a><code><a href="#prod-xpath40-Char">Char</a></code></td><td>::=</td><td><code><a href="https://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#parse-note-xml-version">xgc: xml-version</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-StringTemplate-StringTemplateVariablePart"></a><code><a href="#prod-xpath40-StringTemplateVariablePart">StringTemplateVariablePart</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-StringTemplate-EnclosedExpr">EnclosedExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-StringTemplate-EnclosedExpr"></a><code><a href="#prod-xpath40-EnclosedExpr">EnclosedExpr</a></code></td><td>::=</td><td><code>"{" <a href="#doc-xpath40-Expr">Expr</a>? "}"</code></td></tr></tbody></table><p>String templates provide an alternative way of constructing strings. For example, the expression <code>`Pi is { round(math:pi(), 4) }`</code> returns the string <code>"Pi is 3.1416"</code>.</p><p>A string template starts and ends with <span class="unicode-codepoint">U+0060</span> (<span class="unicode-name">GRAVE ACCENT, BACKTICK</span>, <code>`</code>) , popularly known as a back-tick. Between the back-ticks is a string consisting of an sequence of fixed parts and variable parts:</p><ul><li><p>A variable part consists of an optional XPath expression enclosed in curly brackets (<code>{}</code>): more specifically, a string conforming to the XPath production <code>Expr?</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An expression within a variable part may contain an unescaped <span class="unicode-codepoint">U+007B</span> (<span class="unicode-name">LEFT CURLY BRACKET</span>, <code>{</code>) or <span class="unicode-codepoint">U+007D</span> (<span class="unicode-name">RIGHT CURLY BRACKET</span>, <code>}</code>) within a <a href="#doc-xpath40-StringLiteral">StringLiteral</a> or within a comment.</p><p>The fact that the expression is optional means that the string contained between the curly brackets may be zero-length, may comprise whitespace only, or may contain XPath comments. The effective value in this case is a zero-length string, which is equivalent to omitting the variable part entirely, together with its curly-bracket delimiters. </p></div></li><li><p>A fixed part may contain any characters, except that:</p><ul><li><p>The character <span class="unicode-codepoint">U+007B</span> (<span class="unicode-name">LEFT CURLY BRACKET</span>, <code>{</code>) <span class="verb">must</span> be written as <code>{{</code>.</p></li><li><p>The character <span class="unicode-codepoint">U+007D</span> (<span class="unicode-name">RIGHT CURLY BRACKET</span>, <code>}</code>) <span class="verb">must</span> be written as <code>}}</code>.</p></li><li><p>The character <span class="unicode-codepoint">U+0060</span> (<span class="unicode-name">GRAVE ACCENT, BACKTICK</span>, <code>`</code>) <span class="verb">must</span> be written as <code>``</code>.</p></li></ul><p>Following the principles of the “longest token” rule, any occurrence of <code>{{</code> within the fixed part is interpreted as an escaped left curly bracket. This means that the enclosed expression must not start with <span class="unicode-codepoint">U+007B</span> (<span class="unicode-name">LEFT CURLY BRACKET</span>, <code>{</code>) : if this is required, the two left curly brackets can be separated by whitespace. For example the string template <code>`{{"key":"{ {1:"yes", 0:"no"}?$condition}"}}`</code> evaluates to the string <code>{"key":"yes"}</code> or <code>{"key":"no"}</code> depending on the value of <code>$condition</code>.</p><p>By contrast, if the enclosed expression ends with <span class="unicode-codepoint">U+007D</span> (<span class="unicode-name">RIGHT CURLY BRACKET</span>, <code>}</code>) , this can be immediately followed by the closing <span class="unicode-codepoint">U+007D</span> (<span class="unicode-name">RIGHT CURLY BRACKET</span>, <code>}</code>) delimiter without intervening whitespace.</p></li></ul><p> The result of evaluating a string template is the string obtained by concatenating the expansions of the fixed and variable parts:</p><ul><li><p>The expansion of a fixed part is obtained by replacing any double curly brackets (<code>{{</code> or <code>}}</code>) by the corresponding single curly bracket, and replacing doubled back-ticks (<code>``</code>) by a single back-tick.</p></li><li><p>The expansion of a variable part containing an expression is as follows:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to the value of the enclosed expression, converting it to a sequence of atomic items.</p></li><li><p>If the result of atomization is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result is the zero-length string. Otherwise, each atomic item in the atomized sequence is cast into a string.</p></li><li><p>The individual strings resulting from the previous step are merged into a single string by concatenating them with a single space character between each pair.</p></li></ol></li><li><p>The expansion of <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty variable part (one that contains no expression) is a zero-length string.</p></li></ul><p>For example:</p><div class="exampleInner"><pre xml:space="preserve">let $greeting := "Hello", $planet := "Mars"
return `{ $greeting }, { $planet }!`</pre></div><p>returns <code>"Hello, Mars!"</code>.</p><p>The expression:</p><div class="exampleInner"><pre xml:space="preserve">let $long-months := (1, 3, 5, 7, 8, 10, 12)
return `The months with 31 days are: { $long-months }.`</pre></div><p>returns <code>"The months with 31 days are: 1 3 5 7 8 10 12."</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The rules for processing an enclosed expression are identical to the rules for attributes in XQuery direct element constructors. These rules differ slightly from the rules in XSLT attribute value templates, where adjacent text nodes are concatenated with no separator, prior to atomization.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>A string template containing no variable parts is effectively just another way of writing a string literal: <code>"Goethe"</code>, <code>'Goethe'</code>, and <code>`Goethe`</code> are interchangeable. This means that back-ticks can sometimes be a useful way of delimiting a string that contains both single and double quotes: <code>`He said: "I didn't."`</code>.</p><p>It is sometimes useful to use string templates in conjunction with the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-char"><code>fn:char</code></a> function to build strings containing special characters, for example <code>`Chapter{ fn:char("nbsp") }{ $chapNr }`</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>String literals containing an ampersand behave differently between XPath and XQuery: in XPath (unless first expanded by an XML parser) the string literal <code>"Bacon &amp; Eggs"</code> represents a string containing an ampersand, while in XQuery it is an error, because an ampersand is taken as introducing a character reference. This difference does not arise for string templates, since neither XPath nor XQuery recognizes entity or character references in a string template. This means that back-tick delimited strings (such as <code>`Bacon &amp; Eggs`</code>) may be useful in contexts where an XPath expression is required to have the same effect whether it is evaluated using an XPath or an XQuery processor.</p></div><p>In XQuery, the token <code>``[</code> is recognized as the start of a <code>StringConstructor</code>, under the “longest token” rule (see <a href="#lexical-structure"><b>A.3 Lexical structure</b></a>). This means that the construct <code>``[1]</code> is not recognized as a <a href="#doc-xpath40-StringTemplate">StringTemplate</a> followed by a predicate. <span class="xpath">Although the token <code>``[</code> is not used in XPath, it is reserved for compatibility reasons, and <span class="verb">must</span> be rejected as syntactically invalid.</span> In the unlikely event that an empty <a href="#doc-xpath40-StringTemplate">StringTemplate</a> followed by a predicate is wanted, whitespace or parentheses can be used to avoid the tokenization problem.</p></div></div><div class="_diffs div2"><h3><a id="id-comparisons"></a>4.11 <a href="#id-comparisons" style="text-decoration: none">Comparison Expressions</a></h3><p>Comparison expressions allow two values to be compared. XPath 4.0 provides three kinds of comparison expressions, called value comparisons, general comparisons, and GNode comparisons.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ComparisonExpr"></a><code><a href="#prod-xpath40-ComparisonExpr">ComparisonExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-ComparisonExpr-OtherwiseExpr">OtherwiseExpr</a> ((<a href="#doc-xpath40-ComparisonExpr-ValueComp">ValueComp</a> | <a href="#doc-xpath40-ComparisonExpr-GeneralComp">GeneralComp</a> | <a href="#doc-xpath40-ComparisonExpr-NodeComp">NodeComp</a>) <a href="#doc-xpath40-ComparisonExpr-OtherwiseExpr">OtherwiseExpr</a>)?</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ComparisonExpr-OtherwiseExpr"></a><code><a href="#prod-xpath40-OtherwiseExpr">OtherwiseExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-StringConcatExpr">StringConcatExpr</a> ("otherwise" <a href="#doc-xpath40-StringConcatExpr">StringConcatExpr</a>)*</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ComparisonExpr-ValueComp"></a><code><a href="#prod-xpath40-ValueComp">ValueComp</a></code></td><td>::=</td><td><code>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ComparisonExpr-GeneralComp"></a><code><a href="#prod-xpath40-GeneralComp">GeneralComp</a></code></td><td>::=</td><td><code>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;="</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ComparisonExpr-NodeComp"></a><code><a href="#prod-xpath40-NodeComp">NodeComp</a></code></td><td>::=</td><td><code>"is" | "is-not" | <a href="#doc-xpath40-ComparisonExpr-NodePrecedes">NodePrecedes</a> | <a href="#doc-xpath40-ComparisonExpr-NodeFollows">NodeFollows</a> | "precedes-or-is" | "follows-or-is"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ComparisonExpr-NodePrecedes"></a><code><a href="#prod-xpath40-NodePrecedes">NodePrecedes</a></code></td><td>::=</td><td><code>"&lt;&lt;" | "precedes"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-ComparisonExpr-NodeFollows"></a><code><a href="#prod-xpath40-NodeFollows">NodeFollows</a></code></td><td>::=</td><td><code>"&gt;&gt;" | "follows"</code></td></tr></tbody></table><div class="note"><p class="prefix"><b>Note:</b></p><p class="xpath">When an XPath expression is written within an XML document, the XML escaping rules for special characters must be followed; thus <code>&lt;</code> must be written as <code>&amp;lt;</code>.</p></div><p>For a summary of the differences between different ways of comparing atomic items in XPath 4.0, see <a href="#id-atomic-comparisons"><b>G Atomic Comparisons: An Overview</b></a>.</p><div class="_diffs div3"><h4><a id="id-value-comparisons"></a>4.11.1 <a href="#id-value-comparisons" style="text-decoration: none">Value Comparisons</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-general-comparisons">next</a> | <a href="#id-string-templates">previous</a>)</p><ol><li><p> The rules for value comparisons when comparing values of different types (for example, decimal and double) have changed to be transitive. A decimal value is no longer converted to double, instead the double is converted to a decimal without loss of precision. This may affect compatibility in edge cases involving comparison of values that are numerically very close. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/986">986</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2218">2218</a>&nbsp;29 September 2025]</i></p></li><li><p> An ordering is now defined for all data types. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2216">2216</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2256">2256</a>&nbsp;1 December 2025]</i></p></li></ol></div><p>The value comparison operators are <code>eq</code>, <code>ne</code>, <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code>. Value comparisons are used for comparing single <a title="atomic item" class="termref" href="#dt-atomic-item">atomic items</a>.</p><p>The first step in evaluating a value comparison is to evaluate its operands. The order in which the operands are evaluated is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. Each operand is evaluated by applying the following steps, in order:</p><ol class="enumar"><li><p><a title="atomization" class="termref" href="#dt-atomization">Atomization</a> is applied to each operand. The result of this operation is called the <b>atomized operand</b>.</p></li><li><p>If either or both of the atomized operands is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result of the value comparison is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, and the implementation need not evaluate the other operand or apply the operator. However, an implementation may choose to evaluate the other operand and may raise an error if evaluation fails.</p></li><li><p> If an atomized operand is a sequence of length greater than one, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>If both operands are instances of <code>xs:numeric</code>, and if either or both of the atomized operands is <code>NaN</code>, then the result is <code>false</code> if the operator is <code>eq</code>, <code>lt</code>, <code>gt</code>, <code>le</code>, or <code>ge</code>, but <code>true</code> if the operator is <code>ne</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>When an operand is <code>NaN</code>, the effect of a value comparison expression differs from the result of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-compare"><code>fn:compare</code></a> function.</p></div></li><li><p>The function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-compare"><code>fn:compare</code></a> is then called, supplying the two atomized operands as the first two arguments. The collation used by <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-compare"><code>fn:compare</code></a> is the default collation from the static context, and the implicit timezone used by the function is the implicit timezone from the dynamic context.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of this rule is that <code>xs:untypedAtomic</code> values (which typically result from atomizing a node) are treated as strings.</p></div></li><li><p>If <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-compare"><code>fn:compare</code></a> raises an error (typically because the two operands belong to different <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-type-family">type families</a><sup><small>DM</small></sup>), then the value comparison fails with that error.</p></li><li><p>The result of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-compare"><code>fn:compare</code></a> function determines the result of the value comparison, according to the following table:</p><table><caption>Result of a Value Comparison</caption><thead><tr><th>Result of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-compare"><code>fn:compare</code></a></th><th><code>eq</code></th><th><code>ne</code></th><th><code>lt</code></th><th><code>le</code></th><th><code>gt</code></th><th><code>ge</code></th></tr></thead><tbody><tr><td><code>-1</code></td><td><code>false</code></td><td><code>true</code></td><td><code>true</code></td><td><code>true</code></td><td><code>false</code></td><td><code>false</code></td></tr><tr><td><code>0</code></td><td><code>true</code></td><td><code>false</code></td><td><code>false</code></td><td><code>true</code></td><td><code>false</code></td><td><code>true</code></td></tr><tr><td><code>+1</code></td><td><code>false</code></td><td><code>true</code></td><td><code>false</code></td><td><code>false</code></td><td><code>true</code></td><td><code>true</code></td></tr></tbody></table></li></ol><p>Here are some examples of value comparisons:</p><ul><li><p><span style="display: none;" class="delete_version">The following comparison atomizes the node(s) that are returned by the expression <code>$book/author</code>. The comparison is true only if the result of atomization is the value "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>. If the result of atomization is an empty sequence, the result of the comparison is an empty sequence. If the result of atomization is a sequence containing more than one value, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</span><span style="display: none;" class="add_version">The following comparison atomizes the node(s) that are returned by the expression <code>$book/author</code>. The comparison is true only if the result of atomization is the value "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>. If the result of atomization is the empty sequence, the result of the comparison is the empty sequence. If the result of atomization is a sequence containing more than one value, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</span><span class="modify_version">The following comparison atomizes the node(s) that are returned by the expression <code>$book/author</code>. The comparison is true only if the result of atomization is the value "Kennedy" as an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>. If the result of atomization is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result of the comparison is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. If the result of atomization is a sequence containing more than one value, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</span></p><div class="exampleInner"><pre xml:space="preserve">$book1/author eq "Kennedy"</pre></div></li><li><p>The following comparison is <code>true</code> because atomization converts an array to its member sequence:</p><div class="exampleInner"><pre xml:space="preserve">[ "Kennedy" ] eq "Kennedy"</pre></div></li><li><p>The following <a title="path expression" class="termref" href="#dt-path-expression">path expression</a> contains a predicate that selects products whose weight is greater than 100. For any product that does not have a <code>weight</code> subelement, the value of the predicate is the empty sequence, and the product is not selected. This example assumes that <code>weight</code> is a validated element with a numeric type.</p><div class="exampleInner"><pre xml:space="preserve">//product[weight gt 100]</pre></div></li><li><p>The following comparison is true if <code>my:hatsize</code> and <code>my:shoesize</code> are both user-defined types that are derived by restriction from a primitive <a title="numeric" class="termref" href="#dt-numeric">numeric</a> type:</p><div class="exampleInner"><pre xml:space="preserve">my:hatsize(5) eq my:shoesize(5)</pre></div></li><li><p>The following comparison is true. The <code>eq</code> operator compares two QNames by performing codepoint-comparisons of their namespace URIs and their local names, ignoring their namespace prefixes.</p><div class="exampleInner"><pre xml:space="preserve">QName("http://example.com/ns1", "this:color") eq
QName("http://example.com/ns1", "that:color")</pre></div></li><li><p>The following comparison is false. The <code>xs:double</code> value <code>1.1e0</code> is converted to type <code>xs:decimal</code>, giving the result <code>1.100000000000000088817841970012523233890533447265625</code>, which is not equal to the <code>xs:decimal</code> value <code>1.1</code>.</p><div class="exampleInner"><pre xml:space="preserve">1.1 eq 1.1e0</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>This is incompatible with previous versions, which converted both operands to <code>xs:double</code> before comparing them. This change has been made because there are contexts (such as sorting and grouping) where it is important that comparison results should be transitive, and this was not previously the case.</p></div></li></ul></div><div class="_diffs div3"><h4><a id="id-node-comparisons"></a>4.11.3 <a href="#id-node-comparisons" style="text-decoration: none">GNode Comparisons</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-logical-expressions">next</a> | <a href="#id-general-comparisons">previous</a>)</p><ol><li><p> Operator <code>is-not</code> is introduced, as a complement to the operator <code>is</code>. <i>&nbsp;&nbsp;[&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2130">2130</a>&nbsp;28 July 2025]</i></p></li><li><p> Operators <code>precedes</code> and <code>follows</code> are introduced as synonyms for operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code>. <i>&nbsp;&nbsp;[&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2130">2130</a>&nbsp;28 July 2025]</i></p></li><li><p> Operators <code>precedes-or-is</code> and <code>follows-or-is</code> are introduced as synonyms for the union of operators <code>&lt;&lt;</code> and <code>is</code> and for the union of operators <code>&gt;&gt;</code> and <code>is</code>, respectively. <i>&nbsp;&nbsp;[&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2176">2176</a>&nbsp;22 August 2025]</i></p></li></ol></div><p>GNode comparisons are used to compare two <a title="GNode" class="termref" href="#dt-GNode">GNodes</a> (that is, <a title="XNode" class="termref" href="#dt-XNode">XNodes</a> or <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-JNode">JNodes</a><sup><small>DM</small></sup>), by their identity or by their <a title="document order" class="termref" href="#dt-document-order">document order</a>. The result of a GNode comparison is defined by the following rules:</p><ol class="enumar"><li><p>The operands of a <a title="GNode" class="termref" href="#dt-GNode">GNode</a> comparison are evaluated in <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order.</p></li><li><p>If either operand is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result of the comparison is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, and the implementation need not evaluate the other operand or apply the operator. However, an implementation may choose to evaluate the other operand in order to determine whether it raises an error.</p></li><li><p> Each operand must be either a single <a title="GNode" class="termref" href="#dt-GNode">GNode</a> or <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence; otherwise a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>A comparison with the <code>is</code> operator is <code>true</code> if the values of two operands are the same GNode; otherwise it is <code>false</code>. See <a href="#xpath-datamodel-40">[XDM 4.0]</a> for the definition of GNode identity.</p></li><li><p>A comparison with the <code>is-not</code> operator is <code>false</code> if the values of two operands are the same GNode; otherwise it is <code>true</code>. See <a href="#xpath-datamodel-40">[XDM 4.0]</a> for the definition of GNode identity.</p></li><li><p>A comparison with the <code>&lt;&lt;</code> or <code>precedes</code> operator returns <code>true</code> if the left operand <a title="GNode" class="termref" href="#dt-GNode">GNode</a> precedes the right operand GNode in <a title="document order" class="termref" href="#dt-document-order">document order</a>; otherwise it returns <code>false</code>.</p></li><li><p>A comparison with the <code>&gt;&gt;</code> or <code>follows</code> operator returns <code>true</code> if the left operand GNode follows the right operand GNode in <a title="document order" class="termref" href="#dt-document-order">document order</a>; otherwise it returns <code>false</code>.</p></li><li><p>A comparison with the <code>precedes-or-is</code> operator returns <code>true</code> if the left operand <a title="GNode" class="termref" href="#dt-GNode">GNode</a> precedes the right operand GNode in <a title="document order" class="termref" href="#dt-document-order">document order</a> or if the values of two operands are the same GNode; otherwise it returns <code>false</code>.</p></li><li><p>A comparison with the <code>follows-or-is</code> operator returns <code>true</code> if the left operand <a title="GNode" class="termref" href="#dt-GNode">GNode</a> follows the right operand GNode in <a title="document order" class="termref" href="#dt-document-order">document order</a> or if the values of two operands are the same GNode; otherwise it returns <code>false</code>.</p></li></ol><p>Here are some examples of GNode comparisons:</p><ul><li><p>The following comparison is true only if the left and right sides each evaluate to exactly the same single node:</p><div class="exampleInner"><pre xml:space="preserve">/books/book[isbn = "1558604820"] is /books/book[call = "QA76.9 C3845"]</pre></div></li><li><p>The following comparison is true only if the node identified by the left side occurs before the node identified by the right side in document order:</p><div class="exampleInner"><pre xml:space="preserve">/transactions/purchase[parcel = "28-451"] &lt;&lt; /transactions/sale[parcel = "33-870"]</pre></div></li><li><p>The following comparison is true only if the first integer among the members of an array precedes the first string. This expression compares two JNodes:</p><div class="exampleInner"><pre xml:space="preserve">let $A := ["Q", 3, "E", "R", "T", 5, "Y"]
return $A ? child::type(xs:integer)[1] precedes $A ? child::type(xs:string)[1]</pre></div></li></ul></div></div><div class="_diffs div2"><h3><a id="id-flwor-expressions"></a>4.13 <a href="#id-flwor-expressions" style="text-decoration: none"><span class="xpath">For and Let Expressions</span></a></h3><p class="xpath">XPath provides two closely-related expressions, called For and Let expressions, that can be used to bind variables to values. These are described in the following sections.</p><div class="_diffs div3 xpath"><h4><a id="id-let-expressions"></a>4.13.2 <a href="#id-let-expressions" style="text-decoration: none">Let Expressions</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-maps">next</a> | <a href="#id-for-expressions">previous</a>)</p><ol><li><p> Multiple <code>for</code> and <code>let</code> clauses can be combined in an expression without an intervening <code>return</code> keyword. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/22">22</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/28">28</a>&nbsp;18 December 2020]</i></p></li><li><p> The type of a variable used in a <code>let</code> expression can be declared. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/796">796</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1131">1131</a>&nbsp;1 April 2024]</i></p></li><li><p> Sequences, arrays, and maps can be destructured in a <code>let</code> expression to extract their components into multiple variables. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/37">37</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2055">2055</a>&nbsp;17 June 2025]</i></p></li></ol></div><p>XPath allows a variable to be declared and bound to a value using a <b>let expression</b>.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-LetExpr"></a><code><a href="#prod-xpath40-LetExpr">LetExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-LetExpr-LetClause">LetClause</a><a href="#doc-xpath40-LetExpr-ForLetReturn">ForLetReturn</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-LetExpr-LetClause"></a><code><a href="#prod-xpath40-LetClause">LetClause</a></code></td><td>::=</td><td><code>"let" (<a href="#doc-xpath40-LetExpr-LetBinding">LetBinding</a> ++ ",")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-LetExpr-LetBinding"></a><code><a href="#prod-xpath40-LetBinding">LetBinding</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-LetExpr-LetValueBinding">LetValueBinding</a> | <a href="#doc-xpath40-LetExpr-LetSequenceBinding">LetSequenceBinding</a> | <a href="#doc-xpath40-LetExpr-LetArrayBinding">LetArrayBinding</a> | <a href="#doc-xpath40-LetExpr-LetMapBinding">LetMapBinding</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-LetExpr-LetValueBinding"></a><code><a href="#prod-xpath40-LetValueBinding">LetValueBinding</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-LetExpr-VarNameAndType">VarNameAndType</a> ":=" <a href="#doc-xpath40-LetExpr-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-LetExpr-VarNameAndType"></a><code><a href="#prod-xpath40-VarNameAndType">VarNameAndType</a></code></td><td>::=</td><td><code>"$" <a href="#doc-xpath40-LetExpr-EQName">EQName</a><a href="#doc-xpath40-LetExpr-TypeDeclaration">TypeDeclaration</a>?</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-LetExpr-EQName"></a><code><a href="#prod-xpath40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-QName">QName</a> | <a href="#prod-xpath40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-LetExpr-TypeDeclaration"></a><code><a href="#prod-xpath40-TypeDeclaration">TypeDeclaration</a></code></td><td>::=</td><td><code>"as" <a href="#doc-xpath40-LetExpr-SequenceType">SequenceType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-LetExpr-ExprSingle"></a><code><a href="#prod-xpath40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-LetExpr-ForExpr">ForExpr</a><br>| <a href="#doc-xpath40-LetExpr">LetExpr</a><br>| <a href="#doc-xpath40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xpath40-IfExpr">IfExpr</a><br>| <a href="#doc-xpath40-OrExpr">OrExpr</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-LetExpr-LetSequenceBinding"></a><code><a href="#prod-xpath40-LetSequenceBinding">LetSequenceBinding</a></code></td><td>::=</td><td><code>"$" "(" (<a href="#doc-xpath40-LetExpr-VarNameAndType">VarNameAndType</a> ++ ",") ")" <a href="#doc-xpath40-LetExpr-TypeDeclaration">TypeDeclaration</a>? ":=" <a href="#doc-xpath40-LetExpr-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-LetExpr-SequenceType"></a><code><a href="#prod-xpath40-SequenceType">SequenceType</a></code></td><td>::=</td><td><code>("empty-sequence" "(" ")")<br>| (<a href="#doc-xpath40-ItemType">ItemType</a><a href="#prod-xpath40-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-LetExpr-LetArrayBinding"></a><code><a href="#prod-xpath40-LetArrayBinding">LetArrayBinding</a></code></td><td>::=</td><td><code>"$" "[" (<a href="#doc-xpath40-LetExpr-VarNameAndType">VarNameAndType</a> ++ ",") "]" <a href="#doc-xpath40-LetExpr-TypeDeclaration">TypeDeclaration</a>? ":=" <a href="#doc-xpath40-LetExpr-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-LetExpr-LetMapBinding"></a><code><a href="#prod-xpath40-LetMapBinding">LetMapBinding</a></code></td><td>::=</td><td><code>"$" "{" (<a href="#doc-xpath40-LetExpr-VarNameAndType">VarNameAndType</a> ++ ",") "}" <a href="#doc-xpath40-LetExpr-TypeDeclaration">TypeDeclaration</a>? ":=" <a href="#doc-xpath40-LetExpr-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-LetExpr-ForLetReturn"></a><code><a href="#prod-xpath40-ForLetReturn">ForLetReturn</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-LetExpr-ForExpr">ForExpr</a> | <a href="#doc-xpath40-LetExpr">LetExpr</a> | ("return" <a href="#doc-xpath40-LetExpr-ExprSingle">ExprSingle</a>)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-LetExpr-ForExpr"></a><code><a href="#prod-xpath40-ForExpr">ForExpr</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-ForClause">ForClause</a><a href="#doc-xpath40-LetExpr-ForLetReturn">ForLetReturn</a></code></td></tr></tbody></table><p>A let expression is evaluated as follows:</p><ol class="enumar"><li><p>If the let expression uses multiple variables, it is first expanded to a set of nested let expressions, each of which uses only one variable. Specifically, any separating comma is replaced by <code>let</code>.</p><div class="example"><div class="exampleHeader"><a id="d2e29641"></a><a id="d2e29638"></a>Example:</div><p>The expression:</p><div class="exampleInner"><pre xml:space="preserve">let $x := 4, $y := 3 return $x + $y</pre></div><p>is expanded to:</p><div class="exampleInner"><pre xml:space="preserve">let $x := 4 let $y := 3 return $x + $y</pre></div></div></li><li><p>In a <a href="#prod-xpath40-LetValueBinding">LetValueBinding</a> such as <code>let $<var>V</var> as <var>T</var> := <var>EXPR</var></code>:</p><ol class="enumla"><li><p>The variable <var>V</var> is called the <b>range variable</b>.</p></li><li><p>The sequence type <var>T</var> is called the <b>declared type</b>. If there is no declared type, then <code>item()*</code> is assumed.</p></li><li><p>The expression <var>EXPR</var> is evaluated, and its value is converted to the declared type by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. The resulting value is called the <b>binding sequence</b>.</p></li></ol></li><li><p>In a <a href="#prod-xpath40-LetSequenceBinding">LetSequenceBinding</a> such as <code>let $( $<var>A<sub>1</sub></var> as <var>T<sub>1</sub></var>, $<var>A<sub>2</sub></var> as <var>T<sub>2</sub></var>, ... , $<var>A<sub>n</sub></var> as <var>T<sub>n</sub></var> ) as <var>ST</var> := <var>EXPR</var></code>:</p><ol class="enumla"><li><p>The sequence type <var>ST</var> is called the <b>declared sequence type</b>. If there is no declared sequence type, then <code>item()*</code> is assumed.</p></li><li><p>The expression <var>EXPR</var> is evaluated, and its value is converted to the declared sequence type <var>ST</var> by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. Call the resulting (coerced) value <var>V</var>.</p></li><li><p>Each variable <var>A<sub>i</sub></var> (for <var>i</var> in 1 to <var>n</var>-1) is effectively replaced by a <a href="#prod-xpath40-LetValueBinding">LetValueBinding</a> of the form <code>let <var>A<sub>i</sub></var> as <var>T<sub>i</sub></var> := items-at(<var>V</var>, <var>i</var>)</code>. That is, a <b>range variable</b> named <var>A<sub>i</sub></var> is declared, whose <b>binding sequence</b> is the item <var>V[ i ]</var>, after coercion to the type <var>T<sub>i</sub></var> if specified. If <var>T<sub>i</sub></var> is absent, no further coercion takes place (the default is effectively <code>item()?</code>).</p></li><li><p>The last variable <var>A<sub>n</sub></var> is effectively replaced by a <a href="#prod-xpath40-LetValueBinding">LetValueBinding</a> of the form <code>let <var>A<sub>n</sub></var> as <var>T<sub>n</sub></var> := subsequence(<var>V</var>, <var>n</var>)</code>. That is, the last variable is bound to the rest of the binding sequence (or to the empty sequence if the binding sequence has fewer items than the number of variables). </p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">If <var>i</var> exceeds the length of the sequence <var>V</var>, then <var>A<sub>i</sub></var> is bound to an empty sequence. This will cause a type error if type <var>T<sub>i</sub></var> does not permit an empty sequence.</span><span style="display: none;" class="add_version">If <var>i</var> exceeds the length of the sequence <var>V</var>, then <var>A<sub>i</sub></var> is bound to the empty sequence. This will cause a type error if type <var>T<sub>i</sub></var> does not permit the empty sequence.</span><span class="modify_version">If <var>i</var> exceeds the length of the sequence <var>V</var>, then <var>A<sub>i</sub></var> is bound to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. This will cause a type error if type <var>T<sub>i</sub></var> does not permit <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>It is permissible to bind several variables with the same name; all but the last are occluded. A useful convention is therefore to bind items in the sequence that are of no interest to the variable <code>$_</code>: for example <code>let $( $_, $_, $x ) := <var>EXPR</var></code> effectively binds <code>$x</code> to the third item in the sequence and causes the first two items to be ignored.</p></div><div class="example"><div class="exampleHeader"><a id="d2e29827"></a><a id="d2e29824"></a>Example:</div><p>The expression:</p><div class="exampleInner"><pre xml:space="preserve">let $( $a, $b as xs:integer, $local:c ) := (2, 4, 6)
return $a + $b + $local:c</pre></div><p>is expanded to:</p><div class="exampleInner"><pre xml:space="preserve">let $temp := (2, 4, 6)
let $a := fn:items-at($temp, 1)
let $b as xs:integer := fn:items-at($temp, 2)
let $local:c := fn:subsequence($temp, 3)
return $a + $b + $local:c</pre></div><p>where <code>$temp</code> is some variable name that is otherwise unused.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d2e29840"></a><a id="d2e29837"></a>Example:</div><p>Consider the element <var>$E</var> := <code>&lt;e A="p q r" B="x y z"/&gt;</code>.</p><p>Then consider the expression:</p><div class="exampleInner"><pre xml:space="preserve">let $( $a, $b ) := $E!(@A, @B)</pre></div><p>Here the binding sequence is a sequence of two attribute nodes, so <code>$a</code> is bound to the attribute <code>@A</code>, and <code>$b</code> is bound to the attribute node <code>@B</code>.</p><p>If the operator <code>"!"</code> were replaced by <code>"/"</code>, or if <code>","</code> were replaced by <code>"|"</code>, then the binding sequence would be sorted into document order, and since the order of attributes is not defined, this would make it unpredictable which variable is bound to which attribute node.</p><p>Now consider what happens when a declared sequence type is added:</p><div class="exampleInner"><pre xml:space="preserve">let $( $a, $b ) as xs:string* := $E!(@A, @B)</pre></div><p>The sequence of two attribute nodes is now atomized to form a sequence of strings. The first string in this sequence is bound to <code>$a</code>, and the remainder of the sequence is bound to <code>$b</code>. If the element <code>$E</code> is untyped, this will result in <code>$a</code> being bound to the <code>xs:untypedAtomic</code> value <code>"p q r"</code>, while <code>$b</code> is bound to the <code>xs:untypedAtomic</code> value <code>"x y z"</code>.</p><p>However, suppose that the element <code>$E</code> has been validated against a schema that defines both attributes <code>@A</code> and <code>@B</code> as list types with item type <code>xs:string</code>. In this case, the atomized value of <code>$E</code> will be a sequence of six strings. The variable <code>$a</code> is bound to the first of these strings (that is, <code>"p"</code>), while <code>$b</code> is bound to a sequence containing the remaining five strings (that is, <code>("q", "r", "x", "y", "z")</code>).</p><p>By contrast, if the expression is written as:</p><div class="exampleInner"><pre xml:space="preserve">let $( $a as xs:string*, $b as xs:string* ) := $E!(@A, @B)</pre></div><p>then <code>$a</code> is bound to the result of atomizing the first attribute (the <code>untypedAtomic</code> value <code>"p q r"</code> in the untyped case, or the sequence of three strings <code>("p", "q", "r")</code> in the schema-validated case), while <code>$b</code> is similarly bound to the result of atomizing the second attribute.</p></div></li><li><p>In a <a href="#prod-xpath40-LetArrayBinding">LetArrayBinding</a> such as <code>let $[ $<var>A<sub>1</sub></var> as <var>T<sub>1</sub></var>, $<var>A<sub>2</sub></var> as <var>T<sub>2</sub></var>, ... , $<var>A<sub>n</sub></var> as <var>T<sub>n</sub></var> ] as <var>AT</var> := <var>EXPR</var></code>:</p><ol class="enumla"><li><p>The sequence type <var>AT</var> is called the <b>declared array type</b>. If there is no declared array type, then <code>array(*)</code> is assumed.</p></li><li><p>The expression <var>EXPR</var> is evaluated, and its value is converted to the declared array type <var>AT</var> by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. A type error [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] is raised if the result is not a <a title="singleton" class="termref" href="#dt-singleton">singleton</a> array. Call the resulting (coerced) value <var>V</var>.</p></li><li><p>Each variable <var>A<sub>i</sub></var> (for <var>i</var> in 1 to <var>n</var>) is effectively replaced by a <a href="#prod-xpath40-LetValueBinding">LetValueBinding</a> of the form <code>let <var>A<sub>i</sub></var> as <var>T<sub>i</sub></var> := array:get(<var>V</var>, <var>i</var>)</code>. That is, a <b>range variable</b> named <var>A<sub>i</sub></var> is declared, whose <b>binding sequence</b> is the array member <var>V ? i</var>, after coercion to the type <var>T<sub>i</sub></var> if specified. If <var>T<sub>i</sub></var> is absent, no further coercion takes place (the default is effectively <code>item()*</code>).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If <var>i</var> exceeds the length of the array <var>V</var>, then a dynamic error [<a href="https://www.w3.org/TR/xpath-functions/#ERRFOAR0001" title="err:FOAR0001">err:FOAR0001</a>]<sup><small>FO</small></sup> is raised.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>It is permissible to bind several variables with the same name; all but the last are occluded. A useful convention is therefore to bind items in the sequence that are of no interest to the variable <code>$_</code>: for example <code>let $( $_, $_, $x ) := <var>EXPR</var></code> effectively binds <code>$x</code> to the third item in the sequence and causes the first two items to be ignored.</p></div><div class="example"><div class="exampleHeader"><a id="d2e30082"></a><a id="d2e30079"></a>Example:</div><p>The expression:</p><div class="exampleInner"><pre xml:space="preserve">let $[ $a, $b as xs:integer, $local:c ] := [ 2, 4, 6 ]
return $a + $b + $local:c</pre></div><p>is expanded to:</p><div class="exampleInner"><pre xml:space="preserve">let $temp := [ 2, 4, 6 ]
let $a := array:get($temp, 1, ())
let $b as xs:integer := array:get($temp, 2, ())
let $local:c := array:get($temp, 3, ())
return $a + $b + $local:c</pre></div><p>where <code>$temp</code> is some variable name that is otherwise unused.</p></div></li></ol></li><li><p>In a <a href="#prod-xpath40-LetMapBinding">LetMapBinding</a> such as <code>let ${ $<var>A<sub>1</sub></var> as <var>T<sub>1</sub></var>, $<var>A<sub>2</sub></var> as <var>T<sub>2</sub></var>, ... , $<var>A<sub>n</sub></var> as <var>T<sub>n</sub></var> } as <var>MT</var> := <var>EXPR</var></code>:</p><ol class="enumla"><li><p>The sequence type <var>MT</var> is called the <b>declared map type</b>. If there is no declared map type, then <code>map(*)</code> is assumed.</p></li><li><p>The expression <var>EXPR</var> is evaluated, and its value is converted to the declared map type <var>MT</var> by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. A type error [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>] is raised if the result is not a <a title="singleton" class="termref" href="#dt-singleton">singleton</a> map. Call the resulting (coerced) value <var>V</var>.</p></li><li><p>Each variable <var>A<sub>i</sub></var> (for <var>i</var> in 1 to <var>n</var>) is effectively replaced by a <a href="#prod-xpath40-LetValueBinding">LetValueBinding</a> of the form <code>let <var>A<sub>i</sub></var> as <var>T<sub>i</sub></var> := map:get(<var>V</var>, "<var>N<sub>i</sub></var>", ())</code>, where <var>N<sub>i</sub></var> is the local part of the name of the variable <var>A<sub>i</sub></var>. That is, a <b>range variable</b> named <var>A<sub>i</sub></var> is declared, whose <b>binding sequence</b> is the value of the map entry in <var>V</var> whose key is an <code>xs:string</code> (or <code>xs:anyURI</code> or <code>xs:untypedAtomic</code>) equal to the local part of the variable name, after coercion to the type <var>T<sub>i</sub></var> if specified. If <var>T<sub>i</sub></var> is absent, no further coercion takes place (the default is effectively <code>item()*</code>).</p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">If there is no entry in the map with a key corresponding to the variable name, then the variable <var>A<sub>i</sub></var> is bound to an empty sequence. This will cause a type error if type <var>T<sub>i</sub></var> does not permit an empty sequence.</span><span style="display: none;" class="add_version">If there is no entry in the map with a key corresponding to the variable name, then the variable <var>A<sub>i</sub></var> is bound to the empty sequence. This will cause a type error if type <var>T<sub>i</sub></var> does not permit the empty sequence.</span><span class="modify_version">If there is no entry in the map with a key corresponding to the variable name, then the variable <var>A<sub>i</sub></var> is bound to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. This will cause a type error if type <var>T<sub>i</sub></var> does not permit <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>It is not possible to use this mechanism to bind variables to values in a map unless the keys in the map are strings in the form of <code>NCNames</code>.</p></div><div class="example"><div class="exampleHeader"><a id="d2e30216"></a><a id="d2e30213"></a>Example:</div><p>The expression:</p><div class="exampleInner"><pre xml:space="preserve">let ${ $a, $b as xs:integer, $local:c } := { "a": 2, "b": 4, "c": 6, "d": 8 }
return $a + $b + $local:c</pre></div><p>is expanded to:</p><div class="exampleInner"><pre xml:space="preserve">let $temp := { "a": 2, "b": 4, "c": 6 }
let $a := map:get($temp, "a", ())
let $b as xs:integer := map:get($temp, "b", ())
let $local:c := map:get($temp, "c", ())
return $a + $b + $local:c</pre></div><p>where <code>$temp</code> is some variable name that is otherwise unused.</p></div></li></ol></li><li><p>The expression in the <a href="#prod-xpath40-ForLetReturn">ForLetReturn</a> part (that is, the following <a href="#doc-xpath40-LetExpr">LetExpr</a> or <a href="#doc-xpath40-ForExpr">ForExpr</a>, or the <a href="#doc-xpath40-ExprSingle">ExprSingle</a> that follows the <code>return</code> keyword) is called the <b>return expression</b>. The result of the let expression is obtained by evaluating the <b>return expression</b> with a dynamic context in which each range variable is bound to the corresponding binding sequence. </p></li></ol><p>The scope of a variable bound in a let expression is the <b>return expression</b>. The scope does not include the expression to which the variable is bound. The following example illustrates how a variable binding may reference another variable bound earlier in the same let expression:</p><div class="exampleInner"><pre xml:space="preserve">let $x := doc('a.xml')/*, $y := $x//*
return $y[@value gt $x/@min]</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>It is not required that the variables should have distinct names. It is permitted, for example, to write:</p><div class="exampleInner"><pre xml:space="preserve">let $x := "[A fine romance]"
let $x := substring-after($x, "[")
let $x := substring-before($x, "]")
return upper-case($x)</pre></div><p>which returns the result <code>"A FINE ROMANCE"</code>. Note that this expression declares three separate variables which happen to have the same name; it should not be read as declaring a single variable and binding it successively to different values.</p></div></div></div><div class="_diffs div2"><h3><a id="id-maps-and-arrays"></a>4.14 <a href="#id-maps-and-arrays" style="text-decoration: none">Maps and Arrays</a></h3><p>Most modern programming languages have support for collections of key/value pairs, which may be called maps, dictionaries, associative arrays, hash tables, keyed lists, or objects (these are not the same thing as objects in object-oriented systems). In XPath 4.0, we call these maps. Most modern programming languages also support ordered lists of values, which may be called arrays, vectors, or sequences. In XPath 4.0, we have both sequences and arrays. Unlike sequences, an array is an item, and can appear as an item in a sequence.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The XPath 4.0 specification focuses on syntax provided for maps and arrays, especially constructors and lookup.</p><p>Some of the functionality typically needed for maps and arrays is provided by functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#maps">14 Processing maps</a> and <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#arrays">15 Processing arrays</a>, including functions used to read JSON to create maps and arrays, serialize maps and arrays to JSON, combine maps to create a new map, remove map entries to create a new map, iterate over the keys of a map, convert an array to create a sequence, combine arrays to form a new array, and iterate over arrays in various ways.</p></div><div class="_diffs div3"><h4><a id="id-lookup"></a>4.14.3 <a href="#id-lookup" style="text-decoration: none">Lookup Expressions</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-methods">next</a> | <a href="#id-map-constructors">previous</a>)</p><ol><li><p> The lookup operator <code>?</code> can now be followed by an arbitrary literal, for cases where keys are items other than integers or NCNames. It can also be followed by a variable reference or a context value reference. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1996">1996</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2134">2134</a>&nbsp;29 July 2025]</i></p></li></ol></div><p>The operator "?", known as the lookup operator, returns values found in the operand map or array.</p><div class="_diffs div4"><h5><a id="id-lookup-vs-path-expressions"></a>4.14.3.3 <a href="#id-lookup-vs-path-expressions" style="text-decoration: none">Comparing Lookup and Path Expressions</a></h5><p>Lookup expressions are retained in this specification with only minor changes from the previous version 3.1. They remain a convenient solution for simple lookups of entries in maps and arrays.</p><p>For more complex queries into trees of maps and arrays, XPath 4.0 introduces a generalization of path expressions (see <a href="#id-path-expressions"><b>4.7 Path Expressions</b></a>) which can now handle <a title="JTree" class="termref" href="#dt-JTree">JTrees</a> as well as <a title="XTree" class="termref" href="#dt-XTree">XTrees</a>.</p><p>For simple expressions, the capabilities of the two constructs overlap. For example, if <code>$m</code> is a map, then the expressions <code>$m?code = 3</code> and <code>$m/code = 3</code> have the same effect. Path expressions, however, have more power, and with it, more complexity. The expression <code>$m/code = 3</code> (unless simplified by an optimizer) effectively expands the expression to <code>(jtree($m)/child::get("code") =&gt; jnode-content()) = 3</code>: that is, the supplied map is wrapped in a JNode, the child axis returns a sequence of JNodes, and the <b>·content·</b> properties of these JNodes are compared with the supplied value <code>3</code>.</p><p>Whereas simple lookups of specific entries in maps and arrays work well, experience has shown that the <code>?*</code> wildcard lookup can be problematic. This is because of the flattening effect: for example, given the array <code>let $A := [(1,2), (3,4), (), 5]</code> the result of the expression <code>$A?*</code> is the sequence <code>(1, 2, 3, 4, 5)</code> which loses information that might be needed for further processing. By contrast, the path expression <code>$A/*</code> (or <code>$A/child::*</code>) returns a sequence of four JNodes, whose <b>·content·</b> properties are respectively <code>(1,2)</code>, <code>(3,4)</code>, <code>()</code>, and <code>5</code>.</p><p>The result of a lookup expression is a simple value (the value of an entry in a map or a member of an array, or the <a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation">sequence concatenation</a> of several such values). By contrast, the result of a path expression applied to maps or arrays is always a sequence of JNodes. These JNodes can be used for further navigation. If only the <b>·content·</b> properties of the JNodes are needed, these will usually be extracted automatically by virtue of the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>: for example if the value is used in an arithmetic expression or a value comparison, atomization of the JNode automatically extracts its <b>·content·</b>. In other cases the value can be extracted explicitly by a call of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-jnode-content"><code>jnode-content</code></a> function.</p><p><span style="display: none;" class="delete_version">Lookup expressions on arrays result in a dynamic error if the subscript is out of bounds, whereas the equivalent path expression succeeds, returning an empty sequence. For example <code>array{1 to 5}?10</code> raises [<a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOAY0001" title="err:FOAY0001">err:FOAY0001</a>]<sup><small>FO40</small></sup>, whereas <code>array{1 to 5}/get(10)</code> returns a empty sequence. </span><span style="display: none;" class="add_version">Lookup expressions on arrays result in a dynamic error if the subscript is out of bounds, whereas the equivalent path expression succeeds, returning the empty sequence. For example <code>array{1 to 5}?10</code> raises [<a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOAY0001" title="err:FOAY0001">err:FOAY0001</a>]<sup><small>FO40</small></sup>, whereas <code>array{1 to 5}/get(10)</code> returns a empty sequence. </span><span class="modify_version">Lookup expressions on arrays result in a dynamic error if the subscript is out of bounds, whereas the equivalent path expression succeeds, returning <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. For example <code>array{1 to 5}?10</code> raises [<a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFOAY0001" title="err:FOAY0001">err:FOAY0001</a>]<sup><small>FO40</small></sup>, whereas <code>array{1 to 5}/get(10)</code> returns a empty sequence. </span></p></div></div><div class="_diffs div3"><h4><a id="id-filter-maps-and-arrays"></a>4.14.5 <a href="#id-filter-maps-and-arrays" style="text-decoration: none">Filter Expressions for Maps and Arrays</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-conditionals">next</a> | <a href="#id-methods">previous</a>)</p><ol><li><p> Filter expressions for maps and arrays are introduced. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1159">1159</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1163">1163</a>&nbsp;20 April 2024]</i></p></li><li><p> Predicates in filter expressions for maps and arrays can now be numeric. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1207">1207</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1217">1217</a>&nbsp;15 May 2024]</i></p></li><li><p> The group is considering removing or substantially changing this feature, it is considered <a href="#at-risk">at risk</a>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2351">2351</a>&nbsp;]</i></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-FilterExprAM"></a><code><a href="#prod-xpath40-FilterExprAM">FilterExprAM</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-FilterExprAM-PostfixExpr">PostfixExpr</a> "?[" <a href="#doc-xpath40-FilterExprAM-Expr">Expr</a> "]"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-FilterExprAM-PostfixExpr"></a><code><a href="#prod-xpath40-PostfixExpr">PostfixExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-PrimaryExpr">PrimaryExpr</a> | <a href="#doc-xpath40-FilterExpr">FilterExpr</a> | <a href="#doc-xpath40-DynamicFunctionCall">DynamicFunctionCall</a> | <a href="#doc-xpath40-LookupExpr">LookupExpr</a> | <a href="#doc-xpath40-MethodCall">MethodCall</a> | <a href="#doc-xpath40-FilterExprAM">FilterExprAM</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-FilterExprAM-Expr"></a><code><a href="#prod-xpath40-Expr">Expr</a></code></td><td>::=</td><td><code>(<a href="#doc-xpath40-ExprSingle">ExprSingle</a> ++ ",")</code></td></tr></tbody></table><p>Maps and arrays can be filtered using the construct <code><var>INPUT</var>?[<var>FILTER</var>]</code>. For example, <code>$array?[count(.)=1]</code> filters an array to retain only those members that are single items.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The character-pair <code>?[</code> forms a single token; no intervening whitespace or comment is allowed.</p></div><p><span style="display: none;" class="delete_version">The required type of the left-hand operand <code><var>INPUT</var></code> is <code>(map(*)|array(*))?</code>: that is, it must be either an empty sequence, a single map, or a single array [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. However, the coercion rules also allow a JNode whose <b>·content·</b> is a map or array to be supplied. If the value is an empty sequence, the result of the expression is an empty sequence.</span><span style="display: none;" class="add_version">The required type of the left-hand operand <code><var>INPUT</var></code> is <code>(map(*)|array(*))?</code>: that is, it must be either the empty sequence, a single map, or a single array [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. However, the coercion rules also allow a JNode whose <b>·content·</b> is a map or array to be supplied. If the value is the empty sequence, the result of the expression is the empty sequence.</span><span class="modify_version">The required type of the left-hand operand <code><var>INPUT</var></code> is <code>(map(*)|array(*))?</code>: that is, it must be either <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, a single map, or a single array [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]. However, the coercion rules also allow a JNode whose <b>·content·</b> is a map or array to be supplied. If the value is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, the result of the expression is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p><p>If the value of <code><var>INPUT</var></code> is an array, then the <code><var>FILTER</var></code> expression is evaluated for each member of the array, with that member as the context value, with its position in the array as the context position, and with the size of the array as the context size. The result of the expression is an array containing those members of the input array for which the <a title="predicate truth value" class="termref" href="#dt-predicate-truth-value">predicate truth value</a> of the <code><var>FILTER</var></code> expression is true. The order of retained members is preserved.</p><p>For example, the following expression:</p><div class="exampleInner"><pre xml:space="preserve">let $array := [ (), 1, (2, 3), (4, 5, 6) ]
return $array?[count(.) ge 2]</pre></div><p>returns:</p><div class="exampleInner"><pre xml:space="preserve">[ (2, 3), (4, 5, 6) ]</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Numeric predicates are handled in the same way as with filter expressions for sequences. However, the result is always an array, even if only one member is selected. For example, given the <code>$array</code> shown above, the result of <code>$array?[3]</code> is the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-single-member-array">single-member array</a><sup><small>DM</small></sup><code>[ (2, 3) ]</code>. Contrast this with <code>$array?3</code> which delivers the sequence <code>2, 3</code>.</p></div><p>If the value of <code><var>INPUT</var></code> is a map, then the <code><var>FILTER</var></code> expression is evaluated for each entry in the map, with the context value set to an item of type <code>record(key as xs:anyAtomicType, value as item()*)</code>, in which the <code>key</code> and <code>value</code> fields represent the key and value of the map entry. The context position is the position of the entry in the map (in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-entry-order">entry order</a><sup><small>DM</small></sup>), and the context size is the number of entries in the map. The result of the expression is a map containing those entries of the input map for which the <a title="predicate truth value" class="termref" href="#dt-predicate-truth-value">predicate truth value</a> of the <code><var>FILTER</var></code> expression is true. The relative order of entries in the result retains the relative order of entries in the input. </p><p>For example, the following expression:</p><div class="exampleInner"><pre xml:space="preserve">let $map := { 1: "alpha", 2: "beta", 3: "gamma" }
return $map?[?key ge 2]</pre></div><p>returns:</p><div class="exampleInner"><pre xml:space="preserve">{ 2: "beta", 3: "gamma" }</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>A filter expression such as <code>$map?[last()-1, last()]</code> might be used to return the last two entries of a map in <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-entry-order">entry order</a><sup><small>DM</small></sup>.</p></div></div></div><div class="_diffs div2"><h3><a id="id-otherwise"></a>4.16 <a href="#id-otherwise" style="text-decoration: none">Otherwise Expressions</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-quantified-expressions">next</a> | <a href="#id-conditionals">previous</a>)</p><ol><li><p><span style="display: none;" class="delete_version"> An <code>otherwise</code> operator is introduced: <code>A otherwise B</code> returns the value of <code>A</code>, unless it is an empty sequence, in which case it returns the value of <code>B</code>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1024">1024</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1031">1031</a>&nbsp;27 February 2024]</i></span><span style="display: none;" class="add_version"> An <code>otherwise</code> operator is introduced: <code>A otherwise B</code> returns the value of <code>A</code>, unless it is the empty sequence, in which case it returns the value of <code>B</code>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1024">1024</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1031">1031</a>&nbsp;27 February 2024]</i></span><span class="modify_version"> An <code>otherwise</code> operator is introduced: <code>A otherwise B</code> returns the value of <code>A</code>, unless it is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, in which case it returns the value of <code>B</code>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1024">1024</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1031">1031</a>&nbsp;27 February 2024]</i></span></p></li></ol></div><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-OtherwiseExpr"></a><code><a href="#prod-xpath40-OtherwiseExpr">OtherwiseExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-OtherwiseExpr-StringConcatExpr">StringConcatExpr</a> ("otherwise" <a href="#doc-xpath40-OtherwiseExpr-StringConcatExpr">StringConcatExpr</a>)*</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-OtherwiseExpr-StringConcatExpr"></a><code><a href="#prod-xpath40-StringConcatExpr">StringConcatExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-RangeExpr">RangeExpr</a> ("||" <a href="#doc-xpath40-RangeExpr">RangeExpr</a>)*</code></td></tr></tbody></table><p><span style="display: none;" class="delete_version">The <code>otherwise</code> expression returns the value of its first operand, unless this is an empty sequence, in which case it returns the value of its second operand.</span><span style="display: none;" class="add_version">The <code>otherwise</code> expression returns the value of its first operand, unless this is the empty sequence, in which case it returns the value of its second operand.</span><span class="modify_version">The <code>otherwise</code> expression returns the value of its first operand, unless this is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, in which case it returns the value of its second operand.</span></p><p>For example, <code>@price - (@discount otherwise 0)</code> returns the value of <code>@price - @discount</code>, if the attribute <code>@discount</code> exists, or the value of <code>@price</code> if the <code>@discount</code> attribute is absent.</p><p>To prevent spurious errors, the right hand operand is <a title="guarded" class="termref" href="#dt-guarded">guarded</a>: it cannot throw any dynamic error unless the left-hand operand returns <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The operator is associative (even under error conditions): <code>A otherwise (B otherwise C)</code> returns the same result as <code>(A otherwise B) otherwise C</code>.</p><p>The <code>otherwise</code> operator binds more tightly than comparison operators such as <code>=</code>, but less tightly than string concatenation (<code>||</code>) or arithemetic operators. The expression <code>$a = @x otherwise @y + 1</code> parses as <code>$a = (@x otherwise (@y + 1))</code>.</p></div></div><div class="_diffs div2"><h3><a id="id-quantified-expressions"></a>4.17 <a href="#id-quantified-expressions" style="text-decoration: none">Quantified Expressions</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-treat">next</a> | <a href="#id-otherwise">previous</a>)</p><ol><li><p> If a type declaration is present, the supplied values in the input sequence are now coerced to the required type. Type declarations are now permitted in XPath as well as XQuery. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1316">1316</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1384">1384</a>&nbsp;13 August 2024]</i></p></li></ol></div><p>Quantified expressions support existential and universal quantification. The value of a quantified expression is always <code>true</code> or <code>false</code>.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-QuantifiedExpr"></a><code><a href="#prod-xpath40-QuantifiedExpr">QuantifiedExpr</a></code></td><td>::=</td><td><code>("some" | "every") (<a href="#doc-xpath40-QuantifiedExpr-QuantifierBinding">QuantifierBinding</a> ++ ",") "satisfies" <a href="#doc-xpath40-QuantifiedExpr-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-QuantifiedExpr-QuantifierBinding"></a><code><a href="#prod-xpath40-QuantifierBinding">QuantifierBinding</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-QuantifiedExpr-VarNameAndType">VarNameAndType</a> "in" <a href="#doc-xpath40-QuantifiedExpr-ExprSingle">ExprSingle</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-QuantifiedExpr-VarNameAndType"></a><code><a href="#prod-xpath40-VarNameAndType">VarNameAndType</a></code></td><td>::=</td><td><code>"$" <a href="#doc-xpath40-QuantifiedExpr-EQName">EQName</a><a href="#doc-xpath40-QuantifiedExpr-TypeDeclaration">TypeDeclaration</a>?</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-QuantifiedExpr-EQName"></a><code><a href="#prod-xpath40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-QName">QName</a> | <a href="#prod-xpath40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-QuantifiedExpr-TypeDeclaration"></a><code><a href="#prod-xpath40-TypeDeclaration">TypeDeclaration</a></code></td><td>::=</td><td><code>"as" <a href="#doc-xpath40-QuantifiedExpr-SequenceType">SequenceType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-QuantifiedExpr-SequenceType"></a><code><a href="#prod-xpath40-SequenceType">SequenceType</a></code></td><td>::=</td><td><code>("empty-sequence" "(" ")")<br>| (<a href="#doc-xpath40-ItemType">ItemType</a><a href="#prod-xpath40-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-QuantifiedExpr-ExprSingle"></a><code><a href="#prod-xpath40-ExprSingle">ExprSingle</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-ForExpr">ForExpr</a><br>| <a href="#doc-xpath40-LetExpr">LetExpr</a><br>| <a href="#doc-xpath40-QuantifiedExpr">QuantifiedExpr</a><br>| <a href="#doc-xpath40-IfExpr">IfExpr</a><br>| <a href="#doc-xpath40-OrExpr">OrExpr</a></code></td></tr></tbody></table><p>A <b>quantified expression</b> begins with a <b>quantifier</b>, which is the keyword <code>some</code> or <code>every</code>, followed by one or more in-clauses that are used to bind variables, followed by the keyword <code>satisfies</code> and a test expression. Each in-clause associates a variable with an expression that returns a sequence of items, called the binding sequence for that variable. The value of the quantified expression is defined by the following rules:</p><ol class="enumar"><li><p>If the <a href="#doc-xpath40-QuantifiedExpr">QuantifiedExpr</a> contains more than one <a href="#prod-xpath40-QuantifierBinding">QuantifierBinding</a>, then it is equivalent to the expression obtained by replacing each comma with <code>satisfies some</code> or <code>satisfies every</code> respectively. For example, the expression <code>some $x in X, $y in Y satisfies $x = $y</code> is equivalent to <code>some $x in X satisfies some $y in Y satisfies $x = $y</code>, while the expression <code>every $x in X, $y in Y satisfies $x lt $y</code> is equivalent to <code>every $x in X satisfies every $y in Y satisfies $x lt $y</code></p></li><li><p>If the quantifier is <code>some</code>, the <a href="#doc-xpath40-QuantifiedExpr">QuantifiedExpr</a> returns <code>true</code> if at least one evaluation of the test expression has the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a><code>true</code>; otherwise it returns <code>false</code>. In consequence, if the binding sequence is empty, the result of the <a href="#doc-xpath40-QuantifiedExpr">QuantifiedExpr</a> is <code>false</code>.</p></li><li><p>If the quantifier is <code>every</code>, the <a href="#doc-xpath40-QuantifiedExpr">QuantifiedExpr</a> returns <code>true</code> if every evaluation of the test expression has the <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a><code>true</code>; otherwise it returns <code>false</code>. In consequence, if the binding sequence is empty, the result of the <a href="#doc-xpath40-QuantifiedExpr">QuantifiedExpr</a> is <code>true</code>.</p></li></ol><p>The scope of a variable bound in a quantified expression comprises all subexpressions of the quantified expression that appear after the variable binding. The scope does not include the expression to which the variable is bound. </p><p>Each variable binding may be accompanied by a <b>type declaration</b>, which consists of the keyword <code>as</code> followed by the static type of the variable, declared using the syntax in <a href="#id-sequencetype-syntax"><b>3.1 Sequence Types</b></a>. The type declaration defines a required type for the value. At run-time, the supplied value for the variable is converted to the required type by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. If conversion is not possible, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p><p>The order in which test expressions are evaluated for the various items in the binding sequence is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. If the quantifier is <code>some</code>, an implementation may return <code>true</code> as soon as it finds one item for which the test expression has an <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of <code>true</code>, and it may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> as soon as it finds one item for which the test expression raises an error. Similarly, if the quantifier is <code>every</code>, an implementation may return <code>false</code> as soon as it finds one item for which the test expression has an <a title="effective boolean value" class="termref" href="#dt-ebv">effective boolean value</a> of <code>false</code>, and it may raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> as soon as it finds one item for which the test expression raises an error. As a result of these rules, the value of a quantified expression is not deterministic in the presence of errors, as illustrated in the examples below.</p><p>Here are some examples of quantified expressions:</p><ul><li><p>This expression is <code>true</code> if every <code>part</code> element has a <code>discounted</code> attribute (regardless of the values of these attributes):</p><div class="exampleInner"><pre xml:space="preserve">every $part in /parts/part satisfies $part/@discounted</pre></div></li><li><p>This expression is <code>true</code> if at least one <code>employee</code> element satisfies the given comparison expression:</p><div class="exampleInner"><pre xml:space="preserve">some $emp in /emps/employee satisfies $emp/bonus &gt; 0.25 * $emp/salary</pre></div></li><li><p>This expression is <code>true</code> if every <code>employee</code> element has at least one <code>salary</code> child with the attribute <code>current="true"</code>:</p><div class="exampleInner"><pre xml:space="preserve">every $emp in /emps/employee satisfies (
  some $sal in $emp/salary satisfies $sal/@current = 'true'
)</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Like many quantified expressions, this can be simplified. This example can be written <code>every $emp in /emps/employee satisfies $emp/salary[@current = 'true']</code>, or even more concisely as <code>empty(/emps/employee[not(salary/@current = 'true')]</code>.</p><p>Another alternative in XPath 4.0 is to use the higher-order functions <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-some"><code>fn:some</code></a> and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-every"><code>fn:every</code></a>. This example can be written <code>every(/emps/employee, fn { salary/@current = 'true' })</code></p></div></li><li><p>In the following examples, each quantified expression evaluates its test expression over nine pairs of items, formed from the Cartesian product of the sequences <code>(1, 2, 3)</code> and <code>(2, 3, 4)</code>. The expression beginning with <code>some</code> evaluates to <code>true</code>, and the expression beginning with <code>every</code> evaluates to <code>false</code>.</p><div class="exampleInner"><pre xml:space="preserve">some $x in (1, 2, 3), $y in (2, 3, 4) satisfies $x + $y = 4</pre></div><div class="exampleInner"><pre xml:space="preserve">every $x in (1, 2, 3), $y in (2, 3, 4) satisfies $x + $y = 4</pre></div></li><li><p>This quantified expression may either return <code>true</code> or raise a <a title="type error" class="termref" href="#dt-type-error">type error</a>, since its test expression returns <code>true</code> for one item and raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> for another:</p><div class="exampleInner"><pre xml:space="preserve">some $x in (1, 2, "cat") satisfies $x * 2 = 4</pre></div></li><li><p>This quantified expression may either return <code>false</code> or raise a <a title="type error" class="termref" href="#dt-type-error">type error</a>, since its test expression returns <code>false</code> for one item and raises a <a title="type error" class="termref" href="#dt-type-error">type error</a> for another:</p><div class="exampleInner"><pre xml:space="preserve">every $x in (1, 2, "cat") satisfies $x * 2 = 4</pre></div></li><li><p>This quantified expression returns <code>true</code>, because the binding sequence is empty, despite the fact that the condition can never be satisfied:</p><div class="exampleInner"><pre xml:space="preserve">every $x in () satisfies ($x lt 0 and $x gt 0)</pre></div></li><li><p><span style="display: none;" class="delete_version">This quantified expression is <a title="implausible" class="termref" href="#dt-implausible">implausible</a> because it will always fail with a type error except in the case where <code>$input</code> is an empty sequence. If <code>$input</code> contains one or more <code>xs:date</code> values, a processor <span class="verb">must</span> raise a type error on the grounds that an <code>xs:date</code> cannot be compared to an <code>xs:integer</code>. If <code>$input</code> is empty, the processor <span class="verb">may</span> (or may not) report this error:</span><span style="display: none;" class="add_version">This quantified expression is <a title="implausible" class="termref" href="#dt-implausible">implausible</a> because it will always fail with a type error except in the case where <code>$input</code> is the empty sequence. If <code>$input</code> contains one or more <code>xs:date</code> values, a processor <span class="verb">must</span> raise a type error on the grounds that an <code>xs:date</code> cannot be compared to an <code>xs:integer</code>. If <code>$input</code> is empty, the processor <span class="verb">may</span> (or may not) report this error:</span><span class="modify_version">This quantified expression is <a title="implausible" class="termref" href="#dt-implausible">implausible</a> because it will always fail with a type error except in the case where <code>$input</code> is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. If <code>$input</code> contains one or more <code>xs:date</code> values, a processor <span class="verb">must</span> raise a type error on the grounds that an <code>xs:date</code> cannot be compared to an <code>xs:integer</code>. If <code>$input</code> is empty, the processor <span class="verb">may</span> (or may not) report this error:</span></p><div class="exampleInner"><pre xml:space="preserve">every $x as xs:date in $input satisfies ($x lt 0)</pre></div></li><li><p>This quantified expression contains a <a href="#prod-xpath40-TypeDeclaration">type declaration</a> that is not satisfied by every item in the test expression. The expression may either return <code>true</code> or raise a <a title="type error" class="termref" href="#dt-type-error">type error</a>.</p><div class="exampleInner"><pre xml:space="preserve">some $x as xs:integer in (1, 2, "cat") satisfies $x * 2 = 4</pre></div></li></ul></div><div class="_diffs div2"><h3><a id="id-expressions-on-datatypes"></a>4.18 <a href="#id-expressions-on-datatypes" style="text-decoration: none">Expressions on SequenceTypes</a></h3><p> The <code>instance of</code>, <code>cast</code>, <code>castable</code>, and <code>treat</code> expressions are used to test whether a value conforms to a given type or to convert it to an instance of a given type. </p><div class="_diffs div3"><h4><a id="id-cast"></a>4.18.2 <a href="#id-cast" style="text-decoration: none">Cast</a></h4><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-CastExpr"></a><code><a href="#prod-xpath40-CastExpr">CastExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-CastExpr-PipelineExpr">PipelineExpr</a> ("cast" "as" <a href="#doc-xpath40-CastExpr-CastTarget">CastTarget</a> "?"?)?</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-CastExpr-PipelineExpr"></a><code><a href="#prod-xpath40-PipelineExpr">PipelineExpr</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-ArrowExpr">ArrowExpr</a> ("-&gt;" <a href="#doc-xpath40-ArrowExpr">ArrowExpr</a>)*</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-CastExpr-CastTarget"></a><code><a href="#prod-xpath40-CastTarget">CastTarget</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-CastExpr-TypeName">TypeName</a> | <a href="#doc-xpath40-CastExpr-ChoiceItemType">ChoiceItemType</a> | <a href="#doc-xpath40-CastExpr-EnumerationType">EnumerationType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-CastExpr-TypeName"></a><code><a href="#prod-xpath40-TypeName">TypeName</a></code></td><td>::=</td><td><code><a href="#doc-xpath40-CastExpr-EQName">EQName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-CastExpr-EQName"></a><code><a href="#prod-xpath40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-QName">QName</a> | <a href="#prod-xpath40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-CastExpr-ChoiceItemType"></a><code><a href="#prod-xpath40-ChoiceItemType">ChoiceItemType</a></code></td><td>::=</td><td><code>"(" (<a href="#doc-xpath40-CastExpr-ItemType">ItemType</a> ++ "|") ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-CastExpr-ItemType"></a><code><a href="#prod-xpath40-ItemType">ItemType</a></code></td><td>::=</td><td><code><a href="#prod-xpath40-RegularItemType">RegularItemType</a> | <a href="#doc-xpath40-FunctionType">FunctionType</a> | <a href="#doc-xpath40-CastExpr-TypeName">TypeName</a> | <a href="#doc-xpath40-CastExpr-ChoiceItemType">ChoiceItemType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xpath40-CastExpr-EnumerationType"></a><code><a href="#prod-xpath40-EnumerationType">EnumerationType</a></code></td><td>::=</td><td><code>"enum" "(" (<a href="#doc-xpath40-StringLiteral">StringLiteral</a> ++ ",") ")"</code></td></tr></tbody></table><p>Sometimes it is necessary to convert a value to a specific datatype. For this purpose, XPath 4.0 provides a <code>cast</code> expression that creates a new value of a specific type based on an existing value. A <code>cast</code> expression takes two operands: an <b>input expression</b> and a <b>target type</b>. The type of the atomized value of the input expression is called the <b>input type</b>. The target type must be a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a>. In practice this means it may be any of:</p><ul><li><p>The name of an <a title="named item type" class="termref" href="#dt-named-item-type">named item type</a> defined in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, which in turn must refer to an item type in one of the following categories.</p></li><li><p>The name of a type defined in the <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a>, which must be a simple type (of variety atomic, list or union) [<a href="#ERRXQST0052" title="err:XQST0052">err:XQST0052</a>] . In addition, the target type cannot be <code>xs:NOTATION</code>, <code>xs:anySimpleType</code>, or <code>xs:anyAtomicType</code></p></li><li><p>A <code>ChoiceItemType</code> representing a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a> (such as <code>(xs:date | xs:dateTime)</code>).</p></li><li><p>An <code>EnumerationType</code> such as <code>enum("red", "green", "blue")</code>.</p></li></ul><p>Otherwise, a static error is raised [<a href="#ERRXPST0080" title="err:XPST0080">err:XPST0080</a>].</p><p><span style="display: none;" class="delete_version">The optional occurrence indicator <code>?</code> denotes that an empty sequence is permitted.</span><span style="display: none;" class="add_version">The optional occurrence indicator <code>?</code> denotes that the empty sequence is permitted.</span><span class="modify_version">The optional occurrence indicator <code>?</code> denotes that <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence is permitted.</span></p><p>Casting a node to <code>xs:QName</code> can cause surprises because it uses the <a title="static context" class="termref" href="#dt-static-context">static context</a> of the cast expression to provide the <a title="namespace binding" class="termref" href="#dt-namespace-binding">namespace bindings</a> for this operation. Instead of casting to <code>xs:QName</code>, it is generally preferable to use the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-QName"><code>fn:QName</code></a> function, which allows the namespace context to be taken from the document containing the QName.</p><p>The semantics of the <code>cast</code> expression are as follows:</p><ol class="enumar"><li><p>The input expression is evaluated.</p></li><li><p>The result of the first step is <a title="atomization" class="termref" href="#dt-atomization">atomized</a>.</p></li><li><p> If the result of atomization is a sequence of more than one atomic item, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>If the result of atomization is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence:</p><ol class="enumla"><li><p><span style="display: none;" class="delete_version">If <code>?</code> is specified after the target type, the result of the <code>cast</code> expression is an empty sequence.</span><span style="display: none;" class="add_version">If <code>?</code> is specified after the target type, the result of the <code>cast</code> expression is the empty sequence.</span><span class="modify_version">If <code>?</code> is specified after the target type, the result of the <code>cast</code> expression is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence.</span></p></li><li><p> If <code>?</code> is not specified after the target type, a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li></ol></li><li><p>If the result of atomization is a single atomic item, the result of the cast expression is determined by casting to the target type as described in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#casting">23 Casting</a>. When casting, an implementation may need to determine whether one type is derived by restriction from another. An implementation can determine this either by examining the <a title="in-scope schema definitions" class="termref" href="#dt-issd">in-scope schema definitions</a> or by using an alternative, <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> mechanism such as a data dictionary. The result of a cast expression is one of the following: </p><ol class="enumla"><li><p> A value of the target type (or, in the case of list types, a sequence of values that are instances of the item type of the list type). </p></li><li><p> A type error, if casting from the source type to the target type is not supported (for example attempting to convert an integer to a date). </p></li><li><p> A dynamic error, if the particular input value cannot be converted to the target type (for example, attempting to convert the string <code>"three"</code> to an integer). </p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Casting to an enumeration type relies on the fact that an enumeration type is a generalized atomic type. So the expression <code>cast $x as enum("red", "green")</code> has the following effect:</p><ul><li><p>If <code>$x</code> is an instance of <code>xs:string</code>, the expression returns <code>$x</code> unchanged if it is one of the permitted strings, and raises a dynamic error otherwise;</p></li><li><p>In other cases, the expression first casts <code>$x</code> to <code>xs:string</code>, and then proceeds as above.</p></li></ul></div></li></ol></div></div></div></div><div class="back"><div class="_diffs div1"><h2><a id="id-glossary"></a>F <a href="#id-glossary" style="text-decoration: none">Glossary</a> (Non-Normative)</h2><dl><dt><a href="#dt-absolute-path-expression">absolute path expression</a></dt><dd><p> An <b>absolute path expression</b> is an instance of the production <a href="#prod-xpath40-AbsolutePathExpr">AbsolutePathExpr</a>: it consists of either (a) the operator <code>/</code> followed by zero or more operands separated by <code>/</code> or <code>//</code> operators, or (b) the operator <code>//</code> followed by one or more operands separated by <code>/</code> or <code>//</code> operators.</p></dd><dt><a href="#dt-and-expression">and expression</a></dt><dd><p>An <b>and expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production <a href="#prod-xpath40-AndExpr">AndExpr</a>.</p></dd><dt><a href="#dt-anonymous-function">anonymous function</a></dt><dd><p> An <b>anonymous function</b> is a <a title="function item" class="termref" href="#dt-function-item">function item</a> with no name. Anonymous functions may be created, for example, by evaluating an inline function expression or by partial function application.</p></dd><dt><a href="#dt-application-function">application function</a></dt><dd><p><b>Application functions</b> are function definitions written in a host language such as XQuery or XSLT whose syntax and semantics are defined in this family of specifications. Their behavior (including the rules determining the static and dynamic context) follows the rules for such functions in the relevant host language specification.</p></dd><dt><a href="#dt-arg-expr">argument expression</a></dt><dd><p>An argument to a function call is either an <b>argument expression</b> or an <a href="#prod-xpath40-ArgumentPlaceholder">ArgumentPlaceholder</a> (<code>?</code>); in both cases it may either be supplied positionally, or identified by a name (called a keyword).</p></dd><dt><a href="#dt-arity-range">arity range</a></dt><dd><p>A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> has an <b>arity range</b>, which is a range of consecutive non-negative integers. If the function definition has <var>M</var> required parameters and <var>N</var> optional parameters, then its arity range is from <var>M</var> to <var>M</var>+<var>N</var> inclusive.</p></dd><dt><a href="#dt-array">array</a></dt><dd><p>An <b>array</b> is a <a title="function item" class="termref" href="#dt-function-item">function item</a> that associates a set of positions, represented as positive integer keys, with values.</p></dd><dt><a href="#dt-associated-value">associated value</a></dt><dd><p>The value associated with a given key is called the <b>associated value</b> of the key.</p></dd><dt><a href="#dt-atomic-item">atomic item</a></dt><dd><p>An <b>atomic item</b> is a value in the value space of an <b>atomic type</b>, as defined in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.</p></dd><dt><a href="#dt-atomic-type">atomic type</a></dt><dd><p>An <b>atomic type</b> is a simple <a title="schema type" class="termref" href="#dt-schema-type">schema type</a> whose <a href="https://www.w3.org/TR/xmlschema11-1/#std-variety">{variety}<sup><small>XS11-1</small></sup></a> is <code>atomic</code>.</p></dd><dt><a href="#dt-atomization">atomization</a></dt><dd><p><b>Atomization</b> of a sequence is defined as the result of invoking the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-data"><code>fn:data</code></a> function, as defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#func-data">12.1.6 fn:data</a>.</p></dd><dt><a href="#dt-available-docs">available documents</a></dt><dd><p>The term <b>available documents</b> refers (TODO: for the time being) to the set of XML documents that an application is able to access by URI.</p></dd><dt><a href="#dt-axis-step">axis step</a></dt><dd><p>An <b>axis step</b> is an instance of the production <a href="#doc-xpath40-AxisStep">AxisStep</a>: it is an expression that returns a sequence of GNodes that are reachable from a starting GNode via a specified axis. An axis step has three parts: an <b>axis</b>, which defines the direction of movement for the step, a <a title="node test" class="termref" href="#dt-node-test">node test</a>, which selects GNodes based on their properties, and zero or more predicates which are used to filter the results.</p></dd><dt><a href="#dt-binding-collection-xp">binding collection</a></dt><dd><p>The result of evaluating the <b>binding expression</b> in a <code>for</code> expression is called the <b>binding collection</b></p></dd><dt><a href="#dt-choice-item-type">choice item type</a></dt><dd><p>A <b>choice item type</b> defines an item type that is the union of a number of alternatives. For example the type <code>(xs:hexBinary | xs:base64Binary)</code> defines the union of these two primitive <a title="atomic type" class="termref" href="#dt-atomic-type">atomic types</a>, while the type <code>(map(*) | array(*))</code> matches any item that is either a map or an array.</p></dd><dt><a href="#dt-coercion-rules">coercion rules</a></dt><dd><p>The <b>coercion rules</b> are rules used to convert a supplied value to a required type, for example when converting an argument of a function call to the declared type of the function parameter. </p></dd><dt><a href="#dt-collation">collation</a></dt><dd><p>A <b>collation</b> is a specification of the manner in which strings and URIs are compared and, by extension, ordered. For a more complete definition of collation, see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#string-compare">5.3 Comparison of strings</a>.</p></dd><dt><a href="#dt-comma-operator">comma operator</a></dt><dd><p>A <b>comma operator</b> is a comma used specifically as the operator in a <a title="sequence expression" class="termref" href="#dt-sequence-expression">sequence expression</a>.</p></dd><dt><a href="#dt-complex-terminal">complex terminal</a></dt><dd><p>A <b>complex terminal</b> is a <a title="variable terminal" class="termref" href="#dt-variable-terminal">variable terminal</a> whose production rule references, directly or indirectly, an <a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule">ordinary production rule</a>.</p></dd><dt><a href="#dt-constructor-function">constructor function</a></dt><dd><p>The <b>constructor function</b> for a given simple type is used to convert instances of other simple types into the given type. The semantics of the constructor function call <code>T($arg)</code> are defined to be equivalent to the expression <code>$arg cast as T?</code>.</p></dd><dt><a href="#dt-content-expression">content expression</a></dt><dd><p>In an <a title="enclosed expression" class="termref" href="#dt-enclosed-expression">enclosed expression</a>, the optional expression enclosed in curly brackets is called the <b>content expression</b>.</p></dd><dt><a href="#dt-context-dependent">context dependent</a></dt><dd><p>A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> is said to be <b>context dependent</b> if its result depends on the static or dynamic context of its caller. A function definition may be context-dependent for some arities in its arity range, and context-independent for others: for example <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-name"><code>fn:name#0</code></a> is context-dependent while <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-name"><code>fn:name#1</code></a> is context-independent.</p></dd><dt><a href="#dt-context-node">context node</a></dt><dd><p>When the context value is a single item, it can also be referred to as the <b>context item</b>; when it is a single node, it can also be referred to as the <b>context node</b>.</p></dd><dt><a href="#dt-context-position">context position</a></dt><dd><p>The <b>context position</b> is the position of the context value within the series of values currently being processed.</p></dd><dt><a href="#dt-context-size">context size</a></dt><dd><p>The <b>context size</b> is the number of values in the series of values currently being processed.</p></dd><dt><a href="#dt-context-value">context value</a></dt><dd><p>The <b>context value</b> is the <a title="value" class="termref" href="#dt-value">value</a> currently being processed.</p></dd><dt><a href="#dt-date-time">current dateTime</a></dt><dd><p><b>Current dateTime.</b> This information represents an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> point in time during the processing of <span class="xpath">an expression</span>, and includes an explicit timezone. It can be retrieved by the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-current-dateTime"><code>fn:current-dateTime</code></a> function. If called multiple times during the execution of <span class="xpath">an expression</span>, this function always returns the same result.</p></dd><dt><a href="#dt-datamodel">data model</a></dt><dd><p>XPath 4.0 operates on the abstract, logical structure of an XML document or JSON object rather than its surface syntax. This logical structure, known as the <b>data model</b>, is defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>.</p></dd><dt><a href="#id-static-decimal-format-decimal-separator">decimal-separator</a></dt><dd><p><b>decimal-separator</b><em>(<var>M</var>, <var>R</var>)</em> is used to separate the integer part of the number from the fractional part. The default value for both the marker and the rendition is <span class="unicode-codepoint">U+002E</span> (<span class="unicode-name">FULL STOP, PERIOD</span>, <code>.</code>) .</p></dd><dt><a href="#dt-default-calendar">default calendar</a></dt><dd><p><b>Default calendar.</b> This is the calendar used when formatting dates in human-readable output (for example, by the functions <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-date"><code>fn:format-date</code></a> and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-dateTime"><code>fn:format-dateTime</code></a>) if no other calendar is requested. The value is a string.</p></dd><dt><a href="#dt-def-collation">default collation</a></dt><dd><p><b>Default collation.</b> This identifies one of the collations in <a title="statically known collations" class="termref" href="#dt-static-collations">statically known collations</a> as the collation to be used by functions and operators for comparing and ordering values of type <code>xs:string</code> and <code>xs:anyURI</code> (and types derived from them) when no explicit collation is specified.</p></dd><dt><a href="#dt-default-collection">default collection</a></dt><dd><p><b>Default collection.</b> This is the sequence of items that would result from calling the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>fn:collection</code></a> function with no arguments.</p></dd><dt><a href="#dt-default-element-namespace-rule">default element namespace rule</a></dt><dd><p>When an unprefixed lexical QName is expanded using the <b>default element namespace rule</b>, then it uses the <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a>. If this is absent, or if it takes the special value <code>##any</code>, then the <a title="no-namespace rule" class="termref" href="#dt-no-namespace-rule">no-namespace rule</a> is used.</p></dd><dt><a href="#dt-default-function-namespace">default function namespace</a></dt><dd><p><b>Default function namespace.</b> This determines how unprefixed lexical QNames appearing in a <a title="static function call" class="termref" href="#dt-static-function-call">static function call</a> or a <a title="named function reference" class="termref" href="#dt-named-function-ref">named function reference</a> are interpreted.</p></dd><dt><a href="#dt-default-function-namespace-rule">default function namespace rule</a></dt><dd><p>When an unprefixed lexical QName is expanded using the <b>default function namespace rule</b>, the processor searches for a matching function definition as follows: first, if the static context includes a no-namespace function definition with the required local name and arity, then that function definition is used; otherwise, the name is expanded using the <a title="default function namespace" class="termref" href="#dt-default-function-namespace">default function namespace</a> from the <a title="static context" class="termref" href="#dt-static-context">static context</a>.</p></dd><dt><a href="#dt-default-in-scope-namespace">default in-scope namespace</a></dt><dd><p>The <b>default in-scope namespace</b> of an element node</p></dd><dt><a href="#dt-default-language">default language</a></dt><dd><p><b>Default language.</b> This is the natural language used when creating human-readable output (for example, by the functions <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-date"><code>fn:format-date</code></a> and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-integer"><code>fn:format-integer</code></a>) if no other language is requested. The value is a language code as defined by the type <code>xs:language</code>.</p></dd><dt><a href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a></dt><dd><p><b>Default namespace for elements and types.</b> This is either a namespace URI, or the special value <code>"##any"</code>, or <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM</small></sup>. This indicates how unprefixed QNames are interpreted when they appear in a position where an element name or type name is expected.</p></dd><dt><a href="#dt-default-place">default place</a></dt><dd><p><b>Default place.</b> This is a geographical location used to identify the place where events happened (or will happen) when processing dates and times using functions such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-date"><code>fn:format-date</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-dateTime"><code>fn:format-dateTime</code></a>, and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-civil-timezone"><code>fn:civil-timezone</code></a>, if no other place is specified. It is used when translating timezone offsets to civil timezone names, and when using calendars where the translation from ISO dates/times to a local representation is dependent on geographical location. Possible representations of this information are an ISO country code or an Olson timezone name, but implementations are free to use other representations from which the above information can be derived. The only requirement is that it should uniquely identify a civil timezone, which means that country codes for countries with multiple timezones, such as the United States, are inadequate.</p></dd><dt><a href="#dt-default-type-namespace-rule">default type namespace rule</a></dt><dd><p>When an unprefixed lexical QName is expanded using the <b>default type namespace rule</b>, it uses the <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a>. If this is absent, the <a title="no-namespace rule" class="termref" href="#dt-no-namespace-rule">no-namespace rule</a> is used. If the <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a> has the special value <code>##any</code>, then the lexical QName refers to a name in the namespace <code>http://www.w3.org/2001/XMLSchema</code>.</p></dd><dt><a href="#dt-default-uri-collection">default URI collection</a></dt><dd><p><b>Default URI collection.</b> This is the sequence of URIs that would result from calling the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-uri-collection"><code>fn:uri-collection</code></a> function with no arguments.</p></dd><dt><a href="#delimiting-token">delimiting terminal symbol</a></dt><dd><p>The <b>delimiting terminal symbols</b> are: <code>!</code><code>!=</code><code>#</code><code>$</code><code>(</code><code>)</code><code>*</code><code>*:</code><code>+</code><code>,</code><code>-</code><code>-&gt;</code><code>.</code><code>..</code><code>/</code><code>//</code><code>:</code><code>:*</code><code>::</code><code>:=</code><code>;</code><code>&lt;</code><code>&lt;&lt;</code><code>&lt;=</code><code>=</code><code>=!&gt;</code><code>=&gt;</code><code>=?&gt;</code><code>&gt;</code><code>&gt;=</code><code>&gt;&gt;</code><code>?</code><code>?[</code><code>@</code><code>[</code><code>]</code><code>`</code><code>``</code><code>{</code><code>{{</code><code>|</code><code>||</code><code>}</code><code>}}</code><code>×</code><code>÷</code><a href="#prod-xpath40-AposStringLiteral">AposStringLiteral</a><a href="#prod-xpath40-BracedURILiteral">BracedURILiteral</a><a href="#prod-xpath40-QuotStringLiteral">QuotStringLiteral</a><a href="#prod-xpath40-StringLiteral">StringLiteral</a><a href="#prod-xpath40-URIQualifiedName">URIQualifiedName</a></p></dd><dt><a href="#dt-derives-from">derives from</a></dt><dd><p>A <a title="schema type" class="termref" href="#dt-schema-type">schema type</a><var>S<sub>1</sub></var> is said to <b>derive from</b><a title="schema type" class="termref" href="#dt-schema-type">schema type</a><var>S<sub>2</sub></var> if any of the following conditions is true:</p><ul><li><p><var>S<sub>1</sub></var> is the same type as <var>S<sub>2</sub></var>.</p></li><li><p><var>S<sub>2</sub></var> is the base type of <var>S<sub>1</sub></var>.</p></li><li><p><var>S<sub>2</sub></var> is a <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a> of which <var>S<sub>1</sub></var> is a member type.</p></li><li><p>There is a <a title="schema type" class="termref" href="#dt-schema-type">schema type</a><var>M</var> such that <var>S<sub>1</sub></var><a title="derives from" class="termref" href="#dt-derives-from">derives from</a><var>M</var> and <var>M</var><a title="derives from" class="termref" href="#dt-derives-from">derives from</a><var>S<sub>2</sub></var>.</p></li></ul></dd><dt><a href="#id-static-decimal-format-digit">digit</a></dt><dd><p><b>digit</b><em>(<var>M</var>)</em> is a character used in the picture string to represent an optional digit; the default value is <span class="unicode-codepoint">U+0023</span> (<span class="unicode-name">NUMBER SIGN</span>, <code>#</code>) .</p></dd><dt><a href="#dt-document-order">document order</a></dt><dd><p>Informally, <b>document order</b> is the order in which nodes appear in the XML serialization of a document.</p></dd><dt><a href="#dt-dynamically-known-function-definitions">dynamically known function definitions</a></dt><dd><p><b>Dynamically known function definitions</b>. This is a set of <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a>. It includes the <a title="statically known function definitions" class="termref" href="#dt-statically-known-function-definitions">statically known function definitions</a> as a subset, but may include other function definitions that are not known statically. </p></dd><dt><a href="#dt-dynamic-context">dynamic context</a></dt><dd><p>The <b>dynamic context</b> of an expression is defined as information that is needed for the dynamic evaluation of an expression, beyond any information that is needed from the <a title="static context" class="termref" href="#dt-static-context">static context</a>.</p></dd><dt><a href="#dt-dynamic-error">dynamic error</a></dt><dd><p>A <b>dynamic error</b> is an error that must be detected during the dynamic evaluation phase and may be detected during the static analysis phase.</p></dd><dt><a href="#dt-dynamic-evaluation">dynamic evaluation phase</a></dt><dd><p>The <b>dynamic evaluation phase</b> is the phase during which the value of an expression is computed.</p></dd><dt><a href="#dt-dynamic-function-call">dynamic function call</a></dt><dd><p>A <b>dynamic function call</b> is an instance of the construct <a href="#doc-xpath40-DynamicFunctionCall">DynamicFunctionCall</a>: that is, it is an expression in the form <code><var>E<sub>1</sub></var>(<var>E<sub>2</sub></var>, <var>E<sub>3</sub></var>, ...)</code> in which <var>E<sub>1</sub></var> identifies a <a title="function item" class="termref" href="#dt-function-item">function item</a> to be called, and the parenthesized argument list <code>(<var>E<sub>2</sub></var>, <var>E<sub>3</sub></var>, ...)</code>) identifies the arguments supplied to the function.</p></dd><dt><a href="#dt-dynamic-type">dynamic type</a></dt><dd><p> Every value matches one or more <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a>. A value is said to have a <b>dynamic type</b><var>T</var> if it matches (or <b>is an instance of</b>) the sequence type <var>T</var>.</p></dd><dt><a href="#dt-ebv">effective boolean value</a></dt><dd><p>The <b>effective boolean value</b> of a value is defined as the result of applying the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-boolean"><code>fn:boolean</code></a> function to the value.</p></dd><dt><a href="#dt-element-name-matching-rule">element name matching rule</a></dt><dd><p>When an unprefixed lexical QName is expanded using the <b>element name matching rule</b> rule, then it uses the <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a>. If this is absent, then it uses the <a title="no-namespace rule" class="termref" href="#dt-no-namespace-rule">no-namespace rule</a>. But if it takes the special value <code>##any</code>, then the name is taken as matching any <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> with the corresponding local part, regardless of namespace: that is, the unprefixed name <code>local</code> is interpreted as <code>*:local</code>.</p></dd><dt><a href="#dt-empty-sequence">empty sequence</a></dt><dd><p><span style="display: none;" class="delete_version">A sequence containing zero items is called an <b>empty sequence</b>.</span><span style="display: none;" class="add_version">The sequence containing zero items is called the <b>empty sequence</b>.</span><span class="modify_version"><span class="deltaxml-old" style="background:#FF5555">A</span><span class="deltaxml-new" style="background:#90EE90">The</span> sequence containing zero items is called <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> <b>empty sequence</b>.</span></p></dd><dt><a href="#dt-enclosed-expression">enclosed expression</a></dt><dd><p>An <b>enclosed expression</b> is an instance of the <a href="#doc-xpath40-EnclosedExpr">EnclosedExpr</a> production, which allows an optional expression within curly brackets.</p></dd><dt><a href="#dt-entry">entry</a></dt><dd><p>Each key / value pair in a map is called an <b>entry</b>.</p></dd><dt><a href="#dt-enumeration-type">enumeration type</a></dt><dd><p>An <b>EnumerationType</b> accepts a fixed set of string values.</p></dd><dt><a href="#dt-environment-variables">environment variables</a></dt><dd><p><b>Environment variables.</b> This is a mapping from names to values. Both the names and the values are strings. The names are compared using an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> collation, and are unique under this collation. The set of environment variables is <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> and <span class="verb">may</span> be empty.</p></dd><dt><a href="#dt-error-value">error value</a></dt><dd><p>In addition to its identifying QName, a dynamic error may also carry a descriptive string and one or more additional values called <b>error values</b>.</p></dd><dt><a href="#dt-executable-base-uri">Executable Base URI</a></dt><dd><p><b>Executable Base URI.</b> This is an absolute URI used to resolve relative URIs during the evaluation of expressions; it is used, for example, to resolve a relative URI supplied to the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>fn:doc</code></a> or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-unparsed-text"><code>fn:unparsed-text</code></a> functions. </p></dd><dt><a href="#dt-expanded-qname">expanded QName</a></dt><dd><p>An <b>expanded QName</b> is a triple: its components are a prefix, a local name, and a namespace URI. In the case of a name in no namespace, the namespace URI and prefix are both absent. In the case of a name in the default namespace, the prefix is absent.</p></dd><dt><a href="#id-static-decimal-format-exponent-separator">exponent-separator</a></dt><dd><p><b>exponent-separator</b><em>(<var>M</var>, <var>R</var>)</em> is used to separate the mantissa from the exponent in scientific notation. The default value for both the marker and the rendition is <span class="unicode-codepoint">U+0065</span> (<span class="unicode-name">LATIN SMALL LETTER E</span>, <code>e</code>) .</p></dd><dt><a href="#dt-expression-context">expression context</a></dt><dd><p>The <b>expression context</b> for a given expression consists of all the information that can affect the result of the expression.</p></dd><dt><a href="#dt-external-function">external function</a></dt><dd><p><b>External functions</b> can be characterized as functions that are neither part of the processor implementation, nor written in a language whose semantics are under the control of this family of specifications. The semantics of external functions, including any context dependencies, are entirely implementation-defined. In XSLT, external functions are called <a href="https://www.w3.org/TR/xslt-30/#extension-functions"> 24.1 Extension Functions </a><sup><small>XT30</small></sup>. </p></dd><dt><a href="#dt-filter-expression">filter expression</a></dt><dd><p> A <b>filter expression</b> is an instance of the construct <a href="#doc-xpath40-FilterExpr">FilterExpr</a>: that is, it is an expression in the form <code><var>E<sub>1</sub></var>[<var>E<sub>2</sub></var>]</code>. Its effect is to return those items from the value of <var>E<sub>1</sub></var> that satisfy the predicate in <var>E<sub>2</sub></var>.</p></dd><dt><a href="#dt-filter-expression-ma">filter expression for maps and arrays</a></dt><dd><p> A <b>filter expression for maps and arrays</b> is an instance of the construct <a href="#doc-xpath40-FilterExprAM">FilterExprAM</a>: that is, it is an expression in the form <code><var>E<sub>1</sub></var>?[<var>E<sub>2</sub></var>]</code>. Its effect is to evaluate <var>E<sub>1</sub></var> to return an array or map, and to select members of the array, or entries from the map, that satisfy the predicate in <var>E<sub>2</sub></var>.</p></dd><dt><a href="#dt-fixed-focus">fixed focus</a></dt><dd><p>A <b>fixed focus</b> is a focus for an expression that is evaluated once, rather than being applied to a series of values; in a fixed focus, the context value is set to one specific value, the context position is 1, and the context size is 1.</p></dd><dt><a href="#dt-focus">focus</a></dt><dd><p>The first three components of the <a title="dynamic context" class="termref" href="#dt-dynamic-context">dynamic context</a> (context value, context position, and context size) are called the <b>focus</b> of the expression. </p></dd><dt><a href="#dt-focus-function">focus function</a></dt><dd><p>A <b>focus function</b> is an inline function expression in which the function signature is implicit: the function takes a single argument of type <code>item()*</code> (that is, any value), and binds this to the context value when evaluating the function body, which returns a result of type <code>item()*</code>.</p></dd><dt><a href="#dt-function-coercion">function coercion</a></dt><dd><p><b>Function coercion</b> wraps a <a title="function item" class="termref" href="#dt-function-item">function item</a> in a new function whose signature is the same as the expected type. This effectively delays the checking of the argument and return types until the function is called.</p></dd><dt><a href="#dt-function-definition">function definition</a></dt><dd><p>A <b>function definition</b> contains information used to evaluate a static function call, including the name, parameters, and return type of the function.</p></dd><dt><a href="#dt-function-item">function item</a></dt><dd><p>A <b>function item</b> is an item that can be called using a <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic function call</a>.</p></dd><dt><a href="#dt-generalized-atomic-type">generalized atomic type</a></dt><dd><p>A <b>generalized atomic type</b> is an <a title="item type" class="termref" href="#dt-item-type">item type</a> whose instances are all atomic items. Generalized atomic types include (a) <a title="atomic type" class="termref" href="#dt-atomic-type">atomic types</a>, either built-in (for example <code>xs:integer</code>) or imported from a schema, (b) <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union types</a>, either built-in (<code>xs:numeric</code> and <code>xs:error</code>) or imported from a schema, (c) <a title="choice item type" class="termref" href="#dt-choice-item-type">choice item types</a> if their alternatives are all generalized atomic types, and (d) <a title="enumeration type" class="termref" href="#dt-enumeration-type">enumeration types</a>. </p></dd><dt><a href="#dt-GNode">GNode</a></dt><dd><p><span class="deltaxml-old" style="background:#FF5555">The term </span><b><span class="deltaxml-old" style="background:#FF5555">generic node</span></b><span class="deltaxml-old" style="background:#FF5555"> or </span><b><span class="deltaxml-old" style="background:#FF5555">GNode</span></b><span class="deltaxml-old" style="background:#FF5555"> is a collective term for </span><a title="XNode" class="termref" href="#dt-XNode"><span class="deltaxml-old" style="background:#FF5555">XNodes</span></a><span class="deltaxml-old" style="background:#FF5555"> (more commonly called simply </span><a title="node" class="termref" href="#dt-node"><span class="deltaxml-old" style="background:#FF5555">nodes</span></a><span class="deltaxml-old" style="background:#FF5555">) representing the parts of an XML document, and </span><a title="JNode" class="termref" href="#dt-JNode"><span class="deltaxml-old" style="background:#FF5555">JNodes</span></a><span class="deltaxml-old" style="background:#FF5555">, often used to represent the parts of a JSON document.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">GNode</span></b><span class="deltaxml-new" style="background:#90EE90"> (for </span><em><span class="deltaxml-new" style="background:#90EE90">generalized node</span></em><span class="deltaxml-new" style="background:#90EE90">) is either an </span><a title="XNode" class="termref" href="#dt-XNode"><span class="deltaxml-new" style="background:#90EE90">XNode</span></a><span class="deltaxml-new" style="background:#90EE90"> or a </span><a title="JNode" class="termref" href="#dt-JNode"><span class="deltaxml-new" style="background:#90EE90">JNode</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a href="#id-static-decimal-format-grouping-separator">grouping-separator</a></dt><dd><p><b>grouping-separator</b><em>(<var>M</var>, <var>R</var>)</em> is used to separate groups of digits (for example as a thousands separator). The default value for both the marker and the rendition is <span class="unicode-codepoint">U+002C</span> (<span class="unicode-name">COMMA</span>, <code>,</code>) .</p></dd><dt><a href="#dt-GTree">GTree</a></dt><dd><p>The term <b>GTree</b> means <a title="JTree" class="termref" href="#dt-JTree">JTree</a> or <a title="XTree" class="termref" href="#dt-XTree">XTree</a>.</p></dd><dt><a href="#dt-guarded">guarded</a></dt><dd><p>An expression <var>E</var> is said to be <b>guarded</b> by some governing condition <var>C</var> if evaluation of <var>E</var> is not allowed to fail with a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> except when <var>C</var> applies.</p></dd><dt><a href="#dt-host-language">host language</a></dt><dd><p> A <b>host language</b> for XPath is any environment that provides capabilities for XPath expressions to be defined and evaluated, and that supplies a static and dynamic context for their evaluation. </p></dd><dt><a href="#IgnorableWhitespace">ignorable whitespace</a></dt><dd><p><b>Ignorable whitespace</b> consists of any <a title="whitespace" class="termref" href="#Whitespace">whitespace</a> characters that may occur between <a title="terminal" class="termref" href="#terminal">terminals</a>, unless these characters occur in the context of a production marked with a <a href="#ExplicitWhitespaceHandling"> ws:explicit</a> annotation, in which case they can occur only where explicitly specified (see <a href="#ExplicitWhitespaceHandling"><b>A.3.4.2 Explicit Whitespace Handling</b></a>).</p></dd><dt><a href="#dt-implausible">implausible</a></dt><dd><p>Certain expressions, while not erroneous, are classified as being <b>implausible</b>, because they achieve no useful effect.</p></dd><dt><a href="#dt-implementation-defined">implementation defined</a></dt><dd><p><b>Implementation-defined</b> indicates an aspect that may differ between implementations, but must be specified by the implementer for each particular implementation.</p></dd><dt><a href="#dt-implementation-dependent">implementation dependent</a></dt><dd><p><b>Implementation-dependent</b> indicates an aspect that may differ between implementations, is not specified by this or any W3C specification, and is not required to be specified by the implementer for any particular implementation.</p></dd><dt><a href="#dt-timezone">implicit timezone</a></dt><dd><p><b>Implicit timezone.</b> This is the timezone to be used when a date, time, or dateTime value that does not have a timezone is used in a comparison or arithmetic operation. The implicit timezone is an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> value of type <code>xs:dayTimeDuration</code>. See <a href="https://www.w3.org/TR/xmlschema-2/#dateTime-timezones"> 3.2.7.3 Timezones </a><sup><small>XS1-2</small></sup> or <a href="https://www.w3.org/TR/xmlschema11-2/#dateTime"> 3.3.7 dateTime </a><sup><small>XS11-2</small></sup> for the range of valid values of a timezone.</p></dd><dt><a href="#id-static-decimal-format-infinity">infinity</a></dt><dd><p><b>infinity</b><em>(<var>R</var>)</em> is the string used to represent the double value infinity (<code>INF</code>); the default value is the string <code>"Infinity"</code></p></dd><dt><a href="#dt-inline-func">inline function expression</a></dt><dd><p>An <b>inline function expression</b> is an instance of the construct <a href="#doc-xpath40-InlineFunctionExpr">InlineFunctionExpr</a>. When evaluated, an inline function expression creates an <a title="anonymous function" class="termref" href="#dt-anonymous-function">anonymous function</a> whose properties are defined directly in the inline function expression.</p></dd><dt><a href="#dt-is-attrs">in-scope attribute declarations</a></dt><dd><p><b>In-scope attribute declarations.</b> Each attribute declaration is identified either by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (for a top-level attribute declaration) or by an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> attribute identifier (for a local attribute declaration). </p></dd><dt><a href="#dt-is-elems">in-scope element declarations</a></dt><dd><p><b>In-scope element declarations.</b> Each element declaration is identified either by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (for a top-level element declaration) or by an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> element identifier (for a local element declaration). </p></dd><dt><a href="#dt-in-scope-named-item-types">in-scope named item types</a></dt><dd><p><b>In-scope named item types.</b> This is a mapping from <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> to <a title="named item type" class="termref" href="#dt-named-item-type">named item types</a>.</p></dd><dt><a href="#dt-in-scope-namespaces">in-scope namespaces</a></dt><dd><p>The <b>in-scope namespaces</b> property of an element node is a set of <a title="namespace binding" class="termref" href="#dt-namespace-binding">namespace bindings</a>, each of which associates a namespace prefix with a URI.</p></dd><dt><a href="#dt-issd">in-scope schema definitions</a></dt><dd><p><b>In-scope schema definitions</b> is a generic term for all the element declarations, attribute declarations, and schema type definitions that are in scope during static analysis of an expression.</p></dd><dt><a href="#dt-is-types">in-scope schema type</a></dt><dd><p><b>In-scope schema types.</b> Each schema type definition is identified either by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (for a <b>named type</b>) or by an <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> type identifier (for an <b>anonymous type</b>). The in-scope schema types include the predefined schema types described in <a href="#id-predefined-types"><b>3.5 Schema Types</b></a>. </p></dd><dt><a href="#dt-in-scope-variables">in-scope variables</a></dt><dd><p><b>In-scope variables.</b> This is a mapping from <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> to sequence types. It defines the set of variables that are available for reference within an expression. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is the name of the variable, and the type is the <a title="static type" class="termref" href="#dt-static-type">static type</a> of the variable.</p></dd><dt><a href="#dt-item">item</a></dt><dd><p> An <b>item</b> is either an <a title="atomic item" class="termref" href="#dt-atomic-item">atomic item</a>, a <a title="node" class="termref" href="#dt-node">node</a>, or a <a title="function item" class="termref" href="#dt-function-item">function item</a>.</p></dd><dt><a href="#dt-item-type">item type</a></dt><dd><p>An <b>item type</b> is a type that can be expressed using the <a href="#doc-xpath40-ItemType">ItemType</a> syntax, which forms part of the <a href="#doc-xpath40-SequenceType">SequenceType</a> syntax. Item types match individual <a title="item" class="termref" href="#dt-item">items</a>.</p></dd><dt><a href="#dt-item-type-designator">item type designator</a></dt><dd><p>An <b>item type designator</b> is a syntactic construct conforming to the grammar rule <a href="#doc-xpath40-ItemType">ItemType</a>. An item type designator is said to <b>designate</b> an <a title="item type" class="termref" href="#dt-item-type">item type</a>.</p></dd><dt><a href="#dt-JNode">JNode</a></dt><dd><p><span class="deltaxml-old" style="background:#FF5555">A </span><b><span class="deltaxml-old" style="background:#FF5555">JNode</span></b><span class="deltaxml-old" style="background:#FF5555"> is a kind of </span><a href="#dt-item" title="item" class="termref"><span class="deltaxml-old" style="background:#FF5555">item</span></a><span class="deltaxml-old" style="background:#FF5555"> used to represent a value within the context of a tree of </span><a title="map" class="termref" href="#dt-map"><span class="deltaxml-old" style="background:#FF5555">maps</span></a><span class="deltaxml-old" style="background:#FF5555"> and </span><a title="array" class="termref" href="#dt-array"><span class="deltaxml-old" style="background:#FF5555">arrays</span></a><span class="deltaxml-old" style="background:#FF5555">. A root </span><b><span class="deltaxml-old" style="background:#FF5555">JNode</span></b><span class="deltaxml-old" style="background:#FF5555"> represents a map or array; a non-root </span><b><span class="deltaxml-old" style="background:#FF5555">JNode</span></b><span class="deltaxml-old" style="background:#FF5555"> represents a </span><a title="member" class="termref" href="#dt-member"><span class="deltaxml-old" style="background:#FF5555">member</span></a><span class="deltaxml-old" style="background:#FF5555"> of an array or an </span><a title="entry" class="termref" href="#dt-entry"><span class="deltaxml-old" style="background:#FF5555">entry</span></a><span class="deltaxml-old" style="background:#FF5555"> in a map.</span></p><p><span class="deltaxml-new" style="background:#90EE90">A </span><b><span class="deltaxml-new" style="background:#90EE90">JNode</span></b><span class="deltaxml-new" style="background:#90EE90"> (see also </span><a href="#xpath-datamodel-40"><span class="deltaxml-new" style="background:#90EE90">[XDM 4.0]</span></a><span class="deltaxml-new" style="background:#90EE90"> section </span><a href="../xpath-datamodel-40/#id-JNodes"><span class="deltaxml-new" style="background:#90EE90">8.4 JNodes</span></a><span class="deltaxml-new" style="background:#90EE90">) is an encapsulation of a value as it appears within a tree of maps and arrays, typically (but not necessarily) obtained by parsing JSON texts.</span></p></dd><dt><a href="#dt-JTree">JTree</a></dt><dd><p>A tree that is rooted at a parentless <a title="JNode" class="termref" href="#dt-JNode">JNode</a> is referred to as a <b>JTree</b>.</p></dd><dt><a href="#dt-qname">lexical QName</a></dt><dd><p>A <b>lexical QName</b> is a name that conforms to the syntax of the <a href="#prod-xpath40-QName">QName</a> production</p></dd><dt><a href="#dt-literal">literal</a></dt><dd><p>A <b>literal</b> is a direct syntactic representation of an atomic item.</p></dd><dt><a href="#dt-literal-terminal">literal terminal</a></dt><dd><p>A <b>literal terminal</b> is a token appearing as a string in quotation marks on the right-hand side of an <a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule">ordinary production rule</a>.</p></dd><dt><a href="#dt-logical-expression">logical expression</a></dt><dd><p> A <b>logical expression</b> is either an <a title="and expression" class="termref" href="#dt-and-expression">and expression</a> or an <a title="or expression" class="termref" href="#dt-or-expression">or expression</a>. If a logical expression does not raise an error, its value is always one of the boolean values <code>true</code> or <code>false</code>.</p></dd><dt><a href="#dt-lookup-expression">lookup expression</a></dt><dd><p> A <b>lookup expression</b> is an instance of the production <a href="#doc-xpath40-LookupExpr">LookupExpr</a>: that is, an expression in the form <code><var>E<sub>1</sub></var>?<var>KS</var></code>, where <var>E<sub>1</sub></var> is an expression returning a sequence of maps or arrays, and <var>KS</var> is a key specifier, which indicates which entries in a map, or members in an array, should be selected.</p></dd><dt><a href="#dt-map">map</a></dt><dd><p>A <b>map</b> is a function that associates a set of keys with values, resulting in a collection of key / value pairs.</p></dd><dt><a href="#dt-mapping-arrow-operator">mapping arrow operator</a></dt><dd><p> The <b>mapping arrow operator</b><code>=!&gt;</code> applies a function to each item in a sequence.</p></dd><dt><a href="#may">may</a></dt><dd><p><b>MAY</b> means that an item is truly optional.</p></dd><dt><a href="#dt-member">member</a></dt><dd><p>The values of an array are called its <b>members</b>.</p></dd><dt><a href="#id-static-decimal-format-minus-sign">minus-sign</a></dt><dd><p><b>minus-sign</b><em>(<var>R</var>)</em> is the string used to mark negative numbers; the default value is <span class="unicode-codepoint">U+002D</span> (<span class="unicode-name">HYPHEN-MINUS</span>, <code>-</code>) .</p></dd><dt><a href="#must">must</a></dt><dd><p><b>MUST</b> means that the item is an absolute requirement of the specification.</p></dd><dt><a href="#mustnot">must not</a></dt><dd><p><b>MUST NOT</b> means that the item is an absolute prohibition of the specification.</p></dd><dt><a href="#dt-named-function-ref">named function reference</a></dt><dd><p> A <b>named function reference</b> is an instance of the production <a href="#doc-xpath40-NamedFunctionRef">NamedFunctionRef</a>: it is an expression (written <code>name#arity</code>) which evaluates to a <a title="function item" class="termref" href="#dt-function-item">function item</a>, the details of the function item being based on the properties of a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>.</p></dd><dt><a href="#dt-named-item-type">named item type</a></dt><dd><p>A <b>named item type</b> is an <code>ItemType</code> identified by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p></dd><dt><a href="#dt-namespace-binding">namespace binding</a></dt><dd><p>A <b>namespace binding</b> is a pair comprising a namespace prefix (which is either an <code>xs:NCName</code> or empty), and a namespace URI.</p></dd><dt><a href="#dt-namespace-sensitive">namespace-sensitive</a></dt><dd><p>The <b>namespace-sensitive</b> types are <code>xs:QName</code>, <code>xs:NOTATION</code>, types derived by restriction from <code>xs:QName</code> or <code>xs:NOTATION</code>, list types that have a namespace-sensitive item type, and union types with a namespace-sensitive type in their transitive membership.</p></dd><dt><a href="#dt-name-test">name test</a></dt><dd><p>A node test that consists only of an EQName or a Wildcard is called a <b>name test</b>.</p></dd><dt><a href="#id-static-decimal-format-NaN">NaN</a></dt><dd><p><b>NaN</b><em>(<var>R</var>)</em> is the string used to represent the double value <code>NaN</code> (not a number); the default value is the string <code>"NaN"</code></p></dd><dt><a href="#dt-node">node</a></dt><dd><p>Except where the context indicates otherwise, the term <b>node</b> is used as a synonym for <a title="XNode" class="termref" href="#dt-XNode">XNode</a>.</p></dd><dt><a href="#dt-node-test">node test</a></dt><dd><p>A <b>node test</b> is a condition on the properties of a <a title="GNode" class="termref" href="#dt-GNode">GNode</a>. A node test determines which GNodes returned by an axis are selected by a <a title="step" class="termref" href="#dt-step">step</a>.</p></dd><dt><a href="#dt-no-namespace-rule">no-namespace rule</a></dt><dd><p>When an unprefixed lexical QName is expanded using the <b>no-namespace rule</b>, it is interpreted as having an absent namespace URI.</p></dd><dt><a href="#non-delimiting-token">non-delimiting terminal symbol</a></dt><dd><p>The <b>non-delimiting terminal symbols</b> are: <code>ancestor</code><code>ancestor-or-self</code><code>and</code><code>array</code><code>as</code><code>at</code><code>attribute</code><code>cast</code><code>castable</code><code>child</code><code>comment</code><code>declare</code><code>default</code><code>descendant</code><code>descendant-or-self</code><code>div</code><code>document-node</code><code>element</code><code>else</code><code>empty-sequence</code><code>enum</code><code>eq</code><code>every</code><code>except</code><code>false</code><code>fn</code><code>following</code><code>following-or-self</code><code>following-sibling</code><code>following-sibling-or-self</code><code>follows</code><code>follows-or-is</code><code>for</code><code>function</code><code>ge</code><code>get</code><code>gnode</code><code>gt</code><code>idiv</code><code>if</code><code>in</code><code>instance</code><code>intersect</code><code>is</code><code>is-not</code><code>item</code><code>jnode</code><code>key</code><code>le</code><code>let</code><code>lt</code><code>map</code><code>member</code><code>mod</code><code>namespace</code><code>namespace-node</code><code>ne</code><code>node</code><code>of</code><code>or</code><code>otherwise</code><code>parent</code><code>precedes</code><code>precedes-or-is</code><code>preceding</code><code>preceding-or-self</code><code>preceding-sibling</code><code>preceding-sibling-or-self</code><code>processing-instruction</code><code>record</code><code>return</code><code>satisfies</code><code>schema-attribute</code><code>schema-element</code><code>self</code><code>some</code><code>text</code><code>then</code><code>to</code><code>treat</code><code>true</code><code>union</code><code>value</code><a href="#prod-xpath40-BinaryIntegerLiteral">BinaryIntegerLiteral</a><a href="#prod-xpath40-DecimalLiteral">DecimalLiteral</a><a href="#prod-xpath40-DoubleLiteral">DoubleLiteral</a><a href="#prod-xpath40-HexIntegerLiteral">HexIntegerLiteral</a><a href="#prod-xpath40-IntegerLiteral">IntegerLiteral</a><a href="#prod-xpath40-NCName">NCName</a><a href="#prod-xpath40-QName">QName</a></p></dd><dt><a href="#dt-non-trivial">non-trivial</a></dt><dd><p>A construct is said to be a <b>non-trivial</b> instance of a grammatical production if it is not also an instance of one of its sub-productions.</p></dd><dt><a href="#dt-numeric">numeric</a></dt><dd><p>The type <code>xs:numeric</code> is defined as a union type with member types <code>xs:double</code>, <code>xs:float</code>, and <code>xs:decimal</code>. An item that is an instance of any of these types is referred to as a <b>numeric value</b>, and a type that is a subtype of <code>xs:numeric</code> is referred to as a <b>numeric type</b>.</p></dd><dt><a href="#dt-ordinary-production-rule">ordinary production rule</a></dt><dd><p>An <b>ordinary production rule</b> is a production rule in <a href="#id-grammar"><b>A.1 EBNF</b></a> that is not annotated <code>ws:explicit</code>.</p></dd><dt><a href="#dt-or-expression">or expression</a></dt><dd><p>An <b>or expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production <a href="#doc-xpath40-OrExpr">OrExpr</a>.</p></dd><dt><a href="#dt-partial-function-application">partial function application</a></dt><dd><p> A <a title="static function call" class="termref" href="#dt-static-function-call">static</a> or <a title="dynamic function call" class="termref" href="#dt-dynamic-function-call">dynamic</a> function call is a <b>partial function application</b> if one or more arguments is an <a href="#prod-xpath40-ArgumentPlaceholder">ArgumentPlaceholder</a>.</p></dd><dt><a href="#dt-partially-applied-function">partially applied function</a></dt><dd><p>A <b>partially applied function</b> is a function created by <a title="partial function application" class="termref" href="#dt-partial-function-application">partial function application</a>.</p></dd><dt><a href="#dt-path-expression">path expression</a></dt><dd><p>A <b>path expression</b> is either an <a title="absolute path expression" class="termref" href="#dt-absolute-path-expression">absolute path expression</a> or a <a title="relative path expression" class="termref" href="#dt-relative-path-expression">relative path expression</a></p></dd><dt><a href="#id-static-decimal-format-pattern-separator">pattern-separator</a></dt><dd><p><b>pattern-separator</b><em>(<var>M</var>)</em> is a character used to separate positive and negative sub-pictures in a picture string; the default value is <span class="unicode-codepoint">U+003B</span> (<span class="unicode-name">SEMICOLON</span>, <code>;</code>) .</p></dd><dt><a href="#id-static-decimal-format-percent">percent</a></dt><dd><p><b>percent</b><em>(<var>M</var>, <var>R</var>)</em> is used to indicate that the number is written as a per-hundred fraction; the default value for both the marker and the rendition is <span class="unicode-codepoint">U+0025</span> (<span class="unicode-name">PERCENT SIGN</span>, <code>%</code>) .</p></dd><dt><a href="#id-static-decimal-format-per-mille">per-mille</a></dt><dd><p><b>per-mille</b><em>(<var>M</var>, <var>R</var>)</em> is used to indicate that the number is written as a per-thousand fraction; the default value for both the marker and the rendition is <span class="unicode-codepoint">U+2030</span> (<span class="unicode-name">PER MILLE SIGN</span>, <code>‰</code>) .</p></dd><dt><a href="#dt-pipeline-operator">pipeline operator</a></dt><dd><p> The <b>pipeline operator</b><code>-&gt;</code> evaluates an expression and binds the result to the context value before evaluating another expression.</p></dd><dt><a href="#dt-predicate-truth-value">predicate truth value</a></dt><dd><p>The <b>predicate truth value</b> of a value <code>$V</code> is the result of the expression <code>if ($V instance of xs:numeric+) then ($V = position()) else fn:boolean($V)</code>.</p></dd><dt><a href="#dt-primary-expression">primary expression</a></dt><dd><p> A <b>primary expression</b> is an instance of the production <a href="#doc-xpath40-PrimaryExpr">PrimaryExpr</a>. Primary expressions are the basic primitives of the language. They include literals, variable references, context value references, and function calls. A primary expression may also be created by enclosing any expression in parentheses, which is sometimes helpful in controlling the precedence of operators.</p></dd><dt><a href="#dt-principal-node-kind">principal node kind</a></dt><dd><p>Every axis has a <b>principal node kind</b>. If an axis can contain elements, then the principal node kind is element; otherwise, it is the kind of nodes that the axis can contain.</p></dd><dt><a href="#dt-pure-union-type">pure union type</a></dt><dd><p>A <b>pure union type</b> is a <span><b>simple type</b></span> that satisfies the following constraints: (a) <a href="https://www.w3.org/TR/xmlschema11-1/#std-variety">{variety}<sup><small>XS11-1</small></sup></a> is <code>union</code>, (b) the <a href="https://www.w3.org/TR/xmlschema11-1/#std-facets">{facets}<sup><small>XS11-1</small></sup></a> property is empty, (c) no type in the transitive membership of the union type has <a href="https://www.w3.org/TR/xmlschema11-1/#std-variety">{variety}<sup><small>XS11-1</small></sup></a><code>list</code>, and (d) no type in the transitive membership of the union type is a type with <a href="https://www.w3.org/TR/xmlschema11-1/#std-variety">{variety}<sup><small>XS11-1</small></sup></a><code>union</code> having a non-empty <a href="https://www.w3.org/TR/xmlschema11-1/#std-facets">{facets}<sup><small>XS11-1</small></sup></a> property</p></dd><dt><a href="#dt-range-expression">range expression</a></dt><dd><p>A <b>range expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production <a href="#doc-xpath40-RangeExpr">RangeExpr</a>. A range expression is used to construct a sequence of integers.</p></dd><dt><a href="#dt-relative-path-expression">relative path expression</a></dt><dd><p> A <b>relative path expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production <a href="#doc-xpath40-RelativePathExpr">RelativePathExpr</a>: it consists of two or more operand expressions separated by <code>/</code> or <code>//</code> operators.</p></dd><dt><a href="#dt-resolve-relative-uri">resolve</a></dt><dd><p>To <b>resolve a relative URI</b><code>$rel</code> against a base URI <code>$base</code> is to expand it to an absolute URI, as if by calling the function <code>fn:resolve-uri($rel, $base)</code>.</p></dd><dt><a href="#dt-reverse-document-order">reverse document order</a></dt><dd><p>The node ordering that is the reverse of document order is called <b>reverse document order</b>.</p></dd><dt><a href="#dt-same-key">same key</a></dt><dd><p>Two atomic items <var>K<sub>1</sub></var> and <var>K<sub>2</sub></var> have the <b>same key value</b> if <code>fn:atomic-equal(<var>K<sub>1</sub></var>, <var>K<sub>2</sub></var>)</code> returns <code>true</code>, as specified in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#func-atomic-equal">2.2.1 fn:atomic-equal</a></p></dd><dt><a href="#dt-schema-type">schema type</a></dt><dd><p>A <b>schema type</b> is a complex type or simple type as defined in the <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> specifications, including built-in types as well as user-defined types.</p></dd><dt><a href="#dt-sequence">sequence</a></dt><dd><p>A <b>sequence</b> is an ordered collection of zero or more <a title="item" class="termref" href="#dt-item">items</a>.</p></dd><dt><a href="#dt-sequence-arrow-operator">sequence arrow operator</a></dt><dd><p> The <b>sequence arrow operator</b><code>=&gt;</code> applies a function to a supplied sequence.</p></dd><dt><a href="#dt-sequence-concatenation">sequence concatenation</a></dt><dd><p>The <b>sequence concatenation</b> of a number of sequences <var>S<sub>1</sub></var>, <var>S<sub>2</sub></var>, ... <var>S<sub>n</sub></var> is defined to be the sequence formed from the items of <var>S<sub>1</sub></var>, followed by the items from <var>S<sub>2</sub></var>, and so on, retaining order.</p></dd><dt><a href="#dt-sequence-expression">sequence expression</a></dt><dd><p>A <b>sequence expression</b> is a <a title="non-trivial" class="termref" href="#dt-non-trivial">non-trivial</a> instance of the production rule <a href="#doc-xpath40-Expr">Expr</a>, that is, an expression containing two or more instances of the production <a href="#doc-xpath40-ExprSingle">ExprSingle</a> separated by the comma operator.</p></dd><dt><a href="#dt-sequence-type">sequence type</a></dt><dd><p>A <b>sequence type</b> is a type that can be expressed using the <a href="#doc-xpath40-SequenceType">SequenceType</a> syntax. Sequence types are used whenever it is necessary to refer to a type in an XPath 4.0 expression. Since all values are sequences, every value matches one or more <b>sequence types</b>.</p></dd><dt><a href="#dt-sequence-type-designator">sequence type designator</a></dt><dd><p>A <b>sequence type designator</b> is a syntactic construct conforming to the grammar rule <a href="#doc-xpath40-SequenceType">SequenceType</a>. A sequence type designator is said to <b>designate</b> a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>.</p></dd><dt><a href="#dt-sequencetype-matching">SequenceType matching</a></dt><dd><p><b>SequenceType matching</b> compares a value with an expected <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>. </p></dd><dt><a href="#dt-serialization">serialization</a></dt><dd><p><b>Serialization</b> is the process of converting an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> to a sequence of octets (step DM4 in Figure 1.), as described in <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a>.</p></dd><dt><a href="#dt-singleton">singleton</a></dt><dd><p>A sequence containing exactly one item is called a <b>singleton</b>.</p></dd><dt><a href="#dt-singleton-enumeration-type">singleton enumeration type</a></dt><dd><p>An enumeration type with a single enumerated value <var>E</var> (such as <code>enum("red")</code>) matches an item <var>S</var> if and only if (a) <var>S</var> is an instance of <code>xs:string</code>, and (b) <var>S</var> is equal to <var>E</var> when compared using Unicode codepoint collation. This is referred to as a <b>singleton enumeration type</b>.</p></dd><dt><a href="#dt-singleton-focus">singleton focus</a></dt><dd><p>A <b>singleton focus</b> is a <a title="fixed focus" class="termref" href="#dt-fixed-focus">fixed focus</a> in which the <a title="context value" class="termref" href="#dt-context-value">context value</a> is a <a title="singleton" class="termref" href="#dt-singleton">singleton</a> item.</p></dd><dt><a href="#stable">stable</a></dt><dd><p>Document order is <b>stable</b>, which means that the relative order of two nodes will not change during the processing of a given <span class="xpath">expression</span>, even if this order is <a title="implementation   dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p></dd><dt><a href="#dt-static-collations">statically known collations</a></dt><dd><p><b>Statically known collations.</b> This is an <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> mapping from URI to collation. It defines the names of the collations that are available for use in processing expressions.</p></dd><dt><a href="#dt-static-decimal-formats">statically known decimal formats</a></dt><dd><p><b>Statically known decimal formats.</b> This is a mapping from QNames to decimal formats, with one default format that has no visible name, referred to as the unnamed decimal format. Each format is available for use when formatting numbers using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-number"><code>fn:format-number</code></a> function.</p></dd><dt><a href="#dt-statically-known-function-definitions">statically known function definitions</a></dt><dd><p><b>Statically known function definitions.</b> This is a set of <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a>.</p></dd><dt><a href="#dt-static-namespaces">statically known namespaces</a></dt><dd><p><b>Statically known namespaces.</b> This is a mapping from prefix to namespace URI that defines all the namespaces that are known during static processing of a given expression.</p></dd><dt><a href="#dt-static-analysis">static analysis phase</a></dt><dd><p>The <b>static analysis phase</b> depends on the expression itself and on the <a title="static context" class="termref" href="#dt-static-context">static context</a>. The <b>static analysis phase</b> does not depend on input data (other than schemas).</p></dd><dt><a href="#dt-static-base-uri">Static Base URI</a></dt><dd><p><b>Static Base URI.</b> This is an absolute URI, used to resolve relative URIs during static analysis. </p></dd><dt><a href="#dt-static-context">static context</a></dt><dd><p>The <b>static context</b> of an expression is the information that is available during static analysis of the expression, prior to its evaluation.</p></dd><dt><a href="#dt-static-error">static error</a></dt><dd><p> An error that can be detected during the static analysis phase, and is not a type error, is a <b>static error</b>.</p></dd><dt><a href="#dt-static-function-call">static function call</a></dt><dd><p>A <b>static function call</b> is an instance of the production <a href="#doc-xpath40-FunctionCall">FunctionCall</a>: it consists of an EQName followed by a parenthesized list of zero or more arguments.</p></dd><dt><a href="#dt-static-type">static type</a></dt><dd><p>The <b>static type</b> of an expression is the best inference that the processor is able to make statically about the type of the result of the expression.</p></dd><dt><a href="#dt-step">step</a></dt><dd><p>The operands of a path expression are conventionally referred to as <b>steps</b>.</p></dd><dt><a href="#dt-string-value">string value</a></dt><dd><p>The <b>string value</b> of a node is a string and can be extracted by applying the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-string"><code>string</code></a> function to the node.</p></dd><dt><a href="#dt-substantively-disjoint">substantively disjoint</a></dt><dd><p>Two <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a> are deemed to be <b>substantively disjoint</b> if (a) neither is a subtype of the other (see <a href="#id-seqtype-subtype"><b>3.3.1 Subtypes of Sequence Types</b></a>) and (b) the only values that are instances of both types are one or more of the following:</p><ul><li><p>The empty sequence, <code>()</code>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-map">empty map</a><sup><small>DM</small></sup>, <code>{}</code>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-array">empty array</a><sup><small>DM</small></sup>, <code>[]</code>.</p></li></ul></dd><dt><a href="#dt-substitution-group">substitution group</a></dt><dd><p><b>Substitution groups</b> are defined in <a href="https://www.w3.org/TR/xmlschema-1/#Element_Equivalence_Class"> 2.2.2.2 Element Substitution Group </a><sup><small>XS1-1</small></sup> and <a href="https://www.w3.org/TR/xmlschema11-1/#Element_Equivalence_Class"> 2.2.2.2 Element Substitution Group </a><sup><small>XS11-1</small></sup>. Informally, the substitution group headed by a given element (called the <b>head element</b>) consists of the set of elements that can be substituted for the head element without affecting the outcome of schema validation.</p></dd><dt><a href="#dt-subtype">subtype</a></dt><dd><p>Given two <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a> or <a title="item type" class="termref" href="#dt-item-type">item types</a>, the rules in this section determine if one is a <b>subtype</b> of the other. If a type <var>A</var> is a subtype of type <var>B</var>, it follows that every value matched by <var>A</var> is also matched by <var>B</var>.</p></dd><dt><a href="#dt-subtype-substitution">subtype substitution</a></dt><dd><p>The use of a value that has a <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> that is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of the expected type is known as <b>subtype substitution</b>.</p></dd><dt><a href="#symbol">symbol</a></dt><dd><p>Each rule in the grammar defines one <b>symbol</b>, using the following format: </p><div class="exampleInner"><pre xml:space="preserve">symbol ::= expression</pre></div></dd><dt><a href="#symbolseparators">symbol separators</a></dt><dd><p><a title="whitespace" class="termref" href="#Whitespace">Whitespace</a> and <a href="#doc-xpath40-Comment">Comments</a> function as <b>symbol separators</b>. For the most part, they are not mentioned in the grammar, and may occur between any two terminal symbols mentioned in the grammar, except where that is forbidden by the <a href="#ws-explicit">/* ws: explicit */</a> annotation in the EBNF, or by the <a href="#parse-note-xml-version">/* xgc: xml-version */</a> annotation.</p></dd><dt><a href="#dt-system-function">system function</a></dt><dd><p><b>System functions</b> include the functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>, functions defined by the specifications of a host language, <a title="constructor function" class="termref" href="#dt-constructor-function">constructor functions</a> for atomic types, and any additional functions provided by the implementation. System functions are sometimes called built-in functions.</p></dd><dt><a href="#terminal">terminal</a></dt><dd><p>A <b>terminal</b> is a symbol or string or pattern that can appear in the right-hand side of a rule, but never appears on the left-hand side in the main grammar, although it may appear on the left-hand side of a rule in the grammar for terminals.</p></dd><dt><a href="#dt-trusted">trusted</a></dt><dd><p>The static context includes a boolean property called <b>trusted</b> that determines whether external resources are available.</p></dd><dt><a href="#dt-type-annotation">type annotation</a></dt><dd><p>Each element node and attribute node in an <a title="XDM instance" class="termref" href="#dt-data-model-instance">XDM instance</a> has a <b>type annotation</b> (described in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#types">4.1 Schema Information</a>). The type annotation of a node is a reference to a <a title="schema type" class="termref" href="#dt-schema-type">schema type</a>. </p></dd><dt><a href="#dt-typed-value">typed value</a></dt><dd><p>The <b>typed value</b> of a node is a sequence of atomic items and can be extracted by applying the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-data"><code>data</code></a> function to the node.</p></dd><dt><a href="#dt-type-error">type error</a></dt><dd><p>A <b>type error</b> may be raised during the static analysis phase or the dynamic evaluation phase. During the static analysis phase, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs when the <a title="static type" class="termref" href="#dt-static-type">static type</a> of an expression does not match the expected type of the context in which the expression occurs. During the dynamic evaluation phase, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs when the <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a> of a value does not match the expected type of the context in which the value occurs.</p></dd><dt><a href="#dt-untrusted">untrusted</a></dt><dd></dd><dt><a href="#dt-URI">URI</a></dt><dd><p>Within this specification, the term <b>URI</b> refers to a Universal Resource Identifier as defined in <a href="#RFC3986">[RFC3986]</a> and extended in <a href="#RFC3987">[RFC3987]</a> with the new name <b>IRI</b>.</p></dd><dt><a href="#dt-value">value</a></dt><dd><p>In the <a title="data model" class="termref" href="#dt-datamodel">data model</a>, a <b>value</b> is always a <a title="sequence" class="termref" href="#dt-sequence">sequence</a>.</p></dd><dt><a href="#dt-variable-reference">variable reference</a></dt><dd><p>A <b>variable reference</b> is an EQName preceded by a $-sign.</p></dd><dt><a href="#dt-variable-terminal">variable terminal</a></dt><dd><p>A <b>variable terminal</b> is an instance of a production rule that is not itself an <a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule">ordinary production rule</a> but that is named (directly) on the right-hand side of an <a title="ordinary production rule" class="termref" href="#dt-ordinary-production-rule">ordinary production rule</a>.</p></dd><dt><a href="#dt-variable-values">variable values</a></dt><dd><p><b>Variable values</b>. This is a mapping from <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> to values. It contains the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> as the <a title="in-scope variables" class="termref" href="#dt-in-scope-variables">in-scope variables</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a> for the expression. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is the name of the variable and the value is the dynamic value of the variable, which includes its <a title="dynamic type" class="termref" href="#dt-dynamic-type">dynamic type</a>.</p></dd><dt><a href="#dt-warning">warning</a></dt><dd><p>In addition to <a title="static error" class="termref" href="#dt-static-error">static errors</a>, <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a>, and <a title="type error" class="termref" href="#dt-type-error">type errors</a>, an XPath 4.0 implementation may raise <b>warnings</b>, either during the <a title="static analysis phase" class="termref" href="#dt-static-analysis">static analysis phase</a> or the <a title="dynamic evaluation phase" class="termref" href="#dt-dynamic-evaluation">dynamic evaluation phase</a>. The circumstances in which warnings are raised, and the ways in which warnings are handled, are <a title="implementation defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p></dd><dt><a href="#Whitespace">whitespace</a></dt><dd><p>A <b>whitespace</b> character is any of the characters defined by <a href="http://www.w3.org/TR/REC-xml/#NT-S"> [http://www.w3.org/TR/REC-xml/#NT-S]</a>.</p></dd><dt><a href="#dt-wildcard-matches">wildcard-matches</a></dt><dd><p>In these rules, if <var>MU</var> and <var>NU</var> are <a href="#prod-xpath40-NameTestUnion">NameTestUnions</a>, then <var>MU</var><b>wildcard-matches</b><var>NU</var> is true if every name that matches <var>MU</var> also matches <var>NU</var>.</p></dd><dt><a href="#dt-data-model-instance">XDM instance</a></dt><dd><p>The term <b>XDM instance</b> is used, synonymously with the term <a title="value" class="termref" href="#dt-value">value</a>, to denote an unconstrained <a title="sequence" class="termref" href="#dt-sequence">sequence</a> of <a title="item" class="termref" href="#dt-item">items</a>.</p></dd><dt><a href="#dt-XNode">XNode</a></dt><dd><p>An <b>XNode</b> is an instance of one of the <b>node kinds</b> defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#nodes">7.1 XML Nodes</a>.</p></dd><dt><a href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a></dt><dd><p><b>XPath 1.0 compatibility mode.</b><span class="xpath">This value is <code>true</code> if rules for backward compatibility with XPath Version 1.0 are in effect; otherwise it is <code>false</code>.</span></p></dd><dt><a href="#dt-anyAtomicType">xs:anyAtomicType</a></dt><dd><p><code>xs:anyAtomicType</code> is an <a title="atomic type" class="termref" href="#dt-atomic-type">atomic type</a> that includes all atomic items (and no values that are not atomic). Its base type is <code>xs:anySimpleType</code> from which all simple types, including atomic, list, and union types, are derived. All primitive atomic types, such as <code>xs:decimal</code> and <code>xs:string</code>, have <code>xs:anyAtomicType</code> as their base type.</p></dd><dt><a href="#dt-dayTimeDuration">xs:dayTimeDuration</a></dt><dd><p><code>xs:dayTimeDuration</code> is derived by restriction from <code>xs:duration</code>. The lexical representation of <code>xs:dayTimeDuration</code> is restricted to contain only day, hour, minute, and second components.</p></dd><dt><a href="#dt-xs-error">xs:error</a></dt><dd><p><code>xs:error</code> is a simple type with no value space. It is defined in <a href="https://www.w3.org/TR/xmlschema11-1/#xsd-error"> 3.16.7.3 xs:error </a><sup><small>XS11-1</small></sup> and can be used in the <a href="#id-sequencetype-syntax"><b>3.1 Sequence Types</b></a> to raise errors.</p></dd><dt><a href="#dt-untyped">xs:untyped</a></dt><dd><p><code>xs:untyped</code> is used as the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of an element node that has not been validated, or has been validated in <code>skip</code> mode.</p></dd><dt><a href="#dt-untypedAtomic">xs:untypedAtomic</a></dt><dd><p><code>xs:untypedAtomic</code> is an <a title="atomic type" class="termref" href="#dt-atomic-type">atomic type</a> that is used to denote untyped atomic data, such as text that has not been assigned a more specific type.</p></dd><dt><a href="#dt-yearMonthDuration">xs:yearMonthDuration</a></dt><dd><p><code>xs:yearMonthDuration</code> is derived by restriction from <code>xs:duration</code>. The lexical representation of <code>xs:yearMonthDuration</code> is restricted to contain only year and month components.</p></dd><dt><a href="#dt-XTree">XTree</a></dt><dd><p>A tree that is rooted at a parentless <a title="XNode" class="termref" href="#dt-XNode">XNode</a> is referred to as an <b>XTree</b>.</p></dd><dt><a href="#id-static-decimal-format-zero-digit">zero-digit</a></dt><dd><p><b>zero-digit</b><em>(<var>M</var>)</em> is the character used in the picture string to represent the digit zero; the default value is <span class="unicode-codepoint">U+0030</span> (<span class="unicode-name">DIGIT ZERO</span>, <code>0</code>) . This character must be a digit (category Nd in the Unicode property database), and it must have the numeric value zero. This property implicitly defines the ten Unicode characters that are used to represent the values 0 to 9 in the function output: Unicode is organized so that each set of decimal digits forms a contiguous block of characters in numerical sequence. Within the picture string any of these ten character can be used (interchangeably) as a place-holder for a mandatory digit. Within the final result string, these ten characters are used to represent the digits zero to nine.</p></dd></dl></div><div class="_diffs div1"><h2><a id="id-revision-log"></a>I <a href="#id-revision-log" style="text-decoration: none">Change Log</a> (Non-Normative)</h2><ol><li><p>If a section of this specification has been updated since version 3.1, an overview of the changes is provided, along with links to navigate to the next or previous change.</p><p>See <a href="#id-introduction"><b>1 Introduction</b></a></p></li><li><p>Sections with significant changes are marked with a ✭ symbol in the table of contents.</p><p>See <a href="#id-introduction"><b>1 Introduction</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/691 2154">691 2154&nbsp;</a></p><p>Enumeration types are added as a new kind of <code>ItemType</code>, constraining the value space of strings.</p><p>See <a href="#id-enumeration-types"><b>3.2.6 Enumeration Types</b></a></p></li><li><p> Setting the default namespace for elements and types to the special value <code>##any</code> causes an unprefixed element name to act as a wildcard, matching by local name regardless of namespace. </p><p>See <a href="#id-element-test"><b>3.2.7.2 Element Types</b></a></p></li><li><p>The terms <b>FunctionType</b>, <b>ArrayType</b>, <b>MapType</b>, and <b>RecordType</b> replace <b>FunctionTest</b>, <b>ArrayTest</b>, <b>MapTest</b>, and <b>RecordTest</b>, with no change in meaning.</p><p>See <a href="#id-function-test"><b>3.2.8.1 Function Types</b></a></p></li><li><p> Record types are added as a new kind of <code>ItemType</code>, constraining the value space of maps. </p><p>See <a href="#id-record-test"><b>3.2.8.3 Record Types</b></a></p></li><li><p> Function coercion now allows a function with arity <var>N</var> to be supplied where a function of arity greater than <var>N</var> is expected. For example this allows the function <code>true#0</code> to be supplied where a predicate function is required. </p><p>See <a href="#id-function-coercion"><b>3.4.4 Function Coercion</b></a></p></li><li><p> The symbols <code>×</code> and <code>÷</code> can be used for multiplication and division. </p><p>See <a href="#id-arithmetic"><b>4.9 Arithmetic Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1763 1830">1763 1830&nbsp;</a></p><p>The syntax on the right-hand side of an arrow operator has been relaxed; a dynamic function call no longer needs to start with a variable reference or a parenthesized expression, it can also be (for example) an inline function expression or a map or array constructor.</p><p>See <a href="#id-arrow-operator"><b>4.21 Arrow Expressions</b></a></p></li><li><p> The arrow operator <code>=&gt;</code> is now complemented by a “mapping arrow” operator <code>=!&gt;</code> which applies the supplied function to each item in the input sequence independently. </p><p>See <a href="#id-mapping-arrow-expression"><b>4.21.2 Mapping Arrow Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1023 1128">1023 1128&nbsp;</a></p><p> It has been clarified that function coercion applies even when the supplied function item matches the required function type. This is to ensure that arguments supplied when calling the function are checked against the signature of the required function type, which might be stricter than the signature of the supplied function item. </p><p>See <a href="#id-function-coercion"><b>3.4.4 Function Coercion</b></a></p></li><li><p>A dynamic function call can now be applied to a sequence of functions, and in particular to <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence. This makes it easier to chain a sequence of calls.</p><p>See <a href="#id-eval-dynamic-function-call"><b>4.6.3.1 Evaluating Dynamic Function Calls</b></a></p></li><li><p> The syntax <code>document-node(<var>N</var>)</code>, where <var>N</var> is a <code>NameTestUnion</code>, is introduced as an abbreviation for <code>document-node(element(<var>N</var>))</code>. For example, <code>document-node(*)</code> matches any well-formed XML document (as distinct from a document fragment). </p><p>See <a href="#node-types"><b>3.2.7 Node Types</b></a></p></li><li><p>QName literals are new in 4.0.</p><p>See <a href="#id-qname-literals"><b>4.3.1.3 QName Literals</b></a></p></li><li><p> Path expressions are extended to handle JNodes (found in trees of maps and arrays) as well as XNodes (found in trees representing parsed XML). </p><p>See <a href="#id-path-expressions"><b>4.7 Path Expressions</b></a></p></li><li><p>A method call invokes a function held as the value of an entry in a map, supplying the map implicitly as the value of the first argument.</p><p>See <a href="#id-methods"><b>4.14.4 Method Calls</b></a></p></li><li><p>The <code>treat as</code> expression now raises a type error rather than a dynamic error when it fails.</p><p>See <a href="#id-treat"><b>4.18.5 Treat</b></a></p></li><li><p> XPath 4.0 allows an XPath expression to be preceded by namespace declarations, allowing namespace prefixes to be bound within the XPath expression, rather than relying entirely on the host language to declare namespace prefixes. </p><p>See <a href="#namespace-declarations"><b>4.1 Namespace Declarations</b></a></p></li><li><p> The group is considering removing or substantially changing this feature, it is considered <a href="#at-risk">at risk</a>. </p><p>See <a href="#id-filter-maps-and-arrays"><b>4.14.5 Filter Expressions for Maps and Arrays</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/28">28&nbsp;</a></p><p> Multiple <code>for</code> and <code>let</code> clauses can be combined in an expression without an intervening <code>return</code> keyword. </p><p>See <a href="#id-for-expressions"><b>4.13.1 For Expressions</b></a></p><p>See <a href="#id-let-expressions"><b>4.13.2 Let Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/159">159&nbsp;</a></p><p> Keyword arguments are allowed on static function calls, as well as positional arguments. </p><p>See <a href="#id-function-calls"><b>4.6.1.1 Static Function Call Syntax</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/202">202&nbsp;</a></p><p>The presentation of the rules for the subtype relationship between sequence types and item types has been substantially rewritten to improve clarity; no change to the semantics is intended.</p><p>See <a href="#id-sequencetype-subtype"><b>3.3 Subtype Relationships</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/230">230&nbsp;</a></p><p> The rules for “errors and optimization” have been tightened up to disallow many cases of optimizations that alter error behavior. In particular there are restrictions on reordering the operands of <code>and</code> and <code>or</code>, and of predicates in filter expressions, in a way that might allow the processor to raise dynamic errors that the author intended to prevent. </p><p>See <a href="#id-guarded-expressions"><b>2.5.5 Guarded Expressions</b></a></p><p>See <a href="#id-logical-expressions"><b>4.12 Logical Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/254">254&nbsp;</a></p><p> The term "function conversion rules" used in 3.1 has been replaced by the term "coercion rules". </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p><p> The coercion rules allow “relabeling” of a supplied atomic item where the required type is a derived atomic type: for example, it is now permitted to supply the value 3 when calling a function that expects an instance of <code>xs:positiveInteger</code>. </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/284">284&nbsp;</a></p><p> Alternative syntax for conditional expressions is available: <code>if (condition) { X }</code>. </p><p>See <a href="#id-conditionals"><b>4.15 Conditional Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/286">286&nbsp;</a></p><p> Element and attribute tests can include alternative names: <code>element(chapter|section)</code>, <code>attribute(role|class)</code>. </p><p>See <a href="#node-types"><b>3.2.7 Node Types</b></a></p><p> The <code>NodeTest</code> in an <code>AxisStep</code> now allows alternatives: <code>ancestor::(section|appendix)</code></p><p>See <a href="#node-types"><b>3.2.7 Node Types</b></a></p><p> Element and attribute tests of the form <code>element(N)</code> and <code>attribute(N)</code> now allow <code>N</code> to be any <code>NameTest</code>, including a wildcard. </p><p>See <a href="#id-element-test"><b>3.2.7.2 Element Types</b></a></p><p>See <a href="#id-attribute-test"><b>3.2.7.3 Attribute Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/324">324&nbsp;</a></p><p> String templates provide a new way of constructing strings: for example <code>`{$greeting}, {$planet}!`</code> is equivalent to <code>$greeting || ', ' || $planet || '!'</code></p><p>See <a href="#id-string-templates"><b>4.10.2 String Templates</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/326">326&nbsp;</a></p><p> Support for higher-order functions is now a mandatory feature (in 3.1 it was optional). </p><p>See <a href="#id-conformance"><b>5 Conformance</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/344">344&nbsp;</a></p><p>A <code>for member</code> clause is added to FLWOR expressions to allow iteration over an array.</p><p>See <a href="#id-for-expressions"><b>4.13.1 For Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/368">368&nbsp;</a></p><p> The concept of the context item has been generalized, so it is now a context value. That is, it is no longer constrained to be a single item. </p><p>See <a href="#eval_context"><b>2.2.2 Dynamic Context</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/433">433&nbsp;</a></p><p> Numeric literals can now be written in hexadecimal or binary notation; and underscores can be included for readability. </p><p>See <a href="#id-numeric-literals"><b>4.3.1.1 Numeric Literals</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/519">519&nbsp;</a></p><p> The rules for tokenization have been largely rewritten. In some cases the revised specification may affect edge cases that were handled in different ways by different 3.1 processors, which could lead to incompatible behavior. </p><p>See <a href="#lexical-structure"><b>A.3 Lexical structure</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/521">521&nbsp;</a></p><p>New abbreviated syntax is introduced (<a title="focus function" class="termref" href="#dt-focus-function">focus function</a>) for simple inline functions taking a single argument. An example is <code>fn { ../@code }</code></p><p>See <a href="#id-inline-func"><b>4.6.6 Inline Function Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/603">603&nbsp;</a></p><p><span style="display: none;" class="delete_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return an empty sequence rather than an error. </span><span style="display: none;" class="add_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return the empty sequence rather than an error. </span><span class="modify_version"> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence rather than an error. </span></p><p>See <a href="#id-implausible-expressions"><b>2.5.6 Implausible Expressions</b></a></p><p>See <a href="#implausible-axis-steps"><b>4.7.5.6 Implausible Axis Steps</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/606">606&nbsp;</a></p><p> Element and attribute tests of the form <code>element(A|B)</code> and <code>attribute(A|B)</code> are now allowed. </p><p>See <a href="#id-element-test"><b>3.2.7.2 Element Types</b></a></p><p>See <a href="#id-attribute-test"><b>3.2.7.3 Attribute Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/728">728&nbsp;</a></p><p> The syntax <code>record(*)</code> is allowed; it matches any map. </p><p>See <a href="#id-record-test"><b>3.2.8.3 Record Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/815">815&nbsp;</a></p><p> The coercion rules now allow conversion in either direction between <code>xs:hexBinary</code> and <code>xs:base64Binary</code>. </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/911">911&nbsp;</a></p><p> The coercion rules now allow any numeric type to be implicitly converted to any other, for example an <code>xs:double</code> is accepted where the required type is <code>xs:decimal</code>. </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/996">996&nbsp;</a></p><p> The value of a predicate in a filter expression can now be a sequence of integers. </p><p>See <a href="#id-filter-expression"><b>4.5 Filter Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1031">1031&nbsp;</a></p><p><span style="display: none;" class="delete_version"> An <code>otherwise</code> operator is introduced: <code>A otherwise B</code> returns the value of <code>A</code>, unless it is an empty sequence, in which case it returns the value of <code>B</code>. </span><span style="display: none;" class="add_version"> An <code>otherwise</code> operator is introduced: <code>A otherwise B</code> returns the value of <code>A</code>, unless it is the empty sequence, in which case it returns the value of <code>B</code>. </span><span class="modify_version"> An <code>otherwise</code> operator is introduced: <code>A otherwise B</code> returns the value of <code>A</code>, unless it is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty sequence, in which case it returns the value of <code>B</code>. </span></p><p>See <a href="#id-otherwise"><b>4.16 Otherwise Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1071">1071&nbsp;</a></p><p> In map constructors, the keyword <code>map</code> is now optional, so <code>map { 0: false(), 1: true() }</code> can now be written <code>{ 0: false(), 1: true() }</code>, provided it is used in a context where this creates no ambiguity. </p><p>See <a href="#id-map-constructors"><b>4.14.1.1 Map Constructors</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1131">1131&nbsp;</a></p><p> A positional variable can be defined in a <code>for</code> expression. </p><p>See <a href="#id-for-expressions"><b>4.13.1 For Expressions</b></a></p><p> The type of a variable used in a <code>for</code> expression can be declared. </p><p>See <a href="#id-for-expressions"><b>4.13.1 For Expressions</b></a></p><p> The type of a variable used in a <code>let</code> expression can be declared. </p><p>See <a href="#id-let-expressions"><b>4.13.2 Let Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1132">1132&nbsp;</a></p><p> Choice item types (an item type allowing a set of alternative item types) are introduced. </p><p>See <a href="#id-choice-item-types"><b>3.2.5 Choice Item Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1163">1163&nbsp;</a></p><p> Filter expressions for maps and arrays are introduced. </p><p>See <a href="#id-filter-maps-and-arrays"><b>4.14.5 Filter Expressions for Maps and Arrays</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1181">1181&nbsp;</a></p><p> The <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a> can be set to the value <code>##any</code>, allowing unprefixed names in axis steps to match elements with a given local name in any namespace. </p><p>See <a href="#static_context"><b>2.2.1 Static Context</b></a></p><p> If the default namespace for elements and types has the special value <code>##any</code>, then an unprefixed name in a <code>NameTest</code> acts as a wildcard, matching names in any namespace or none. </p><p>See <a href="#node-tests"><b>4.7.5.2 Node Tests</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1197">1197&nbsp;</a></p><p>The keyword <code>fn</code> is allowed as a synonym for <code>function</code> in function types, to align with changes to inline function declarations.</p><p>See <a href="#id-function-test"><b>3.2.8.1 Function Types</b></a></p><p> In inline function expressions, the keyword <code>function</code> may be abbreviated as <code>fn</code>. </p><p>See <a href="#id-inline-func"><b>4.6.6 Inline Function Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1212">1212&nbsp;</a></p><p> New keywords introducing item types, such as <code>record</code>, <code>item</code>, and <code>enum</code>, have been added to the list of reserved function names. </p><p>See <a href="#id-reserved-fn-names"><b>A.4 Reserved Function Names</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1217">1217&nbsp;</a></p><p> Predicates in filter expressions for maps and arrays can now be numeric. </p><p>See <a href="#id-filter-maps-and-arrays"><b>4.14.5 Filter Expressions for Maps and Arrays</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1249">1249&nbsp;</a></p><p> A <code>for key/value</code> clause is added to FLWOR expressions to allow iteration over maps.</p><p>See <a href="#id-for-expressions"><b>4.13.1 For Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1250">1250&nbsp;</a></p><p> Several decimal format properties, including minus sign, exponent separator, percent, and per-mille, can now be rendered as arbitrary strings rather than being confined to a single character. </p><p>See <a href="#id-decimal-formats"><b>2.2.1.2 Decimal Formats</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1265">1265&nbsp;</a></p><p> The rules regarding the <code>document-uri</code> property of nodes returned by the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>fn:collection</code></a> function have been relaxed. </p><p>See <a href="#eval_context"><b>2.2.2 Dynamic Context</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1344">1344&nbsp;</a></p><p> Parts of the static context that were there purely to assist in static typing, such as the statically known documents, were no longer referenced and have therefore been dropped. </p><p>See <a href="#static_context"><b>2.2.1 Static Context</b></a></p><p> The static typing option has been dropped. </p><p>See <a href="#id-processing-model"><b>2.4 Processing Model</b></a></p><p> The static typing feature has been dropped. </p><p>See <a href="#id-conformance"><b>5 Conformance</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1361">1361&nbsp;</a></p><p> The term <b>atomic value</b> has been replaced by <a title="atomic item" class="termref" href="#dt-atomic-item">atomic item</a>. </p><p>See <a href="#id-values"><b>2.1.3 Values</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1384">1384&nbsp;</a></p><p> If a type declaration is present, the supplied values in the input sequence are now coerced to the required type. Type declarations are now permitted in XPath as well as XQuery. </p><p>See <a href="#id-quantified-expressions"><b>4.17 Quantified Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1496">1496&nbsp;</a></p><p> The context value static type, which was there purely to assist in static typing, has been dropped. </p><p>See <a href="#static_context"><b>2.2.1 Static Context</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1498">1498&nbsp;</a></p><p>The EBNF operators <code>++</code> and <code>**</code> have been introduced, for more concise representation of sequences using a character such as <code>","</code> as a separator. The notation is borrowed from Invisible XML.</p><p>See <a href="#id-terminology"><b>2.1 Terminology</b></a></p><p> The EBNF notation has been extended to allow the constructs <code>(A ++ ",")</code> (one or more occurrences of <code>A</code>, comma-separated, and <code>(A ** ",")</code> (zero or more occurrences of <code>A</code>, comma-separated. </p><p>See <a href="#id-ebnf-introduction"><b>2.1.1 Grammar Notation</b></a></p><p>The EBNF operators <code>++</code> and <code>**</code> have been introduced, for more concise representation of sequences using a character such as <code>","</code> as a separator. The notation is borrowed from Invisible XML.</p><p>See <a href="#id-grammar"><b>A.1 EBNF</b></a></p><p>See <a href="#EBNFNotation"><b>A.1.1 Notation</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1501">1501&nbsp;</a></p><p> The coercion rules now apply recursively to the members of an array and the entries in a map. </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1532">1532&nbsp;</a></p><p> Four new axes have been defined: <code>preceding-or-self</code>, <code>preceding-sibling-or-self</code>, <code>following-or-self</code>, and <code>following-sibling-or-self</code>. </p><p>See <a href="#axes"><b>4.7.5.1 Axes</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1577">1577&nbsp;</a></p><p><span style="display: none;" class="delete_version"> The syntax <code>record()</code> is allowed; the only thing it matches is an empty map. </span><span style="display: none;" class="add_version"> The syntax <code>record()</code> is allowed; the only thing it matches is the empty map. </span><span class="modify_version"> The syntax <code>record()</code> is allowed; the only thing it matches is <span class="deltaxml-old" style="background:#FF5555">an</span><span class="deltaxml-new" style="background:#90EE90">the</span> empty map. </span></p><p>See <a href="#id-record-test"><b>3.2.8.3 Record Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1686">1686&nbsp;</a></p><p> With the pipeline operator <code>-&gt;</code>, the result of an expression can be bound to the context value before evaluating another expression. </p><p>See <a href="#id-pipeline-operator"><b>4.19 Pipeline operator</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1696">1696&nbsp;</a></p><p> Parameter names may be included in a function signature; they are purely documentary. </p><p>See <a href="#id-function-test"><b>3.2.8.1 Function Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1703">1703&nbsp;</a></p><p>Ordered maps are introduced.</p><p>See <a href="#id-maps"><b>4.14.1 Maps</b></a></p><p>The order of key-value pairs in the map constructor is now retained in the constructed map.</p><p>See <a href="#id-map-constructors"><b>4.14.1.1 Map Constructors</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1874">1874&nbsp;</a></p><p> The coercion rules now reorder the entries in a map when the required type is a record type. </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1898">1898&nbsp;</a></p><p>The rules for subtyping of document node types have been refined.</p><p>See <a href="#id-item-subtype-documents"><b>3.3.2.5.2 Subtyping Nodes: Document Nodes</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1991">1991&nbsp;</a></p><p> Named record types used in the signatures of built-in functions are now available as standard in the static context. </p><p>See <a href="#static_context"><b>2.2.1 Static Context</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2031">2031&nbsp;</a></p><p> The terms <b>XNode</b> and <code>JNode</code> are introduced; the existing term <b>node</b> remains in use as a synonym for <b>XNode</b> where the context does not specify otherwise. </p><p>See <a href="#id-values"><b>2.1.3 Values</b></a></p><p> JNodes are introduced </p><p>See <a href="#id-jnode-types"><b>3.2.9 JNode Types</b></a></p><p>See <a href="#id-generalized-node-types"><b>3.2.10 Generalized Node Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2055">2055&nbsp;</a></p><p> Sequences, arrays, and maps can be destructured in a <code>let</code> expression to extract their components into multiple variables. </p><p>See <a href="#id-let-expressions"><b>4.13.2 Let Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2094">2094&nbsp;</a></p><p>A general expression is allowed within a map constructor; this facilitates the creation of maps in which the presence or absence of particular keys is decided dynamically.</p><p>See <a href="#id-map-constructors"><b>4.14.1.1 Map Constructors</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2115">2115&nbsp;</a></p><p> This section describes and formalizes a convention that was already in use, but not explicitly stated, in earlier versions of the specification. </p><p>See <a href="#id-expression-names"><b>2.1.2 Expression Names</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2130">2130&nbsp;</a></p><p> Operator <code>is-not</code> is introduced, as a complement to the operator <code>is</code>. </p><p>See <a href="#id-node-comparisons"><b>4.11.3 GNode Comparisons</b></a></p><p> Operators <code>precedes</code> and <code>follows</code> are introduced as synonyms for operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code>. </p><p>See <a href="#id-node-comparisons"><b>4.11.3 GNode Comparisons</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2134">2134&nbsp;</a></p><p> The lookup operator <code>?</code> can now be followed by an arbitrary literal, for cases where keys are items other than integers or NCNames. It can also be followed by a variable reference or a context value reference. </p><p>See <a href="#id-lookup"><b>4.14.3 Lookup Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2176">2176&nbsp;</a></p><p> Operators <code>precedes-or-is</code> and <code>follows-or-is</code> are introduced as synonyms for the union of operators <code>&lt;&lt;</code> and <code>is</code> and for the union of operators <code>&gt;&gt;</code> and <code>is</code>, respectively. </p><p>See <a href="#id-node-comparisons"><b>4.11.3 GNode Comparisons</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2202">2202&nbsp;</a></p><p>The type <code>schema-element(N)</code> is now defined to be a subtype of <code>element()</code> and of various other element tests.</p><p>See <a href="#id-item-subtype-elements"><b>3.3.2.5.3 Subtyping Nodes: Elements</b></a></p><p>The type <code>schema-attribute(N)</code> is now defined to be a subtype of <code>attribute()</code> and of various other attribute tests.</p><p>See <a href="#id-item-subtype-attributes"><b>3.3.2.5.4 Subtyping Nodes: Attributes</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2213">2213&nbsp;</a></p><p>This section (“External Resources and Security”) is new.</p><p>See <a href="#id-security-resources"><b>2.3 External Resources and Security</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2218">2218&nbsp;</a></p><p> The rules for value comparisons when comparing values of different types (for example, decimal and double) have changed to be transitive. A decimal value is no longer converted to double, instead the double is converted to a decimal without loss of precision. This may affect compatibility in edge cases involving comparison of values that are numerically very close. </p><p>See <a href="#id-value-comparisons"><b>4.11.1 Value Comparisons</b></a></p><p>The rules for comparing untyped atomic items with numeric values have changed. Rather than converting an untyped atomic item unconditionally to <code>xs:double</code>, it is now converted to the type of the numeric operand. This is designed to ensure that comparisons such as <code>&lt;a&gt;1.1&lt;/a&gt; = 1.1</code> succeed, given that the values will now be compared as decimals rather than as doubles.</p><p>See <a href="#id-general-comparisons"><b>4.11.2 General Comparisons</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2227">2227&nbsp;</a></p><p>A <code>URIQualifiedName</code> may now supply a prefix as well as a URI and local name.</p><p>See <a href="#id-namespaces-and-qnames"><b>2.1.4 Namespaces and QNames</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2256">2256&nbsp;</a></p><p> An ordering is now defined for all data types. </p><p>See <a href="#id-value-comparisons"><b>4.11.1 Value Comparisons</b></a></p></li></ol></div></div><script src="js/toc.js"></script><script src="/js/scroll.js"></script></body></html>