<!DOCTYPE HTML><html xmlns="http://www.w3.org/1999/xhtml" lang="EN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>XQuery 4.0: An XML Query Language </title><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link rel="stylesheet" type="text/css" href="css/w3c-base.css"><link rel="stylesheet" href="css/qtspecs.css"><link rel="stylesheet" href="css/xquery-40.css"><style type="text/css">
          body { margin-top: 50px }
          a.button { background: #DDD; border: 2px outset black; padding: 2px; margin: 2px; font-family: sans-serif; font-size: small;}
          a.button:hover { cursor:pointer; }
          a.button:active { border-style: inset; }
        </style><link rel="stylesheet" href="/css/autodiff.css"></head><body class="toc-inline"><div style="position:fixed; clear:both; top:0px" id="_autodiff_buttons"><p><a class="button" onclick="view('old')">
              View Old
            </a><a class="button" onclick="view('new')">
              View New
            </a><a class="button" onclick="view('both')">
              View Both
            </a><a class="button" onclick="view('only')">
              View Only
            </a><a class="button" onclick="scroll_to('prev')">
              Previous
            </a><a class="button" onclick="scroll_to('next')">
              Next
            </a><span id="__autodiff__"></span></p><p>This draft contains only sections that have differences from the version that it modified.</p></div><div class="head"><p><a href="https://www.w3.org/"><img src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C" alt="W3C" height="48" width="72"></a></p><h1><a id="title"></a>XQuery 4.0: An XML Query Language </h1><h2><a id="w3c-doctype"></a>W3C Editor's Draft 2&nbsp;February&nbsp;2026</h2><dl><dt>This version:</dt><dd><a href="https://qt4cg.org/specifications/xquery-40/">https://qt4cg.org/specifications/xquery-40/</a></dd><dt>Most recent version of XQuery:</dt><dd><a href="https://qt4cg.org/specifications/xquery-40/">https://qt4cg.org/specifications/xquery-40/</a></dd><dt>Most recent Recommendation of XQuery:</dt><dd><a href="https://www.w3.org/TR/2017/REC-xquery-31-20170321/">https://www.w3.org/TR/2017/REC-xquery-31-20170321/</a></dd><dt>Editor:</dt><dd>Michael Kay, Saxonica <a href="http://www.saxonica.com/">&lt;http://www.saxonica.com/&gt;</a></dd></dl><p>This document is also available in these non-normative formats: <a href="xquery-40.xml">XML</a>.</p><p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;©&nbsp;2000&nbsp;<a href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="https://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="https://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="https://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p><hr></div><div><h2><a id="abstract"></a>Abstract</h2><p class="xquery">XML is a versatile markup language, capable of labeling the information content of diverse data sources, including structured and semi-structured documents, relational databases, and object repositories. A query language that uses the structure of XML intelligently can express queries across all these kinds of data, whether physically stored in XML or viewed as XML via middleware. This specification describes a query language called XQuery, which is designed to be broadly applicable across many types of XML data sources.</p><p class="xquery">A list of changes made since XQuery 3.1 can be found in <a href="#id-revision-log"><b>J Change Log</b></a>. </p></div><div><h2><a id="status"></a>Status of this Document</h2><p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document.</em></p><p>This document is a working draft developed and maintained by a W3C Community Group, the <a href="https://www.w3.org/community/xslt-40/">XQuery and XSLT Extensions Community Group</a> unofficially known as QT4CG (where "QT" denotes Query and Transformation). This draft is work in progress and should not be considered either stable or complete. Standard W3C copyright and patent conditions apply.</p><p>The community group welcomes comments on the specification. Comments are best submitted as issues on the group's <a href="https://github.com/qt4cg/qtspecs/issues">GitHub repository</a>.</p><p id="at-risk">As the Community Group moves towards publishing dated, stable drafts, some features that the group thinks may likely be removed or substantially changed are marked “at risk” in their changes section. In this draft:</p><ul><li><a href="#id-filter-maps-and-arrays">Filter Expressions for Maps and Arrays</a></li></ul><p>The community group maintains two extensive test suites, one oriented to XQuery and XPath, the other to XSLT. These can be found at <a href="https://github.com/qt4cg/qt4tests">qt4tests</a> and <a href="https://github.com/qt4cg/xslt40-test">xslt40-test</a> respectively. New tests, or suggestions for correcting existing tests, are welcome. The test suites include extensive metadata describing the conditions for applicability of each test case as well as the expected results. They do not include any test drivers for executing the tests: each implementation is expected to provide its own test driver.</p><div class="dedication" id="dedication"><h3>Dedication</h3><p class="xquery">The publications of this community group <a href="xpath-40.html#dedication">are dedicated</a> to our co-chair, Michael Sperberg-McQueen&nbsp;(1954–2024).</p></div></div><hr><div class="body"><div class="_diffs div1"><h2><a id="id-types"></a>3 <a href="#id-types" style="text-decoration: none">Types</a></h2><p>As noted in <a href="#id-values"><b>2.1.3 Values</b></a>, every value in XQuery 4.0 is regarded as a <a title="sequence" class="termref" href="#dt-sequence">sequence</a> of zero, one, or more <a title="item" class="termref" href="#dt-item">items</a>. The type system of XQuery 4.0, described in this section, classifies the kinds of value that the language can handle, and the operations permitted on different kinds of value.</p><p>The type system of XQuery 4.0 is related to the type system of <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a> in two ways:</p><ul><li><p>atomic items in XQuery 4.0 (which are one kind of <a title="item" class="termref" href="#dt-item">item</a>) have <a title="atomic type" class="termref" href="#dt-atomic-type">atomic types</a> such as <code>xs:string</code>, <code>xs:boolean</code>, and <code>xs:integer</code>. These types are taken directly from their definitions in <a href="#XMLSchema10">[XML Schema 1.0]</a> or <a href="#XMLSchema11">[XML Schema 1.1]</a>.</p></li><li><p><a title="XNode" class="termref" href="#dt-XNode">XNodes</a> (which are another kind of <a title="item" class="termref" href="#dt-item">item</a>) have a property called a <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> which determines the type of their content. The type annotation is a <a title="schema type" class="termref" href="#dt-schema-type">schema type</a>. The type annotation of a node must not be confused with the item type of the node. For example, an element <code>&lt;age&gt;23&lt;/age&gt;</code> might have been validated against a schema that defines this element as having <code>xs:integer</code> content. If this is the case, the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of the node will be <code>xs:integer</code>, and in the XQuery 4.0 type system, the node will match the <a title="item type" class="termref" href="#dt-item-type">item type</a><code>element(age, xs:integer)</code>. </p></li></ul><p>This chapter of the specification starts by defining <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a> and <a title="item type" class="termref" href="#dt-item-type">item types</a>, which describe the range of <a title="value" class="termref" href="#dt-value">values</a> that can be bound to variables, used in expressions, or passed to functions. It then describes how these relate to <a title="schema type" class="termref" href="#dt-schema-type">schema types</a>, that is, the simple and complex types defined in an XSD schema.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In many situations the terms <b>item type</b> and <b>sequence type</b> are used interchangeably to refer either to the type itself, or to the syntactic construct that designates the type: so in the expression <code>$x instance of xs:string*</code>, the construct <code>xs:string*</code> uses the <a href="#doc-xquery40-SequenceType">SequenceType</a> syntax to designate a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> whose instances are sequences of strings. When more precision is required, the specification is careful to use the terms <a title="item type" class="termref" href="#dt-item-type">item type</a> and <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> to refer to the actual types, while using the production names <a href="#doc-xquery40-ItemType">ItemType</a> and <a href="#doc-xquery40-SequenceType">SequenceType</a> to refer to the syntactic designators of these types.</p></div><div class="_diffs div2"><h3><a id="id-matching-item"></a>3.2 <a href="#id-matching-item" style="text-decoration: none">Item Types</a></h3><p> [<a id="dt-item-type" title="item type">Definition</a>: An <b>item type</b> is a type that can be expressed using the <a href="#doc-xquery40-ItemType">ItemType</a> syntax, which forms part of the <a href="#doc-xquery40-SequenceType">SequenceType</a> syntax. Item types match individual <a title="item" class="termref" href="#dt-item">items</a>.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>While this definition is adequate for the purpose of defining the syntax of XQuery 4.0, it ignores the fact that there are also item types that cannot be expressed using XQuery 4.0 syntax: specifically, item types that reference an anonymous simple type or complex type defined in a schema. Such types can appear as type annotations on nodes following schema validation.</p></div><p>In most cases, the set of items matched by an item type consists either exclusively of <a title="atomic item" class="termref" href="#dt-atomic-item">atomic items</a>, exclusively of <a title="node" class="termref" href="#dt-node">nodes</a>, or exclusively of <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-function-item">function items</a><sup><small>DM</small></sup>. Exceptions include the generic types <code>item()</code>, which matches all items, <code>xs:error</code>, which matches no items, and <a title="choice item type" class="termref" href="#dt-choice-item-type">choice item types</a>, which can match any combination of types. </p><p> [<a id="dt-item-type-designator" title="item type designator">Definition</a>: An <b>item type designator</b> is a syntactic construct conforming to the grammar rule <a href="#doc-xquery40-ItemType">ItemType</a>. An item type designator is said to <b>designate</b> an <a title="item type" class="termref" href="#dt-item-type">item type</a>.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Two <a title="item type designator" class="termref" href="#dt-item-type-designator">item type designators</a> may designate the same item type. For example, <code>element()</code> and <code>element(*)</code> are equivalent, as are <code>attribute(A)</code> and <code>attribute(A, xs:anySimpleType)</code>.</p></div><p><a title="lexical QName" class="termref" href="#dt-qname">Lexical QNames</a> appearing in an <a title="item type designator" class="termref" href="#dt-item-type-designator">item type designator</a><span class="xquery">(other than within a <a title="function assertion" class="termref" href="#dt-function-assertion">function assertion</a>)</span> are expanded using the <a title="default type namespace rule" class="termref" href="#dt-default-type-namespace-rule">default type namespace rule</a>. Equality of QNames is defined by the <code>eq</code> operator.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType"></a><code><a href="#prod-xquery40-ItemType">ItemType</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-ItemType-RegularItemType">RegularItemType</a> | <a href="#doc-xquery40-ItemType-FunctionType">FunctionType</a> | <a href="#doc-xquery40-ItemType-TypeName">TypeName</a> | <a href="#doc-xquery40-ItemType-ChoiceItemType">ChoiceItemType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-RegularItemType"></a><code><a href="#prod-xquery40-RegularItemType">RegularItemType</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-ItemType-AnyItemTest">AnyItemTest</a> | <a href="#doc-xquery40-ItemType-NodeKindTest">NodeKindTest</a> | <a href="#doc-xquery40-ItemType-GNodeType">GNodeType</a> | <a href="#doc-xquery40-ItemType-JNodeType">JNodeType</a> | <a href="#doc-xquery40-ItemType-MapType">MapType</a> | <a href="#doc-xquery40-ItemType-ArrayType">ArrayType</a> | <a href="#doc-xquery40-ItemType-RecordType">RecordType</a> | <a href="#doc-xquery40-ItemType-EnumerationType">EnumerationType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-AnyItemTest"></a><code><a href="#prod-xquery40-AnyItemTest">AnyItemTest</a></code></td><td>::=</td><td><code>"item" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-NodeKindTest"></a><code><a href="#prod-xquery40-NodeKindTest">NodeKindTest</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-ItemType-DocumentTest">DocumentTest</a><br>| <a href="#doc-xquery40-ItemType-ElementTest">ElementTest</a><br>| <a href="#doc-xquery40-ItemType-AttributeTest">AttributeTest</a><br>| <a href="#doc-xquery40-ItemType-SchemaElementTest">SchemaElementTest</a><br>| <a href="#doc-xquery40-ItemType-SchemaAttributeTest">SchemaAttributeTest</a><br>| <a href="#doc-xquery40-ItemType-PITest">PITest</a><br>| <a href="#doc-xquery40-ItemType-CommentTest">CommentTest</a><br>| <a href="#doc-xquery40-ItemType-TextTest">TextTest</a><br>| <a href="#doc-xquery40-ItemType-NamespaceNodeTest">NamespaceNodeTest</a><br>| <a href="#doc-xquery40-ItemType-AnyNodeKindTest">AnyNodeKindTest</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-DocumentTest"></a><code><a href="#prod-xquery40-DocumentTest">DocumentTest</a></code></td><td>::=</td><td><code>"document-node" "(" (<a href="#doc-xquery40-ItemType-ElementTest">ElementTest</a> | <a href="#doc-xquery40-ItemType-SchemaElementTest">SchemaElementTest</a> | <a href="#doc-xquery40-ItemType-NameTestUnion">NameTestUnion</a>)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-ElementTest"></a><code><a href="#prod-xquery40-ElementTest">ElementTest</a></code></td><td>::=</td><td><code>"element" "(" (<a href="#doc-xquery40-ItemType-NameTestUnion">NameTestUnion</a> ("," <a href="#doc-xquery40-ItemType-TypeName">TypeName</a> "?"?)?)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-SchemaElementTest"></a><code><a href="#prod-xquery40-SchemaElementTest">SchemaElementTest</a></code></td><td>::=</td><td><code>"schema-element" "(" <a href="#prod-xquery40-ElementName">ElementName</a> ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-NameTestUnion"></a><code><a href="#prod-xquery40-NameTestUnion">NameTestUnion</a></code></td><td>::=</td><td><code>(<a href="#doc-xquery40-ItemType-NameTest">NameTest</a> ++ "|")</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-NameTest"></a><code><a href="#prod-xquery40-NameTest">NameTest</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-ItemType-EQName">EQName</a> | <a href="#prod-xquery40-Wildcard">Wildcard</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-AttributeTest"></a><code><a href="#prod-xquery40-AttributeTest">AttributeTest</a></code></td><td>::=</td><td><code>"attribute" "(" (<a href="#doc-xquery40-ItemType-NameTestUnion">NameTestUnion</a> ("," <a href="#doc-xquery40-ItemType-TypeName">TypeName</a>)?)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-SchemaAttributeTest"></a><code><a href="#prod-xquery40-SchemaAttributeTest">SchemaAttributeTest</a></code></td><td>::=</td><td><code>"schema-attribute" "(" <a href="#prod-xquery40-AttributeName">AttributeName</a> ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-PITest"></a><code><a href="#prod-xquery40-PITest">PITest</a></code></td><td>::=</td><td><code>"processing-instruction" "(" (<a href="#prod-xquery40-NCName">NCName</a> | <a href="#doc-xquery40-ItemType-StringLiteral">StringLiteral</a>)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-StringLiteral"></a><code><a href="#prod-xquery40-StringLiteral">StringLiteral</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-AposStringLiteral">AposStringLiteral</a> | <a href="#prod-xquery40-QuotStringLiteral">QuotStringLiteral</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-CommentTest"></a><code><a href="#prod-xquery40-CommentTest">CommentTest</a></code></td><td>::=</td><td><code>"comment" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-TextTest"></a><code><a href="#prod-xquery40-TextTest">TextTest</a></code></td><td>::=</td><td><code>"text" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-NamespaceNodeTest"></a><code><a href="#prod-xquery40-NamespaceNodeTest">NamespaceNodeTest</a></code></td><td>::=</td><td><code>"namespace-node" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-AnyNodeKindTest"></a><code><a href="#prod-xquery40-AnyNodeKindTest">AnyNodeKindTest</a></code></td><td>::=</td><td><code>"node" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-GNodeType"></a><code><a href="#prod-xquery40-GNodeType">GNodeType</a></code></td><td>::=</td><td><code>"gnode" "(" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-JNodeType"></a><code><a href="#prod-xquery40-JNodeType">JNodeType</a></code></td><td>::=</td><td><code>"jnode" "(" (("*" | <a href="#prod-xquery40-NCName">NCName</a> | <a href="#doc-xquery40-Constant">Constant</a>) ("," ("*" | <a href="#doc-xquery40-SequenceType">SequenceType</a>))?)? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-MapType"></a><code><a href="#prod-xquery40-MapType">MapType</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-AnyMapType">AnyMapType</a> | <a href="#prod-xquery40-TypedMapType">TypedMapType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-ArrayType"></a><code><a href="#prod-xquery40-ArrayType">ArrayType</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-AnyArrayType">AnyArrayType</a> | <a href="#prod-xquery40-TypedArrayType">TypedArrayType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-RecordType"></a><code><a href="#prod-xquery40-RecordType">RecordType</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-AnyRecordType">AnyRecordType</a> | <a href="#prod-xquery40-TypedRecordType">TypedRecordType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-EnumerationType"></a><code><a href="#prod-xquery40-EnumerationType">EnumerationType</a></code></td><td>::=</td><td><code>"enum" "(" (<a href="#doc-xquery40-ItemType-StringLiteral">StringLiteral</a> ++ ",") ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-FunctionType"></a><code><a href="#prod-xquery40-FunctionType">FunctionType</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-Annotation">Annotation</a>* (<a href="#prod-xquery40-AnyFunctionType">AnyFunctionType</a><br>| <a href="#prod-xquery40-TypedFunctionType">TypedFunctionType</a>)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-TypeName"></a><code><a href="#prod-xquery40-TypeName">TypeName</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-ItemType-EQName">EQName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-EQName"></a><code><a href="#prod-xquery40-EQName">EQName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-QName">QName</a> | <a href="#prod-xquery40-URIQualifiedName">URIQualifiedName</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-ItemType-ChoiceItemType"></a><code><a href="#prod-xquery40-ChoiceItemType">ChoiceItemType</a></code></td><td>::=</td><td><code>"(" (<a href="#doc-xquery40-ItemType">ItemType</a> ++ "|") ")"</code></td></tr></tbody></table><p>This section defines the syntax and semantics of different <code>ItemTypes</code> in terms of the values that they match.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For an explanation of the EBNF grammar notation (and in particular, the operators <code>++</code> and <code>**</code>), see <a href="#id-grammar"><b>A.1 EBNF</b></a>.</p></div><p>An <a title="item type designator" class="termref" href="#dt-item-type-designator">item type designator</a> written simply as an <code>EQName</code> (that is, a <code>TypeName</code>) is interpreted as follows:</p><ol class="enumar"><li><p>If the name is written as a lexical QName, then it is expanded using the <a title="default type namespace rule" class="termref" href="#dt-default-type-namespace-rule">default type namespace rule</a>.</p></li><li><p>If the expanded name matches a <a title="named item type" class="termref" href="#dt-named-item-type">named item type</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>, then it is taken as a reference to the corresponding item type. The rules that apply are the rules for the expanded item type definition.</p></li><li><p>Otherwise, it must match the name of a type in the <a title="in-scope schema type" class="termref" href="#dt-is-types">in-scope schema types</a> in the <a title="static context" class="termref" href="#dt-static-context">static context</a>: specifically, an <a title="atomic type" class="termref" href="#dt-atomic-type">atomic type</a> or a <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a>. See <a href="#id-predefined-types"><b>3.5 Schema Types</b></a> for details. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>A name in the <code>xs</code> namespace will always fall into this category, since the namespace is reserved. See <a href="#id-namespaces-and-qnames"><b>2.1.4 Namespaces and QNames</b></a>.</p></div></li><li><p>If the name cannot be resolved to a type, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised [<a href="#ERRXPST0051" title="err:XPST0051">err:XPST0051</a>].</p></li></ol><div class="_diffs div3"><h4><a id="id-function-map-array-tests"></a>3.2.8 <a href="#id-function-map-array-tests" style="text-decoration: none">Function, Map, and Array Types</a></h4><p>The following sections describe the syntax for <a title="item type" class="termref" href="#dt-item-type">item types</a> for functions, including arrays and maps.</p><p>The <a title="subtype" class="termref" href="#dt-subtype">subtype</a> relation among these types is described in the various subsections of <a href="#id-itemtype-subtype"><b>3.3.2 Subtypes of Item Types</b></a>.</p><div class="_diffs div4"><h5><a id="id-record-test"></a>3.2.8.3 <a href="#id-record-test" style="text-decoration: none">Record Types</a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-jnode-types">next</a> | <a href="#id-function-test">previous</a>)</p><ol><li><p> Record types are added as a new kind of <code>ItemType</code>, constraining the value space of maps. </p></li><li><p><span style="display: none;" class="delete_version"> The syntax <code>record()</code> is allowed; the only thing it matches is an empty map. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1491">1491</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1577">1577</a>&nbsp;17 October 2024]</i></span><span style="display: none;" class="add_version"> The syntax <code>record(*)</code> is allowed; it matches any map. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/52">52</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/728">728</a>&nbsp;10 October 2023]</i></span><span class="modify_version"> The syntax <code>record(<span class="deltaxml-new" style="background:#90EE90">*</span>)</code> is allowed; <span class="deltaxml-old" style="background:#FF5555">the only thing </span>it matches <span class="deltaxml-old" style="background:#FF5555">is an empty</span><span class="deltaxml-new" style="background:#90EE90">any</span> map. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1491"><span class="deltaxml-old" style="background:#FF5555">1491</span></a><a href="https://github.com/qt4cg/qtspecs/issues/52"><span class="deltaxml-new" style="background:#90EE90">52</span></a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1577"><span class="deltaxml-old" style="background:#FF5555">1577</span></a><a href="https://github.com/qt4cg/qtspecs/pull/728"><span class="deltaxml-new" style="background:#90EE90">728</span></a>&nbsp;<span class="deltaxml-old" style="background:#FF5555">17 October 2024</span><span class="deltaxml-new" style="background:#90EE90">10 October 2023</span>]</i></span></p></li><li><p><span class="deltaxml-old" style="background:#FF5555"> Extensible map types are dropped; instead, the coercion rules cause undefined map entries to be discarded. </span><i><span class="deltaxml-old" style="background:#FF5555">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/2365"><span class="deltaxml-old" style="background:#FF5555">2365</span></a><span class="deltaxml-old" style="background:#FF5555">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/2413"><span class="deltaxml-old" style="background:#FF5555">2413</span></a><span class="deltaxml-old" style="background:#FF5555">&nbsp;28 January 2026]</span></i></p><p><span class="deltaxml-new" style="background:#90EE90"> The syntax </span><code><span class="deltaxml-new" style="background:#90EE90">record()</span></code><span class="deltaxml-new" style="background:#90EE90"> is allowed; the only thing it matches is an empty map. </span><i><span class="deltaxml-new" style="background:#90EE90">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/1491"><span class="deltaxml-new" style="background:#90EE90">1491</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/1577"><span class="deltaxml-new" style="background:#90EE90">1577</span></a><span class="deltaxml-new" style="background:#90EE90">&nbsp;17 October 2024]</span></i></p></li></ol></div><p>A <a href="#doc-xquery40-RecordType">RecordType</a> matches maps that meet specific criteria.</p><p>For example, the <code>RecordType</code><code>record(r as xs:double, i as xs:double)</code> matches a map if the map has exactly two entries: an entry with key <code>"r"</code> whose value is a <a title="singleton" class="termref" href="#dt-singleton">singleton</a><code>xs:double</code> value, and an entry with key <code>"i"</code> whose value is also a <a title="singleton" class="termref" href="#dt-singleton">singleton</a><code>xs:double</code> value.</p><p>Record types describe a subset of the value space of maps. They do not define any new kinds of values, or any additional operations. They are useful in many cases to describe more accurately the type of a variable, function parameter, or function result, giving benefits both in the readability of the code, and in the ability of the processor to detect and diagnose type errors and to optimize execution.</p><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordType"></a><code><a href="#prod-xquery40-RecordType">RecordType</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-RecordType-AnyRecordType">AnyRecordType</a> | <a href="#doc-xquery40-RecordType-TypedRecordType">TypedRecordType</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordType-AnyRecordType"></a><code><a href="#prod-xquery40-AnyRecordType">AnyRecordType</a></code></td><td>::=</td><td><code>"record" "(" "*" ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordType-TypedRecordType"></a><code><a href="#prod-xquery40-TypedRecordType">TypedRecordType</a></code></td><td>::=</td><td><code>"record" "(" (<a href="#doc-xquery40-RecordType-FieldDeclaration">FieldDeclaration</a> ** ",") <a href="#doc-xquery40-RecordType-ExtensibleFlag">ExtensibleFlag</a>? ")"</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordType-FieldDeclaration"></a><code><a href="#prod-xquery40-FieldDeclaration">FieldDeclaration</a></code></td><td>::=</td><td><code><a href="#doc-xquery40-RecordType-FieldName">FieldName</a> "?"? ("as" <a href="#doc-xquery40-RecordType-SequenceType">SequenceType</a>)?</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordType-FieldName"></a><code><a href="#prod-xquery40-FieldName">FieldName</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-NCName">NCName</a> | <a href="#doc-xquery40-RecordType-StringLiteral">StringLiteral</a></code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordType-StringLiteral"></a><code><a href="#prod-xquery40-StringLiteral">StringLiteral</a></code></td><td>::=</td><td><code><a href="#prod-xquery40-AposStringLiteral">AposStringLiteral</a> | <a href="#prod-xquery40-QuotStringLiteral">QuotStringLiteral</a></code></td></tr><tr><td></td><td></td><td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordType-SequenceType"></a><code><a href="#prod-xquery40-SequenceType">SequenceType</a></code></td><td>::=</td><td><code>("empty-sequence" "(" ")")<br>| (<a href="#doc-xquery40-ItemType">ItemType</a><a href="#prod-xquery40-OccurrenceIndicator">OccurrenceIndicator</a>?)</code></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xquery40-RecordType-ExtensibleFlag"></a><code><a href="#prod-xquery40-ExtensibleFlag">ExtensibleFlag</a></code></td><td>::=</td><td><code>"," "*"</code></td></tr></tbody></table><p><span class="deltaxml-old" style="background:#FF5555">For generality, the syntax </span><code><span class="deltaxml-old" style="background:#FF5555">record()</span></code><span class="deltaxml-old" style="background:#FF5555"> defines a record type that has no explicit fields. The only thing it matches is an </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-map"><span class="deltaxml-old" style="background:#FF5555">empty map</span></a><sup><small><span class="deltaxml-old" style="background:#FF5555">DM</span></small></sup><span class="deltaxml-old" style="background:#FF5555">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the list of fields ends with </span><code><span class="deltaxml-new" style="background:#90EE90">",*"</span></code><span class="deltaxml-new" style="background:#90EE90"> then the record type is said to be </span><b><span class="deltaxml-new" style="background:#90EE90">extensible</span></b><span class="deltaxml-new" style="background:#90EE90">. For example, the </span><code><span class="deltaxml-new" style="background:#90EE90">RecordType</span></code><code><span class="deltaxml-new" style="background:#90EE90">record(e as element(Employee), *)</span></code><span class="deltaxml-new" style="background:#90EE90"> matches a map if it has an entry with key </span><code><span class="deltaxml-new" style="background:#90EE90">"e"</span></code><span class="deltaxml-new" style="background:#90EE90"> whose value matches </span><code><span class="deltaxml-new" style="background:#90EE90">element(Employee)</span></code><span class="deltaxml-new" style="background:#90EE90">, regardless what other entries the map might contain.</span></p><p><span class="deltaxml-new" style="background:#90EE90">For generality:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">The syntax </span><code><span class="deltaxml-new" style="background:#90EE90">record()</span></code><span class="deltaxml-new" style="background:#90EE90"> defines a record type that has no explicit fields and that is not extensible. The only thing it matches is an </span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-empty-map"><span class="deltaxml-new" style="background:#90EE90">empty map</span></a><sup><small><span class="deltaxml-new" style="background:#90EE90">DM</span></small></sup><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The syntax </span><code><span class="deltaxml-new" style="background:#90EE90">record(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> defines an extensible record type that has no explicit field declarations. It is equivalent to the item type </span><code><span class="deltaxml-new" style="background:#90EE90">map(*)</span></code><span class="deltaxml-new" style="background:#90EE90">: that is, it matches any map.</span></p></li></ul><p>A record type can <span class="deltaxml-old" style="background:#FF5555">describe only maps</span><span class="deltaxml-new" style="background:#90EE90">constrain only those entries</span> whose keys are strings<span class="deltaxml-old" style="background:#FF5555">. A field</span><span class="deltaxml-new" style="background:#90EE90">, but when the record type is marked as extensible, then other entries may be present in the map with either string or non-string keys. Entries</span> whose key is a string can be expressed using an (unquoted) NCName if the key conforms to NCName syntax, or using a (quoted) string literal otherwise.</p><p>Although constructors for named record types produce a map in which the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-entry-order">entry order</a><sup><small>DM</small></sup> reflects the order of field definitions in the record type definition, the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-entry-order">entry order</a><sup><small>DM</small></sup> of a map has no effect on whether the map matches a particular record type: the entries in a map do not have to be in any particular order.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Lookup expressions have been extended in 4.0 so that non-NCName keys can be used without parentheses: <code>employee?"middle name"</code></p></div><p>If the type declaration for a field is omitted, then <code>item()*</code> is assumed: that is, the map entry may have any type.</p><p><span style="display: none;" class="delete_version">If the field name is followed by a question mark, then the value must have the specified type if it is present, but it may also be absent. For example, the <code>RecordType</code><code>record(first as xs:string, middle? as xs:string, last as xs:string)</code> requires the map to have string-valued entries with keys <code>"first"</code> and <code>"last"</code>; it also declares that if the map has an entry with key <code>"middle"</code>, the value of that entry must be a single <code>xs:string</code>. Declaring the type as <code>record(first as xs:string, middle? as xs:string?, last as xs:string)</code> also allows the entry with key <code>"middle"</code> to be present but empty.</span><span style="display: none;" class="add_version">If the field name is followed by a question mark, then the value must have the specified type if it is present, but it may also be absent. For example, the <code>RecordType</code><code>record(first as xs:string, middle? as xs:string, last as xs:string, *)</code> requires the map to have string-valued entries with keys <code>"first"</code> and <code>"last"</code>; it also declares that if the map has an entry with key <code>"middle"</code>, the value of that entry must be a single <code>xs:string</code>. Declaring the type as <code>record(first as xs:string, middle? as xs:string?, last as xs:string, *)</code> also allows the entry with key <code>"middle"</code> to be present but empty.</span><span class="modify_version">If the field name is followed by a question mark, then the value must have the specified type if it is present, but it may also be absent. For example, the <code>RecordType</code><code>record(first as xs:string, middle? as xs:string, last as xs:string<span class="deltaxml-new" style="background:#90EE90">, *</span>)</code> requires the map to have string-valued entries with keys <code>"first"</code> and <code>"last"</code>; it also declares that if the map has an entry with key <code>"middle"</code>, the value of that entry must be a single <code>xs:string</code>. Declaring the type as <code>record(first as xs:string, middle? as xs:string?, last as xs:string<span class="deltaxml-new" style="background:#90EE90">, *</span>)</code> also allows the entry with key <code>"middle"</code> to be present but empty.</span></p><p><span class="deltaxml-old" style="background:#FF5555">A map that contains an entry whose key corresponds to no field in the record type does not match the record type. However, it can be coerced to such a record type when the </span><a title="coercion rules" class="termref" href="#dt-coercion-rules"><span class="deltaxml-old" style="background:#FF5555">coercion rules</span></a><span class="deltaxml-old" style="background:#FF5555"> are applied. In practice this means that when the required type of a parameter is declared using a record type, the map that is supplied as a value for this argument may contain additional fields, which are discarded so they are not available to the called function.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Within an extensible record type, a </span><code><span class="deltaxml-new" style="background:#90EE90">FieldDeclaration</span></code><span class="deltaxml-new" style="background:#90EE90"> that is marked optional and has no declared type does not constrain the map in any way, so it serves no practical purpose, but it is permitted because it may have documentary value.</span></p></div><p>The names of the fields in a record type must be distinct [<a href="#ERRXPST0021" title="err:XPST0021">err:XPST0021</a>].</p><p>If a variable <code>$rec</code> is known to conform to a particular record type, then when a lookup expression <code>$rec?field</code> is used, (a) the processor can report a type error if <code>$rec</code> cannot contain an entry with name <code>field</code> (see <a href="#id-implausible-lookup-expressions"><b>4.14.3.4 Implausible Lookup Expressions</b></a>), and (b) the processor can make static type inferences about the type of value returned by <code>$rec?field</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">(TODO: change function signatures as suggested here!) A number of functions in the standard function library use maps as function arguments; this is a useful technique where the information to be supplied across the interface is highly variable. However, the type signature for such functions typically declares the argument type as <code>map(*)</code>, which gives very little information (and places very few constraints) on the values that are actually passed across. Using record types offers the possibility of improving this: for example, the options argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-parse-json"><code>fn:parse-json</code></a>, previously given as <code>map(*)</code>, can now be expressed as <code>record(liberal? as xs:boolean, duplicates? as xs:string, escape? as xs:boolean, fallback as fn(xs:string) as xs:string)</code>. In principle the <code>xs:string</code> type used to describe the <code>duplicates</code> option could also be replaced by a schema-defined subtype of <code>xs:string</code> that enumerates the permitted values (<code>"reject"</code>, <code>"use-first"</code>, <code>"use-last"</code>). </span><span style="display: none;" class="add_version">(TODO: change function signatures as suggested here!) A number of functions in the standard function library use maps as function arguments; this is a useful technique where the information to be supplied across the interface is highly variable. However, the type signature for such functions typically declares the argument type as <code>map(*)</code>, which gives very little information (and places very few constraints) on the values that are actually passed across. Using record types offers the possibility of improving this: for example, the options argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-parse-json"><code>fn:parse-json</code></a>, previously given as <code>map(*)</code>, can now be expressed as <code>record(liberal? as xs:boolean, duplicates? as xs:string, escape? as xs:boolean, fallback as fn(xs:string) as xs:string, *)</code>. In principle the <code>xs:string</code> type used to describe the <code>duplicates</code> option could also be replaced by a schema-defined subtype of <code>xs:string</code> that enumerates the permitted values (<code>"reject"</code>, <code>"use-first"</code>, <code>"use-last"</code>). </span><span class="modify_version">(TODO: change function signatures as suggested here!) A number of functions in the standard function library use maps as function arguments; this is a useful technique where the information to be supplied across the interface is highly variable. However, the type signature for such functions typically declares the argument type as <code>map(*)</code>, which gives very little information (and places very few constraints) on the values that are actually passed across. Using record types offers the possibility of improving this: for example, the options argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-parse-json"><code>fn:parse-json</code></a>, previously given as <code>map(*)</code>, can now be expressed as <code>record(liberal? as xs:boolean, duplicates? as xs:string, escape? as xs:boolean, fallback as fn(xs:string) as xs:string<span class="deltaxml-new" style="background:#90EE90">, *</span>)</code>. In principle the <code>xs:string</code> type used to describe the <code>duplicates</code> option could also be replaced by a schema-defined subtype of <code>xs:string</code> that enumerates the permitted values (<code>"reject"</code>, <code>"use-first"</code>, <code>"use-last"</code>). </span></p><p>The use of a record type in the signature of such a function causes the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to be invoked. So, for example, if the function expects an entry in the map to be an <code>xs:double</code> value, it becomes possible to supply a map in which the corresponding entry has type <code>xs:integer</code>.</p><p>Greater precision in defining the types of such arguments also enables better type checking, better diagnostics, better optimization, better documentation, and better syntax-directed editing tools.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>One of the motivations for introducing record types is to enable better pattern matching in XSLT when processing JSON input. With XML input, patterns are often based around XML element names. JSON has no direct equivalent of XML’s element names; matching a JSON object such as <code>{longitude: 130.2, latitude: 53.4}</code> relies instead on recognizing the property names appearing in the object. XSLT 4.0, by integrating record types into pattern matching syntax, allows such an object to be matched with a pattern of the form <code>match="record(longitude, latitude)"</code></p></div><p>Rules defining whether one record type is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of another are given in <a href="#id-item-subtype-records"><b>3.3.2.9 Subtyping Records</b></a>.</p></div></div></div><div class="_diffs div2"><h3><a id="id-sequencetype-subtype"></a>3.3 <a href="#id-sequencetype-subtype" style="text-decoration: none">Subtype Relationships</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-item-subtype-documents">next</a> | <a href="#id-generalized-node-types">previous</a>)</p><ol><li><p>The presentation of the rules for the subtype relationship between sequence types and item types has been substantially rewritten to improve clarity; no change to the semantics is intended.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/196">196</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/202">202</a>&nbsp;25 October 2022]</i></p></li></ol></div><p> [<a id="dt-subtype" title="subtype">Definition</a>: Given two <a title="sequence type" class="termref" href="#dt-sequence-type">sequence types</a> or <a title="item type" class="termref" href="#dt-item-type">item types</a>, the rules in this section determine if one is a <b>subtype</b> of the other. If a type <var>A</var> is a subtype of type <var>B</var>, it follows that every value matched by <var>A</var> is also matched by <var>B</var>.] </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The relationship <code>subtype(A, A)</code> is always true: every type is a subtype of itself.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The converse is not necessarily true: we cannot infer that if every value matched by <var>A</var> is also matched by <var>B</var>, then <var>A</var> is a subtype of type <var>B</var>. For example, <var>A</var> might be defined as the set of strings matching the regular expression <code>[A-Z]*</code>, while <var>B</var> is the set of strings matching the regular expression <code>[A-Za-z]*</code>; no subtype relationship holds between these types.</p></div><p>The rules for deciding whether one <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a> is a subtype of another are given in <a href="#id-seqtype-subtype"><b>3.3.1 Subtypes of Sequence Types</b></a>. The rules for deciding whether one <a title="item type" class="termref" href="#dt-item-type">item type</a> is a subtype of another are given in <a href="#id-itemtype-subtype"><b>3.3.2 Subtypes of Item Types</b></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The subtype relationship is not acyclic. There are cases where <code>subtype(A, B)</code> and <code>subtype(B, A)</code> are both true. This implies that <var>A</var> and <var>B</var> have the same value space, but they can still be different types. For example this applies when <var>A</var> is a union type with member types <code>xs:string</code> and <code>xs:integer</code>, while <var>B</var> is a union type with member types <code>xs:integer</code> and <code>xs:string</code>. These are different types (<code>"23" cast as A</code> produces a string, while <code>"23" cast as B</code> produces an integer, because casting is attempted to each member type in order) but both types have the same value space. </p></div><div class="_diffs div3"><h4><a id="id-itemtype-subtype"></a>3.3.2 <a href="#id-itemtype-subtype" style="text-decoration: none">Subtypes of Item Types</a></h4><p>We use the notation <code>A ⊆ B</code>, or <code>itemtype-subtype(A, B)</code> to indicate that an <a title="item type" class="termref" href="#dt-item-type">item type</a><code>A</code> is a <a title="subtype" class="termref" href="#dt-subtype">subtype</a> of an item type <code>B</code>. This section defines the rules for deciding whether any two item types have this relationship.</p><p>The rules in this section apply to <a title="item type" class="termref" href="#dt-item-type">item types</a>, not to <a title="item type designator" class="termref" href="#dt-item-type-designator">item type designators</a>. For example, if the name <code>STR</code> has been defined in the static context as a <a title="named item type" class="termref" href="#dt-named-item-type">named item type</a> referring to the type <code>xs:string</code>, then anything said here about the type <code>xs:string</code> applies equally whether it is designated as <code>xs:string</code> or as <code>STR</code>, or indeed as the parenthesized forms <code>(xs:string)</code> or <code>(STR)</code>.</p><p>References to <a title="named item type" class="termref" href="#dt-named-item-type">named item types</a> are handled as described in <a href="#id-itemtype-subtype-aliases"><b>3.3.2.10 Subtyping of Named Item Types</b></a>.</p><p>The relationship <code>A ⊆ B</code> is true if and only if at least one of the conditions listed in the following subsections applies:</p><div class="_diffs div4"><h5><a id="id-item-subtype-records"></a>3.3.2.9 <a href="#id-item-subtype-records" style="text-decoration: none">Subtyping Records</a></h5><div class="changes"><p class="changesHeading"><span class="deltaxml-old" style="background:#FF5555"> Changes in 4.0 (</span><a href="#id-coercion-rules"><span class="deltaxml-old" style="background:#FF5555">next</span></a><span class="deltaxml-old" style="background:#FF5555"> | </span><a href="#id-item-subtype-attributes"><span class="deltaxml-old" style="background:#FF5555">previous</span></a><span class="deltaxml-old" style="background:#FF5555">)</span></p><ol><li><p><span class="deltaxml-old" style="background:#FF5555"> Extensible map types are dropped; instead, the coercion rules cause undefined map entries to be discarded. </span><i><span class="deltaxml-old" style="background:#FF5555">&nbsp;&nbsp;[Issue </span><a href="https://github.com/qt4cg/qtspecs/issues/2365"><span class="deltaxml-old" style="background:#FF5555">2365</span></a><span class="deltaxml-old" style="background:#FF5555">&nbsp;PR </span><a href="https://github.com/qt4cg/qtspecs/pull/2413"><span class="deltaxml-old" style="background:#FF5555">2413</span></a><span class="deltaxml-old" style="background:#FF5555">&nbsp;28 January 2026]</span></i></p></li></ol></div><p>Given item types <var>A</var> and <var>B</var>, <var>A</var><code>⊆</code><var>B</var> is true if any of the following apply:</p><ol class="enumar"><li class="add_version" style="display: none;"><p><var>A</var> is <code>map(*)</code> and <var>B</var> is <code>record(*)</code>.</p></li><li class="modify_version"><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">map(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">record(*)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p>All of the following are true:</p><ol class="enumla"><li><p><var>A</var> is a record type.</p></li><li><p><span style="display: none;" class="delete_version"><var>B</var> is <code>map(*)</code>.</span><span style="display: none;" class="add_version"><var>B</var> is <code>map(*)</code> or <code>record(*)</code>.</span><span class="modify_version"><var>B</var> is <code>map(*)</code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">record(*)</span></code>.</span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e14124"></a><span class="deltaxml-old" style="background:#FF5555">Example:</span></div><div class="exampleHeader"><a id="d2e14167"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><p><code>record(longitude, latitude)</code> ⊆ <code>map(*)</code></p><p><span style="display: none;" class="delete_version"><code>record(longitude as xs:double, latitude as xs:double)</code> ⊆ <code>map(*)</code></span><span style="display: none;" class="add_version"><code>record(longitude, latitude, *)</code> ⊆ <code>record(*)</code></span><span class="modify_version"><code>record(longitude<span class="deltaxml-old" style="background:#FF5555"> as xs:double</span>, latitude<span class="deltaxml-old" style="background:#FF5555"> as xs:double</span><span class="deltaxml-new" style="background:#90EE90">, *</span>)</code> ⊆ <code><span class="deltaxml-old" style="background:#FF5555">map</span><span class="deltaxml-new" style="background:#90EE90">record</span>(*)</code></span></p><p><span style="display: none;" class="delete_version"><code>record(longitude, latitude, altitude?)</code> ⊆ <code>map(*)</code></span><span style="display: none;" class="add_version"><code>record(*)</code> ⊆ <code>map(*)</code></span><span class="modify_version"><code>record(<span class="deltaxml-old" style="background:#FF5555">longitude, latitude, altitude?</span><span class="deltaxml-new" style="background:#90EE90">*</span>)</code> ⊆ <code>map(*)</code></span></p></div></li><li><p>All of the following are true:</p><ol class="enumla"><li><p><span style="display: none;" class="delete_version"><var>A</var> is a record type</span><span style="display: none;" class="add_version"><var>A</var> is a non-extensible record type</span><span class="modify_version"><var>A</var> is a <span class="deltaxml-new" style="background:#90EE90">non-extensible </span>record type</span></p></li><li><p><var>B</var> is <code>map(<var>K</var>, <var>V</var>)</code></p></li><li><p><var>K</var> is either <code>xs:string</code> or <code>xs:anyAtomicType</code></p></li><li><p>For every field <var>F</var> in <var>A</var>, where <var>T</var> is the declared type of <var>F</var> (or its default, <code>item()*</code>), <code><var>T</var> ⊑ <var>V</var></code>.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e14203"></a><a id="d2e14246"></a>Examples:</div><ul><li><p><code>record(x, y)</code> ⊆ <code>map(xs:string, item()*)</code></p></li><li><p><code>record(x as xs:double, y as xs:double)</code> ⊆ <code>map(xs:string, xs:double)</code></p></li></ul></div></li><li><p>All of the following are true:</p><ol class="enumla"><li><p><span style="display: none;" class="delete_version"><var>A</var> is a record type.</span><span style="display: none;" class="add_version"><var>A</var> is a non-extensible record type.</span><span class="modify_version"><var>A</var> is a <span class="deltaxml-new" style="background:#90EE90">non-extensible </span>record type.</span></p></li><li><p><span style="display: none;" class="delete_version"><var>B</var> is a record type.</span><span style="display: none;" class="add_version"><var>B</var> is a non-extensible record type.</span><span class="modify_version"><var>B</var> is a <span class="deltaxml-new" style="background:#90EE90">non-extensible </span>record type.</span></p></li><li><p>Every field in <var>A</var> is also declared in <var>B</var>.</p></li><li><p>Every mandatory field in <var>B</var> is also declared as mandatory in <var>A</var>.</p></li><li><p>For every field that is declared in both <var>A</var> and <var>B</var>, where the declared type in <var>A</var> is <var>T</var> and the declared type in <var>B</var> is <var>U</var>, <code><var>T</var> ⊑ <var>U</var></code>.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e14274"></a><a id="d2e14317"></a>Examples:</div><ul><li><p><code>record(x, y as xs:integer) ⊆ record(x, y as xs:decimal)</code></p></li><li><p><code>record(x, y) ⊆ record(x, y, z?)</code></p></li></ul></div></li><li class="add_version" style="display: none;"><p>All of the following are true:</p><ol class="enumla"><li><p><var>A</var> is an extensible record type</p></li><li><p><var>B</var> is an extensible record type</p></li><li><p>Every mandatory field in <var>B</var> is also declared as mandatory in <var>A</var>.</p></li><li><p>For every field that is declared in both <var>A</var> and <var>B</var>, where the declared type in <var>A</var> is <var>T</var> and the declared type in <var>B</var> is <var>U</var>, <code><var>T</var> ⊑ <var>U</var></code>.</p></li><li><p>For every field that is declared in <var>B</var> but not in <var>A</var>, the declared type in <var>B</var> is <code>item()*</code>.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e14387"></a>Examples:</div><ul><li><p><code>record(x, y, z, *) ⊆ record(x, y, *)</code></p></li><li><p><code>record(x?, y?, z?, *) ⊆ record(x, y, *)</code></p></li><li><p><code>record(x as xs:integer, y as xs:integer, *) ⊆ record(x as xs:decimal, y as xs:integer*, *)</code></p></li><li><p><code>record(x as xs:integer, *) ⊆ record(x as xs:decimal, y as item(), *)</code></p></li></ul></div></li><li class="modify_version"><p><span class="deltaxml-new" style="background:#90EE90">All of the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is an extensible record type</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is an extensible record type</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Every mandatory field in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is also declared as mandatory in </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For every field that is declared in both </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, where the declared type in </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> and the declared type in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><code><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊑ </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For every field that is declared in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> but not in </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90">, the declared type in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e14387"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(x, y, z, *) ⊆ record(x, y, *)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(x?, y?, z?, *) ⊆ record(x, y, *)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(x as xs:integer, y as xs:integer, *) ⊆ record(x as xs:decimal, y as xs:integer*, *)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(x as xs:integer, *) ⊆ record(x as xs:decimal, y as item(), *)</span></code></p></li></ul></div></li><li class="add_version" style="display: none;"><p>All of the following are true:</p><ol class="enumla"><li><p><var>A</var> is a non-extensible record type.</p></li><li><p><var>B</var> is an extensible record type.</p></li><li><p>Every mandatory field in <var>B</var> is also declared as mandatory in <var>A</var>.</p></li><li><p>For every field that is declared in both <var>A</var> and <var>B</var>, where the declared type in <var>A</var> is <var>T</var> and the declared type in <var>B</var> is <var>U</var>, <code><var>T</var> ⊑ <var>U</var></code>.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e14458"></a>Examples:</div><ul><li><p><code>record(x, y as xs:integer) ⊆ record(x, y as xs:decimal, *)</code></p></li><li><p><code>record(y as xs:integer) ⊆ record(x?, y as xs:decimal, *)</code></p></li></ul></div></li><li class="modify_version"><p><span class="deltaxml-new" style="background:#90EE90">All of the following are true:</span></p><ol class="enumla"><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is a non-extensible record type.</span></p></li><li><p><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is an extensible record type.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Every mandatory field in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is also declared as mandatory in </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">For every field that is declared in both </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90">, where the declared type in </span><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> and the declared type in </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> is </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var><span class="deltaxml-new" style="background:#90EE90">, </span><code><var><span class="deltaxml-new" style="background:#90EE90">T</span></var><span class="deltaxml-new" style="background:#90EE90"> ⊑ </span><var><span class="deltaxml-new" style="background:#90EE90">U</span></var></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="example"><div class="exampleHeader"><a id="d2e14458"></a><span class="deltaxml-new" style="background:#90EE90">Examples:</span></div><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(x, y as xs:integer) ⊆ record(x, y as xs:decimal, *)</span></code></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(y as xs:integer) ⊆ record(x?, y as xs:decimal, *)</span></code></p></li></ul></div></li></ol></div><div class="_diffs div4"><h5><a id="id-itemtype-subtype-aliases"></a>3.3.2.10 <a href="#id-itemtype-subtype-aliases" style="text-decoration: none">Subtyping of Named Item Types</a></h5><p>This section describes how references to <a title="named item type" class="termref" href="#dt-named-item-type">named item types</a> are handled when evaluating the subtype relationship.</p><p>Named item types can be classified as recursive or non-recursive. A recursive type is one that references itself, directly or indirectly. Only named record types are allowed to be recursive.</p><p>In the case of references to non-recursive named item types, the reference is fully expanded as the first step in evaluating the subtype relationship. For example this means that if <var>U</var> is a named item type with the expansion <code>(xs:integer | xs:double)</code>, then <code>xs:integer ⊆ U</code> is true, because <code>xs:integer ⊆ (xs:integer | xs:double)</code> is true.</p><p>Recursive record types are considered to be, in the terminology of the computer science literature, <b>iso-recursive</b> (rather than <b>equi-recursive</b>). This means that a recursive type name is not treated as being equivalent to its expansion (at any depth). For example, if the named item type <var>T</var> has the expansion <code>record(A as item()*, B as T?)</code>, then the type <code>array(T)</code> is not considered to be equivalent to <code>array(record(A as item()*, B as T?))</code>, despite the fact that the two types have exactly the same instances.</p><p>The rules are therefore defined as follows:</p><ul><li><p>If <var>B</var> is a reference to a recursive record type, then <var>A</var> ⊆ <var>B</var> is true if and only if <var>A</var> and <var>B</var> are references to the same named record type.</p></li><li><p><span style="display: none;" class="delete_version">If <var>A</var> is a reference to a recursive named item type, then <var>A</var> ⊆ <var>B</var> is true if and only if <var>A</var> and <var>B</var> are references to the same named record type.</span><span style="display: none;" class="add_version">If <var>A</var> is a reference to a recursive named item type, then <var>A</var> ⊆ <var>B</var> is true if either:</span><span class="modify_version">If <var>A</var> is a reference to a recursive named item type, then <var>A</var> ⊆ <var>B</var> is true if <span class="deltaxml-old" style="background:#FF5555">and only if </span><span class="deltaxml-new" style="background:#90EE90">either</span><span class="deltaxml-old" style="background:#FF5555">A</span><span class="deltaxml-old" style="background:#FF5555"> and </span><span class="deltaxml-old" style="background:#FF5555">B</span><span class="deltaxml-old" style="background:#FF5555"> are references to the same named record type.</span><span class="deltaxml-new" style="background:#90EE90">:</span></span></p><ul><li><p><var><span class="deltaxml-new" style="background:#90EE90">A</span></var><span class="deltaxml-new" style="background:#90EE90"> and </span><var><span class="deltaxml-new" style="background:#90EE90">B</span></var><span class="deltaxml-new" style="background:#90EE90"> are references to the same named record type.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">record(*) ⊆ B</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This is because only record types are allowed to be recursive.</span></p></div></li></ul></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The decision to make recursive types iso-recursive rather than equi-recursive was made largely because it saves a great deal of implementation complexity without any serious adverse effects for users. In practice, problems can be avoided by using named record types consistently (for example, avoiding having two named record types with different names but identical definitions).</p></div></div></div></div><div class="_diffs div2"><h3><a id="id-coercion-rules"></a>3.4 <a href="#id-coercion-rules" style="text-decoration: none">Coercion Rules</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-function-coercion">next</a> | <a href="#id-item-subtype-attributes">previous</a>)</p><ol><li><p> The term "function conversion rules" used in 3.1 has been replaced by the term "coercion rules". <i>&nbsp;&nbsp;[&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/254">254</a>&nbsp;29 November 2022]</i></p></li><li><p> The coercion rules allow “relabeling” of a supplied atomic item where the required type is a derived atomic type: for example, it is now permitted to supply the value 3 when calling a function that expects an instance of <code>xs:positiveInteger</code>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/117">117</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/254">254</a>&nbsp;29 November 2022]</i></p></li><li><p> The coercion rules now allow any numeric type to be implicitly converted to any other, for example an <code>xs:double</code> is accepted where the required type is <code>xs:decimal</code>. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/980">980</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/911">911</a>&nbsp;30 January 2024]</i></p></li><li><p> The coercion rules now allow conversion in either direction between <code>xs:hexBinary</code> and <code>xs:base64Binary</code>. <i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/130">130</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/480">480</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/815">815</a>&nbsp;7 November 2023]</i></p></li><li><p> The coercion rules now apply recursively to the members of an array and the entries in a map. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1318">1318</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1501">1501</a>&nbsp;29 October 2024]</i></p></li><li><p> The coercion rules now reorder the entries in a map when the required type is a record type. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1862">1862</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1874">1874</a>&nbsp;25 March 2025]</i></p></li></ol></div><p> [<a id="dt-coercion-rules" title="coercion rules">Definition</a>: The <b>coercion rules</b> are rules used to convert a supplied value to a required type, for example when converting an argument of a function call to the declared type of the function parameter. ] The required type is expressed as a <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a>. The effect of the coercion rules may be to accept the value as supplied, to convert it to a value that matches the required type, or to reject it with a type error.</p><p>This section defines how the coercion rules operate; the situations in which the rules apply are defined elsewhere, by reference to this section.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In previous versions of this specification, the coercion rules were referred to as the <em>function conversion</em> rules. The terminology has changed because the rules are not exclusively associated with functions or function calling.</p></div><p>If the required type is <code>empty-sequence()</code>, no coercion takes place (the supplied value must be an empty sequence, or a type error occurs).</p><p>In all other cases, the required <a title="sequence type" class="termref" href="#dt-sequence-type">sequence type</a><var>T</var> comprises a required <a title="item type" class="termref" href="#dt-item-type">item type</a><var>R</var> and an optional occurrence indicator. The coercion rules are then applied to a supplied value <var>V</var> and the required type <var>T</var> as follows:</p><ol class="enumar"><li><p>Each item in <var>V</var> is processed against the required item type <var>R</var> using the item coercion rules defined in <a href="#id-item-coercion-rules"><b>3.4.1 Item Coercion Rules</b></a>, and the results are sequence-concatenated into a single sequence <var>V′</var>.</p></li><li><p>A type error is raised if the cardinality of <var>V′</var> does not match the required cardinality of <var>T</var> [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li></ol><div class="_diffs div3"><h4><a id="id-item-coercion-rules"></a>3.4.1 <a href="#id-item-coercion-rules" style="text-decoration: none">Item Coercion Rules</a></h4><p>The rules in this section are used to process each item <var>J</var> in a supplied sequence, given a required <a title="item type" class="termref" href="#dt-item-type">item type</a><var>R</var>.</p><ol class="enumar"><li><p>If <var>R</var> is a <a title="generalized atomic type" class="termref" href="#dt-generalized-atomic-type">generalized atomic type</a> (for example, if it is an <a title="atomic type" class="termref" href="#dt-atomic-type">atomic type</a>, a <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a>, or an <a title="enumeration type" class="termref" href="#dt-enumeration-type">enumeration type</a>), and <var>J</var> is not an atomic item, then: </p><ol class="enumla"><li><p><var>J</var> is <a title="atomization" class="termref" href="#dt-atomization">atomized</a> to produce a sequence of atomic items <var>JJ</var>.</p></li><li><p>Each atomic item in <var>JJ</var> is coerced to the required type <var>R</var> by recursive application of the item coercion rules (the rules in this section) to produce a value <var>V</var>.</p></li><li><p>The result is the <a title="sequence concatenation" class="termref" href="#dt-sequence-concatenation">sequence concatenation</a> of the <var>V</var> values.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, if <code>J</code> is an element with type annotation <code>xs:integer</code>, and <code>R</code> is the union type <code>xs:numeric</code>, then the effect is to atomize the element to an <code>xs:integer</code>, and then to coerce the resulting <code>xs:integer</code> to <code>xs:numeric</code> (which leaves the integer unchanged). This is not the same as attempting to coerce the element to each of the alternatives of the union type in turn, which would deliver an instance of <code>xs:double</code>.</p></div></li><li><p>Otherwise, if <var>R</var> is a <a title="choice item type" class="termref" href="#dt-choice-item-type">choice item type</a> or a <a title="pure union type" class="termref" href="#dt-pure-union-type">pure union type</a> (which includes the case where it is an <a title="enumeration type" class="termref" href="#dt-enumeration-type">enumeration type</a>), then:</p><ol class="enumla"><li><p>If <var>J</var> matches (is an instance of) one of the alternatives in <var>R</var>, then <var>J</var> is coerced to the first alternative in <var>R</var> that <var>J</var> matches.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>There are two situations where coercing an item to a type that it already matches does not simply return the item unchanged:</p><ul><li><p>When the required type is a typed function type (see <a href="#id-function-test"><b>3.2.8.1 Function Types</b></a>), then function coercion is applied to coerce <var>J</var> to that function type, as described in <a href="#id-function-coercion"><b>3.4.3 Function Coercion</b></a>.</p></li><li><p>When the required type is a record type and the supplied value is a map, then coercion may change the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-entry-order">entry order</a><sup><small>DM</small></sup> of the entries in the map.</p></li></ul></div></li><li><p>Otherwise, the item coercion rules (the rules in this section) are applied to <var>J</var> recursively with <var>R</var> set to each of the alternatives in the choice or union item type, in order, until an alternative is found that does not result in a type error; a type error is raised only if all alternatives fail.</p><p>The error code used in the event of failure should be the error code arising from the first unsuccessful matching attempt. (The diagnostic information associated with the error may also describe how further attempts failed.)</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Suppose the required type is <code>(xs:integer | element(e))*</code> and the supplied value is the sequence <code>(&lt;e&gt;22&lt;/e&gt;, 23, &lt;f&gt;24&lt;/f&gt;)</code>. Item coercion is applied independently to each of the three items in this sequence. The first item matches one of the alternatives, namely <code>element(e)</code>, so it is returned unchanged as an element node. The second item (the integer 23) also matches one of the alternatives, and is returned unchanged as an integer. The third item does not match any of the alternatives, so coercion is attempted to each one in turn. Coercion to type <code>xs:integer</code> succeeds (by virtue of atomization and untyped atomic conversion), so the final result is the sequence <code>(&lt;e&gt;22&lt;/e&gt;, 23, 24)</code></p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Suppose the required type is <code>enum("red", "green", "blue")</code> and the supplied value is <code>"green"</code>. The enumeration type is defined as a choice item type whose alternatives are singleton enumerations, so the rules are applied first to the type <code>enum("red")</code> (which fails), and then to the type <code>enum("green")</code> (which succeeds). The strings in an enumeration type are required to be distinct so the order of checking is in this case immaterial. The supplied value will be accepted, and will be relabeled if necessary as an instance of <code>xs:string</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Schema-defined union types behave in exactly the same way as <a title="choice item type" class="termref" href="#dt-choice-item-type">choice item types.</a></p></div></li><li><p>If <var>R</var> is an <a title="atomic type" class="termref" href="#dt-atomic-type">atomic type</a> and <var>J</var> is an <a title="atomic item" class="termref" href="#dt-atomic-item">atomic item</a>, then:</p><ol class="enumla"><li><p>If <var>J</var> is an instance of <var>R</var> then it is used unchanged.</p></li><li><p>If <var>J</var> is an instance of type <code>xs:untypedAtomic</code> then:</p><ol class="enumlr"><li><p>If <var>R</var> is <a title="namespace-sensitive" class="termref" href="#dt-namespace-sensitive">namespace-sensitive</a> then a <a title="type error" class="termref" href="#dt-type-error">type error</a> [<a href="#ERRXPTY0117" title="err:XPTY0117">err:XPTY0117</a>] is raised.</p></li><li><p>Otherwise, <var>J</var> is cast to type <var>R</var>.</p></li></ol></li></ol></li><li><p>If there is an entry (<var>from</var>, <var>to</var>) in the following table such that <var>J</var> is an instance of <var>from</var>, and <var>to</var> is <var>R</var>, then <var>J</var> is cast to type <var>R</var>.</p><table style="border:1px solid" class="medium"><caption>Implicit Casting</caption><thead><tr><th>from</th><th>to</th></tr></thead><tbody><tr><td><code>xs:decimal</code></td><td><code>xs:double</code></td></tr><tr><td><code>xs:double</code></td><td><code>xs:decimal</code></td></tr><tr><td><code>xs:decimal</code></td><td><code>xs:float</code></td></tr><tr><td><code>xs:float</code></td><td><code>xs:decimal</code></td></tr><tr><td><code>xs:float</code></td><td><code>xs:double</code></td></tr><tr><td><code>xs:double</code></td><td><code>xs:float</code></td></tr><tr><td><code>xs:string</code></td><td><code>xs:anyURI</code></td></tr><tr><td><code>xs:anyURI</code></td><td><code>xs:string</code></td></tr><tr><td><code>xs:hexBinary</code></td><td><code>xs:base64Binary</code></td></tr><tr><td><code>xs:base64Binary</code></td><td><code>xs:hexBinary</code></td></tr></tbody></table><div class="note"><p class="prefix"><b>Note:</b></p><p>The item type in the <var>to</var> column must match <var>R</var> exactly; however, <var>J</var> may belong to a subtype of the type in the <var>from</var> column.</p><p>For example, an <code>xs:NCName</code> will be cast to type <code>xs:anyURI</code>, but an <code>xs:anyURI</code> will not be cast to type <code>xs:NCName</code>.</p><p>Similarly, an <code>xs:integer</code> will be cast to type <code>xs:double</code>, but an <code>xs:double</code> will not be cast to type <code>xs:integer</code>.</p></div></li><li><p>If <var>R</var> is an <a title="singleton enumeration type" class="termref" href="#dt-singleton-enumeration-type">singleton enumeration type</a> and <var>J</var> is an instance of <code>xs:untypedAtomic</code> or <code>xs:anyURI</code>, then <var>J</var> is cast to type <code>xs:string</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of this rule, when taken in conjunction with the rules above regarding atomization and choice item types, is that when the required type is based on an <a title="enumeration type" class="termref" href="#dt-enumeration-type">enumeration type</a>, for example <code>enum("red", "green", "blue")*</code>, the supplied value can be, in this example:</p><ul><li><p>An empty sequence.</p></li><li><p>The string <code>"red"</code>.</p></li><li><p>An untyped node whose string value is <code>"red"</code>.</p></li><li><p>A list-valued node whose typed value contains zero or more strings (or <code>xs:anyURI</code> values), each of which is codepoint-equal to one of <code>"red"</code>, <code>"green"</code>, or <code>"blue"</code>.</p></li><li><p>The <code>xs:anyURI</code> value <code>"red"</code>.</p></li><li><p>An array with zero or more members each of which is codepoint-equal to one of <code>"red"</code>, <code>"green"</code>, or <code>"blue"</code>.</p></li><li><p>A JNode whose <b>·content·</b> property is any of the above.</p></li></ul></div></li><li><p>If <var>R</var> is derived from some primitive atomic type <var>P</var>, then <var>J</var> is <b>relabeled</b> as an instance of <var>R</var> if it satisfies all the following conditions:</p><ul><li><p><var>J</var> is an instance of <var>P</var>.</p></li><li><p><var>J</var> is not an instance of <var>R</var>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-datum">datum</a><sup><small>DM</small></sup> of <var>J</var> is within the value space of <var>R</var>.</p></li></ul><p>Relabeling an atomic item changes the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> but not the <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-datum">datum</a><sup><small>DM</small></sup>. For example, the <code>xs:integer</code> value 3 can be relabeled as an instance of <code>xs:unsignedByte</code>, because the datum is within the value space of <code>xs:unsignedByte</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Relabeling is not the same as casting. For example, the <code>xs:decimal</code> value 10.1 can be cast to <code>xs:integer</code>, but it cannot be relabeled as <code>xs:integer</code>, because its datum not within the value space of <code>xs:integer</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of this rule is that if, for example, a function parameter is declared with an expected type of <code>xs:positiveInteger</code>, then a call that supplies the literal value 3 will succeed, whereas a call that supplies -3 will fail.</p><p>This differs from previous versions of this specification, where both these calls would fail.</p><p>This change allows the arguments of existing functions to be defined with a more precise type. For example, the <code>$position</code> argument of <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-get"><code>array:get</code></a> could be defined as <code>xs:positiveInteger</code> rather than <code>xs:integer</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>If <var>T</var> is a union type with members <code>xs:negativeInteger</code> and <code>xs:positiveInteger</code> and the supplied value is the sequence <code>(20, -20)</code>, then the effect of these rules is that the first item <code>20</code> is relabeled as type <code>xs:positiveInteger</code> and the second item <code>-20</code>is relabeled as type <code>xs:negativeInteger</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Promotion (for example of <code>xs:float</code> to <code>xs:double</code>) occurs only when <var>T</var> is a primitive type. Relabeling occurs only when <var>T</var> is a derived type. Promotion and relabeling are therefore never combined.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>A <a title="singleton enumeration type" class="termref" href="#dt-singleton-enumeration-type">singleton enumeration type</a> such as <code>enum("green")</code> is treated as an atomic type derived by restriction from <code>xs:string</code>; so if the <code>xs:string</code> value <code>"green"</code> is supplied in a context where the required type is <code>enum("red", "green", "blue")</code>, the value will be accepted.</p></div></li><li><p>If <var>J</var> is a <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-JNode">JNode</a><sup><small>DM</small></sup> and does not match <var>R</var>, then each item in the <b>·content·</b> of <var>J</var> is coerced to type <var>R</var> by applying the coercion rules recursively.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, if <code>$A</code> is an array and the members of the array are maps, then <code>$A/child::*</code> returns a sequence of JNodes that encapsulate maps, and the average size of these maps can be obtained using the expression <code>avg($A/child::* ! map:size(.))</code>. The first argument of <code>map:size</code> does not accept a JNode directly, but it does (in effect) accept a JNode that encapsulates a map.</p></div></li><li><p>If <var>R</var> is an <a href="#doc-xquery40-ArrayType">ArrayType</a> other than <code>array(*)</code> and <var>J</var> is an array, then <var>J</var> is converted to a new array by converting each member to the required member type by applying the coercion rules recursively.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, if the required type is <code>array(xs:double)</code> and the supplied value is <code>[ 1, 2 ]</code>, the array is converted to <code>[ 1e0, 2e0 ]</code>.</p></div></li><li><p>If <var>R</var> is a <a href="#doc-xquery40-MapType">MapType</a> other than <code>map(*)</code> and <var>J</var> is a map, then <var>J</var> is converted to a new map as follows:</p><ol class="enumla"><li><p>Each key in the supplied map is converted to the required map key type by applying the coercion rules. If the resulting map would contain duplicate keys, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p></li><li><p>The corresponding value is converted to the required map value type by applying the coercion rules recursively.</p></li><li><p>The order of entries in the map remains unchanged.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, if the required type is <code>map(xs:string, xs:double)</code> and the supplied value is <code>{ "x": 1, "y": 2 }</code>, the map is converted to <code>{ "x": 1e0, "y": 2e0 }</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Duplicate keys can occur if the value space of the target type is more restrictive than the original type. For example, an error is raised if the map <code>{ 1.2: 0, 1.2000001: 0 }</code>, which contains two keys of type <code>xs:decimal</code>, is coerced to the type <code>map(xs:float, xs:integer)</code>.</p></div></li><li><p>If <var>R</var> is a <a href="#doc-xquery40-RecordType">RecordType</a> and <var>J</var> is a map, then <var>J</var> is converted to a new map as follows:</p><ol class="enumla"><li><p>The keys in the supplied map are unchanged.</p></li><li><p>In any map entry whose key is equal to the name of one of the field declarations in <var>R</var> (under the rules of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-atomic-equal"><code>atomic-equal</code></a> function), the corresponding value is converted to the required type defined by that field declaration, by applying the coercion rules recursively (but with XPath 1.0 compatibility mode treated as false).</p></li><li class="delete_version" style="display: none;"><p>Any map entry in the supplied map whose key is not equal to the name of any of the field declarations in <var>R</var> (under the same rules) is removed from the map.</p></li><li class="modify_version"><p><span class="deltaxml-old" style="background:#FF5555">Any map entry in the supplied map whose key is not equal to the name of any of the field declarations in </span><var><span class="deltaxml-old" style="background:#FF5555">R</span></var><span class="deltaxml-old" style="background:#FF5555"> (under the same rules) is removed from the map.</span></p></li><li><p><span class="deltaxml-old" style="background:#FF5555">The order of entries in the map is changed to match the order of the field declarations in </span><var><span class="deltaxml-old" style="background:#FF5555">R</span></var><span class="deltaxml-old" style="background:#FF5555">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The order of entries in the map is changed: entries whose keys correspond to the names of field declarations in </span><var><span class="deltaxml-new" style="background:#90EE90">R</span></var><span class="deltaxml-new" style="background:#90EE90"> appear first, in the order of the corresponding field declarations, and (if the record type is extensible) other entries then follow retaining their relative order in </span><var><span class="deltaxml-new" style="background:#90EE90">J</span></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">For example, if the required type is <code>record(longitude as xs:double, latitude as xs:double)</code> and the supplied value is <code>{ "latitude": 53.2, "longitude": 0, "altitude": 3_500 }</code>, then the map is converted to <code>{ "longitude": 0.0e0, "latitude": 53.2e0 }</code>.</span><span style="display: none;" class="add_version">For example, if the required type is <code>record(longitude as xs:double, latitude as xs:double)</code> and the supplied value is <code>{ "latitude": 53.2, "longitude": 0 }</code>, then the map is converted to <code>{ "longitude": 0.0e0, "latitude": 53.2e0 }</code>.</span><span class="modify_version">For example, if the required type is <code>record(longitude as xs:double, latitude as xs:double)</code> and the supplied value is <code>{ "latitude": 53.2, "longitude": 0<span class="deltaxml-old" style="background:#FF5555">, "altitude": 3_500</span> }</code>, then the map is converted to <code>{ "longitude": 0.0e0, "latitude": 53.2e0 }</code>.</span></p></div></li><li><p>If <var>R</var> is a <a href="#prod-xquery40-TypedFunctionType">TypedFunctionType</a> and <var>J</var> is a function item, then <a title="function coercion" class="termref" href="#dt-function-coercion">function coercion</a> is applied to <var>J</var>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Function coercion applies even if <var>J</var> is already an instance of <var>R</var>.</p><p>Maps and arrays are functions, so function coercion applies to them as well.</p></div></li><li><p> If, after the above conversions, the resulting item does not match the expected item type <var>R</var> according to the rules for <a title="SequenceType matching" class="termref" href="#dt-sequencetype-matching">SequenceType Matching</a>, a type error is raised [<a href="#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>].</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Under the general rules for type errors (see <a href="#id-kinds-of-errors"><b>2.5.1 Kinds of Errors</b></a>), a processor <span class="verb">may</span> report a type error during static analysis if it will necessarily occur when the expression is evaluated. For example, the function call <code>fn:abs("beer")</code> will necessarily fail when evaluated, because the function requires a numeric value as its argument; this <span class="verb">may</span> be detected and reported as a static error.</p></div></li></ol></div></div></div></div><div class="back"><div class="_diffs div1"><h2><a id="id-revision-log"></a>J <a href="#id-revision-log" style="text-decoration: none">Change Log</a> (Non-Normative)</h2><ol><li><p>If a section of this specification has been updated since version 3.1, an overview of the changes is provided, along with links to navigate to the next or previous change.</p><p>See <a href="#id-introduction"><b>1 Introduction</b></a></p></li><li><p>Sections with significant changes are marked with a ✭ symbol in the table of contents.</p><p>See <a href="#id-introduction"><b>1 Introduction</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/691 2154">691 2154&nbsp;</a></p><p>Enumeration types are added as a new kind of <code>ItemType</code>, constraining the value space of strings.</p><p>See <a href="#id-enumeration-types"><b>3.2.6 Enumeration Types</b></a></p></li><li><p> Setting the default namespace for elements and types to the special value <code>##any</code> causes an unprefixed element name to act as a wildcard, matching by local name regardless of namespace. </p><p>See <a href="#id-element-test"><b>3.2.7.2 Element Types</b></a></p></li><li><p>The terms <b>FunctionType</b>, <b>ArrayType</b>, <b>MapType</b>, and <b>RecordType</b> replace <b>FunctionTest</b>, <b>ArrayTest</b>, <b>MapTest</b>, and <b>RecordTest</b>, with no change in meaning.</p><p>See <a href="#id-function-test"><b>3.2.8.1 Function Types</b></a></p></li><li><p> Record types are added as a new kind of <code>ItemType</code>, constraining the value space of maps. </p><p>See <a href="#id-record-test"><b>3.2.8.3 Record Types</b></a></p></li><li><p> Function coercion now allows a function with arity <var>N</var> to be supplied where a function of arity greater than <var>N</var> is expected. For example this allows the function <code>true#0</code> to be supplied where a predicate function is required. </p><p>See <a href="#id-function-coercion"><b>3.4.3 Function Coercion</b></a></p></li><li><p> The symbols <code>×</code> and <code>÷</code> can be used for multiplication and division. </p><p>See <a href="#id-arithmetic"><b>4.8 Arithmetic Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1480 1989">1480 1989&nbsp;</a></p><p> When the element name matches a language keyword such as <code>div</code> or <code>value</code>, it must now be written as a QName literal. This is a backwards incompatible change. </p><p>See <a href="#id-computedElements"><b>4.12.3.1 Computed Element Constructors</b></a></p><p> When the attribute name matches a language keyword such as <code>by</code> or <code>of</code>, it must now be written as a QName literal. This is a backwards incompatible change. </p><p>See <a href="#id-computedAttributes"><b>4.12.3.2 Computed Attribute Constructors</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1513 2028">1513 2028&nbsp;</a></p><p> When the processing instruction name matches a language keyword such as <code>try</code> or <code>validate</code>, it must now be written with a preceding <code>#</code> character. This is a backwards incompatible change. </p><p>See <a href="#id-computed-pis"><b>4.12.3.5 Computed Processing Instruction Constructors</b></a></p><p> When the namespace prefix matches a language keyword such as <code>as</code> or <code>at</code>, it must now be written with a preceding <code>#</code> character. This is a backwards incompatible change. </p><p>See <a href="#id-computed-namespaces"><b>4.12.3.7 Computed Namespace Constructors</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1763 1830">1763 1830&nbsp;</a></p><p>The syntax on the right-hand side of an arrow operator has been relaxed; a dynamic function call no longer needs to start with a variable reference or a parenthesized expression, it can also be (for example) an inline function expression or a map or array constructor.</p><p>See <a href="#id-arrow-operator"><b>4.24 Arrow Expressions</b></a></p></li><li><p> The arrow operator <code>=&gt;</code> is now complemented by a “mapping arrow” operator <code>=!&gt;</code> which applies the supplied function to each item in the input sequence independently. </p><p>See <a href="#id-mapping-arrow-expression"><b>4.24.2 Mapping Arrow Expressions</b></a></p></li><li><p> All implementations must now predeclare the namespace prefixes <code>math</code>, <code>map</code>, <code>array</code>, and <code>err</code>. In XQuery 3.1 it was permitted but not required to predeclare these namespaces. </p><p>See <a href="#id-namespace-declaration"><b>5.13 Namespace Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2200 2236">2200 2236&nbsp;</a></p><p> The effect of not declaring a default function namespace has changed: user-defined functions can now be in no namespace, and a search for an unprefixed function name will be resolved first against functions in no namespace, and only then against functions in the standard function namespace. </p><p>See <a href="#id-default-namespace"><b>5.14 Default Namespace Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/254 2050">254 2050&nbsp;</a></p><p> The supplied context value is now coerced to the required type specified in the main module using the coercion rules. </p><p>See <a href="#id-context-value-declarations"><b>5.17 Context Value Declaration</b></a></p></li><li><p> Function definitions in the static context may now have optional parameters, provided this does not cause ambiguity across multiple function definitions with the same name. Optional parameters are given a default value, which can be any expression, including one that depends on the context of the caller (so an argument can default to the context value). </p><p>See <a href="#FunctionDeclns"><b>5.18 Function Declarations</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/682 TODO">682 TODO&nbsp;</a></p><p> The values <code>true()</code> and <code>false()</code> are allowed in function annotations, as well as negated numeric literals and QName literals. </p><p>See <a href="#id-function-annotations"><b>5.18.4 Function Annotations</b></a></p></li><li><p> A user-defined function whose name is given as an unprefixed QName is now in no namespace. In previous versions of the language, it represented a name in the <a title="default function namespace" class="termref" href="#dt-default-function-namespace">default function namespace</a> (which only worked if the <a title="default function namespace" class="termref" href="#dt-default-function-namespace">default function namespace</a> was explicitly set to an unreserved namespace, which was rarely done because it caused other problems). </p><p>See <a href="#FunctionDeclns"><b>5.18 Function Declarations</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1023 1128">1023 1128&nbsp;</a></p><p> It has been clarified that function coercion applies even when the supplied function item matches the required function type. This is to ensure that arguments supplied when calling the function are checked against the signature of the required function type, which might be stricter than the signature of the supplied function item. </p><p>See <a href="#id-function-coercion"><b>3.4.3 Function Coercion</b></a></p></li><li><p>A dynamic function call can now be applied to a sequence of functions, and in particular to an empty sequence. This makes it easier to chain a sequence of calls.</p><p>See <a href="#id-eval-dynamic-function-call"><b>4.5.3.1 Evaluating Dynamic Function Calls</b></a></p></li><li><p> Parts of the static context that were there purely to assist in static typing, such as the statically known documents, were no longer referenced and have therefore been dropped. </p><p>See <a href="#id-xq-static-context-components"><b>B.1 Static Context Components</b></a></p></li><li><p> The syntax <code>document-node(<var>N</var>)</code>, where <var>N</var> is a <code>NameTestUnion</code>, is introduced as an abbreviation for <code>document-node(element(<var>N</var>))</code>. For example, <code>document-node(*)</code> matches any well-formed XML document (as distinct from a document fragment). </p><p>See <a href="#node-types"><b>3.2.7 Node Types</b></a></p></li><li><p>QName literals are new in 4.0.</p><p>See <a href="#id-qname-literals"><b>4.2.1.3 QName Literals</b></a></p></li><li><p> Path expressions are extended to handle JNodes (found in trees of maps and arrays) as well as XNodes (found in trees representing parsed XML). </p><p>See <a href="#id-path-expressions"><b>4.6 Path Expressions</b></a></p></li><li><p>A method call invokes a function held as the value of an entry in a map, supplying the map implicitly as the value of the first argument.</p><p>See <a href="#id-methods"><b>4.14.4 Method Calls</b></a></p></li><li><p>The <code>treat as</code> expression now raises a type error rather than a dynamic error when it fails.</p><p>See <a href="#id-treat"><b>4.21.6 Treat</b></a></p></li><li><p> The group is considering removing or substantially changing this feature, it is considered <a href="#at-risk">at risk</a>. </p><p>See <a href="#id-filter-maps-and-arrays"><b>4.14.5 Filter Expressions for Maps and Arrays</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/159">159&nbsp;</a></p><p> Keyword arguments are allowed on static function calls, as well as positional arguments. </p><p>See <a href="#id-function-calls"><b>4.5.1.1 Static Function Call Syntax</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/202">202&nbsp;</a></p><p>The presentation of the rules for the subtype relationship between sequence types and item types has been substantially rewritten to improve clarity; no change to the semantics is intended.</p><p>See <a href="#id-sequencetype-subtype"><b>3.3 Subtype Relationships</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/230">230&nbsp;</a></p><p> The rules for “errors and optimization” have been tightened up to disallow many cases of optimizations that alter error behavior. In particular there are restrictions on reordering the operands of <code>and</code> and <code>or</code>, and of predicates in filter expressions, in a way that might allow the processor to raise dynamic errors that the author intended to prevent. </p><p>See <a href="#id-guarded-expressions"><b>2.5.5 Guarded Expressions</b></a></p><p>See <a href="#id-logical-expressions"><b>4.11 Logical Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/254">254&nbsp;</a></p><p> The term "function conversion rules" used in 3.1 has been replaced by the term "coercion rules". </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p><p> The coercion rules allow “relabeling” of a supplied atomic item where the required type is a derived atomic type: for example, it is now permitted to supply the value 3 when calling a function that expects an instance of <code>xs:positiveInteger</code>. </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p><p> The value bound to a variable in a <code>let</code> clause is now converted to the declared type by applying the coercion rules. </p><p>See <a href="#id-xquery-let-clause"><b>4.13.3 Let Clause</b></a></p><p> The coercion rules are now used when binding values to variables (both global variable declarations and local variable bindings). This aligns XQuery with XSLT, and means that the rules for binding to variables are the same as the rules for binding to function parameters. </p><p>See <a href="#id-variable-declarations"><b>5.16 Variable Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/284">284&nbsp;</a></p><p> Alternative syntax for conditional expressions is available: <code>if (condition) { X }</code>. </p><p>See <a href="#id-conditionals"><b>4.16 Conditional Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/286">286&nbsp;</a></p><p> Element and attribute tests can include alternative names: <code>element(chapter|section)</code>, <code>attribute(role|class)</code>. </p><p>See <a href="#node-types"><b>3.2.7 Node Types</b></a></p><p> The <code>NodeTest</code> in an <code>AxisStep</code> now allows alternatives: <code>ancestor::(section|appendix)</code></p><p>See <a href="#node-types"><b>3.2.7 Node Types</b></a></p><p> Element and attribute tests of the form <code>element(N)</code> and <code>attribute(N)</code> now allow <code>N</code> to be any <code>NameTest</code>, including a wildcard. </p><p>See <a href="#id-element-test"><b>3.2.7.2 Element Types</b></a></p><p>See <a href="#id-attribute-test"><b>3.2.7.3 Attribute Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/324">324&nbsp;</a></p><p> String templates provide a new way of constructing strings: for example <code>`{$greeting}, {$planet}!`</code> is equivalent to <code>$greeting || ', ' || $planet || '!'</code></p><p>See <a href="#id-string-templates"><b>4.9.2 String Templates</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/326">326&nbsp;</a></p><p> Support for higher-order functions is now a mandatory feature (in 3.1 it was optional). </p><p>See <a href="#id-conformance"><b>6 Conformance</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/344">344&nbsp;</a></p><p>A <code>for member</code> clause is added to FLWOR expressions to allow iteration over an array. </p><p>See <a href="#id-xquery-for-clause"><b>4.13.2 For Clause</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/364">364&nbsp;</a></p><p> Switch expressions now allow a <code>case</code> clause to match multiple atomic items. </p><p>See <a href="#id-switch"><b>4.18 Switch Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/368">368&nbsp;</a></p><p> The concept of the context item has been generalized, so it is now a context value. That is, it is no longer constrained to be a single item. </p><p>See <a href="#eval_context"><b>2.2.2 Dynamic Context</b></a></p><p>See <a href="#id-context-value-declarations"><b>5.17 Context Value Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/433">433&nbsp;</a></p><p> Numeric literals can now be written in hexadecimal or binary notation; and underscores can be included for readability. </p><p>See <a href="#id-numeric-literals"><b>4.2.1.1 Numeric Literals</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/483">483&nbsp;</a></p><p> The <code>start</code> clause in window expressions has become optional, as well as the <code>when</code> keyword and its associated expression. </p><p>See <a href="#id-windows"><b>4.13.4 Window Clause</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/487">487&nbsp;</a></p><p>In XQuery 4.0, an initial set of namespace bindings is prescribed for the static context.</p><p>See <a href="#id-namespaces-and-qnames"><b>2.1.4 Namespaces and QNames</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/493">493&nbsp;</a></p><p> A new variable <code>$err:map</code> is available, capturing all error information in one place. </p><p>See <a href="#id-try-catch"><b>4.20 Try/Catch Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/519">519&nbsp;</a></p><p> The rules for tokenization have been largely rewritten. In some cases the revised specification may affect edge cases that were handled in different ways by different 3.1 processors, which could lead to incompatible behavior. </p><p>See <a href="#lexical-structure"><b>A.3 Lexical structure</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/521">521&nbsp;</a></p><p>New abbreviated syntax is introduced (<a title="focus function" class="termref" href="#dt-focus-function">focus function</a>) for simple inline functions taking a single argument. An example is <code>fn { ../@code }</code></p><p>See <a href="#id-inline-func"><b>4.5.6 Inline Function Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/587">587&nbsp;</a></p><p> Switch and typeswitch expressions can now be written with curly brackets, to improve readability. </p><p>See <a href="#id-switch"><b>4.18 Switch Expressions</b></a></p><p>See <a href="#id-typeswitch"><b>4.21.2 Typeswitch</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/603">603&nbsp;</a></p><p> The rules for reporting type errors during static analysis have been changed so that a processor has more freedom to report errors in respect of constructs that are evidently wrong, such as <code>@price/@value</code>, even though dynamic evaluation is defined to return an empty sequence rather than an error. </p><p>See <a href="#id-implausible-expressions"><b>2.5.6 Implausible Expressions</b></a></p><p>See <a href="#implausible-axis-steps"><b>4.6.5.6 Implausible Axis Steps</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/606">606&nbsp;</a></p><p> Element and attribute tests of the form <code>element(A|B)</code> and <code>attribute(A|B)</code> are now allowed. </p><p>See <a href="#id-element-test"><b>3.2.7.2 Element Types</b></a></p><p>See <a href="#id-attribute-test"><b>3.2.7.3 Attribute Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/635">635&nbsp;</a></p><p>The rules for the consistency of schemas imported by different query modules, and for consistency between imported schemas and those used for validating input documents, have been defined with greater precision. It is now recognized that these schemas will not always be identical, and that validation with respect to different schemas may produce different outcomes, even if the components of one are a subset of the components of the other.</p><p>See <a href="#id-schema-import"><b>5.11 Schema Import</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/659">659&nbsp;</a></p><p>In previous versions the interpretation of location hints in <code>import schema</code> declarations was entirely at the discretion of the processor. To improve interoperability, XQuery 4.0 recommends (but does not mandate) a specific strategy for interpreting these hints.</p><p>See <a href="#id-schema-import"><b>5.11 Schema Import</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/678">678&nbsp;</a></p><p> The comparand expression in a switch expression can be omitted, allowing the switch cases to be provided as arbitrary boolean expressions. </p><p>See <a href="#id-switch"><b>4.18 Switch Expressions</b></a></p></li><li class="add_version" style="display: none;"><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/728">728&nbsp;</a></p><p> The syntax <code>record(*)</code> is allowed; it matches any map. </p><p>See <a href="#id-record-test"><b>3.2.8.3 Record Types</b></a></p></li><li class="modify_version"><p><span class="deltaxml-new" style="background:#90EE90">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/728"><span class="deltaxml-new" style="background:#90EE90">728&nbsp;</span></a></p><p><span class="deltaxml-new" style="background:#90EE90"> The syntax </span><code><span class="deltaxml-new" style="background:#90EE90">record(*)</span></code><span class="deltaxml-new" style="background:#90EE90"> is allowed; it matches any map. </span></p><p><span class="deltaxml-new" style="background:#90EE90">See </span><a href="#id-record-test"><b><span class="deltaxml-new" style="background:#90EE90">3.2.8.3 Record Types</span></b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/753">753&nbsp;</a></p><p> The <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a> can now be declared to be fixed for a query module, meaning it is unaffected by a namespace declaration appearing on a direct element constructor. </p><p>See <a href="#id-namespaces"><b>4.12.1.2 Namespace Declaration Attributes</b></a></p><p>See <a href="#id-default-namespace"><b>5.14 Default Namespace Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/815">815&nbsp;</a></p><p> The coercion rules now allow conversion in either direction between <code>xs:hexBinary</code> and <code>xs:base64Binary</code>. </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/820">820&nbsp;</a></p><p> The value bound to a variable in a <code>for</code> clause is now converted to the declared type by applying the coercion rules. </p><p>See <a href="#id-xquery-for-clause"><b>4.13.2 For Clause</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/911">911&nbsp;</a></p><p> The coercion rules now allow any numeric type to be implicitly converted to any other, for example an <code>xs:double</code> is accepted where the required type is <code>xs:decimal</code>. </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/943">943&nbsp;</a></p><p> A FLWOR expression may now include a <code>while</code> clause, which causes early exit from the iteration when a condition is encountered. </p><p>See <a href="#id-while"><b>4.13.6 While Clause</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/996">996&nbsp;</a></p><p> The value of a predicate in a filter expression can now be a sequence of integers. </p><p>See <a href="#id-filter-expression"><b>4.4 Filter Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1031">1031&nbsp;</a></p><p> An <code>otherwise</code> operator is introduced: <code>A otherwise B</code> returns the value of <code>A</code>, unless it is an empty sequence, in which case it returns the value of <code>B</code>. </p><p>See <a href="#id-otherwise"><b>4.17 Otherwise Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1071">1071&nbsp;</a></p><p> In map constructors, the keyword <code>map</code> is now optional, so <code>map { 0: false(), 1: true() }</code> can now be written <code>{ 0: false(), 1: true() }</code>, provided it is used in a context where this creates no ambiguity. </p><p>See <a href="#id-map-constructors"><b>4.14.1.1 Map Constructors</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1132">1132&nbsp;</a></p><p> Choice item types (an item type allowing a set of alternative item types) are introduced. </p><p>See <a href="#id-choice-item-types"><b>3.2.5 Choice Item Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1163">1163&nbsp;</a></p><p> Filter expressions for maps and arrays are introduced. </p><p>See <a href="#id-filter-maps-and-arrays"><b>4.14.5 Filter Expressions for Maps and Arrays</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1181">1181&nbsp;</a></p><p> The <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a> can be set to the value <code>##any</code>, allowing unprefixed names in axis steps to match elements with a given local name in any namespace. </p><p>See <a href="#static_context"><b>2.2.1 Static Context</b></a></p><p> If the default namespace for elements and types has the special value <code>##any</code>, then an unprefixed name in a <code>NameTest</code> acts as a wildcard, matching names in any namespace or none. </p><p>See <a href="#node-tests"><b>4.6.5.2 Node Tests</b></a></p><p> The <a title="default namespace for elements and types" class="termref" href="#dt-default-namespace-elements-and-types">default namespace for elements and types</a> can be set to the value <code>##any</code>, allowing unprefixed names in axis steps to match elements with a given local name in any namespace. </p><p>See <a href="#id-default-namespace"><b>5.14 Default Namespace Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1197">1197&nbsp;</a></p><p>The keyword <code>fn</code> is allowed as a synonym for <code>function</code> in function types, to align with changes to inline function declarations.</p><p>See <a href="#id-function-test"><b>3.2.8.1 Function Types</b></a></p><p> In inline function expressions, the keyword <code>function</code> may be abbreviated as <code>fn</code>. </p><p>See <a href="#id-inline-func"><b>4.5.6 Inline Function Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1212">1212&nbsp;</a></p><p> New keywords introducing item types, such as <code>record</code>, <code>item</code>, and <code>enum</code>, have been added to the list of reserved function names. </p><p>See <a href="#id-reserved-fn-names"><b>A.4 Reserved Function Names</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1217">1217&nbsp;</a></p><p> Predicates in filter expressions for maps and arrays can now be numeric. </p><p>See <a href="#id-filter-maps-and-arrays"><b>4.14.5 Filter Expressions for Maps and Arrays</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1249">1249&nbsp;</a></p><p>A <code>for key/value</code> clause is added to FLWOR expressions to allow iteration over a map. </p><p>See <a href="#id-xquery-for-clause"><b>4.13.2 For Clause</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1250">1250&nbsp;</a></p><p> Several decimal format properties, including minus sign, exponent separator, percent, and per-mille, can now be rendered as arbitrary strings rather than being confined to a single character. </p><p>See <a href="#id-decimal-formats"><b>2.2.1.2 Decimal Formats</b></a></p><p>See <a href="#id-decimal-format-decl"><b>5.10 Decimal Format Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1254">1254&nbsp;</a></p><p> The rules concerning the interpretation of <code>xsi:schemaLocation</code> and <code>xsi:noNamespaceSchemaLocation</code> attributes have been tightened up. </p><p>See <a href="#id-validate"><b>4.25 Validate Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1265">1265&nbsp;</a></p><p> The rules regarding the <code>document-uri</code> property of nodes returned by the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>fn:collection</code></a> function have been relaxed. </p><p>See <a href="#eval_context"><b>2.2.2 Dynamic Context</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1342">1342&nbsp;</a></p><p> The <code>ordered { E }</code> and <code>unordered { E }</code> expressions are retained for backwards compatibility reasons, but in XQuery 4.0 they are deprecated and have no useful effect. </p><p>See <a href="#id-unordered-expressions"><b>4.15 Ordered and Unordered Expressions</b></a></p><p> The ordering mode declaration is retained for backwards compatibility reasons, but in XQuery 4.0 it is deprecated and has no useful effect. </p><p>See <a href="#id-default-ordering-decl"><b>5.7 Ordering Mode Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1344">1344&nbsp;</a></p><p> Parts of the static context that were there purely to assist in static typing, such as the statically known documents, were no longer referenced and have therefore been dropped. </p><p>See <a href="#static_context"><b>2.2.1 Static Context</b></a></p><p> The static typing option has been dropped. </p><p>See <a href="#id-processing-model"><b>2.4 Processing Model</b></a></p><p> The static typing feature has been dropped. </p><p>See <a href="#id-conformance"><b>6 Conformance</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1361">1361&nbsp;</a></p><p> The term <b>atomic value</b> has been replaced by <a title="atomic item" class="termref" href="#dt-atomic-item">atomic item</a>. </p><p>See <a href="#id-values"><b>2.1.3 Values</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1384">1384&nbsp;</a></p><p> If a type declaration is present, the supplied values in the input sequence are now coerced to the required type. Type declarations are now permitted in XPath as well as XQuery. </p><p>See <a href="#id-quantified-expressions"><b>4.19 Quantified Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1432">1432&nbsp;</a></p><p> In earlier versions, the static context for the <a title="initializing expression" class="termref" href="#dt-initializing-expression">initializing expression</a> excluded the variable being declared. This restriction has been lifted. </p><p>See <a href="#id-variable-declarations"><b>5.16 Variable Declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1470">1470&nbsp;</a></p><p><code>$err:stack-trace</code> provides information about the current state of execution. </p><p>See <a href="#id-try-catch"><b>4.20 Try/Catch Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1496">1496&nbsp;</a></p><p> The context value static type, which was there purely to assist in static typing, has been dropped. </p><p>See <a href="#static_context"><b>2.2.1 Static Context</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1498">1498&nbsp;</a></p><p>The EBNF operators <code>++</code> and <code>**</code> have been introduced, for more concise representation of sequences using a character such as <code>","</code> as a separator. The notation is borrowed from Invisible XML.</p><p>See <a href="#id-terminology"><b>2.1 Terminology</b></a></p><p> The EBNF notation has been extended to allow the constructs <code>(A ++ ",")</code> (one or more occurrences of <code>A</code>, comma-separated, and <code>(A ** ",")</code> (zero or more occurrences of <code>A</code>, comma-separated. </p><p>See <a href="#id-ebnf-introduction"><b>2.1.1 Grammar Notation</b></a></p><p>The EBNF operators <code>++</code> and <code>**</code> have been introduced, for more concise representation of sequences using a character such as <code>","</code> as a separator. The notation is borrowed from Invisible XML.</p><p>See <a href="#id-grammar"><b>A.1 EBNF</b></a></p><p>See <a href="#EBNFNotation"><b>A.1.1 Notation</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1501">1501&nbsp;</a></p><p> The coercion rules now apply recursively to the members of an array and the entries in a map. </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1532">1532&nbsp;</a></p><p> Four new axes have been defined: <code>preceding-or-self</code>, <code>preceding-sibling-or-self</code>, <code>following-or-self</code>, and <code>following-sibling-or-self</code>. </p><p>See <a href="#axes"><b>4.6.5.1 Axes</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1577">1577&nbsp;</a></p><p> The syntax <code>record()</code> is allowed; the only thing it matches is an empty map. </p><p>See <a href="#id-record-test"><b>3.2.8.3 Record Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1686">1686&nbsp;</a></p><p> With the pipeline operator <code>-&gt;</code>, the result of an expression can be bound to the context value before evaluating another expression. </p><p>See <a href="#id-pipeline-operator"><b>4.22 Pipeline operator</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1696">1696&nbsp;</a></p><p> Parameter names may be included in a function signature; they are purely documentary. </p><p>See <a href="#id-function-test"><b>3.2.8.1 Function Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1703">1703&nbsp;</a></p><p>Ordered maps are introduced.</p><p>See <a href="#id-maps"><b>4.14.1 Maps</b></a></p><p>The order of key-value pairs in the map constructor is now retained in the constructed map.</p><p>See <a href="#id-map-constructors"><b>4.14.1.1 Map Constructors</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1874">1874&nbsp;</a></p><p> The coercion rules now reorder the entries in a map when the required type is a record type. </p><p>See <a href="#id-coercion-rules"><b>3.4 Coercion Rules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1898">1898&nbsp;</a></p><p>The rules for subtyping of document node types have been refined.</p><p>See <a href="#id-item-subtype-documents"><b>3.3.2.5.2 Subtyping Nodes: Document Nodes</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1914">1914&nbsp;</a></p><p> A <code>finally</code> clause can be supplied, which will always be evaluated after the expressions of the try/catch clauses. </p><p>See <a href="#id-try-catch"><b>4.20 Try/Catch Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1956">1956&nbsp;</a></p><p> Private variables declared in a library module are no longer required to be in the module namespace. </p><p>See <a href="#id-variable-declarations"><b>5.16 Variable Declaration</b></a></p><p> Private functions declared in a library module are no longer required to be in the module namespace. </p><p>See <a href="#id-function-names"><b>5.18.2 Function Names</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1982">1982&nbsp;</a></p><p> Whitespace is now required after the opening <code>(#</code> of a pragma. This is an incompatible change, made to ensure that an expression such as <code>error(#err:XPTY0004)</code> can be parsed as a function call taking a QName literal as its argument value. </p><p>See <a href="#id-extension-expressions"><b>4.26 Extension Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1991">1991&nbsp;</a></p><p> Named record types used in the signatures of built-in functions are now available as standard in the static context. </p><p>See <a href="#static_context"><b>2.2.1 Static Context</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2026">2026&nbsp;</a></p><p> The module feature is no longer an optional feature; processing of library modules is now required. </p><p>See <a href="#id-conformance"><b>6 Conformance</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2030">2030&nbsp;</a></p><p> The technical details of how validation works have been moved to the <em>Functions and Operators</em> specification. The XQuery <code>validate</code> expression is now defined in terms of the new <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-xsd-validator"><code>xsd-validator</code></a> function. </p><p>See <a href="#id-validate"><b>4.25 Validate Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2031">2031&nbsp;</a></p><p> The terms <b>XNode</b> and <code>JNode</code> are introduced; the existing term <b>node</b> remains in use as a synonym for <b>XNode</b> where the context does not specify otherwise. </p><p>See <a href="#id-values"><b>2.1.3 Values</b></a></p><p> JNodes are introduced </p><p>See <a href="#id-jnode-types"><b>3.2.9 JNode Types</b></a></p><p>See <a href="#id-generalized-node-types"><b>3.2.10 Generalized Node Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2055">2055&nbsp;</a></p><p> Sequences, arrays, and maps can be destructured in a <code>let</code> clause to extract their components into multiple variables. </p><p>See <a href="#id-xquery-let-clause"><b>4.13.3 Let Clause</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2094">2094&nbsp;</a></p><p>A general expression is allowed within a map constructor; this facilitates the creation of maps in which the presence or absence of particular keys is decided dynamically.</p><p>See <a href="#id-map-constructors"><b>4.14.1.1 Map Constructors</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2115">2115&nbsp;</a></p><p> This section describes and formalizes a convention that was already in use, but not explicitly stated, in earlier versions of the specification. </p><p>See <a href="#id-expression-names"><b>2.1.2 Expression Names</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2130">2130&nbsp;</a></p><p> Operator <code>is-not</code> is introduced, as a complement to the operator <code>is</code>. </p><p>See <a href="#id-node-comparisons"><b>4.10.3 GNode Comparisons</b></a></p><p> Operators <code>precedes</code> and <code>follows</code> are introduced as synonyms for operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code>. </p><p>See <a href="#id-node-comparisons"><b>4.10.3 GNode Comparisons</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2134">2134&nbsp;</a></p><p> The lookup operator <code>?</code> can now be followed by an arbitrary literal, for cases where keys are items other than integers or NCNames. It can also be followed by a variable reference or a context value reference. </p><p>See <a href="#id-lookup"><b>4.14.3 Lookup Expressions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2176">2176&nbsp;</a></p><p> Operators <code>precedes-or-is</code> and <code>follows-or-is</code> are introduced as synonyms for the union of operators <code>&lt;&lt;</code> and <code>is</code> and for the union of operators <code>&gt;&gt;</code> and <code>is</code>, respectively. </p><p>See <a href="#id-node-comparisons"><b>4.10.3 GNode Comparisons</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2202">2202&nbsp;</a></p><p>The type <code>schema-element(N)</code> is now defined to be a subtype of <code>element()</code> and of various other element tests.</p><p>See <a href="#id-item-subtype-elements"><b>3.3.2.5.3 Subtyping Nodes: Elements</b></a></p><p>The type <code>schema-attribute(N)</code> is now defined to be a subtype of <code>attribute()</code> and of various other attribute tests.</p><p>See <a href="#id-item-subtype-attributes"><b>3.3.2.5.4 Subtyping Nodes: Attributes</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2213">2213&nbsp;</a></p><p>This section (“External Resources and Security”) is new.</p><p>See <a href="#id-security-resources"><b>2.3 External Resources and Security</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2218">2218&nbsp;</a></p><p> The rules for value comparisons when comparing values of different types (for example, decimal and double) have changed to be transitive. A decimal value is no longer converted to double, instead the double is converted to a decimal without loss of precision. This may affect compatibility in edge cases involving comparison of values that are numerically very close. </p><p>See <a href="#id-value-comparisons"><b>4.10.1 Value Comparisons</b></a></p><p>The rules for comparing untyped atomic items with numeric values have changed. Rather than converting an untyped atomic item unconditionally to <code>xs:double</code>, it is now converted to the type of the numeric operand. This is designed to ensure that comparisons such as <code>&lt;a&gt;1.1&lt;/a&gt; = 1.1</code> succeed, given that the values will now be compared as decimals rather than as doubles.</p><p>See <a href="#id-general-comparisons"><b>4.10.2 General Comparisons</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2227">2227&nbsp;</a></p><p>A <code>URIQualifiedName</code> may now supply a prefix as well as a URI and local name.</p><p>See <a href="#id-namespaces-and-qnames"><b>2.1.4 Namespaces and QNames</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2236">2236&nbsp;</a></p><p> In the absence of a default namespace declaration, a user-defined function whose name is given as an unprefixed QName is now in no namespace. In previous versions of the language, this would generally be an error. </p><p>See <a href="#id-function-names"><b>5.18.2 Function Names</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2256">2256&nbsp;</a></p><p> An ordering is now defined for all data types. </p><p>See <a href="#id-value-comparisons"><b>4.10.1 Value Comparisons</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2259">2259&nbsp;</a></p><p> A new parameter <code>canonical</code> is available to give control over serialization of XML, XHTML, and JSON. </p><p>See <a href="#id-output-declarations"><b>5.22 Output Declarations</b></a></p></li><li class="delete_version" style="display: none;"><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2413">2413&nbsp;</a></p><p> Extensible map types are dropped; instead, the coercion rules cause undefined map entries to be discarded. </p><p>See <a href="#id-record-test"><b>3.2.8.3 Record Types</b></a></p><p>See <a href="#id-item-subtype-records"><b>3.3.2.9 Subtyping Records</b></a></p></li><li class="modify_version"><p><span class="deltaxml-old" style="background:#FF5555">PR </span><a href="https://github.com/qt4cg/qtspecs/pull/2413"><span class="deltaxml-old" style="background:#FF5555">2413&nbsp;</span></a></p><p><span class="deltaxml-old" style="background:#FF5555"> Extensible map types are dropped; instead, the coercion rules cause undefined map entries to be discarded. </span></p><p><span class="deltaxml-old" style="background:#FF5555">See </span><a href="#id-record-test"><b><span class="deltaxml-old" style="background:#FF5555">3.2.8.3 Record Types</span></b></a></p><p><span class="deltaxml-old" style="background:#FF5555">See </span><a href="#id-item-subtype-records"><b><span class="deltaxml-old" style="background:#FF5555">3.3.2.9 Subtyping Records</span></b></a></p></li></ol></div></div><script src="js/toc.js"></script><script src="/js/scroll.js"></script></body></html>