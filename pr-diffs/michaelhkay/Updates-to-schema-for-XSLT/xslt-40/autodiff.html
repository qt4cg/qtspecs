<!DOCTYPE HTML><html xmlns="http://www.w3.org/1999/xhtml" lang="EN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>XSL Transformations (XSLT) Version 4.0</title><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link rel="stylesheet" type="text/css" href="css/w3c-base.css"><link rel="stylesheet" href="css/qtspecs.css"><link rel="stylesheet" href="css/xslt-40.css"><style type="text/css">
          body { margin-top: 50px }
          a.button { background: #DDD; border: 2px outset black; padding: 2px; margin: 2px; font-family: sans-serif; font-size: small;}
          a.button:hover { cursor:pointer; }
          a.button:active { border-style: inset; }
        </style><link rel="stylesheet" href="/css/autodiff.css"></head><body class="toc-inline"><div style="position:fixed; clear:both; top:0px" id="_autodiff_buttons"><p><a class="button" onclick="view('old')">
              View Old
            </a><a class="button" onclick="view('new')">
              View New
            </a><a class="button" onclick="view('both')">
              View Both
            </a><a class="button" onclick="view('only')">
              View Only
            </a><a class="button" onclick="scroll_to('prev')">
              Previous
            </a><a class="button" onclick="scroll_to('next')">
              Next
            </a><span id="__autodiff__"></span></p><p>This draft contains only sections that have differences from the version that it modified.</p></div><div class="head"><p><a href="https://www.w3.org/"><img src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C" alt="W3C" height="48" width="72"></a></p><h1><a id="title"></a>XSL Transformations (XSLT) Version 4.0</h1><h2><a id="w3c-doctype"></a>W3C Editor's Draft <span class="deltaxml-old" style="background:#FF5555">2</span><span class="deltaxml-new" style="background:#90EE90">3</span> February 2026</h2><dl><dt>This version:</dt><dd><a href="https://qt4cg.org/specifications/xslt-40/">https://qt4cg.org/specifications/xslt-40/</a></dd><dt>Latest version:</dt><dd><a href="https://qt4cg.org/specifications/xslt-40/">https://qt4cg.org/specifications/xslt-40/</a></dd><dt>Most recent Recommendation of XSL Transformations (XSLT):</dt><dd><a href="https://www.w3.org/TR/xslt-30/">https://www.w3.org/TR/xslt-30/</a></dd><dt>Editor:</dt><dd>Michael Kay, Saxonica <a href="http://www.saxonica.com/">&lt;http://www.saxonica.com/&gt;</a></dd></dl><p>The following associated resources are available: <a href="xslt-40.xml">Specification in XML format</a>, <a href="schema-for-xslt40.xsd">XSD 1.1 Schema for XSLT 4.0 Stylesheets (non-normative)</a>, <a href="schema-for-xslt40.rnc">Relax-NG Schema for XSLT 4.0 Stylesheets (non-normative)</a>, <a href="xml-to-json.xsl">Stylesheet for XML-to-JSON conversion (non-normative)</a></p><p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;©&nbsp;2026&nbsp;<a href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="https://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="https://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="https://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p><hr></div><div><h2><a id="abstract"></a>Abstract</h2><p>This specification defines the syntax and semantics of XSLT 4.0, a language designed primarily for transforming XML documents into other XML documents, but also offering support for other data formats including JSON, HTML, and CSV.</p><p>XSLT 4.0 is a revised version of the XSLT 3.0 Recommendation <a href="#xslt-30">[XSLT 3.0]</a> published on 8 June 2017. Changes are presented in <a href="#whats-new-in-xslt4"><i>1.2 What’s New in XSLT 4.0?</i></a>. </p><p>XSLT 4.0 is designed to be used in conjunction with XPath 4.0, which is defined in <a href="#xpath-40">[XPath 4.0]</a>. XSLT shares the same data model as XPath 4.0, which is defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>, and it uses the library of functions and operators defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. XPath 4.0 and the underlying function library introduce a number of enhancements, for example the availability of union and record types. </p><p><em>This document contains hyperlinks to specific sections or definitions within other documents in this family of specifications. These links are indicated visually by a superscript identifying the target specification: for example XP for XPath 4.0, DM for the XDM data model version 4.0, FO for Functions and Operators version 4.0, SG for XSLT Streaming version 4.0.</em></p><p>An optional feature of the XSLT language is support for streamed transformations. The XSLT 4.0 specification has been modularized so that streaming is now described in a separate specification document. This has been done in order to make the specifications more manageable, both for editors and readers: it does not alter the status of streaming as an optional feature, available in some processors and not others.</p></div><div><h2><a id="status"></a>Status of this Document</h2><p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document.</em></p><p>This document is a working draft developed and maintained by a W3C Community Group, the <a href="https://www.w3.org/community/xslt-40/">XQuery and XSLT Extensions Community Group</a> unofficially known as QT4CG (where "QT" denotes Query and Transformation). This draft is work in progress and should not be considered either stable or complete. Standard W3C copyright and patent conditions apply.</p><p>The community group welcomes comments on the specification. Comments are best submitted as issues on the group's <a href="https://github.com/qt4cg/qtspecs/issues">GitHub repository</a>.</p><p>The community group maintains two extensive test suites, one oriented to XQuery and XPath, the other to XSLT. These can be found at <a href="https://github.com/qt4cg/qt4tests">qt4tests</a> and <a href="https://github.com/qt4cg/xslt40-test">xslt40-test</a> respectively. New tests, or suggestions for correcting existing tests, are welcome. The test suites include extensive metadata describing the conditions for applicability of each test case as well as the expected results. They do not include any test drivers for executing the tests: each implementation is expected to provide its own test driver.</p><div class="dedication" id="dedication"><h3>Dedication</h3><p>The publications of this community group <a href="../xquery-40/xpath-40.html#dedication">are dedicated</a> to our co-chair, Michael Sperberg-McQueen&nbsp;(1954–2024).</p></div></div><hr><div class="body"></div><div class="back"><div class="_diffs div1"><h2><a id="schema-for-xslt"></a>H <a href="#schema-for-xslt" style="text-decoration: none">Schemas for XSLT 4.0 Stylesheets</a> (Non-Normative)</h2><p>For convenience, schemas are provided for validation of XSLT 4.0 stylesheets using the XSD 1.1 and Relax NG schema languages. These are non-normative. Neither will detect every static error that might arise in an XSLT 4.0 stylesheet (for example, there is no attempt to check the syntax of XPath expressions); in addition, these schemas may reject some stylesheets that are valid, for example because they rely on <code>xsl:use-when</code> to eliminate sections of code that would otherwise be invalid.</p><div class="_diffs div2"><h3><a id="xsd11-schema-for-xslt"></a>H.1 <a href="#xsd11-schema-for-xslt" style="text-decoration: none">XSD 1.1 Schema for XSLT Stylesheets</a></h3><p>The following XSD 1.1 schema describes the structure of an XSLT stylesheet module. There are some limitations:</p><ul><li><p>It does not define all the constraints that apply to a stylesheet (for example, it does not attempt to define a datatype that precisely represents attributes containing XPath <a title="expression" class="termref" href="#dt-expression">expressions</a>).</p></li><li><p>Stylesheets that use <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> (an <code>[xsl:]version</code> attribute greater than 4.0), or that have sections excluded using <code>[xsl:]use-when</code> attributes, are not required to conform to the schema.</p></li><li><p>The specification allows <a href="#element-note"><code>xsl:note</code></a> elements to appear anywhere, but this schema is more restrictive.</p></li></ul><p>A copy of this schema is available at <span><a href="schema-for-xslt40.xsd">schema-for-xslt40.xsd</a></span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The schema as written uses a lax wildcard to permit literal result elements to appear in a sequence constructor. This assumes that the schema used for validation will not contain any global element declaration that matches the element name of a literal result element. The content model for an element such as <code>invoice</code> appearing within a stylesheet is not the same as the content model for the same element appearing within a source document (it is likely to contain XSLT instructions rather than other elements from the target vocabulary): therefore, including such declarations in the schema used for validating a stylesheet is inappropriate.</p><p>The reason that lax validation rather than skip validation is used is so that XSLT instructions appearing as children of the literal result element will themselves be validated, using the appropriate global element declaration.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The schema uses XSD 1.1 assertions to represent some of the non-grammatical constraints appearing in the specification, for example the rule that some elements can have either a <code>select</code> attribute or a contained sequence constructor, but not both. At this stage, no attempt has been made to represent every such constraint, even where it is not difficult to express the rule. There will always be some constraints that cannot be expressed at all, for example those that require access to multiple stylesheet modules, those that require access to the in-scope schema components, and those that involve parsing a non-regular grammar, such as the grammar for patterns.</p><p>Apart from assertions, the only other significant use of XSD 1.1 features is that the elements <a href="#element-param"><code>xsl:param</code></a> and <a href="#element-variable"><code>xsl:variable</code></a> are in two substitution groups: one containing all instructions, and one containing all declarations. If the schema needs to be converted to an XSD 1.0 schema, removing all assertions is straightforward; the other change needed is to remove <a href="#element-param"><code>xsl:param</code></a> and <a href="#element-variable"><code>xsl:variable</code></a> from the substitution group for declarations, and instead permit them explicitly as children of <a href="#element-transform"><code>xsl:transform</code></a>.</p></div><pre class="font-size: small" xml:space="preserve"><span class="deltaxml-old" style="background:#FF5555">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
           xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning"
           targetNamespace="http://www.w3.org/1999/XSL/Transform"
           elementFormDefault="qualified"
           vc:minVersion="1.1"&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      &lt;p&gt;
         This is an XSD 1.1 schema for XSLT 4.0 stylesheets. It defines all the
         elements that appear in the XSLT namespace; it also provides hooks that
         allow the inclusion of user-defined literal result elements, extension
         instructions, and top-level data elements.
      &lt;/p&gt;
      &lt;p&gt;
         This schema is available for use under the conditions of the W3C Software
         License published at
         http://www.w3.org/Consortium/Legal/copyright-software-19980720
      &lt;/p&gt;
      &lt;p&gt;
         The schema is organized as follows:
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;
           PART A: definitions of complex types and model groups used as the basis
           for element definitions
        &lt;/li&gt;
        &lt;li&gt;
           PART B: definitions of individual XSLT elements
        &lt;/li&gt;
        &lt;li&gt;
           PART C: definitions for literal result elements
        &lt;/li&gt;
        &lt;li&gt;
           PART D: definitions of simple types used in attribute definitions
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;
         The schema has a number of limitations:
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;
           The XSLT specification allows additional elements and attributes to be
           present where forwards compatibility is invoked. This schema does not.
        &lt;/li&gt;
        &lt;li&gt;
           The XSLT specification allows arbitrary content in a part of the
           stylesheet that is excluded by virtue of a use-when attribute. This
           schema does not.
        &lt;/li&gt;
        &lt;li&gt;
           The handling of literal result elements in this schema is imperfect;
           although various options are allowed, none matches the specification
           exactly. For example, the content of a literal result element uses lax
           validation, which permits child elements in the XSLT namespace that have
           no declaration in this schema.
        &lt;/li&gt;
        &lt;li&gt;
           The schema makes no attempt to check XPath expressions for syntactic or
           semantic correctness, nor to check that component references are
           resolved (for example that a template named in &lt;code&gt;xsl:call-template&lt;/code&gt; has a
           declaration). Doing this in general requires cross-document validation,
           which is beyond the scope of XSD.
        &lt;/li&gt;
        &lt;li&gt;
           The XSLT specification allows &lt;code&gt;xsl:note&lt;/code&gt; elements to appear
           anywhere, with arbitrary content. This schema does not: for example, it does
           not allow &lt;code&gt;xsl:note&lt;/code&gt; as a child of an element such as &lt;code&gt;xsl:text&lt;/code&gt;
           or &lt;code&gt;xsl:strip-space&lt;/code&gt;.
        &lt;/li&gt;
        &lt;li&gt;
           The schema imports the schema for XSD 1.0 schema documents. In
           stylesheets that contain an inline XSD 1.1 schema, this import should be
           replaced with one for the schema for XSD 1.1 schema documents.
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;!--
The declaration of xml:space and xml:lang may need to be commented out because
of problems processing the schema using various tools
--&gt;

  &lt;xs:import namespace="http://www.w3.org/XML/1998/namespace"/&gt;
  &lt;!--schemaLocation="http://www.w3.org/2001/xml.xsd"--&gt;

  &lt;!-- 
    An XSLT stylesheet may contain an in-line schema within an xsl:import-schema element,
    so the Schema for schemas needs to be imported. We use the XSD 1.1 version.
--&gt;

  &lt;xs:import namespace="http://www.w3.org/2001/XMLSchema"
             schemaLocation="http://www.w3.org/TR/xmlschema11-1/XMLSchema.xsd"/&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      &lt;p&gt;
         PART A: definitions of complex types and model groups used as the basis
         for element definitions
      &lt;/p&gt;
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  
  &lt;xs:defaultOpenContent&gt;
    &lt;!-- Allow xsl:note anywhere --&gt;
    &lt;xs:any processContents="strict" 
            namespace="##targetNamespace"
            notQName="xsl:accept 
                      xsl:accumulator 
                      xsl:accumulator-rule 
                      xsl:analyze-string 
                      xsl:apply-imports 
                      xsl:apply-templates 
                      xsl:array 
                      xsl:assert 
                      xsl:attribute 
                      xsl:attribute-set 
                      xsl:break 
                      xsl:call-template 
                      xsl:catch 
                      xsl:character-map 
                      xsl:choose 
                      xsl:comment 
                      xsl:context-item 
                      xsl:copy 
                      xsl:copy-of 
                      xsl:document 
                      xsl:decimal-format 
                      xsl:element 
                      xsl:evaluate 
                      xsl:expose 
                      xsl:fallback
                      xsl:field 
                      xsl:for-each 
                      xsl:for-each-group 
                      xsl:fork 
                      xsl:function 
                      xsl:global-context-item 
                      xsl:if 
                      xsl:import 
                      xsl:import-schema 
                      xsl:include 
                      xsl:iterate 
                      xsl:key 
                      xsl:map 
                      xsl:map-entry 
                      xsl:matching-substring 
                      xsl:merge 
                      xsl:merge-action 
                      xsl:merge-key 
                      xsl:merge-source 
                      xsl:message 
                      xsl:mode 
                      xsl:namespace 
                      xsl:namespace-alias 
                      xsl:next-iteration 
                      xsl:next-match 
                      xsl:non-matching-substring 
                      xsl:number 
                      xsl:on-completion 
                      xsl:on-empty 
                      xsl:on-non-empty 
                      xsl:otherwise 
                      xsl:output 
                      xsl:output-character 
                      xsl:override 
                      xsl:package 
                      xsl:param 
                      xsl:perform-sort 
                      xsl:preserve-space 
                      xsl:processing-instruction
                      xsl:record 
                      xsl:record-type 
                      xsl:result-document
                      xsl:select
                      xsl:sequence 
                      xsl:sort 
                      xsl:source-document 
                      xsl:strip-space 
                      xsl:stylesheet 
                      xsl:switch 
                      xsl:template 
                      xsl:text 
                      xsl:transform 
                      xsl:try 
                      xsl:use-package 
                      xsl:value-of 
                      xsl:variable 
                      xsl:when 
                      xsl:where-populated 
                      xsl:with-param
            "/&gt;
  &lt;/xs:defaultOpenContent&gt;
  
  &lt;xs:complexType name="generic-element-type" mixed="true"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This complex type provides a generic supertype for all XSLT elements except 
           &lt;code&gt;xsl:record&lt;/code&gt;; it contains the definitions of the standard attributes 
           that may appear on any element.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:attribute name="default-collation" type="xsl:uri-list"/&gt;
    &lt;xs:attribute name="default-mode" type="xsl:default-mode-type"/&gt;
    &lt;xs:attribute name="default-validation"
                  type="xsl:validation-strip-or-preserve"
                  default="strip"/&gt;
    &lt;xs:attribute name="exclude-result-prefixes" type="xsl:prefix-list-or-all"/&gt;
    &lt;xs:attribute name="expand-text" type="xsl:yes-or-no"/&gt;
    &lt;xs:attribute name="extension-element-prefixes" type="xsl:prefix-list"/&gt;
    &lt;xs:attribute name="schema-role" type="xs:NCName"/&gt;
    &lt;xs:attribute name="use-when" type="xsl:expression"/&gt;
    &lt;xs:attribute name="xpath-default-namespace" type="xs:anyURI"/&gt;
    &lt;xs:attribute name="_default-collation" type="xs:string"/&gt;
    &lt;xs:attribute name="_default-mode" type="xs:string"/&gt;
    &lt;xs:attribute name="_default-validation" type="xs:string"/&gt;
    &lt;xs:attribute name="_exclude-result-prefixes" type="xs:string"/&gt;
    &lt;xs:attribute name="_expand-text" type="xs:string"/&gt;
    &lt;xs:attribute name="_extension-element-prefixes" type="xs:string"/&gt;
    &lt;xs:attribute name="_schema-role" type="xs:string"/&gt;
    &lt;xs:attribute name="_use-when" type="xs:string"/&gt;
    &lt;xs:attribute name="_xpath-default-namespace" type="xs:string"/&gt;
    &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="element-only-generic-element-type" mixed="false"&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="xsl:generic-element-type"/&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="versioned-element-type" mixed="true"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This complex type provides a generic supertype for all XSLT elements with
                the exception of &lt;code&gt;xsl:output&lt;/code&gt; and &lt;code&gt;xsl:record&lt;/code&gt;; it contains the
                definitions of the &lt;code&gt;version&lt;/code&gt; attribute that may appear on any element.
                &lt;/p&gt;
        &lt;p&gt;The &lt;code&gt;xsl:output&lt;/code&gt; element does not use this definition because, although it
             has a &lt;code&gt;version&lt;/code&gt; attribute, the syntax and semantics of this attribute are
             unrelated to the standard &lt;code&gt;version&lt;/code&gt; attribute allowed on other elements.&lt;/p&gt;
        &lt;p&gt;Similarly &lt;code&gt;xsl:record&lt;/code&gt; does not use this definition because it expects
        standard attributes (including [xsl:]version) to be in the XSLT namespace.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:generic-element-type"&gt;
        &lt;xs:attribute name="version" type="xs:decimal" use="optional"/&gt;
        &lt;xs:attribute name="_version" type="xs:string"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="element-only-versioned-element-type" mixed="false"&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="xsl:versioned-element-type"&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="sequence-constructor"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This complex type provides a generic supertype for all XSLT elements
           that allow a sequence constructor as their content.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:group ref="xsl:sequence-constructor-group"
                  minOccurs="0"
                  maxOccurs="unbounded"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="sequence-constructor-and-select"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This complex type allows a sequence constructor and a select attribute.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="_select" type="xs:string"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="sequence-constructor-or-select"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This complex type allows a sequence constructor or a select attribute,
           but not both.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:restriction base="xsl:sequence-constructor-and-select"&gt;
        &lt;xs:group ref="xsl:sequence-constructor-group"
                  minOccurs="0"
                  maxOccurs="unbounded"/&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
        &lt;xs:assert test="not(exists(@select | @_select) and 
          (exists(* except xsl:fallback) or exists(text()[normalize-space()])))"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:group name="sequence-constructor-group"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This complex type provides a generic supertype for all XSLT elements
           that allow a sequence constructor as their content.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="xsl:instruction"/&gt;
      &lt;xs:element ref="xsl:record"/&gt;
      &lt;xs:group ref="xsl:result-elements"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

  &lt;xs:element name="declaration" type="xsl:generic-element-type" abstract="true"/&gt;

  &lt;xs:element name="instruction" type="xsl:versioned-element-type" abstract="true"/&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      &lt;p&gt;
         PART B: definitions of individual XSLT elements Elements are listed in
         alphabetical order.
      &lt;/p&gt;
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  
  &lt;xs:element name="accept"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:use-package&lt;/code&gt; and defines 
            any variations that the containing package wishes to make to the visibility of
            components made available from a library package. For example, it may indicate that
            some of the public components in the library package are not to be made available
            to the containing package.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="component" type="xsl:component-kind-type"/&gt;
          &lt;xs:attribute name="names" type="xsl:component-tests"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt;
          &lt;xs:attribute name="_component" type="xs:string"/&gt;
          &lt;xs:attribute name="_names" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@component | @_component)"/&gt;
          &lt;xs:assert test="exists(@names | @_names)"/&gt;
          &lt;xs:assert test="exists(@visibility | @_visibility)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="accumulator" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:accumulator-rule" minOccurs="1" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="initial-value" type="xsl:expression"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_initial-value" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="accumulator-rule"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:sequence/&gt;
          &lt;xs:attribute name="match" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="phase"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:token"&gt;
                &lt;xs:enumeration value="start"/&gt;
                &lt;xs:enumeration value="end"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="capture" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="_match" type="xs:string"/&gt;
          &lt;xs:attribute name="_phase" type="xs:string"/&gt;
          &lt;xs:attribute name="_capture" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@match | @_match)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="analyze-string" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:matching-substring" minOccurs="0"/&gt;
            &lt;xs:element ref="xsl:non-matching-substring" minOccurs="0"/&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="regex" type="xsl:avt"/&gt;
          &lt;xs:attribute name="flags" type="xsl:avt" default=""/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_regex" type="xs:string"/&gt;
          &lt;xs:attribute name="_flags" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
          &lt;xs:assert test="exists(@regex | @_regex)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="apply-imports" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="apply-templates" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:sort"/&gt;
            &lt;xs:element ref="xsl:with-param"/&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="select" type="xsl:expression" default="child::node()"/&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="mode" type="xsl:mode"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_mode" type="xs:string"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) 
                           satisfies empty($e/(@stable | @_stable))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is a static error if an &lt;code&gt;xsl:sort&lt;/code&gt; element other than the first
                   in a sequence of sibling &lt;code&gt;xsl:sort&lt;/code&gt; elements has a &lt;code&gt;stable&lt;/code&gt;
                   attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="array" 
              substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="for-each" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_for-each" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="array-member"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor-or-select"/&gt;
  
  &lt;xs:element name="assert" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="test" type="xsl:expression"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="error-code" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_test" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_error-code" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@test | @_test)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="attribute" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:avt"/&gt;
          &lt;xs:attribute name="namespace" type="xsl:avt"/&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_namespace" type="xs:string"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="attribute-set" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:attribute"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="break"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="call-template" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="catch"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="errors" type="xsl:nametests" use="optional"/&gt;
          &lt;xs:attribute name="_errors" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="character-map" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:output-character" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="use-character-maps" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="choose" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:when" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:otherwise" minOccurs="0"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="comment"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor-or-select"/&gt;
  
  &lt;xs:element name="context-item"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="as" type="xsl:item-type"/&gt;
          &lt;xs:attribute name="use"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:token"&gt;
                &lt;xs:enumeration value="required"/&gt;
                &lt;xs:enumeration value="optional"/&gt;
                &lt;xs:enumeration value="absent"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_use" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="copy" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_copy-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_inherit-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="copy-of" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="copy-accumulators" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_copy-accumulators" type="xs:string"/&gt;
          &lt;xs:attribute name="_copy-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="document" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="decimal-format" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="decimal-separator" type="xsl:char-optionally-expanded" default="."/&gt;
          &lt;xs:attribute name="grouping-separator" type="xsl:char-optionally-expanded" default=","/&gt;
          &lt;xs:attribute name="infinity" type="xs:string" default="Infinity"/&gt;
          &lt;xs:attribute name="minus-sign" type="xs:string" default="-"/&gt;
          &lt;xs:attribute name="exponent-separator" type="xsl:char-optionally-expanded" default="e"/&gt;
          &lt;xs:attribute name="NaN" type="xs:string" default="NaN"/&gt;
          &lt;xs:attribute name="percent" type="xsl:char-optionally-expanded" default="%"/&gt;
          &lt;xs:attribute name="per-mille" type="xsl:char-optionally-expanded" default="â€°"/&gt;
          &lt;xs:attribute name="zero-digit" type="xsl:zero-digit" default="0"/&gt;
          &lt;xs:attribute name="digit" type="xsl:char" default="#"/&gt;
          &lt;xs:attribute name="pattern-separator" type="xsl:char" default=";"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_decimal-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_grouping-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_infinity" type="xs:string"/&gt;
          &lt;xs:attribute name="_minus-sign" type="xs:string"/&gt;
          &lt;xs:attribute name="_exponent-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_NaN" type="xs:string"/&gt;
          &lt;xs:attribute name="_percent" type="xs:string"/&gt;
          &lt;xs:attribute name="_per-mille" type="xs:string"/&gt;
          &lt;xs:attribute name="_zero-digit" type="xs:string"/&gt;
          &lt;xs:attribute name="_digit" type="xs:string"/&gt;
          &lt;xs:attribute name="_pattern-separator" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="element" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="name" type="xsl:avt"/&gt;
          &lt;xs:attribute name="namespace" type="xsl:avt"/&gt;
          &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_namespace" type="xs:string"/&gt;
          &lt;xs:attribute name="_inherit-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="evaluate" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:with-param"/&gt;
            &lt;xs:element ref="xsl:fallback"/&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="xpath" type="xsl:expression"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="base-uri" type="xsl:avt"/&gt;
          &lt;xs:attribute name="context-item" type="xsl:expression"/&gt;
          &lt;xs:attribute name="namespace-context" type="xsl:expression"/&gt;
          &lt;xs:attribute name="schema-aware" type="xsl:avt"/&gt;
          &lt;xs:attribute name="trusted" type="xsl:avt"/&gt;
          &lt;xs:attribute name="with-params" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_xpath" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_base-uri" type="xs:string"/&gt;
          &lt;xs:attribute name="_context-item" type="xs:string"/&gt;
          &lt;xs:attribute name="_namespace-context" type="xs:string"/&gt;
          &lt;xs:attribute name="_schema-aware" type="xs:string"/&gt;
          &lt;xs:attribute name="_trusted" type="xs:string"/&gt;
          &lt;xs:attribute name="_with-params" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@xpath | @_xpath)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="expose"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:use-package&lt;/code&gt; and defines 
            the visibility of components that are made available (or not) by this package
            to other using packages.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="component" type="xsl:component-kind-type"/&gt;
          &lt;xs:attribute name="names" type="xsl:component-tests"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
          &lt;xs:attribute name="_component" type="xs:string"/&gt;
          &lt;xs:attribute name="_names" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@component | @_component)"/&gt;
          &lt;xs:assert test="exists(@names | @_names)"/&gt;
          &lt;xs:assert test="exists(@visibility | @_visibility)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="fallback"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor"/&gt;
  
  &lt;xs:element name="field"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="name" type="xs:NCName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="required" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="default" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_required" type="xs:string"/&gt;
          &lt;xs:attribute name="_default" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="for-each" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) 
                           satisfies empty($e/(@stable | @_stable))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is a static error if an &lt;code&gt;xsl:sort&lt;/code&gt; element other than the first
                   in a sequence of sibling &lt;code&gt;xsl:sort&lt;/code&gt; elements has a &lt;code&gt;stable&lt;/code&gt;
                   attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="for-each-group" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="group-by" type="xsl:expression"/&gt;
          &lt;xs:attribute name="group-adjacent" type="xsl:expression"/&gt;
          &lt;xs:attribute name="group-starting-with" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="group-ending-with" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="split-when" type="xsl:expression"/&gt;
          &lt;xs:attribute name="composite" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="collation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_group-by" type="xs:string"/&gt;
          &lt;xs:attribute name="_group-adjacent" type="xs:string"/&gt;
          &lt;xs:attribute name="_group-starting-with" type="xs:string"/&gt;
          &lt;xs:attribute name="_group-ending-with" type="xs:string"/&gt;
          &lt;xs:attribute name="_split-when" type="xs:string"/&gt;
          &lt;xs:attribute name="_composite" type="xs:string"/&gt;
          &lt;xs:attribute name="_collation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) 
                           satisfies empty($e/(@stable | @_stable))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is a static error if an &lt;code&gt;xsl:sort&lt;/code&gt; element other than the first
                   in a sequence of sibling &lt;code&gt;xsl:sort&lt;/code&gt; elements has a &lt;code&gt;stable&lt;/code&gt;
                   attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="count(((@group-by|@_group-by)[1], 
                                  (@group-adjacent|@_group-adjacent)[1], 
                                  (@group-starting-with|@_group-starting-with)[1], 
                                  (@group-ending-with|@_group-ending-with)[1],
                                  (@split-when|@_split-when)[1])) = 1"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   These four attributes are mutually exclusive: it is a static
                   error if none of these four attributes is present or if more
                   than one of them is present.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (exists(@collation|@_collation) or exists(@composite|@_composite)) 
                           then (exists(@group-by|@_group-by) or exists(@group-adjacent|@_group-adjacent)) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is an error to specify the collation attribute or the
                   composite attribute if neither the group-by attribute nor
                   group-adjacent attribute is specified.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="fork" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:choice&gt;
              &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
                &lt;xs:element ref="xsl:sequence"/&gt;
                &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
              &lt;/xs:sequence&gt;
              &lt;xs:sequence&gt;
                &lt;xs:element ref="xsl:for-each-group"/&gt;
                &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
              &lt;/xs:sequence&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="function" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="override" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
          &lt;xs:attribute name="streamability" type="xsl:streamability-type"/&gt;
          &lt;xs:attribute name="override-extension-function" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="new-each-time" type="xsl:yes-or-no-or-maybe"/&gt;
          &lt;xs:attribute name="cache" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_override" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamability" type="xs:string"/&gt;
          &lt;xs:attribute name="_override-extension-function" type="xs:string"/&gt;
          &lt;xs:attribute name="_new-each-time" type="xs:string"/&gt;
          &lt;xs:attribute name="_cache" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="every $e in xsl:param satisfies empty($e/(@visibility | @_visibility))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;A parameter for a function must have no &lt;code&gt;visibility&lt;/code&gt; attribute.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="global-context-item" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="as" type="xsl:item-type"/&gt;
          &lt;xs:attribute name="use"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:token"&gt;
                &lt;xs:enumeration value="required"/&gt;
                &lt;xs:enumeration value="optional"/&gt;
                &lt;xs:enumeration value="absent"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_use" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  

  &lt;xs:element name="if" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="test" type="xsl:expression"/&gt;
          &lt;xs:attribute name="then" type="xsl:expression"/&gt;
          &lt;xs:attribute name="else" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_test" type="xs:string"/&gt;
          &lt;xs:attribute name="_then" type="xs:string"/&gt;
          &lt;xs:attribute name="_else" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@test | @_test)"/&gt;
          &lt;xs:assert test="not(exists(@then | @_then) and 
            (exists(* except xsl:fallback) or exists(text()[normalize-space()])))"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="import" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="href" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@href | @_href)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="import-schema" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xs:schema" minOccurs="0" maxOccurs="1"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="namespace" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="role" type="xs:NCName"/&gt;
          &lt;xs:attribute name="schema-location" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="_namespace" type="xs:string"/&gt;
          &lt;xs:attribute name="_role" type="xs:string"/&gt;
          &lt;xs:attribute name="_schema-location" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@schema-location | @_schema-location) and exists(xs:schema))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   XTSE0215: It is a static error if an &lt;code&gt;xsl:import-schema&lt;/code&gt; element
                   that contains an xs:schema element has a &lt;code&gt;schema-location&lt;/code&gt;
                   attribute
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="include" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="href" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@href | @_href)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="iterate" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:on-completion" minOccurs="0" maxOccurs="1"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="key" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="match" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="use" type="xsl:expression"/&gt;
          &lt;xs:attribute name="composite" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="collation" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_match" type="xs:string"/&gt;
          &lt;xs:attribute name="_use" type="xs:string"/&gt;
          &lt;xs:attribute name="_composite" type="xs:string"/&gt;
          &lt;xs:attribute name="_collation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="exists(@match | @_match)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="map"
              substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-and-select"&gt;
          &lt;xs:attribute name="duplicates" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_duplicates" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="map-entry" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-and-select"&gt;
          &lt;xs:attribute name="key" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_key" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@key | @_key)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="matching-substring" type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="merge" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:merge-source" minOccurs="1" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:merge-action" minOccurs="1" maxOccurs="1"/&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="merge-action" type="xsl:sequence-constructor"/&gt;

  &lt;xs:element name="merge-key" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
          &lt;xs:attribute name="order" type="xsl:avt"/&gt;
          &lt;xs:attribute name="collation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="case-order" type="xsl:avt"/&gt;
          &lt;xs:attribute name="data-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_lang" type="xs:string"/&gt;
          &lt;xs:attribute name="_order" type="xs:string"/&gt;
          &lt;xs:attribute name="_collation" type="xs:string"/&gt;
          &lt;xs:attribute name="_case-order" type="xs:string"/&gt;
          &lt;xs:attribute name="_data-type" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="merge-source"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:merge-key" minOccurs="1" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xs:NCName"/&gt;
          &lt;xs:attribute name="for-each-item" type="xsl:expression"/&gt;
          &lt;xs:attribute name="for-each-source" type="xsl:expression"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="use-accumulators" type="xsl:accumulator-names"/&gt;
          &lt;xs:attribute name="sort-before-merge" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_for-each-item" type="xs:string"/&gt;
          &lt;xs:attribute name="_for-each-source" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-accumulators" type="xs:string"/&gt;
          &lt;xs:attribute name="_sort-before-merge" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="message" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="terminate" type="xsl:avt" default="no"/&gt;
          &lt;xs:attribute name="error-code" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_terminate" type="xs:string"/&gt;
          &lt;xs:attribute name="_error-code" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="mode" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="false"&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:template"/&gt; 
            &lt;xs:element ref="xsl:fallback"/&gt; 
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="use-accumulators" type="xsl:accumulator-names"/&gt;
          &lt;xs:attribute name="on-no-match" type="xsl:on-no-match-type" default="text-only-copy"/&gt;
          &lt;xs:attribute name="on-multiple-match"
                        type="xsl:on-multiple-match-type"
                        default="use-last"/&gt;
          &lt;xs:attribute name="warning-on-no-match" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="warning-on-multiple-match" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="typed" type="xsl:typed-type"/&gt;
          &lt;xs:attribute name="visibility"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xsl:visibility-type"&gt;
                &lt;xs:enumeration value="public"/&gt;
                &lt;xs:enumeration value="private"/&gt;
                &lt;xs:enumeration value="final"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_copy-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-accumulators" type="xs:string"/&gt;
          &lt;xs:attribute name="_on-no-match" type="xs:string"/&gt;
          &lt;xs:attribute name="_on-multiple-match" type="xs:string"/&gt;
          &lt;xs:attribute name="_warning-on-no-match" type="xs:string"/&gt;
          &lt;xs:attribute name="_warning-on-multiple-match" type="xs:string"/&gt;
          &lt;xs:attribute name="_typed" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;


  &lt;xs:element name="namespace" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="namespace-alias" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="stylesheet-prefix" type="xsl:prefix-or-default"/&gt;
          &lt;xs:attribute name="result-prefix" type="xsl:prefix-or-default"/&gt;
          &lt;xs:attribute name="_stylesheet-prefix" type="xs:string"/&gt;
          &lt;xs:attribute name="_result-prefix" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@stylesheet-prefix | @_stylesheet-prefix)"/&gt;
          &lt;xs:assert test="exists(@result-prefix | @_result-prefix)"/&gt;
          &lt;xs:assert test="every $prefix in (@stylesheet-prefix, @result-prefix)/normalize-space(.)[. ne '#default']
                           satisfies $prefix = in-scope-prefixes(.)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;


  &lt;xs:element name="next-iteration" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;


  &lt;xs:element name="next-match" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:with-param"/&gt;
            &lt;xs:element ref="xsl:fallback"/&gt;
          &lt;/xs:choice&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="non-matching-substring" type="xsl:sequence-constructor-or-select"/&gt;
  
  &lt;xs:element name="note" type="xs:anyType"/&gt;

  &lt;xs:element name="number" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:attribute name="value" type="xsl:expression"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="level" type="xsl:level" default="single"/&gt;
          &lt;xs:attribute name="count" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="from" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="format" type="xsl:avt" default="1"/&gt;
          &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
          &lt;xs:attribute name="letter-value" type="xsl:avt"/&gt;
          &lt;xs:attribute name="ordinal" type="xsl:avt"/&gt;
          &lt;xs:attribute name="start-at" type="xsl:avt"/&gt;
          &lt;xs:attribute name="grouping-separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="grouping-size" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_value" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_level" type="xs:string"/&gt;
          &lt;xs:attribute name="_count" type="xs:string"/&gt;
          &lt;xs:attribute name="_from" type="xs:string"/&gt;
          &lt;xs:attribute name="_format" type="xs:string"/&gt;
          &lt;xs:attribute name="_lang" type="xs:string"/&gt;
          &lt;xs:attribute name="_letter-value" type="xs:string"/&gt;
          &lt;xs:attribute name="_ordinal" type="xs:string"/&gt;
          &lt;xs:attribute name="_start-at" type="xs:string"/&gt;
          &lt;xs:attribute name="_grouping-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_grouping-size" type="xs:string"/&gt;
          &lt;xs:assert test="if (exists(@value | @_value)) 
                           then empty((@select | @_select, @count | @_count, @from | @_from)) 
                            and (exists(@_level) or normalize-space(@level)='single') 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is a static error if the value attribute of &lt;code&gt;xsl:number&lt;/code&gt; is
                   present unless the &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;level&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, 
                   and &lt;code&gt;from&lt;/code&gt; attributes are all absent.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="on-completion" type="xsl:sequence-constructor-or-select"/&gt;
  
  &lt;xs:element name="on-empty"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor-or-select"/&gt;
  
  &lt;xs:element name="on-non-empty"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="otherwise" 
              type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="output" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent &gt;
        &lt;xs:extension base="xsl:element-only-generic-element-type"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="method" type="xsl:method"/&gt;
          &lt;xs:attribute name="allow-duplicate-names" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="build-tree" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="byte-order-mark" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="cdata-section-elements" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="doctype-public" type="xs:string"/&gt;
          &lt;xs:attribute name="doctype-system" type="xs:string"/&gt;
          &lt;xs:attribute name="encoding" type="xs:string"/&gt;
          &lt;xs:attribute name="escape-solidus" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="escape-uri-attributes" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="html-version" type="xs:decimal"/&gt;
          &lt;xs:attribute name="include-content-type" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="indent" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="item-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="json-lines" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="json-node-output-method" type="xsl:method"/&gt;
          &lt;xs:attribute name="media-type" type="xs:string"/&gt;
          &lt;xs:attribute name="normalization-form" type="xs:NMTOKEN"/&gt;
          &lt;xs:attribute name="omit-xml-declaration" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="parameter-document" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="standalone" type="xsl:yes-or-no-or-omit"/&gt;
          &lt;xs:attribute name="suppress-indentation" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="undeclare-prefixes" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="use-character-maps" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="version" type="xs:NMTOKEN"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_method" type="xs:string"/&gt;
          &lt;xs:attribute name="_allow-duplicate-names" type="xs:string"/&gt;
          &lt;xs:attribute name="_build-tree" type="xs:string"/&gt;
          &lt;xs:attribute name="_byte-order-mark" type="xs:string"/&gt;
          &lt;xs:attribute name="_cdata-section-elements" type="xs:string"/&gt;
          &lt;xs:attribute name="_doctype-public" type="xs:string"/&gt;
          &lt;xs:attribute name="_doctype-system" type="xs:string"/&gt;
          &lt;xs:attribute name="_encoding" type="xs:string"/&gt;
          &lt;xs:attribute name="_escape-solidus" type="xs:string"/&gt;
          &lt;xs:attribute name="_escape-uri-attributes" type="xs:string"/&gt;
          &lt;xs:attribute name="_html-version" type="xs:string"/&gt;
          &lt;xs:attribute name="_include-content-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_indent" type="xs:string"/&gt;
          &lt;xs:attribute name="_item-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_json-lines" type="xs:string"/&gt;
          &lt;xs:attribute name="_json-node-output-method" type="xs:string"/&gt;
          &lt;xs:attribute name="_media-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_normalization-form" type="xs:string"/&gt;
          &lt;xs:attribute name="_omit-xml-declaration" type="xs:string"/&gt;
          &lt;xs:attribute name="_parameter-document" type="xs:string"/&gt;
          &lt;xs:attribute name="_standalone" type="xs:string"/&gt;
          &lt;xs:attribute name="_suppress-indentation" type="xs:string"/&gt;
          &lt;xs:attribute name="_undeclare-prefixes" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt;
          &lt;xs:attribute name="_version" type="xs:string"/&gt;
          &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="output-character"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="character" type="xsl:char"/&gt;
          &lt;xs:attribute name="string" type="xs:string"/&gt;
          &lt;xs:attribute name="_character" type="xs:string"/&gt;
          &lt;xs:attribute name="_string" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@character | @_character)"/&gt;
          &lt;xs:assert test="exists(@string | @_string)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="override"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:use-package&lt;/code&gt; and defines 
            any overriding definitions of components that the containing package wishes to make 
            to the components made available from a library package.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:template"/&gt;
            &lt;xs:element ref="xsl:function"/&gt;
            &lt;xs:element ref="xsl:variable"/&gt;
            &lt;xs:element ref="xsl:param"/&gt;
            &lt;xs:element ref="xsl:attribute-set"/&gt;
          &lt;/xs:choice&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
    
  &lt;xs:element name="package"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xs:element ref="xsl:expose"/&gt;
              &lt;xs:element ref="xsl:declaration"/&gt;
              &lt;xs:any namespace="##other" processContents="lax"/&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="declared-modes" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="id" type="xs:ID"/&gt;
          &lt;xs:attribute name="name" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="package-version" type="xs:string"/&gt;
          &lt;xs:attribute name="input-type-annotations" type="xsl:input-type-annotations-type"/&gt;
          &lt;xs:attribute name="fixed-namespaces" type="xsl:fixed-namespaces-type"/&gt;
          &lt;xs:attribute name="_declared-modes" type="xs:string"/&gt;
          &lt;xs:attribute name="_id" type="xs:string"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_package-version" type="xs:string"/&gt;
          &lt;xs:attribute name="_input-type-annotations" type="xs:string"/&gt;
          &lt;xs:attribute name="_fixed-namespaces" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="param" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;Declaration of the &lt;code&gt;xsl:param&lt;/code&gt; element, used both defining function
            parameters, template parameters, parameters to &lt;code&gt;xsl:iterate&lt;/code&gt;,
            and global stylesheet parameters.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="required" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="static" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_required" type="xs:string"/&gt;
          &lt;xs:attribute name="_tunnel" type="xs:string"/&gt;
          &lt;xs:attribute name="_static" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="if (normalize-space(@static) = ('yes', 'true', '1')) 
                           then empty((*,text())) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   When the attribute &lt;code&gt;static="yes"&lt;/code&gt; is specified, the &lt;code&gt;xsl:param&lt;/code&gt;
                   element must have empty content.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  

  &lt;xs:element name="perform-sort" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:sort" minOccurs="1" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) 
                           satisfies empty($e/(@stable | @_stable))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is a static error if an &lt;code&gt;xsl:sort&lt;/code&gt; element other than the first
                   in a sequence of sibling &lt;code&gt;xsl:sort&lt;/code&gt; elements has a &lt;code&gt;stable&lt;/code&gt;
                   attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="preserve-space" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="elements" type="xsl:nametests"/&gt;
          &lt;xs:attribute name="_elements" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@elements | @_elements)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="processing-instruction" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="record"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;  
          &lt;xs:attribute name="as" form="qualified" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="duplicates" form="qualified" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="_as" form="qualified" type="xs:string"/&gt;
          &lt;xs:attribute name="_duplicates" form="qualified" type="xs:string"/&gt;
          &lt;xs:attributeGroup ref="xsl:literal-result-element-attributes"/&gt;
          &lt;xs:anyAttribute namespace="##local" processContents="lax"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="record-type" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:field" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="extensible" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_extensible" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="result-document" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="format" type="xsl:avt"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="href" type="xsl:avt"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="method" type="xsl:avt"/&gt;
          &lt;xs:attribute name="allow-duplicate-names" type="xsl:avt"/&gt;
          &lt;xs:attribute name="build-tree" type="xsl:avt"/&gt;
          &lt;xs:attribute name="byte-order-mark" type="xsl:avt"/&gt;
          &lt;xs:attribute name="cdata-section-elements" type="xsl:avt"/&gt;
          &lt;xs:attribute name="doctype-public" type="xsl:avt"/&gt;
          &lt;xs:attribute name="doctype-system" type="xsl:avt"/&gt;
          &lt;xs:attribute name="encoding" type="xsl:avt"/&gt;
          &lt;xs:attribute name="escape-solidus" type="xsl:avt"/&gt;
          &lt;xs:attribute name="escape-uri-attributes" type="xsl:avt"/&gt;
          &lt;xs:attribute name="html-version" type="xsl:avt"/&gt;
          &lt;xs:attribute name="include-content-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="indent" type="xsl:avt"/&gt;
          &lt;xs:attribute name="item-separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="json-lines" type="xsl:avt"/&gt;
          &lt;xs:attribute name="json-node-output-method" type="xsl:avt"/&gt;
          &lt;xs:attribute name="media-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="normalization-form" type="xsl:avt"/&gt;
          &lt;xs:attribute name="omit-xml-declaration" type="xsl:avt"/&gt;
          &lt;xs:attribute name="parameter-document" type="xsl:avt"/&gt;
          &lt;xs:attribute name="standalone" type="xsl:avt"/&gt;
          &lt;xs:attribute name="suppress-indentation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="undeclare-prefixes" type="xsl:avt"/&gt;
          &lt;xs:attribute name="use-character-maps" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="output-version" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_format" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:attribute name="_method" type="xs:string"/&gt;
          &lt;xs:attribute name="_allow-duplicate-names" type="xs:string"/&gt;
          &lt;xs:attribute name="_build-tree" type="xs:string"/&gt;
          &lt;xs:attribute name="_byte-order-mark" type="xs:string"/&gt;
          &lt;xs:attribute name="_cdata-section-elements" type="xs:string"/&gt;
          &lt;xs:attribute name="_doctype-public" type="xs:string"/&gt;
          &lt;xs:attribute name="_doctype-system" type="xs:string"/&gt;
          &lt;xs:attribute name="_encoding" type="xs:string"/&gt;
          &lt;xs:attribute name="_escape-solidus" type="xs:string"/&gt;
          &lt;xs:attribute name="_escape-uri-attributes" type="xs:string"/&gt;
          &lt;xs:attribute name="_html-version" type="xs:string"/&gt;
          &lt;xs:attribute name="_include-content-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_indent" type="xs:string"/&gt;
          &lt;xs:attribute name="_item-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_json-lines" type="xs:string"/&gt;
          &lt;xs:attribute name="_json-node-output-method" type="xs:string"/&gt;
          &lt;xs:attribute name="_media-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_normalization-form" type="xs:string"/&gt;
          &lt;xs:attribute name="_omit-xml-declaration" type="xs:string"/&gt;
          &lt;xs:attribute name="_parameter-document" type="xs:string"/&gt;
          &lt;xs:attribute name="_standalone" type="xs:string"/&gt;
          &lt;xs:attribute name="_suppress-indentation" type="xs:string"/&gt;
          &lt;xs:attribute name="_undeclare-prefixes" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt;
          &lt;xs:attribute name="_output-version" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="select"
              substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;  
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:assert test="empty(xsl:fallback/preceding-sibling::text()[normalize-space()])"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;An xsl:fallback child must not be preceded by a non-whitespace text node.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="sequence"
              substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="sort"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
          &lt;xs:attribute name="data-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="order" type="xsl:avt" default="ascending"/&gt;
          &lt;xs:attribute name="case-order" type="xsl:avt"/&gt;
          &lt;xs:attribute name="collation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="stable" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_lang" type="xs:string"/&gt;
          &lt;xs:attribute name="_data-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_order" type="xs:string"/&gt;
          &lt;xs:attribute name="_case-order" type="xs:string"/&gt;
          &lt;xs:attribute name="_collation" type="xs:string"/&gt;
          &lt;xs:attribute name="_stable" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="source-document" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="href" type="xsl:avt"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="use-accumulators" type="xsl:accumulator-names"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-accumulators" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@href | @_href)"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="strip-space" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="elements" type="xsl:nametests"/&gt;
          &lt;xs:attribute name="_elements" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@elements | @_elements)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="stylesheet" substitutionGroup="xsl:transform"/&gt;

  &lt;xs:element name="switch" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:when" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:otherwise" minOccurs="0"/&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_select" type="xsl:avt"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="template" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:context-item" minOccurs="0" maxOccurs="1"/&gt;
            &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="match" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="priority" type="xs:decimal"/&gt;
          &lt;xs:attribute name="mode" type="xsl:modes"/&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
          &lt;xs:attribute name="_match" type="xs:string"/&gt;
          &lt;xs:attribute name="_priority" type="xs:string"/&gt;
          &lt;xs:attribute name="_mode" type="xs:string"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@match | @_match) or exists(@name | @_name)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   An &lt;code&gt;xsl:template&lt;/code&gt; element must have either a &lt;code&gt;match&lt;/code&gt; attribute or a
                   &lt;code&gt;name&lt;/code&gt; attribute, or both.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (empty(@match | @_match)) 
                           then (empty(@mode | @_mode) and empty(@priority | @_priority)) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   An &lt;code&gt;xsl:template&lt;/code&gt; element that has no &lt;code&gt;match&lt;/code&gt; attribute must have no
                   &lt;code&gt;mode&lt;/code&gt; attribute and no &lt;code&gt;priority&lt;/code&gt; attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="not(exists(@visibility | @_visibility) and empty(@name | @_name))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   An &lt;code&gt;xsl:template&lt;/code&gt; element that has no &lt;code&gt;name&lt;/code&gt; attribute must have no
                   &lt;code&gt;visibility&lt;/code&gt; attribute
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (normalize-space(@visibility) = 'abstract') 
                           then empty(* except (xsl:context-item, xsl:param)) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   If the &lt;code&gt;visibility&lt;/code&gt; attribute is present with the value &lt;code&gt;abstract&lt;/code&gt;
                   then (a) the sequence constructor defining the template body
                   must be empty: that is, the only permitted children are
                   &lt;code&gt;xsl:context-item&lt;/code&gt; and &lt;code&gt;xsl:param&lt;/code&gt;
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="not(normalize-space(@visibility) = 'abstract' and exists(@match))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   If the &lt;code&gt;visibility&lt;/code&gt; attribute is present with the value &lt;code&gt;abstract&lt;/code&gt;
                   then there must be no &lt;code&gt;match&lt;/code&gt; attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="every $e in xsl:param satisfies empty($e/(@visibility | @_visibility))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;A parameter for a template must have no &lt;code&gt;visibility&lt;/code&gt; attribute.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="text" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="cdata" type="xsl:avt"/&gt;
          &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_cdata" type="xs:string"/&gt;
          &lt;xs:attribute name="_disable-output-escaping" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:complexType name="transform-element-base-type"&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="version" type="xs:decimal" use="optional"/&gt;
        &lt;xs:attribute name="_version" type="xs:string"&gt;
          &lt;xs:annotation&gt;
            &lt;xs:documentation&gt;
              &lt;p&gt;
                 The version attribute indicates the version of XSLT that the
                 stylesheet module requires. The attribute is required, unless the
                 &lt;code&gt;xsl:stylesheet&lt;/code&gt; element is a child of an &lt;code&gt;xsl:package&lt;/code&gt; element, in
                 which case it is optional: the default is then taken from the
                 parent &lt;code&gt;xsl:package&lt;/code&gt; element.
              &lt;/p&gt;
            &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
        &lt;/xs:attribute&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="transform"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:transform-element-base-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xs:element ref="xsl:declaration"/&gt;
              &lt;xs:any namespace="##other" processContents="lax"/&gt;
              &lt;!-- weaker than XSLT 1.0 --&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="id" type="xs:ID"/&gt;
          &lt;xs:attribute name="input-type-annotations"
                        type="xsl:input-type-annotations-type"
                        default="unspecified"/&gt;
          &lt;xs:attribute name="fixed-namespaces"
                        type="xsl:fixed-namespaces-type"/&gt;
          &lt;xs:attribute name="_id" type="xs:string"/&gt;
          &lt;xs:attribute name="_input-type-annotations" type="xs:string"/&gt;
          &lt;xs:attribute name="_fixed-namespaces" type="xs:string"/&gt;
          &lt;!--* The 'static' attribute may be used on 'param' and 'variable'
              * only when they are top-level elements. *--&gt;
          &lt;xs:assert test="every $v in (.//xsl:param, .//xsl:variable)[exists(@static | @_static)] 
                           satisfies $v[parent::xsl:stylesheet or parent::xsl:transform or parent::xsl:override]"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   The static attribute must not be present on an &lt;code&gt;xsl:variable&lt;/code&gt; or
                   &lt;code&gt;xsl:param&lt;/code&gt; element unless it is a top-level element.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="every $prefix in (@exclude-result-prefixes[not(. = '#all')], 
                                             @extension-element-prefixes) 
                           satisfies ((if ($prefix = '#default') then '' else $prefix) = in-scope-prefixes(.))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   XTSE0808: It is a static error if a namespace prefix is used
                   within the &lt;code&gt;[xsl:]exclude-result-prefixes&lt;/code&gt; attribute and there is
                   no namespace binding in scope for that prefix.
                &lt;/p&gt;
                &lt;p&gt;
                   XTSE0809: It is a static error if the value #default is used
                   within the &lt;code&gt;[xsl:]exclude-result-prefixes&lt;/code&gt; attribute and the
                   parent element of the &lt;code&gt;[xsl:]exclude-result-prefixes&lt;/code&gt; attribute
                   has no default namespace.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="try" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:catch" minOccurs="1" maxOccurs="1"/&gt;
            &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xs:element ref="xsl:catch"/&gt;
              &lt;xs:element ref="xsl:fallback"/&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="rollback-output" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression" use="optional"/&gt;
          &lt;xs:attribute name="_rollback-output" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="use-package" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:package&lt;/code&gt; and defines a dependency
            of the containing package on another package, identified by URI in the &lt;code&gt;name&lt;/code&gt;
            attribute. The &lt;code&gt;package-version&lt;/code&gt; attribute indicates which version of the
            library package is required, or may indicate a range of versions.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="false"&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:accept"/&gt;
            &lt;xs:element ref="xsl:override"/&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="name" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="package-version" type="xs:string"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_package-version" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="value-of" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="cdata" type="xsl:avt"/&gt;
          &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_cdata" type="xs:string"/&gt;
          &lt;xs:attribute name="_disable-output-escaping" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="variable" substitutionGroup="xsl:declaration xsl:instruction"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;Declaration of the &lt;code&gt;xsl:variable&lt;/code&gt; element, used both for local
            and global variable bindings.&lt;/p&gt;
        &lt;p&gt;
           This definition takes advantage of the ability in XSD 1.1 for an element
           to belong to more than one substitution group. A global variable is a
           declaration, while a local variable can appear as an instruction in a
           sequence constructor.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
          &lt;xs:attribute name="static" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:attribute name="_static" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="if (normalize-space(@static) = ('yes', 'true', '1')) 
                           then (exists(@_visibility) or normalize-space(@visibility) 
                                       = ('', 'private', 'final')) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   When the static attribute is present with the value yes, the
                   visibility attribute must not have a value other than private or
                   final.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (normalize-space(@static) = ('yes', 'true', '1')) 
                           then (empty((*, text())) and exists(@select | @_select)) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   When the attribute &lt;code&gt;static="yes"&lt;/code&gt; is specified, the &lt;code&gt;xsl:variable&lt;/code&gt;
                   element must have empty content, and the &lt;code&gt;select&lt;/code&gt; attribute must
                   be present to define the value of the variable.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="when"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="test" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_test" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@test | @_test)"/&gt;
          &lt;xs:assert test="not(exists(@select | @_select) and 
            (exists(* except xsl:fallback) or exists(text()[normalize-space()])))"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="where-populated"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor"/&gt;

  &lt;xs:element name="with-param"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_tunnel" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt; PART C: definition of literal result elements There are three ways to define
      the literal result elements permissible in a stylesheet. (a) do nothing. This allows any
      element to be used as a literal result element, provided it is not in the XSLT namespace (b)
      declare all permitted literal result elements as members of the &lt;code&gt;xsl:literal-result-element&lt;/code&gt;
      substitution group (c) redefine the model group xsl:result-elements to accommodate all
      permitted literal result elements. Literal result elements are allowed to take certain
      attributes in the XSLT namespace. These are defined in the attribute group
      &lt;code&gt;literal-result-element-attributes&lt;/code&gt;, which can be included in the definition of any literal
      result element. &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;xs:element name="literal-result-element" abstract="true" type="xs:anyType"/&gt;

  &lt;xs:attributeGroup name="literal-result-element-attributes"&gt;
    &lt;xs:attribute name="default-collation" 
                  form="qualified" 
                  type="xsl:uri-list"/&gt;
    &lt;xs:attribute name="default-mode" 
                  form="qualified"  
                  type="xsl:default-mode-type"/&gt;
    &lt;xs:attribute name="default-validation" 
                  form="qualified" 
                  type="xsl:validation-strip-or-preserve"
                  default="strip"/&gt;
    &lt;xs:attribute name="expand-text" 
                  form="qualified"  
                  type="xsl:yes-or-no"/&gt;
    &lt;xs:attribute name="extension-element-prefixes" 
                  form="qualified" 
                  type="xsl:prefix-list"/&gt;
    &lt;xs:attribute name="exclude-result-prefixes" 
                  form="qualified" 
                  type="xsl:prefix-list-or-all"/&gt;
    &lt;xs:attribute name="inherit-namespaces"
                  form="qualified"
                  type="xsl:yes-or-no"
                  default="yes"/&gt;
    &lt;xs:attribute name="schema-role"
                  form="qualified"
                  type="xs:NCName"
                  default="yes"/&gt;
    &lt;xs:attribute name="use-attribute-sets"
                  form="qualified"
                  type="xsl:EQNames"
                  default=""/&gt;
    &lt;xs:attribute name="use-when" 
                  form="qualified" 
                  type="xsl:expression"/&gt;
    &lt;xs:attribute name="version" 
                  form="qualified" 
                  type="xs:decimal"/&gt;
    &lt;xs:attribute name="type" 
                  form="qualified" 
                  type="xsl:EQName"/&gt;
    &lt;xs:attribute name="validation" 
                  form="qualified" 
                  type="xsl:validation-type"/&gt;
    &lt;xs:attribute name="xpath-default-namespace" 
                  form="qualified" 
                  type="xs:anyURI"/&gt;
  &lt;/xs:attributeGroup&gt;

  &lt;xs:group name="result-elements"&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="xsl:literal-result-element"/&gt;
      &lt;xs:any namespace="##other" processContents="lax"/&gt;
      &lt;xs:any namespace="##local" processContents="lax"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;


  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      &lt;p&gt;
         PART D: definitions of simple types used in stylesheet attributes
      &lt;/p&gt;
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;xs:simpleType name="accumulator-names"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;use-accumulators&lt;/code&gt; attribute of &lt;code&gt;xsl:source-document&lt;/code&gt;, 
           &lt;code&gt;xsl:merge-source&lt;/code&gt;, or &lt;code&gt;xsl:global-context-item&lt;/code&gt;: 
           either a list, each member being a QName; or the value &lt;code&gt;#all&lt;/code&gt;
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:list itemType="xsl:EQName"/&gt;
      &lt;/xs:simpleType&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#all"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt; 
  
  &lt;xs:simpleType name="avt"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This type is used for all attributes that allow an attribute value
           template. The general rules for the syntax of attribute value templates,
           and the specific rules for each such attribute, are described in the
           XSLT 4.0 Recommendation.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:string"/&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="char"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A string containing exactly one character.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:length value="1"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

           
  &lt;xs:simpleType name="char-optionally-expanded"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A string containing either a single character, or a single character
           followed by a colon followed by an arbitrary string
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:pattern value=".(:.*)?"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt; 

           
  &lt;xs:simpleType name="component-kind-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes a kind of component within a package.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="template"/&gt;
      &lt;xs:enumeration value="function"/&gt;
      &lt;xs:enumeration value="variable"/&gt;
      &lt;xs:enumeration value="attribute-set"/&gt;
      &lt;xs:enumeration value="mode"/&gt;
      &lt;xs:enumeration value="*"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="default-mode-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;default-mode&lt;/code&gt; attribute of &lt;code&gt;xsl:stylesheet&lt;/code&gt;, 
           &lt;code&gt;xsl:transform&lt;/code&gt;, &lt;code&gt;xsl:package&lt;/code&gt;
           (or any other xsl:* element): either a QName or #unnamed.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#unnamed"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="component-test"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt; A NameTest or a named function reference. &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:nametest xsl:named-function-reference"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="component-tests"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt; A list of NameTests or named function references&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:list itemType="xsl:component-test"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="expression"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           An XPath 4.0 expression.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value=".+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="fixed-namespaces-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
          A sequence of tokens, each of which may be one of #default, an NCName, a prefix=namespace binding, or a URI
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:list&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:union memberTypes="xsl:fixed-namespaces-type-standard xs:NCName xsl:fixed-namespaces-type-prefix-binding xs:anyURI"/&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:list&gt;
 
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="fixed-namespaces-type-standard"&gt;
    &lt;xs:restriction base="xs:token"&gt;
       &lt;xs:enumeration value="#standard"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="fixed-namespaces-type-prefix-binding"&gt;
    &lt;xs:restriction base="xs:string"&gt;
       &lt;xs:pattern value="([\i-[:]][\c-[:]]*:)=.+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="item-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           An XPath 4.0 ItemType
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value=".+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="input-type-annotations-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes how type annotations in source documents are handled.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="preserve"/&gt;
      &lt;xs:enumeration value="strip"/&gt;
      &lt;xs:enumeration value="unspecified"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="level"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;level&lt;/code&gt; attribute of &lt;code&gt;xsl:number&lt;/code&gt;: 
           one of &lt;code&gt;single&lt;/code&gt;, &lt;code&gt;multiple&lt;/code&gt;, or &lt;code&gt;any&lt;/code&gt;.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="single"/&gt;
      &lt;xs:enumeration value="multiple"/&gt;
      &lt;xs:enumeration value="any"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="mode"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;mode&lt;/code&gt; attribute of &lt;code&gt;xsl:apply-templates&lt;/code&gt;: 
           either a QName, or &lt;code&gt;#current&lt;/code&gt;,
           or &lt;code&gt;#unnamed&lt;/code&gt;, or &lt;code&gt;#default&lt;/code&gt;.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#default"/&gt;
          &lt;xs:enumeration value="#unnamed"/&gt;
          &lt;xs:enumeration value="#current"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="modes"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;mode&lt;/code&gt; attribute of &lt;code&gt;xsl:template&lt;/code&gt;: either a list, each member being
           either a QName or &lt;code&gt;#default&lt;/code&gt; or &lt;code&gt;#unnamed&lt;/code&gt;; or the value &lt;code&gt;#all&lt;/code&gt;
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction&gt;
          &lt;xs:simpleType&gt;
            &lt;xs:list&gt;
              &lt;xs:simpleType&gt;
                &lt;xs:union memberTypes="xsl:EQName"&gt;
                  &lt;xs:simpleType&gt;
                    &lt;xs:restriction base="xs:token"&gt;
                      &lt;xs:enumeration value="#default"/&gt;
                      &lt;xs:enumeration value="#unnamed"/&gt;
                    &lt;/xs:restriction&gt;
                  &lt;/xs:simpleType&gt;
                &lt;/xs:union&gt;
              &lt;/xs:simpleType&gt;
            &lt;/xs:list&gt;
          &lt;/xs:simpleType&gt;
          &lt;xs:assertion test="count($value) = count(distinct-values($value))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   XTSE0550: It is a static error if the same token is included
                   more than once in the list.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assertion&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#all"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

   &lt;xs:simpleType name="named-function-reference"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt; In simple terms, this is an EQName followed by "#arity" where "arity" is a non-negative integer. However,
          XSD doesn't allow us to reuse the definition of EQName in this way, so it has to be defined from scratch. The simplest
          way to do this is with an assertion. However, the assertion cannot exploit types such as &lt;code&gt;xsl:EQName&lt;/code&gt; defined in this
        schema&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value="((Q\{.*\})|([\i-[:]][\c-[:]]*:))?[\i-[:]][\c-[:]]*#[0-9]+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="nametest"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt; A list of NameTests, as defined in the XPath 31 Recommendation. Each NameTest is either
          an EQName, or "*", or "prefix:*", or "*:localname", or the wildcard Q{uri}*. &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="*"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:pattern value="[\i-[:]][\c-[:]]*:\*"/&gt;
          &lt;xs:pattern value="\*:[\i-[:]][\c-[:]]*"/&gt;
          &lt;xs:pattern value="Q\{[^}]*\}\*"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="nametests"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt; A list of NameTests, as defined in the XPath 4.0 Recommendation. Each NameTest is either
          a QName, or "*", or "prefix:*", or "*:localname" &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:list itemType="xsl:nametest"/&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="on-multiple-match-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes the action to be taken when there are several template rules
           to match an item in a given mode.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="use-last"/&gt;
      &lt;xs:enumeration value="fail"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="on-no-match-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes the action to be taken when there is no template rule to match
           an item in a given mode.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="deep-copy"/&gt;
      &lt;xs:enumeration value="shallow-copy"/&gt;
      &lt;xs:enumeration value="shallow-copy-all"/&gt;
      &lt;xs:enumeration value="deep-skip"/&gt;
      &lt;xs:enumeration value="shallow-skip"/&gt;
      &lt;xs:enumeration value="text-only-copy"/&gt;
      &lt;xs:enumeration value="fail"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefix-list-or-all"&gt;
    &lt;xs:union memberTypes="xsl:prefix-list"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#all"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefix-list"&gt;
    &lt;xs:list itemType="xsl:prefix-or-default"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="method"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;method&lt;/code&gt; attribute of &lt;code&gt;xsl:output&lt;/code&gt;: Either one of the recognized names
           "xml", "xhtml", "html", "text", "json", or "adaptive",
            or an EQName that must include a prefix or namespace URI.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName-in-namespace"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="xml"/&gt;
          &lt;xs:enumeration value="xhtml"/&gt;
          &lt;xs:enumeration value="html"/&gt;
          &lt;xs:enumeration value="text"/&gt;
          &lt;xs:enumeration value="json"/&gt;
          &lt;xs:enumeration value="adaptive"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="pattern"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A match pattern as defined in the XSLT 4.0 Recommendation. The syntax
           for patterns is a restricted form of the syntax for XPath 4.0
           expressions. 
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:expression"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefix-or-default"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Either a namespace prefix, or &lt;code&gt;#default&lt;/code&gt;. Used in the &lt;code&gt;xsl:namespace-alias&lt;/code&gt;
           element.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xs:NCName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#default"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="EQNames"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A list of QNames. Used in the &lt;code&gt;[xsl:]use-attribute-sets&lt;/code&gt; attribute of
           various elements, and in the &lt;code&gt;cdata-section-elements&lt;/code&gt; attribute of
           &lt;code&gt;xsl:output&lt;/code&gt;.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:list itemType="xsl:EQName"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="EQName"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           An extended QName. This schema does not use the built-in type &lt;code&gt;xs:QName&lt;/code&gt;,
           but rather defines its own QName type. This may be either a local name,
           or a prefixed QName, or a name written using the extended QName notation
           &lt;code&gt;Q{uri}[prefix:]local&lt;/code&gt;
        &lt;/p&gt;
        &lt;p&gt;In XSLT 4.0, where a QName is used in the &lt;code&gt;name&lt;/code&gt; attribute
        of (say) &lt;code&gt;xsl:template&lt;/code&gt; or &lt;code&gt;xsl:call-template&lt;/code&gt;, the prefix
        does not have to be bound in an XML namespace declaration; rather it can be bound
        in a &lt;code&gt;fixed-namespaces&lt;/code&gt; attribute on the &lt;code&gt;xsl:stylesheet&lt;/code&gt;
        element. Therefore, the built-in &lt;code&gt;xs:QName&lt;/code&gt; type cannot be used.
        This schema does not attempt to verify that namespace prefixes have been
        properly declared.&lt;/p&gt;
        
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xs:NCName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:pattern value="[\i-[:]][\c-[:]]*:[\i-[:]][\c-[:]]*"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:pattern value="Q\{[^{}]*\}[\i-[:]][\c-[:]]*(:[\i-[:]][\c-[:]]*)?"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="EQName-in-namespace"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A subtype of EQNames that excludes no-namespace names
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:EQName"&gt;
      &lt;xs:pattern value="Q\{.+\}.+|\i\c*:.+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="sequence-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The description of a datatype, conforming to the SequenceType production
           defined in the XPath 4.0 Recommendation
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value=".+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="streamability-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes the category to which a function belongs, with regards to its
           streaming behavior.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName-in-namespace"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="unclassified"/&gt;
          &lt;xs:enumeration value="absorbing"/&gt;
          &lt;xs:enumeration value="inspection"/&gt;
          &lt;xs:enumeration value="filter"/&gt;
          &lt;xs:enumeration value="shallow-descent"/&gt;
          &lt;xs:enumeration value="deep-descent"/&gt;
          &lt;xs:enumeration value="ascent"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="tokens"&gt;
    &lt;xs:list itemType="xs:token"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="typed-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes whether a mode is designed to match typed or untyped nodes.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="true"/&gt;
      &lt;xs:enumeration value="false"/&gt;
      &lt;xs:enumeration value="1"/&gt;
      &lt;xs:enumeration value="0"/&gt;
      &lt;xs:enumeration value="strict"/&gt;
      &lt;xs:enumeration value="lax"/&gt;
      &lt;xs:enumeration value="unspecified"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="uri-list"&gt;
    &lt;xs:list itemType="xs:anyURI"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="validation-strip-or-preserve"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes different ways of type-annotating an element or attribute.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:validation-type"&gt;
      &lt;xs:enumeration value="preserve"/&gt;
      &lt;xs:enumeration value="strip"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="validation-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes different ways of type-annotating an element or attribute.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="strict"/&gt;
      &lt;xs:enumeration value="lax"/&gt;
      &lt;xs:enumeration value="preserve"/&gt;
      &lt;xs:enumeration value="strip"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="visibility-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes the visibility of a component within a package.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="public"/&gt;
      &lt;xs:enumeration value="private"/&gt;
      &lt;xs:enumeration value="final"/&gt;
      &lt;xs:enumeration value="abstract"/&gt;
      &lt;xs:enumeration value="hidden"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="visibility-not-hidden-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes the visibility of a component within a package.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:visibility-type"&gt;
      &lt;xs:enumeration value="public"/&gt;
      &lt;xs:enumeration value="private"/&gt;
      &lt;xs:enumeration value="final"/&gt;
      &lt;xs:enumeration value="abstract"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="yes-or-no"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           One of the values "yes" or "no": the values "true" or "false", or "1" or
           "0" are accepted as synonyms.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="true"/&gt;
      &lt;xs:enumeration value="false"/&gt;
      &lt;xs:enumeration value="1"/&gt;
      &lt;xs:enumeration value="0"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="yes-or-no-or-maybe"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           One of the values "yes" or "no" or "omit". The values "true" or "false",
           or "1" or "0" are accepted as synonyms of "yes" and "no" respectively.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="true"/&gt;
      &lt;xs:enumeration value="false"/&gt;
      &lt;xs:enumeration value="1"/&gt;
      &lt;xs:enumeration value="0"/&gt;
      &lt;xs:enumeration value="maybe"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="yes-or-no-or-omit"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           One of the values "yes" or "no" or "omit". The values "true" or "false",
           or "1" or "0" are accepted as synonyms of "yes" and "no" respectively.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="true"/&gt;
      &lt;xs:enumeration value="false"/&gt;
      &lt;xs:enumeration value="1"/&gt;
      &lt;xs:enumeration value="0"/&gt;
      &lt;xs:enumeration value="omit"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="zero-digit"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A digit that has the numerical value zero.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:char"&gt;
      &lt;xs:pattern value="\p{Nd}"/&gt;
      &lt;xs:assertion test="matches(string-join(codepoints-to-string(
           for $i in 0 to 9 return string-to-codepoints($value) + $i), ''), '\p{Nd}{10}')"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;
</span></pre><pre class="font-size: small" xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
           xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning"
           targetNamespace="http://www.w3.org/1999/XSL/Transform"
           elementFormDefault="qualified"
           vc:minVersion="1.1"&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      &lt;p&gt;
         This is an XSD 1.1 schema for XSLT 4.0 stylesheets. It defines all the
         elements that appear in the XSLT namespace; it also provides hooks that
         allow the inclusion of user-defined literal result elements, extension
         instructions, and top-level data elements.
      &lt;/p&gt;
      &lt;p&gt;
         This schema is available for use under the conditions of the W3C Software
         License published at
         http://www.w3.org/Consortium/Legal/copyright-software-19980720
      &lt;/p&gt;
      &lt;p&gt;
         The schema is organized as follows:
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;
           PART A: definitions of complex types and model groups used as the basis
           for element definitions
        &lt;/li&gt;
        &lt;li&gt;
           PART B: definitions of individual XSLT elements
        &lt;/li&gt;
        &lt;li&gt;
           PART C: definitions for literal result elements
        &lt;/li&gt;
        &lt;li&gt;
           PART D: definitions of simple types used in attribute definitions
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;
         The schema has a number of limitations:
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;
           The XSLT specification allows additional elements and attributes to be
           present where forwards compatibility is invoked. This schema does not.
        &lt;/li&gt;
        &lt;li&gt;
           The XSLT specification allows arbitrary content in a part of the
           stylesheet that is excluded by virtue of a use-when attribute. This
           schema does not.
        &lt;/li&gt;
        &lt;li&gt;
           The handling of literal result elements in this schema is imperfect;
           although various options are allowed, none matches the specification
           exactly. For example, the content of a literal result element uses lax
           validation, which permits child elements in the XSLT namespace that have
           no declaration in this schema.
        &lt;/li&gt;
        &lt;li&gt;
           The schema makes no attempt to check XPath expressions for syntactic or
           semantic correctness, nor to check that component references are
           resolved (for example that a template named in &lt;code&gt;xsl:call-template&lt;/code&gt; has a
           declaration). Doing this in general requires cross-document validation,
           which is beyond the scope of XSD.
        &lt;/li&gt;
        &lt;li&gt;
           The XSLT specification allows &lt;code&gt;xsl:note&lt;/code&gt; elements to appear
           anywhere, with arbitrary content. This schema does not: for example, it does
           not allow &lt;code&gt;xsl:note&lt;/code&gt; as a child of an element such as &lt;code&gt;xsl:text&lt;/code&gt;
           or &lt;code&gt;xsl:strip-space&lt;/code&gt;.
        &lt;/li&gt;
        &lt;li&gt;
           The schema imports the schema for XSD 1.0 schema documents. In
           stylesheets that contain an inline XSD 1.1 schema, this import should be
           replaced with one for the schema for XSD 1.1 schema documents.
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;!--
The declaration of xml:space and xml:lang may need to be commented out because
of problems processing the schema using various tools
--&gt;

  &lt;xs:import namespace="http://www.w3.org/XML/1998/namespace"/&gt;
  &lt;!--schemaLocation="http://www.w3.org/2001/xml.xsd"--&gt;

  &lt;!-- 
    An XSLT stylesheet may contain an in-line schema within an xsl:import-schema element,
    so the Schema for schemas needs to be imported. We use the XSD 1.1 version.
--&gt;

  &lt;xs:import namespace="http://www.w3.org/2001/XMLSchema"
             schemaLocation="http://www.w3.org/TR/xmlschema11-1/XMLSchema.xsd"/&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      &lt;p&gt;
         PART A: definitions of complex types and model groups used as the basis
         for element definitions
      &lt;/p&gt;
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  
  &lt;xs:defaultOpenContent&gt;
    &lt;!-- Allow xsl:note anywhere --&gt;
    &lt;xs:any processContents="strict" 
            namespace="##targetNamespace"
            notQName="xsl:accept 
                      xsl:accumulator 
                      xsl:accumulator-rule 
                      xsl:analyze-string 
                      xsl:apply-imports 
                      xsl:apply-templates 
                      xsl:array 
                      xsl:assert 
                      xsl:attribute 
                      xsl:attribute-set 
                      xsl:break 
                      xsl:call-template 
                      xsl:catch 
                      xsl:character-map 
                      xsl:choose 
                      xsl:comment 
                      xsl:context-item 
                      xsl:copy 
                      xsl:copy-of 
                      xsl:document 
                      xsl:decimal-format 
                      xsl:element 
                      xsl:evaluate 
                      xsl:expose 
                      xsl:fallback
                      xsl:field 
                      xsl:for-each 
                      xsl:for-each-group 
                      xsl:fork 
                      xsl:function 
                      xsl:global-context-item 
                      xsl:if 
                      xsl:import 
                      xsl:import-schema 
                      xsl:include 
                      xsl:iterate 
                      xsl:key 
                      xsl:map 
                      xsl:map-entry 
                      xsl:matching-substring 
                      xsl:merge 
                      xsl:merge-action 
                      xsl:merge-key 
                      xsl:merge-source 
                      xsl:message 
                      xsl:mode 
                      xsl:namespace 
                      xsl:namespace-alias 
                      xsl:next-iteration 
                      xsl:next-match 
                      xsl:non-matching-substring 
                      xsl:number 
                      xsl:on-completion 
                      xsl:on-empty 
                      xsl:on-non-empty 
                      xsl:otherwise 
                      xsl:output 
                      xsl:output-character 
                      xsl:override 
                      xsl:package
                      xsl:package-location
                      xsl:param 
                      xsl:perform-sort 
                      xsl:preserve-space 
                      xsl:processing-instruction
                      xsl:record 
                      xsl:record-type 
                      xsl:result-document
                      xsl:select
                      xsl:sequence 
                      xsl:sort 
                      xsl:source-document 
                      xsl:strip-space 
                      xsl:stylesheet 
                      xsl:switch 
                      xsl:template 
                      xsl:text 
                      xsl:transform 
                      xsl:try 
                      xsl:use-package 
                      xsl:value-of 
                      xsl:variable 
                      xsl:when 
                      xsl:where-populated 
                      xsl:with-param
            "/&gt;
  &lt;/xs:defaultOpenContent&gt;
  
  &lt;xs:complexType name="generic-element-type" mixed="true"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This complex type provides a generic supertype for all XSLT elements except 
           &lt;code&gt;xsl:record&lt;/code&gt;; it contains the definitions of the standard attributes 
           that may appear on any element.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:attribute name="default-collation" type="xsl:uri-list"/&gt;
    &lt;xs:attribute name="default-mode" type="xsl:default-mode-type"/&gt;
    &lt;xs:attribute name="default-validation"
                  type="xsl:validation-strip-or-preserve"
                  default="strip"/&gt;
    &lt;xs:attribute name="exclude-result-prefixes" type="xsl:prefix-list-or-all"/&gt;
    &lt;xs:attribute name="expand-text" type="xsl:yes-or-no"/&gt;
    &lt;xs:attribute name="extension-element-prefixes" type="xsl:prefix-list"/&gt;
    &lt;xs:attribute name="schema-role" type="xs:NCName"/&gt;
    &lt;xs:attribute name="use-when" type="xsl:expression"/&gt;
    &lt;xs:attribute name="xpath-default-namespace" type="xs:anyURI"/&gt;
    &lt;xs:attribute name="_default-collation" type="xs:string"/&gt;
    &lt;xs:attribute name="_default-mode" type="xs:string"/&gt;
    &lt;xs:attribute name="_default-validation" type="xs:string"/&gt;
    &lt;xs:attribute name="_exclude-result-prefixes" type="xs:string"/&gt;
    &lt;xs:attribute name="_expand-text" type="xs:string"/&gt;
    &lt;xs:attribute name="_extension-element-prefixes" type="xs:string"/&gt;
    &lt;xs:attribute name="_schema-role" type="xs:string"/&gt;
    &lt;xs:attribute name="_use-when" type="xs:string"/&gt;
    &lt;xs:attribute name="_xpath-default-namespace" type="xs:string"/&gt;
    &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="element-only-generic-element-type" mixed="false"&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="xsl:generic-element-type"/&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="versioned-element-type" mixed="true"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This complex type provides a generic supertype for all XSLT elements with
                the exception of &lt;code&gt;xsl:output&lt;/code&gt; and &lt;code&gt;xsl:record&lt;/code&gt;; it contains the
                definitions of the &lt;code&gt;version&lt;/code&gt; attribute that may appear on any element.
                &lt;/p&gt;
        &lt;p&gt;The &lt;code&gt;xsl:output&lt;/code&gt; element does not use this definition because, although it
             has a &lt;code&gt;version&lt;/code&gt; attribute, the syntax and semantics of this attribute are
             unrelated to the standard &lt;code&gt;version&lt;/code&gt; attribute allowed on other elements.&lt;/p&gt;
        &lt;p&gt;Similarly &lt;code&gt;xsl:record&lt;/code&gt; does not use this definition because it expects
        standard attributes (including [xsl:]version) to be in the XSLT namespace.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:generic-element-type"&gt;
        &lt;xs:attribute name="version" type="xs:decimal" use="optional"/&gt;
        &lt;xs:attribute name="_version" type="xs:string"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="element-only-versioned-element-type" mixed="false"&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="xsl:versioned-element-type"&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="sequence-constructor"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This complex type provides a generic supertype for all XSLT elements
           that allow a sequence constructor as their content.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:group ref="xsl:sequence-constructor-group"
                  minOccurs="0"
                  maxOccurs="unbounded"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="sequence-constructor-and-select"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This complex type allows a sequence constructor and a select attribute.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="_select" type="xs:string"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="sequence-constructor-or-select"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This complex type allows a sequence constructor or a select attribute,
           but not both.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:restriction base="xsl:sequence-constructor-and-select"&gt;
        &lt;xs:group ref="xsl:sequence-constructor-group"
                  minOccurs="0"
                  maxOccurs="unbounded"/&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
        &lt;xs:assert test="not(exists(@select | @_select) and 
          (exists(* except xsl:fallback) or exists(text()[normalize-space()])))"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:group name="sequence-constructor-group"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This complex type provides a generic supertype for all XSLT elements
           that allow a sequence constructor as their content.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="xsl:instruction"/&gt;
      &lt;xs:element ref="xsl:record"/&gt;
      &lt;xs:group ref="xsl:result-elements"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

  &lt;xs:element name="declaration" type="xsl:generic-element-type" abstract="true"/&gt;

  &lt;xs:element name="instruction" type="xsl:versioned-element-type" abstract="true"/&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      &lt;p&gt;
         PART B: definitions of individual XSLT elements Elements are listed in
         alphabetical order.
      &lt;/p&gt;
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  
  &lt;xs:element name="accept"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:use-package&lt;/code&gt; and defines 
            any variations that the containing package wishes to make to the visibility of
            components made available from a library package. For example, it may indicate that
            some of the public components in the library package are not to be made available
            to the containing package.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="component" type="xsl:component-kind-type"/&gt;
          &lt;xs:attribute name="names" type="xsl:component-tests"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt;
          &lt;xs:attribute name="_component" type="xs:string"/&gt;
          &lt;xs:attribute name="_names" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@component | @_component)"/&gt;
          &lt;xs:assert test="exists(@names | @_names)"/&gt;
          &lt;xs:assert test="exists(@visibility | @_visibility)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="accumulator" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:accumulator-rule" minOccurs="1" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="initial-value" type="xsl:expression"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_initial-value" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="accumulator-rule"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:sequence/&gt;
          &lt;xs:attribute name="match" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="phase"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:token"&gt;
                &lt;xs:enumeration value="start"/&gt;
                &lt;xs:enumeration value="end"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="capture" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="_match" type="xs:string"/&gt;
          &lt;xs:attribute name="_phase" type="xs:string"/&gt;
          &lt;xs:attribute name="_capture" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@match | @_match)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="analyze-string" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:matching-substring" minOccurs="0"/&gt;
            &lt;xs:element ref="xsl:non-matching-substring" minOccurs="0"/&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="regex" type="xsl:avt"/&gt;
          &lt;xs:attribute name="flags" type="xsl:avt" default=""/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_regex" type="xs:string"/&gt;
          &lt;xs:attribute name="_flags" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
          &lt;xs:assert test="exists(@regex | @_regex)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="apply-imports" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="apply-templates" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:sort"/&gt;
            &lt;xs:element ref="xsl:with-param"/&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="select" type="xsl:expression" default="child::node()"/&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="mode" type="xsl:mode"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_mode" type="xs:string"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) 
                           satisfies empty($e/(@stable | @_stable))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is a static error if an &lt;code&gt;xsl:sort&lt;/code&gt; element other than the first
                   in a sequence of sibling &lt;code&gt;xsl:sort&lt;/code&gt; elements has a &lt;code&gt;stable&lt;/code&gt;
                   attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="array" 
              substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="for-each" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_for-each" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="array-member"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor-or-select"/&gt;
  
  &lt;xs:element name="assert" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="test" type="xsl:expression"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="error-code" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_test" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_error-code" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@test | @_test)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="attribute" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:avt"/&gt;
          &lt;xs:attribute name="namespace" type="xsl:avt"/&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_namespace" type="xs:string"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="attribute-set" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:attribute"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="break"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="call-template" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="catch"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="errors" type="xsl:nametests" use="optional"/&gt;
          &lt;xs:attribute name="_errors" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="character-map" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:output-character" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="use-character-maps" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="choose" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:when" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:otherwise" minOccurs="0"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="comment"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor-or-select"/&gt;
  
  &lt;xs:element name="context-item"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="as" type="xsl:item-type"/&gt;
          &lt;xs:attribute name="use"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:token"&gt;
                &lt;xs:enumeration value="required"/&gt;
                &lt;xs:enumeration value="optional"/&gt;
                &lt;xs:enumeration value="absent"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_use" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="copy" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_copy-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_inherit-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="copy-of" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="copy-accumulators" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_copy-accumulators" type="xs:string"/&gt;
          &lt;xs:attribute name="_copy-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="document" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="decimal-format" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="decimal-separator" type="xsl:char-optionally-expanded" default="."/&gt;
          &lt;xs:attribute name="grouping-separator" type="xsl:char-optionally-expanded" default=","/&gt;
          &lt;xs:attribute name="infinity" type="xs:string" default="Infinity"/&gt;
          &lt;xs:attribute name="minus-sign" type="xs:string" default="-"/&gt;
          &lt;xs:attribute name="exponent-separator" type="xsl:char-optionally-expanded" default="e"/&gt;
          &lt;xs:attribute name="NaN" type="xs:string" default="NaN"/&gt;
          &lt;xs:attribute name="percent" type="xsl:char-optionally-expanded" default="%"/&gt;
          &lt;xs:attribute name="per-mille" type="xsl:char-optionally-expanded" default="â€°"/&gt;
          &lt;xs:attribute name="zero-digit" type="xsl:zero-digit" default="0"/&gt;
          &lt;xs:attribute name="digit" type="xsl:char" default="#"/&gt;
          &lt;xs:attribute name="pattern-separator" type="xsl:char" default=";"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_decimal-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_grouping-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_infinity" type="xs:string"/&gt;
          &lt;xs:attribute name="_minus-sign" type="xs:string"/&gt;
          &lt;xs:attribute name="_exponent-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_NaN" type="xs:string"/&gt;
          &lt;xs:attribute name="_percent" type="xs:string"/&gt;
          &lt;xs:attribute name="_per-mille" type="xs:string"/&gt;
          &lt;xs:attribute name="_zero-digit" type="xs:string"/&gt;
          &lt;xs:attribute name="_digit" type="xs:string"/&gt;
          &lt;xs:attribute name="_pattern-separator" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="element" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="name" type="xsl:avt"/&gt;
          &lt;xs:attribute name="namespace" type="xsl:avt"/&gt;
          &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_namespace" type="xs:string"/&gt;
          &lt;xs:attribute name="_inherit-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="evaluate" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:with-param"/&gt;
            &lt;xs:element ref="xsl:fallback"/&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="xpath" type="xsl:expression"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="base-uri" type="xsl:avt"/&gt;
          &lt;xs:attribute name="context-item" type="xsl:expression"/&gt;
          &lt;xs:attribute name="namespace-context" type="xsl:expression"/&gt;
          &lt;xs:attribute name="schema-aware" type="xsl:avt"/&gt;
          &lt;xs:attribute name="trusted" type="xsl:avt"/&gt;
          &lt;xs:attribute name="with-params" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_xpath" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_base-uri" type="xs:string"/&gt;
          &lt;xs:attribute name="_context-item" type="xs:string"/&gt;
          &lt;xs:attribute name="_namespace-context" type="xs:string"/&gt;
          &lt;xs:attribute name="_schema-aware" type="xs:string"/&gt;
          &lt;xs:attribute name="_trusted" type="xs:string"/&gt;
          &lt;xs:attribute name="_with-params" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@xpath | @_xpath)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="expose"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:use-package&lt;/code&gt; and defines 
            the visibility of components that are made available (or not) by this package
            to other using packages.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="component" type="xsl:component-kind-type"/&gt;
          &lt;xs:attribute name="names" type="xsl:component-tests"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
          &lt;xs:attribute name="_component" type="xs:string"/&gt;
          &lt;xs:attribute name="_names" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@component | @_component)"/&gt;
          &lt;xs:assert test="exists(@names | @_names)"/&gt;
          &lt;xs:assert test="exists(@visibility | @_visibility)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="fallback"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor"/&gt;
  
  &lt;xs:element name="field"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="name" type="xs:NCName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="required" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="default" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_required" type="xs:string"/&gt;
          &lt;xs:attribute name="_default" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="for-each" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) 
                           satisfies empty($e/(@stable | @_stable))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is a static error if an &lt;code&gt;xsl:sort&lt;/code&gt; element other than the first
                   in a sequence of sibling &lt;code&gt;xsl:sort&lt;/code&gt; elements has a &lt;code&gt;stable&lt;/code&gt;
                   attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="for-each-group" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="group-by" type="xsl:expression"/&gt;
          &lt;xs:attribute name="group-adjacent" type="xsl:expression"/&gt;
          &lt;xs:attribute name="group-starting-with" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="group-ending-with" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="split-when" type="xsl:expression"/&gt;
          &lt;xs:attribute name="composite" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="collation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_group-by" type="xs:string"/&gt;
          &lt;xs:attribute name="_group-adjacent" type="xs:string"/&gt;
          &lt;xs:attribute name="_group-starting-with" type="xs:string"/&gt;
          &lt;xs:attribute name="_group-ending-with" type="xs:string"/&gt;
          &lt;xs:attribute name="_split-when" type="xs:string"/&gt;
          &lt;xs:attribute name="_composite" type="xs:string"/&gt;
          &lt;xs:attribute name="_collation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) 
                           satisfies empty($e/(@stable | @_stable))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is a static error if an &lt;code&gt;xsl:sort&lt;/code&gt; element other than the first
                   in a sequence of sibling &lt;code&gt;xsl:sort&lt;/code&gt; elements has a &lt;code&gt;stable&lt;/code&gt;
                   attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="count(((@group-by|@_group-by)[1], 
                                  (@group-adjacent|@_group-adjacent)[1], 
                                  (@group-starting-with|@_group-starting-with)[1], 
                                  (@group-ending-with|@_group-ending-with)[1],
                                  (@split-when|@_split-when)[1])) = 1"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   These four attributes are mutually exclusive: it is a static
                   error if none of these four attributes is present or if more
                   than one of them is present.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (exists(@collation|@_collation) or exists(@composite|@_composite)) 
                           then (exists(@group-by|@_group-by) or exists(@group-adjacent|@_group-adjacent)) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is an error to specify the collation attribute or the
                   composite attribute if neither the group-by attribute nor
                   group-adjacent attribute is specified.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="fork" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:choice&gt;
              &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
                &lt;xs:element ref="xsl:sequence"/&gt;
                &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
              &lt;/xs:sequence&gt;
              &lt;xs:sequence&gt;
                &lt;xs:element ref="xsl:for-each-group"/&gt;
                &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
              &lt;/xs:sequence&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="function" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="override" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
          &lt;xs:attribute name="streamability" type="xsl:streamability-type"/&gt;
          &lt;xs:attribute name="override-extension-function" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="new-each-time" type="xsl:yes-or-no-or-maybe"/&gt;
          &lt;xs:attribute name="cache" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_override" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamability" type="xs:string"/&gt;
          &lt;xs:attribute name="_override-extension-function" type="xs:string"/&gt;
          &lt;xs:attribute name="_new-each-time" type="xs:string"/&gt;
          &lt;xs:attribute name="_cache" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="every $e in xsl:param satisfies empty($e/(@visibility | @_visibility))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;A parameter for a function must have no &lt;code&gt;visibility&lt;/code&gt; attribute.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="global-context-item" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="as" type="xsl:item-type"/&gt;
          &lt;xs:attribute name="use"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:token"&gt;
                &lt;xs:enumeration value="required"/&gt;
                &lt;xs:enumeration value="optional"/&gt;
                &lt;xs:enumeration value="absent"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_use" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  

  &lt;xs:element name="if" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="test" type="xsl:expression"/&gt;
          &lt;xs:attribute name="then" type="xsl:expression"/&gt;
          &lt;xs:attribute name="else" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_test" type="xs:string"/&gt;
          &lt;xs:attribute name="_then" type="xs:string"/&gt;
          &lt;xs:attribute name="_else" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@test | @_test)"/&gt;
          &lt;xs:assert test="not(exists(@then | @_then) and 
            (exists(* except xsl:fallback) or exists(text()[normalize-space()])))"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="import" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="href" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@href | @_href)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="import-schema" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xs:schema" minOccurs="0" maxOccurs="1"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="namespace" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="role" type="xs:NCName"/&gt;
          &lt;xs:attribute name="schema-location" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="_namespace" type="xs:string"/&gt;
          &lt;xs:attribute name="_role" type="xs:string"/&gt;
          &lt;xs:attribute name="_schema-location" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@schema-location | @_schema-location) and exists(xs:schema))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   XTSE0215: It is a static error if an &lt;code&gt;xsl:import-schema&lt;/code&gt; element
                   that contains an xs:schema element has a &lt;code&gt;schema-location&lt;/code&gt;
                   attribute
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="include" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="href" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@href | @_href)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="iterate" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:on-completion" minOccurs="0" maxOccurs="1"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="key" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="match" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="use" type="xsl:expression"/&gt;
          &lt;xs:attribute name="composite" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="collation" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_match" type="xs:string"/&gt;
          &lt;xs:attribute name="_use" type="xs:string"/&gt;
          &lt;xs:attribute name="_composite" type="xs:string"/&gt;
          &lt;xs:attribute name="_collation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="exists(@match | @_match)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="map"
              substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-and-select"&gt;
          &lt;xs:attribute name="duplicates" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_duplicates" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="map-entry" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-and-select"&gt;
          &lt;xs:attribute name="key" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_key" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@key | @_key)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="matching-substring" type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="merge" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:merge-source" minOccurs="1" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:merge-action" minOccurs="1" maxOccurs="1"/&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="merge-action" type="xsl:sequence-constructor"/&gt;

  &lt;xs:element name="merge-key" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
          &lt;xs:attribute name="order" type="xsl:avt"/&gt;
          &lt;xs:attribute name="collation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="case-order" type="xsl:avt"/&gt;
          &lt;xs:attribute name="data-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_lang" type="xs:string"/&gt;
          &lt;xs:attribute name="_order" type="xs:string"/&gt;
          &lt;xs:attribute name="_collation" type="xs:string"/&gt;
          &lt;xs:attribute name="_case-order" type="xs:string"/&gt;
          &lt;xs:attribute name="_data-type" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="merge-source"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:merge-key" minOccurs="1" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xs:NCName"/&gt;
          &lt;xs:attribute name="for-each-item" type="xsl:expression"/&gt;
          &lt;xs:attribute name="for-each-source" type="xsl:expression"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="use-accumulators" type="xsl:accumulator-names"/&gt;
          &lt;xs:attribute name="sort-before-merge" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_for-each-item" type="xs:string"/&gt;
          &lt;xs:attribute name="_for-each-source" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-accumulators" type="xs:string"/&gt;
          &lt;xs:attribute name="_sort-before-merge" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="message" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="terminate" type="xsl:avt" default="no"/&gt;
          &lt;xs:attribute name="error-code" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_terminate" type="xs:string"/&gt;
          &lt;xs:attribute name="_error-code" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="mode" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="false"&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:template"/&gt; 
            &lt;xs:element ref="xsl:fallback"/&gt; 
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="use-accumulators" type="xsl:accumulator-names"/&gt;
          &lt;xs:attribute name="on-no-match" type="xsl:on-no-match-type" default="text-only-copy"/&gt;
          &lt;xs:attribute name="on-multiple-match"
                        type="xsl:on-multiple-match-type"
                        default="use-last"/&gt;
          &lt;xs:attribute name="warning-on-no-match" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="warning-on-multiple-match" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="typed" type="xsl:typed-type"/&gt;
          &lt;xs:attribute name="visibility"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xsl:visibility-type"&gt;
                &lt;xs:enumeration value="public"/&gt;
                &lt;xs:enumeration value="private"/&gt;
                &lt;xs:enumeration value="final"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_copy-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-accumulators" type="xs:string"/&gt;
          &lt;xs:attribute name="_on-no-match" type="xs:string"/&gt;
          &lt;xs:attribute name="_on-multiple-match" type="xs:string"/&gt;
          &lt;xs:attribute name="_warning-on-no-match" type="xs:string"/&gt;
          &lt;xs:attribute name="_warning-on-multiple-match" type="xs:string"/&gt;
          &lt;xs:attribute name="_typed" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;


  &lt;xs:element name="namespace" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="namespace-alias" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="stylesheet-prefix" type="xsl:prefix-or-default"/&gt;
          &lt;xs:attribute name="result-prefix" type="xsl:prefix-or-default"/&gt;
          &lt;xs:attribute name="_stylesheet-prefix" type="xs:string"/&gt;
          &lt;xs:attribute name="_result-prefix" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@stylesheet-prefix | @_stylesheet-prefix)"/&gt;
          &lt;xs:assert test="exists(@result-prefix | @_result-prefix)"/&gt;
          &lt;xs:assert test="every $prefix in (@stylesheet-prefix, @result-prefix)/normalize-space(.)[. ne '#default']
                           satisfies $prefix = in-scope-prefixes(.)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;


  &lt;xs:element name="next-iteration" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;


  &lt;xs:element name="next-match" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:with-param"/&gt;
            &lt;xs:element ref="xsl:fallback"/&gt;
          &lt;/xs:choice&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="non-matching-substring" type="xsl:sequence-constructor-or-select"/&gt;
  
  &lt;xs:element name="note" type="xs:anyType"/&gt;

  &lt;xs:element name="number" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:attribute name="value" type="xsl:expression"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="level" type="xsl:level" default="single"/&gt;
          &lt;xs:attribute name="count" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="from" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="format" type="xsl:avt" default="1"/&gt;
          &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
          &lt;xs:attribute name="letter-value" type="xsl:avt"/&gt;
          &lt;xs:attribute name="ordinal" type="xsl:avt"/&gt;
          &lt;xs:attribute name="start-at" type="xsl:avt"/&gt;
          &lt;xs:attribute name="grouping-separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="grouping-size" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_value" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_level" type="xs:string"/&gt;
          &lt;xs:attribute name="_count" type="xs:string"/&gt;
          &lt;xs:attribute name="_from" type="xs:string"/&gt;
          &lt;xs:attribute name="_format" type="xs:string"/&gt;
          &lt;xs:attribute name="_lang" type="xs:string"/&gt;
          &lt;xs:attribute name="_letter-value" type="xs:string"/&gt;
          &lt;xs:attribute name="_ordinal" type="xs:string"/&gt;
          &lt;xs:attribute name="_start-at" type="xs:string"/&gt;
          &lt;xs:attribute name="_grouping-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_grouping-size" type="xs:string"/&gt;
          &lt;xs:assert test="if (exists(@value | @_value)) 
                           then empty((@select | @_select, @count | @_count, @from | @_from)) 
                            and (exists(@_level) or normalize-space(@level)='single') 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is a static error if the value attribute of &lt;code&gt;xsl:number&lt;/code&gt; is
                   present unless the &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;level&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, 
                   and &lt;code&gt;from&lt;/code&gt; attributes are all absent.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="on-completion" type="xsl:sequence-constructor-or-select"/&gt;
  
  &lt;xs:element name="on-empty"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor-or-select"/&gt;
  
  &lt;xs:element name="on-non-empty"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="otherwise" 
              type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="output" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent &gt;
        &lt;xs:extension base="xsl:element-only-generic-element-type"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="method" type="xsl:method"/&gt;
          &lt;xs:attribute name="allow-duplicate-names" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="build-tree" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="byte-order-mark" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="canonical" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="cdata-section-elements" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="doctype-public" type="xs:string"/&gt;
          &lt;xs:attribute name="doctype-system" type="xs:string"/&gt;
          &lt;xs:attribute name="encoding" type="xs:string"/&gt;
          &lt;xs:attribute name="escape-solidus" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="escape-uri-attributes" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="html-version" type="xs:decimal"/&gt;
          &lt;xs:attribute name="include-content-type" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="indent" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="item-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="json-lines" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="json-node-output-method" type="xsl:method"/&gt;
          &lt;xs:attribute name="media-type" type="xs:string"/&gt;
          &lt;xs:attribute name="normalization-form" type="xs:NMTOKEN"/&gt;
          &lt;xs:attribute name="omit-xml-declaration" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="parameter-document" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="standalone" type="xsl:yes-or-no-or-omit"/&gt;
          &lt;xs:attribute name="suppress-indentation" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="undeclare-prefixes" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="use-character-maps" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="version" type="xs:NMTOKEN"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_method" type="xs:string"/&gt;
          &lt;xs:attribute name="_allow-duplicate-names" type="xs:string"/&gt;
          &lt;xs:attribute name="_build-tree" type="xs:string"/&gt;
          &lt;xs:attribute name="_byte-order-mark" type="xs:string"/&gt;
          &lt;xs:attribute name="_canonical" type="xs:string"/&gt;
          &lt;xs:attribute name="_cdata-section-elements" type="xs:string"/&gt;
          &lt;xs:attribute name="_doctype-public" type="xs:string"/&gt;
          &lt;xs:attribute name="_doctype-system" type="xs:string"/&gt;
          &lt;xs:attribute name="_encoding" type="xs:string"/&gt;
          &lt;xs:attribute name="_escape-solidus" type="xs:string"/&gt;
          &lt;xs:attribute name="_escape-uri-attributes" type="xs:string"/&gt;
          &lt;xs:attribute name="_html-version" type="xs:string"/&gt;
          &lt;xs:attribute name="_include-content-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_indent" type="xs:string"/&gt;
          &lt;xs:attribute name="_item-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_json-lines" type="xs:string"/&gt;
          &lt;xs:attribute name="_json-node-output-method" type="xs:string"/&gt;
          &lt;xs:attribute name="_media-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_normalization-form" type="xs:string"/&gt;
          &lt;xs:attribute name="_omit-xml-declaration" type="xs:string"/&gt;
          &lt;xs:attribute name="_parameter-document" type="xs:string"/&gt;
          &lt;xs:attribute name="_standalone" type="xs:string"/&gt;
          &lt;xs:attribute name="_suppress-indentation" type="xs:string"/&gt;
          &lt;xs:attribute name="_undeclare-prefixes" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt;
          &lt;xs:attribute name="_version" type="xs:string"/&gt;
          &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="output-character"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="character" type="xsl:char"/&gt;
          &lt;xs:attribute name="string" type="xs:string"/&gt;
          &lt;xs:attribute name="_character" type="xs:string"/&gt;
          &lt;xs:attribute name="_string" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@character | @_character)"/&gt;
          &lt;xs:assert test="exists(@string | @_string)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="override"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:use-package&lt;/code&gt; and defines 
            any overriding definitions of components that the containing package wishes to make 
            to the components made available from a library package.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:template"/&gt;
            &lt;xs:element ref="xsl:function"/&gt;
            &lt;xs:element ref="xsl:variable"/&gt;
            &lt;xs:element ref="xsl:param"/&gt;
            &lt;xs:element ref="xsl:attribute-set"/&gt;
          &lt;/xs:choice&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
    
  &lt;xs:element name="package"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xs:element ref="xsl:expose"/&gt;
              &lt;xs:element ref="xsl:declaration"/&gt;
              &lt;xs:any namespace="##other" processContents="lax"/&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="declared-modes" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="id" type="xs:ID"/&gt;
          &lt;xs:attribute name="name" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="package-version" type="xs:string"/&gt;
          &lt;xs:attribute name="input-type-annotations" type="xsl:input-type-annotations-type"/&gt;
          &lt;xs:attribute name="fixed-namespaces" type="xsl:fixed-namespaces-type"/&gt;
          &lt;xs:attribute name="_declared-modes" type="xs:string"/&gt;
          &lt;xs:attribute name="_id" type="xs:string"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_package-version" type="xs:string"/&gt;
          &lt;xs:attribute name="_input-type-annotations" type="xs:string"/&gt;
          &lt;xs:attribute name="_fixed-namespaces" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="package-location"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="href" type="xs:anyURI" use="required"/&gt;
          &lt;xs:attribute name="path-in-archive" type="xs:string"/&gt;
          &lt;xs:attribute name="archive-type" type="xs:string"/&gt;
          &lt;xs:attribute name="is-priority" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="format" type="xs:string"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:attribute name="_path-in-archive" type="xs:string"/&gt;
          &lt;xs:attribute name="_archive-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_is-priority" type="xs:string"/&gt;
          &lt;xs:attribute name="_format" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="param" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;Declaration of the &lt;code&gt;xsl:param&lt;/code&gt; element, used both defining function
            parameters, template parameters, parameters to &lt;code&gt;xsl:iterate&lt;/code&gt;,
            and global stylesheet parameters.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="required" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="static" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_required" type="xs:string"/&gt;
          &lt;xs:attribute name="_tunnel" type="xs:string"/&gt;
          &lt;xs:attribute name="_static" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="if (normalize-space(@static) = ('yes', 'true', '1')) 
                           then empty((*,text())) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   When the attribute &lt;code&gt;static="yes"&lt;/code&gt; is specified, the &lt;code&gt;xsl:param&lt;/code&gt;
                   element must have empty content.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  

  &lt;xs:element name="perform-sort" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:sort" minOccurs="1" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) 
                           satisfies empty($e/(@stable | @_stable))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is a static error if an &lt;code&gt;xsl:sort&lt;/code&gt; element other than the first
                   in a sequence of sibling &lt;code&gt;xsl:sort&lt;/code&gt; elements has a &lt;code&gt;stable&lt;/code&gt;
                   attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="preserve-space" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="elements" type="xsl:nametests"/&gt;
          &lt;xs:attribute name="_elements" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@elements | @_elements)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="processing-instruction" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="record"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;  
          &lt;xs:attribute name="as" form="qualified" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="duplicates" form="qualified" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="_as" form="qualified" type="xs:string"/&gt;
          &lt;xs:attribute name="_duplicates" form="qualified" type="xs:string"/&gt;
          &lt;xs:attributeGroup ref="xsl:literal-result-element-attributes"/&gt;
          &lt;xs:anyAttribute namespace="##local" processContents="lax"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="record-type" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:field" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="extensible" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_extensible" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="result-document" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="format" type="xsl:avt"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="href" type="xsl:avt"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="method" type="xsl:avt"/&gt;
          &lt;xs:attribute name="allow-duplicate-names" type="xsl:avt"/&gt;
          &lt;xs:attribute name="build-tree" type="xsl:avt"/&gt;
          &lt;xs:attribute name="byte-order-mark" type="xsl:avt"/&gt;
          &lt;xs:attribute name="canonical" type="xsl:avt"/&gt;
          &lt;xs:attribute name="cdata-section-elements" type="xsl:avt"/&gt;
          &lt;xs:attribute name="doctype-public" type="xsl:avt"/&gt;
          &lt;xs:attribute name="doctype-system" type="xsl:avt"/&gt;
          &lt;xs:attribute name="encoding" type="xsl:avt"/&gt;
          &lt;xs:attribute name="escape-solidus" type="xsl:avt"/&gt;
          &lt;xs:attribute name="escape-uri-attributes" type="xsl:avt"/&gt;
          &lt;xs:attribute name="html-version" type="xsl:avt"/&gt;
          &lt;xs:attribute name="include-content-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="indent" type="xsl:avt"/&gt;
          &lt;xs:attribute name="item-separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="json-lines" type="xsl:avt"/&gt;
          &lt;xs:attribute name="json-node-output-method" type="xsl:avt"/&gt;
          &lt;xs:attribute name="media-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="normalization-form" type="xsl:avt"/&gt;
          &lt;xs:attribute name="omit-xml-declaration" type="xsl:avt"/&gt;
          &lt;xs:attribute name="parameter-document" type="xsl:avt"/&gt;
          &lt;xs:attribute name="standalone" type="xsl:avt"/&gt;
          &lt;xs:attribute name="suppress-indentation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="undeclare-prefixes" type="xsl:avt"/&gt;
          &lt;xs:attribute name="use-character-maps" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="output-version" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_format" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:attribute name="_method" type="xs:string"/&gt;
          &lt;xs:attribute name="_allow-duplicate-names" type="xs:string"/&gt;
          &lt;xs:attribute name="_build-tree" type="xs:string"/&gt;
          &lt;xs:attribute name="_byte-order-mark" type="xs:string"/&gt;
          &lt;xs:attribute name="_canonical" type="xs:string"/&gt;
          &lt;xs:attribute name="_cdata-section-elements" type="xs:string"/&gt;
          &lt;xs:attribute name="_doctype-public" type="xs:string"/&gt;
          &lt;xs:attribute name="_doctype-system" type="xs:string"/&gt;
          &lt;xs:attribute name="_encoding" type="xs:string"/&gt;
          &lt;xs:attribute name="_escape-solidus" type="xs:string"/&gt;
          &lt;xs:attribute name="_escape-uri-attributes" type="xs:string"/&gt;
          &lt;xs:attribute name="_html-version" type="xs:string"/&gt;
          &lt;xs:attribute name="_include-content-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_indent" type="xs:string"/&gt;
          &lt;xs:attribute name="_item-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_json-lines" type="xs:string"/&gt;
          &lt;xs:attribute name="_json-node-output-method" type="xs:string"/&gt;
          &lt;xs:attribute name="_media-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_normalization-form" type="xs:string"/&gt;
          &lt;xs:attribute name="_omit-xml-declaration" type="xs:string"/&gt;
          &lt;xs:attribute name="_parameter-document" type="xs:string"/&gt;
          &lt;xs:attribute name="_standalone" type="xs:string"/&gt;
          &lt;xs:attribute name="_suppress-indentation" type="xs:string"/&gt;
          &lt;xs:attribute name="_undeclare-prefixes" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt;
          &lt;xs:attribute name="_output-version" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="select"
              substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;  
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:assert test="empty(xsl:fallback/preceding-sibling::text()[normalize-space()])"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;An xsl:fallback child must not be preceded by a non-whitespace text node.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="sequence"
              substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="sort"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
          &lt;xs:attribute name="data-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="order" type="xsl:avt" default="ascending"/&gt;
          &lt;xs:attribute name="case-order" type="xsl:avt"/&gt;
          &lt;xs:attribute name="collation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="stable" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_lang" type="xs:string"/&gt;
          &lt;xs:attribute name="_data-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_order" type="xs:string"/&gt;
          &lt;xs:attribute name="_case-order" type="xs:string"/&gt;
          &lt;xs:attribute name="_collation" type="xs:string"/&gt;
          &lt;xs:attribute name="_stable" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="source-document" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="href" type="xsl:avt"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="use-accumulators" type="xsl:accumulator-names"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-accumulators" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@href | @_href)"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="strip-space" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="elements" type="xsl:nametests"/&gt;
          &lt;xs:attribute name="_elements" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@elements | @_elements)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="stylesheet" substitutionGroup="xsl:transform"/&gt;

  &lt;xs:element name="switch" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:when" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:otherwise" minOccurs="0"/&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_select" type="xsl:avt"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="template" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:context-item" minOccurs="0" maxOccurs="1"/&gt;
            &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="match" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="priority" type="xs:decimal"/&gt;
          &lt;xs:attribute name="mode" type="xsl:modes"/&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
          &lt;xs:attribute name="_match" type="xs:string"/&gt;
          &lt;xs:attribute name="_priority" type="xs:string"/&gt;
          &lt;xs:attribute name="_mode" type="xs:string"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@match | @_match) or exists(@name | @_name)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   An &lt;code&gt;xsl:template&lt;/code&gt; element must have either a &lt;code&gt;match&lt;/code&gt; attribute or a
                   &lt;code&gt;name&lt;/code&gt; attribute, or both.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (empty(@match | @_match)) 
                           then (empty(@mode | @_mode) and empty(@priority | @_priority)) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   An &lt;code&gt;xsl:template&lt;/code&gt; element that has no &lt;code&gt;match&lt;/code&gt; attribute must have no
                   &lt;code&gt;mode&lt;/code&gt; attribute and no &lt;code&gt;priority&lt;/code&gt; attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="not(exists(@visibility | @_visibility) and empty(@name | @_name))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   An &lt;code&gt;xsl:template&lt;/code&gt; element that has no &lt;code&gt;name&lt;/code&gt; attribute must have no
                   &lt;code&gt;visibility&lt;/code&gt; attribute
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (normalize-space(@visibility) = 'abstract') 
                           then empty(* except (xsl:context-item, xsl:param)) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   If the &lt;code&gt;visibility&lt;/code&gt; attribute is present with the value &lt;code&gt;abstract&lt;/code&gt;
                   then (a) the sequence constructor defining the template body
                   must be empty: that is, the only permitted children are
                   &lt;code&gt;xsl:context-item&lt;/code&gt; and &lt;code&gt;xsl:param&lt;/code&gt;
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="not(normalize-space(@visibility) = 'abstract' and exists(@match))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   If the &lt;code&gt;visibility&lt;/code&gt; attribute is present with the value &lt;code&gt;abstract&lt;/code&gt;
                   then there must be no &lt;code&gt;match&lt;/code&gt; attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="every $e in xsl:param satisfies empty($e/(@visibility | @_visibility))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;A parameter for a template must have no &lt;code&gt;visibility&lt;/code&gt; attribute.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="text" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="cdata" type="xsl:avt"/&gt;
          &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_cdata" type="xs:string"/&gt;
          &lt;xs:attribute name="_disable-output-escaping" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:complexType name="transform-element-base-type"&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="version" type="xs:decimal" use="optional"/&gt;
        &lt;xs:attribute name="_version" type="xs:string"&gt;
          &lt;xs:annotation&gt;
            &lt;xs:documentation&gt;
              &lt;p&gt;
                 The version attribute indicates the version of XSLT that the
                 stylesheet module requires. The attribute is required, unless the
                 &lt;code&gt;xsl:stylesheet&lt;/code&gt; element is a child of an &lt;code&gt;xsl:package&lt;/code&gt; element, in
                 which case it is optional: the default is then taken from the
                 parent &lt;code&gt;xsl:package&lt;/code&gt; element.
              &lt;/p&gt;
            &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
        &lt;/xs:attribute&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="transform"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:transform-element-base-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xs:element ref="xsl:declaration"/&gt;
              &lt;xs:any namespace="##other" processContents="lax"/&gt;
              &lt;!-- weaker than XSLT 1.0 --&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="id" type="xs:ID"/&gt;
          &lt;xs:attribute name="input-type-annotations"
                        type="xsl:input-type-annotations-type"
                        default="unspecified"/&gt;
          &lt;xs:attribute name="fixed-namespaces"
                        type="xsl:fixed-namespaces-type"/&gt;
          &lt;xs:attribute name="_id" type="xs:string"/&gt;
          &lt;xs:attribute name="_input-type-annotations" type="xs:string"/&gt;
          &lt;xs:attribute name="_fixed-namespaces" type="xs:string"/&gt;
          &lt;!--* The 'static' attribute may be used on 'param' and 'variable'
              * only when they are top-level elements. *--&gt;
          &lt;xs:assert test="every $v in (.//xsl:param, .//xsl:variable)[exists(@static | @_static)] 
                           satisfies $v[parent::xsl:stylesheet or parent::xsl:transform or parent::xsl:override]"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   The static attribute must not be present on an &lt;code&gt;xsl:variable&lt;/code&gt; or
                   &lt;code&gt;xsl:param&lt;/code&gt; element unless it is a top-level element.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="every $prefix in (@exclude-result-prefixes[not(. = '#all')], 
                                             @extension-element-prefixes) 
                           satisfies ((if ($prefix = '#default') then '' else $prefix) = in-scope-prefixes(.))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   XTSE0808: It is a static error if a namespace prefix is used
                   within the &lt;code&gt;[xsl:]exclude-result-prefixes&lt;/code&gt; attribute and there is
                   no namespace binding in scope for that prefix.
                &lt;/p&gt;
                &lt;p&gt;
                   XTSE0809: It is a static error if the value #default is used
                   within the &lt;code&gt;[xsl:]exclude-result-prefixes&lt;/code&gt; attribute and the
                   parent element of the &lt;code&gt;[xsl:]exclude-result-prefixes&lt;/code&gt; attribute
                   has no default namespace.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="try" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:catch" minOccurs="1" maxOccurs="1"/&gt;
            &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xs:element ref="xsl:catch"/&gt;
              &lt;xs:element ref="xsl:fallback"/&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="rollback-output" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression" use="optional"/&gt;
          &lt;xs:attribute name="_rollback-output" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="use-package" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:package&lt;/code&gt; and defines a dependency
            of the containing package on another package, identified by URI in the &lt;code&gt;name&lt;/code&gt;
            attribute. The &lt;code&gt;package-version&lt;/code&gt; attribute indicates which version of the
            library package is required, or may indicate a range of versions.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="false"&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:package-location"/&gt;
            &lt;xs:element ref="xsl:accept"/&gt;
            &lt;xs:element ref="xsl:override"/&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="name" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="package-version" type="xs:string"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_package-version" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="value-of" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="cdata" type="xsl:avt"/&gt;
          &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_cdata" type="xs:string"/&gt;
          &lt;xs:attribute name="_disable-output-escaping" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="variable" substitutionGroup="xsl:declaration xsl:instruction"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;Declaration of the &lt;code&gt;xsl:variable&lt;/code&gt; element, used both for local
            and global variable bindings.&lt;/p&gt;
        &lt;p&gt;
           This definition takes advantage of the ability in XSD 1.1 for an element
           to belong to more than one substitution group. A global variable is a
           declaration, while a local variable can appear as an instruction in a
           sequence constructor.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
          &lt;xs:attribute name="static" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:attribute name="_static" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="if (normalize-space(@static) = ('yes', 'true', '1')) 
                           then (exists(@_visibility) or normalize-space(@visibility) 
                                       = ('', 'private', 'final')) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   When the static attribute is present with the value yes, the
                   visibility attribute must not have a value other than private or
                   final.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (normalize-space(@static) = ('yes', 'true', '1')) 
                           then (empty((*, text())) and exists(@select | @_select)) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   When the attribute &lt;code&gt;static="yes"&lt;/code&gt; is specified, the &lt;code&gt;xsl:variable&lt;/code&gt;
                   element must have empty content, and the &lt;code&gt;select&lt;/code&gt; attribute must
                   be present to define the value of the variable.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="when"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="test" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_test" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@test | @_test)"/&gt;
          &lt;xs:assert test="not(exists(@select | @_select) and 
            (exists(* except xsl:fallback) or exists(text()[normalize-space()])))"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="where-populated"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor"/&gt;

  &lt;xs:element name="with-param"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_tunnel" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt; PART C: definition of literal result elements There are three ways to define
      the literal result elements permissible in a stylesheet. (a) do nothing. This allows any
      element to be used as a literal result element, provided it is not in the XSLT namespace (b)
      declare all permitted literal result elements as members of the &lt;code&gt;xsl:literal-result-element&lt;/code&gt;
      substitution group (c) redefine the model group xsl:result-elements to accommodate all
      permitted literal result elements. Literal result elements are allowed to take certain
      attributes in the XSLT namespace. These are defined in the attribute group
      &lt;code&gt;literal-result-element-attributes&lt;/code&gt;, which can be included in the definition of any literal
      result element. &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;xs:element name="literal-result-element" abstract="true" type="xs:anyType"/&gt;

  &lt;xs:attributeGroup name="literal-result-element-attributes"&gt;
    &lt;xs:attribute name="default-collation" 
                  form="qualified" 
                  type="xsl:uri-list"/&gt;
    &lt;xs:attribute name="default-mode" 
                  form="qualified"  
                  type="xsl:default-mode-type"/&gt;
    &lt;xs:attribute name="default-validation" 
                  form="qualified" 
                  type="xsl:validation-strip-or-preserve"
                  default="strip"/&gt;
    &lt;xs:attribute name="expand-text" 
                  form="qualified"  
                  type="xsl:yes-or-no"/&gt;
    &lt;xs:attribute name="extension-element-prefixes" 
                  form="qualified" 
                  type="xsl:prefix-list"/&gt;
    &lt;xs:attribute name="exclude-result-prefixes" 
                  form="qualified" 
                  type="xsl:prefix-list-or-all"/&gt;
    &lt;xs:attribute name="inherit-namespaces"
                  form="qualified"
                  type="xsl:yes-or-no"
                  default="yes"/&gt;
    &lt;xs:attribute name="schema-role"
                  form="qualified"
                  type="xs:NCName"
                  default="yes"/&gt;
    &lt;xs:attribute name="use-attribute-sets"
                  form="qualified"
                  type="xsl:EQNames"
                  default=""/&gt;
    &lt;xs:attribute name="use-when" 
                  form="qualified" 
                  type="xsl:expression"/&gt;
    &lt;xs:attribute name="version" 
                  form="qualified" 
                  type="xs:decimal"/&gt;
    &lt;xs:attribute name="type" 
                  form="qualified" 
                  type="xsl:EQName"/&gt;
    &lt;xs:attribute name="validation" 
                  form="qualified" 
                  type="xsl:validation-type"/&gt;
    &lt;xs:attribute name="xpath-default-namespace" 
                  form="qualified" 
                  type="xs:anyURI"/&gt;
  &lt;/xs:attributeGroup&gt;

  &lt;xs:group name="result-elements"&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="xsl:literal-result-element"/&gt;
      &lt;xs:any namespace="##other" processContents="lax"/&gt;
      &lt;xs:any namespace="##local" processContents="lax"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;


  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      &lt;p&gt;
         PART D: definitions of simple types used in stylesheet attributes
      &lt;/p&gt;
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;xs:simpleType name="accumulator-names"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;use-accumulators&lt;/code&gt; attribute of &lt;code&gt;xsl:source-document&lt;/code&gt;, 
           &lt;code&gt;xsl:merge-source&lt;/code&gt;, or &lt;code&gt;xsl:global-context-item&lt;/code&gt;: 
           either a list, each member being a QName; or the value &lt;code&gt;#all&lt;/code&gt;
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:list itemType="xsl:EQName"/&gt;
      &lt;/xs:simpleType&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#all"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt; 
  
  &lt;xs:simpleType name="avt"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This type is used for all attributes that allow an attribute value
           template. The general rules for the syntax of attribute value templates,
           and the specific rules for each such attribute, are described in the
           XSLT 4.0 Recommendation.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:string"/&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="char"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A string containing exactly one character.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:length value="1"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

           
  &lt;xs:simpleType name="char-optionally-expanded"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A string containing either a single character, or a single character
           followed by a colon followed by an arbitrary string
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:pattern value=".(:.*)?"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt; 

           
  &lt;xs:simpleType name="component-kind-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes a kind of component within a package.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="template"/&gt;
      &lt;xs:enumeration value="function"/&gt;
      &lt;xs:enumeration value="variable"/&gt;
      &lt;xs:enumeration value="attribute-set"/&gt;
      &lt;xs:enumeration value="mode"/&gt;
      &lt;xs:enumeration value="*"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="default-mode-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;default-mode&lt;/code&gt; attribute of &lt;code&gt;xsl:stylesheet&lt;/code&gt;, 
           &lt;code&gt;xsl:transform&lt;/code&gt;, &lt;code&gt;xsl:package&lt;/code&gt;
           (or any other xsl:* element): either a QName or #unnamed.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#unnamed"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="component-test"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt; A NameTest or a named function reference. &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:nametest xsl:named-function-reference"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="component-tests"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt; A list of NameTests or named function references&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:list itemType="xsl:component-test"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="expression"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           An XPath 4.0 expression.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value=".+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="fixed-namespaces-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
          A sequence of tokens, each of which may be one of #default, an NCName, a prefix=namespace binding, or a URI
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:list&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:union memberTypes="xsl:fixed-namespaces-type-standard xs:NCName xsl:fixed-namespaces-type-prefix-binding xs:anyURI"/&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:list&gt;
 
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="fixed-namespaces-type-standard"&gt;
    &lt;xs:restriction base="xs:token"&gt;
       &lt;xs:enumeration value="#standard"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="fixed-namespaces-type-prefix-binding"&gt;
    &lt;xs:restriction base="xs:string"&gt;
       &lt;xs:pattern value="([\i-[:]][\c-[:]]*:)=.+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="item-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           An XPath 4.0 ItemType
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value=".+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="input-type-annotations-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes how type annotations in source documents are handled.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="preserve"/&gt;
      &lt;xs:enumeration value="strip"/&gt;
      &lt;xs:enumeration value="unspecified"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="level"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;level&lt;/code&gt; attribute of &lt;code&gt;xsl:number&lt;/code&gt;: 
           one of &lt;code&gt;single&lt;/code&gt;, &lt;code&gt;multiple&lt;/code&gt;, or &lt;code&gt;any&lt;/code&gt;.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="single"/&gt;
      &lt;xs:enumeration value="multiple"/&gt;
      &lt;xs:enumeration value="any"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="mode"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;mode&lt;/code&gt; attribute of &lt;code&gt;xsl:apply-templates&lt;/code&gt;: 
           either a QName, or &lt;code&gt;#current&lt;/code&gt;,
           or &lt;code&gt;#unnamed&lt;/code&gt;, or &lt;code&gt;#default&lt;/code&gt;.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#default"/&gt;
          &lt;xs:enumeration value="#unnamed"/&gt;
          &lt;xs:enumeration value="#current"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="modes"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;mode&lt;/code&gt; attribute of &lt;code&gt;xsl:template&lt;/code&gt;: either a list, each member being
           either a QName or &lt;code&gt;#default&lt;/code&gt; or &lt;code&gt;#unnamed&lt;/code&gt;; or the value &lt;code&gt;#all&lt;/code&gt;
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction&gt;
          &lt;xs:simpleType&gt;
            &lt;xs:list&gt;
              &lt;xs:simpleType&gt;
                &lt;xs:union memberTypes="xsl:EQName"&gt;
                  &lt;xs:simpleType&gt;
                    &lt;xs:restriction base="xs:token"&gt;
                      &lt;xs:enumeration value="#default"/&gt;
                      &lt;xs:enumeration value="#unnamed"/&gt;
                    &lt;/xs:restriction&gt;
                  &lt;/xs:simpleType&gt;
                &lt;/xs:union&gt;
              &lt;/xs:simpleType&gt;
            &lt;/xs:list&gt;
          &lt;/xs:simpleType&gt;
          &lt;xs:assertion test="count($value) = count(distinct-values($value))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   XTSE0550: It is a static error if the same token is included
                   more than once in the list.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assertion&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#all"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

   &lt;xs:simpleType name="named-function-reference"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt; In simple terms, this is an EQName followed by "#arity" where "arity" is a non-negative integer. However,
          XSD doesn't allow us to reuse the definition of EQName in this way, so it has to be defined from scratch. The simplest
          way to do this is with an assertion. However, the assertion cannot exploit types such as &lt;code&gt;xsl:EQName&lt;/code&gt; defined in this
        schema&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value="((Q\{.*\})|([\i-[:]][\c-[:]]*:))?[\i-[:]][\c-[:]]*#[0-9]+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="nametest"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt; A list of NameTests, as defined in the XPath 31 Recommendation. Each NameTest is either
          an EQName, or "*", or "prefix:*", or "*:localname", or the wildcard Q{uri}*. &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="*"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:pattern value="[\i-[:]][\c-[:]]*:\*"/&gt;
          &lt;xs:pattern value="\*:[\i-[:]][\c-[:]]*"/&gt;
          &lt;xs:pattern value="Q\{[^}]*\}\*"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="nametests"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt; A list of NameTests, as defined in the XPath 4.0 Recommendation. Each NameTest is either
          a QName, or "*", or "prefix:*", or "*:localname" &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:list itemType="xsl:nametest"/&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="on-multiple-match-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes the action to be taken when there are several template rules
           to match an item in a given mode.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="use-last"/&gt;
      &lt;xs:enumeration value="fail"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="on-no-match-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes the action to be taken when there is no template rule to match
           an item in a given mode.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="deep-copy"/&gt;
      &lt;xs:enumeration value="shallow-copy"/&gt;
      &lt;xs:enumeration value="shallow-copy-all"/&gt;
      &lt;xs:enumeration value="deep-skip"/&gt;
      &lt;xs:enumeration value="shallow-skip"/&gt;
      &lt;xs:enumeration value="text-only-copy"/&gt;
      &lt;xs:enumeration value="fail"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefix-list-or-all"&gt;
    &lt;xs:union memberTypes="xsl:prefix-list"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#all"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefix-list"&gt;
    &lt;xs:list itemType="xsl:prefix-or-default"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="method"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;method&lt;/code&gt; attribute of &lt;code&gt;xsl:output&lt;/code&gt;: Either one of the recognized names
           "xml", "xhtml", "html", "text", "json", or "adaptive",
            or an EQName that must include a prefix or namespace URI.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName-in-namespace"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="xml"/&gt;
          &lt;xs:enumeration value="xhtml"/&gt;
          &lt;xs:enumeration value="html"/&gt;
          &lt;xs:enumeration value="text"/&gt;
          &lt;xs:enumeration value="json"/&gt;
          &lt;xs:enumeration value="adaptive"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="pattern"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A match pattern as defined in the XSLT 4.0 Recommendation. The syntax
           for patterns is a restricted form of the syntax for XPath 4.0
           expressions. 
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:expression"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefix-or-default"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Either a namespace prefix, or &lt;code&gt;#default&lt;/code&gt;. Used in the &lt;code&gt;xsl:namespace-alias&lt;/code&gt;
           element.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xs:NCName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#default"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="EQNames"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A list of QNames. Used in the &lt;code&gt;[xsl:]use-attribute-sets&lt;/code&gt; attribute of
           various elements, and in the &lt;code&gt;cdata-section-elements&lt;/code&gt; attribute of
           &lt;code&gt;xsl:output&lt;/code&gt;.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:list itemType="xsl:EQName"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="EQName"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           An extended QName. This schema does not use the built-in type &lt;code&gt;xs:QName&lt;/code&gt;,
           but rather defines its own QName type. This may be either a local name,
           or a prefixed QName, or a name written using the extended QName notation
           &lt;code&gt;Q{uri}[prefix:]local&lt;/code&gt;
        &lt;/p&gt;
        &lt;p&gt;In XSLT 4.0, where a QName is used in the &lt;code&gt;name&lt;/code&gt; attribute
        of (say) &lt;code&gt;xsl:template&lt;/code&gt; or &lt;code&gt;xsl:call-template&lt;/code&gt;, the prefix
        does not have to be bound in an XML namespace declaration; rather it can be bound
        in a &lt;code&gt;fixed-namespaces&lt;/code&gt; attribute on the &lt;code&gt;xsl:stylesheet&lt;/code&gt;
        element. Therefore, the built-in &lt;code&gt;xs:QName&lt;/code&gt; type cannot be used.
        This schema does not attempt to verify that namespace prefixes have been
        properly declared.&lt;/p&gt;
        
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xs:NCName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:pattern value="[\i-[:]][\c-[:]]*:[\i-[:]][\c-[:]]*"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:pattern value="Q\{[^{}]*\}[\i-[:]][\c-[:]]*(:[\i-[:]][\c-[:]]*)?"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="EQName-in-namespace"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A subtype of EQNames that excludes no-namespace names
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:EQName"&gt;
      &lt;xs:pattern value="Q\{.+\}.+|\i\c*:.+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="sequence-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The description of a datatype, conforming to the SequenceType production
           defined in the XPath 4.0 Recommendation
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value=".+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="streamability-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes the category to which a function belongs, with regards to its
           streaming behavior.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName-in-namespace"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="unclassified"/&gt;
          &lt;xs:enumeration value="absorbing"/&gt;
          &lt;xs:enumeration value="inspection"/&gt;
          &lt;xs:enumeration value="filter"/&gt;
          &lt;xs:enumeration value="shallow-descent"/&gt;
          &lt;xs:enumeration value="deep-descent"/&gt;
          &lt;xs:enumeration value="ascent"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="tokens"&gt;
    &lt;xs:list itemType="xs:token"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="typed-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes whether a mode is designed to match typed or untyped nodes.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="true"/&gt;
      &lt;xs:enumeration value="false"/&gt;
      &lt;xs:enumeration value="1"/&gt;
      &lt;xs:enumeration value="0"/&gt;
      &lt;xs:enumeration value="strict"/&gt;
      &lt;xs:enumeration value="lax"/&gt;
      &lt;xs:enumeration value="unspecified"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="uri-list"&gt;
    &lt;xs:list itemType="xs:anyURI"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="validation-strip-or-preserve"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes different ways of type-annotating an element or attribute.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:validation-type"&gt;
      &lt;xs:enumeration value="preserve"/&gt;
      &lt;xs:enumeration value="strip"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="validation-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes different ways of type-annotating an element or attribute.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="strict"/&gt;
      &lt;xs:enumeration value="lax"/&gt;
      &lt;xs:enumeration value="preserve"/&gt;
      &lt;xs:enumeration value="strip"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="visibility-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes the visibility of a component within a package.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="public"/&gt;
      &lt;xs:enumeration value="private"/&gt;
      &lt;xs:enumeration value="final"/&gt;
      &lt;xs:enumeration value="abstract"/&gt;
      &lt;xs:enumeration value="hidden"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="visibility-not-hidden-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes the visibility of a component within a package.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:visibility-type"&gt;
      &lt;xs:enumeration value="public"/&gt;
      &lt;xs:enumeration value="private"/&gt;
      &lt;xs:enumeration value="final"/&gt;
      &lt;xs:enumeration value="abstract"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="yes-or-no"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           One of the values "yes" or "no": the values "true" or "false", or "1" or
           "0" are accepted as synonyms.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="true"/&gt;
      &lt;xs:enumeration value="false"/&gt;
      &lt;xs:enumeration value="1"/&gt;
      &lt;xs:enumeration value="0"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="yes-or-no-or-maybe"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           One of the values "yes" or "no" or "omit". The values "true" or "false",
           or "1" or "0" are accepted as synonyms of "yes" and "no" respectively.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="true"/&gt;
      &lt;xs:enumeration value="false"/&gt;
      &lt;xs:enumeration value="1"/&gt;
      &lt;xs:enumeration value="0"/&gt;
      &lt;xs:enumeration value="maybe"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="yes-or-no-or-omit"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           One of the values "yes" or "no" or "omit". The values "true" or "false",
           or "1" or "0" are accepted as synonyms of "yes" and "no" respectively.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="true"/&gt;
      &lt;xs:enumeration value="false"/&gt;
      &lt;xs:enumeration value="1"/&gt;
      &lt;xs:enumeration value="0"/&gt;
      &lt;xs:enumeration value="omit"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="zero-digit"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A digit that has the numerical value zero.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:char"&gt;
      &lt;xs:pattern value="\p{Nd}"/&gt;
      &lt;xs:assertion test="matches(string-join(codepoints-to-string(
           for $i in 0 to 9 return string-to-codepoints($value) + $i), ''), '\p{Nd}{10}')"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;
</span></pre></div><div class="_diffs div2"><h3><a id="relax-ng-schema-for-xslt"></a>H.2 <a href="#relax-ng-schema-for-xslt" style="text-decoration: none">Relax-NG Schema for XSLT Stylesheets</a></h3><p>The following Relax-NG schema may be used to validate XSLT 4.0 stylesheet modules. Similar caveats apply as for the XSD 1.1 version.</p><p>A copy of this schema is available at <a href="schema-for-xslt30.rnc">schema-for-xslt30.rnc</a></p><p>TODO: Needs updating for 4.0.</p><pre class="font-size: small" xml:space="preserve"><span class="deltaxml-old" style="background:#FF5555"># XSLT 4.0 Relax NG Schema
# 
# Copyright (c) 2010-2016, Mohamed ZERGAOUI (Innovimax)
# Portions © 2024, XQuery and XSLT Extensions Community Group
# 
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer. Redistributions in binary
# form must reproduce the above copyright notice, this list of conditions and
# the following disclaimer in the documentation and/or other materials provided
# with the distribution. Neither the name of the Mohamed ZERGAOUI or Innovimax
# nor the names of its contributors may be used to endorse or promote products
# derived from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# 
namespace local = ""
default namespace xsl = "http://www.w3.org/1999/XSL/Transform"
namespace xs = "http://www.w3.org/2001/XMLSchema"

start =
  stylesheet.element
  | transform.element
  | package.element  
  | literal-result-element-as-stylesheet
  
sequence-constructor.model = (instruction.category | record.element | literal-result-element | text)*

literal-result-element-as-stylesheet =
  element * - xsl:* {
    attribute xsl:version { decimal.datatype },
    literal-result-element-no-version.atts,
    sequence-constructor.model
  }

literal-result-element =
  element * - xsl:* {
     literal-result-element.atts,
     sequence-constructor.model
  }

literal-result-element.atts =
  literal-result-element-no-version.atts,
  attribute xsl:version { text }?

# These attributes may also appear on a literal result element, but in this case, to distinguish them from user-defined attributes, 
# the names of the attributes are in the XSLT namespace. They are thus typically written as 
# xsl:default-collation,
# xsl:default-mode,
# xsl:default-validation,
# xsl:exclude-result-prefixes,
# xsl:expand-text,
# xsl:extension-element-prefixes,
# xsl:use-when,
# xsl:version,
# or xsl:xpath-default-namespace.
literal-result-element-no-version.atts =
   attribute * - xsl:* { avt.datatype }*
 &amp; attribute xsl:default-collation { uris.datatype }?
 &amp; attribute xsl:default-mode { eqname.datatype | '#unnamed' }?
 &amp; attribute xsl:default-validation  { "preserve" | "strip" }?
 &amp; attribute xsl:exclude-result-prefixes { exclude.prefixes.datatype }? # or prefixes.datatype ?
 &amp; attribute xsl:expand-text { boolean.datatype }?
 &amp; attribute xsl:extension-element-prefixes { extension.prefixes.datatype }? # or prefixes.datatype ?
 &amp; attribute xsl:inherit-namespaces { boolean.datatype }?
 &amp; attribute xsl:on-empty { expression.datatype }?
 &amp; attribute xsl:use-attribute-sets { eqnames.datatype }?
 &amp; attribute xsl:use-when { expression.datatype }?
 &amp; attribute xsl:xpath-default-namespace { xsd:anyURI }?
 &amp; attribute xsl:schema-role { ncname.datatype }?
 &amp; (attribute xsl:type { eqname.datatype }
    | attribute xsl:validation { "strict" | "lax" | "preserve" | "strip" })?


top-level-extension =
  element * - (xsl:* | local:*) {
     anyElement
  }

anyElement =
   grammar {
      start = any
      any =
        (attribute * { text }
         | text
         | element * { any })*
    }
    
extension.atts = attribute * - (xsl:* | local:*) { text }*

declarations.model = (declaration.category | top-level-extension)*

# [Definition: There are a number of standard attributes that may appear on any XSLT element: specifically 
# default-collation, 
# default-mode, 
# default-validation, 
# exclude-result-prefixes, 
# expand-text, 
# extension-element-prefixes, 
# use-when, 
# version, 
# and xpath-default-namespace.]

global.atts = 
   attribute default-collation { uris.datatype }?,
   attribute _default-collation { avt.datatype }?,
   attribute default-mode { eqname.datatype | '#unnamed' }?,
   attribute _default-mode { avt.datatype }?,
   attribute default-validation  { "preserve" | "strip" }?,
   attribute _default-validation { avt.datatype }?,   
   attribute exclude-result-prefixes { exclude.prefixes.datatype }?,
   attribute _exclude-result-prefixes { avt.datatype }?, # or prefixes.datatype ?
   attribute expand-text { boolean.datatype }?,
   attribute _expand-text { avt.datatype }?,
   attribute extension-element-prefixes { extension.prefixes.datatype }?,
   attribute _extension-element-prefixes { avt.datatype }?, # or prefixes.datatype ?
   attribute use-when { expression.datatype }?,
   attribute _use-when { avt.datatype }?,
   attribute version { decimal.datatype }?,
   attribute _version { avt.datatype }?,
   attribute xpath-default-namespace { uri.datatype }?,
   attribute _xpath-default-namespace { avt.datatype }?
   

global.atts.except.version = 
   attribute default-collation { uris.datatype }?,
   attribute _default-collation { avt.datatype }?,
   attribute exclude-result-prefixes { exclude.prefixes.datatype }?,
   attribute _exclude-result-prefixes { avt.datatype }?, # or prefixes.datatype ?
   attribute expand-text { boolean.datatype }?,
   attribute _expand-text { avt.datatype }?,
   attribute extension-element-prefixes { extension.prefixes.datatype }?,
   attribute _extension-element-prefixes { avt.datatype }?, # or prefixes.datatype ?
   attribute use-when { expression.datatype }?,
   attribute _use-when { avt.datatype }?,
   attribute xpath-default-namespace { uri.datatype }?,
   attribute _xpath-default-namespace { avt.datatype }?
   
# In XSLT 4.0, prefixes can be defined with the fixed-namespaces attribute
# on the xsl:stylesheet, so we can't rely on XML declarations for QNames.
qname.strict = xsd:token { pattern = "[\i-[:]][\c-[:]]*:[\i-[:]][\c-[:]]*" }
qname.datatype = xsd:NCName | qname.strict

# Extract from XPath 3.0
#[94]   EQName           ::= QName | URIQualifiedName
#[104]  QName            ::= [http://www.w3.org/TR/REC-xml-names/#NT-QName]Names
#[105]  NCName           ::= [http://www.w3.org/TR/REC-xml-names/#NT-NCName]Names
#[99]   URIQualifiedName ::= BracedURILiteral NCName
#[100]  BracedURILiteral ::= "Q" "{" [^{}]* "}"

uri.qualified.name = xsd:token { pattern = "Q\{[^\{\}]*\}[\i-[:]][\c-[:]]*" } 
eqname.datatype = qname.datatype | uri.qualified.name
qnames.datatype = list { qname.datatype* }
eqnames.datatype = list { eqname.datatype* }
ncname.datatype = xsd:NCName
prefix.datatype = xsd:NCName
boolean.datatype = "yes" | "no" | "true" | "false" | "0" | "1" 
expression.datatype = text
char.datatype = xsd:string { length = "1" }
string.datatype = text
id.datatype = xsd:NCName
tokens.datatype = list { token* }
prefixes.datatype = list { token* }
extension.prefixes.datatype = list { xsd:NCName* }
exclude.prefixes.datatype = list { "#all" | (xsd:NCName | "#default")* }
token.datatype = token
language.datatype = xsd:language
nmtoken.datatype = xsd:NMTOKEN
decimal.datatype = xsd:decimal
integer.datatype = xsd:integer
uri.datatype = xsd:anyURI
uris.datatype = list { xsd:anyURI* }
pattern.datatype = text
qname-but-not-ncname.datatype = xsd:QName { pattern = ".*:.*" }
xs_schema.element = element xs:schema { anyElement* }
item-type.datatype = text
sequence-type.datatype = text

# #standard or NCName or prefix=URI or URI
fixed-namespaces.datatype = xsd:string

select-or-sequence-constructor.model =
  ((attribute select { expression.datatype }
    | attribute _select { avt.datatype })+
   | sequence-constructor.model)

declaration.category =
   use-package.element
 | include.element
 | import.element
 | import-schema.element
 | strip-space.element
 | preserve-space.element
 | decimal-format.element
 | template.element
 | mode.element
 | global-context-item.element
 | variable.element
 | param.element
 | attribute-set.element
 | function.element
 | namespace-alias.element
 | accumulator.element
 | key.element
 | output.element
 | character-map.element

instruction.category =
   apply-templates.element
 | apply-imports.element
 | next-match.element
 | for-each.element
 | iterate.element
 | next-iteration.element
 | break.element
 | if.element
 | choose.element
 | switch.element
 | try.element
 | variable.element
 | call-template.element
 | evaluate.element
 | element.element
 | attribute.element
 | text.element
 | value-of.element
 | document.element
 | processing-instruction.element
 | namespace.element
 | comment.element
 | copy.element
 | copy-of.element
 | sequence.element
 | where-populated.element
 | on-empty.element
 | on-non-empty.element
 | number.element
 | perform-sort.element
 | for-each-group.element
 | merge.element
 | fork.element
 | analyze-string.element
 | source-document.element
 | map.element
 | map-entry.element
 | array.element
 | array-member.element
 | message.element
 | assert.element
 | fallback.element
 | result-document.element
 | select.element
package.element =
   element package {
      extension.atts,
      attribute id { id.datatype }?,
      attribute _id { avt.datatype }?,
      attribute name { uri.datatype }?,
      attribute _name { avt.datatype }?,
      attribute package-version { string.datatype }?,
      attribute _package-version { avt.datatype }?,
      attribute version { decimal.datatype }?,
      attribute _version { avt.datatype }?,
      attribute input-type-annotations { "preserve" | "strip" | "unspecified" }?,
      attribute _input-type-annotations { avt.datatype }?,
      attribute declared-modes { boolean.datatype }?,
      attribute _declared-modes { avt.datatype }?,
      attribute default-mode { eqname.datatype | "#unnamed" }?,
      attribute _default-mode { avt.datatype }?,
      attribute default-validation { "preserve" | "strip" }?,
      attribute _default-validation { avt.datatype }?,
      attribute default-collation { uris.datatype }?,
      attribute _default-collation { avt.datatype }?,
      attribute extension-element-prefixes { prefixes.datatype }?,
      attribute _extension-element-prefixes { avt.datatype }?,
      attribute exclude-result-prefixes { prefixes.datatype }?,
      attribute _exclude-result-prefixes { avt.datatype }?,
      attribute expand-text { boolean.datatype }?,
      attribute _expand-text { avt.datatype }?,
      attribute use-when { expression.datatype }?,
      attribute _use-when { avt.datatype }?,
      attribute xpath-default-namespace { uri.datatype }?,
      attribute _xpath-default-namespace { avt.datatype }?,
      attribute fixed-namespaces { fixed-namespaces.datatype }?,
      attribute _fixed-namespaces { fixed-namespaces.datatype }?,
      ((expose.element | declarations.model)*)
   }
use-package.element =
   element use-package {
      extension.atts,
      global.atts,
      attribute name { uri.datatype }?,
      attribute _name { avt.datatype }?,
      attribute package-version { string.datatype }?,
      attribute _package-version { avt.datatype }?,
      (accept.element | override.element)*
   }
expose.element =
   element expose {
      extension.atts,
      global.atts,
      attribute component { "template" | "function" | "attribute-set" | "variable" | "mode" | "*" }?,
      attribute _component { avt.datatype }?,
      attribute names { tokens.datatype }?,
      attribute _names { avt.datatype }?,
      attribute visibility { "public" | "private" | "final" | "abstract" }?,
      attribute _visibility { avt.datatype }?,
      empty
   }
accept.element =
   element accept {
      extension.atts,
      global.atts,
      (attribute component { "template" | "function" | "attribute-set" | "variable" | "mode" | "*" } |
      attribute _component { avt.datatype })+,
      (attribute names { tokens.datatype } |
      attribute _names { avt.datatype })+,
      (attribute visibility { "public" | "private" | "final" | "abstract" | "hidden" } |
      attribute _visibility { avt.datatype })+,
      empty
   }
override.element =
   element override {
      extension.atts,
      global.atts,
      (template.element | function.element | variable.element | param.element | attribute-set.element)*
   }
stylesheet.element =
   element stylesheet {
      extension.atts,
      attribute id { id.datatype }?,
      attribute _id { avt.datatype }?,
      attribute version { decimal.datatype }?,
      attribute _version { avt.datatype }?,
      attribute default-mode { eqname.datatype | "#unnamed" }?,
      attribute _default-mode { avt.datatype }?,
      attribute default-validation { "preserve" | "strip" }?,
      attribute _default-validation { avt.datatype }?,
      attribute input-type-annotations { "preserve" | "strip" | "unspecified" }?,
      attribute _input-type-annotations { avt.datatype }?,
      attribute default-collation { uris.datatype }?,
      attribute _default-collation { avt.datatype }?,
      attribute extension-element-prefixes { prefixes.datatype }?,
      attribute _extension-element-prefixes { avt.datatype }?,
      attribute exclude-result-prefixes { prefixes.datatype }?,
      attribute _exclude-result-prefixes { avt.datatype }?,
      attribute expand-text { boolean.datatype }?,
      attribute _expand-text { avt.datatype }?,
      attribute use-when { expression.datatype }?,
      attribute _use-when { avt.datatype }?,
      attribute xpath-default-namespace { uri.datatype }?,
      attribute _xpath-default-namespace { avt.datatype }?,
      attribute fixed-namespaces { fixed-namespaces.datatype }?,
      attribute _fixed-namespaces { fixed-namespaces.datatype }?,
      (declarations.model)
   }
transform.element =
   element transform {
      extension.atts,
      attribute id { id.datatype }?,
      attribute _id { avt.datatype }?,
      attribute version { decimal.datatype }?,
      attribute _version { avt.datatype }?,
      attribute default-mode { eqname.datatype | "#unnamed" }?,
      attribute _default-mode { avt.datatype }?,
      attribute default-validation { "preserve" | "strip" }?,
      attribute _default-validation { avt.datatype }?,
      attribute input-type-annotations { "preserve" | "strip" | "unspecified" }?,
      attribute _input-type-annotations { avt.datatype }?,
      attribute default-collation { uris.datatype }?,
      attribute _default-collation { avt.datatype }?,
      attribute extension-element-prefixes { prefixes.datatype }?,
      attribute _extension-element-prefixes { avt.datatype }?,
      attribute exclude-result-prefixes { prefixes.datatype }?,
      attribute _exclude-result-prefixes { avt.datatype }?,
      attribute expand-text { boolean.datatype }?,
      attribute _expand-text { avt.datatype }?,
      attribute use-when { expression.datatype }?,
      attribute _use-when { avt.datatype }?,
      attribute xpath-default-namespace { uri.datatype }?,
      attribute _xpath-default-namespace { avt.datatype }?,
      attribute fixed-namespaces { fixed-namespaces.datatype }?,
      attribute _fixed-namespaces { fixed-namespaces.datatype }?,
      (declarations.model)
   }
include.element =
   element include {
      extension.atts,
      global.atts,
      attribute href { uri.datatype }?,
      attribute _href { avt.datatype }?,
      empty
   }
import.element =
   element import {
      extension.atts,
      global.atts,
      (attribute href { uri.datatype }
      | attribute _href { avt.datatype })+,
      empty
   }
import-schema.element =
   element import-schema {
      extension.atts,
      global.atts,
      attribute namespace { uri.datatype }?,
      attribute _namespace { avt.datatype }?,
      attribute schema-location { uri.datatype }?,
      attribute _schema-location { avt.datatype }?,
      xs_schema.element?
   }
strip-space.element =
   element strip-space {
      extension.atts,
      global.atts,
      (attribute elements { tokens.datatype }
      | attribute _elements { avt.datatype })+,
      empty
   }
preserve-space.element =
   element preserve-space {
      extension.atts,
      global.atts,
      (attribute elements { tokens.datatype }
      | attribute _elements { avt.datatype })+,
      empty
   }
decimal-format.element =
   element decimal-format {
      extension.atts,
      global.atts,
      attribute name { eqname.datatype }?,
      attribute _name { avt.datatype }?,
      attribute decimal-separator { char.datatype }?,
      attribute _decimal-separator { avt.datatype }?,
      attribute grouping-separator { char.datatype }?,
      attribute _grouping-separator { avt.datatype }?,
      attribute infinity { string.datatype }?,
      attribute _infinity { avt.datatype }?,
      attribute minus-sign { char.datatype }?,
      attribute _minus-sign { avt.datatype }?,
      attribute exponent-separator { char.datatype }?,
      attribute _exponent-separator { avt.datatype }?,
      attribute NaN { string.datatype }?,
      attribute _NaN { avt.datatype }?,
      attribute percent { char.datatype }?,
      attribute _percent { avt.datatype }?,
      attribute per-mille { char.datatype }?,
      attribute _per-mille { avt.datatype }?,
      attribute zero-digit { char.datatype }?,
      attribute _zero-digit { avt.datatype }?,
      attribute digit { char.datatype }?,
      attribute _digit { avt.datatype }?,
      attribute pattern-separator { char.datatype }?,
      attribute _pattern-separator { avt.datatype }?,
      empty
   }
template.element =
   element template {
      extension.atts,
      global.atts,
      (attribute match { pattern.datatype }
      | attribute _match { avt.datatype }
      | attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute priority { decimal.datatype }?,
      attribute _priority { avt.datatype }?,
      attribute mode { list { '#all' | ('#default' | '#unnamed' | eqname.datatype)* } }?,
      attribute _mode { avt.datatype }?,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute visibility { "public" | "private" | "final" | "abstract" }?,
      attribute _visibility { avt.datatype }?,
      (context-item.element?, param.element*, sequence-constructor.model)
   }
apply-templates.element =
   element apply-templates {
      extension.atts,
      global.atts,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      attribute mode { (eqname.datatype | '#unnamed' | '#default' | '#current') }?,
      attribute _mode { avt.datatype }?,
      attribute separator { avt.datatype }?,
      attribute _separator { avt.datatype }?,
      (sort.element | with-param.element)*
   }
mode.element =
   element mode {
      extension.atts,
      global.atts,
      (attribute as { sequence-type.datatype }?
      | attribute _as { avt.datatype }?),
      (attribute copy-namespaces { boolean.datatype }?
      | attribute _copy-namespaces { boolean.datatype }?),
      (attribute name { eqname.datatype }?
      | attribute _name { avt.datatype }?),
      (attribute streamable { boolean.datatype }?
      | attribute _streamable { avt.datatype }?),
      (attribute on-no-match { "deep-copy" | "shallow-copy" | "shallow-copy-all" | "deep-skip" | "shallow-skip" | "text-only-copy" | "fail" }?
      | attribute _on-no-match { avt.datatype }?),
      (attribute on-multiple-match { "use-last" | "fail" }?
      | attribute _on-multiple-match { avt.datatype }?),
      (attribute warning-on-no-match { boolean.datatype }?
      | attribute _warning-on-no-match { avt.datatype }?),
      (attribute warning-on-multiple-match { boolean.datatype }?
      | attribute _warning-on-multiple-match { avt.datatype }?),
      (attribute typed { boolean.datatype | "strict" | "lax" | "unspecified" }?
      | attribute _typed { avt.datatype }?),
      (attribute visibility { "public" | "private" | "final" }?
      | attribute _visibility { avt.datatype }?),
      (attribute use-accumulators { tokens.datatype }?
      | attribute _use-accumulators { avt.datatype }?),
      empty
   }
context-item.element =
   element context-item {
      extension.atts,
      global.atts,
      attribute as { item-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute use { "required" | "optional" | "absent" }?,
      attribute _use { avt.datatype }?,
      empty
   }
global-context-item.element =
   element global-context-item {
      extension.atts,
      global.atts,
      attribute as { item-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute use { "required" | "optional" | "absent" }?,
      attribute _use { avt.datatype }?,
      empty
   }
apply-imports.element =
   element apply-imports {
      extension.atts,
      global.atts,
      with-param.element*
   }
next-match.element =
   element next-match {
      extension.atts,
      global.atts,
      (with-param.element | fallback.element)*
   }
for-each.element =
   element for-each {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      (sort.element*, sequence-constructor.model)
   }
iterate.element =
   element iterate {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      (param.element*, on-completion.element?, sequence-constructor.model)
   }
next-iteration.element =
   element next-iteration {
      extension.atts,
      global.atts,
      (with-param.element*)
   }
break.element =
   element break {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })?,
      sequence-constructor.model
   }
on-completion.element =
   element on-completion {
      extension.atts,
      global.atts,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      sequence-constructor.model
   }
if.element =
   element if {
      extension.atts,
      global.atts,
      (attribute test { expression.datatype }
      | attribute _test { avt.datatype })+,
      sequence-constructor.model
   }
choose.element =
   element choose {
      extension.atts,
      global.atts,
      (when.element+, otherwise.element?)
   }
when.element =
   element when {
      extension.atts,
      global.atts,
      (attribute test { expression.datatype }
      | attribute _test { avt.datatype })+,
      select-or-sequence-constructor.model
   }
otherwise.element =
   element otherwise {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }

switch.element =
  element switch {
    extension.atts,
    global.atts,
    (attribute select { expression.datatype }
    | attribute _select { avt.datatype })+,
    (when.element+, otherwise.element?, fallback.element*)
  }

try.element =
   element try {
      extension.atts,
      global.atts,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      attribute rollback-output { boolean.datatype }?,
      attribute _rollback-output { avt.datatype }?,
      (sequence-constructor.model, catch.element, (catch.element | fallback.element)*)
   }
catch.element =
   element catch {
      extension.atts,
      global.atts,
      attribute errors { tokens.datatype }?,
      attribute _errors { avt.datatype }?,
      select-or-sequence-constructor.model
   }
variable.element =
   element variable {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute static { boolean.datatype }?,
      attribute _static { avt.datatype }?,
      attribute visibility { "public" | "private" | "final" | "abstract" }?,
      attribute _visibility { avt.datatype }?,
      select-or-sequence-constructor.model
   }
param.element =
   element param {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute required { boolean.datatype }?,
      attribute _required { avt.datatype }?,
      attribute tunnel { boolean.datatype }?,
      attribute _tunnel { avt.datatype }?,
      attribute static { boolean.datatype }?,
      attribute _static { avt.datatype }?,
      select-or-sequence-constructor.model
   }
with-param.element =
   element with-param {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute tunnel { boolean.datatype }?,
      attribute _tunnel { avt.datatype }?,
      select-or-sequence-constructor.model
   }
call-template.element =
   element call-template {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      with-param.element*
   }
attribute-set.element =
   element attribute-set {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute use-attribute-sets { eqnames.datatype }?,
      attribute _use-attribute-sets { avt.datatype }?,
      attribute visibility { "public" | "private" | "final" | "abstract" }?,
      attribute _visibility { avt.datatype }?,
      attribute streamable { boolean.datatype }?,
      attribute _streamable { avt.datatype }?,
      attribute.element*
   }
function.element =
   element function {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      (attribute as { sequence-type.datatype }?
      | attribute _as { avt.datatype }?),
      (attribute visibility { "public" | "private" | "final" | "abstract" }?
      | attribute _visibility { avt.datatype }?),
      (attribute streamability { "unclassified" | "absorbing" | "inspection" | "filter" | "shallow-descent" | "deep-descent" | "ascent" | eqname.datatype }?
      | attribute _streamability { avt.datatype }?),
      (attribute override-extension-function { boolean.datatype }?
      | attribute _override-extension-function { avt.datatype }?),
      (attribute override { boolean.datatype }?
      | attribute _override { avt.datatype }?),
      (attribute new-each-time { "yes" | "true" | "1" | "no" | "false" | "0" | "maybe" }?
      | attribute _new-each-time { avt.datatype }?),
      (attribute cache { boolean.datatype }?
      | attribute _cache { avt.datatype }?),
      (param.element*, sequence-constructor.model)
   }
evaluate.element =
   element evaluate {
      extension.atts,
      global.atts,
      (attribute xpath { expression.datatype }
      | attribute _xpath { avt.datatype })+,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute base-uri { uri.datatype | avt.datatype }?,
      attribute _base-uri { avt.datatype }?,
      attribute with-params { expression.datatype }?,
      attribute _with-params { avt.datatype }?,
      attribute context-item { expression.datatype }?,
      attribute _context-item { avt.datatype }?,
      attribute namespace-context { expression.datatype }?,
      attribute _namespace-context { avt.datatype }?,
      attribute schema-aware { boolean.datatype | avt.datatype }?,
      attribute _schema-aware { avt.datatype }?,
      (with-param.element | fallback.element)*
   }
namespace-alias.element =
   element namespace-alias {
      extension.atts,
      global.atts,
      (attribute stylesheet-prefix { prefix.datatype | "#default" }
      | attribute _stylesheet-prefix { avt.datatype })+,
      (attribute result-prefix { prefix.datatype | "#default" }
      | attribute _result-prefix { avt.datatype })+,
      empty
   }
element.element =
   element element {
      extension.atts,
      global.atts,
      (attribute name { qname.datatype | avt.datatype }
      | attribute _name { avt.datatype })+,
      attribute namespace { uri.datatype | avt.datatype }?,
      attribute _namespace { avt.datatype }?,
      attribute inherit-namespaces { boolean.datatype }?,
      attribute _inherit-namespaces { avt.datatype }?,
      attribute use-attribute-sets { eqnames.datatype }?,
      attribute _use-attribute-sets { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      sequence-constructor.model
   }
attribute.element =
   element attribute {
      extension.atts,
      global.atts,
      (attribute name { qname.datatype | avt.datatype }
      | attribute _name { avt.datatype })+,
      attribute namespace { uri.datatype | avt.datatype }?,
      attribute _namespace { avt.datatype }?,
      attribute separator { string.datatype | avt.datatype }?,
      attribute _separator { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      select-or-sequence-constructor.model
   }
text.element =
   element text {
      extension.atts,
      global.atts,
      attribute separator { string.datatype | avt.datatype }?,
      attribute _separator { avt.datatype }?,
      attribute cdata { boolean.datatype | avt.datatype }?,
      attribute _cdata { avt.datatype }?,
      attribute disable-output-escaping { boolean.datatype }?,
      attribute _disable-output-escaping { avt.datatype }?,
      text
   }
value-of.element =
   element value-of {
      extension.atts,
      global.atts,
      attribute separator { string.datatype | avt.datatype }?,
      attribute _separator { avt.datatype }?,
      attribute cdata { boolean.datatype | avt.datatype }?,
      attribute _cdata { avt.datatype }?,
      attribute disable-output-escaping { boolean.datatype }?,
      attribute _disable-output-escaping { avt.datatype }?,
      select-or-sequence-constructor.model
   }
document.element =
   element document {
      extension.atts,
      global.atts,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      sequence-constructor.model
   }
processing-instruction.element =
   element processing-instruction {
      extension.atts,
      global.atts,
      (attribute name { ncname.datatype | avt.datatype }
      | attribute _name { avt.datatype }),
      select-or-sequence-constructor.model
   }
record.element = 
   element record {
      (attribute as { sequence-type.datatype }?
      | attribute _as { avt.datatype }?),
      (attribute duplicates { expression.datatype }?
      | attribute _duplicates { avt.datatype }?),
      sequence-constructor.model
  }
record-type.element = 
   element record-type {
      (attribute name { ncname.datatype | avt.datatype }
      | attribute _name { avt.datatype }),
      (attribute extensible { boolean.datatype }?
      | attribute _extensible { avt.datatype }?),
      (attribute visibility { "public" | "private" | "final" | "abstract" | "hidden" }?
      | attribute _visibility { avt.datatype }?),
      field.element*
  }
field.element = 
   element field {
      (attribute name { ncname.datatype | avt.datatype }
      | attribute _name { avt.datatype }),
      (attribute as { sequence-type.datatype }?
      | attribute _as { avt.datatype }?),
      (attribute required { boolean.datatype }?
      | attribute _required { avt.datatype }?),
      (attribute \default { expression.datatype }?
      |attribute _default { expression.datatype }?),
      empty
  }

select.element = 
   element select {
      (attribute as { sequence-type.datatype }?
      | attribute _as { avt.datatype }?),
      (fallback.element | text)*
  }
namespace.element =
   element namespace {
      extension.atts,
      global.atts,
      (attribute name { ncname.datatype | avt.datatype }
      | attribute _name { avt.datatype })+,
      select-or-sequence-constructor.model
   }
comment.element =
   element comment {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }
copy.element =
   element copy {
      extension.atts,
      global.atts,
      attribute copy-namespaces { boolean.datatype }?,
      attribute _copy-namespaces { avt.datatype }?,
      attribute inherit-namespaces { boolean.datatype }?,
      attribute _inherit-namespaces { avt.datatype }?,
      attribute use-attribute-sets { eqnames.datatype }?,
      attribute _use-attribute-sets { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      sequence-constructor.model
   }
copy-of.element =
   element copy-of {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      attribute copy-accumulators { boolean.datatype }?,
      attribute _copy-accumulators { avt.datatype }?,
      attribute copy-namespaces { boolean.datatype }?,
      attribute _copy-namespaces { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      empty
   }
sequence.element =
   element sequence {
      extension.atts,
      global.atts,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      select-or-sequence-constructor.model
   }
where-populated.element =
   element where-populated {
      extension.atts,
      global.atts,
      sequence-constructor.model
   }
on-empty.element =
   element on-empty {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }
on-non-empty.element =
   element on-non-empty {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }
number.element =
   element number {
      extension.atts,
      global.atts,
      attribute value { expression.datatype }?,
      attribute _value { avt.datatype }?,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      attribute level { "single" | "multiple" | "any" }?,
      attribute _level { avt.datatype }?,
      attribute count { pattern.datatype }?,
      attribute _count { avt.datatype }?,
      attribute from { pattern.datatype }?,
      attribute _from { avt.datatype }?,
      attribute format { string.datatype | avt.datatype }?,
      attribute _format { avt.datatype }?,
      attribute lang { language.datatype | avt.datatype }?,
      attribute _lang { avt.datatype }?,
      attribute letter-value { "alphabetic" | "traditional" | avt.datatype }?,
      attribute _letter-value { avt.datatype }?,
      attribute ordinal { string.datatype | avt.datatype }?,
      attribute _ordinal { avt.datatype }?,
      attribute start-at { integer.datatype | avt.datatype }?,
      attribute _start-at { avt.datatype }?,
      attribute grouping-separator { char.datatype | avt.datatype }?,
      attribute _grouping-separator { avt.datatype }?,
      attribute grouping-size { integer.datatype | avt.datatype }?,
      attribute _grouping-size { avt.datatype }?,
      empty
   }
sort.element =
   element sort {
      extension.atts,
      global.atts,
      attribute lang { language.datatype | avt.datatype }?,
      attribute _lang { avt.datatype }?,
      attribute order { "ascending" | "descending" | avt.datatype }?,
      attribute _order { avt.datatype }?,
      attribute collation { uri.datatype | avt.datatype }?,
      attribute _collation { avt.datatype }?,
      attribute stable { boolean.datatype | avt.datatype }?,
      attribute _stable { avt.datatype }?,
      attribute case-order { "upper-first" | "lower-first" | avt.datatype }?,
      attribute _case-order { avt.datatype }?,
      attribute data-type { "text" | "number" | eqname.datatype | avt.datatype }?,
      attribute _data-type { avt.datatype }?,
      select-or-sequence-constructor.model
   }
perform-sort.element =
   element perform-sort {
      extension.atts,
      global.atts,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      (sort.element+, sequence-constructor.model)
   }
for-each-group.element =
   element for-each-group {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      ((attribute group-by { expression.datatype }?,
      attribute _group-by { avt.datatype }?) |
      (attribute group-adjacent { expression.datatype }?,
      attribute _group-adjacent { avt.datatype }?) |
      (attribute group-starting-with { pattern.datatype }?,
      attribute _group-starting-with { avt.datatype }?) |
      (attribute group-ending-with { pattern.datatype }?,
      attribute _group-ending-with { avt.datatype }?)),
      attribute composite { boolean.datatype }?,
      attribute _composite { avt.datatype }?,
      attribute collation { uri.datatype | avt.datatype }?,
      attribute _collation { avt.datatype }?,
      (sort.element*, sequence-constructor.model)
   }
merge.element =
   element merge {
      extension.atts,
      global.atts,
      (merge-source.element+, merge-action.element, fallback.element*)
   }
merge-source.element =
   element merge-source {
      extension.atts,
      global.atts,
      attribute name { ncname.datatype }?,
      attribute _name { avt.datatype }?,
      attribute for-each-item { expression.datatype }?,
      attribute _for-each-item { avt.datatype }?,
      attribute for-each-stream { expression.datatype }?,
      attribute _for-each-stream { avt.datatype }?,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      attribute streamable { boolean.datatype }?,
      attribute _streamable { avt.datatype }?,
      attribute use-accumulators { tokens.datatype }?,
      attribute _use-accumulators { avt.datatype }?,
      attribute sort-before-merge { boolean.datatype }?,
      attribute _sort-before-merge { avt.datatype }?,
      attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }?,
      attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?,
      attribute for-each-source { expression.datatype }?,
      attribute _for-each-source { avt.datatype }?,
      merge-key.element+
   }
merge-key.element =
   element merge-key {
      extension.atts,
      global.atts,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      attribute lang { language.datatype | avt.datatype }?,
      attribute _lang { avt.datatype }?,
      attribute order { "ascending" | "descending" | avt.datatype }?,
      attribute _order { avt.datatype }?,
      attribute collation { uri.datatype | avt.datatype }?,
      attribute _collation { avt.datatype }?,
      attribute case-order { "upper-first" | "lower-first" | avt.datatype }?,
      attribute _case-order { avt.datatype }?,
      attribute data-type { "text" | "number" | eqname.datatype | avt.datatype }?,
      attribute _data-type { avt.datatype }?,
      sequence-constructor.model
   }
merge-action.element =
   element merge-action {
      extension.atts,
      global.atts,
      sequence-constructor.model
   }
fork.element =
   element fork {
      extension.atts,
      global.atts,
      (fallback.element*, ((sequence.element, fallback.element*)* | (for-each-group.element, fallback.element*)))
   }
analyze-string.element =
   element analyze-string {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      (attribute regex { string.datatype | avt.datatype }
      | attribute _regex { avt.datatype })+,
      attribute flags { string.datatype | avt.datatype }?,
      attribute _flags { avt.datatype }?,
      (matching-substring.element?, non-matching-substring.element?, fallback.element*)
   }
matching-substring.element =
   element matching-substring {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }
non-matching-substring.element =
   element non-matching-substring {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }
source-document.element =
   element source-document {
      extension.atts,
      global.atts,
      (attribute href { uri.datatype | avt.datatype }
      | attribute _href { avt.datatype })+,
      attribute use-accumulators { tokens.datatype }?,
      attribute _use-accumulators { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      attribute streamable { boolean.datatype }?,
      attribute _streamable { avt.datatype }?,
      sequence-constructor.model
   }
accumulator.element =
   element accumulator {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype }),
      (attribute initial-value { expression.datatype }
      | attribute _initial-value { avt.datatype }),
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute streamable { boolean.datatype }?,
      attribute _streamable { avt.datatype }?,
      accumulator-rule.element+
   }
accumulator-rule.element =
   element accumulator-rule {
      extension.atts,
      global.atts,
      (attribute match { pattern.datatype } |
      attribute _match { avt.datatype })+,
      attribute phase { "start" | "end" }?,
      attribute _phase { avt.datatype }?,
      select-or-sequence-constructor.model
   }
key.element =
   element key {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      (attribute match { pattern.datatype }
      | attribute _match { avt.datatype })+,
      attribute use { expression.datatype }?,
      attribute _use { avt.datatype }?,
      attribute composite { boolean.datatype }?,
      attribute _composite { avt.datatype }?,
      attribute collation { uri.datatype }?,
      attribute _collation { avt.datatype }?,
      sequence-constructor.model
   }
map.element =
   element map {
      (attribute duplicates { expression.datatype }?
      | attribute _duplicates { avt.datatype }?),
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }

map-entry.element =
   element map-entry {
      extension.atts,
      global.atts,
      (attribute key { expression.datatype }
      | attribute _key { avt.datatype }),
      select-or-sequence-constructor.model
   }

array.element =
  element array {
    (attribute for-each { expression.datatype }
     | attribute _for-each { expression.datatype }),
    extension.atts,
    global.atts,
    select-or-sequence-constructor.model
  }

array-member.element =
  element array-member {
    extension.atts,
    global.atts,
    select-or-sequence-constructor.model
  }

message.element =
   element message {
      extension.atts,
      global.atts,
      attribute terminate { boolean.datatype | avt.datatype }?,
      attribute _terminate { avt.datatype }?,
      attribute error-code { eqname.datatype | avt.datatype }?,
      attribute _error-code { avt.datatype }?,
      select-or-sequence-constructor.model
   }
assert.element =
   element assert {
      extension.atts,
      global.atts,
      (attribute test { expression.datatype }
      | attribute _test { avt.datatype })+,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      attribute error-code { eqname.datatype | avt.datatype }?,
      attribute _error-code { avt.datatype }?,
      sequence-constructor.model
   }
fallback.element =
   element fallback {
      extension.atts,
      global.atts,
      sequence-constructor.model
   }
result-document.element =
   element result-document {
      extension.atts,
      global.atts,
      attribute format { eqname.datatype | avt.datatype }?,
      attribute _format { avt.datatype }?,
      attribute href { uri.datatype | avt.datatype }?,
      attribute _href { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive      
      attribute method { "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | eqname.datatype | avt.datatype }?,
      attribute _method { avt.datatype }?,
      attribute allow-duplicate-names { boolean.datatype | avt.datatype }?,
      attribute _allow-duplicate-names { avt.datatype }?,
      attribute build-tree { boolean.datatype | avt.datatype }?,
      attribute _build-tree { avt.datatype }?,
      attribute byte-order-mark { boolean.datatype | avt.datatype }?,
      attribute _byte-order-mark { avt.datatype }?,
      attribute cdata-section-elements { eqnames.datatype | avt.datatype }?,
      attribute _cdata-section-elements { avt.datatype }?,
      attribute doctype-public { string.datatype | avt.datatype }?,
      attribute _doctype-public { avt.datatype }?,
      attribute doctype-system { string.datatype | avt.datatype }?,
      attribute _doctype-system { avt.datatype }?,
      attribute encoding { string.datatype | avt.datatype }?,
      attribute _encoding { avt.datatype }?,
      attribute escape-uri-attributes { boolean.datatype | avt.datatype }?,
      attribute _escape-uri-attributes { avt.datatype }?,
      attribute html-version { decimal.datatype | avt.datatype }?,
      attribute _html-version { avt.datatype }?,
      attribute include-content-type { boolean.datatype | avt.datatype }?,
      attribute _include-content-type { avt.datatype }?,
      attribute indent { boolean.datatype | avt.datatype }?,
      attribute _indent { avt.datatype }?,
      attribute item-separator { string.datatype | avt.datatype }?,
      attribute _item-separator { avt.datatype }?,
      attribute json-node-output-method { "xml" | "html" | "xhtml" | "text" | eqname.datatype | avt.datatype }?,
      attribute _json-node-output-method { avt.datatype }?,
      attribute media-type { string.datatype | avt.datatype }?,
      attribute _media-type { avt.datatype }?,
      attribute normalization-form { "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | nmtoken.datatype | avt.datatype }?,
      attribute _normalization-form { avt.datatype }?,
      attribute omit-xml-declaration { boolean.datatype | avt.datatype }?,
      attribute _omit-xml-declaration { avt.datatype }?,
      attribute parameter-document { uri.datatype | avt.datatype }?,
      attribute _parameter-document { avt.datatype }?,
      attribute standalone { boolean.datatype | "omit" | avt.datatype }?,
      attribute _standalone { avt.datatype }?,
      attribute suppress-indentation { eqnames.datatype | avt.datatype }?,
      attribute _suppress-indentation { avt.datatype }?,
      attribute undeclare-prefixes { boolean.datatype | avt.datatype }?,
      attribute _undeclare-prefixes { avt.datatype }?,
      attribute use-character-maps { eqnames.datatype }?,
      attribute _use-character-maps { avt.datatype }?,
      attribute output-version { nmtoken.datatype | avt.datatype }?,
      attribute _output-version { avt.datatype }?,
      sequence-constructor.model
   }
output.element =
   element output {
      extension.atts,
      global.atts.except.version,
      attribute name { eqname.datatype }?,
      attribute _name { avt.datatype }?,
      attribute method { "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | eqname.datatype }?,
      attribute _method { avt.datatype }?,
      attribute allow-duplicate-names { boolean.datatype }?,
      attribute _allow-duplicate-names { avt.datatype }?,
      attribute build-tree { boolean.datatype }?,
      attribute _build-tree { avt.datatype }?,
      attribute byte-order-mark { boolean.datatype }?,
      attribute _byte-order-mark { avt.datatype }?,
      attribute cdata-section-elements { eqnames.datatype }?,
      attribute _cdata-section-elements { avt.datatype }?,
      attribute doctype-public { string.datatype }?,
      attribute _doctype-public { avt.datatype }?,
      attribute doctype-system { string.datatype }?,
      attribute _doctype-system { avt.datatype }?,
      attribute encoding { string.datatype }?,
      attribute _encoding { avt.datatype }?,
      attribute escape-uri-attributes { boolean.datatype }?,
      attribute _escape-uri-attributes { avt.datatype }?,
      attribute html-version { decimal.datatype }?,
      attribute _html-version { avt.datatype }?,
      attribute include-content-type { boolean.datatype }?,
      attribute _include-content-type { avt.datatype }?,
      attribute indent { boolean.datatype }?,
      attribute _indent { avt.datatype }?,
      attribute item-separator { string.datatype }?,
      attribute _item-separator { avt.datatype }?,
      attribute json-node-output-method { "xml" | "html" | "xhtml" | "text" | eqname.datatype }?,
      attribute _json-node-output-method { avt.datatype }?,
      attribute media-type { string.datatype }?,
      attribute _media-type { avt.datatype }?,
      attribute normalization-form { "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | nmtoken.datatype }?,
      attribute _normalization-form { avt.datatype }?,
      attribute omit-xml-declaration { boolean.datatype }?,
      attribute _omit-xml-declaration { avt.datatype }?,
      attribute parameter-document { uri.datatype }?,
      attribute _parameter-document { avt.datatype }?,
      attribute standalone { boolean.datatype | "omit" }?,
      attribute _standalone { avt.datatype }?,
      attribute suppress-indentation { eqnames.datatype }?,
      attribute _suppress-indentation { avt.datatype }?,
      attribute undeclare-prefixes { boolean.datatype }?,
      attribute _undeclare-prefixes { avt.datatype }?,
      attribute use-character-maps { eqnames.datatype }?,
      attribute _use-character-maps { avt.datatype }?,
      attribute version { nmtoken.datatype }?,
      attribute _version { avt.datatype }?,
      empty
   }
character-map.element =
   element character-map {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute use-character-maps { eqnames.datatype }?,
      attribute _use-character-maps { avt.datatype }?,
      (output-character.element*)
   }
output-character.element =
   element output-character {
      extension.atts,
      global.atts,
      (attribute character { char.datatype }
      | attribute _character { avt.datatype })+,
      (attribute string { string.datatype }
      | attribute _string { avt.datatype })+,
      empty
   }
avt.datatype =
  xsd:string
# {
#    pattern =
#      """([^\{\}]|\{\{|\}\}|\{([^"'\{\}]|"[^"]*"|'[^']*')+\})*""" # this regexp will not work in all the case.
#      }
</span></pre><pre class="font-size: small" xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90"># XSLT 4.0 Relax NG Schema
# 
# Copyright (c) 2010-2016, Mohamed ZERGAOUI (Innovimax)
# Portions © 2024, XQuery and XSLT Extensions Community Group
# 
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer. Redistributions in binary
# form must reproduce the above copyright notice, this list of conditions and
# the following disclaimer in the documentation and/or other materials provided
# with the distribution. Neither the name of the Mohamed ZERGAOUI or Innovimax
# nor the names of its contributors may be used to endorse or promote products
# derived from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# 
namespace local = ""
default namespace xsl = "http://www.w3.org/1999/XSL/Transform"
namespace xs = "http://www.w3.org/2001/XMLSchema"

start =
  stylesheet.element
  | transform.element
  | package.element  
  | literal-result-element-as-stylesheet
  
sequence-constructor.model = (instruction.category | record.element | literal-result-element | text)*

literal-result-element-as-stylesheet =
  element * - xsl:* {
    attribute xsl:version { decimal.datatype },
    literal-result-element-no-version.atts,
    sequence-constructor.model
  }

literal-result-element =
  element * - xsl:* {
     literal-result-element.atts,
     sequence-constructor.model
  }

literal-result-element.atts =
  literal-result-element-no-version.atts,
  attribute xsl:version { text }?

# These attributes may also appear on a literal result element, but in this case, to distinguish them from user-defined attributes, 
# the names of the attributes are in the XSLT namespace. They are thus typically written as 
# xsl:default-collation,
# xsl:default-mode,
# xsl:default-validation,
# xsl:exclude-result-prefixes,
# xsl:expand-text,
# xsl:extension-element-prefixes,
# xsl:use-when,
# xsl:version,
# or xsl:xpath-default-namespace.
literal-result-element-no-version.atts =
   attribute * - xsl:* { avt.datatype }*
 &amp; attribute xsl:default-collation { uris.datatype }?
 &amp; attribute xsl:default-mode { eqname.datatype | '#unnamed' }?
 &amp; attribute xsl:default-validation  { "preserve" | "strip" }?
 &amp; attribute xsl:exclude-result-prefixes { exclude.prefixes.datatype }? # or prefixes.datatype ?
 &amp; attribute xsl:expand-text { boolean.datatype }?
 &amp; attribute xsl:extension-element-prefixes { extension.prefixes.datatype }? # or prefixes.datatype ?
 &amp; attribute xsl:inherit-namespaces { boolean.datatype }?
 &amp; attribute xsl:on-empty { expression.datatype }?
 &amp; attribute xsl:use-attribute-sets { eqnames.datatype }?
 &amp; attribute xsl:use-when { expression.datatype }?
 &amp; attribute xsl:xpath-default-namespace { xsd:anyURI }?
 &amp; attribute xsl:schema-role { ncname.datatype }?
 &amp; (attribute xsl:type { eqname.datatype }
    | attribute xsl:validation { "strict" | "lax" | "preserve" | "strip" })?


top-level-extension =
  element * - (xsl:* | local:*) {
     anyElement
  }

anyElement =
   grammar {
      start = any
      any =
        (attribute * { text }
         | text
         | element * { any })*
    }
    
extension.atts = attribute * - (xsl:* | local:*) { text }*

declarations.model = (declaration.category | top-level-extension)*

# [Definition: There are a number of standard attributes that may appear on any XSLT element: specifically 
# default-collation, 
# default-mode, 
# default-validation, 
# exclude-result-prefixes, 
# expand-text, 
# extension-element-prefixes, 
# use-when, 
# version, 
# and xpath-default-namespace.]

global.atts = 
   attribute default-collation { uris.datatype }?,
   attribute _default-collation { avt.datatype }?,
   attribute default-mode { eqname.datatype | '#unnamed' }?,
   attribute _default-mode { avt.datatype }?,
   attribute default-validation  { "preserve" | "strip" }?,
   attribute _default-validation { avt.datatype }?,   
   attribute exclude-result-prefixes { exclude.prefixes.datatype }?,
   attribute _exclude-result-prefixes { avt.datatype }?, # or prefixes.datatype ?
   attribute expand-text { boolean.datatype }?,
   attribute _expand-text { avt.datatype }?,
   attribute extension-element-prefixes { extension.prefixes.datatype }?,
   attribute _extension-element-prefixes { avt.datatype }?, # or prefixes.datatype ?
   attribute use-when { expression.datatype }?,
   attribute _use-when { avt.datatype }?,
   attribute version { decimal.datatype }?,
   attribute _version { avt.datatype }?,
   attribute xpath-default-namespace { uri.datatype }?,
   attribute _xpath-default-namespace { avt.datatype }?
   

global.atts.except.version = 
   attribute default-collation { uris.datatype }?,
   attribute _default-collation { avt.datatype }?,
   attribute exclude-result-prefixes { exclude.prefixes.datatype }?,
   attribute _exclude-result-prefixes { avt.datatype }?, # or prefixes.datatype ?
   attribute expand-text { boolean.datatype }?,
   attribute _expand-text { avt.datatype }?,
   attribute extension-element-prefixes { extension.prefixes.datatype }?,
   attribute _extension-element-prefixes { avt.datatype }?, # or prefixes.datatype ?
   attribute use-when { expression.datatype }?,
   attribute _use-when { avt.datatype }?,
   attribute xpath-default-namespace { uri.datatype }?,
   attribute _xpath-default-namespace { avt.datatype }?
   
# In XSLT 4.0, prefixes can be defined with the fixed-namespaces attribute
# on the xsl:stylesheet, so we can't rely on XML declarations for QNames.
qname.strict = xsd:token { pattern = "[\i-[:]][\c-[:]]*:[\i-[:]][\c-[:]]*" }
qname.datatype = xsd:NCName | qname.strict

# Extract from XPath 3.0
#[94]   EQName           ::= QName | URIQualifiedName
#[104]  QName            ::= [http://www.w3.org/TR/REC-xml-names/#NT-QName]Names
#[105]  NCName           ::= [http://www.w3.org/TR/REC-xml-names/#NT-NCName]Names
#[99]   URIQualifiedName ::= BracedURILiteral NCName
#[100]  BracedURILiteral ::= "Q" "{" [^{}]* "}"

uri.qualified.name = xsd:token { pattern = "Q\{[^\{\}]*\}[\i-[:]][\c-[:]]*" } 
eqname.datatype = qname.datatype | uri.qualified.name
qnames.datatype = list { qname.datatype* }
eqnames.datatype = list { eqname.datatype* }
ncname.datatype = xsd:NCName
prefix.datatype = xsd:NCName
boolean.datatype = "yes" | "no" | "true" | "false" | "0" | "1" 
expression.datatype = text
char.datatype = xsd:string { length = "1" }
string.datatype = text
id.datatype = xsd:NCName
tokens.datatype = list { token* }
prefixes.datatype = list { token* }
extension.prefixes.datatype = list { xsd:NCName* }
exclude.prefixes.datatype = list { "#all" | (xsd:NCName | "#default")* }
token.datatype = token
language.datatype = xsd:language
nmtoken.datatype = xsd:NMTOKEN
decimal.datatype = xsd:decimal
integer.datatype = xsd:integer
uri.datatype = xsd:anyURI
uris.datatype = list { xsd:anyURI* }
pattern.datatype = text
qname-but-not-ncname.datatype = xsd:QName { pattern = ".*:.*" }
xs_schema.element = element xs:schema { anyElement* }
item-type.datatype = text
sequence-type.datatype = text

# #standard or NCName or prefix=URI or URI
fixed-namespaces.datatype = xsd:string

select-or-sequence-constructor.model =
  ((attribute select { expression.datatype }
    | attribute _select { avt.datatype })+
   | sequence-constructor.model)

declaration.category =
   use-package.element
 | include.element
 | import.element
 | import-schema.element
 | strip-space.element
 | preserve-space.element
 | decimal-format.element
 | template.element
 | mode.element
 | global-context-item.element
 | variable.element
 | param.element
 | attribute-set.element
 | function.element
 | namespace-alias.element
 | accumulator.element
 | key.element
 | output.element
 | character-map.element

instruction.category =
   apply-templates.element
 | apply-imports.element
 | next-match.element
 | for-each.element
 | iterate.element
 | next-iteration.element
 | break.element
 | if.element
 | choose.element
 | switch.element
 | try.element
 | variable.element
 | call-template.element
 | evaluate.element
 | element.element
 | attribute.element
 | text.element
 | value-of.element
 | document.element
 | processing-instruction.element
 | namespace.element
 | comment.element
 | copy.element
 | copy-of.element
 | sequence.element
 | where-populated.element
 | on-empty.element
 | on-non-empty.element
 | number.element
 | perform-sort.element
 | for-each-group.element
 | merge.element
 | fork.element
 | analyze-string.element
 | source-document.element
 | map.element
 | map-entry.element
 | array.element
 | array-member.element
 | message.element
 | assert.element
 | fallback.element
 | result-document.element
 | select.element
package.element =
   element package {
      extension.atts,
      attribute id { id.datatype }?,
      attribute _id { avt.datatype }?,
      attribute name { uri.datatype }?,
      attribute _name { avt.datatype }?,
      attribute package-version { string.datatype }?,
      attribute _package-version { avt.datatype }?,
      attribute version { decimal.datatype }?,
      attribute _version { avt.datatype }?,
      attribute input-type-annotations { "preserve" | "strip" | "unspecified" }?,
      attribute _input-type-annotations { avt.datatype }?,
      attribute declared-modes { boolean.datatype }?,
      attribute _declared-modes { avt.datatype }?,
      attribute default-mode { eqname.datatype | "#unnamed" }?,
      attribute _default-mode { avt.datatype }?,
      attribute default-validation { "preserve" | "strip" }?,
      attribute _default-validation { avt.datatype }?,
      attribute default-collation { uris.datatype }?,
      attribute _default-collation { avt.datatype }?,
      attribute extension-element-prefixes { prefixes.datatype }?,
      attribute _extension-element-prefixes { avt.datatype }?,
      attribute exclude-result-prefixes { prefixes.datatype }?,
      attribute _exclude-result-prefixes { avt.datatype }?,
      attribute expand-text { boolean.datatype }?,
      attribute _expand-text { avt.datatype }?,
      attribute use-when { expression.datatype }?,
      attribute _use-when { avt.datatype }?,
      attribute xpath-default-namespace { uri.datatype }?,
      attribute _xpath-default-namespace { avt.datatype }?,
      attribute fixed-namespaces { fixed-namespaces.datatype }?,
      attribute _fixed-namespaces { fixed-namespaces.datatype }?,
      ((expose.element | declarations.model)*)
   }
use-package.element =
   element use-package {
      extension.atts,
      global.atts,
      attribute name { uri.datatype }?,
      attribute _name { avt.datatype }?,
      attribute package-version { string.datatype }?,
      attribute _package-version { avt.datatype }?,
      (package-location.element | accept.element | override.element)*
   }
expose.element =
   element expose {
      extension.atts,
      global.atts,
      attribute component { "template" | "function" | "attribute-set" | "variable" | "mode" | "*" }?,
      attribute _component { avt.datatype }?,
      attribute names { tokens.datatype }?,
      attribute _names { avt.datatype }?,
      attribute visibility { "public" | "private" | "final" | "abstract" }?,
      attribute _visibility { avt.datatype }?,
      empty
   }
package-location.element =
   element package-location {
      extension.atts,
      global.atts,    
      (attribute path-in-archive { string.datatype } |
      attribute _path-in-archive { avt.datatype })+,
      (attribute archive-type { string.datatype } |
      attribute _archive-type { avt.datatype })+,
      (attribute is-priority { boolean.datatype } |
      attribute _is-priority { avt.datatype })+,
      (attribute format { string.datatype } |
      attribute _format { avt.datatype })+,
      empty
   }   
accept.element =
   element accept {
      extension.atts,
      global.atts,
      (attribute component { "template" | "function" | "attribute-set" | "variable" | "mode" | "*" } |
      attribute _component { avt.datatype })+,
      (attribute names { tokens.datatype } |
      attribute _names { avt.datatype })+,
      (attribute visibility { "public" | "private" | "final" | "abstract" | "hidden" } |
      attribute _visibility { avt.datatype })+,
      empty
   }
override.element =
   element override {
      extension.atts,
      global.atts,
      (template.element | function.element | variable.element | param.element | attribute-set.element)*
   }
stylesheet.element =
   element stylesheet {
      extension.atts,
      attribute id { id.datatype }?,
      attribute _id { avt.datatype }?,
      attribute version { decimal.datatype }?,
      attribute _version { avt.datatype }?,
      attribute default-mode { eqname.datatype | "#unnamed" }?,
      attribute _default-mode { avt.datatype }?,
      attribute default-validation { "preserve" | "strip" }?,
      attribute _default-validation { avt.datatype }?,
      attribute input-type-annotations { "preserve" | "strip" | "unspecified" }?,
      attribute _input-type-annotations { avt.datatype }?,
      attribute default-collation { uris.datatype }?,
      attribute _default-collation { avt.datatype }?,
      attribute extension-element-prefixes { prefixes.datatype }?,
      attribute _extension-element-prefixes { avt.datatype }?,
      attribute exclude-result-prefixes { prefixes.datatype }?,
      attribute _exclude-result-prefixes { avt.datatype }?,
      attribute expand-text { boolean.datatype }?,
      attribute _expand-text { avt.datatype }?,
      attribute use-when { expression.datatype }?,
      attribute _use-when { avt.datatype }?,
      attribute xpath-default-namespace { uri.datatype }?,
      attribute _xpath-default-namespace { avt.datatype }?,
      attribute fixed-namespaces { fixed-namespaces.datatype }?,
      attribute _fixed-namespaces { fixed-namespaces.datatype }?,
      (declarations.model)
   }
transform.element =
   element transform {
      extension.atts,
      attribute id { id.datatype }?,
      attribute _id { avt.datatype }?,
      attribute version { decimal.datatype }?,
      attribute _version { avt.datatype }?,
      attribute default-mode { eqname.datatype | "#unnamed" }?,
      attribute _default-mode { avt.datatype }?,
      attribute default-validation { "preserve" | "strip" }?,
      attribute _default-validation { avt.datatype }?,
      attribute input-type-annotations { "preserve" | "strip" | "unspecified" }?,
      attribute _input-type-annotations { avt.datatype }?,
      attribute default-collation { uris.datatype }?,
      attribute _default-collation { avt.datatype }?,
      attribute extension-element-prefixes { prefixes.datatype }?,
      attribute _extension-element-prefixes { avt.datatype }?,
      attribute exclude-result-prefixes { prefixes.datatype }?,
      attribute _exclude-result-prefixes { avt.datatype }?,
      attribute expand-text { boolean.datatype }?,
      attribute _expand-text { avt.datatype }?,
      attribute use-when { expression.datatype }?,
      attribute _use-when { avt.datatype }?,
      attribute xpath-default-namespace { uri.datatype }?,
      attribute _xpath-default-namespace { avt.datatype }?,
      attribute fixed-namespaces { fixed-namespaces.datatype }?,
      attribute _fixed-namespaces { fixed-namespaces.datatype }?,
      (declarations.model)
   }
include.element =
   element include {
      extension.atts,
      global.atts,
      attribute href { uri.datatype }?,
      attribute _href { avt.datatype }?,
      empty
   }
import.element =
   element import {
      extension.atts,
      global.atts,
      (attribute href { uri.datatype }
      | attribute _href { avt.datatype })+,
      empty
   }
import-schema.element =
   element import-schema {
      extension.atts,
      global.atts,
      attribute namespace { uri.datatype }?,
      attribute _namespace { avt.datatype }?,
      attribute schema-location { uri.datatype }?,
      attribute _schema-location { avt.datatype }?,
      xs_schema.element?
   }
strip-space.element =
   element strip-space {
      extension.atts,
      global.atts,
      (attribute elements { tokens.datatype }
      | attribute _elements { avt.datatype })+,
      empty
   }
preserve-space.element =
   element preserve-space {
      extension.atts,
      global.atts,
      (attribute elements { tokens.datatype }
      | attribute _elements { avt.datatype })+,
      empty
   }
decimal-format.element =
   element decimal-format {
      extension.atts,
      global.atts,
      attribute name { eqname.datatype }?,
      attribute _name { avt.datatype }?,
      attribute decimal-separator { char.datatype }?,
      attribute _decimal-separator { avt.datatype }?,
      attribute grouping-separator { char.datatype }?,
      attribute _grouping-separator { avt.datatype }?,
      attribute infinity { string.datatype }?,
      attribute _infinity { avt.datatype }?,
      attribute minus-sign { char.datatype }?,
      attribute _minus-sign { avt.datatype }?,
      attribute exponent-separator { char.datatype }?,
      attribute _exponent-separator { avt.datatype }?,
      attribute NaN { string.datatype }?,
      attribute _NaN { avt.datatype }?,
      attribute percent { char.datatype }?,
      attribute _percent { avt.datatype }?,
      attribute per-mille { char.datatype }?,
      attribute _per-mille { avt.datatype }?,
      attribute zero-digit { char.datatype }?,
      attribute _zero-digit { avt.datatype }?,
      attribute digit { char.datatype }?,
      attribute _digit { avt.datatype }?,
      attribute pattern-separator { char.datatype }?,
      attribute _pattern-separator { avt.datatype }?,
      empty
   }
template.element =
   element template {
      extension.atts,
      global.atts,
      (attribute match { pattern.datatype }
      | attribute _match { avt.datatype }
      | attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute priority { decimal.datatype }?,
      attribute _priority { avt.datatype }?,
      attribute mode { list { '#all' | ('#default' | '#unnamed' | eqname.datatype)* } }?,
      attribute _mode { avt.datatype }?,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute visibility { "public" | "private" | "final" | "abstract" }?,
      attribute _visibility { avt.datatype }?,
      (context-item.element?, param.element*, sequence-constructor.model)
   }
apply-templates.element =
   element apply-templates {
      extension.atts,
      global.atts,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      attribute mode { (eqname.datatype | '#unnamed' | '#default' | '#current') }?,
      attribute _mode { avt.datatype }?,
      attribute separator { avt.datatype }?,
      attribute _separator { avt.datatype }?,
      (sort.element | with-param.element)*
   }
mode.element =
   element mode {
      extension.atts,
      global.atts,
      (attribute as { sequence-type.datatype }?
      | attribute _as { avt.datatype }?),
      (attribute copy-namespaces { boolean.datatype }?
      | attribute _copy-namespaces { boolean.datatype }?),
      (attribute name { eqname.datatype }?
      | attribute _name { avt.datatype }?),
      (attribute streamable { boolean.datatype }?
      | attribute _streamable { avt.datatype }?),
      (attribute on-no-match { "deep-copy" | "shallow-copy" | "shallow-copy-all" | "deep-skip" | "shallow-skip" | "text-only-copy" | "fail" }?
      | attribute _on-no-match { avt.datatype }?),
      (attribute on-multiple-match { "use-last" | "fail" }?
      | attribute _on-multiple-match { avt.datatype }?),
      (attribute warning-on-no-match { boolean.datatype }?
      | attribute _warning-on-no-match { avt.datatype }?),
      (attribute warning-on-multiple-match { boolean.datatype }?
      | attribute _warning-on-multiple-match { avt.datatype }?),
      (attribute typed { boolean.datatype | "strict" | "lax" | "unspecified" }?
      | attribute _typed { avt.datatype }?),
      (attribute visibility { "public" | "private" | "final" }?
      | attribute _visibility { avt.datatype }?),
      (attribute use-accumulators { tokens.datatype }?
      | attribute _use-accumulators { avt.datatype }?),
      empty
   }
context-item.element =
   element context-item {
      extension.atts,
      global.atts,
      attribute as { item-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute use { "required" | "optional" | "absent" }?,
      attribute _use { avt.datatype }?,
      empty
   }
global-context-item.element =
   element global-context-item {
      extension.atts,
      global.atts,
      attribute as { item-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute use { "required" | "optional" | "absent" }?,
      attribute _use { avt.datatype }?,
      empty
   }
apply-imports.element =
   element apply-imports {
      extension.atts,
      global.atts,
      with-param.element*
   }
next-match.element =
   element next-match {
      extension.atts,
      global.atts,
      (with-param.element | fallback.element)*
   }
for-each.element =
   element for-each {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      (sort.element*, sequence-constructor.model)
   }
iterate.element =
   element iterate {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      (param.element*, on-completion.element?, sequence-constructor.model)
   }
next-iteration.element =
   element next-iteration {
      extension.atts,
      global.atts,
      (with-param.element*)
   }
break.element =
   element break {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })?,
      sequence-constructor.model
   }
on-completion.element =
   element on-completion {
      extension.atts,
      global.atts,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      sequence-constructor.model
   }
if.element =
   element if {
      extension.atts,
      global.atts,
      (attribute test { expression.datatype }
      | attribute _test { avt.datatype })+,
      sequence-constructor.model
   }
choose.element =
   element choose {
      extension.atts,
      global.atts,
      (when.element+, otherwise.element?)
   }
when.element =
   element when {
      extension.atts,
      global.atts,
      (attribute test { expression.datatype }
      | attribute _test { avt.datatype })+,
      select-or-sequence-constructor.model
   }
otherwise.element =
   element otherwise {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }

switch.element =
  element switch {
    extension.atts,
    global.atts,
    (attribute select { expression.datatype }
    | attribute _select { avt.datatype })+,
    (when.element+, otherwise.element?, fallback.element*)
  }

try.element =
   element try {
      extension.atts,
      global.atts,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      attribute rollback-output { boolean.datatype }?,
      attribute _rollback-output { avt.datatype }?,
      (sequence-constructor.model, catch.element, (catch.element | fallback.element)*)
   }
catch.element =
   element catch {
      extension.atts,
      global.atts,
      attribute errors { tokens.datatype }?,
      attribute _errors { avt.datatype }?,
      select-or-sequence-constructor.model
   }
variable.element =
   element variable {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute static { boolean.datatype }?,
      attribute _static { avt.datatype }?,
      attribute visibility { "public" | "private" | "final" | "abstract" }?,
      attribute _visibility { avt.datatype }?,
      select-or-sequence-constructor.model
   }
param.element =
   element param {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute required { boolean.datatype }?,
      attribute _required { avt.datatype }?,
      attribute tunnel { boolean.datatype }?,
      attribute _tunnel { avt.datatype }?,
      attribute static { boolean.datatype }?,
      attribute _static { avt.datatype }?,
      select-or-sequence-constructor.model
   }
with-param.element =
   element with-param {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute tunnel { boolean.datatype }?,
      attribute _tunnel { avt.datatype }?,
      select-or-sequence-constructor.model
   }
call-template.element =
   element call-template {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      with-param.element*
   }
attribute-set.element =
   element attribute-set {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute use-attribute-sets { eqnames.datatype }?,
      attribute _use-attribute-sets { avt.datatype }?,
      attribute visibility { "public" | "private" | "final" | "abstract" }?,
      attribute _visibility { avt.datatype }?,
      attribute streamable { boolean.datatype }?,
      attribute _streamable { avt.datatype }?,
      attribute.element*
   }
function.element =
   element function {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      (attribute as { sequence-type.datatype }?
      | attribute _as { avt.datatype }?),
      (attribute visibility { "public" | "private" | "final" | "abstract" }?
      | attribute _visibility { avt.datatype }?),
      (attribute streamability { "unclassified" | "absorbing" | "inspection" | "filter" | "shallow-descent" | "deep-descent" | "ascent" | eqname.datatype }?
      | attribute _streamability { avt.datatype }?),
      (attribute override-extension-function { boolean.datatype }?
      | attribute _override-extension-function { avt.datatype }?),
      (attribute override { boolean.datatype }?
      | attribute _override { avt.datatype }?),
      (attribute new-each-time { "yes" | "true" | "1" | "no" | "false" | "0" | "maybe" }?
      | attribute _new-each-time { avt.datatype }?),
      (attribute cache { boolean.datatype }?
      | attribute _cache { avt.datatype }?),
      (param.element*, sequence-constructor.model)
   }
evaluate.element =
   element evaluate {
      extension.atts,
      global.atts,
      (attribute xpath { expression.datatype }
      | attribute _xpath { avt.datatype })+,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute base-uri { uri.datatype | avt.datatype }?,
      attribute _base-uri { avt.datatype }?,
      attribute with-params { expression.datatype }?,
      attribute _with-params { avt.datatype }?,
      attribute context-item { expression.datatype }?,
      attribute _context-item { avt.datatype }?,
      attribute namespace-context { expression.datatype }?,
      attribute _namespace-context { avt.datatype }?,
      attribute schema-aware { boolean.datatype | avt.datatype }?,
      attribute _schema-aware { avt.datatype }?,
      (with-param.element | fallback.element)*
   }
namespace-alias.element =
   element namespace-alias {
      extension.atts,
      global.atts,
      (attribute stylesheet-prefix { prefix.datatype | "#default" }
      | attribute _stylesheet-prefix { avt.datatype })+,
      (attribute result-prefix { prefix.datatype | "#default" }
      | attribute _result-prefix { avt.datatype })+,
      empty
   }
element.element =
   element element {
      extension.atts,
      global.atts,
      (attribute name { qname.datatype | avt.datatype }
      | attribute _name { avt.datatype })+,
      attribute namespace { uri.datatype | avt.datatype }?,
      attribute _namespace { avt.datatype }?,
      attribute inherit-namespaces { boolean.datatype }?,
      attribute _inherit-namespaces { avt.datatype }?,
      attribute use-attribute-sets { eqnames.datatype }?,
      attribute _use-attribute-sets { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      sequence-constructor.model
   }
attribute.element =
   element attribute {
      extension.atts,
      global.atts,
      (attribute name { qname.datatype | avt.datatype }
      | attribute _name { avt.datatype })+,
      attribute namespace { uri.datatype | avt.datatype }?,
      attribute _namespace { avt.datatype }?,
      attribute separator { string.datatype | avt.datatype }?,
      attribute _separator { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      select-or-sequence-constructor.model
   }
text.element =
   element text {
      extension.atts,
      global.atts,
      attribute separator { string.datatype | avt.datatype }?,
      attribute _separator { avt.datatype }?,
      attribute cdata { boolean.datatype | avt.datatype }?,
      attribute _cdata { avt.datatype }?,
      attribute disable-output-escaping { boolean.datatype }?,
      attribute _disable-output-escaping { avt.datatype }?,
      text
   }
value-of.element =
   element value-of {
      extension.atts,
      global.atts,
      attribute separator { string.datatype | avt.datatype }?,
      attribute _separator { avt.datatype }?,
      attribute cdata { boolean.datatype | avt.datatype }?,
      attribute _cdata { avt.datatype }?,
      attribute disable-output-escaping { boolean.datatype }?,
      attribute _disable-output-escaping { avt.datatype }?,
      select-or-sequence-constructor.model
   }
document.element =
   element document {
      extension.atts,
      global.atts,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      sequence-constructor.model
   }
processing-instruction.element =
   element processing-instruction {
      extension.atts,
      global.atts,
      (attribute name { ncname.datatype | avt.datatype }
      | attribute _name { avt.datatype }),
      select-or-sequence-constructor.model
   }
record.element = 
   element record {
      (attribute as { sequence-type.datatype }?
      | attribute _as { avt.datatype }?),
      (attribute duplicates { expression.datatype }?
      | attribute _duplicates { avt.datatype }?),
      sequence-constructor.model
  }
record-type.element = 
   element record-type {
      (attribute name { ncname.datatype | avt.datatype }
      | attribute _name { avt.datatype }),
      (attribute extensible { boolean.datatype }?
      | attribute _extensible { avt.datatype }?),
      (attribute visibility { "public" | "private" | "final" | "abstract" | "hidden" }?
      | attribute _visibility { avt.datatype }?),
      field.element*
  }
field.element = 
   element field {
      (attribute name { ncname.datatype | avt.datatype }
      | attribute _name { avt.datatype }),
      (attribute as { sequence-type.datatype }?
      | attribute _as { avt.datatype }?),
      (attribute required { boolean.datatype }?
      | attribute _required { avt.datatype }?),
      (attribute \default { expression.datatype }?
      |attribute _default { expression.datatype }?),
      empty
  }

select.element = 
   element select {
      (attribute as { sequence-type.datatype }?
      | attribute _as { avt.datatype }?),
      (fallback.element | text)*
  }
namespace.element =
   element namespace {
      extension.atts,
      global.atts,
      (attribute name { ncname.datatype | avt.datatype }
      | attribute _name { avt.datatype })+,
      select-or-sequence-constructor.model
   }
comment.element =
   element comment {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }
copy.element =
   element copy {
      extension.atts,
      global.atts,
      attribute copy-namespaces { boolean.datatype }?,
      attribute _copy-namespaces { avt.datatype }?,
      attribute inherit-namespaces { boolean.datatype }?,
      attribute _inherit-namespaces { avt.datatype }?,
      attribute use-attribute-sets { eqnames.datatype }?,
      attribute _use-attribute-sets { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      sequence-constructor.model
   }
copy-of.element =
   element copy-of {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      attribute copy-accumulators { boolean.datatype }?,
      attribute _copy-accumulators { avt.datatype }?,
      attribute copy-namespaces { boolean.datatype }?,
      attribute _copy-namespaces { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      empty
   }
sequence.element =
   element sequence {
      extension.atts,
      global.atts,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      select-or-sequence-constructor.model
   }
where-populated.element =
   element where-populated {
      extension.atts,
      global.atts,
      sequence-constructor.model
   }
on-empty.element =
   element on-empty {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }
on-non-empty.element =
   element on-non-empty {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }
number.element =
   element number {
      extension.atts,
      global.atts,
      attribute value { expression.datatype }?,
      attribute _value { avt.datatype }?,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      attribute level { "single" | "multiple" | "any" }?,
      attribute _level { avt.datatype }?,
      attribute count { pattern.datatype }?,
      attribute _count { avt.datatype }?,
      attribute from { pattern.datatype }?,
      attribute _from { avt.datatype }?,
      attribute format { string.datatype | avt.datatype }?,
      attribute _format { avt.datatype }?,
      attribute lang { language.datatype | avt.datatype }?,
      attribute _lang { avt.datatype }?,
      attribute letter-value { "alphabetic" | "traditional" | avt.datatype }?,
      attribute _letter-value { avt.datatype }?,
      attribute ordinal { string.datatype | avt.datatype }?,
      attribute _ordinal { avt.datatype }?,
      attribute start-at { integer.datatype | avt.datatype }?,
      attribute _start-at { avt.datatype }?,
      attribute grouping-separator { char.datatype | avt.datatype }?,
      attribute _grouping-separator { avt.datatype }?,
      attribute grouping-size { integer.datatype | avt.datatype }?,
      attribute _grouping-size { avt.datatype }?,
      empty
   }
sort.element =
   element sort {
      extension.atts,
      global.atts,
      attribute lang { language.datatype | avt.datatype }?,
      attribute _lang { avt.datatype }?,
      attribute order { "ascending" | "descending" | avt.datatype }?,
      attribute _order { avt.datatype }?,
      attribute collation { uri.datatype | avt.datatype }?,
      attribute _collation { avt.datatype }?,
      attribute stable { boolean.datatype | avt.datatype }?,
      attribute _stable { avt.datatype }?,
      attribute case-order { "upper-first" | "lower-first" | avt.datatype }?,
      attribute _case-order { avt.datatype }?,
      attribute data-type { "text" | "number" | eqname.datatype | avt.datatype }?,
      attribute _data-type { avt.datatype }?,
      select-or-sequence-constructor.model
   }
perform-sort.element =
   element perform-sort {
      extension.atts,
      global.atts,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      (sort.element+, sequence-constructor.model)
   }
for-each-group.element =
   element for-each-group {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      ((attribute group-by { expression.datatype }?,
      attribute _group-by { avt.datatype }?) |
      (attribute group-adjacent { expression.datatype }?,
      attribute _group-adjacent { avt.datatype }?) |
      (attribute group-starting-with { pattern.datatype }?,
      attribute _group-starting-with { avt.datatype }?) |
      (attribute group-ending-with { pattern.datatype }?,
      attribute _group-ending-with { avt.datatype }?)),
      attribute composite { boolean.datatype }?,
      attribute _composite { avt.datatype }?,
      attribute collation { uri.datatype | avt.datatype }?,
      attribute _collation { avt.datatype }?,
      (sort.element*, sequence-constructor.model)
   }
merge.element =
   element merge {
      extension.atts,
      global.atts,
      (merge-source.element+, merge-action.element, fallback.element*)
   }
merge-source.element =
   element merge-source {
      extension.atts,
      global.atts,
      attribute name { ncname.datatype }?,
      attribute _name { avt.datatype }?,
      attribute for-each-item { expression.datatype }?,
      attribute _for-each-item { avt.datatype }?,
      attribute for-each-stream { expression.datatype }?,
      attribute _for-each-stream { avt.datatype }?,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      attribute streamable { boolean.datatype }?,
      attribute _streamable { avt.datatype }?,
      attribute use-accumulators { tokens.datatype }?,
      attribute _use-accumulators { avt.datatype }?,
      attribute sort-before-merge { boolean.datatype }?,
      attribute _sort-before-merge { avt.datatype }?,
      attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }?,
      attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?,
      attribute for-each-source { expression.datatype }?,
      attribute _for-each-source { avt.datatype }?,
      merge-key.element+
   }
merge-key.element =
   element merge-key {
      extension.atts,
      global.atts,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      attribute lang { language.datatype | avt.datatype }?,
      attribute _lang { avt.datatype }?,
      attribute order { "ascending" | "descending" | avt.datatype }?,
      attribute _order { avt.datatype }?,
      attribute collation { uri.datatype | avt.datatype }?,
      attribute _collation { avt.datatype }?,
      attribute case-order { "upper-first" | "lower-first" | avt.datatype }?,
      attribute _case-order { avt.datatype }?,
      attribute data-type { "text" | "number" | eqname.datatype | avt.datatype }?,
      attribute _data-type { avt.datatype }?,
      sequence-constructor.model
   }
merge-action.element =
   element merge-action {
      extension.atts,
      global.atts,
      sequence-constructor.model
   }
fork.element =
   element fork {
      extension.atts,
      global.atts,
      (fallback.element*, ((sequence.element, fallback.element*)* | (for-each-group.element, fallback.element*)))
   }
analyze-string.element =
   element analyze-string {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      (attribute regex { string.datatype | avt.datatype }
      | attribute _regex { avt.datatype })+,
      attribute flags { string.datatype | avt.datatype }?,
      attribute _flags { avt.datatype }?,
      (matching-substring.element?, non-matching-substring.element?, fallback.element*)
   }
matching-substring.element =
   element matching-substring {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }
non-matching-substring.element =
   element non-matching-substring {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }
source-document.element =
   element source-document {
      extension.atts,
      global.atts,
      (attribute href { uri.datatype | avt.datatype }
      | attribute _href { avt.datatype })+,
      attribute use-accumulators { tokens.datatype }?,
      attribute _use-accumulators { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      attribute streamable { boolean.datatype }?,
      attribute _streamable { avt.datatype }?,
      sequence-constructor.model
   }
accumulator.element =
   element accumulator {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype }),
      (attribute initial-value { expression.datatype }
      | attribute _initial-value { avt.datatype }),
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute streamable { boolean.datatype }?,
      attribute _streamable { avt.datatype }?,
      accumulator-rule.element+
   }
accumulator-rule.element =
   element accumulator-rule {
      extension.atts,
      global.atts,
      (attribute match { pattern.datatype } |
      attribute _match { avt.datatype })+,
      attribute phase { "start" | "end" }?,
      attribute _phase { avt.datatype }?,
      select-or-sequence-constructor.model
   }
key.element =
   element key {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      (attribute match { pattern.datatype }
      | attribute _match { avt.datatype })+,
      attribute use { expression.datatype }?,
      attribute _use { avt.datatype }?,
      attribute composite { boolean.datatype }?,
      attribute _composite { avt.datatype }?,
      attribute collation { uri.datatype }?,
      attribute _collation { avt.datatype }?,
      sequence-constructor.model
   }
map.element =
   element map {
      (attribute duplicates { expression.datatype }?
      | attribute _duplicates { avt.datatype }?),
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }

map-entry.element =
   element map-entry {
      extension.atts,
      global.atts,
      (attribute key { expression.datatype }
      | attribute _key { avt.datatype }),
      select-or-sequence-constructor.model
   }

array.element =
  element array {
    (attribute for-each { expression.datatype }
     | attribute _for-each { expression.datatype }),
    extension.atts,
    global.atts,
    select-or-sequence-constructor.model
  }

array-member.element =
  element array-member {
    extension.atts,
    global.atts,
    select-or-sequence-constructor.model
  }

message.element =
   element message {
      extension.atts,
      global.atts,
      attribute terminate { boolean.datatype | avt.datatype }?,
      attribute _terminate { avt.datatype }?,
      attribute error-code { eqname.datatype | avt.datatype }?,
      attribute _error-code { avt.datatype }?,
      select-or-sequence-constructor.model
   }
assert.element =
   element assert {
      extension.atts,
      global.atts,
      (attribute test { expression.datatype }
      | attribute _test { avt.datatype })+,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      attribute error-code { eqname.datatype | avt.datatype }?,
      attribute _error-code { avt.datatype }?,
      sequence-constructor.model
   }
fallback.element =
   element fallback {
      extension.atts,
      global.atts,
      sequence-constructor.model
   }
result-document.element =
   element result-document {
      extension.atts,
      global.atts,
      attribute format { eqname.datatype | avt.datatype }?,
      attribute _format { avt.datatype }?,
      attribute href { uri.datatype | avt.datatype }?,
      attribute _href { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive      
      attribute method { "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | eqname.datatype | avt.datatype }?,
      attribute _method { avt.datatype }?,
      attribute allow-duplicate-names { boolean.datatype | avt.datatype }?,
      attribute _allow-duplicate-names { avt.datatype }?,
      attribute build-tree { boolean.datatype | avt.datatype }?,
      attribute _build-tree { avt.datatype }?,
      attribute byte-order-mark { boolean.datatype | avt.datatype }?,
      attribute _byte-order-mark { avt.datatype }?,
      attribute canonical { boolean.datatype | avt.datatype }?,
      attribute _canonical { avt.datatype }?,
      attribute cdata-section-elements { eqnames.datatype | avt.datatype }?,
      attribute _cdata-section-elements { avt.datatype }?,
      attribute doctype-public { string.datatype | avt.datatype }?,
      attribute _doctype-public { avt.datatype }?,
      attribute doctype-system { string.datatype | avt.datatype }?,
      attribute _doctype-system { avt.datatype }?,
      attribute encoding { string.datatype | avt.datatype }?,
      attribute _encoding { avt.datatype }?,
      attribute escape-uri-attributes { boolean.datatype | avt.datatype }?,
      attribute _escape-uri-attributes { avt.datatype }?,
      attribute html-version { decimal.datatype | avt.datatype }?,
      attribute _html-version { avt.datatype }?,
      attribute include-content-type { boolean.datatype | avt.datatype }?,
      attribute _include-content-type { avt.datatype }?,
      attribute indent { boolean.datatype | avt.datatype }?,
      attribute _indent { avt.datatype }?,
      attribute item-separator { string.datatype | avt.datatype }?,
      attribute _item-separator { avt.datatype }?,
      attribute json-node-output-method { "xml" | "html" | "xhtml" | "text" | eqname.datatype | avt.datatype }?,
      attribute _json-node-output-method { avt.datatype }?,
      attribute media-type { string.datatype | avt.datatype }?,
      attribute _media-type { avt.datatype }?,
      attribute normalization-form { "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | nmtoken.datatype | avt.datatype }?,
      attribute _normalization-form { avt.datatype }?,
      attribute omit-xml-declaration { boolean.datatype | avt.datatype }?,
      attribute _omit-xml-declaration { avt.datatype }?,
      attribute parameter-document { uri.datatype | avt.datatype }?,
      attribute _parameter-document { avt.datatype }?,
      attribute standalone { boolean.datatype | "omit" | avt.datatype }?,
      attribute _standalone { avt.datatype }?,
      attribute suppress-indentation { eqnames.datatype | avt.datatype }?,
      attribute _suppress-indentation { avt.datatype }?,
      attribute undeclare-prefixes { boolean.datatype | avt.datatype }?,
      attribute _undeclare-prefixes { avt.datatype }?,
      attribute use-character-maps { eqnames.datatype }?,
      attribute _use-character-maps { avt.datatype }?,
      attribute output-version { nmtoken.datatype | avt.datatype }?,
      attribute _output-version { avt.datatype }?,
      sequence-constructor.model
   }
output.element =
   element output {
      extension.atts,
      global.atts.except.version,
      attribute name { eqname.datatype }?,
      attribute _name { avt.datatype }?,
      attribute method { "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | eqname.datatype }?,
      attribute _method { avt.datatype }?,
      attribute allow-duplicate-names { boolean.datatype }?,
      attribute _allow-duplicate-names { avt.datatype }?,
      attribute build-tree { boolean.datatype }?,
      attribute _build-tree { avt.datatype }?,
      attribute byte-order-mark { boolean.datatype }?,
      attribute _byte-order-mark { avt.datatype }?,
      attribute canonical { boolean.datatype }?,
      attribute _canonical { avt.datatype }?,
      attribute cdata-section-elements { eqnames.datatype }?,
      attribute _cdata-section-elements { avt.datatype }?,
      attribute doctype-public { string.datatype }?,
      attribute _doctype-public { avt.datatype }?,
      attribute doctype-system { string.datatype }?,
      attribute _doctype-system { avt.datatype }?,
      attribute encoding { string.datatype }?,
      attribute _encoding { avt.datatype }?,
      attribute escape-uri-attributes { boolean.datatype }?,
      attribute _escape-uri-attributes { avt.datatype }?,
      attribute html-version { decimal.datatype }?,
      attribute _html-version { avt.datatype }?,
      attribute include-content-type { boolean.datatype }?,
      attribute _include-content-type { avt.datatype }?,
      attribute indent { boolean.datatype }?,
      attribute _indent { avt.datatype }?,
      attribute item-separator { string.datatype }?,
      attribute _item-separator { avt.datatype }?,
      attribute json-node-output-method { "xml" | "html" | "xhtml" | "text" | eqname.datatype }?,
      attribute _json-node-output-method { avt.datatype }?,
      attribute media-type { string.datatype }?,
      attribute _media-type { avt.datatype }?,
      attribute normalization-form { "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | nmtoken.datatype }?,
      attribute _normalization-form { avt.datatype }?,
      attribute omit-xml-declaration { boolean.datatype }?,
      attribute _omit-xml-declaration { avt.datatype }?,
      attribute parameter-document { uri.datatype }?,
      attribute _parameter-document { avt.datatype }?,
      attribute standalone { boolean.datatype | "omit" }?,
      attribute _standalone { avt.datatype }?,
      attribute suppress-indentation { eqnames.datatype }?,
      attribute _suppress-indentation { avt.datatype }?,
      attribute undeclare-prefixes { boolean.datatype }?,
      attribute _undeclare-prefixes { avt.datatype }?,
      attribute use-character-maps { eqnames.datatype }?,
      attribute _use-character-maps { avt.datatype }?,
      attribute version { nmtoken.datatype }?,
      attribute _version { avt.datatype }?,
      empty
   }
character-map.element =
   element character-map {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute use-character-maps { eqnames.datatype }?,
      attribute _use-character-maps { avt.datatype }?,
      (output-character.element*)
   }
output-character.element =
   element output-character {
      extension.atts,
      global.atts,
      (attribute character { char.datatype }
      | attribute _character { avt.datatype })+,
      (attribute string { string.datatype }
      | attribute _string { avt.datatype })+,
      empty
   }
avt.datatype =
  xsd:string
# {
#    pattern =
#      """([^\{\}]|\{\{|\}\}|\{([^"'\{\}]|"[^"]*"|'[^']*')+\})*""" # this regexp will not work in all the case.
#      }
</span></pre></div></div></div><p role="navigation" id="back-to-top"><a href="#title"><abbr title="Back to top">↑</abbr></a></p><script src="js/toc.js"></script><script src="/js/scroll.js"></script></body></html>