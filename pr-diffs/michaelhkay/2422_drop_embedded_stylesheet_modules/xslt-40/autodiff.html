<!DOCTYPE HTML><html xmlns="http://www.w3.org/1999/xhtml" lang="EN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>XSL Transformations (XSLT) Version 4.0</title><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link rel="stylesheet" type="text/css" href="css/w3c-base.css"><link rel="stylesheet" href="css/qtspecs.css"><link rel="stylesheet" href="css/xslt-40.css"><style type="text/css">
          body { margin-top: 50px }
          a.button { background: #DDD; border: 2px outset black; padding: 2px; margin: 2px; font-family: sans-serif; font-size: small;}
          a.button:hover { cursor:pointer; }
          a.button:active { border-style: inset; }
        </style><link rel="stylesheet" href="/css/autodiff.css"></head><body class="toc-inline"><div style="position:fixed; clear:both; top:0px" id="_autodiff_buttons"><p><a class="button" onclick="view('old')">
              View Old
            </a><a class="button" onclick="view('new')">
              View New
            </a><a class="button" onclick="view('both')">
              View Both
            </a><a class="button" onclick="view('only')">
              View Only
            </a><a class="button" onclick="scroll_to('prev')">
              Previous
            </a><a class="button" onclick="scroll_to('next')">
              Next
            </a><span id="__autodiff__"></span></p><p>This draft contains only sections that have differences from the version that it modified.</p></div><div class="head"><p><a href="https://www.w3.org/"><img src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C" alt="W3C" height="48" width="72"></a></p><h1><a id="title"></a>XSL Transformations (XSLT) Version 4.0</h1><h2><a id="w3c-doctype"></a>W3C Editor's Draft <span class="deltaxml-old" style="background:#FF5555">30 January</span><span class="deltaxml-new" style="background:#90EE90">2 February</span> 2026</h2><dl><dt>This version:</dt><dd><a href="https://qt4cg.org/specifications/xslt-40/">https://qt4cg.org/specifications/xslt-40/</a></dd><dt>Latest version:</dt><dd><a href="https://qt4cg.org/specifications/xslt-40/">https://qt4cg.org/specifications/xslt-40/</a></dd><dt>Most recent Recommendation of XSL Transformations (XSLT):</dt><dd><a href="https://www.w3.org/TR/xslt-30/">https://www.w3.org/TR/xslt-30/</a></dd><dt>Editor:</dt><dd>Michael Kay, Saxonica <a href="http://www.saxonica.com/">&lt;http://www.saxonica.com/&gt;</a></dd></dl><p>The following associated resources are available: <a href="xslt-40.xml">Specification in XML format</a>, <a href="schema-for-xslt40.xsd">XSD 1.1 Schema for XSLT 4.0 Stylesheets (non-normative)</a>, <a href="schema-for-xslt40.rnc">Relax-NG Schema for XSLT 4.0 Stylesheets (non-normative)</a>, <a href="xml-to-json.xsl">Stylesheet for XML-to-JSON conversion (non-normative)</a></p><p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;©&nbsp;2026&nbsp;<a href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="https://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="https://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="https://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p><hr></div><div><h2><a id="abstract"></a>Abstract</h2><p>This specification defines the syntax and semantics of XSLT 4.0, a language designed primarily for transforming XML documents into other XML documents, but also offering support for other data formats including JSON, HTML, and CSV.</p><p>XSLT 4.0 is a revised version of the XSLT 3.0 Recommendation <a href="#xslt-30">[XSLT 3.0]</a> published on 8 June 2017. Changes are presented in <a href="#whats-new-in-xslt4"><i>1.2 What’s New in XSLT 4.0?</i></a>. </p><p>XSLT 4.0 is designed to be used in conjunction with XPath 4.0, which is defined in <a href="#xpath-40">[XPath 4.0]</a>. XSLT shares the same data model as XPath 4.0, which is defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>, and it uses the library of functions and operators defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. XPath 4.0 and the underlying function library introduce a number of enhancements, for example the availability of union and record types. </p><p><em>This document contains hyperlinks to specific sections or definitions within other documents in this family of specifications. These links are indicated visually by a superscript identifying the target specification: for example XP for XPath 4.0, DM for the XDM data model version 4.0, FO for Functions and Operators version 4.0, SG for XSLT Streaming version 4.0.</em></p><p>An optional feature of the XSLT language is support for streamed transformations. The XSLT 4.0 specification has been modularized so that streaming is now described in a separate specification document. This has been done in order to make the specifications more manageable, both for editors and readers: it does not alter the status of streaming as an optional feature, available in some processors and not others.</p></div><div><h2><a id="status"></a>Status of this Document</h2><p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document.</em></p><p>This document is a working draft developed and maintained by a W3C Community Group, the <a href="https://www.w3.org/community/xslt-40/">XQuery and XSLT Extensions Community Group</a> unofficially known as QT4CG (where "QT" denotes Query and Transformation). This draft is work in progress and should not be considered either stable or complete. Standard W3C copyright and patent conditions apply.</p><p>The community group welcomes comments on the specification. Comments are best submitted as issues on the group's <a href="https://github.com/qt4cg/qtspecs/issues">GitHub repository</a>.</p><p>The community group maintains two extensive test suites, one oriented to XQuery and XPath, the other to XSLT. These can be found at <a href="https://github.com/qt4cg/qt4tests">qt4tests</a> and <a href="https://github.com/qt4cg/xslt40-test">xslt40-test</a> respectively. New tests, or suggestions for correcting existing tests, are welcome. The test suites include extensive metadata describing the conditions for applicability of each test case as well as the expected results. They do not include any test drivers for executing the tests: each implementation is expected to provide its own test driver.</p><div class="dedication" id="dedication"><h3>Dedication</h3><p>The publications of this community group <a href="../xquery-40/xpath-40.html#dedication">are dedicated</a> to our co-chair, Michael Sperberg-McQueen&nbsp;(1954–2024).</p></div></div><hr><div class="body"><div class="_diffs div1"><h2><a id="concepts"></a>2 <a href="#concepts" style="text-decoration: none">Concepts</a></h2><div class="_diffs div2"><h3><a id="notation"></a>2.2 <a href="#notation" style="text-decoration: none">Notation</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-xslt-element" title="XSLT element"></a>An <b>XSLT element</b> is an element in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> whose syntax and semantics are defined in this specification.<span class="definition">]</span> For a non-normative list of XSLT elements, see <a href="#element-syntax-summary"><i>C Element Syntax Summary</i></a>.</p><p>In this document the specification of each <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a> is preceded by a summary of its syntax in the form of a model for elements of that element type. A full list of all these specifications can be found in <a href="#element-syntax-summary"><i>C Element Syntax Summary</i></a>. The meaning of the syntax summary notation is as follows:</p><ul><li><p>An attribute that is <span class="verb">required</span> is shown with its name in bold. An attribute that may be omitted is shown with a question mark following its name.</p></li><li><p>An attribute that is <a title="deprecated" class="termref" href="#dt-deprecated">deprecated</a> is shown in a grayed font within square brackets.</p></li><li><p>The string that occurs in the place of an attribute value specifies the allowed values of the attribute. If this is surrounded by curly brackets (<code>{...}</code>), then the attribute value is treated as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>, and the string occurring within curly brackets specifies the allowed values of the result of evaluating the attribute value template. Alternative allowed values are separated by <code>|</code>. A quoted string indicates a value equal to that specific string. An unquoted, italicized name specifies a particular type of value.</p><p>The types used, and their meanings, are as follows:</p><dl><dt class="label"><code>boolean</code></dt><dd><p>One of the strings <code>"yes"</code>, <code>"true"</code>, or <code>"1"</code> to indicate the value <code>true</code>, or one of the strings <code>"no"</code>, <code>"false"</code>, or <code>"0"</code> to indicate the value <code>false</code>. Note: the values are synonyms; where this specification uses a phrase such as “If <code>required='yes'</code> is specified ...” this is to be interpreted as meaning “If the attribute named <code>required</code> is present, and has the value <code>yes</code>, <code>true</code>, or <code>1</code> (after stripping leading and trailing whitespace) ...”. </p></dd><dt class="label"><code>string</code></dt><dd><p>Any string.</p></dd><dt class="label"><code>expression</code></dt><dd><p>An XPath <a title="expression" class="termref" href="#dt-expression">expression</a>.</p></dd><dt class="label"><code>pattern</code></dt><dd><p>A <a title="pattern" class="termref" href="#dt-pattern">pattern</a> as described in <a href="#patterns"><i>6.3 Patterns</i></a>.</p></dd><dt class="label"><code>item-type</code></dt><dd><p>An <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup> as defined in the XPath <span>4.0</span> specification.</p></dd><dt class="label"><code>sequence-type</code></dt><dd><p>A <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup> as defined in the XPath <span>4.0</span> specification.</p></dd><dt class="label"><code>uri; uris</code></dt><dd><p>A URI, for example a namespace URI or a collation URI; a whitespace-separated list of URIs.</p></dd><dt class="label"><code>qname</code></dt><dd><p>A <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> as defined in <a href="#qname"><i>5.1.1 Qualified Names</i></a>.</p></dd><dt class="label"><code>eqname; eqnames</code></dt><dd><p>An <a title="EQName" class="termref" href="#dt-eqname">EQName</a> as defined in <a href="#qname"><i>5.1.1 Qualified Names</i></a>; a whitespace-separated list of EQNames.</p></dd><dt class="label"><code>token; tokens</code></dt><dd><p>A string containing no significant whitespace; a whitespace-separated list of such strings.</p></dd><dt class="label"><code>nmtoken; nmtokens</code></dt><dd><p>A string conforming to the XML schema rules for the type <code>xs:NMTOKEN</code>; a whitespace-separated list of such strings.</p></dd><dt class="label"><code>char</code></dt><dd><p>A string comprising a single Unicode character.</p></dd><dt class="label"><code>language</code></dt><dd><p>A string in the value space of <code>xs:language</code>, or a zero-length string.</p></dd><dt class="label"><code>integer</code></dt><dd><p>An integer, that is, a string <span>that is castable to</span> the schema type <code>xs:integer</code>.</p></dd><dt class="label"><code>decimal</code></dt><dd><p>A decimal value, that is, a string <span>that is castable to</span> the schema type <code>xs:decimal</code>.</p></dd><dt class="label"><code>ncname</code>; <span><code>ncnames</code></span></dt><dd><p>An unprefixed name: a string <span>that is castable to</span> the schema type <code>xs:NCName</code>; <span>a whitespace-separated list of such strings</span>.</p></dd><dt class="label"><code>prefix</code><span>; <code>prefixes</code></span></dt><dd><p>An <code>xs:NCName</code> representing a namespace prefix, which must be in scope for the element on which it appears; <span>a whitespace-separated list of such strings</span>.</p></dd><dt class="label"><code>id</code></dt><dd><p>An <code>xs:NCName</code> used as a unique identifier for an element in the containing XML document.</p></dd></dl><p>Except where the set of allowed values of an attribute is specified using the italicized name <em>string</em> or <em>char</em>, leading and trailing whitespace in the attribute value is ignored. In the case of an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>, this applies to the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> obtained when the attribute value template is expanded.</p><p>XPath comments (delimited by <code>(: ... :)</code>) are permitted anywhere that inter-token whitespace is permitted in attributes whose type is given as <em>expression</em>, <em>pattern</em>, <em>item-type</em>, or <em>sequence-type</em>, and are not permitted in attributes of other types (other than within expressions enclosed by curly braces within an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>).</p></li><li><p>If an attribute has a simple default value, this is shown between tortoise-shell brackets (for example <code>〔'no'〕</code>). Where no default is shown, the consequence of omitting the attribute is explained in the prose narrative. Default values shown in the summary apply only where the attribute itself is applicable; if an attribute is not permitted to appear in the particular context, then its default value should be ignored. (For example, the <code>stable</code> attribute of <a href="#element-sort"><code>xsl:sort</code></a> is shown as having a default value of <code>'yes'</code>, but the attribute is allowed only on the first of a sequence of adjacent <a href="#element-sort"><code>xsl:sort</code></a> elements.) The quotation marks around a default value are not part of the value.</p></li><li><p>Unless the element is <span class="verb">required</span> to be empty, the model element contains a comment specifying the allowed content. The allowed content is specified in a way similar to an element type declaration in XML; <em>sequence constructor</em> means that any mixture of text nodes, <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>, <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>, and <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a> from the <a title="instruction" class="termref" href="#dt-instruction">instruction</a> category is allowed; <em>other-declarations</em> means that any mixture of XSLT elements from the <a title="declaration" class="termref" href="#dt-declaration">declaration</a> category is allowed, together with <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a>.</p></li><li><p>The element is prefaced by comments indicating if it belongs to the <code>instruction</code> category or <code>declaration</code> category or both. The category of an element affects only whether it is allowed in the content of elements that allow a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> or <em>other-declarations</em>.</p></li></ul><div class="example"><div class="exampleHeader"><a id="d4e1013"></a>Example: Syntax Notation</div><p>This example illustrates the notation used to describe <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>.</p><p class="element-syntax"><a id="element-example-element"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:example-element<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;debug? = <var>boolean</var><br>&nbsp;&nbsp;validation? = { "strict" | "lax" }〔strict〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: ((<a href="#element-variable">xsl:variable</a> | <a href="#element-param">xsl:param</a>)*, <a href="#element-sequence">xsl:sequence</a>) --&gt;<br>&lt;/xsl:example-element&gt;</code></p><p>This example defines a (non-existent) element <code>xsl:example-element</code>. The element is classified as an instruction. It takes the following attributes:</p><ol class="enumar"><li><p>A mandatory <code>select</code> attribute, whose value is an XPath <a title="expression" class="termref" href="#dt-expression">expression</a></p></li><li><p>An optional <code>debug</code> attribute, whose value <span class="verb">must</span> be <code>yes</code>, <code>true</code>, or <code>1</code> to indicate <code>true</code>, or <code>no</code>, <code>false</code>, or <code>0</code> to indicate <code>false</code>.</p></li><li><p>An optional <code>validation</code> attribute, whose value must be <code>strict</code> or <code>lax</code>; the curly brackets indicate that the value can be defined as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>, allowing a value such as <code>validation="{ $val }"</code>, where the <a title="variable" class="termref" href="#dt-variable">variable</a><code>val</code> is evaluated to yield <code>"strict"</code> or <code>"lax"</code> at run-time. The value <code>strict</code> in tortoise-shell brackets indicates the default value, if the attribute is not present.</p></li></ol><p>The content of an <code>xsl:example-element</code> instruction is defined to be a sequence of zero or more <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> elements, followed by an <a href="#element-sequence"><code>xsl:sequence</code></a> element.</p></div><p><a id="err-XTSE0010"><span class="error">[ERR XTSE0010] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an XSLT-defined element is used in a context where it is not permitted, if a <span class="verb">required</span> attribute is omitted, or if the content of the element does not correspond to the content that is allowed for the element. </p><p>The rules in the element syntax summary (both for the element structure and for its attributes) apply to the stylesheet content after preprocessing as described in <a href="#preprocessing"><span style="display: none;" class="delete_version"><i>3.12 Stylesheet Preprocessing</i></span><span style="display: none;" class="add_version"><i>3.11 Stylesheet Preprocessing</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12</span><span class="deltaxml-new" style="background:#90EE90">3.11</span> Stylesheet Preprocessing</i></span></a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-effective-value" title="effective value"></a>The <b>effective value</b> of an attribute or text node in the stylesheet is the value after any required expansion or normalization.<span class="definition">]</span></p><p>More specifically, the effective value is the value after:</p><ul><li><p>Expanding shadow attributes as described in <a href="#shadow-attributes"><span style="display: none;" class="delete_version"><i>3.12.4 Shadow Attributes</i></span><span style="display: none;" class="add_version"><i>3.11.4 Shadow Attributes</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.4</span><span class="deltaxml-new" style="background:#90EE90">3.11.4</span> Shadow Attributes</i></span></a>;</p></li><li><p>Expanding defaults (for example, if an <a href="#element-message"><code>xsl:message</code></a> instruction has no <code>terminate</code> attribute, then the effective value of the <code>terminate</code> attribute is <code>no</code>);</p></li><li><p>Stripping ignored whitespace (for example, the effective value of a boolean attribute written as <code>terminate=" no "</code> is <code>no</code>);</p></li><li><p>Replacing synonyms (for example in boolean attributes, <code>1</code> and <code>true</code> are synonyms of <code>yes</code>);</p></li><li><p>Expanding <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a> and <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a>.</p></li><li><p>Applying rules from the static context: for example, the effective value of a <code>collation</code> attribute is the value after expanding a relative URI against the static base URI.</p></li></ul><p>Attributes are validated as follows. These rules apply to the value of the attribute after removing leading and trailing whitespace.</p><ul><li><p><a id="err-XTSE0020"><span class="error">[ERR XTSE0020] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an attribute (other than an attribute written using curly brackets in a position where an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a> is permitted) contains a value that is not one of the permitted values for that attribute. </p></li><li><p><a id="err-XTDE0030"><span class="error">[ERR XTDE0030] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of an attribute written using curly brackets, in a position where an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a> is permitted, is a value that is not one of the permitted values for that attribute. If the processor is able to detect the error statically (for example, when any XPath expressions within the curly brackets can be evaluated statically), then the processor may optionally raise this as a static error. </p></li></ul><p>Special rules apply if the construct appears in part of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that is processed with <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a>: see <a href="#forwards"><i>3.9 Forwards Compatible Processing</i></a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-deprecated" title="deprecated"></a>Some constructs defined in this specification are described as being <b>deprecated</b>. The use of this term implies that stylesheet authors <span class="verb">should not</span> use the construct, and that the construct may be removed in a later version of this specification.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>This specification includes a non-normative XML Schema for XSLT <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> (see <a href="#schema-for-xslt"><i>H Schemas for XSLT 4.0 Stylesheets</i></a>). The syntax summaries described in this section are normative.</p></div><p>XSLT defines a set of standard functions which are additional to those defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. A list of these functions appears in <a href="#XSLT-defined-functions"><i>G.2 List of XSLT-defined functions</i></a>. The signatures of these functions are described using the same notation as used in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. The names of many of these functions are in the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a>.</p></div><div class="_diffs div2"><h3><a id="initiating"></a>2.3 <a href="#initiating" style="text-decoration: none">Initiating a Transformation</a></h3><p>This document does not specify any application programming interfaces or other interfaces for initiating a transformation. This section, however, describes the information that is supplied when a transformation is initiated. Except where otherwise indicated, the information is <span class="verb">required</span>.</p><p><span style="display: none;" class="delete_version">The execution of a stylesheet necessarily involves two activities: static analysis and dynamic evaluation. Static analysis consists of those tasks that can be performed by inspection of the stylesheet alone, including the binding of <a title="static variable" class="termref" href="#dt-static-variable">static variables</a>, the evaluation of <code>[xsl:]use-when</code> expressions (see <a href="#conditional-inclusion"><span class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span class="modify_version"><i>3.12.3 Conditional Element Inclusion</i></span></a>) and shadow attributes (see <a href="#shadow-attributes"><span class="delete_version"><i>3.12.4 Shadow Attributes</i></span><span class="modify_version"><i>3.12.4 Shadow Attributes</i></span></a>), and the detection of <a title="static error" class="termref" href="#dt-static-error">static errors</a>. Dynamic evaluation consists of tasks which in general cannot be carried out until a source document is available.</span><span style="display: none;" class="add_version">The execution of a stylesheet necessarily involves two activities: static analysis and dynamic evaluation. Static analysis consists of those tasks that can be performed by inspection of the stylesheet alone, including the binding of <a title="static variable" class="termref" href="#dt-static-variable">static variables</a>, the evaluation of <code>[xsl:]use-when</code> expressions (see <a href="#conditional-inclusion"><span class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i>3.11.3 Conditional Element Inclusion</i></span></a>) and shadow attributes (see <a href="#shadow-attributes"><span class="add_version"><i>3.11.4 Shadow Attributes</i></span><span class="modify_version"><i>3.11.4 Shadow Attributes</i></span></a>), and the detection of <a title="static error" class="termref" href="#dt-static-error">static errors</a>. Dynamic evaluation consists of tasks which in general cannot be carried out until a source document is available.</span><span class="modify_version">The execution of a stylesheet necessarily involves two activities: static analysis and dynamic evaluation. Static analysis consists of those tasks that can be performed by inspection of the stylesheet alone, including the binding of <a title="static variable" class="termref" href="#dt-static-variable">static variables</a>, the evaluation of <code>[xsl:]use-when</code> expressions (see <a href="#conditional-inclusion"><span style="display: none;" class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span style="display: none;" class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.3</span><span class="deltaxml-new" style="background:#90EE90">3.11.3</span> Conditional Element Inclusion</i></span></a>) and shadow attributes (see <a href="#shadow-attributes"><span style="display: none;" class="delete_version"><i>3.12.4 Shadow Attributes</i></span><span style="display: none;" class="add_version"><i>3.11.4 Shadow Attributes</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.4</span><span class="deltaxml-new" style="background:#90EE90">3.11.4</span> Shadow Attributes</i></span></a>), and the detection of <a title="static error" class="termref" href="#dt-static-error">static errors</a>. Dynamic evaluation consists of tasks which in general cannot be carried out until a source document is available.</span></p><p>Dynamic evaluation is further divided into two activities: <b>priming</b> the stylesheet, and <b>invoking</b> a selected component. </p><ul><li><p>Priming the stylesheet provides the dynamic context for evaluation, and supplies all the information needed to establish the values of global variables.</p></li><li><p>Invoking a component (such as a template or function) causes evaluation of that template or function to produce a result, which is an arbitrary XDM value.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-raw-result" title="raw result"></a>The result of invoking the selected component, after any required conversion to the declared result type of the component, is referred to as the <b>raw result</b>.<span class="definition">]</span></p><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> of the invocation is the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained in the target template or function, modified by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to convert the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> to the type declared in the <code>as</code> attribute of the <a href="#element-template"><code>xsl:template</code></a> or <a href="#element-function"><code>xsl:function</code></a> declaration, if present.</p><p>This raw result may optionally be post-processed to construct a result tree, to serialize the result, or both, as described in <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a>.</p></li></ul><p>Implementations <span class="verb">may</span> allow static analysis and dynamic evaluation to be initiated independently, so that the cost of static analysis can be amortized over multiple transformations using the same stylesheet. Implementations <span class="verb">may</span> also allow priming of a stylesheet and invocation of components to be initiated independently, in which case a single act of priming the stylesheet may be followed by a series of independent component invocations. Although this specification does not require such a separation, this section distinguishes information that is needed before static analysis can proceed, information that is needed to prime the stylesheet, and information that is needed when invoking components.</p><p>The language is designed to allow the static analysis of each <a title="package" class="termref" href="#dt-package">package</a> to be performed independently of other packages, with only basic knowledge of the properties of components made available by used packages. Beyond this, the specification leaves it to implementations to decide how to organize this process. When packages are not used explicitly, the entire stylesheet is treated as a single package.</p></div><div class="_diffs div2"><h3><a id="stylesheets-and-schemas"></a>2.10 <a href="#stylesheets-and-schemas" style="text-decoration: none">Stylesheets and XML Schemas</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#standard-attributes">next</a> | <a href="#terminology">previous</a>)</p><ol><li><p> Different parts of a stylesheet may now use different imported schemas. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/451">451</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1819">1819</a>&nbsp;18 February 2025]</i></p></li></ol></div><p>An XSLT <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> can make use of information from a schema. An XSLT transformation can take place in the absence of a schema (and, indeed, in the absence of a DTD), but where the source document has undergone schema validity assessment, the XSLT processor has access to the type information associated with individual nodes, not merely to the untyped text.</p><p>Information from a schema can be used both statically (when the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is compiled), and dynamically (during evaluation of the stylesheet to transform a source document).</p><p>There are places within a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, and within XPath <a title="expression" class="termref" href="#dt-expression">expressions</a> and <a title="pattern" class="termref" href="#dt-pattern">patterns</a> in a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, where it is possible to refer to named type definitions in a schema, or to element and attribute declarations. For example, it is possible to declare the types expected for the parameters of a function. This is done using a <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-sequence-type" title="SequenceType"></a>A <b>SequenceType</b> constrains the type and number of items in a sequence. The term is used both to denote the concept, and to refer to the syntactic form in which sequence types are expressed in the XPath grammar: specifically <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup> in <a href="#xpath-40">[XPath 4.0]</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-schema-component" title="schema component"></a>Type definitions and element and attribute declarations are referred to collectively as <b>schema components</b>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-in-scope-schema-component" title="in-scope schema component"></a>The <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> that may be referenced by name in a <a title="package" class="termref" href="#dt-package">package</a> are referred to as the <b>in-scope schema components</b>.<span class="definition">]</span></p><p>The set of in-scope schema components may vary between one package and another, and between different parts of the same package, but as explained in <a href="#import-schema"><span style="display: none;" class="delete_version"><i>3.14 Importing Schema Components</i></span><span style="display: none;" class="add_version"><i>3.13 Importing Schema Components</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.14</span><span class="deltaxml-new" style="background:#90EE90">3.13</span> Importing Schema Components</i></span></a>, the schema components used in different parts of the stylesheet must be consistent with each other.</p><p>The conformance rules for XSLT 4.0, defined in <a href="#conformance"><i>27 Conformance</i></a>, distinguish between a <a title="basic XSLT processor" class="termref" href="#dt-basic-xslt-processor">basic XSLT processor</a> and a <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a>. As the names suggest, a basic XSLT processor does not support the features of XSLT that require access to schema information, either statically or dynamically. A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that works with a basic XSLT processor will produce the same results with a schema-aware XSLT processor provided that the source documents are untyped (that is, they are not validated against a schema). However, if source documents are validated against a schema then the results may be different from the case where they are not validated. Some constructs that work on untyped data may fail with typed data (for example, an attribute of type <code>xs:date</code> cannot be used as an argument of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-substring"><code>substring</code></a> function) and other constructs may produce different results depending on the datatype (for example, given the element <code>&lt;product price="10.00" discount="2.00"/&gt;</code>, the expression <code>@price gt @discount</code> will return <code>true</code> if the attributes have type <code>xs:decimal</code>, but will return <code>false</code> if they are untyped).</p><p>There is a standard set of type definitions that are always available as <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> in every stylesheet. These are defined in <a href="#built-in-types"><span style="display: none;" class="delete_version"><i>3.13 Built-in Types</i></span><span style="display: none;" class="add_version"><i>3.12 Built-in Types</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.13</span><span class="deltaxml-new" style="background:#90EE90">3.12</span> Built-in Types</i></span></a>. </p><p>The remainder of this section describes facilities that are available only with a <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a>.</p><p>Additional <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> (type definitions, element declarations, and attribute declarations) may be added to the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> by means of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration in a stylesheet.</p><p>The <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration may reference an external schema document by means of a URI, or it may contain an inline <code>xs:schema</code> element.</p><p>An <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration may include a <code>role</code> attribute, which indicates that the schema components are only to be present in the static context of a region of the stylesheet where they are explicitly invoked by means of an <code>[xsl:]schema-role</code> attribute.</p><p>It is only necessary to import a schema explicitly if one or more of its <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> are referenced explicitly by name in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>; it is not necessary to import a schema merely because the stylesheet is used to process a source document that has been assessed against that schema. It is possible to make use of the information resulting from schema assessment (for example, the fact that a particular attribute holds a date) even if no schema has been imported by the stylesheet.</p><p>Importing a schema does not of itself say anything about the type of the source document that the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is expected to process. The imported type definitions can be used for temporary nodes or for nodes on a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> just as much as for nodes in source documents. It is possible to make assertions about the type of an input document by means of tests within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. For example:</p><div class="example"><div class="exampleHeader"><a id="d4e3121"></a>Example: Asserting the Required Type of the Source Document</div><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:mode typed="lax"/&gt;
&lt;xsl:global-context-item use="required"
            as="document-node(schema-element(my:invoice))"/&gt;</pre></div><p>This example will cause the transformation to fail with an error message, unless the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> is valid against the top-level element declaration <code>my:invoice</code>, and has been annotated as such.</p><p>A <code>schema-role</code> attribute could be added to the declaration to indicate which schema the element declaration <code>my:invoice</code> is to be taken from.</p><p>The setting <code>typed="lax"</code> further ensures that in any match pattern for a template rule in this mode, an element name that corresponds to the name of an element declaration in the schema is taken as referring to elements validated against that declaration: for example, <code>match="employee"</code> will only match a validated <code>employee</code> element. Selecting this option enables the XSLT processor to do more compile-time type-checking against the schema, for example it allows the processor to produce warning or error messages when path expressions contain misspelt element names, or confuse an element with an attribute.</p></div><p>It is also true that importing a schema does not of itself say anything about the structure of the result tree. It is possible to request validation of a result tree against the schema by using the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, for example:</p><div class="example"><div class="exampleHeader"><a id="d4e3155"></a>Example: Requesting Validation of the Result Document</div><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xhtml:html&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xhtml:html&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;</pre></div><p>This example will cause the transformation to fail with an error message unless the document element of the result document is valid against the top-level element declaration <code>xhtml:html</code>.</p><p>A <code>schema-role</code> attribute could be added to the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction to indicate which schema the document is to be validated against.</p></div><p>It is possible that a source document may contain nodes whose <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> is not one of the types imported by the stylesheet. The data model (see <a href="#xpath-datamodel-40">[XDM 4.0]</a>) requires that the processor has sufficient information about such types to correctly implement the semantics of the language, even though the schema has not been imported; it also requires that all schemas used by the processor in a given processing episode (for example, an XSLT transformation) should be consistent. For example, if a type annotation of a node is the simple type <code>my:percentage</code>, and a type named <code>my:percentage</code> appears in an imported schema, then they must be the same type.</p><p>Where a stylesheet author chooses to make assertions about the types of nodes or of <a title="variable" class="termref" href="#dt-variable">variables</a> and <a title="parameter" class="termref" href="#dt-parameter">parameters</a>, it is possible for an XSLT processor to perform static analysis of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (that is, analysis in the absence of any source document). Such analysis <span class="verb">may</span> reveal errors that would otherwise not be discovered until the transformation is actually executed. An XSLT processor is not <span class="verb">required</span> to perform such static type-checking. Under some circumstances (see <a href="#errors"><i>2.12 Error Handling</i></a>) type errors that are detected early <span class="verb">may</span> be raised as static errors. In addition an implementation <span class="verb">may</span> report any condition found during static analysis as a warning, provided that this does not prevent the stylesheet being evaluated as described by this specification.</p><p>A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> can also control the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> of nodes that it constructs in a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. This can be done in a number of ways.</p><ul><li><p>It is possible to request explicit validation of a complete document, that is, a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> rooted at a document node. Validation is either strict or lax, as described in <a href="#xmlschema-1">[XML Schema Part 1]</a>. If validation of a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> fails (strictly speaking, if the outcome of the validity assessment is <code>invalid</code>), then the transformation fails, but in all other cases, the element and attribute nodes of the tree will be annotated with the names of the types to which these nodes conform. These <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> will be discarded if the result tree is serialized as an XML document, but they remain available when the result tree is passed to an application (perhaps another <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>) for further processing.</p></li><li><p>It is also possible to validate individual element and attribute nodes as they are constructed. This is done using the <code>type</code> and <code>validation</code> attributes of the <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, and <a href="#element-copy-of"><code>xsl:copy-of</code></a> instructions, or the <code>xsl:type</code> and <code>xsl:validation</code> attributes of a literal result element.</p></li><li><p>When elements, attributes, or document nodes are copied, either explicitly using the <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> instructions, or implicitly when nodes in a sequence are attached to a new parent node, the options <code>validation="strip"</code> and <code>validation="preserve"</code> are available, to control whether existing <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> are to be retained or not.</p></li></ul><p>When nodes in a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> are validated, type information is available for use by operations carried out on the temporary tree, in the same way as for a source document that has undergone schema assessment.</p><p>For details of how validation of element and attribute nodes works, see <a href="#validation"><i>25.4 Validation</i></a>.</p></div></div><div class="_diffs div1"><h2><a id="stylesheet-structure"></a>3 <a href="#stylesheet-structure" style="text-decoration: none">Stylesheet Structure</a></h2><p>This section describes the overall structure of a stylesheet as a collection of XML documents.</p><div class="_diffs div2"><h3><a id="standard-attributes"></a>3.3 <a href="#standard-attributes" style="text-decoration: none">Standard Attributes</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#package-locations">next</a> | <a href="#stylesheets-and-schemas">previous</a>)</p><ol><li><p> The standard attribute <code>[xsl:]schema-role</code> is introduced, to allow different parts of a stylesheet to use different schemas. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/451">451</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1819">1819</a>&nbsp;18 February 2025]</i></p></li></ol></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-standard-attributes" title="standard attributes"></a>There are a number of <b>standard attributes</b> that may appear on any <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>: specifically <code>default-collation</code>, <code>default-mode</code>, <code>default-validation</code>, <code>exclude-result-prefixes</code>, <code>expand-text</code>, <code>extension-element-prefixes</code>, <code>schema-role</code>, <code>use-when</code>, <code>version</code>, and <code>xpath-default-namespace</code>.<span class="definition">]</span></p><p>These attributes may also appear on a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, but in this case, to distinguish them from user-defined attributes, the names of the attributes are in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>. They are thus typically written as <code>xsl:default-collation</code>, <code>xsl:default-mode</code>, <code>xsl:default-validation</code>, <code>xsl:exclude-result-prefixes</code>, <code>xsl:expand-text</code>, <code>xsl:extension-element-prefixes</code>, <code>xsl:use-when</code>, <code>xsl:version</code>, or <code>xsl:xpath-default-namespace</code>.</p><p>It is <span class="verb">recommended</span> that all these attributes should also be permitted on <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>, but this is at the discretion of the implementer of each extension instruction. They <span class="verb">may</span> also be permitted on <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a>, though they will only have any useful effect in the case of data elements that are designed to behave like XSLT declarations or instructions.</p><p>In the following descriptions, these attributes are referred to generically as <code>[xsl:]version</code>, and so on.</p><p>These attributes all affect the element they appear on, together with any elements and attributes that have that element as an ancestor. The two forms with and without the XSLT namespace have the same effect; the XSLT namespace is used for the attribute if and only if its parent element is <em>not</em> in the XSLT namespace.</p><p>In the case of <code>[xsl:]default-collation</code>, <code>[xsl:]expand-text</code>, <code>[xsl:]schema-role</code>, <code>[xsl:]version</code>, and <code>[xsl:]xpath-default-namespace</code>, the value can be overridden by a different value for the same attribute appearing on a descendant element. The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute for a particular stylesheet element is determined by the innermost ancestor-or-self element on which the attribute appears.</p><p>In an <a title="embedded stylesheet module" class="termref" href="#dt-embedded-stylesheet-module">embedded stylesheet module</a>, <a title="standard attributes" class="termref" href="#dt-standard-attributes">standard attributes</a> appearing on ancestors of the outermost element of the stylesheet module have no effect.</p><p>In the case of <code>[xsl:]exclude-result-prefixes</code> and <code>[xsl:]extension-element-prefixes</code> the values are cumulative. For these attributes, the value is given as a whitespace-separated list of namespace prefixes, and the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> for an element is the combined set of namespace URIs designated by the prefixes that appear in this attribute for that element and any of its ancestor elements. Again, the two forms with and without the XSLT namespace are equivalent.</p><p><span style="display: none;" class="delete_version">The effect of the <code>[xsl:]use-when</code> attribute is described in <a href="#conditional-inclusion"><span class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span class="modify_version"><i>3.12.3 Conditional Element Inclusion</i></span></a>.</span><span style="display: none;" class="add_version">The effect of the <code>[xsl:]use-when</code> attribute is described in <a href="#conditional-inclusion"><span class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i>3.11.3 Conditional Element Inclusion</i></span></a>.</span><span class="modify_version">The effect of the <code>[xsl:]use-when</code> attribute is described in <a href="#conditional-inclusion"><span style="display: none;" class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span style="display: none;" class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.3</span><span class="deltaxml-new" style="background:#90EE90">3.11.3</span> Conditional Element Inclusion</i></span></a>.</span></p><p>Because these attributes may appear on any <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>, they are not listed in the syntax summary of each individual element. Instead they are listed and described in the entry for the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, and <a href="#element-package"><code>xsl:package</code></a> elements only. This reflects the fact that these attributes are often used on the outermost element of the stylesheet, in which case they apply to the entire <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> or <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a>.</p><p>Note that the effect of these attributes does <em>not</em> extend to <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> referenced by <a href="#element-include"><code>xsl:include</code></a> or <a href="#element-import"><code>xsl:import</code></a> declarations, nor to packages referenced using <a href="#element-use-package"><code>xsl:use-package</code></a>.</p><p>For the detailed effect of each attribute, see the following sections:</p><dl><dt class="label"><code>[xsl:]default-collation</code></dt><dd><p>see <a href="#default-collation-attribute"><i>3.6.2 The default-collation Attribute</i></a></p></dd><dt class="label"><code>[xsl:]default-mode</code></dt><dd><p>see <a href="#default-mode"><i>3.6.3 The default-mode Attribute</i></a></p></dd><dt class="label"><code>[xsl:]default-validation</code></dt><dd><p>see <a href="#validation"><i>25.4 Validation</i></a></p></dd><dt class="label"><code>[xsl:]exclude-result-prefixes</code></dt><dd><p>see <a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for Literal Result Elements</i></a></p></dd><dt class="label"><code>[xsl:]expand-text</code></dt><dd><p>see <a href="#text-value-templates"><i>5.6.2 Text Value Templates</i></a></p></dd><dt class="label"><code>[xsl:]extension-element-prefixes</code></dt><dd><p>see <a href="#extension-instruction"><i>24.3 Extension Instructions</i></a></p></dd><dt class="label"><code>[xsl:]schema-role</code></dt><dd><p>see <a href="#multiple-schemas"><span style="display: none;" class="delete_version"><i>3.14.1 Multiple Schemas</i></span><span style="display: none;" class="add_version"><i>3.13.1 Multiple Schemas</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.14.1</span><span class="deltaxml-new" style="background:#90EE90">3.13.1</span> Multiple Schemas</i></span></a></p></dd><dt class="label"><code>[xsl:]use-when</code></dt><dd><p>see <a href="#conditional-inclusion"><span style="display: none;" class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span style="display: none;" class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.3</span><span class="deltaxml-new" style="background:#90EE90">3.11.3</span> Conditional Element Inclusion</i></span></a></p></dd><dt class="label"><code>[xsl:]version</code></dt><dd><p>see <a href="#backwards"><i>3.8 Backwards Compatible Processing</i></a> and <a href="#forwards"><i>3.9 Forwards Compatible Processing</i></a></p></dd><dt class="label"><code>[xsl:]xpath-default-namespace</code></dt><dd><p>see <a href="#unprefixed-qnames"><i>5.1.2 Unprefixed Lexical QNames in Expressions and Patterns</i></a></p></dd></dl></div><div class="_diffs div2"><h3><a id="stylesheet-modules"></a>3.5 <a href="#stylesheet-modules" style="text-decoration: none">Stylesheet Modules</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-stylesheet-module" title="stylesheet module"></a>A <a title="package" class="termref" href="#dt-package">package</a> consists of one or more <b>stylesheet modules</b>, each one forming all or part of an XML document.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>A stylesheet module is represented by an XDM element node (see <a href="#xpath-datamodel-40">[XDM 4.0]</a>). In the case of a standard stylesheet module, this will be an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element. In the case of a simplified stylesheet module, it can be any element (not in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>) that has an <code>xsl:version</code> attribute.</p><p>Although stylesheet modules will commonly be maintained in the form of documents conforming to XML 1.0 or XML 1.1, this specification does not mandate such a representation. As with <a title="source tree" class="termref" href="#dt-source-tree">source trees</a>, the way in which stylesheet modules are constructed, from textual XML or otherwise, is outside the scope of this specification.</p></div><p>The principal stylesheet module of a package may take one of three forms:</p><ul><li><p>A package manifest, as described in <a href="#packages"><i>3.4 Packages</i></a>, which is a subtree rooted at an <a href="#element-package"><code>xsl:package</code></a> element</p></li><li><p>An implicit package, which is a subtree rooted at an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element. This is transformed automatically to a package as described in <a href="#packages"><i>3.4 Packages</i></a>. </p></li><li><p>A simplified stylesheet, which is a subtree rooted at a literal result element, as described in <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>. This is first converted to an implicit package by wrapping it in an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element using the transformation described in <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>, and then to an explicit package (rooted at an <a href="#element-package"><code>xsl:package</code></a> element) using the transformation described in <a href="#packages"><i>3.4 Packages</i></a>. </p></li></ul><p>A stylesheet module other than the principal stylesheet module of a package may take either of two forms:</p><ul><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-standard-stylesheet-module" title="standard stylesheet module"></a>A <b>standard stylesheet module</b>, which is a subtree rooted at an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element.<span class="definition">]</span></p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-simplified-stylesheet-module" title="simplified stylesheet"></a>A <b>simplified stylesheet</b>, which is a subtree rooted at a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, as described in <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>. This is first converted to a <a title="standard stylesheet module" class="termref" href="#dt-standard-stylesheet-module">standard stylesheet module</a> by wrapping it in an xsl:stylesheet element using the transformation described in <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>.<span class="definition">]</span></p></li></ul><p>Whichever of the above forms a module takes, the outermost element (<a href="#element-package"><code>xsl:package</code></a>, <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, or a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>) <span class="verb">may</span> either be the outermost element of an XML document, or it <span class="verb">may</span> be a child of some (non-XSLT) element in a host document. </p><p><span style="display: none;" class="delete_version"><span class="definition">[Definition:&nbsp;</span><a id="dt-embedded-stylesheet-module" title="embedded stylesheet module"></a>A stylesheet module whose outermost element is the child of a non-XSLT element in a host document is referred to as an <b>embedded stylesheet module</b>. See <a href="#embedded"><i>3.11 Embedded Stylesheet Modules</i></a>.<span class="definition">]</span></span><span style="display: none;" class="add_version"><span class="definition">[Definition:&nbsp;</span><a id="dt-embedded-stylesheet-module" title="embedded stylesheet module"></a>A stylesheet module whose outermost element is the child of a non-XSLT element in a host document is referred to as an <b>embedded stylesheet module</b>.<span class="definition">]</span></span><span class="modify_version"><span class="definition">[Definition:&nbsp;</span><a id="dt-embedded-stylesheet-module" title="embedded stylesheet module"></a>A stylesheet module whose outermost element is the child of a non-XSLT element in a host document is referred to as an <b>embedded stylesheet module</b>.<span class="deltaxml-old" style="background:#FF5555"> See </span><a href="#embedded"><i><span class="deltaxml-old" style="background:#FF5555">3.11 Embedded Stylesheet Modules</span></i></a><span class="deltaxml-old" style="background:#FF5555">.</span><span class="definition">]</span></span></p></div><div class="_diffs div2"><h3><a id="stylesheet-element"></a>3.6 <a href="#stylesheet-element" style="text-decoration: none">Stylesheet Element</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#fixed-namespaces">next</a> | <a href="#package-locations">previous</a>)</p><ol><li><p> A new attribute, <code>main-module</code>, is added to the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element. The attribute is provided for the benefit of development tools such as syntax-directed editors to provide information about all the components (variables, functions, etc) visible within a stylesheet module. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/87">87</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/353">353</a>&nbsp;19 April 2023]</i></p></li></ol></div><p class="element-syntax"><a id="element-stylesheet"></a><code>&lt;xsl:stylesheet<br>&nbsp;&nbsp;id? = <var>id</var><br>&nbsp;&nbsp;<b>version</b> = <var>decimal</var><br>&nbsp;&nbsp;default-mode? = <var>eqname</var> | "#unnamed"〔'#unnamed'〕<br>&nbsp;&nbsp;default-validation? = "preserve" | "strip"〔'strip'〕<br>&nbsp;&nbsp;input-type-annotations? = "preserve" | "strip" | "unspecified"〔'unspecified'〕<br>&nbsp;&nbsp;default-collation? = <var>uris</var><br>&nbsp;&nbsp;extension-element-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;exclude-result-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;expand-text? = <var>boolean</var><br>&nbsp;&nbsp;fixed-namespaces? = <var>string</var><br>&nbsp;&nbsp;main-module? = <var>uri</var><br>&nbsp;&nbsp;schema-role? = <var>ncname</var><br>&nbsp;&nbsp;use-when? = <var>expression</var>〔true()〕<br>&nbsp;&nbsp;xpath-default-namespace? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<var>declarations</var>) --&gt;<br>&lt;/xsl:stylesheet&gt;</code></p><p class="element-syntax"><a id="element-transform"></a><code>&lt;xsl:transform<br>&nbsp;&nbsp;id? = <var>id</var><br>&nbsp;&nbsp;<b>version</b> = <var>decimal</var><br>&nbsp;&nbsp;default-mode? = <var>eqname</var> | "#unnamed"〔'#unnamed'〕<br>&nbsp;&nbsp;default-validation? = "preserve" | "strip"〔'strip'〕<br>&nbsp;&nbsp;input-type-annotations? = "preserve" | "strip" | "unspecified"〔'unspecified'〕<br>&nbsp;&nbsp;default-collation? = <var>uris</var><br>&nbsp;&nbsp;extension-element-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;exclude-result-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;expand-text? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;fixed-namespaces? = <var>string</var><br>&nbsp;&nbsp;main-module? = <var>uri</var><br>&nbsp;&nbsp;schema-role? = <var>ncname</var><br>&nbsp;&nbsp;use-when? = <var>expression</var>〔true()〕<br>&nbsp;&nbsp;xpath-default-namespace? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<var>declarations</var>) --&gt;<br>&lt;/xsl:transform&gt;</code></p><p>A stylesheet module is represented by an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element in an XML document. <a href="#element-transform"><code>xsl:transform</code></a> is allowed as a synonym for <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>; everything this specification says about the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element applies equally to <a href="#element-transform"><code>xsl:transform</code></a>.</p><p>The <code>version</code> attribute indicates the version of XSLT that the stylesheet module requires. The attribute is <span class="verb">required</span>.</p><p><a id="err-XTSE0110"><span class="error">[ERR XTSE0110] </span></a>The value of the <code>version</code> attribute <span class="verb">must</span> be a number: specifically, it <span class="verb">must</span> be a valid instance of the type <code>xs:decimal</code> as defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>. </p><p>The <code>version</code> attribute is intended to indicate the version of the XSLT specification against which the stylesheet is written. In a stylesheet written to use XSLT 4.0, the value <span class="verb">should</span> normally be set to <code>4.0</code>. If the value is numerically less than 4.0, the stylesheet is processed using the rules for <a title="backwards compatible behavior" class="termref" href="#dt-backwards-compatible-behavior">backwards compatible behavior</a> (see <a href="#backwards"><i>3.8 Backwards Compatible Processing</i></a>). If the value is numerically greater than <span>4.0</span>, the stylesheet is processed using the rules for <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> (see <a href="#forwards"><i>3.9 Forwards Compatible Processing</i></a>).</p><p>The effect of the <code>input-type-annotations</code> attribute is described in <a href="#stripping-annotations"><i>4.2.1 Stripping Type Annotations from a Source Tree</i></a>.</p><p>The <code>[xsl:]default-validation</code> attribute defines the default value of the <code>validation</code> attribute of all relevant instructions appearing within its scope. For details of the effect of this attribute, see <a href="#validation"><i>25.4 Validation</i></a>.</p><p>The optional <code>main-module</code> attribute is purely documentary. By including this attribute in every <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> of a <a title="package" class="termref" href="#dt-package">package</a>, an XSLT editing tool may be enabled to locate the <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet module</a> of the relevant package, and thus to gather information about all the global variables, templates, and functions available within the module being edited. This information can be used (for example) to enable auto-completion and error highlighting of the code as it is entered. Note that it may be inconvenient or misleading to use this attribute when the <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> module is used as a shared component within multiple <a title="package" class="termref" href="#dt-package">packages</a>. </p><p><span style="display: none;" class="delete_version"><a id="err-XTSE0120"><span class="error">[ERR XTSE0120] </span></a>An <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a> element <span class="verb">must not</span> have any text node children. (This rule applies after stripping of <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> as described in <a href="#stylesheet-stripping"><span class="delete_version"><i>3.12.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span class="modify_version"><i>3.12.1 Stripping Whitespace and Commentary from the Stylesheet</i></span></a>.)</span><span style="display: none;" class="add_version"><a id="err-XTSE0120"><span class="error">[ERR XTSE0120] </span></a>An <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a> element <span class="verb">must not</span> have any text node children. (This rule applies after stripping of <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> as described in <a href="#stylesheet-stripping"><span class="add_version"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span class="modify_version"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></span></a>.)</span><span class="modify_version"><a id="err-XTSE0120"><span class="error">[ERR XTSE0120] </span></a>An <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a> element <span class="verb">must not</span> have any text node children. (This rule applies after stripping of <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> as described in <a href="#stylesheet-stripping"><span style="display: none;" class="delete_version"><i>3.12.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span style="display: none;" class="add_version"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.1</span><span class="deltaxml-new" style="background:#90EE90">3.11.1</span> Stripping Whitespace and Commentary from the Stylesheet</i></span></a>.)</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-top-level" title="top-level"></a>An element occurring as a child of an <a href="#element-package"><code>xsl:package</code></a>, <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-override"><code>xsl:override</code></a> element is called a <b>top-level</b> element.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-declaration" title="declaration"></a>Top-level elements fall into two categories: declarations, and user-defined data elements. Top-level elements whose names are in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> are <b>declarations</b>. Top-level elements in any other namespace are <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> (see <a href="#user-defined-top-level"><i>3.6.4 User-defined Data Elements</i></a>)<span class="definition">]</span>.</p><p>The <a title="declaration" class="termref" href="#dt-declaration">declaration</a> elements permitted in the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element are:</p><blockquote><p><a href="#element-accumulator"><code>xsl:accumulator</code></a><br><a href="#element-attribute-set"><code>xsl:attribute-set</code></a><br><a href="#element-character-map"><code>xsl:character-map</code></a><br><a href="#element-decimal-format"><code>xsl:decimal-format</code></a><br><a href="#element-function"><code>xsl:function</code></a><br><a href="#element-global-context-item"><code>xsl:global-context-item</code></a><br><a href="#element-import"><code>xsl:import</code></a><br><a href="#element-import-schema"><code>xsl:import-schema</code></a><br><a href="#element-include"><code>xsl:include</code></a><br><a href="#element-item-type"><code>xsl:item-type</code></a><br><a href="#element-key"><code>xsl:key</code></a><br><a href="#element-mode"><code>xsl:mode</code></a><br><a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a><br><a href="#element-output"><code>xsl:output</code></a><br><a href="#element-param"><code>xsl:param</code></a><br><a href="#element-preserve-space"><code>xsl:preserve-space</code></a><br><a href="#element-record-type"><code>xsl:record-type</code></a><br><a href="#element-strip-space"><code>xsl:strip-space</code></a><br><a href="#element-template"><code>xsl:template</code></a><br><a href="#element-use-package"><code>xsl:use-package</code></a><br><a href="#element-variable"><code>xsl:variable</code></a></p></blockquote><p>Note that the <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> elements can act either as <a title="declaration" class="termref" href="#dt-declaration">declarations</a> or as <a title="instruction" class="termref" href="#dt-instruction">instructions</a>. A global variable or parameter is defined using a declaration; a local variable or parameter using an instruction.</p><p>The child elements of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element may appear in any order. In most cases, the ordering of these elements does not affect the results of the transformation; however:</p><ul><li><p>As described in <a href="#conflict"><i>6.6 Conflict Resolution for Template Rules</i></a>, when two template rules with the same <a title="priority" class="termref" href="#dt-priority">priority</a> match the same nodes, there are situations where the order of the template rules will affect which is chosen.</p></li><li><p>Forwards references to <a title="static variable" class="termref" href="#dt-static-variable">static variables</a> are not allowed in <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a>.</p></li></ul><div class="_diffs div3"><h4><a id="fixed-namespaces"></a>3.6.1 <a href="#fixed-namespaces" style="text-decoration: none">The <code>fixed-namespaces</code> Attribute</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#simplified-stylesheet">next</a> | <a href="#stylesheet-element">previous</a>)</p><ol><li><p> The <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a> element may have a <code>fixed-namespaces</code> attribute making it easier to have the same namespace declarations in force throughout a stylesheet. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/369">369</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/470">470</a>&nbsp;29 November 2023]</i></p></li></ol></div><p>The <code>fixed-namespaces</code> attribute, if present, defines the <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a> for a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>. The attribute may appear only on the outermost element of a stylesheet module (<a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a>). It is not available with <a title="simplified stylesheet" class="termref" href="#dt-simplified-stylesheet-module">simplified stylesheet modules</a>.</p><p>If the <code>fixed-namespaces</code> attribute is present, then it defines the entire set of namespace bindings present in the static context of XPath expressions and <a title="pattern" class="termref" href="#dt-pattern">patterns</a> within the stylesheet, as well as other constructs where namespace prefixes are used in attribute and text nodes, such as the <code>name</code> attribute of declarations like <a href="#element-function"><code>xsl:function</code></a> and <a href="#element-variable"><code>xsl:variable</code></a>, and <code>as</code> and <code>type</code> attributes referring to item types and schema types.</p><p>The value of the attribute is a whitespace-separated list of tokens, where each token contributes one or more namespace bindings to the <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a> of the <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>. Each token must be one of the following. If a token falls into more than one of these categories, then the first one that applies takes precedence.</p><ul><li><p>The string <code>#standard</code>, which is equivalent to specifying <code>xsl xml xs xsi fn math map array err</code>. This has the effect of binding each of these namespace prefixes to the <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a> with which it is conventionally associated.</p></li><li><p>An <code>NCName</code> corresponding to one of the namespace prefixes present in the in-scope namespaces of the containing element node. This has the effect of adding the corresponding namespace binding to the <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a>.</p></li><li><p>Any one of the strings <code>xsl</code>, <code>xml</code>, <code>xs</code>, <code>xsi</code>, <code>fn</code>, <code>math</code>, <code>map</code>, <code>array</code>, <code>err</code>. This has the effect of binding that particular namespace prefix to the <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a> with which it is conventionally associated, whether or not the <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace bindings</a> contain a binding for this prefix.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Including <code>xml</code> in the list has no effect, since the XML namespace will always be in scope anyway.</p></div><p>If the namespace prefix is explicitly bound to a different namespace, for example <code>xmlns:math="java:java.util.Math"</code>, then that binding takes precedence.</p></li><li><p>A string in the form <code>prefix=uri</code>, where <code>prefix</code> is an <code>NCName</code> and <code>uri</code> is a (non-empty) namespace URI: for example, <code>xalan=http://xml.apache.org/xalan</code>. This has the effect of binding the specified prefix to the specified URI.</p></li><li><p>A <a title="URI Reference" class="termref" href="#dt-uri-reference">URI Reference</a> identifying the location of an XML document whose namespace bindings are to be used. For example, <code>./package.xsl</code>. A token is interpreted as a URI if it does not match any of the other possibilities listed above (which will be the case if it contains a <code>"/"</code> as in this example).</p><p>The <a title="URI Reference" class="termref" href="#dt-uri-reference">URI Reference</a> is used to locate an XML document, in the same way as described for <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a> in <a href="#locating-modules"><i>3.10.1 Locating Stylesheet Modules</i></a>. The resource that is retrieved may be any namespace well-formed XML document. The in-scope namespace bindings of the outermost element of this document are added to the <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a> of the stylesheet module.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Such URIs cannot contain whitespace.</p></div></li></ul><p>If different tokens in the <code>fixed-namespaces</code> attribute result in multiple bindings for the same namespace prefix, the last one wins.</p><p><a id="err-XTSE0122"><span class="error">[ERR XTSE0122] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token appearing in the <code>fixed-namespaces</code> attribute takes a form that is not one of the permitted forms, or if it is interpreted as a URI but cannot be dereferenced to locate a namespace well-formed XML document. It is not permitted to bind the prefix <code>xmlns</code>. It is not permitted to bind the prefix <code>xml</code> or the XML namespace URI <code>http://www.w3.org/XML/1998/namespace</code>, other than to each other. </p><p>The following observations apply when a <code>fixed-namespaces</code> attribute is present:</p><ul><li><p>All expressions in the stylesheet module will have the same <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-namespaces">statically known namespaces</a><sup><small>XP</small></sup> in their static context. This means that all prefixes used in XPath expressions, patterns, and similar constructs must be declared at the top level.</p></li><li><p>Namespace prefixes used in element and attribute names in the stylesheet cannot be declared using this mechanism. Such prefixes must be bound using <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace bindings</a>. This also applies to namespace prefixes used in the <code>[xsl:]exclude-result-prefixes</code> and <code>[xsl:]extension-element-prefixes</code> attributes, and the <code>stylesheet-prefix</code> and <code>result-prefix</code> attributes of <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a>.</p></li><li><p>It is not an error for an element within a stylesheet module to rebind a prefix listed in the <code>fixed-namespaces</code> attribute to a different URI; however this rebinding has no effect on the static context of XPath expressions and other similar constructs within its scope.</p></li><li><p>The <code>fixed-namespaces</code> attribute has no effect on the interpretation of unprefixed names.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">It is possible to use the <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a> in other attributes of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, such as <code>default-mode</code>. It is also possible to use them in shadow attributes (see <a href="#shadow-attributes"><span class="delete_version"><i>3.12.4 Shadow Attributes</i></span><span class="modify_version"><i>3.12.4 Shadow Attributes</i></span></a>).</span><span style="display: none;" class="add_version">It is possible to use the <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a> in other attributes of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, such as <code>default-mode</code>. It is also possible to use them in shadow attributes (see <a href="#shadow-attributes"><span class="add_version"><i>3.11.4 Shadow Attributes</i></span><span class="modify_version"><i>3.11.4 Shadow Attributes</i></span></a>).</span><span class="modify_version">It is possible to use the <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a> in other attributes of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, such as <code>default-mode</code>. It is also possible to use them in shadow attributes (see <a href="#shadow-attributes"><span style="display: none;" class="delete_version"><i>3.12.4 Shadow Attributes</i></span><span style="display: none;" class="add_version"><i>3.11.4 Shadow Attributes</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.4</span><span class="deltaxml-new" style="background:#90EE90">3.11.4</span> Shadow Attributes</i></span></a>).</span></p><p>It is possible for the <code>fixed-namespaces</code> attribute itself to be supplied as a shadow attribute (written with an underscore, <code>_fixed-namespaces</code>). It can then refer to <a title="static variable" class="termref" href="#dt-static-variable">static variables</a> declared in an importing or including <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>. This provides an alternative way of sharing common namespace bindings throughout a <a title="package" class="termref" href="#dt-package">package</a>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The ability to fetch namespace bindings using a URI can be exploited in various ways:</p><ul><li><p>Generally, the benefit is that it avoids repeating the same information in every stylesheet module, thereby reducing the amount of boilerplate code and keeping common information in a common place. This satisfies the <b>DRY</b> principle in software engineering: <em>Don't Repeat Yourself</em>.</p></li><li><p>The document identified by the URI may be a stylesheet module. One way to use the feature is to use the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> as the primary source for namespace bindings.</p></li><li><p>It is also possible to adopt the namespace bindings from a sample source document. For example, if it is known that the stylesheet is designed primarily to process documents whose first start tag takes the form:</p><div class="exampleInner"><pre xml:space="preserve">&lt;w:document
  xmlns:wps="http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"&gt;</pre></div><p>then these three namespace bindings may conveniently be copied to the stylesheet by referencing a sample document of this form.</p><p>Note however, that only the namespace bindings from the outermost element of the document will be copied.</p></li><li><p>It is possible to supply multiple URIs to assemble namespace bindings from more than one source.</p></li><li><p>Namespace bindings taken from an external document may be overridden using a local declaration for the prefix. This must appear after the URI in the content of the <code>fixed-namespaces</code> attribute.</p></li></ul></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Using the <code>fixed-namespaces</code> attribute rather than <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace bindings</a> to bind namespaces has a number of potential benefits:</p><ul><li><p>It reduces repetitive coding across stylesheet module boundaries, and thus eliminates a source of potential errors.</p></li><li><p>It ensures that all expressions in a stylesheet module have the same namespace bindings in their static context. This can reduce implementation overheads because it reduces the need to maintain the namespace context at the level of individual expressions through rewrites such as function inlining. With processors that compile stylesheets to a persistent executable form, it can contribute to a reduction in the size of compiled code.</p></li><li><p>Namespaces bound in this way will never accidentally leak into a result tree; there is no need to exclude them using <code>[xsl:]exclude-result-prefixes</code>.</p></li><li><p>Namespaces declared on literal result elements are used purely to define the namespace of elements and attributes within the result tree; they no longer leak into the static context used when evaluating XPath expressions.</p></li></ul></div></div></div><div class="_diffs div2"><h3><a id="forwards"></a>3.9 <a href="#forwards" style="text-decoration: none">Forwards Compatible Processing</a></h3><p>The intent of forwards compatible behavior is to make it possible to write a stylesheet that takes advantage of features introduced in some version of XSLT subsequent to XSLT 4.0, while retaining the ability to execute the stylesheet with an XSLT 4.0 processor using appropriate fallback behavior.</p><p><span style="display: none;" class="delete_version">It is always possible to write conditional code to run under different XSLT versions by using the <code>use-when</code> feature described in <a href="#conditional-inclusion"><span class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span class="modify_version"><i>3.12.3 Conditional Element Inclusion</i></span></a>. The rules for forwards compatible behavior supplement this mechanism in two ways:</span><span style="display: none;" class="add_version">It is always possible to write conditional code to run under different XSLT versions by using the <code>use-when</code> feature described in <a href="#conditional-inclusion"><span class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i>3.11.3 Conditional Element Inclusion</i></span></a>. The rules for forwards compatible behavior supplement this mechanism in two ways:</span><span class="modify_version">It is always possible to write conditional code to run under different XSLT versions by using the <code>use-when</code> feature described in <a href="#conditional-inclusion"><span style="display: none;" class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span style="display: none;" class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.3</span><span class="deltaxml-new" style="background:#90EE90">3.11.3</span> Conditional Element Inclusion</i></span></a>. The rules for forwards compatible behavior supplement this mechanism in two ways:</span></p><ul><li><p>Certain constructs in the stylesheet that mean nothing to an XSLT 4.0 processor are ignored, rather than being treated as errors.</p></li><li><p>Explicit fallback behavior can be defined for instructions defined in a future XSLT release, using the <a href="#element-fallback"><code>xsl:fallback</code></a> instruction.</p></li></ul><p>The detailed rules follow.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-forwards-compatible-behavior" title="forwards compatible behavior"></a>An element is processed with <b>forwards compatible behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is greater than <span>4.0</span>.<span class="definition">]</span></p><p>These rules do not apply to the <code>version</code> attribute of the <a href="#element-output"><code>xsl:output</code></a> element, which has an entirely different purpose: it is used to define the version of the output method to be used for serialization.</p><p>When an element is processed with forwards compatible behavior:</p><ul><li><p>If the element is in the XSLT namespace and appears as a child of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, and XSLT 4.0 does not allow the element to appear as a child of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, then the element and its content <span class="verb">must</span> be ignored.</p></li><li><p>If the element has an attribute that XSLT 4.0 does not allow the element to have, then the attribute <span class="verb">must</span> be ignored.</p></li><li><p>If the element is in the XSLT namespace and appears as a child of an element whose content model requires a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and XSLT <span>4.0</span> does not allow such elements to appear as part of a sequence constructor, then:</p><ol class="enumar"><li><p>If the element has one or more <a href="#element-fallback"><code>xsl:fallback</code></a> children, then no error is raised either statically or dynamically, and the result of evaluating the instruction is the concatenation of the sequences formed by evaluating the sequence constructors within its <a href="#element-fallback"><code>xsl:fallback</code></a> children, in document order. Siblings of the <a href="#element-fallback"><code>xsl:fallback</code></a> elements are ignored, even if they are valid XSLT 4.0 instructions.</p></li><li><p>If the element has no <a href="#element-fallback"><code>xsl:fallback</code></a> children, then a static error is raised in the same way as if forwards compatible behavior were not enabled.</p></li></ol></li></ul><div class="example"><div class="exampleHeader"><a id="d4e10996"></a><a id="d4e10994"></a>Example: Forwards Compatible Behavior</div><p>For example, an XSLT 4.0 <a title="processor" class="termref" href="#dt-processor">processor</a> will process the following stylesheet without error, although the stylesheet includes elements from the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> that are not defined in this specification:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:stylesheet version="17.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:exciting-new-17.0-feature&gt;
      &lt;xsl:fly-to-the-moon/&gt;
      &lt;xsl:fallback&gt;
        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;XSLT 17.0 required&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
            &lt;p&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/p&gt;
          &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:fallback&gt;
    &lt;/xsl:exciting-new-17.0-feature&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>If a stylesheet depends crucially on a <a title="declaration" class="termref" href="#dt-declaration">declaration</a> introduced by a version of XSLT after <span>4.0</span>, then the stylesheet can use an <a href="#element-message"><code>xsl:message</code></a> element with <code>terminate="yes"</code> (see <a href="#message"><i>23.1 Messages</i></a>) to ensure that implementations that conform to an earlier version of XSLT will not silently ignore the <a title="declaration" class="termref" href="#dt-declaration">declaration</a>.</p></div><div class="example"><div class="exampleHeader"><a id="d4e11029"></a><a id="d4e11027"></a>Example: Testing the XSLT Version</div><p>For example,</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:stylesheet version="18.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:important-new-17.0-declaration/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="number(system-property('xsl:version')) lt 17.0"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        ...
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  ...
&lt;/xsl:stylesheet&gt;</pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The XSLT 1.0 and XSLT 2.0 specifications did not anticipate the introduction of the <a href="#element-package"><code>xsl:package</code></a> element. An XSLT 1.0 or 2.0 processor encountering this element will raise a static error, regardless of the <code>version</code> setting.</p><p>This problem can be circumvented by using the simplified package syntax (whereby an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element is implicitly treated as <a href="#element-package"><code>xsl:package</code></a>), or by writing the stylesheet code in a separate module from the package manifest, and using the separate module as the version of the stylesheet that is presented to a 2.0 processor.</p></div><p>For an XSLT 4.0 processor, the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of an <a href="#element-fallback"><code>xsl:fallback</code></a> element that has no explicit <code>version</code> attribute is 4.0: more generally, it is the version of XSLT supported by the processor. This rule is designed to ensure that the <a href="#element-fallback"><code>xsl:fallback</code></a> element itself is not processed with <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a>, which would be pointless since the whole purpose of the instruction is to provide code that can be evaluated with an earlier version of XSLT.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This rule was not present in earlier versions of this specification. On a strict reading of the XSLT 3.0 specification, for example, an <a href="#element-fallback"><code>xsl:fallback</code></a> instruction with no <code>version</code> attribute is evaluated with forwards compatible behavior. This means, for example, that if the stylesheet author writes <code>&lt;xsl:fallback select="42"/&gt;</code> (which is incorrect, because the instruction does not define a <code>select</code> attribute) then the <code>select</code> attribute will simply be ignored.</p><p>Stylesheet authors can prevent this problem by adding an explicit <code>version</code> attribute to <code>xsl:fallback</code> indicating the version of XSLT that is needed to evaluate the fallback code.</p><p>This specification cannot retrospectively dictate what XSLT 3.0 (or earlier) processors should do; however, developers of such processors are encouraged to adopt this rule, so that in an XSLT 4.0 stylesheet, an <a href="#element-fallback"><code>xsl:fallback</code></a> instruction that cannot be properly evaluated by an XSLT 3.0 processor is rejected rather than being silently ignored.</p></div></div><div class="_diffs div2"><h3><a id="embedded"></a><span class="deltaxml-old" style="background:#FF5555">3.11 </span><a href="#embedded" style="text-decoration: none"><span class="deltaxml-old" style="background:#FF5555">Embedded Stylesheet Modules</span></a></h3><p><span class="deltaxml-old" style="background:#FF5555">An </span><a title="embedded stylesheet module" class="termref" href="#dt-embedded-stylesheet-module"><span class="deltaxml-old" style="background:#FF5555">embedded stylesheet module</span></a><span class="deltaxml-old" style="background:#FF5555"> is a </span><a title="stylesheet module" class="termref" href="#dt-stylesheet-module"><span class="deltaxml-old" style="background:#FF5555">stylesheet module</span></a><span class="deltaxml-old" style="background:#FF5555"> whose containing element is not the outermost element of the containing XML document. Both </span><a title="standard stylesheet module" class="termref" href="#dt-standard-stylesheet-module"><span class="deltaxml-old" style="background:#FF5555">standard stylesheet modules</span></a><span class="deltaxml-old" style="background:#FF5555"> and </span><a title="simplified stylesheet" class="termref" href="#dt-simplified-stylesheet-module"><span class="deltaxml-old" style="background:#FF5555">simplified stylesheet modules</span></a><span class="deltaxml-old" style="background:#FF5555"> may be embedded in this way.</span></p><p><span class="deltaxml-old" style="background:#FF5555">Two situations where embedded stylesheets may be useful are:</span></p><ul><li><p><span class="deltaxml-old" style="background:#FF5555">The stylesheet may be embedded in the source document to be transformed.</span></p></li><li><p><span class="deltaxml-old" style="background:#FF5555">The stylesheet may be embedded in an XML document that describes a sequence of processing of which the XSLT transformation forms just one part.</span></p></li></ul><p><span class="deltaxml-old" style="background:#FF5555">The </span><a href="#element-stylesheet"><code><span class="deltaxml-old" style="background:#FF5555">xsl:stylesheet</span></code></a><span class="deltaxml-old" style="background:#FF5555"> element </span><span class="verb"><span class="deltaxml-old" style="background:#FF5555">may</span></span><span class="deltaxml-old" style="background:#FF5555"> have an </span><code><span class="deltaxml-old" style="background:#FF5555">id</span></code><span class="deltaxml-old" style="background:#FF5555"> attribute to facilitate reference to the stylesheet module within the containing document.</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-old" style="background:#FF5555">Note:</span></b></p><p><span class="deltaxml-old" style="background:#FF5555">In order for such an attribute value to be used as a fragment identifier in a URI, the XDM attribute node must generally have the </span><code><span class="deltaxml-old" style="background:#FF5555">is-id</span></code><span class="deltaxml-old" style="background:#FF5555"> property: see </span><a href="#xpath-datamodel-40"><span class="deltaxml-old" style="background:#FF5555">[XDM 4.0]</span></a><span class="deltaxml-old" style="background:#FF5555"> section </span><a href="../xpath-datamodel-40/#dm-is-id"><span class="deltaxml-old" style="background:#FF5555">7.6.5 is-id Accessor</span></a><span class="deltaxml-old" style="background:#FF5555">. This property will typically be set if the attribute is defined in a DTD as being of type </span><code><span class="deltaxml-old" style="background:#FF5555">ID</span></code><span class="deltaxml-old" style="background:#FF5555">, or if it is defined in a schema as being of type </span><code><span class="deltaxml-old" style="background:#FF5555">xs:ID</span></code><span class="deltaxml-old" style="background:#FF5555">. It is also necessary that the media type of the containing document should support the use of ID values as fragment identifiers. Such support is widespread in existing products, and is endorsed in respect of the media type </span><code><span class="deltaxml-old" style="background:#FF5555">application/xml</span></code><span class="deltaxml-old" style="background:#FF5555"> by </span><a href="#rfc7303"><span class="deltaxml-old" style="background:#FF5555">[RFC7303]</span></a><span class="deltaxml-old" style="background:#FF5555">.</span></p><p><span class="deltaxml-old" style="background:#FF5555">An alternative, if the implementation supports it, is to use an </span><code><span class="deltaxml-old" style="background:#FF5555">xml:id</span></code><span class="deltaxml-old" style="background:#FF5555"> attribute. XSLT allows this attribute (like other namespaced attributes) to appear on any </span><a title="XSLT element" class="termref" href="#dt-xslt-element"><span class="deltaxml-old" style="background:#FF5555">XSLT element</span></a><span class="deltaxml-old" style="background:#FF5555">.</span></p></div><div class="example"><div class="exampleHeader"><a id="d4e11578"></a><span class="deltaxml-old" style="background:#FF5555">Example: The </span><code><span class="deltaxml-old" style="background:#FF5555">xml-stylesheet</span></code><span class="deltaxml-old" style="background:#FF5555"> Processing Instruction</span></div><p><span class="deltaxml-old" style="background:#FF5555">The following example shows how the </span><code><span class="deltaxml-old" style="background:#FF5555">xml-stylesheet</span></code><span class="deltaxml-old" style="background:#FF5555"> processing instruction (see </span><a href="#xml-stylesheet"><span class="deltaxml-old" style="background:#FF5555">[XML Stylesheet]</span></a><span class="deltaxml-old" style="background:#FF5555">) can be used to allow a source document to contain its own stylesheet. The URI reference uses a fragment identifier to locate the </span><a href="#element-stylesheet"><code><span class="deltaxml-old" style="background:#FF5555">xsl:stylesheet</span></code></a><span class="deltaxml-old" style="background:#FF5555"> element:</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-old" style="background:#FF5555">&lt;?xml-stylesheet type="application/xslt+xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
  &lt;head&gt;
    &lt;xsl:stylesheet id="style1"
                    version="3.0"
                    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                    xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:import href="doc.xsl"/&gt;
    &lt;xsl:template match="id('foo')"&gt;
      &lt;fo:block font-weight="bold"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="xsl:stylesheet"&gt;
      &lt;!-- ignore --&gt;
    &lt;/xsl:template&gt;
    &lt;/xsl:stylesheet&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;para id="foo"&gt;
    ...
    &lt;/para&gt;
  &lt;/body&gt;
&lt;/doc&gt;</span></pre></div></div><div class="note"><p class="prefix"><b><span class="deltaxml-old" style="background:#FF5555">Note:</span></b></p><p><span class="deltaxml-old" style="background:#FF5555">A stylesheet module that is embedded in the document to which it is to be applied typically needs to contain a </span><a title="template rule" class="termref" href="#dt-template-rule"><span class="deltaxml-old" style="background:#FF5555">template rule</span></a><span class="deltaxml-old" style="background:#FF5555"> that specifies that </span><a href="#element-stylesheet"><code><span class="deltaxml-old" style="background:#FF5555">xsl:stylesheet</span></code></a><span class="deltaxml-old" style="background:#FF5555"> elements are to be ignored.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old" style="background:#FF5555">Note:</span></b></p><p><span class="deltaxml-old" style="background:#FF5555">The above example uses the pseudo-attribute </span><code><span class="deltaxml-old" style="background:#FF5555">type="application/xslt+xml"</span></code><span class="deltaxml-old" style="background:#FF5555"> in the </span><code><span class="deltaxml-old" style="background:#FF5555">xml-stylesheet</span></code><span class="deltaxml-old" style="background:#FF5555"> processing instruction to denote an XSLT stylesheet. This is the officially registered media type for XSLT: see </span><a href="#xslt-media-type"><i><span class="deltaxml-old" style="background:#FF5555">3.2 XSLT Media Type</span></i></a><span class="deltaxml-old" style="background:#FF5555">. However, browsers developed before this media type was registered are more likely to accept the unofficial designation </span><code><span class="deltaxml-old" style="background:#FF5555">type="text/xsl"</span></code><span class="deltaxml-old" style="background:#FF5555">.</span></p></div><div class="note"><p class="prefix"><b><span class="deltaxml-old" style="background:#FF5555">Note:</span></b></p><p><span class="deltaxml-old" style="background:#FF5555">Support for the </span><code><span class="deltaxml-old" style="background:#FF5555">xml-stylesheet</span></code><span class="deltaxml-old" style="background:#FF5555"> processing instruction is not required for conformance with this Recommendation. Implementations are not constrained in the mechanisms they use to identify a stylesheet when a transformation is initiated: see </span><a href="#initiating"><i><span class="deltaxml-old" style="background:#FF5555">2.3 Initiating a Transformation</span></i></a><span class="deltaxml-old" style="background:#FF5555">.</span></p></div></div><div class="_diffs div2"><h3><a id="preprocessing"></a><span class="deltaxml-old" style="background:#FF5555">3.12</span><span class="deltaxml-new" style="background:#90EE90">3.11</span> <a href="#preprocessing" style="text-decoration: none">Stylesheet Preprocessing</a></h3><p>This specification provides <span>three</span> features that cause the raw stylesheet to be preprocessed as the first stage of static processing: </p><ul><li><p>Whitespace and commentary are stripped (see <a href="#stylesheet-stripping"><span style="display: none;" class="delete_version"><i>3.12.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span style="display: none;" class="add_version"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.1</span><span class="deltaxml-new" style="background:#90EE90">3.11.1</span> Stripping Whitespace and Commentary from the Stylesheet</i></span></a>).</p></li><li><p><span style="display: none;" class="delete_version">Elements may be conditionally included or excluded by means of an <code>[xsl:]use-when</code> attribute as described in <a href="#conditional-inclusion"><span class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span class="modify_version"><i>3.12.3 Conditional Element Inclusion</i></span></a>.</span><span style="display: none;" class="add_version">Elements may be conditionally included or excluded by means of an <code>[xsl:]use-when</code> attribute as described in <a href="#conditional-inclusion"><span class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i>3.11.3 Conditional Element Inclusion</i></span></a>.</span><span class="modify_version">Elements may be conditionally included or excluded by means of an <code>[xsl:]use-when</code> attribute as described in <a href="#conditional-inclusion"><span style="display: none;" class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span style="display: none;" class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.3</span><span class="deltaxml-new" style="background:#90EE90">3.11.3</span> Conditional Element Inclusion</i></span></a>.</span></p></li><li><p>Attributes may be conditionally computed as described in <a href="#shadow-attributes"><span style="display: none;" class="delete_version"><i>3.12.4 Shadow Attributes</i></span><span style="display: none;" class="add_version"><i>3.11.4 Shadow Attributes</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.4</span><span class="deltaxml-new" style="background:#90EE90">3.11.4</span> Shadow Attributes</i></span></a>.</p></li></ul><p></p><p>Note that many of the rules affecting the validity of stylesheet documents apply to a stylesheet after this preprocessing phase has been carried out.</p><div class="_diffs div3"><h4><a id="stylesheet-stripping"></a><span class="deltaxml-old" style="background:#FF5555">3.12.1</span><span class="deltaxml-new" style="background:#90EE90">3.11.1</span> <a href="#stylesheet-stripping" style="text-decoration: none">Stripping Whitespace and Commentary from the Stylesheet</a></h4><p>The tree representing the stylesheet is preprocessed as follows:</p><ol class="enumar"><li><p>All comments and processing instructions are removed.</p></li><li><p>All <a href="#element-note"><code>xsl:note</code></a> elements are removed, together with their content (see <a href="#xsl-note-elements"><span style="display: none;" class="delete_version"><i>3.12.2 The xsl:note element</i></span><span style="display: none;" class="add_version"><i>3.11.2 The xsl:note element</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.2</span><span class="deltaxml-new" style="background:#90EE90">3.11.2</span> The xsl:note element</i></span></a>).</p></li><li><p>Any text nodes that are now adjacent to each other are merged.</p></li><li><p>Any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> that satisfies both the following conditions is removed from the tree:</p><ul><li><p>The parent of the text node is not an <a href="#element-text"><code>xsl:text</code></a> element</p></li><li><p>The text node does not have an ancestor element that has an <code>xml:space</code> attribute with a value of <code>preserve</code>, unless there is a closer ancestor element having an <code>xml:space</code> attribute with a value of <code>default</code>.</p></li></ul></li><li><p>Any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> whose parent is one of the following elements is removed from the tree, regardless of any <code>xml:space</code> attributes:</p><blockquote><p><a href="#element-accumulator"><code>xsl:accumulator</code></a><br><a href="#element-analyze-string"><code>xsl:analyze-string</code></a><br><a href="#element-apply-imports"><code>xsl:apply-imports</code></a><br><a href="#element-apply-templates"><code>xsl:apply-templates</code></a><br><a href="#element-attribute-set"><code>xsl:attribute-set</code></a><br><a href="#element-call-template"><code>xsl:call-template</code></a><br><a href="#element-character-map"><code>xsl:character-map</code></a><br><a href="#element-choose"><code>xsl:choose</code></a><br><a href="#element-evaluate"><code>xsl:evaluate</code></a><br><a href="#element-fork"><code>xsl:fork</code></a><br><a href="#element-merge"><code>xsl:merge</code></a><br><a href="#element-merge-source"><code>xsl:merge-source</code></a><br><a href="#element-mode"><code>xsl:mode</code></a><br><a href="#element-next-iteration"><code>xsl:next-iteration</code></a><br><a href="#element-next-match"><code>xsl:next-match</code></a><br><a href="#element-override"><code>xsl:override</code></a><br><a href="#element-package"><code>xsl:package</code></a><br><a href="#element-stylesheet"><code>xsl:stylesheet</code></a><br><a href="#element-switch"><code>xsl:switch</code></a><br><a href="#element-transform"><code>xsl:transform</code></a><br><a href="#element-use-package"><code>xsl:use-package</code></a></p></blockquote></li><li><p>Any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> whose immediate following-sibling node is an <a href="#element-param"><code>xsl:param</code></a> or <a href="#element-sort"><code>xsl:sort</code></a> or <a href="#element-context-item"><code>xsl:context-item</code></a> or <a href="#element-on-completion"><code>xsl:on-completion</code></a> element is removed from the tree, regardless of any <code>xml:space</code> attributes.</p></li><li><p>Any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> whose immediate preceding-sibling node is an <a href="#element-catch"><code>xsl:catch</code></a> element is removed from the tree, regardless of any <code>xml:space</code> attributes.</p></li></ol><p><a id="err-XTSE0260"><span class="error">[ERR XTSE0260] </span></a>Within an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a> that is <span class="verb">required</span> to be empty, any content other than comments or processing instructions, including any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> preserved using the <code>xml:space="preserve"</code> attribute, is a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Using <code>xml:space="preserve"</code> in parts of the stylesheet that contain <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructors</a> will cause whitespace text nodes in that part of the stylesheet to be copied to the result of the sequence constructor. When the result of the sequence constructor is used to form the content of an element, this can cause errors if such text nodes are followed by attribute nodes generated using <a href="#element-attribute"><code>xsl:attribute</code></a>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>If an <code>xml:space</code> attribute is specified on a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, it will be copied to the result tree in the same way as any other attribute.</p></div></div><div class="_diffs div3"><h4><a id="xsl-note-elements"></a><span class="deltaxml-old" style="background:#FF5555">3.12.2</span><span class="deltaxml-new" style="background:#90EE90">3.11.2</span> <a href="#xsl-note-elements" style="text-decoration: none">The <code>xsl:note</code> element</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#import-schema">next</a> | <a href="#include">previous</a>)</p><ol><li><p> A new element <a href="#element-note"><code>xsl:note</code></a> is available for documentation and similar purposes: it can appear anywhere in the stylesheet and is ignored by the XSLT processor. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/109">109</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/353">353</a>&nbsp;19 April 2023]</i></p></li></ol></div><p>An <a href="#element-note"><code>xsl:note</code></a> element may appear anywhere in the stylesheet, except as the outermost element.</p><p class="element-syntax"><a id="element-note"></a><code>&lt;xsl:note<br>&nbsp;&nbsp;#any#? = <var>string</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>any</var> --&gt;<br>&lt;/xsl:note&gt;</code></p><p>The element may have any attributes and any children, subject only to rules imposed by other specifications such as the XML specification. The XSLT processor discards <a href="#element-note"><code>xsl:note</code></a> elements at an early stage of processing, without performing any validation, as described in <a href="#stylesheet-stripping"><span style="display: none;" class="delete_version"><i>3.12.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span style="display: none;" class="add_version"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.1</span><span class="deltaxml-new" style="background:#90EE90">3.11.1</span> Stripping Whitespace and Commentary from the Stylesheet</i></span></a>.</p><p>An <a href="#element-note"><code>xsl:note</code></a> element is typically used for documentation. The format of this documentation is not prescribed here: it might be free text, or XHTML, or some custom vocabulary understood by a free-standing documentation generator.</p><p>An <a href="#element-note"><code>xsl:note</code></a> element might also be used for “commenting out” XSLT declarations or instructions.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>A number of documentation processors have been produced for use with XSLT, and the general convention has been to use <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> for this purpose. This approach has its drawbacks:</p><ul><li><p>Annotations can only appear at the top level of the stylesheet (between declarations, but not within declarations). <a title="extension instruction" class="termref" href="#dt-extension-instruction">Extension instructions</a> can also potentially be used as annotations, but this abuses their intended purpose and may create an unwanted dependency on a specific processor.</p></li><li><p>Annotations require a custom namespace to be declared, typically on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, and this namespace becomes part of the static context for all expressions within the stylesheet, thus changing (if only very slightly) the semantics of the stylesheet code. This is true even if the namespace is excluded from the result tree by means of an <code>[xsl:]exclude-result-prefixes</code> attribute.</p></li></ul></div><p>Implementations <span class="verb">must not</span> interpret the contents of an <a href="#element-note"><code>xsl:note</code></a> element to modify the behavior of the stylesheet in any way, whether or not the resulting behavior remains conformant with this specification.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, <a href="#element-note"><code>xsl:note</code></a> elements must not be used to provide processor-specific performance hints. There are better mechanisms for this, such as <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> and <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a>.</p></div></div><div class="_diffs div3"><h4><a id="conditional-inclusion"></a><span class="deltaxml-old" style="background:#FF5555">3.12.3</span><span class="deltaxml-new" style="background:#90EE90">3.11.3</span> <a href="#conditional-inclusion" style="text-decoration: none">Conditional Element Inclusion</a></h4><p>Any element in the XSLT namespace may have a <code>use-when</code> attribute whose value is an XPath expression that can be evaluated statically. A <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, or any other element within a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that is not in the XSLT namespace, may similarly carry an <code>xsl:use-when</code> attribute. If the attribute is present and the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-ebv">effective boolean value</a><sup><small>XP</small></sup> of the expression is <code>false</code>, then the element, together with all the nodes having that element as an ancestor, is effectively excluded from the <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>. When a node is effectively excluded from a stylesheet module the stylesheet module has the same effect as if the node were not there. Among other things this means that no static or dynamic errors will be raised in respect of the element and its contents, other than errors in the <code>use-when</code> attribute itself.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This does not apply to XML parsing or validation errors, which will be raised in the usual way. It also does not apply to attributes that are necessarily processed before <code>[xsl:]use-when</code>, examples being <code>xml:space</code> and <code>[xsl:]xpath-default-namespace</code>.</p></div><p>If the <a href="#element-package"><code>xsl:package</code></a>, <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element itself is effectively excluded, the effect is to exclude all the children of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element, but not the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element or its attributes.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This allows all the declarations that depend on the same condition to be included in one stylesheet module, and for their inclusion or exclusion to be controlled by a single <code>use-when</code> attribute at the level of the module.</p></div><p>Conditional element exclusion happens after stripping of whitespace text nodes from the stylesheet, as described in <a href="#stylesheet-stripping"><span style="display: none;" class="delete_version"><i>3.12.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span style="display: none;" class="add_version"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.1</span><span class="deltaxml-new" style="background:#90EE90">3.11.1</span> Stripping Whitespace and Commentary from the Stylesheet</i></span></a>.</p><p>The XPath expression used as the value of the <code>xsl:use-when</code> attribute follows the rules for <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a>, including the rules for handling errors.</p><p>The use of <code>[xsl:]use-when</code> is illustrated in the following examples.</p><div class="example"><div class="exampleHeader"><a id="d4e12011"></a><a id="d4e11903"></a>Example: Using Conditional Exclusion to Achieve Portability</div><p>This example demonstrates the use of the <code>use-when</code> attribute to achieve portability of a stylesheet across schema-aware and non-schema-aware processors.</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:import-schema schema-location="http://example.com/schema"
              use-when="system-property('xsl:is-schema-aware')='yes'"/&gt;

&lt;xsl:template match="/" 
              use-when="system-property('xsl:is-schema-aware')='yes'" 
              priority="2"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre></div><p>The effect of these declarations is that a non-schema-aware processor ignores the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration and the first template rule, and therefore raises no errors in respect of the schema-related constructs in these declarations.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e12024"></a><a id="d4e11916"></a>Example: Including Variant Stylesheet Modules</div><p>This example includes different stylesheet modules depending on which XSLT processor is in use.</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:include href="module-A.xsl" 
     use-when="system-property('xsl:vendor')='vendor-A'"/&gt;
&lt;xsl:include href="module-B.xsl" 
     use-when="system-property('xsl:vendor')='vendor-B'"/&gt;</pre></div></div></div><div class="_diffs div3"><h4><a id="shadow-attributes"></a><span class="deltaxml-old" style="background:#FF5555">3.12.4</span><span class="deltaxml-new" style="background:#90EE90">3.11.4</span> <a href="#shadow-attributes" style="text-decoration: none">Shadow Attributes</a></h4><p>When a no-namespace attribute name <var>N</var> is permitted to appear on an element in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> (provided that <var>N</var> does not start with an underscore), then a value <var>V</var> can be supplied for <var>N</var> in one of two ways: </p><ul><li><p>The conventional way is for an attribute node with name <var>N</var> and value <var>V</var> to appear in the XDM representation of the element node in the stylesheet tree. </p></li><li><p>As an alternative, a shadow attribute may be supplied allowing the value <var>V</var> to be statically computed during the preprocessing phase. The shadow attribute has a name that is the same as the name <var>N</var> prefixed with an underscore, and the value of the shadow attribute is a <a title="value template" class="termref" href="#dt-value-template">value template</a> in which all expressions enclosed between curly braces must be <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a>. The value <var>V</var> is the result of evaluating the value template. If a shadow attribute is present, then any attribute node with name <var>N</var> (sharing the same parent element) is ignored. </p></li></ul><p>For example, an <a href="#element-include"><code>xsl:include</code></a> element might be written:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:include _href="common{ $VERSION }.xsl"/&gt;</pre></div><p>allowing the stylesheet to include a specific version of a library module based on the value of a <a title="static parameter" class="termref" href="#dt-static-parameter">static parameter</a>.</p><p>Similarly, a <a title="mode" class="termref" href="#dt-mode">mode</a> might be declared like this:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:param name="streamable" as="xs:boolean" 
                  required="yes" static="yes"/&gt;
&lt;xsl:mode _streamable="{ $streamable }" on-no-match="shallow-skip"/&gt;</pre></div><p>this allowing the streamability of the mode to be controlled using a <a title="static parameter" class="termref" href="#dt-static-parameter">static parameter</a> (Note: this example relies on the fact that the <code>streamable</code> attribute accepts a boolean value, which means that the values <code>true</code> and <code>false</code> are accepted as synonyms of <code>yes</code> and <code>no</code>).</p><p>This mechanism applies to all attributes in the stylesheet where the attribute name is in no namespace and the name of the parent element is in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>. This includes attributes that have static significance such as the <code>use-when</code> attribute, the <code>version</code> attribute, and the <code>static</code> attribute on <a href="#element-variable"><code>xsl:variable</code></a>. The mechanism does not apply to shadow attributes (that is, it is not possible to invoke two stages of preprocessing by using two leading underscores). It does not apply to attributes of literal result elements, nor to attributes in a namespace such as the XML or XSLT namespace, nor to namespace declarations.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If a shadow attribute and its corresponding target attribute are both present in the stylesheet, the non-shadow attribute is ignored. This may be useful to make stylesheet code compatible across XSLT versions; an XSLT 2.0 processor operating in forwards compatible mode will ignore shadow attributes, and will require the target attribute to be valid.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The statement that the non-shadow attribute is ignored extends to error detection: it is not an error if the non-shadow attribute has an invalid value. However, this is not reflected in the schema for XSLT stylesheets, so validation using this schema may raise errors in such cases.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>An attribute whose name begins with an underscore is treated specially only when it appears on an element in the XSLT namespace. On a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, it is treated in the same way as any other attribute (that is, its <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is copied to the result tree). On an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> or <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data element</a>, as with other attributes on these elements, its meaning is entirely <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p></div><div class="example"><div class="exampleHeader"><a id="d4e12137"></a><a id="d4e12029"></a>Example: Using Shadow Attributes to Parameterize XPath Default Namespace</div><p>Although it is not usually considered good practice, it sometimes happens that variants or versions of an XML vocabulary exist in which the same local names are used, but in different namespaces. There is then a requirement to write code that will process source documents in a variety of different namespaces.</p><p>It is possible to define a static stylesheet parameter containing the target namespace, for example:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:param name="NS" as="xs:string" static="yes" 
                          select="'http://example.com/ns/one'"/&gt;</pre></div><p>And this can then be used to set the default namespace for XPath expressions:</p><div class="exampleInner"><pre xml:space="preserve">_xpath-default-namespace="{ $NS }"</pre></div><p>However, it is not possible to put this shadow attribute on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-package"><code>xsl:package</code></a> element of the principal stylesheet module, because at that point the variable <code>$NS</code> is not in scope. A workaround is to create a stub stylesheet module which contains nothing but the static parameter declaration and an <a href="#element-include"><code>xsl:include</code></a> of the stylesheet module containing the real logic. The static stylesheet parameter will then be in scope on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element of the included stylesheet module, and the shadow attribute <code>_xpath-default-namespace="{ $NS }"</code> can therefore appear on this <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e12165"></a><a id="d4e12057"></a>Example: Using Shadow Attributes to Parameterize Selection of Elements</div><p>The following stylesheet produces a report giving information about selected employees. The predicate defining which employees are to be included in the report is supplied (as a string containing an XPath expression) in a static stylesheet parameter:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:param name="filter" static="yes"
           as="xs:string" select="'true()'"/&gt;
&lt;xsl:function name="local:filter" as="xs:boolean"&gt;
   &lt;xsl:param name="e" as="element(employee)"/&gt;
   &lt;xsl:sequence _select="$e/({ $filter })"/&gt;
&lt;/xsl:function&gt;
&lt;xsl:template match="/"&gt;
   &lt;report&gt;
      &lt;xsl:apply-templates mode="report" select="//employee[local:filter(.)]"/&gt;
   &lt;/report&gt;
&lt;/xsl:template&gt;</pre></div><p>If the supplied value of the filter parameter is, say <code>location = "UK"</code>, then the report will cover employees based in the UK.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The stylesheet function <code>local:filter</code> is used here in preference to direct use of the supplied predicate within the <code>select</code> attribute of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction because it reduces exposure to code injection attacks. It does not necessarily eliminate all such risks, however. For example, it would be possible for a caller to supply an expression that never terminates, thus creating a denial-of-service risk.</p></div></div></div></div><div class="_diffs div2"><h3><a id="built-in-types"></a><span class="deltaxml-old" style="background:#FF5555">3.13</span><span class="deltaxml-new" style="background:#90EE90">3.12</span> <a href="#built-in-types" style="text-decoration: none">Built-in Types</a></h3><p>Every XSLT 4.0 processor includes the following named type definitions in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a>:</p><ul><li><p> All built-in types defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>, including <code>xs:anyType</code> and <code>xs:anySimpleType</code>.</p></li><li><p>The following types defined in <a href="#xpath-40">[XPath 4.0]</a>: <code>xs:yearMonthDuration</code>, <code>xs:dayTimeDuration</code>, <code>xs:anyAtomicType</code>, <code>xs:untyped</code>, and <code>xs:untypedAtomic</code>.</p></li></ul><p>XSLT 4.0 processors <span class="verb">may</span> optionally include types defined in XSD 1.1 (see <a href="#xmlschema11-1">[XML Schema 1.1 Part 1]</a>). XSD 1.1 adopts the types <code>xs:yearMonthDuration</code>, <code>xs:dayTimeDuration</code>, and <code>xs:anyAtomicType</code> previously defined in XPath 2.0, and adds one new type: <code>xs:dateTimeStamp</code>. XSD 1.1 also allows implementers to define additional primitive types, and XSLT 4.0 permits such types to be supported by an XSLT processor.</p><p>A <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a> additionally supports:</p><ul><li><p>User-defined types, and element and attribute declarations, that are imported using an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration as described in <a href="#import-schema"><span style="display: none;" class="delete_version"><i>3.14 Importing Schema Components</i></span><span style="display: none;" class="add_version"><i>3.13 Importing Schema Components</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.14</span><span class="deltaxml-new" style="background:#90EE90">3.13</span> Importing Schema Components</i></span></a>. These may include both simple and complex types.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The names that are imported from the XML Schema namespace do not include all the names of top-level types defined in either the Schema for Schema Documents or the Schema for Schema Documents (Datatypes). The Schema for Schema Documents, as well as defining built-in types such as <code>xs:integer</code> and <code>xs:double</code>, also defines types that are intended for use only within that schema, such as <code>xs:derivationControl</code>. A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that is designed to process XML Schema documents as its input or output may import the Schema for Schema Documents.</p></div><p>An implementation may define mechanisms that allow additional <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> to be added to the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> for the stylesheet. For example, the mechanisms used to define <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> (see <a href="#extension-functions"><i>24.2 Extension Functions</i></a>) may also be used to import the types used in the interface to such functions.</p><p>These <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> are the only ones that may be referenced in XPath expressions within the stylesheet, or in the <code>[xsl:]type</code> and <code>as</code> attributes of those elements that permit these attributes.</p></div><div class="_diffs div2"><h3><a id="import-schema"></a><span class="deltaxml-old" style="background:#FF5555">3.14</span><span class="deltaxml-new" style="background:#90EE90">3.13</span> <a href="#import-schema" style="text-decoration: none">Importing Schema Components</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#multiple-schemas">next</a> | <a href="#xsl-note-elements">previous</a>)</p><ol><li><p> The rules concerning the compatibility of schemas imported by different packages have been clarified. It is now explicitly stated that instructions that trigger validation must use the imported schema of the package in which validation is invoked. This differs from the current practice of some XSLT 3.0 processors, which may use (for example) a schema formed from the union of the imported schemas in all packages. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/451">451</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/635">635</a>&nbsp;24 October 2023]</i></p></li><li><p> Different parts of a stylesheet may now use different imported schemas. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/451">451</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1819">1819</a>&nbsp;18 February 2025]</i></p></li></ol></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The facilities described in this section are not available with a <a title="basic XSLT processor" class="termref" href="#dt-basic-xslt-processor">basic XSLT processor</a>. They require a <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a>, as described in <a href="#conformance"><i>27 Conformance</i></a>.</p></div><p class="element-syntax"><a id="element-import-schema"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:import-schema<br>&nbsp;&nbsp;role? = <var>ncname</var><br>&nbsp;&nbsp;namespace? = <var>uri</var><br>&nbsp;&nbsp;schema-location? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: xs:schema? --&gt;<br>&lt;/xsl:import-schema&gt;</code></p><p>The <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration is used to identify <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> (that is, top-level type definitions and top-level element and attribute declarations) that need to be available statically, that is, before any source document is available. Names of such components used statically within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> must refer to an <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema component</a>, which means they must either be built-in types as defined in <a href="#built-in-types"><span style="display: none;" class="delete_version"><i>3.13 Built-in Types</i></span><span style="display: none;" class="add_version"><i>3.12 Built-in Types</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.13</span><span class="deltaxml-new" style="background:#90EE90">3.12</span> Built-in Types</i></span></a>, or they must be imported using an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.</p><p>The <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration identifies a namespace containing the names of the components to be imported (or indicates that components whose names are in no namespace are to be imported). The effect is that the names of top-level element and attribute declarations and type definitions from this namespace (or non-namespace) become available for use within XPath expressions in the <a title="package" class="termref" href="#dt-package">package</a>, and within other stylesheet constructs such as the <code>type</code> and <code>as</code> attributes of various <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>.</p><p>If the <code>role</code> attribute is absent, the relevant schema components are available in all stylesheet modules within the <a title="declaring package" class="termref" href="#dt-declaring-package">declaring package</a>, except within subtrees of a stylesheet module where a different schema is selected using an <code>[xsl:]schema-role</code> attribute. Importing components in one stylesheet module makes them available throughout the <a title="package" class="termref" href="#dt-package">package</a>, subject to the constraints imposed by the <code>[xsl:]schema-role</code> attribute. </p><p>The schema components imported into different <a title="package" class="termref" href="#dt-package">packages</a> within a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (regardless of the schema role) must be <span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible">compatible</a><sup><small>DM</small></sup></span>. Specifically, it is not permitted to use the same name in the same XSD symbol space to refer to different schema components within different packages; and the union of the schema components imported into the packages of a stylesheet must constitute a valid schema (as well as the set of schema components imported into each package forming a valid schema in its own right).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The fact that the schemas used in different packages must be compatible does not mean they must be identical. There are circumstances where validating an element using one schema might produce a different outcome from validation with a different schema, despite these consistency rules: an example is where the two schemas define different membership for a substitution group.</p><p>Nevertheless, the consistency rules are strong enough to ensure that an element node validated using one schema can safely be passed to a function declared in another package, where the function declares the required type of an argument as (say) <code>element(*, T)</code>.</p></div><p>The <code>namespace</code> and <code>schema-location</code> attributes are both optional.</p><p>If the <a href="#element-import-schema"><code>xsl:import-schema</code></a> element contains an <code>xs:schema</code> element, then the <code>schema-location</code> attribute <span class="verb">must</span> be absent, and one of the following <span class="verb">must</span> be true:</p><ul><li><p>the <code>namespace</code> attribute of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> element and the <code>targetNamespace</code> attribute of the <code>xs:schema</code> element are both absent (indicating a no-namespace schema), or</p></li><li><p>the <code>namespace</code> attribute of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> element and the <code>targetNamespace</code> attribute of the <code>xs:schema</code> element are both present and both have the same value, or</p></li><li><p>the <code>namespace</code> attribute of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> element is absent and the <code>targetNamespace</code> attribute of the <code>xs:schema</code> element is present, in which case the target namespace is as given on the <code>xs:schema</code> element.</p></li></ul><p><a id="err-XTSE0215"><span class="error">[ERR XTSE0215] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-import-schema"><code>xsl:import-schema</code></a> element that contains an <code>xs:schema</code> element has a <code>schema-location</code> attribute, or if it has a <code>namespace</code> attribute that conflicts with the target namespace of the contained schema. </p><p>If two <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations with the same effective <code>role</code> name specify the same namespace, or if both specify no namespace, then only the one with highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used. If this leaves more than one, then all the declarations at the highest import precedence are used (which may cause conflicts, as described below).</p><p>After discarding any <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations under the above rule, the effect of the remaining <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations for each distinct schema role is defined in terms of a hypothetical document called the synthetic schema document, which is constructed as follows. The synthetic schema document defines an arbitrary target namespace that is different from any namespace actually used by the application, and it contains <code>xs:import</code> elements corresponding one-for-one with the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations with that effective schema role in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, with the following correspondence:</p><ul><li><p>The <code>namespace</code> attribute of the <code>xs:import</code> element is copied from the <code>namespace</code> attribute of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration if it is explicitly present, or is implied by the <code>targetNamespace</code> attribute of a contained <code>xs:schema</code> element, and is absent if it is absent.</p></li><li><p>The <code>schemaLocation</code> attribute of the <code>xs:import</code> element is copied from the <code>schema-location</code> attribute of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration if present, and is absent if it is absent. If there is a contained <code>xs:schema</code> element, the effective value of the <code>schemaLocation</code> attribute is a URI referencing a document containing a copy of the <code>xs:schema</code> element.</p></li><li><p>The base URI of the <code>xs:import</code> element is the same as the base URI of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.</p></li></ul><p>The schema components included in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> of an XPath expression or other construct within a stylesheet (that is, the components whose names are available for use within that construct) depend on the effective schema role for that construct, which is determined by the value of the <code>[xsl:]schema-role</code> attribute of the innermost ancestor element having such an attribute; in the absence of such an attribute, the unnamed schema role applies. The schema components whose names are available are the top-level element and attribute declarations and type definitions that are available for reference within the synthetic schema document for that schema role. See <a href="#xmlschema-1">[XML Schema Part 1]</a> (section 4.2.3, <em>References to schema components across namespaces</em>).</p><p><a id="err-XTSE0220"><span class="error">[ERR XTSE0220] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the synthetic schema document does not satisfy the constraints described in <a href="#xmlschema-1">[XML Schema Part 1]</a> (section 5.1, <em>Errors in Schema Construction and Structure</em>). This includes, without loss of generality, conflicts such as multiple definitions of the same name. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The synthetic schema document does not need to be constructed by a real implementation. It is purely a mechanism for defining the semantics of <a href="#element-import-schema"><code>xsl:import-schema</code></a> in terms of rules that already exist within the XML Schema specification. In particular, it implicitly defines the rules that determine whether the set of <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations are mutually consistent.</p><p>These rules do not cause names to be imported transitively. The fact that a name is available for reference within a schema document <var>A</var> does not of itself make the name available for reference in a stylesheet that imports the target namespace of schema document <var>A</var>. (See <a href="#xmlschema-1">[XML Schema Part 1]</a> section 3.15.3, Constraints on XML Representations of Schemas.) The stylesheet must import all the namespaces containing names that it actually references.</p><p>The <code>namespace</code> attribute indicates that a schema for the given namespace is required by the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. This information may be enough on its own to enable an implementation to locate the required schema components. The <code>namespace</code> attribute may be omitted to indicate that a schema for names in no namespace is being imported. The zero-length string is not a valid namespace URI, and is therefore not a valid value for the <code>namespace</code> attribute.</p><p>The <code>schema-location</code> attribute is a <a title="URI Reference" class="termref" href="#dt-uri-reference">URI Reference</a> that gives a hint indicating where a schema document or other resource containing the required definitions may be found. It is likely that a <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a> will be able to process a schema document found at this location.</p><p>The XML Schema specification gives implementations flexibility in how to handle multiple imports for the same namespace. Multiple imports do not cause errors if the definitions do not conflict.</p><p>A consequence of these rules is that it is not intrinsically an error if no schema document can be located for a namespace identified in an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration. This will cause an error only if it results in the stylesheet containing references to names that have not been imported.</p><p>An inline schema document (using an <code>xs:schema</code> element as a child of the <code>xsl:import-schema</code> element) has the same status as an external schema document, in the sense that it acts as a hint for a source of schema components in the relevant namespace. To ensure that the inline schema document is always used, it is advisable to use a target namespace that is unique to this schema document.</p></div><p>The use of a namespace in an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration does not by itself associate any namespace prefix with the namespace. If names from the namespace are used within the stylesheet module then a namespace declaration must be included in the stylesheet module, in the usual way.</p><div class="example"><div class="exampleHeader"><a id="d4e12655"></a><a id="d4e12547"></a>Example: An Inline Schema Document</div><p>The following example shows an inline schema document. This declares a simple type <code>local:yes-no</code>, which the stylesheet then uses in the declaration of a variable.</p><p>The example assumes the namespace declaration <code>xmlns:local="http://example.com/ns/yes-no"</code></p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:import-schema&gt;
  &lt;xs:schema targetNamespace="http://example.com/ns/yes-no"
             xmlns:xs="http://www.w3.org/2001/XMLSchema"
             xmlns:local="http://example.com/ns/yes-no"&gt;
    &lt;xs:simpleType name="yes-no"&gt;
      &lt;xs:restriction base="xs:string"&gt;
        &lt;xs:enumeration value="yes"/&gt;
        &lt;xs:enumeration value="no"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:schema&gt;
&lt;/xsl:import-schema&gt;

&lt;xsl:variable name="condition" select="local:yes-no('yes')" 
                               as="local:yes-no"/&gt;</pre></div></div><p>There are two built-in functions (<a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-analyze-string"><code>analyze-string</code></a> and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-json-to-xml"><code>json-to-xml</code></a>) whose result is an XML structure for which a schema is defined. The namespace for these schema definitions is (in both cases) <code>http://www.w3.org/2005/xpath-functions</code>. Schema components for these namespaces are available for reference within the stylesheet if and only if an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration is present referencing this namespace. If such a declaration is present, then the schema that is imported is the schema defined in the specification of these functions: the <code>schemaLocation</code> attribute has no effect.</p><div class="_diffs div3"><h4><a id="multiple-schemas"></a><span class="deltaxml-old" style="background:#FF5555">3.14.1</span><span class="deltaxml-new" style="background:#90EE90">3.13.1</span> <a href="#multiple-schemas" style="text-decoration: none">Multiple Schemas</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#unprefixed-qnames">next</a> | <a href="#import-schema">previous</a>)</p><ol><li><p> A stylesheet can import multiple schemas with different schema role names. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/451">451</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1819">1819</a>&nbsp;18 February 2025]</i></p></li></ol></div><p>A stylesheet might perform a transformation from an input document conforming to one schema, to an output document conforming to a different schema. To facilitate this, a schema can be imported with a specific role name, and it is then used only in parts of the stylesheet within the scope of an <code>[xsl:]schema-role</code> attribute specifying this role name. </p><p>More specifically, within the subtree rooted at an element having an <code>[xsl:]schema-role</code> attribute, the static context uses in-scope schema definitions taken from the named schema role.</p><p><a id="err-XTSE4045"><span class="error">[ERR XTSE4045] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of any <code>[xsl:]schema-role</code> in a stylesheet package does not match the value of the <code>role</code> attribute on some <a href="#element-import-schema"><code>xsl:import-schema</code></a> element in the same package.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The introduction of multiple schema roles in XSLT 4.0 enables different input and output documents to be validated against different schemas. For example, a stylesheet might contain the instruction:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:result-document validation="strict" schema-role="output"&gt;
   ...
&lt;/xsl:result-document&gt;</pre></div><p>to control which schema is used to validate the result document. Any instructions used to create validated element nodes in this result document should normally also be within the scope of the same <code>[xsl:]schema-role</code>.</p><p>The fact that multiple schemas can be imported does not relax the requirement that all schemas used in a transformation must be <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible">compatible</a><sup><small>DM</small></sup>. This may mean, for example, that a transformation designed to convert documents from one version of a defined schema to a later version of the same schema may be unable to import both.</p><p>The reason for this restriction is to ensure that stylesheet components (such as functions) using schema components in their type signatures are compatible across the stylesheet as a whole, and that instance documents whose nodes have type annotations resulting from validation against a schema can be checked for conformance with types declared anywhere in the stylesheet.</p><p>It is possible to validate different parts of a constructed document against different schemas. However, validating an element in a document validates the entire subtree rooted at that element, so requesting validation at more than one level may be redundant.</p></div></div></div></div><div class="_diffs div1"><h2><a id="data-model"></a>4 <a href="#data-model" style="text-decoration: none">Data Model</a></h2><p>The data model used by XSLT is the XPath 4.0 and XQuery 4.0 data model (XDM), as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>. XSLT operates on source, result and stylesheet documents using the same data model.</p><p>This section elaborates on some particular features of XDM as it is used by XSLT:</p><p>The rules in <a href="#stylesheet-stripping"><span style="display: none;" class="delete_version"><i>3.12.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span style="display: none;" class="add_version"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.1</span><span class="deltaxml-new" style="background:#90EE90">3.11.1</span> Stripping Whitespace and Commentary from the Stylesheet</i></span></a> and <a href="#strip"><i>4.2.2 Stripping Whitespace from a Source Tree</i></a> make use of the concept of a whitespace text node.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-whitespace-text-node" title="whitespace text node"></a>A <b>whitespace text node</b> is a text node whose content consists entirely of whitespace characters (that is, <span class="unicode-codepoint">U+0009</span> (<span class="unicode-name">TAB</span>) , <span class="unicode-codepoint">U+000A</span> (<span class="unicode-name">NEWLINE</span>) , <span class="unicode-codepoint">U+000D</span> (<span class="unicode-name">CARRIAGE RETURN</span>) , or <span class="unicode-codepoint">U+0020</span> (<span class="unicode-name">SPACE</span>) ).<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>Features of a source XML document that are not represented in the XDM tree will have no effect on the operation of an XSLT stylesheet. Examples of such features are entity references, CDATA sections, character references, whitespace within element tags, and the choice of single or double quotes around attribute values.</p></div></div><div class="_diffs div1"><h2><a id="constructs"></a>5 <a href="#constructs" style="text-decoration: none">Features of the XSLT Language</a></h2><div class="_diffs div2"><h3><a id="static-and-dynamic-context"></a>5.3 <a href="#static-and-dynamic-context" style="text-decoration: none">The Static and Dynamic Context</a></h3><p>XPath defines the concept of an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-expression-context">expression context</a><sup><small>XP</small></sup> which contains all the information that can affect the result of evaluating an <a title="expression" class="termref" href="#dt-expression">expression</a>. The expression context has two parts, the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-context">static context</a><sup><small>XP</small></sup>, and the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamic-context">dynamic context</a><sup><small>XP</small></sup>. The components that make up the expression context are defined in the XPath specification (see <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#context">2.2 Expression Context</a>). This section describes the way in which these components are initialized when an XPath expression is contained within an XSLT stylesheet.</p><p> This section does not apply to <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a> (whose context is defined in <a href="#static-expression"><i>9.7 Static Expressions</i></a>), nor to XPath expressions evaluated using <a href="#element-evaluate"><code>xsl:evaluate</code></a> (whose context is defined in <a href="#evaluate-dynamic-context"><i>10.5.2 Dynamic context for the target expression</i></a>). </p><p>As well as providing values for the static and dynamic context components defined in the XPath specification, XSLT defines additional context components of its own. These context components are used by XSLT instructions (for example, <a href="#element-next-match"><code>xsl:next-match</code></a> and <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>), and also by the functions in the extended function library described in this specification.</p><p>The following four sections describe:</p><blockquote><p><a href="#static-context"><i>5.3.1 Initializing the Static Context</i></a><br><a href="#additional-static-context"><i>5.3.2 Additional Static Context Components used by XSLT</i></a><br><a href="#xpath-dynamic-context"><i>5.3.3 Initializing the Dynamic Context</i></a><br><a href="#additional-dynamic-context"><i>5.3.4 Additional Dynamic Context Components used by XSLT</i></a></p></blockquote><div class="_diffs div3"><h4><a id="static-context"></a>5.3.1 <a href="#static-context" style="text-decoration: none">Initializing the Static Context</a></h4><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-context">static context</a><sup><small>XP</small></sup> of an XPath expression appearing in an XSLT stylesheet is initialized as follows. In these rules, the term <b>containing element</b> means the element within the stylesheet that is the parent of the attribute or text node whose value contains the XPath expression in question, and the term <b>enclosing element</b> means the containing element or any of its ancestors.</p><ul><li><p><a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is set to <code>true</code> if and only if the containing element is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a> (see <a href="#backwards"><i>3.8 Backwards Compatible Processing</i></a>).</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-namespaces">statically known namespaces</a><sup><small>XP</small></sup> are the <span><a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a></span> for the containing element.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-default-namespace-elements-and-types">default namespace for elements and types</a><sup><small>XP</small></sup> is determined as described in <a href="#unprefixed-element-names"><i>5.1.2.1 Unprefixed Element Names</i></a>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-default-function-namespace">default function namespace</a><sup><small>XP</small></sup> is <code>http://www.w3.org/2005/xpath-functions</code> (and cannot be changed).</p></li><li><p><span style="display: none;" class="delete_version">The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-issd">in-scope schema definitions</a><sup><small>XP</small></sup> for the XPath expression are the same as the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> for the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, and are as specified in <a href="#built-in-types"><span class="delete_version"><i>3.13 Built-in Types</i></span><span class="modify_version"><i>3.13 Built-in Types</i></span></a>.</span><span style="display: none;" class="add_version">The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-issd">in-scope schema definitions</a><sup><small>XP</small></sup> for the XPath expression are the same as the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> for the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, and are as specified in <a href="#built-in-types"><span class="add_version"><i>3.12 Built-in Types</i></span><span class="modify_version"><i>3.12 Built-in Types</i></span></a>.</span><span class="modify_version">The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-issd">in-scope schema definitions</a><sup><small>XP</small></sup> for the XPath expression are the same as the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> for the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, and are as specified in <a href="#built-in-types"><span style="display: none;" class="delete_version"><i>3.13 Built-in Types</i></span><span style="display: none;" class="add_version"><i>3.12 Built-in Types</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.13</span><span class="deltaxml-new" style="background:#90EE90">3.12</span> Built-in Types</i></span></a>.</span></p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-in-scope-variables">in-scope variables</a><sup><small>XP</small></sup> are defined by the <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable binding elements</a> that are in scope for the containing element (see <a href="#variables-and-parameters"><i>9 Variables and Parameters</i></a>).</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-statically-known-function-definitions">statically known function definitions</a><sup><small>XP</small></sup> are:</p><ul><li><p>The functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> in namespaces <code>http://www.w3.org/2005/xpath-functions</code> and <code>http://www.w3.org/2005/xpath-functions/math</code>;</p></li><li><p>The functions defined in this specification in namespaces <code>http://www.w3.org/2005/xpath-functions</code> and <code>http://www.w3.org/2005/xpath-functions/map</code>;</p></li><li><p>Constructor functions for all the simple types in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-issd">in-scope schema definitions</a><sup><small>XP</small></sup>, including both built-in types and user-defined types;</p></li><li><p>The <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> defined in the containing <a title="package" class="termref" href="#dt-package">package</a>;</p></li><li><p>Stylesheet functions defined in used packages, subject to visibility: see <a href="#package-dependencies"><i>3.4.2 Dependencies between Packages</i></a>;</p></li><li><p>any <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> bound using <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> mechanisms (see <a href="#extension"><i>24 Extensibility and Fallback</i></a>).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The term <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> includes both vendor-supplied and user-written extension functions.</p></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>It follows from the above that a conformant XSLT processor must implement the entire library of functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> as well as those defined in this specification.</p></div></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-collations">statically known collations</a><sup><small>XP</small></sup> are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, except that they <span class="verb">must</span> always include (a) the Unicode codepoint collation, defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#string-compare">5.3 Comparison of strings</a>, and (b) the family of UCA collations described in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#uca-collations">5.3.4 The Unicode Collation Algorithm</a>.</p></li><li><p><b>Static base URI</b>: In a conventional interpreted environment, the static base URI of an expression in the stylesheet is the base URI of the containing element in the stylesheet. The concept of the base URI of a node is defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-base-uri">7.6.2 base-uri Accessor</a>.</p><p>When stylesheets are executed in an environment where no source code is present (for example, because the code of the stylesheet has been compiled and is distributed as executable object code), it is <span class="verb">recommended</span> (subject to operational constraints such as security) that the static base URI used during stylesheet evaluation should be the location from which the stylesheet was loaded for execution (its “deployed location”). This means, for example, that when the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> or <a href="#func-document"><code>document</code></a> functions are called with a relative URI, the required document is by default located relative to the deployed location of the stylesheet. </p><p>Whether or not the stylesheet is executed directly from source code, it is possible that no static base URI is available, for example because the code was supplied as an anonymous input stream, or because security policies are set to prevent executable code discovering the location from which it was loaded. If the static base URI is not known, the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-static-base-uri"><code>static-base-uri</code></a> function returns an empty sequence, and other operations that depend on the static base URI may fail with a dynamic error.</p></li><li><p>The set of <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-decimal-formats">statically known decimal formats</a><sup><small>XP</small></sup> is the set of decimal formats defined by <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations in the stylesheet. </p></li></ul></div><div class="_diffs div3"><h4><a id="xpath-dynamic-context"></a>5.3.3 <a href="#xpath-dynamic-context" style="text-decoration: none">Initializing the Dynamic Context</a></h4><p>For convenience, the dynamic context is described in two parts: the <a title="focus" class="termref" href="#dt-focus">focus</a>, which represents the place in the source document that is currently being processed, and a collection of additional context variables.</p><p>A number of functions specified in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> are defined to be <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, meaning that if they are called twice during the same <a href="https://qt4cg.org/specifications/xpath-functions-40/#execution-scope">execution scope</a><sup><small>FO</small></sup>, with the same arguments, then they return the same results (see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#terminology">1.9 Terminology</a>). In XSLT, the execution of a stylesheet defines the execution scope. This means, for example, that if the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-current-dateTime"><code>current-dateTime</code></a> is called repeatedly during a transformation, it produces the same result each time. By implication, the components of the dynamic context on which these functions depend are also stable for the duration of the transformation. Specifically, the following components defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#eval_context">2.2.2 Dynamic Context</a> must be stable: <em>function implementations</em>, <em>current dateTime</em>, <em>implicit timezone</em>, <em>available documents</em>, <em>available collections</em>, and <em>default collection</em>. The values of global variables and stylesheet parameters are also stable for the duration of a transformation. The focus is <em>not</em> stable; the additional dynamic context components defined in <a href="#additional-dynamic-context"><i>5.3.4 Additional Dynamic Context Components used by XSLT</i></a> are also <em>not</em> stable.</p><p>As specified in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>, implementations may provide user options that relax the requirement for the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a> functions (and therefore, by implication, the <a href="#func-document"><code>document</code></a> function) to return stable results. By default, however, the functions must be stable. The manner in which such user options are provided, if at all, is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p><span style="display: none;" class="delete_version">XPath expressions contained in <code>[xsl:]use-when</code> attributes are not considered to be evaluated “during the transformation” as defined above. For details see <a href="#conditional-inclusion"><span class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span class="modify_version"><i>3.12.3 Conditional Element Inclusion</i></span></a>.</span><span style="display: none;" class="add_version">XPath expressions contained in <code>[xsl:]use-when</code> attributes are not considered to be evaluated “during the transformation” as defined above. For details see <a href="#conditional-inclusion"><span class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i>3.11.3 Conditional Element Inclusion</i></span></a>.</span><span class="modify_version">XPath expressions contained in <code>[xsl:]use-when</code> attributes are not considered to be evaluated “during the transformation” as defined above. For details see <a href="#conditional-inclusion"><span style="display: none;" class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span style="display: none;" class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.3</span><span class="deltaxml-new" style="background:#90EE90">3.11.3</span> Conditional Element Inclusion</i></span></a>.</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-absent" title="absent"></a>A component of the context that has no value is said to be <b>absent</b>.<span class="definition">]</span> This is a distinguishable state, and is not the same as having the empty sequence as its value.</p></div></div><div class="_diffs div2"><h3><a id="sequence-constructors"></a>5.7 <a href="#sequence-constructors" style="text-decoration: none">Sequence Constructors</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-sequence-constructor" title="sequence constructor"></a>A <b>sequence constructor</b> is a sequence of zero or more sibling nodes in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that can be evaluated to return a sequence of nodes, atomic items, and function items. The way that the resulting sequence is used depends on the containing instruction.<span class="definition">]</span></p><p>Many <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>, and also <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>, are defined to take a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> as their content.</p><p>Four kinds of nodes may be encountered in a sequence constructor:</p><ol class="enumar"><li><p><span style="display: none;" class="delete_version"> A <em>Text node</em> appearing in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (if it has not been removed in the process of whitespace stripping: see <a href="#stylesheet-stripping"><span class="delete_version"><i>3.12.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span class="modify_version"><i>3.12.1 Stripping Whitespace and Commentary from the Stylesheet</i></span></a>) is processed as follows:</span><span style="display: none;" class="add_version"> A <em>Text node</em> appearing in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (if it has not been removed in the process of whitespace stripping: see <a href="#stylesheet-stripping"><span class="add_version"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span class="modify_version"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></span></a>) is processed as follows:</span><span class="modify_version"> A <em>Text node</em> appearing in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (if it has not been removed in the process of whitespace stripping: see <a href="#stylesheet-stripping"><span style="display: none;" class="delete_version"><i>3.12.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span style="display: none;" class="add_version"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.1</span><span class="deltaxml-new" style="background:#90EE90">3.11.1</span> Stripping Whitespace and Commentary from the Stylesheet</i></span></a>) is processed as follows:</span></p><ol class="enumla"><li><p>if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the standard attribute <code>[xsl:]expand-text</code> is <code>no</code>, or in the absence of this attribute, the text node in the stylesheet is copied to create a new parentless text node in the result of the sequence constructor.</p></li><li><p>Otherwise (the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of <code>[xsl:]expand-text</code> is <code>yes</code>), the text node in the stylesheet is processed as described in <a href="#text-value-templates"><i>5.6.2 Text Value Templates</i></a>.</p></li></ol></li><li><p> A <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a> is evaluated to create a new parentless element node, having the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> as the literal result element: see <a href="#literal-result-element"><i>11.1 Literal Result Elements</i></a>. </p></li><li><p>An XSLT <a title="instruction" class="termref" href="#dt-instruction">instruction</a> produces a sequence of zero, one, or more items as its result. For most XSLT instructions, these items are nodes, but some instructions (such as <a href="#element-sequence"><code>xsl:sequence</code></a>, <a href="#element-select"><code>xsl:select</code></a>, <a href="#element-map"><code>xsl:map</code></a>, <a href="#element-array"><code>xsl:array</code></a>, and <a href="#element-copy-of"><code>xsl:copy-of</code></a>) can also produce atomic items or function items.</p><p>Several instructions, such as <a href="#element-element"><code>xsl:element</code></a>, return a newly constructed parentless node (which may have its own attributes, namespaces, children, and other descendants). Other instructions, such as <a href="#element-if"><code>xsl:if</code></a>, pass on the items produced by their own nested sequence constructors.</p><p>Three instructions serve primarily to evaluate XPath expressions:</p><ul><li><p>The <a href="#element-sequence"><code>xsl:sequence</code></a> instruction evaluates an XPath expression written statically in its <code>select</code> attribute.</p></li><li><p>The <a href="#element-select"><code>xsl:select</code></a> instruction evaluates an XPath expression written statically in its contained text node.</p></li><li><p>The <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction compiles and evaluates an XPath expression that is constructed dynamically as a character string.</p></li></ul><p>These three instructions may return atomic items, function items, or nodes.</p></li><li><p> An <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> (see <a href="#extension-instruction"><i>24.3 Extension Instructions</i></a>) also produces a sequence of items as its result.</p></li></ol><p><span class="definition">[Definition:&nbsp;</span><a id="dt-immediate-result" title="immediate result"></a>The result of evaluating a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is the sequence of items formed by concatenating the results of evaluating each of the nodes in the sequence constructor, retaining order. This is referred to as the <b>immediate result</b> of the sequence constructor.<span class="definition">]</span></p><p>However:</p><ul><li><p>For the effect of the <a href="#element-fallback"><code>xsl:fallback</code></a> instruction, see <a href="#fallback"><i>24.3.3 Fallback</i></a>.</p></li><li><p>For the effect of the <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions, see <a href="#conditional-content-construction"><i>8.5 Conditional Content Construction</i></a>.</p></li></ul><p>The way that <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is used depends on the containing element in the stylesheet, and is specified in the rules for that element. It is typically one of the following:</p><ul><li><p>The <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> may be bound to a <a title="variable" class="termref" href="#dt-variable">variable</a> or delivered as the result of a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>. In this case the <code>as</code> attribute of the containing <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-function"><code>xsl:function</code></a> element may be used to declare its required type, and the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> is then converted to the required type by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><ul><li><p>In the absence of an <code>as</code> attribute, the result of a function is the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of the sequence constructor; but the value of a variable (for backwards compatibility reasons) is a document node whose content is formed by applying the rules in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a> to the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a>. </p></li><li><p>The coercion rules do not merge adjacent text nodes or insert separators between adjacent items. This means it is often inappropriate to use <a href="#element-value-of"><code>xsl:value-of</code></a> in the body of <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-function"><code>xsl:function</code></a>, especially when the intent is to return an atomic result. The <a href="#element-sequence"><code>xsl:sequence</code></a> instruction is designed for this purpose, and is usually a better choice. </p></li><li><p>The result of a function, or the value of a variable, may contain nodes (such as elements, attributes, and text nodes) that are not attached to any parent node in a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. The semantics of XPath expressions when applied to parentless nodes are well-defined; however, such expressions should be used with care. For example, the expression <code>/</code> causes a type error if the root of the tree containing the context node is not a document node. </p></li><li><p>Parentless attribute nodes require particular care because they have no namespace nodes associated with them. A parentless attribute node is not permitted to contain namespace-sensitive content (for example, a QName or an XPath expression) because there is no information enabling the prefix to be resolved to a namespace URI. Parentless attributes can be useful in an application (for example, they provide an alternative to the use of attribute sets: see <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a>) but they need to be handled with care.</p></li></ul></div></li><li><p>The sequence may be returned as the result of the containing element. This happens, for example, when the element containing the sequence constructor is <a href="#element-break"><code>xsl:break</code></a>, <a href="#element-catch"><code>xsl:catch</code></a>, <a href="#element-fallback"><code>xsl:fallback</code></a>, <a href="#element-for-each"><code>xsl:for-each</code></a>, <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, <a href="#element-fork"><code>xsl:fork</code></a>, <a href="#element-if"><code>xsl:if</code></a>, <a href="#element-iterate"><code>xsl:iterate</code></a>, <a href="#element-matching-substring"><code>xsl:matching-substring</code></a>, <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>, <a href="#element-on-completion"><code>xsl:on-completion</code></a>, <a href="#element-otherwise"><code>xsl:otherwise</code></a>, <a href="#element-perform-sort"><code>xsl:perform-sort</code></a>, <a href="#element-sequence"><code>xsl:sequence</code></a>, <a href="#element-try"><code>xsl:try</code></a>, or <a href="#element-when"><code>xsl:when</code></a>. </p></li><li><p>The sequence may be used to construct the content of a new element or document node. This happens when the sequence constructor appears as the content of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, or of one of the instructions <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, <a href="#element-assert"><code>xsl:assert</code></a>, or <a href="#element-message"><code>xsl:message</code></a>. It also happens when the sequence constructor is contained in one of the elements <a href="#element-variable"><code>xsl:variable</code></a>, <a href="#element-param"><code>xsl:param</code></a>, or <a href="#element-with-param"><code>xsl:with-param</code></a>, when this instruction has no <code>as</code> attribute. For details, see <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>.</p></li><li><p>The sequence may be used to construct the <a title="string value" class="termref" href="#dt-string-value">string value</a> of an attribute node, text node, namespace node, comment node, or processing instruction node. This happens when the sequence constructor is contained in one of the elements <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-text"><code>xsl:text</code></a>, <a href="#element-value-of"><code>xsl:value-of</code></a>, <a href="#element-namespace"><code>xsl:namespace</code></a>, <a href="#element-comment"><code>xsl:comment</code></a>, or <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>. For details, see <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a>.</p></li></ul></div></div><div class="_diffs div1"><h2><a id="conditionals"></a>8 <a href="#conditionals" style="text-decoration: none">Conditional Processing</a></h2><p>There are several instructions in XSLT that support conditional processing: <a href="#element-if"><code>xsl:if</code></a>, <a href="#element-choose"><code>xsl:choose</code></a><span>, and <a href="#element-switch"><code>xsl:switch</code></a></span>. The <a href="#element-if"><code>xsl:if</code></a> instruction provides simple <span>if-then-else</span> conditionality; the <a href="#element-choose"><code>xsl:choose</code></a> instruction supports selection of one choice when there are several possibilities, <span>and <a href="#element-switch"><code>xsl:switch</code></a> allows a branch to be selected based on the value of a given expression.</span></p><p>XSLT 3.0 also supports <a href="#element-try"><code>xsl:try</code></a> and <a href="#element-catch"><code>xsl:catch</code></a> which define conditional processing to handle <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>XSLT offers a number of ways of expressing conditional logic.</p><p>XSLT 1.0 offered the <a href="#element-if"><code>xsl:if</code></a> instruction for cases where output was to be produced only if a condition was true, with <a href="#element-choose"><code>xsl:choose</code></a> available for multi-way branches where different output was to be produced under different input conditions. In addition, of course, XSLT 1.0 also offered the option of rule-based processing using templates and match patterns.</p><p>XSLT 2.0 added the XPath conditional expression providing two-way branches for use at a finer-grained level where <a href="#element-choose"><code>xsl:choose</code></a> could be excessively verbose: it allowed constructs such as <code>&lt;xsl:value-of select="if ($x) then 'red' else 'green'/&gt;</code> to be reduced from eight lines of code to one.</p><p>XSLT 4.0 introduces the <code>then</code> and <code>else</code> attributes for <a href="#element-if"><code>xsl:if</code></a>, which are particularly useful in contexts such as the body of an <a href="#element-function"><code>xsl:function</code></a> declaration where the alternative results are conveniently evaluated using XPath expressions rather than XSLT instructions: for example a recursive function might have as its body the instruction <code>&lt;xsl:if test="empty($seq)" then="1" else="head($seq) * my:f(tail($seq))"/&gt;</code>. The <code>select</code> attribute of <a href="#element-when"><code>xsl:when</code></a> and <a href="#element-otherwise"><code>xsl:otherwise</code></a> is introduced for similar reasons: XSLT instructions are most useful when contructing node trees, whereas XPath expressions are more convenient when computing atomic items. Again, the main contribution of these enhancements is to reduce visual clutter, making the code more concise and more easily readable.</p><p>The <a href="#element-switch"><code>xsl:switch</code></a> instruction is introduced in XSLT 4.0 as an alternative to <a href="#element-choose"><code>xsl:choose</code></a> for the common use case where the conditions test for multiple different values of some common expression. By avoiding repetition of the common expression whose value is being tested, the logic becomes self-explanatory both to the human reader of the code and to an optimizing compiler, making it easier to generate efficient branching code.</p></div><div class="_diffs div2"><h3><a id="conditional-content-construction"></a>8.5 <a href="#conditional-content-construction" style="text-decoration: none">Conditional Content Construction</a></h3><p>The facilities described in this section are designed to make it easier to generate result trees conditionally depending on what is found in the input, without violating the rules for streamability. Although these facilities were introduced to the language specifically to make streaming easier, they are available whether or not streaming is in use, and users have often found them convenient in non-streaming applications.</p><p>The facilities are introduced first by example:</p><div class="example"><div class="exampleHeader"><a id="d4e26770"></a><a id="d4e26662"></a>Example: Generating a Wrapper Element for a non-Empty Sequence</div><p>The following example generates an <code>events</code> element if and only if there are one or more <code>event</code> elements. The code could be written like this:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:if test="exists(event)"&gt;
  &lt;events&gt;
    &lt;xsl:copy-of select="event"/&gt;
  &lt;/events&gt;
&lt;/xsl:if&gt;</pre></div><p>However, the above code would not be <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-guaranteed-streamable">guaranteed-streamable</a><sup><small>SG</small></sup>, because it processes the child <code>event</code> elements more than once. To make it streamable, it can be rewritten as:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:where-populated&gt;
  &lt;events&gt;
    &lt;xsl:copy-of select="event"/&gt;
  &lt;/events&gt;
&lt;/xsl:where-populated&gt;</pre></div><p>The effect of the <a href="#element-where-populated"><code>xsl:where-populated</code></a> instruction, as explained later, is to avoid outputting the <code>events</code> element if it would have no children. A streaming implementation will typically hold the start tag of the <code>events</code> element in a buffer, to be sent to the output destination only if and when a child node is generated.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e26801"></a><a id="d4e26693"></a>Example: Generating a Header and Footer only if there is Content</div><p>The following example generates an <code>h3</code> element and a summary paragraph only if a list of items is non-empty. The code could be written like this:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:if test="exists(item-for-sale)"&gt;
  &lt;h1&gt;Items for Sale&lt;/h1&gt;
&lt;/xsl:if&gt;  
&lt;xsl:apply-templates select="item-for-sale"/&gt;
&lt;xsl:if test="exists(item-for-sale)"&gt;
  &lt;p&gt;Total value: {accumulator-before('total-value')}&lt;/p&gt;
&lt;/xsl:if&gt;</pre></div><p>However, the above code would not be <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-guaranteed-streamable">guaranteed-streamable</a><sup><small>SG</small></sup>, because it processes the child <code>item-for-sale</code> elements more than once. To make it streamable, it can be rewritten as:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:sequence&gt;
  &lt;xsl:on-non-empty&gt;
    &lt;h1&gt;Items for Sale&lt;/h1&gt;
  &lt;/xsl:on-non-empty&gt;  
  &lt;xsl:apply-templates select="item-for-sale"/&gt;
  &lt;xsl:on-non-empty&gt;
    &lt;p&gt;Total value: {accumulator-before('total-value')}&lt;/p&gt;
  &lt;/xsl:on-non-empty&gt;  
&lt;/xsl:sequence&gt;</pre></div><p>The effect of the <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction, as explained later, is to output the enclosed content only if the containing sequence constructor also generates “ordinary” content, that is, if there is content generated by instructions other than <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e26827"></a><a id="d4e26719"></a>Example: Generating Substitute Text when there is no Content</div><p>The following example generates a summary paragraph only if a list of items is empty. The code could be written like this:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:apply-templates select="item-for-sale"/&gt;
&lt;xsl:if test="empty(item-for-sale)"&gt;
  &lt;p&gt;There are no items for sale.&lt;/p&gt;
&lt;/xsl:if&gt;</pre></div><p>However, the above code would not be <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-guaranteed-streamable">guaranteed-streamable</a><sup><small>SG</small></sup>, because it processes the child <code>item-for-sale</code> elements more than once (the fact that the list is empty is irrelevant, because streamability is determined statically). To make the code streamable, it can be rewritten as:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:sequence&gt;
  &lt;xsl:apply-templates select="item-for-sale"/&gt;
  &lt;xsl:on-empty&gt;
    &lt;p&gt;There are no items for sale.&lt;/p&gt;
  &lt;/xsl:on-empty&gt;
&lt;/xsl:sequence&gt;</pre></div><p>The effect of the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction, as explained later, is to output the enclosed content only if the containing sequence constructor generates no “ordinary” content, that is, if there is no content generated by instructions other than <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions.</p></div><p>For further examples showing the use of these instructions when streaming, see <a href="../xslt-streaming-40/#handling-empty-input">7 Handling Empty Input</a><sup><small>SG</small></sup>.</p><div class="_diffs div3"><h4><a id="on-empty"></a>8.5.2 <a href="#on-empty" style="text-decoration: none">The <code>xsl:on-empty</code> instruction</a></h4><p class="element-syntax"><a id="element-on-empty"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:on-empty<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:on-empty&gt;</code></p><p>The <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction has the same content model as <a href="#element-sequence"><code>xsl:sequence</code></a>, and when it is evaluated, the same rules apply. In particular, the <code>select</code> attribute and the contained sequence constructor are mutually exclusive <span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span>.</p><p>When an <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction appears in a sequence constructor, then:</p><ol class="enumar"><li><p>It must be the only <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction in the sequence constructor, and</p></li><li><p>It must not be followed in the sequence constructor by any other <a title="instruction" class="termref" href="#dt-instruction">instruction</a>, other than <a href="#element-fallback"><code>xsl:fallback</code></a>, or by a significant text node (that is, a text node that has not been discarded under the provisions of <a href="#stylesheet-stripping"><span style="display: none;" class="delete_version"><i>3.12.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span style="display: none;" class="add_version"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.1</span><span class="deltaxml-new" style="background:#90EE90">3.11.1</span> Stripping Whitespace and Commentary from the Stylesheet</i></span></a>), or by a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>. It may, however, be followed by non-instructions such as <a href="#element-catch"><code>xsl:catch</code></a> where appropriate.</p></li></ol><p><span class="definition">[Definition:&nbsp;</span><a id="dt-vacuous" title="vacuous"></a>An item is <b>vacuous</b> if it is one of the following: a zero-length text node; a document node with no children; an atomic item which, on casting to <code>xs:string</code>, produces a zero-length string; or an array which on flattening using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-flatten"><code>array:flatten</code></a> function produces either an empty sequence or a sequence consisting entirely of <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items.<span class="definition">]</span></p><p>An <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction is triggered only if every preceding sibling instruction, text node, and literal result element in the same <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> returns either an empty sequence, or a sequence consisting entirely of <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items. </p><p>If an <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction is triggered, then the result of the containing <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is the result of the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that the (vacuous) results produced by other instructions in the sequence constructor are discarded. This is relevant mainly when the result of the sequence constructor is used for something other than constructing a node: for example if it forms the result of a function, or the value of a variable, and the function or variable specifies a required type.</p><p>When streaming, it may be necessary to buffer vacuous items in the result sequence until it is known whether the result will contain items that are non-vacuous. In many common situations, however — in particular, when the sequence constructor is being used to create the content of a node — vacuous items can be discarded immediately because they do not affect the content of the node being constructed. </p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In nearly all cases, the rules for <a href="#element-on-empty"><code>xsl:on-empty</code></a> are aligned with the rules for constructing complex content. If the sequence constructor within a literal result element or an <a href="#element-element"><code>xsl:element</code></a> instruction includes an <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction, then the content of the element will be the value delivered by the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction if and only if the content would otherwise be empty.</p><p>There is one minor exception to this rule: if the sequence constructor delivers multiple zero-length strings, then in the absence of the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction the new element would contain whitespace, made up of the separators between these zero-length strings; but <a href="#element-on-empty"><code>xsl:on-empty</code></a> takes no account of these separators.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Attribute and namespace nodes created by the sequence constructor are significant; the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction will not be triggered if such nodes are present. If this is not the desired effect, it is possible to partition the sequence constructor to change the scope of <a href="#element-on-empty"><code>xsl:on-empty</code></a>, for example:</p><div class="exampleInner"><pre xml:space="preserve">&lt;ol&gt;
  &lt;xsl:attribute name="class" select="numbered-list"/&gt;
  &lt;xsl:sequence&gt;
    &lt;xsl:value-of select="xyz"/&gt;
    &lt;xsl:on-empty select="'The list is empty'"/&gt;
  &lt;/xsl:sequence&gt;
&lt;/ol&gt;</pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Where the sequence constructor is a child of an instruction with an <code>[xsl:]use-attribute-sets</code> attribute, any attribute nodes created by expanding the referenced attribute set(s) are not part of the result of the sequence constructor and therefore play no role in determining whether an <a href="#element-on-empty"><code>xsl:on-empty</code></a> or <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction is triggered. Equally, when the sequence constructor is a child of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, attribute nodes generated by expanding the attributes of the literal result element are not taken into account.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>If <a href="#element-on-empty"><code>xsl:on-empty</code></a> is the only instruction in a sequence constructor then it is always evaluated.</p><p>If <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> appear in the same sequence constructor, then the rules ensure that only one of them will be evaluated.</p></div></div></div></div><div class="_diffs div1"><h2><a id="variables-and-parameters"></a>9 <a href="#variables-and-parameters" style="text-decoration: none">Variables and Parameters</a></h2><p><span class="definition">[Definition:&nbsp;</span><a id="dt-variable-binding-element" title="variable-binding element"></a>The two elements <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> are referred to as <b>variable-binding elements</b>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-variable" title="variable"></a>The <a href="#element-variable"><code>xsl:variable</code></a> element declares a <b>variable</b>, which may be a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> or a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-parameter" title="parameter"></a>The <a href="#element-param"><code>xsl:param</code></a> element declares a <b>parameter</b>, which may be a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a>, a <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a>, a <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a>, or an <a href="#element-iterate"><code>xsl:iterate</code></a> parameter. A parameter is a <a title="variable" class="termref" href="#dt-variable">variable</a> with the additional property that its value can be set by the caller.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-value" title="value"></a>A variable is a binding between a name and a value. The <b>value</b> of a variable is any sequence (of nodes, atomic items, and/or function items), as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>.<span class="definition">]</span></p><div class="_diffs div2"><h3><a id="static-expression"></a>9.7 <a href="#static-expression" style="text-decoration: none">Static Expressions</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-static-expression" title="static expression"></a>A <b>static expression</b> is an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> whose value must be computed during static analysis of the stylesheet.<span class="definition">]</span></p><p>Static expressions appear in a number of contexts, in particular:</p><ul><li><p><span style="display: none;" class="delete_version">In <code>[xsl:]use-when</code> attributes (see <a href="#conditional-inclusion"><span class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span class="modify_version"><i>3.12.3 Conditional Element Inclusion</i></span></a>);</span><span style="display: none;" class="add_version">In <code>[xsl:]use-when</code> attributes (see <a href="#conditional-inclusion"><span class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i>3.11.3 Conditional Element Inclusion</i></span></a>);</span><span class="modify_version">In <code>[xsl:]use-when</code> attributes (see <a href="#conditional-inclusion"><span style="display: none;" class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span style="display: none;" class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.3</span><span class="deltaxml-new" style="background:#90EE90">3.11.3</span> Conditional Element Inclusion</i></span></a>);</span></p></li><li><p>In the <code>select</code> attribute of <a title="static variable" class="termref" href="#dt-static-variable">static variable</a> declarations (<a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> with <code>static="yes"</code>);</p></li><li><p>In shadow attributes (see <a href="#shadow-attributes"><span style="display: none;" class="delete_version"><i>3.12.4 Shadow Attributes</i></span><span style="display: none;" class="add_version"><i>3.11.4 Shadow Attributes</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.4</span><span class="deltaxml-new" style="background:#90EE90">3.11.4</span> Shadow Attributes</i></span></a>).</p></li></ul><p>There are no syntactic constraints on the XPath expression that can be used as a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>. However, there are severe constraints on the information provided in its evaluation context. These constraints are designed to ensure that the expression can be evaluated at the earliest possible stage of stylesheet processing, without any dependency on information contained in the stylesheet itself or in any source document.</p><p>Specifically, the components of the static and dynamic context are defined by the following two tables:</p><table class="def"><caption>Static Context Components for Static Expressions</caption><thead><tr><th style="text-align:left; vertical-align:top">Component</th><th style="text-align:left; vertical-align:top">Value</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top">XPath 1.0 compatibility mode</td><td style="text-align:left; vertical-align:top">false</td></tr><tr><td style="text-align:left; vertical-align:top">Statically known namespaces</td><td style="text-align:left; vertical-align:top">the <span><a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a></span> for the containing element in the stylesheet</td></tr><tr><td style="text-align:left; vertical-align:top">Default namespace for elements and types</td><td style="text-align:left; vertical-align:top">determined by the <code>xpath-default-namespace</code> attribute if present (see <a href="#unprefixed-qnames"><i>5.1.2 Unprefixed Lexical QNames in Expressions and Patterns</i></a>); otherwise absent</td></tr><tr><td style="text-align:left; vertical-align:top">Default function namespace</td><td style="text-align:left; vertical-align:top">the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a>. </td></tr><tr><td style="text-align:left; vertical-align:top">In-scope schema types</td><td style="text-align:left; vertical-align:top">The type definitions that would be available in the absence of any <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration</td></tr><tr><td style="text-align:left; vertical-align:top">In-scope element declarations</td><td style="text-align:left; vertical-align:top">None</td></tr><tr><td style="text-align:left; vertical-align:top">In-scope attribute declarations</td><td style="text-align:left; vertical-align:top">None</td></tr><tr><td style="text-align:left; vertical-align:top">In-scope variables</td><td style="text-align:left; vertical-align:top">The <a title="static variable" class="termref" href="#dt-static-variable">static variables</a> visible within the containing package whose declarations occur prior to the element containing the static expression in stylesheet tree order. Stylesheet tree order is the order that results when all <a href="#element-import"><code>xsl:import</code></a> and <a href="#element-include"><code>xsl:include</code></a> declarations are replaced by the declarations in the imported or included stylesheet module. A static variable is not in scope within its own declaration, and it is in scope only within its declaring package, not in any using packages. If two static variables satisfying this rule have the same name and are both in scope, the one that appears most recently in stylesheet tree order is used; as a consequence of rules defined elsewhere this will always be consistent with the declaration having highest import precedence.</td></tr><tr><td style="text-align:left; vertical-align:top">Context item static type</td><td style="text-align:left; vertical-align:top"><a title="absent" class="termref" href="#dt-absent">Absent</a></td></tr><tr><td style="text-align:left; vertical-align:top">In-scope named item types</td><td style="text-align:left; vertical-align:top">None</td></tr><tr><td style="text-align:left; vertical-align:top">Statically known function definitions</td><td style="text-align:left; vertical-align:top">The functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> in the <code>fn</code><code>math</code>, <span><code>map</code>, and <code>array</code></span> namespaces, together with: <ol class="enumar"><li><p>the functions <a href="#func-element-available"><code>element-available</code></a>, <a href="#func-function-available"><code>function-available</code></a>, <a href="#func-type-available"><code>type-available</code></a>, <a href="#func-available-system-properties"><code>available-system-properties</code></a>, and <a href="#func-system-property"><code>system-property</code></a> defined in this specification;</p></li><li><p>functions that appear in both this specification and in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> (for example, the functions in the <code>map</code> namespaces, and a few others such as <code>collation-key</code> and <code>json-to-xml</code>);</p></li><li><p>constructor functions for built-in types;</p></li><li><p>the set of extension functions that are present in the static context of every XPath expression (other than a static expression) within the content of the element that contains the static expression. </p></li></ol> Note that <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> are <em>not</em> included in the context, which means that the function <a href="#func-function-available"><code>function-available</code></a> will return <code>false</code> in respect of such functions, and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a> will fail to find them. The effect of this rule is to ensure that <a href="#func-function-available"><code>function-available</code></a> returns <code>true</code> in respect of functions that can be called within the static expression. It also has the effect that these extension functions will be recognized within the static expression itself; however, the fact that a function is available in this sense gives no guarantee that a call on the function will succeed.</td></tr><tr><td style="text-align:left; vertical-align:top">Statically known collations</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Default collation</td><td style="text-align:left; vertical-align:top">The Unicode Codepoint Collation</td></tr><tr><td style="text-align:left; vertical-align:top">Static Base URI</td><td style="text-align:left; vertical-align:top">The base URI of the containing element in the stylesheet document (see <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-base-uri">7.6.2 base-uri Accessor</a>)</td></tr><tr><td style="text-align:left; vertical-align:top">Statically known documents</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Statically known collections</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Statically known default collection type</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Statically known decimal formats</td><td style="text-align:left; vertical-align:top">A single unnamed <a title="decimal format" class="termref" href="#dt-decimal-format">decimal format</a> equivalent to the decimal format that is created by an <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration with no attributes.</td></tr></tbody></table><p>&nbsp;</p><table class="def"><caption>Dynamic Context Components for Static Expressions</caption><thead><tr><th style="text-align:left; vertical-align:top">Component</th><th style="text-align:left; vertical-align:top">Value</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top">Context item, position, and size</td><td style="text-align:left; vertical-align:top"><a title="absent" class="termref" href="#dt-absent">Absent</a></td></tr><tr><td style="text-align:left; vertical-align:top">Variable values</td><td style="text-align:left; vertical-align:top">A value for every variable present in the in-scope variables. For <a title="static parameter" class="termref" href="#dt-static-parameter">static parameters</a> where an external value is supplied: the externally supplied value of the parameter. In all other cases: the value of the variable as defined in <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>.</td></tr><tr><td style="text-align:left; vertical-align:top">Dynamically known function definitions</td><td style="text-align:left; vertical-align:top">The same as the statically known function definitions</td></tr><tr><td style="text-align:left; vertical-align:top">Current dateTime</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Implicit timezone</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Executable Base URI</td><td style="text-align:left; vertical-align:top">The same as the Static Base URI</td></tr><tr><td style="text-align:left; vertical-align:top">Default collation</td><td style="text-align:left; vertical-align:top">The Unicode Codepoint Collation</td></tr><tr><td style="text-align:left; vertical-align:top">Default language</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Default calendar</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Default place</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Available documents</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Available text resources</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Available collections</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Default collection</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Available URI collections</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Default URI collection</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Environment variables</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr></tbody></table><p>Within a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>, all static expressions are evaluated in a single <a href="https://qt4cg.org/specifications/xpath-functions-40/#execution-scope">execution scope</a><sup><small>FO</small></sup>. This need not be the same execution scope as that used for static expressions in other stylesheet modules, or as that used when evaluating XPath expressions appearing elsewhere in the stylesheet module. This means that a function such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-current-date"><code>current-date</code></a> will return the same result when called in different <code>[xsl:]use-when</code> expressions within the same stylesheet module, but will not necessarily return the same result as the same call in an <code>[xsl:]use-when</code> expression within a different stylesheet module, or as a call on the same function executed during the transformation proper.</p><p>If a <a title="static error" class="termref" href="#dt-static-error">static error</a> is present in a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>, it is treated in the same way as any other static error in the stylesheet module. If a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs during evaluation of a static expression, it is treated as a static error in the analysis of the stylesheet, while retaining its original error code.</p></div></div><div class="_diffs div1"><h2><a id="callable-components"></a>10 <a href="#callable-components" style="text-decoration: none">Callable Components</a></h2><p>This section describes three constructs that can be used to provide subroutine-like functionality that can be invoked from anywhere in the stylesheet: named templates (see <a href="#named-templates"><i>10.1 Named Templates</i></a>), named attribute sets (see <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a>), and <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> (see <a href="#stylesheet-functions"><i>10.3 Stylesheet Functions</i></a>).</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-invocation-construct" title="invocation construct"></a>The following constructs are classified as <b>invocation constructs</b>: the instructions <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, and <a href="#element-next-match"><code>xsl:next-match</code></a>; XPath function calls that bind to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>; XPath dynamic function calls; the functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a>; the <code>[xsl:]use-attribute-sets</code> attribute. These all have the characteristic that they can cause evaluation of constructs that are not lexically contained within the calling construct.<span class="definition">]</span></p><div class="_diffs div2"><h3><a id="dynamic-xpath"></a>10.5 <a href="#dynamic-xpath" style="text-decoration: none">Dynamic XPath Evaluation</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#creating-text-nodes">next</a> | <a href="#select-instruction">previous</a>)</p><ol><li><p> A new attribute <code>trusted=yes|no</code> is added to <a href="#element-evaluate"><code>xsl:evaluate</code></a> to indicate whether the XPath expression to be evaluated is trusted to access external resources. The default value is <code>no</code>, which may cause backwards incompatibility. Dynamic evaluation using <a href="#element-evaluate"><code>xsl:evaluate</code></a> is no longer an optional feature of the XSLT language. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2047">2047</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2213">2213</a>&nbsp;23 October 2025]</i></p></li></ol></div><p class="element-syntax"><a id="element-evaluate"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:evaluate<br>&nbsp;&nbsp;<b>xpath</b> = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕<br>&nbsp;&nbsp;base-uri? = { <var>uri</var> }<br>&nbsp;&nbsp;with-params? = <var>expression</var><br>&nbsp;&nbsp;context-item? = <var>expression</var><br>&nbsp;&nbsp;namespace-context? = <var>expression</var><br>&nbsp;&nbsp;schema-aware? = { <var>boolean</var> }〔'no'〕<br>&nbsp;&nbsp;trusted? = { <var>boolean</var> }〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-with-param">xsl:with-param</a> | <a href="#element-fallback">xsl:fallback</a>)* --&gt;<br>&lt;/xsl:evaluate&gt;</code></p><p>The <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction constructs an XPath expression in the form of a string, evaluates the expression in a specified context, and returns the result of the evaluation.</p><p>The expression given as the value of the <code>xpath</code> attribute is evaluated and the result is converted to a string using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-target-expression" title="target expression"></a>The string that results from evaluating the expression in the <code>xpath</code> attribute is referred to as the <b>target expression</b>.<span class="definition">]</span></p><p><a id="err-XTDE3160"><span class="error">[ERR XTDE3160] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="target expression" class="termref" href="#dt-target-expression">target expression</a> is not a valid <a title="expression" class="termref" href="#dt-expression">expression</a> (that is, if a static error occurs when analyzing the string according to the rules of the XPath specification).</p><p>The <code>as</code> attribute, if present, indicates the required type of the result. If the attribute is absent, the required type is <code>item()*</code>, which allows any result. The result of evaluating the <a title="target expression" class="termref" href="#dt-target-expression">target expression</a> is converted to the required type using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. This may cause a <a title="type error" class="termref" href="#dt-type-error">type error</a> if conversion is not possible. The result after conversion is returned as the result of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction.</p><p>The target expression may contain variable references; the values of such variables may be supplied using an <a href="#element-with-param"><code>xsl:with-param</code></a> child instruction if the names of the variables are known statically, or using a map supplied as the value of the expression in the <code>with-params</code> attribute if the names are only known dynamically. If the <code>with-params</code> attribute is present then it must contain an expression whose value, when evaluated, is of type <code>map(xs:QName, item()*)</code> (see <a href="#map"><i>21 Maps</i></a> for details of maps).</p><p><a id="err-XTTE3165"><span class="error">[ERR XTTE3165] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the expression in the <code>with-params</code> attribute of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is anything other than a single map of type <code>map(xs:QName, item()*)</code>. </p><div class="_diffs div3"><h4><a id="evaluate-static-context"></a>10.5.1 <a href="#evaluate-static-context" style="text-decoration: none">Static context for the target expression</a></h4><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-context">static context</a><sup><small>XP</small></sup> for the <a title="target expression" class="termref" href="#dt-target-expression">target expression</a> is as follows:</p><ul><li><p>XPath 1.0 compatibility mode is <code>false</code>.</p></li><li><p>Trust level: the <a href="../xquery-40/xpath-40.html#">trust level</a><sup><small>XP</small></sup> of the target expression is determined by the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>trusted</code> attribute. If the value is <code>yes</code>, the target expression has the same level of trust, and may therefore access the same external resources, as the calling stylesheet. If the value is <code>no</code>, the target expression has no access to external resources, other than any resources made explicitly available via some secure <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> mechanism.</p></li><li><p>Statically known namespaces and default namespaces for elements and for types:</p><ul><li><p>if the <code>namespace-context</code> attribute is present, then its value is an <a title="expression" class="termref" href="#dt-expression">expression</a> whose required type is a single node. The expression is evaluated, and the in-scope namespaces of the resulting node are used as the statically known namespaces for the target expression. The binding for the default namespace in the in-scope namespaces is used as the default namespace for <span>both</span> elements and types in the target expression.</p><p><a id="err-XTTE3170"><span class="error">[ERR XTTE3170] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>namespace-context</code> attribute of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is anything other than a single node. </p></li><li><p>if the <code>namespace-context</code> attribute is absent, then the <span><a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a></span> of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction (with the exception of any binding for the default namespace) are used as the statically known namespaces for the target expression, and the value of the attribute <code>[xsl:]xpath-default-namespace</code>, if present, is used to establish the default namespace for elements and types in the target expression, as described in <a href="#unprefixed-qnames"><i>5.1.2 Unprefixed Lexical QNames in Expressions and Patterns</i></a>.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>XPath 3.0 allows expanded names to be written in a context-independent way using the syntax <code>Q{namespace-uri}local-name</code></p></div></li><li><p>Default function namespace: the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a>.</p></li><li><p><span style="display: none;" class="delete_version">In-scope schema definitions: if the <code>schema-aware</code> attribute is present and has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>yes</code>, then the in-scope schema definitions from the stylesheet context of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction (that is, the schema definitions imported using <a href="#element-import-schema"><code>xsl:import-schema</code></a>, taking into account any <code>[xsl:]schema-role</code> on the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction or on any of its ancestors). Otherwise, the built-in types (see <a href="#built-in-types"><span class="delete_version"><i>3.13 Built-in Types</i></span><span class="modify_version"><i>3.13 Built-in Types</i></span></a>).</span><span style="display: none;" class="add_version">In-scope schema definitions: if the <code>schema-aware</code> attribute is present and has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>yes</code>, then the in-scope schema definitions from the stylesheet context of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction (that is, the schema definitions imported using <a href="#element-import-schema"><code>xsl:import-schema</code></a>, taking into account any <code>[xsl:]schema-role</code> on the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction or on any of its ancestors). Otherwise, the built-in types (see <a href="#built-in-types"><span class="add_version"><i>3.12 Built-in Types</i></span><span class="modify_version"><i>3.12 Built-in Types</i></span></a>).</span><span class="modify_version">In-scope schema definitions: if the <code>schema-aware</code> attribute is present and has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>yes</code>, then the in-scope schema definitions from the stylesheet context of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction (that is, the schema definitions imported using <a href="#element-import-schema"><code>xsl:import-schema</code></a>, taking into account any <code>[xsl:]schema-role</code> on the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction or on any of its ancestors). Otherwise, the built-in types (see <a href="#built-in-types"><span style="display: none;" class="delete_version"><i>3.13 Built-in Types</i></span><span style="display: none;" class="add_version"><i>3.12 Built-in Types</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.13</span><span class="deltaxml-new" style="background:#90EE90">3.12</span> Built-in Types</i></span></a>).</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>If the containing stylesheet does not import a schema, then the in-scope schema definitions for the target expression will contain only the built-in schema types, regardless of the value of the <code>schema-aware</code> attribute.</p></div></li><li><p>In-scope variables: the names of the in-scope variables are the union of the names appearing in the <code>name</code> attribute of the contained <a href="#element-with-param"><code>xsl:with-param</code></a> elements, and the names present as keys in the map obtained by evaluating the <code>with-params</code> attribute, if present. The corresponding type is <code>item()*</code> in the case of a name found as a key in the <code>with-params</code> map, or the type named in the <code>as</code> attribute of <a href="#element-with-param"><code>xsl:with-param</code></a> child (defaulting to <code>item()*</code>) otherwise.</p><p>If a variable name is present both the static <a href="#element-with-param"><code>xsl:with-param</code></a> children and also in the dynamic <code>with-params</code> map, the value from the latter takes precedence.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Variables declared in the stylesheet in <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> elements are <em>not</em> in-scope within the target expression.</p></div></li><li><p>Function signatures:</p><ul><li><p>All functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> in the <code>fn</code>, <code>math</code>, <code>map</code>, and <code>array</code> namespaces;</p></li><li><p>Constructor functions for named simple types included in the in-scope schema definitions;</p></li><li><p>All user-defined functions present in the containing package provided their visibility is not <code>hidden</code> or <code>private</code>;</p></li><li><p>An <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> set of <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a>.</p></li></ul><p>Note that this set deliberately excludes XSLT-defined functions in the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a> including for example, <a href="#func-key"><code>key</code></a>, <a href="#func-current-group"><code>current-group</code></a>, and <a href="#func-system-property"><code>system-property</code></a>. A list of these functions is in <a href="#XSLT-defined-functions"><i>G.2 List of XSLT-defined functions</i></a>.</p></li><li><p>Statically known collations: the same as the collations available at this point in the stylesheet.</p></li><li><p>Default collation: the same as the default collation defined at this point in the stylesheet (for example, by use of the <code>[xsl:]default-collation</code> attribute)</p></li><li><p>Base URI: if the <code>base-uri</code> attribute is present, then its <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>; otherwise, the base URI of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction.</p></li></ul></div></div></div><div class="_diffs div1"><h2><a id="creating-new-nodes"></a>11 <a href="#creating-new-nodes" style="text-decoration: none">Creating Nodes</a></h2><p>This section describes instructions that directly create new nodes.</p><div class="_diffs div2"><h3><a id="creating-text-nodes"></a>11.4 <a href="#creating-text-nodes" style="text-decoration: none">Creating Text Nodes</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#xsl-text">next</a> | <a href="#dynamic-xpath">previous</a>)</p><ol><li><p> The <a href="#element-text"><code>xsl:text</code></a> instruction can now have a <code>select</code> attribute, and it can take a sequence constructor as its content. The only remaining distinction between the <a href="#element-text"><code>xsl:text</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a> instructions is that whitespace text node children of <a href="#element-text"><code>xsl:text</code></a> are treated as significant, rather than being stripped during stylesheet preprocessing. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/323">323</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2251">2251</a>&nbsp;14 October 2025]</i></p></li></ol></div><p>This section describes three different ways of creating text nodes: by means of literal text nodes in the stylesheet, or by using the <a href="#element-text"><code>xsl:text</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a> instructions. It is also possible to create text nodes using the <a href="#element-number"><code>xsl:number</code></a> instruction described in <a href="#number"><i>12 Numbering</i></a>.</p><p>If and when the sequence that results from evaluating a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is used to form the content of a node, as described in <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a> and <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>, adjacent text nodes in the sequence are merged. Within the sequence itself, however, they exist as distinct nodes.</p><div class="example"><div class="exampleHeader"><a id="d4e35156"></a><a id="d4e35048"></a>Example: A Sequence of Text Nodes</div><p>The following function returns a sequence of three text nodes:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:function name="f:wrap"&gt;
  &lt;xsl:param name="s"/&gt;
  &lt;xsl:text&gt;(&lt;/xsl:text&gt;
  &lt;xsl:value-of select="$s"/&gt;
  &lt;xsl:text&gt;)&lt;/xsl:text&gt;
&lt;/xsl:function&gt;</pre></div><p>When this function is called as follows:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:value-of select="f:wrap('---')"/&gt;</pre></div><p>the result is:</p><div class="exampleInner"><pre xml:space="preserve">(---)</pre></div><p>No additional spaces are inserted, because the calling <a href="#element-value-of"><code>xsl:value-of</code></a> instruction merges adjacent text nodes before atomizing the sequence. However, the result of the instruction:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:value-of select="data(f:wrap('---'))"/&gt;</pre></div><p>is:</p><div class="exampleInner"><pre xml:space="preserve">( --- )</pre></div><p>because in this case the three text nodes are atomized to form three strings, and spaces are inserted between adjacent strings.</p><p>This example reflects the traditional usage of <a href="#element-text"><code>xsl:text</code></a> to output constant text and <a href="#element-value-of"><code>xsl:value-of</code></a> to output variable text. In XSLT 4.0, however, either instruction can be used for either purpose, and in the example above either instruction could be replaced by the other.</p></div><p>It is possible to construct text nodes whose string value is zero-length. A zero-length text node, when atomized, produces a zero-length string. However, zero-length text nodes are ignored when they appear in a sequence that is used to form the content of a node, as described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a> and <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a>.</p><div class="_diffs div3"><h4><a id="literal-text-nodes"></a>11.4.1 <a href="#literal-text-nodes" style="text-decoration: none">Literal Text Nodes</a></h4><p>A <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> can contain text nodes. Each text node in a sequence constructor remaining after <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> have been stripped as specified in <a href="#stylesheet-stripping"><span style="display: none;" class="delete_version"><i>3.12.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span style="display: none;" class="add_version"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.1</span><span class="deltaxml-new" style="background:#90EE90">3.11.1</span> Stripping Whitespace and Commentary from the Stylesheet</i></span></a> will construct a new text node with the same <a title="string value" class="termref" href="#dt-string-value">string value</a>. The resulting text node is added to the result of the containing sequence constructor.</p><p>Text is processed at the tree level. Thus, markup of <code>&amp;lt;</code> in a template will be represented in the stylesheet tree by a text node that includes the character <code>&lt;</code>. This will create a text node in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> that contains a <code>&lt;</code> character, which will be represented by the markup <code>&amp;lt;</code> (or an equivalent character reference) when the result tree is serialized as an XML document, unless otherwise specified using <a title="character map" class="termref" href="#dt-character-map">character maps</a> (see <a href="#character-maps"><i>26.3 Character Maps</i></a>) or <code>disable-output-escaping</code> (see <a href="#disable-output-escaping"><i>26.5 Disabling Output Escaping</i></a>).</p><p>A non-whitespace text node in the stylesheet that is not contained within an <a href="#element-text"><code>xsl:text</code></a> or <a href="#element-value-of"><code>xsl:value-of</code></a> instruction is equivalent to wrapping the text node in <a href="#element-text"><code>xsl:text</code></a>. For example:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:if test="$debug"&gt;Here I am&lt;/xsl:if&gt;</pre></div><p>is equivalent to:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:if test="$debug"&gt;&lt;xsl:text&gt;Here I am&lt;/xsl:text&gt;&lt;/xsl:if&gt;</pre></div></div><div class="_diffs div3"><h4><a id="xsl-text"></a>11.4.2 <a href="#xsl-text" style="text-decoration: none">The <code>xsl:text</code> and <code>xsl:value-of</code> instructions</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#generating-cdata">next</a> | <a href="#creating-text-nodes">previous</a>)</p><ol><li><p>The rules for <a href="#element-text"><code>xsl:text</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a> are integrated, allowing <a href="#element-text"><code>xsl:text</code></a> to be used to construct all text nodes, whether the content is fixed or variable.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/323">323</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2251">2251</a>&nbsp;31 October 2025]</i></p></li><li><p>The attribute <code>cdata</code> is added to <a href="#element-text"><code>xsl:text</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a> to request serialization of a text node as a CDATA section.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2198">2198</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2301">2301</a>&nbsp;19 November 2025]</i></p></li></ol></div><p class="element-syntax"><a id="element-text"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:text<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }<br>&nbsp;&nbsp;cdata? = { <var>boolean</var> }〔'no'〕<br>&nbsp;&nbsp;<span class="grayed">[disable-output-escaping]?</span> = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:text&gt;</code></p><p class="element-syntax"><a id="element-value-of"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:value-of<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }<br>&nbsp;&nbsp;cdata? = { <var>boolean</var> }〔'no'〕<br>&nbsp;&nbsp;<span class="grayed">[disable-output-escaping]?</span> = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:value-of&gt;</code></p><p>The <a href="#element-text"><code>xsl:text</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a>element have identical content models. The only differences between them are:</p><ol class="enumar"><li><p>The <a href="#element-text"><code>xsl:text</code></a> element is treated specially during whitespace-stripping, as described in <a href="#stylesheet-stripping"><span style="display: none;" class="delete_version"><i>3.12.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span style="display: none;" class="add_version"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.1</span><span class="deltaxml-new" style="background:#90EE90">3.11.1</span> Stripping Whitespace and Commentary from the Stylesheet</i></span></a>. Specifically, whitespace text nodes that are children of <a href="#element-text"><code>xsl:text</code></a> are preserved, whereas whitespace text nodes that are children of <a href="#element-value-of"><code>xsl:value-of</code></a> are discarded.</p></li><li><p>Special rules apply to <a href="#element-value-of"><code>xsl:value-of</code></a> when the instruction is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>. Specifically, if no <code>separator</code> attribute is present, and if the <code>select</code> attribute is present, then all items in the <a title="atomize" class="termref" href="#dt-atomization">atomized</a> result sequence other than the first are ignored.</p></li></ol><p>The <a href="#element-text"><code>xsl:text</code></a> or <a href="#element-value-of"><code>xsl:value-of</code></a> instruction is evaluated to construct a new text node; the result of the instruction is the newly constructed text node.</p><p>The string value of the new text node may be defined either by using the <code>select</code> attribute, or by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (see <a href="#sequence-constructors"><i>5.7 Sequence Constructors</i></a>) that forms the content of the <a href="#element-text"><code>xsl:text</code></a> or <a href="#element-value-of"><code>xsl:value-of</code></a> element. These are mutually exclusive: if the <code>select</code> attribute is present then the sequence constructor must be empty, and if the sequence constructor is non-empty then the <code>select</code> attribute must be absent. If the <code>select</code> attribute is absent and the sequence constructor is empty, then the result of the instruction is a text node whose string value is zero-length. The way in which the value is constructed is specified in <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a>.</p><p><a id="err-XTSE0870"><span class="error">[ERR XTSE0870] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-text"><code>xsl:text</code></a> or <a href="#element-value-of"><code>xsl:value-of</code></a> element is present when the content of the element is non-empty. </p><p>If the <code>separator</code> attribute is present, then the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of this attribute is used to separate adjacent items in the result sequence, as described in <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a>. In the absence of this attribute, the default separator is <span class="unicode-codepoint">U+0020</span> (<span class="unicode-name">SPACE</span>) when the content is specified using the <code>select</code> attribute, or a zero-length string when the content is specified using a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><p>If the element or one of its ancestors has an <code>[xsl:]expand-text</code> attribute, and the nearest ancestor with such an attribute has the value <code>yes</code>, then any unescaped curly brackets in the value of the element indicate the presence of <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a>, which are expanded as described in <a href="#text-value-templates"><i>5.6.2 Text Value Templates</i></a>.</p><p>In the absence of such an attribute, or if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is <code>no</code>, the content of the <a href="#element-text"><code>xsl:text</code></a> or <a href="#element-value-of"><code>xsl:value-of</code></a> instruction may comprise a single text node whose value forms the <a title="string value" class="termref" href="#dt-string-value">string value</a> of the constructed text node. An <a href="#element-text"><code>xsl:text</code></a> or <a href="#element-value-of"><code>xsl:value-of</code></a> element may also be empty, in which case the result of evaluating the instruction is a text node whose string value is the zero-length string.</p><p>For the effect of the <code>cdata</code> attribute, see <a href="#generating-cdata"><i>11.4.3 Generating CDATA Sections</i></a>.</p><p>For the effect of the <a title="deprecated" class="termref" href="#dt-deprecated">deprecated</a><code>disable-output-escaping</code> attribute, see <a href="#disable-output-escaping"><i>26.5 Disabling Output Escaping</i></a></p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is not always necessary to use the <a href="#element-text"><code>xsl:text</code></a> or <a href="#element-value-of"><code>xsl:value-of</code></a> instruction to write text nodes to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. Literal text can be written to the result tree by including it anywhere in a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. The principal reason for using <a href="#element-text"><code>xsl:text</code></a> is that it offers improved control over whitespace handling.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Historically, <a href="#element-value-of"><code>xsl:value-of</code></a> was used to construct variable content, while <a href="#element-text"><code>xsl:text</code></a> was used to copy fixed text from the stylesheet to the result document. In 4.0, that distinction is no longer relevant. Stylesheet authors should consider using <a href="#element-text"><code>xsl:text</code></a> whenever there is a need to construct text nodes, as the intent is more clearly expressed. The <a href="#element-value-of"><code>xsl:value-of</code></a> instruction has often been misunderstood; it is a common mistake to use it where <a href="#element-sequence"><code>xsl:sequence</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> is more appropriate.</p></div><div class="example"><div class="exampleHeader"><a id="d4e35482"></a><a id="d4e35374"></a>Example: Generating a List with Separators</div><p>The instruction:</p><div class="exampleInner"><pre xml:space="preserve">&lt;x&gt;&lt;xsl:text select="1 to 4" separator="|"/&gt;&lt;/x&gt;</pre></div><p>produces the output:</p><div class="exampleInner"><pre xml:space="preserve">&lt;x&gt;1|2|3|4&lt;/x&gt;</pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e35382"></a>Example: Generating Whitespace using <code>xsl:text</code><a id="d4e35382"></a>Example: Generating Whitespace using <code>xsl:text</code></div><p>The instruction:</p><div class="exampleInner"><pre xml:space="preserve">&lt;a&gt;&lt;xsl:text&gt;  &lt;x/&gt;  &lt;/xsl:text&gt;&lt;/a&gt;</pre></div><p>produces the output:</p><div class="exampleInner"><pre xml:space="preserve">&lt;a&gt;  &lt;x/&gt;  &lt;/a&gt;</pre></div><p>This illustrates that all whitespace text node children of <a href="#element-text"><code>xsl:text</code></a> are preserved, even if they have non-whitespace siblings.</p></div></div></div></div><div class="_diffs div1"><h2><a id="map"></a>21 <a href="#map" style="text-decoration: none">Maps</a></h2><p>Maps are defined in the XDM Data Model: see <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#map-items">8.2 Map Items</a>.</p><div class="_diffs div2"><h3><a id="map-instructions"></a>21.1 <a href="#map-instructions" style="text-decoration: none">Map Instructions</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#record-instructions">next</a> | <a href="#func-current">previous</a>)</p><ol><li><p> The <a href="#element-map"><code>xsl:map</code></a> instruction allows a <code>select</code> attribute as an alternative to the contained sequence constructor. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1632">1632</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1694">1694</a>&nbsp;14 January 2025]</i></p></li><li><p> The <a href="#element-map-entry"><code>xsl:map-entry</code></a> instruction, in common with other instructions, now raises error XTSE3185 (rather than XTSE3280) if both a <code>select</code> attribute and a sequence constructor are present. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1632">1632</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1694">1694</a>&nbsp;14 January 2025]</i></p></li><li><p> Ordered maps are introduced. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1651">1651</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1703">1703</a>&nbsp;14 January 2025]</i></p></li></ol></div><p>Three instructions are added to XSLT to facilitate the construction of maps.</p><p class="element-syntax"><a id="element-map"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:map<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;duplicates? = <var>expression</var>〔fn($a, $b) { error(xs:QName(err:XTDE3365)) }〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:map&gt;</code></p><p>The instruction <a href="#element-map"><code>xsl:map</code></a> constructs and returns a new map.</p><p>The <code>select</code> attribute and the contained sequence constructor are mutually exclusive: if a <code>select</code> attribute is present, then the content <span class="verb">must</span> be empty except optionally for <a href="#element-fallback"><code>xsl:fallback</code></a> instructions. <span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span></p><p>The result of evaluating the <code>select</code> expression or the contained sequence constructor is referred to as the <b>input sequence</b>.</p><p>The input sequence <span class="verb">must</span> be a sequence of maps: call this <code>$maps</code>.</p><p><span>In the absence of duplicate keys,</span> the result of the instruction is then given by the XPath 3.1 expression:</p><div class="exampleInner"><pre xml:space="preserve">map:merge($maps)</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Informally: <span>in the absence of duplicate keys</span> the resulting map contains the union of the map entries from the supplied sequence of maps.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The order of entries in the returned map will reflect the order of items in the sequence that results from evaluation of the input sequence.</p></div><p>The handling of duplicate keys is described in <a href="#duplicate-keys"><i>21.1.2 Handling of duplicate keys</i></a> below.</p><p>There is no requirement that the supplied input maps should have the same or compatible types. The type of a map (for example <code>map(xs:integer, xs:string)</code>) is descriptive of the entries it currently contains, but is not a constraint on how the map may be combined with other maps.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>A common coding pattern is to supply the input as a set of single-entry maps, that is, maps containing a single key-value pair. Moreover, it is often convenient to construct these using the <a href="#element-map-entry"><code>xsl:map-entry</code></a> instruction. However, it is not required that the input maps should be single-entry maps, nor is it required that they should be constructed using this instruction.</p></div><p><a id="err-XTTE3375"><span class="error">[ERR XTTE3375] </span></a>A type error occurs if the result of the input sequence is not an instance of the required type <code>map(*)*</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In practice, the effect of this rule is that the result of the <code>select</code> expression or sequence constructor contained in the <a href="#element-map"><code>xsl:map</code></a> instruction is severely constrained: it doesn’t make sense, for example, for it to contain instructions such as <a href="#element-element"><code>xsl:element</code></a> that create new nodes. As with other type errors, processors are free to raise the error statically if they are able to determine that the sequence constructor would always fail when evaluated.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>It is legitimate to construct a map using an instruction such as <code>&lt;xsl:map select="{'a':1, 'b':2}"/&gt;</code>. In this situation <a href="#element-map"><code>xsl:map</code></a> has exactly the same effect as <a href="#element-sequence"><code>xsl:sequence</code></a>, but users may feel that it improves readability.</p></div><p class="element-syntax"><a id="element-map-entry"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:map-entry<br>&nbsp;&nbsp;<b>key</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:map-entry&gt;</code></p><p>The instruction <a href="#element-map-entry"><code>xsl:map-entry</code></a> constructs and returns a singleton map: that is, a map which contains one key and one value. Such a map is primarily used as a building block when constructing maps using the <a href="#element-map"><code>xsl:map</code></a> instruction.</p><p>The <code>select</code> attribute and the contained sequence constructor are mutually exclusive: if a <code>select</code> attribute is present, then the content <span class="verb">must</span> be empty except optionally for <a href="#element-fallback"><code>xsl:fallback</code></a> instructions. <span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span></p><p>The key of the entry in the new map is the value obtained by evaluating the expression in the <code>key</code> attribute, converted to the required type <code>xs:anyAtomicType</code> by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. If the supplied key (after conversion) is of type <code>xs:untypedAtomic</code>, it is cast to <code>xs:string</code>.</p><p>The associated value is the value obtained by evaluating the expression in the <code>select</code> attribute, or the contained sequence constructor, with no conversion. If there is no <code>select</code> attribute and the sequence constructor is empty, the associated value is the empty sequence.</p><div class="example"><div class="exampleHeader"><a id="d4e48059"></a><a id="d4e47951"></a>Example: Using XSLT instructions to create a fixed map</div><p>The following example binds a variable to a map whose content is statically known:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="week" as="map(xs:string, xs:string)"&gt;
  &lt;xsl:map&gt;
    &lt;xsl:map-entry key="'Mo'" select="'Monday'"/&gt;
    &lt;xsl:map-entry key="'Tu'" select="'Tuesday'"/&gt;
    &lt;xsl:map-entry key="'We'" select="'Wednesday'"/&gt;
    &lt;xsl:map-entry key="'Th'" select="'Thursday'"/&gt;
    &lt;xsl:map-entry key="'Fr'" select="'Friday'"/&gt;
    &lt;xsl:map-entry key="'Sa'" select="'Saturday'"/&gt;
    &lt;xsl:map-entry key="'Su'" select="'Sunday'"/&gt;
  &lt;/xsl:map&gt;
&lt;/xsl:variable&gt;</pre></div><p>In simple cases like this the same effect can be achieved using the <a href="#element-record"><code>xsl:record</code></a> instruction:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="week" as="map(xs:string, xs:string)"&gt;
  &lt;xsl:record
    Mo="'Monday'"
    Tu="'Tuesday'"
    We="'Wednesday'"
    Th="'Thursday'"
    Fr="'Friday'"
    Sa="'Saturday'"
    Su="'Sunday'"/&gt;
&lt;/xsl:variable&gt;</pre></div><p>A third option is to construct the map in XPath:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="week" as="map(xs:string, xs:string)"&gt;
  &lt;xsl:select&gt;
    {'Mo':'Monday', 'Tu':'Tuesday', 'We':'Wednesday',
     'Th':'Thursday', 'Fr': 'Friday', 'Sa':'Saturday',
     'Su':'Sunday'}
  &lt;/xsl:select&gt;   
&lt;/xsl:variable&gt;</pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e48073"></a><a id="d4e47965"></a>Example: Using XSLT instructions to create a computed map</div><p>The following example binds a variable to a map acting as an index into a source document:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="index" as="map(xs:string, element(employee))"&gt;
  &lt;xsl:map&gt;
    &lt;xsl:for-each select="//employee"&gt;
      &lt;xsl:map-entry key="@empNr" select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:map&gt;
&lt;/xsl:variable&gt;</pre></div><p>Again, an alternative is to use an XPath expression:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:variable name="index" as="map(xs:string, element(employee))"&gt;
  &lt;xsl:select&gt;
    map:build(//employee, fn{@empNr})
  &lt;/xsl:select&gt;
&lt;/xsl:variable&gt;</pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e48081"></a><a id="d4e47973"></a>Example: Modifying the keys in a map</div><p>The following example modifies a supplied map <code>$input</code> by changing all the keys to upper case. A dynamic error occurs if this results in duplicate keys:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:map&gt;
  &lt;xsl:for-each select="map:pairs($map)"&gt;
    &lt;xsl:map-entry key="upper-case(?key)" select="?value"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:map&gt;</pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e48090"></a><a id="d4e47982"></a>Example: Modifying the values in a map</div><p>The following example modifies a supplied map <code>$input</code> by wrapping each of the values in an array:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:map&gt;
  &lt;xsl:for-each select="map:pairs($map)"&gt;
    &lt;xsl:map-entry key="?key"&gt;
       &lt;xsl:array select="?value"/&gt;
    &lt;/xsl:map-entry&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:map&gt;</pre></div><p>This could also be written:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:map select="
  map:pairs($map) ! { ?key : array{ ?value } }"/&gt;</pre></div></div><div class="_diffs div3"><h4><a id="record-instructions"></a>21.1.1 <a href="#record-instructions" style="text-decoration: none">Record Instruction</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#duplicate-keys">next</a> | <a href="#map-instructions">previous</a>)</p><ol><li><p> The <a href="#element-record"><code>xsl:record</code></a> instruction is introduced to make construction of record maps simpler. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/322">322</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1858">1858</a>&nbsp;25 March 2025]</i></p></li></ol></div><p class="element-syntax"><a id="element-record"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:record<br>&nbsp;&nbsp;xsl:as? = <var>item-type</var>〔'map(*)'〕<br>&nbsp;&nbsp;xsl:duplicates? = <var>expression</var>〔fn($a, $b) { error(xs:QName(err:XTDE3365)) }〕<br>&nbsp;&nbsp;<b>*</b> = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:record&gt;</code></p><p>(The notation <code>* = expression</code> indicates that this instruction accepts any number of additional attributes in no namespace.)</p><table class="ednote" caption="Editorial note"><tbody><tr><td style="text-align: left; vertical-align:top; width: 50%;"><b>Editorial note</b></td><td style="text-align: right; vertical-align:top; width: 50%;">&nbsp;</td></tr><tr style="text-align: left; vertical-align: top;"><td colspan="2">There needs to be a construct available within <code>element-catalog.xml</code> to declare 'any permitted attribute of a given name type/pattern', in this case <code>xs:NCName</code></td></tr></tbody></table><p>The instruction <a href="#element-record"><code>xsl:record</code></a> constructs and returns a new populated map, permitting entries to be declared as attributes on the instruction. It is intended to make writing maps where the entry keys are NCNames simpler and more concise, avoiding larger XSLT constructs using <a href="#element-map"><code>xsl:map</code></a> and <a href="#element-map-entry"><code>xsl:map-entry</code></a> or <a href="#element-sequence"><code>xsl:sequence</code></a> containing map-constructing XPath expressions.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Unlike all other <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>, the names of the attributes <code>xsl:as</code> and <code>xsl:duplicates</code> as well as the <a title="standard attributes" class="termref" href="#dt-standard-attributes">standard attributes</a> (such as <code>use-when</code> or <code>xpath-default-namespace</code>) attached to the <a href="#element-record"><code>xsl:record</code></a> instruction <span class="verb">must</span> be in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, as opposed to being in no namespace. This has been chosen to avoid reserving the names of such attributes (e.g. <code>as</code>, <code>duplicates</code>, <code>use-when</code> etc.) as potential entry keys, leaving any valid NCName as a candidate.</p></div><p>The <a href="#element-record"><code>xsl:record</code></a> generates a new map: call this <code>$record</code>. For each of the attributes of the instruction whose name is an <code>xs:NCName</code> an entry is added to <code>$record</code> whose key is the name of the attribute (as <code>xs:string</code>) and whose value is the result of evaluating the value of that attribute as an expression in the current context.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>As the values of the attributes whose names are <code>xs:NCName</code> are considered to be XPath expressions, two consequences follow for such attributes: </p><ol class="enumar"><li><span style="display: none;" class="delete_version">They <span class="verb">must not</span> be considered as shadow attributes (see <a href="#shadow-attributes"><span class="delete_version"><i>3.12.4 Shadow Attributes</i></span><span class="modify_version"><i>3.12.4 Shadow Attributes</i></span></a>) as a leading underscore is a valid character within an <code>xs:NCName</code>.</span><span style="display: none;" class="add_version">They <span class="verb">must not</span> be considered as shadow attributes (see <a href="#shadow-attributes"><span class="add_version"><i>3.11.4 Shadow Attributes</i></span><span class="modify_version"><i>3.11.4 Shadow Attributes</i></span></a>) as a leading underscore is a valid character within an <code>xs:NCName</code>.</span><span class="modify_version">They <span class="verb">must not</span> be considered as shadow attributes (see <a href="#shadow-attributes"><span style="display: none;" class="delete_version"><i>3.12.4 Shadow Attributes</i></span><span style="display: none;" class="add_version"><i>3.11.4 Shadow Attributes</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.4</span><span class="deltaxml-new" style="background:#90EE90">3.11.4</span> Shadow Attributes</i></span></a>) as a leading underscore is a valid character within an <code>xs:NCName</code>.</span></li><li>They are not designated as <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a>.</li></ol><p> These restrictions do not apply to attributes of <a href="#element-record"><code>xsl:record</code></a> whose names are in namespaces.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The order of attribute-generated entries in <code>$record</code> will reflect the order of attributes returned along the <code>attribute::</code> axis, which is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> but stable.</p></div><p>After processing the applicable attributes of the instruction, any contained sequence constructor is evaluated and the result <span class="verb">must</span> be a (possibly empty) sequence of maps. The entries in these maps are merged into <code>$record</code>. By this means entries can be added whose keys are not NCNames, or conditionally generated entries can be included.</p><p> Each of the map entries in <code>$record</code> is modified by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to convert the singleton map to the type declared in the <code>xsl:as</code> attribute of the <a href="#element-record"><code>xsl:record</code></a> instruction, if present. This may contain a map type declaration or a reference to one of the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-in-scope-named-item-types">in-scope named item types</a><sup><small>XP</small></sup>, which may include record types. Unless any type restriction is violated <code>$record</code> is returned as the instruction result.</p><table class="ednote" caption="Editorial note"><tbody><tr><td style="text-align: left; vertical-align:top; width: 50%;"><b>Editorial note</b></td><td style="text-align: right; vertical-align:top; width: 50%;">&nbsp;</td></tr><tr style="text-align: left; vertical-align: top;"><td colspan="2">This implies that <a href="#element-map"><code>xsl:map</code></a> and possibly <a href="#element-map-entry"><code>xsl:map-entry</code></a> should support an <code>as</code> attribute, restricting type.</td></tr></tbody></table><p>The treatment of duplicate keys between entries defined in the attributes of <a href="#element-record"><code>xsl:record</code></a> and any generated by a contained sequence constructor is described in <a href="#duplicate-keys"><i>21.1.2 Handling of duplicate keys</i></a> below. Note that in the absence of a sequence constructor, no duplicate keys can appear, as all attributes of <a href="#element-record"><code>xsl:record</code></a> must have a unique name within the element tag.</p><p>The effect of this instruction, in the absence of errors, is equivalent to execution of the XSLT <a href="#element-map"><code>xsl:map</code></a> instruction generated by the the following source transformation of the <a href="#element-record"><code>xsl:record</code></a> subtree</p><div class="exampleInner"><pre xml:space="preserve">                   &lt;xsl:namespace-alias stylesheet-prefix="t" result-prefix="xsl"/&gt;
...

&lt;xsl:mode name="record" on-no-match="shallow-copy"&gt;
   &lt;xsl:template match="xsl:record"&gt;
      &lt;xsl:variable name="xsl-attributes" select="@xsl:*"/&gt;
      &lt;xsl:variable name="ncname-attributes" select="@*[empty(prefix-from-QName(node-name()))]"/&gt;
      &lt;xsl:variable name="other-attributes"
          select="@* except ($xsl-attributes, $ncname-attributes)"/&gt;
      &lt;t:map&gt;
         &lt;xsl:sequence select="$other-attributes"/&gt;
         &lt;xsl:apply-templates select="$xsl-attributes, $ncname-attributes, node()"/&gt;
      &lt;/t:map&gt;
   &lt;/xsl:template&gt;
   &lt;xsl:template match="xsl:record/@*"&gt;
      &lt;t:map-entry key="'{name()}'" select="{.}"/&gt;
   &lt;/xsl:template&gt;
   &lt;xsl:template match="xsl:record/@xsl:*" priority="1"&gt;
      &lt;xsl:attribute name="{local-name()}" select="."/&gt;
   &lt;/xsl:template&gt;
&lt;/xsl:mode&gt;</pre></div><p>which for the instruction:</p><div class="exampleInner"><pre xml:space="preserve"> &lt;xsl:record xsl:as="eg:book" author="string(AUTHOR)"
               title="string(TITLE)" 
               price="xs:decimal(PRICE)" 
               publisher="string(../@name)"&gt;
      &lt;xsl:if test="@private"&gt;
         &lt;xsl:map-entry name="'private entry'" select="true()"/&gt;
      &lt;/xsl:if&gt;
   &lt;/xsl:record&gt;</pre></div><p>would produce</p><div class="exampleInner"><pre xml:space="preserve"> &lt;xsl:map as="eg:book"&gt;
      &lt;xsl:map-entry key="'author'" select="string(AUTHOR)"/&gt;
      &lt;xsl:map-entry key="'title'" select="string(TITLE)"/&gt;
      &lt;xsl:map-entry key="'price'" select="xs:decimal(PRICE)"/&gt;
      &lt;xsl:map-entry key="'publisher'" select="string(../@name)"/&gt;
      &lt;xsl:if test="@private"&gt;
         &lt;xsl:map-entry name="'private entry'" select="true()"/&gt;
      &lt;/xsl:if&gt;
   &lt;/xsl:map&gt;</pre></div><div class="example"><div class="exampleHeader"><a id="d4e48186"></a>Example: Generating a map with <code>xsl:record</code><a id="d4e48186"></a>Example: Generating a map with <code>xsl:record</code></div><p>The following example constructs a map using <a href="#element-record"><code>xsl:record</code></a></p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:template match="book" as="map(*)"&gt;
   &lt;xsl:record author="string(AUTHOR)"
               title="string(TITLE)" 
               price="xs:decimal(PRICE)" 
               publisher="string(../@name)"&gt;
      &lt;xsl:if test="@private"&gt;
         &lt;xsl:map-entry name="'private entry'" select="true()"/&gt;
      &lt;/xsl:if&gt;
   &lt;/xsl:record&gt;
&lt;/xsl:template&gt;</pre></div><p>with the following input</p><div class="exampleInner"><pre xml:space="preserve">&lt;catalog name="QT4 Community"&gt;
  &lt;book private="true"&gt;
    &lt;AUTHOR&gt;MHK&lt;/AUTHOR&gt;
    &lt;TITLE&gt;XSLT 4.0&lt;/TITLE&gt;
    &lt;PRICE&gt;123.45&lt;/PRICE&gt;
  &lt;/book&gt;
&lt;/catalog&gt;</pre></div><p>will produce a resulting map:</p><div class="exampleInner"><pre xml:space="preserve">map{'author':'MHK', 'title': 'XSLT 4.0', 'price':123.45, 
                     'publisher':'QT4 Community', 'private entry': true()}</pre></div></div></div></div></div><div class="_diffs div1"><h2><a id="extension"></a>24 <a href="#extension" style="text-decoration: none">Extensibility and Fallback</a></h2><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#extension-attributes">next</a> | <a href="#array-construction">previous</a>)</p><ol><li><p> Functions that accept a lexical QName as an argument, such as <a href="#func-key"><code>key</code></a>, <a href="#func-function-available"><code>function-available</code></a>, <a href="#func-element-available"><code>element-available</code></a>, <a href="#func-type-available"><code>type-available</code></a>, <a href="#func-system-property"><code>system-property</code></a>, <a href="#func-accumulator-before"><code>accumulator-before</code></a>, and <a href="#func-accumulator-after"><code>accumulator-after</code></a>, now have the option of supplying an <code>xs:QName</code> value instead. [This change was in the editor's draft accepted by the WG as its baseline when it started work.] <i>&nbsp;&nbsp;[&nbsp;&nbsp;1 January 2022]</i></p></li></ol></div><p>XSLT allows three kinds of extension: extension attributes, extension instructions, and extension functions.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-extension-attribute" title="extension attribute"></a>An <b>extension attribute</b> is an attribute appearing on an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>, where the name of the attribute is in a non-null namespace other than the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-extension-instruction" title="extension instruction"></a>An <b>extension instruction</b> is an element within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that is in a namespace (not the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>) designated as an extension namespace.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-extension-function" title="extension function"></a>An <b>extension function</b> is a named function introduced to the static or dynamic context by mechanisms outside the scope of this specification.<span class="definition">]</span></p><p>This specification does not define any mechanism for creating or binding implementations of <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a>, <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>, or <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a>, and it is not <span class="verb">required</span> that implementations support any such mechanism. Such mechanisms, if they exist, are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. Therefore, an XSLT stylesheet that must be portable between XSLT implementations cannot rely on particular extensions being available. XSLT provides mechanisms that allow an XSLT stylesheet to determine whether the implementation makes particular extensions available, and to specify what happens if those extensions are not available. If an XSLT stylesheet is careful to make use of these mechanisms, it is possible for it to take advantage of extensions and still retain portability.</p><p><a id="err-XTSE0085"><span class="error">[ERR XTSE0085] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a> in the name of any <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attribute</a>, <a title="extension function" class="termref" href="#dt-extension-function">extension function</a>, or <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>, other than a function or instruction defined in this specification or in a normatively referenced specification. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a prefix bound to a reserved namespace in the <code>[xsl:]extension-element-prefixes</code> attribute. </p><div class="_diffs div2"><h3><a id="extension-functions"></a>24.2 <a href="#extension-functions" style="text-decoration: none">Extension Functions</a></h3><p>The set of functions that can be called from a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionCall">FunctionCall</a><sup><small>XP</small></sup> within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> may include one or more <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a>. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of an extension function always has a non-null namespace URI, which <span class="verb">must not</span> be the URI of a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The definition of the term <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> is written to exclude user-written <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>, constructor functions for built-in and user-defined types, functions in the <code>fn</code>, <code>math</code>, <code>map</code>, and <code>array</code> namespaces, anonymous XPath inline functions, maps and arrays, and partial function applications (including partial applications of extension functions). It also excludes functions obtained by invoking XPath-defined functions such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-load-xquery-module"><code>load-xquery-module</code></a>. The definition allows extension functions to be discovered at evaluation time (typically using <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a>) rather than necessarily being known statically. </p><p>Technically, the definition of extension functions excludes anonymous functions obtained by calling or partially applying other extension functions. Since such functions are by their nature implementation-defined, they may however share some of the characteristics of extension functions.</p></div><div class="_diffs div3"><h4><a id="func-function-available"></a>24.2.1 <a href="#func-function-available" style="text-decoration: none">fn:function-available</a></h4><dl><dt class="label">Summary</dt><dd><p><span style="display: none;" class="delete_version">Determines whether a particular function is or is not available for use. The function is particularly useful for calling within an <code>[xsl:]use-when</code> attribute (see <a href="#conditional-inclusion"><span class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span class="modify_version"><i>3.12.3 Conditional Element Inclusion</i></span></a>) to test whether a particular <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> is available.</span><span style="display: none;" class="add_version">Determines whether a particular function is or is not available for use. The function is particularly useful for calling within an <code>[xsl:]use-when</code> attribute (see <a href="#conditional-inclusion"><span class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i>3.11.3 Conditional Element Inclusion</i></span></a>) to test whether a particular <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> is available.</span><span class="modify_version">Determines whether a particular function is or is not available for use. The function is particularly useful for calling within an <code>[xsl:]use-when</code> attribute (see <a href="#conditional-inclusion"><span style="display: none;" class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span style="display: none;" class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.3</span><span class="deltaxml-new" style="background:#90EE90">3.11.3</span> Conditional Element Inclusion</i></span></a>) to test whether a particular <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> is available.</span></p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">fn:function-available</code>(</td></tr><tr class="arg"><td><code>$name</code></td><td><code class="as">as&nbsp;</code><code class="type">(xs:string | xs:QName)</code>,</td><td></td></tr><tr class="arg"><td><code>$arity</code></td><td><code class="as">as&nbsp;</code><code class="type">xs:integer?</code></td><td><code class="assign">:=&nbsp;</code><code>()</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>xs:boolean</code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>, and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>. It depends on namespaces, and known function signatures. </p></dd><dt class="label">Rules</dt><dd><p>A function is said to be available within an XPath expression if it is present in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-statically-known-function-definitions">statically known function definitions</a><sup><small>XP</small></sup> for that expression (see <a href="#static-context"><i>5.3.1 Initializing the Static Context</i></a>). <span>Function definitions</span> in the static context are uniquely identified by the name of the function (a QName) in combination with its <a title="arity range" class="termref" href="#dt-arity-range">arity range</a>.</p><p>The value of <code>$name</code><span class="verb">must</span> be <span>either an <code>xs:QName</code>, or </span>a string containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. A lexical QName is expanded into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> using the namespace declarations in scope for the <a title="expression" class="termref" href="#dt-expression">expression</a>. If the value is an unprefixed lexical QName, then the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a> is used in the expanded QName.</p><p><span>When the <code>$arity</code> argument is present and non-empty,</span> the <a href="#func-function-available"><code>function-available</code></a> function returns <code>true</code> if and only if there is an available function whose name matches the value of the <code>$function-name</code> argument and whose <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> includes the value of the <code>$arity</code> argument. </p><p><span>When the <code>$arity</code> argument is omitted or empty,</span> the <a href="#func-function-available"><code>function-available</code></a> function returns <code>true</code> if and only if there is at least one available function (with some arity) whose name matches the value of the <code>$name</code> argument. </p><p>When the containing expression is evaluated with <a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> set to <code>true</code>, the <a href="#func-function-available"><code>function-available</code></a> function returns <code>false</code> in respect of a function name and arity for which no implementation is available (other than the fallback error function that raises a dynamic error whenever it is called). This means that it is possible (as in XSLT 1.0) to use logic such as the following to test whether a function is available before calling it:</p><div class="example"><div class="exampleHeader"><a id="d4e49891"></a><a id="d4e49783"></a>Example: Calling an extension function with backwards compatibility enabled</div><div class="exampleInner"><pre xml:space="preserve">&lt;summary xsl:version="1.0"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('my:summary')"&gt;
      &lt;xsl:value-of select="my:summary()"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:text&gt;Summary not available&lt;/xsl:text&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/summary&gt;</pre></div></div></dd><dt class="label">Error Conditions</dt><dd><p><a id="err-XTDE1400"><span class="error">[ERR XTDE1400] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <code>$name</code> argument <span>evaluates to a string that is not</span> a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the value is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no namespace declaration is present in the static context. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p></dd><dt class="label">Notes</dt><dd><div class="note"><p>The fact that a function with a given name is available gives no guarantee that any particular call on the function will be successful. For example, it is not possible to determine the types of the arguments expected.</p><p>The introduction of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a> function in XPath 3.0 reduces the need for <a href="#func-function-available"><code>function-available</code></a>, since <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a> not only tests whether a function is available, but also returns a function item that enables it to be dynamically called.</p><p>If a function is present in the static context but with no useful functionality (for example, if the system has been configured for security reasons so that <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-available-environment-variables"><code>available-environment-variables</code></a> returns no information), then <a href="#func-function-available"><code>function-available</code></a> when applied to that function should return <code>false</code>.</p><p>It is not necessary that there be a direct equivalence between the results of <a href="#func-function-available"><code>function-available</code></a> and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a> in all cases. For example, there may be <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> whose side-effects are such that for security reasons, dynamic calls to the function are disallowed; <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a> might then not provide access to the function. The main use-case for <a href="#func-function-available"><code>function-available</code></a>, by contrast, is for use in <code>[xsl:]use-when</code> conditions to test whether static calls on the function are possible.</p><p>In XSLT 4.0, the argument can be supplied as a QName literal, for example <code>function-available( #fn:matches )</code>. Note that in this case the default function namespace is not used for unprefixed names.</p></div></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium" style="border:1px solid; padding:5px; width:100%"><tbody><tr><td colspan="2" style="text-align:left; vertical-align:top"><div class="example"><div class="exampleHeader"><a id="d4e49981"></a><a id="d4e49873"></a>Example: Stylesheet portable between XSLT 1.0, XSLT 2.0, and XSLT 3.0</div><p>A stylesheet that is designed to use XSLT 2.0 facilities when running under an XSLT 2.0 or XSLT 3.0 processor, but to fall back to XSLT 1.0 capabilities when not, might be written using the code:</p><div class="exampleInner"><pre xml:space="preserve">&lt;out xsl:version="2.0"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('matches')"&gt;
      &lt;xsl:value-of select="matches(/doc/title, '[a-z]*')"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select="string-length(
	        translate(/doc/title, 'abcdefghijklmnopqrstuvwxyz', '')) = 0"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/out&gt;</pre></div><p>Here an XSLT 2.0 or XSLT 3.0 processor will always take the <a href="#element-when"><code>xsl:when</code></a> branch, while a 1.0 processor will follow the <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch. The single-argument version of the <a href="#func-function-available"><code>function-available</code></a> function is used here, because that is the only version available in XSLT 1.0. Under the rules of XSLT 1.0, the call on the <code>matches</code> function is not an error, because it is never evaluated.</p></div></td></tr><tr><td colspan="2" style="text-align:left; vertical-align:top"><div class="example"><div class="exampleHeader"><a id="d4e49999"></a><a id="d4e49891"></a>Example: Stylesheet portable between XSLT 3.0 and a future version of XSLT</div><p>A stylesheet that is designed to use facilities in some future XSLT version when they are available, but to fall back to XSLT 2.0 or XSLT 3.0 capabilities when not, might be written using code such as the following. This hypothesizes the availability in some future version of a function <code>pad</code> which pads a string to a fixed length with spaces:</p><div class="exampleInner"><pre xml:space="preserve"> &lt;xsl:value-of select="pad(/doc/title, 10)" 
               use-when="function-available('pad', 2)"/&gt;
 &lt;xsl:value-of select="concat(/doc/title, string-join(
                          for $i in 1 to 10 - string-length(/doc/title) 
						  return ' ', ''))"
               use-when="not(function-available('pad', 2))"/&gt;</pre></div><p>In this case the two-argument version of <a href="#func-function-available"><code>function-available</code></a> is used, because there is no requirement for this code to run under XSLT 1.0.</p></div></td></tr></tbody></table></div></dd></dl></div></div><div class="_diffs div2"><h3><a id="extension-instruction"></a>24.3 <a href="#extension-instruction" style="text-decoration: none">Extension Instructions</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#creating-result-trees">next</a> | <a href="#extension-attributes">previous</a>)</p><ol><li><p> It is possible to invoke a named template using an extension instruction, specifically, an element whose name matches the name of the named template. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/168">168</a>&nbsp;&nbsp;30 September 2022]</i></p></li></ol></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-extension-namespace" title="extension namespace"></a>The <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> mechanism allows namespaces to be designated as <b>extension namespaces</b>. When a namespace is designated as an extension namespace and an element with a name from that namespace occurs in a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, then the element is treated as an <a title="instruction" class="termref" href="#dt-instruction">instruction</a> rather than as a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>.<span class="definition">]</span> The namespace determines the semantics of the instruction.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Since an element that is a child of an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element is not occurring <em>in a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a></em>, <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> (see <a href="#user-defined-top-level"><i>3.6.4 User-defined Data Elements</i></a>) are not extension elements as defined here, and nothing in this section applies to them.</p></div><p>In XSLT 4.0 it is possible to use extension instructions to invoke named templates: see <a href="#invoking-templates-with-extension-instructions"><i>10.1.3 Invoking Named Templates using Extension Instructions</i></a>. </p><div class="_diffs div3"><h4><a id="func-element-available"></a>24.3.2 <a href="#func-element-available" style="text-decoration: none">fn:element-available</a></h4><dl><dt class="label">Summary</dt><dd><p><span style="display: none;" class="delete_version">Determines whether a particular instruction is or is not available for use. The function is particularly useful for calling within an <code>[xsl:]use-when</code> attribute (see <a href="#conditional-inclusion"><span class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span class="modify_version"><i>3.12.3 Conditional Element Inclusion</i></span></a>) to test whether a particular <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> is available.</span><span style="display: none;" class="add_version">Determines whether a particular instruction is or is not available for use. The function is particularly useful for calling within an <code>[xsl:]use-when</code> attribute (see <a href="#conditional-inclusion"><span class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i>3.11.3 Conditional Element Inclusion</i></span></a>) to test whether a particular <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> is available.</span><span class="modify_version">Determines whether a particular instruction is or is not available for use. The function is particularly useful for calling within an <code>[xsl:]use-when</code> attribute (see <a href="#conditional-inclusion"><span style="display: none;" class="delete_version"><i>3.12.3 Conditional Element Inclusion</i></span><span style="display: none;" class="add_version"><i>3.11.3 Conditional Element Inclusion</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.3</span><span class="deltaxml-new" style="background:#90EE90">3.11.3</span> Conditional Element Inclusion</i></span></a>) to test whether a particular <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> is available.</span></p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">fn:element-available</code>(</td></tr><tr class="arg"><td><code>$name</code></td><td><code class="as">as&nbsp;</code><code class="type">(xs:string | xs:QName)</code></td><td></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>xs:boolean</code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>, and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>. It depends on namespaces. </p></dd><dt class="label">Rules</dt><dd><p>The value of the <code>$name</code> argument <span class="verb">must</span> be <span>either an <code>xs:QName</code>, or</span> a string containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If it is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix, then it is expanded into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> using the namespace declarations in the static context of the <a title="expression" class="termref" href="#dt-expression">expression</a>. If there is a default namespace in scope, then it is used to expand an unprefixed <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>.</p><p> If the resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, the function returns <code>true</code> if and only if the local name matches the name of an XSLT element that is defined in this specification and implemented by the XSLT processor.</p><p>If the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> has a null namespace URI, the <a href="#func-element-available"><code>element-available</code></a> function will return <code>false</code>. </p><p>If the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is not in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, the function returns <code>true</code> if and only if the processor has an <span>external</span> implementation available of an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> with the given expanded QName. This applies whether or not the namespace has been designated as an <a title="extension namespace" class="termref" href="#dt-extension-namespace">extension namespace</a>.</p><p>The term <b>external implementation</b> excludes the use of a <a title="named template" class="termref" href="#dt-named-template">named template</a> as the instruction’s implementation. The function does not return <code>true</code> simply because the name matches the name of a <a title="named template" class="termref" href="#dt-named-template">named template</a>.</p><p>If the processor does not have an implementation of a particular extension instruction available, and such an extension instruction is evaluated, then the processor <span class="verb">must</span> perform fallback for the element as specified in <a href="#fallback"><i>24.3.3 Fallback</i></a>. An implementation <span class="verb">must not</span> raise an error merely because the stylesheet contains an extension instruction for which no implementation is available.</p></dd><dt class="label">Error Conditions</dt><dd><p><a id="err-XTDE1440"><span class="error">[ERR XTDE1440] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the argument <span>evaluates to a string that is not</span> a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the value is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no namespace declaration is present in the static context. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p></dd><dt class="label">Notes</dt><dd><div class="note"><p>For element names in the XSLT namespace:</p><ul><li><p>This function can be useful to distinguish processors that implement XSLT 3.0 from processors that implement other (older or newer) versions of the specification, and to distinguish full implementations from incomplete implementations. (Incomplete implementations, of course, cannot be assumed to behave as described in this specification.)</p></li><li><p>In earlier versions of this specification, <a href="#func-element-available"><code>element-available</code></a> was defined to return <code>true</code> only for elements classified as instructions. The distinction between instructions and other elements, however, is sometimes rather technical, and in XSLT 3.0 the effect of the function has therefore been aligned to do what its name might suggest.</p></li><li><p>If an instruction is recognized but offers no useful functionality (for example, if the system has been configured for security reasons so that <a href="#element-evaluate"><code>xsl:evaluate</code></a> always raises an error), then <a href="#func-element-available"><code>element-available</code></a> when applied to that instruction <span class="verb">should</span> return <code>false</code>.</p></li></ul><p>For element names in other namespaces:</p><ul><li><p>The result of the <a href="#func-element-available"><code>element-available</code></a> does not depend on whether or not the namespace of the supplied instruction name has been designated as an extension element namespace; it tests whether the instruction would be available if the namespace were designated as such.</p></li></ul><p>In XSLT 4.0, the argument can be supplied as a QName literal, for example <code>element-available( #xsl:switch )</code>. Note that in this case the default element namespace is not used for unprefixed names.</p></div></dd></dl></div></div></div><div class="_diffs div1"><h2><a id="result-trees"></a>25 <a href="#result-trees" style="text-decoration: none">Transformation Results</a></h2><p>The output of a transformation includes a <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> and zero or more <a title="secondary result" class="termref" href="#dt-secondary-result">secondary results</a>.</p><p>The way in which these results are delivered to an application is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p>Serialization of results is described further in <a href="#serialization"><i>26 Serialization</i></a></p><div class="_diffs div2"><h3><a id="validation"></a>25.4 <a href="#validation" style="text-decoration: none">Validation</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-xsl-output-declaration">next</a> | <a href="#func-current-output-uri">previous</a>)</p><ol><li><p> The rules concerning the compatibility of schemas imported by different packages have been clarified. It is now explicitly stated that instructions that trigger validation must use the imported schema of the package in which validation is invoked. This differs from the current practice of some XSLT 3.0 processors, which may use (for example) a schema formed from the union of the imported schemas in all packages. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/451">451</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/635">635</a>&nbsp;24 October 2023]</i></p></li><li><p> The rules concerning the interpretation of <code>xsi:schemaLocation</code> and <code>xsi:noNamespaceSchemaLocation</code> attributes have been tightened up. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/729">729</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1254">1254</a>&nbsp;8 June 2024]</i></p></li><li><p> The rules concerning the interpretation of <code>xsi:schemaLocation</code> and <code>xsi:noNamespaceSchemaLocation</code> attributes have been tightened up. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/729">729</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1254">1254</a>&nbsp;8 June 2024]</i></p></li><li><p> In order to reduce duplication between the XSLT and XQuery specifications, description of the validation process has been moved to the <em>Functions and Operators</em> specification. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2029">2029</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2030">2030</a>&nbsp;28 May 2025]</i></p></li></ol></div><p>It is possible to control the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> applied to individual element and attribute nodes as they are constructed. This is done using the <code>type</code> and <code>validation</code> attributes of the <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, <a href="#element-document"><code>xsl:document</code></a>, and <a href="#element-result-document"><code>xsl:result-document</code></a> instructions, or the <code>xsl:type</code> and <code>xsl:validation</code> attributes of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>. The same attributes are used on <a href="#element-source-document"><code>xsl:source-document</code></a> and <a href="#element-merge-source"><code>xsl:merge-source</code></a> to control validation of input documents.</p><p>The <code>[xsl:]type</code> attribute is used to request validation of an element or attribute against a specific simple or complex type defined in a schema. The <code>[xsl:]validation</code> attribute is used to request validation against the global element or attribute declaration whose name matches the name of the element or attribute being validated.</p><p>The <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are mutually exclusive. Both are optional, but if one is present then the other <span class="verb">must</span> be omitted. If both attributes are omitted, the effect is the same as specifying the <code>validation</code> attribute with the value specified in the <code>[xsl:]default-validation</code> attribute of the innermost containing element having such an attribute; if this is not specified, the effect is the same as specifying <code>validation="strip"</code>.</p><p>The <code>[xsl:]default-validation</code> attribute defines the default value of the <code>validation</code> attribute of all <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, <a href="#element-document"><code>xsl:document</code></a>, and <a href="#element-result-document"><code>xsl:result-document</code></a> instructions, and of the <code>xsl:validation</code> attribute of all <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>, <span>appearing as descendants of the element on which the attribute appears, unless there is an inner element that defines a different default</span>. This default does not extend to included or imported stylesheet modules or used packages. If the attribute is omitted, the default is <code>strip</code>. The permitted values are <code>preserve</code> and <code>strip</code>.</p><p> The <code>default-validation</code> attribute on the outermost element of the principal stylesheet module of the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> also determines the validation applied to the implicit final result tree created in the absence of an <a href="#element-result-document"><code>xsl:result-document</code></a> instruction. </p><p>The <code>[xsl:]default-validation</code> attribute has no effect on the <a href="#element-source-document"><code>xsl:source-document</code></a> and <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements, which perform no validation unless explicitly requested.</p><p><a id="err-XTSE1505"><span class="error">[ERR XTSE1505] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if both the <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are present on the <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, <a href="#element-source-document"><code>xsl:source-document</code></a>, or <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements, or on a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>. </p><p><span style="display: none;" class="delete_version">Validation always uses the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-issd">in-scope schema definitions</a><sup><small>XP</small></sup> from the static context of the instruction that invokes validation. The relevant schema may be selected using the <code>[xsl:]schema-role</code> attribute of the instruction itself, or of a containing element. See also <a href="#multiple-schemas"><span class="delete_version"><i>3.14.1 Multiple Schemas</i></span><span class="modify_version"><i>3.14.1 Multiple Schemas</i></span></a>.</span><span style="display: none;" class="add_version">Validation always uses the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-issd">in-scope schema definitions</a><sup><small>XP</small></sup> from the static context of the instruction that invokes validation. The relevant schema may be selected using the <code>[xsl:]schema-role</code> attribute of the instruction itself, or of a containing element. See also <a href="#multiple-schemas"><span class="add_version"><i>3.13.1 Multiple Schemas</i></span><span class="modify_version"><i>3.13.1 Multiple Schemas</i></span></a>.</span><span class="modify_version">Validation always uses the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-issd">in-scope schema definitions</a><sup><small>XP</small></sup> from the static context of the instruction that invokes validation. The relevant schema may be selected using the <code>[xsl:]schema-role</code> attribute of the instruction itself, or of a containing element. See also <a href="#multiple-schemas"><span style="display: none;" class="delete_version"><i>3.14.1 Multiple Schemas</i></span><span style="display: none;" class="add_version"><i>3.13.1 Multiple Schemas</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.14.1</span><span class="deltaxml-new" style="background:#90EE90">3.13.1</span> Multiple Schemas</i></span></a>.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>A stylesheet might take as its primary input a document conforming to schema <var>X</var>, and produce as its primary output a document conforming to schema <var>Y</var>. To be sure that the output is indeed valid against schema <var>Y</var>, the safest course of action is to evaluate an <a href="#element-result-document"><code>xsl:result-document</code></a> instruction using an <code>[xsl:]schema-role</code> attribute that selects schema <var>Y</var> and nothing else. Otherwise, if the validation occurs within a module that imports both <var>X</var> and <code>Y</code>, the outcome of validation might differ because of the differences between the two schemas.</p></div><p>The detailed rules for validation vary depending on the kind of node being validated. The rules for element and attribute nodes are given in <a href="#validating-constructed-nodes"><i>25.4.1 Validating Constructed Elements and Attributes</i></a>, while those for document nodes are given in <a href="#validating-document-nodes"><i>25.4.2 Validating Document Nodes</i></a>.</p></div></div><div class="_diffs div1"><h2><a id="serialization"></a>26 <a href="#serialization" style="text-decoration: none">Serialization</a></h2><p>A <a title="processor" class="termref" href="#dt-processor">processor</a><span class="verb">may</span> output a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> as a sequence of octets, although it is not <span class="verb">required</span> to be able to do so (see <a href="#conformance"><i>27 Conformance</i></a>). This process is described as <b>serialization</b>. Stylesheet authors can use <a href="#element-output"><code>xsl:output</code></a> declarations to specify how they wish result trees to be serialized. If a processor serializes a final result tree, it <span class="verb">must</span> do so as specified by these declarations.</p><p>The rules governing the output of the serializer are defined in <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a>. The serialization is controlled using a number of serialization parameters. The values of these serialization parameters may be set within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, using the <a href="#element-output"><code>xsl:output</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, and <a href="#element-character-map"><code>xsl:character-map</code></a> declarations.</p><div class="_diffs div2"><h3><a id="character-maps"></a>26.3 <a href="#character-maps" style="text-decoration: none">Character Maps</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-character-map" title="character map"></a>A <b>character map</b> allows a specific character appearing in a text or attribute node in the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> to be substituted by a specified string of characters during serialization.<span class="definition">]</span> The effect of character maps is defined in <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a>.</p><p>The character map that is supplied as a parameter to the serializer is determined from the <a href="#element-character-map"><code>xsl:character-map</code></a> elements referenced from the <a href="#element-output"><code>xsl:output</code></a> declaration for the selected <a title="output definition" class="termref" href="#dt-output-definition">output definition</a>.</p><p>The <a href="#element-character-map"><code>xsl:character-map</code></a> element is a declaration that may appear as a child of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p><p class="element-syntax"><a id="element-character-map"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:character-map<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;use-character-maps? = <var>eqnames</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-output-character">xsl:output-character</a>*) --&gt;<br>&lt;/xsl:character-map&gt;</code></p><p>The <a href="#element-character-map"><code>xsl:character-map</code></a> declaration declares a character map with a name and a set of character mappings. The character mappings are specified by means of <a href="#element-output-character"><code>xsl:output-character</code></a> elements contained either directly within the <a href="#element-character-map"><code>xsl:character-map</code></a> element, or in further character maps referenced in the <code>use-character-maps</code> attribute.</p><p>The <span class="verb">required</span><code>name</code> attribute provides a name for the character map. When a character map is used by an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> or another character map, the character map with the highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</p><p>The name of a character map is local to the <a title="package" class="termref" href="#dt-package">package</a> in which its declaration appears; it may be referenced only from within the same package.</p><p><a id="err-XTSE1580"><span class="error">[ERR XTSE1580] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains two or more character maps with the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless it also contains another character map with the same name and higher import precedence. </p><p>The optional <code>use-character-maps</code> attribute lists the names of further character maps that are included into this character map.</p><p><a id="err-XTSE1590"><span class="error">[ERR XTSE1590] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a name in the <code>use-character-maps</code> attribute of the <a href="#element-output"><code>xsl:output</code></a> or <a href="#element-character-map"><code>xsl:character-map</code></a> elements does not match the <code>name</code> attribute of any <a href="#element-character-map"><code>xsl:character-map</code></a> in the containing <a title="package" class="termref" href="#dt-package">package</a>. </p><p><a id="err-XTSE1600"><span class="error">[ERR XTSE1600] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a character map references itself, directly or indirectly, via a name in the <code>use-character-maps</code> attribute. </p><p>It is not an error if the same character map is referenced more than once, directly or indirectly.</p><p>For every <a href="#element-character-map"><code>xsl:character-map</code></a> declaration in a <a title="package" class="termref" href="#dt-package">package</a>, other than one that is overridden by another of higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, the static context of the package includes a named character map derived from the <a href="#element-character-map"><code>xsl:character-map</code></a> declaration. The name of the named character map is the QName formed by expanding the value of the <code>name</code> attribute, and the content is a map of type <code>map{xs:string, xs:string}</code> that maps characters (represented as <code>xs:string</code> instances of length 1) to their replacement strings.</p><p>Recursive expansion of character maps using <code>use-character-maps</code> attributes may produce several mappings for the same character. In this situation, the last character mapping takes precedence. To establish the ordering, the following rules are used:</p><ul><li><p>Within a single <a href="#element-character-map"><code>xsl:character-map</code></a> element, the characters defined in character maps referenced in the <code>use-character-maps</code> attribute are considered before the characters defined in the child <a href="#element-output-character"><code>xsl:output-character</code></a> elements.</p></li><li><p>The character maps referenced in a single <code>use-character-maps</code> attribute are considered in the order in which they are listed in that attribute. The expansion is depth-first: each referenced character map is fully expanded before the next one is considered.</p></li><li><p>Two <a href="#element-output-character"><code>xsl:output-character</code></a> elements appearing as children of the same <a href="#element-character-map"><code>xsl:character-map</code></a> element are considered in document order.</p></li></ul><p>The <a href="#element-output-character"><code>xsl:output-character</code></a> element is defined as follows:</p><p class="element-syntax"><a id="element-output-character"></a><code>&lt;xsl:output-character<br>&nbsp;&nbsp;<b>character</b> = <var>char</var><br>&nbsp;&nbsp;<b>string</b> = <var>string</var>&nbsp;/&gt;</code></p><p>The character map that is passed as a parameter to the serializer contains a mapping for the character specified in the <code>character</code> attribute to the string specified in the <code>string</code> attribute. </p><p>Character mapping is not applied to characters for which output escaping has been disabled as described in <a href="#disable-output-escaping"><i>26.5 Disabling Output Escaping</i></a>.</p><p>If a character is mapped, then it is not subjected to XML or HTML escaping.</p><div class="example"><div class="exampleHeader"><a id="d4e53908"></a><a id="d4e53800"></a>Example: Using Character Maps to Generate Non-XML Output</div><p>Character maps can be useful when producing serialized output in a format that resembles, but is not strictly conformant to, HTML or XML. For example, when the output is a JSP page, there might be a need to generate the output:</p><div class="exampleInner"><pre xml:space="preserve">&lt;jsp:setProperty name="user" property="id" value='&lt;%= "id" + idValue %&gt;'/&gt;</pre></div><p>Although this output is not well-formed XML or HTML, it is valid in Java Server Pages. This can be achieved by allocating three Unicode characters (which are not needed for any other purpose) to represent the strings <code>&lt;%</code>, <code>%&gt;</code>, and <code>"</code>, for example:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:character-map name="jsp"&gt;
  &lt;xsl:output-character character="«" string="&amp;lt;%"/&gt;   
  &lt;xsl:output-character character="»" string="%&amp;gt;"/&gt;
  &lt;xsl:output-character character="§" string='"'/&gt;
&lt;/xsl:character-map&gt;</pre></div><p>When this character map is referenced in the <a href="#element-output"><code>xsl:output</code></a> declaration, the required output can be produced by writing the following in the stylesheet:</p><div class="exampleInner"><pre xml:space="preserve">&lt;jsp:setProperty name="user" property="id" value='«= §id§ + idValue »'/&gt;</pre></div><p>This works on the assumption that when an apostrophe or quotation mark is generated as part of an attribute value by the use of character maps, the serializer will (where possible) use the other choice of delimiter around the attribute value.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d4e53934"></a><a id="d4e53826"></a>Example: Constructing a Composite Character Map</div><p>The following example illustrates a composite character map constructed in a modular fashion:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:output name="htmlDoc" use-character-maps="htmlDoc" /&gt;

&lt;xsl:character-map name="htmlDoc"
  use-character-maps="html-chars doc-entities windows-format" /&gt;
  
&lt;xsl:character-map name="html-chars"
  use-character-maps="latin1 ..." /&gt;

&lt;xsl:character-map name="latin1"&gt;
  &lt;xsl:output-character character="&amp;#160;" string="&amp;amp;nbsp;" /&gt;
  &lt;xsl:output-character character="&amp;#161;" string="&amp;amp;iexcl;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="doc-entities"&gt;
  &lt;xsl:output-character character="&amp;#xE400;" string="&amp;amp;t-and-c;" /&gt;
  &lt;xsl:output-character character="&amp;#xE401;" string="&amp;amp;chap1;" /&gt;
  &lt;xsl:output-character character="&amp;#xE402;" string="&amp;amp;chap2;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="windows-format"&gt;
  &lt;!-- newlines as CRLF --&gt;
  &lt;xsl:output-character character="&amp;#xA;" string="&amp;#xD;&amp;#xA;" /&gt;

  &lt;!-- tabs as three spaces --&gt;
  &lt;xsl:output-character character="&amp;#x9;" string="   " /&gt;

  &lt;!-- images for special characters --&gt;
  &lt;xsl:output-character character="&amp;#xF001;"
    string="&amp;lt;img src='special1.gif' /&amp;gt;" /&gt;
  &lt;xsl:output-character character="&amp;#xF002;"
    string="&amp;lt;img src='special2.gif' /&amp;gt;" /&gt;
  ...
&lt;/xsl:character-map&gt;</pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>When character maps are used, there is no guarantee that the serialized output will be well-formed XML (or HTML). Furthermore, the fact that the result tree was validated against a schema gives no guarantee that the serialized output will still be valid against the same schema. Conversely, it is possible to use character maps to produce schema-valid output from a result tree that would fail validation.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">The value of the <code>string</code> attribute must be a literal string; this means it must consist entirely of characters that are valid in XML 1.0 or XML 1.1, depending on the version of XML used for the containing stylesheet module. The string can however be expressed as a shadow attribute (see <a href="#shadow-attributes"><span class="delete_version"><i>3.12.4 Shadow Attributes</i></span><span class="modify_version"><i>3.12.4 Shadow Attributes</i></span></a>), and this allows it to be defined using a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>. For example, the character <span class="unicode-codepoint">U+2398</span> (<span class="unicode-name">NEXT PAGE</span>, <code>⎘</code>) might be mapped to the control character <span class="unicode-codepoint">U+000C</span> (<span class="unicode-name">FORM FEED</span>) by writing <code>&lt;xsl:output-character char="&amp;#x2398;" _string="{char(0x0C)}"/&gt;</code>. This depends on the processor allowing the form-feed character to appear in strings: the data model allows this, but processors are not <span class="verb">required</span> to support it: see <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#xml-and-xsd-versions">4.1.5 XML and XSD Versions</a>.</span><span style="display: none;" class="add_version">The value of the <code>string</code> attribute must be a literal string; this means it must consist entirely of characters that are valid in XML 1.0 or XML 1.1, depending on the version of XML used for the containing stylesheet module. The string can however be expressed as a shadow attribute (see <a href="#shadow-attributes"><span class="add_version"><i>3.11.4 Shadow Attributes</i></span><span class="modify_version"><i>3.11.4 Shadow Attributes</i></span></a>), and this allows it to be defined using a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>. For example, the character <span class="unicode-codepoint">U+2398</span> (<span class="unicode-name">NEXT PAGE</span>, <code>⎘</code>) might be mapped to the control character <span class="unicode-codepoint">U+000C</span> (<span class="unicode-name">FORM FEED</span>) by writing <code>&lt;xsl:output-character char="&amp;#x2398;" _string="{char(0x0C)}"/&gt;</code>. This depends on the processor allowing the form-feed character to appear in strings: the data model allows this, but processors are not <span class="verb">required</span> to support it: see <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#xml-and-xsd-versions">4.1.5 XML and XSD Versions</a>.</span><span class="modify_version">The value of the <code>string</code> attribute must be a literal string; this means it must consist entirely of characters that are valid in XML 1.0 or XML 1.1, depending on the version of XML used for the containing stylesheet module. The string can however be expressed as a shadow attribute (see <a href="#shadow-attributes"><span style="display: none;" class="delete_version"><i>3.12.4 Shadow Attributes</i></span><span style="display: none;" class="add_version"><i>3.11.4 Shadow Attributes</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.12.4</span><span class="deltaxml-new" style="background:#90EE90">3.11.4</span> Shadow Attributes</i></span></a>), and this allows it to be defined using a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>. For example, the character <span class="unicode-codepoint">U+2398</span> (<span class="unicode-name">NEXT PAGE</span>, <code>⎘</code>) might be mapped to the control character <span class="unicode-codepoint">U+000C</span> (<span class="unicode-name">FORM FEED</span>) by writing <code>&lt;xsl:output-character char="&amp;#x2398;" _string="{char(0x0C)}"/&gt;</code>. This depends on the processor allowing the form-feed character to appear in strings: the data model allows this, but processors are not <span class="verb">required</span> to support it: see <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#xml-and-xsd-versions">4.1.5 XML and XSD Versions</a>.</span></p></div></div></div><div class="_diffs div1"><h2><a id="conformance"></a>27 <a href="#conformance" style="text-decoration: none">Conformance</a></h2><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#func-character-map">previous</a>)</p><ol><li><p> The higher-order-function feature no longer exists; higher-order functions are now a core part of XSLT, no longer an optional extra. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/205">205</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/326">326</a>&nbsp;1 February 2023]</i></p></li><li><p> The dynamic evaluation feature no longer exists; processor are now required to support the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2047">2047</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2213">2213</a>&nbsp;23 October 2025]</i></p></li></ol></div><p>A <a title="processor" class="termref" href="#dt-processor">processor</a> that claims conformance with this specification <span class="verb">must</span> satisfy the conformance requirements for a <a title="basic XSLT processor" class="termref" href="#dt-basic-xslt-processor">basic XSLT processor</a> and for each of the optional features with which it claims conformance.</p><p>The following optional features are defined:</p><ol class="enumar"><li><p>The schema-awareness feature, defined in <a href="#schema-aware-conformance"><i>27.2 Schema-Awareness Conformance Feature</i></a></p></li><li><p>The serialization feature, defined in <a href="#serialization-feature"><i>27.3 Serialization Feature</i></a></p></li><li><p>The backwards compatibility feature, defined in <a href="#backwards-compatibility-feature"><i>27.4 Compatibility Features</i></a></p></li><li><p>The streaming feature, defined in <a href="#streaming-feature"><i>27.5 Streaming Feature</i></a>.</p></li></ol><p>A processor that does not claim conformance with an optional feature <span class="verb">must</span> satisfy the requirements for processors that do not implement that feature.</p><p>An XSLT processor takes as its inputs a stylesheet and zero or more XDM trees conforming to the data model defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>. It is not <span class="verb">required</span> that the processor supports any particular method of constructing XDM trees, but conformance can only be tested if it provides a mechanism that enables XDM trees representing the stylesheet and primary source document to be constructed and supplied as input to the processor.</p><p>The output of the XSLT processor consists of zero or more <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a>. It is not <span class="verb">required</span> that the processor supports any particular method of accessing a final result tree, but if it does not support the serialization feature, conformance can only be tested if it provides some alternative mechanism that enables access to the results of the transformation.</p><p>Certain facilities in this specification are described as producing <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> results. A claim that asserts conformance with this specification <span class="verb">must</span> be accompanied by documentation stating the effect of each implementation-defined feature. For convenience, a non-normative checklist of implementation-defined features is provided at <a href="#implementation-defined-features"><i>F Checklist of Implementation-Defined Features</i></a>.</p><p>A conforming <a title="processor" class="termref" href="#dt-processor">processor</a><span class="verb">must</span> raise any <a title="static error" class="termref" href="#dt-static-error">static error</a> occurring in the stylesheet, or in any XPath <a title="expression" class="termref" href="#dt-expression">expression</a>, except where specified otherwise either for individual error conditions or under the general provisions for <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> (see <a href="#forwards"><i>3.9 Forwards Compatible Processing</i></a>). After raising such an error, the processor <span class="verb">may</span> continue for the purpose of raising additional errors, but <span class="verb">must</span> terminate abnormally without performing any transformation.</p><p>When a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs during the course of a transformation, and is not caught using <a href="#element-catch"><code>xsl:catch</code></a>, the processor <span class="verb">must</span> raise it and <span class="verb">must</span> eventually terminate abnormally. </p><p>Some errors, notably <a title="type error" class="termref" href="#dt-type-error">type errors</a>, <span class="verb">may</span> be treated as <a title="static error" class="termref" href="#dt-static-error">static errors</a> or <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a> at the discretion of the processor.</p><p>A conforming processor <span class="verb">may</span> impose limits on the processing resources consumed by the processing of a stylesheet.</p><p>A requirement is mandatory unless the specification includes wording (such as the use of the words <span class="verb">should</span> or <span class="verb">may</span>) that clearly indicates that it is optional.</p><p>Some of the optional features are defined in such a way that if the feature is not provided, the data model is constrained to exclude certain kinds of item. For example:</p><ul><li><p>A processor that does not provide the <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-awareness</a> feature restricts the data model so that it does not contain atomic items of types other than the built-in types, or nodes with non-trivial type annotations.</p></li></ul><p><a id="err-XTDE1665"><span class="error">[ERR XTDE1665] </span></a>A <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a><span class="verb">may</span> be raised if the input to the processor includes an item that requires availability of an optional feature that the processor does not provide.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is not necessarily possible to trigger this error. A processor that does not provide an optional feature might not define or recognize any representation of the items that are disallowed. The error code is provided for use in cases where a processor is able to interoperate with other software that does not have the same constraints — for example, where a package compiled with a non-schema-aware processor is able to invoke functions in a package that was compiled with a schema-aware processor. Even in that case, processors have the option of filtering or converting the input so that it meets the relevant constraints: for example, a non-schema-aware processor when presented with a schema-validated document in the form of a PSVI might simply ignore the properties it does not understand.</p><p>The dynamic error is optional: for example a processor might report no error if the offending item is not actually used.</p><p>The phrase <em>input to the processor</em> is deliberately wide: it includes (inter alia) the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>, items present in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, items passed as <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, items returned by functions such as <a href="#func-document"><code>document</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a>, and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a>, items returned by <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> and <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>, items supplied in function or template parameters or results across package boundaries, and nodes reachable from any of the above by axis navigation.</p></div><div class="_diffs div2"><h3><a id="schema-aware-conformance"></a>27.2 <a href="#schema-aware-conformance" style="text-decoration: none">Schema-Awareness Conformance Feature</a></h3><p>A conformant processor <span class="verb">must</span> either be a conformant <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a> or a conformant <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware processor</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-schema-aware-xslt-processor" title="schema-aware XSLT processor"></a>A <b>schema-aware XSLT processor</b> is an XSLT processor that implements the mandatory requirements of this specification connected with the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration, the <code>[xsl:]validation</code> and <code>[xsl:]type attributes</code>, and the ability to handle input documents whose nodes have type annotations other than <code>xs:untyped</code> and <code>xs:untypedAtomic</code>. The mandatory requirements of this specification are taken to include the mandatory requirements of XPath 4.0, as described in <a href="#xpath-40">[XPath 4.0]</a>. A requirement is mandatory unless the specification includes wording (such as the use of the words <span class="verb">should</span> or <span class="verb">may</span>) that clearly indicates that it is optional.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-non-schema-aware-processor" title="non-schema-aware processor"></a>A <b>non-schema-aware processor</b> is a processor that does not claim conformance with the schema-aware conformance feature. Such a processor <span class="verb">must</span> handle constructs associated with schema-aware processing as described in this section.<span class="definition">]</span></p><p><a id="err-XTSE1650"><span class="error">[ERR XTSE1650] </span></a>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware processor</a><span class="verb">must</span> raise a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> includes an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>A processor that rejects an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration will also reject any reference to a user-defined type defined in a schema, or to a user-defined element or attribute declaration; it will not, however, reject references to the built-in types listed in <a href="#built-in-types"><span style="display: none;" class="delete_version"><i>3.13 Built-in Types</i></span><span style="display: none;" class="add_version"><i>3.12 Built-in Types</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.13</span><span class="deltaxml-new" style="background:#90EE90">3.12</span> Built-in Types</i></span></a>.</p></div><p>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware processor</a> is not able to validate input documents, and is not able to handle input documents containing type annotations other than <code>xs:untyped</code> or <code>xs:untypedAtomic</code>. Therefore, such a processor <span class="verb">must</span> treat any <code>[xsl:]validation</code> attribute with a value of <code>preserve</code> or <code>lax</code>, or a <code>[xsl:]default-validation</code> attribute with a value of <code>preserve</code> as if the value were <code>strip</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The values <code>lax</code> and <code>preserve</code> indicate that the validation to be applied depends on the calling application, so it is appropriate for the request to be treated differently by different kinds of processor. By contrast, requesting <code>strict</code> validation, either through the <code>[xsl:]validation</code> attribute or the <code>type</code> attribute, indicates that the stylesheet is expecting to deal with typed data, and therefore cannot be processed without performing the validation.</p></div><p><a id="err-XTSE1660"><span class="error">[ERR XTSE1660] </span></a>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware processor</a><span class="verb">must</span> raise a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> includes an <code>[xsl:]type</code> attribute; or an <code>[xsl:]validation</code> or <code>[xsl:]default-validation</code> attribute with a value other than <code>strip</code>, <code>preserve</code>, or <code>lax</code>; or an <a href="#element-mode"><code>xsl:mode</code></a> element whose <code>typed</code> attribute is equal to <code>yes</code> or <code>strict</code>; or an <code>as</code> attribute whose value is a <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a> that can only match nodes with a type annotation other than <code>xs:untyped</code> or <code>xs:untypedAtomic</code> (for example, <code>as="element(*, xs:integer)"</code>). </p><p>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware processor</a> constrains the data model as follows, and raises a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> (<span class="error">[see <a href="#err-XTDE1665">ERR XTDE1665</a>]</span>) if the constraints are not satisfied:</p><ul><li><p><span style="display: none;" class="delete_version">Atomic items <span class="verb">must</span> belong to one of the atomic types listed in <a href="#built-in-types"><span class="delete_version"><i>3.13 Built-in Types</i></span><span class="modify_version"><i>3.13 Built-in Types</i></span></a> (except as noted below).</span><span style="display: none;" class="add_version">Atomic items <span class="verb">must</span> belong to one of the atomic types listed in <a href="#built-in-types"><span class="add_version"><i>3.12 Built-in Types</i></span><span class="modify_version"><i>3.12 Built-in Types</i></span></a> (except as noted below).</span><span class="modify_version">Atomic items <span class="verb">must</span> belong to one of the atomic types listed in <a href="#built-in-types"><span style="display: none;" class="delete_version"><i>3.13 Built-in Types</i></span><span style="display: none;" class="add_version"><i>3.12 Built-in Types</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.13</span><span class="deltaxml-new" style="background:#90EE90">3.12</span> Built-in Types</i></span></a> (except as noted below).</span></p><p>An atomic item may also belong to an implementation-defined type that has been added to the context for use with <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> or <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>.</p><p>The set of constructor functions available are limited to those that construct values of the above atomic types.</p><p>The static context, which defines the full set of type names recognized by an XSLT processor and also by the XPath processor, includes these atomic types, plus <code>xs:anyType</code>, <code>xs:anySimpleType</code>, <code>xs:untyped</code>, and <code>xs:anyAtomicType</code>.</p></li><li><p>Element nodes <span class="verb">must</span> be annotated with the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a><code>xs:untyped</code>, and attribute nodes with the type annotation <code>xs:untypedAtomic</code>.</p></li></ul></div></div></div><div class="back"><div class="_diffs div1"><h2><a id="glossary"></a>B <a href="#glossary" style="text-decoration: none">Glossary</a> (Non-Normative)</h2><dl><dt><a href="#dt-sequence-comparator"></a></dt><dd><p>A <b>sequence comparator</b> is an expression that evaluates two sequences of items and results in a true or false value. </p></dd><dt><a href="#dt-absent">absent</a></dt><dd><p>A component of the context that has no value is said to be <b>absent</b>.</p></dd><dt><a href="#dt-accumulator">accumulator</a></dt><dd><p>An <b>accumulator</b> defines a series of values associated with the nodes of the tree. If an accumulator is applicable to a particular tree, then for each node in the tree, other than attribute and namespace nodes, there will be two values available, called the pre-descent and post-descent values. These two values are available via a pair of functions, <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a>.</p></dd><dt><a href="#dt-accumulator-function">accumulator function</a></dt><dd><p>The functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a> are referred to as the <b>accumulator functions</b>.</p></dd><dt><a href="#dt-alias">alias</a></dt><dd><p>A stylesheet can use the <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> element to declare that a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> is being used as an <b>alias</b> for a <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a>.</p></dd><dt><a href="#dt-applicable">applicable</a></dt><dd><p>A <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is <b>applicable</b> to one or more modes. The modes to which it is applicable are defined by the <code>mode</code> attribute of the <a href="#element-template"><code>xsl:template</code></a> element. If the attribute is omitted, then the template rule is applicable to the <a title="default mode" class="termref" href="#dt-default-mode">default mode</a> specified in the <code>[xsl:]default-mode</code> attribute of the innermost containing element that has such an attribute, which in turn defaults to the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. If the <code>mode</code> attribute is present, then its value <span class="verb">must</span> be a non-empty whitespace-separated list of tokens, each of which defines a mode to which the template rule is applicable.</p></dd><dt><a href="#dt-applicable-static-namespaces">applicable static namespaces</a></dt><dd><p> The <b>applicable static namespaces</b> for an element in a stylesheet module are the <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a> for the module if the root element of the module has a <code>fixed-namespaces</code> attribute, or the <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace bindings</a> of the element otherwise. </p></dd><dt><a href="#dt-arity-range">arity range</a></dt><dd><p>A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> has an <b>arity range</b>, which defines the minimum and maximum number of arguments that must be supplied in a call to the function. The static context can contain multiple <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> with the same name, provided that their <b>arity ranges</b> do not overlap.</p></dd><dt><a href="#dt-atomization">atomize</a></dt><dd><p>The term <b>atomization</b> is defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-atomization">2.6.3 Atomization</a>. It is a process that takes as input a sequence of items, and returns a sequence of atomic items, in which the nodes are replaced by their typed values as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>. Arrays (see <a href="#arrays"><i>22 Arrays</i></a>) are atomized by atomizing their members, recursively.</p></dd><dt><a href="#dt-attribute-set">attribute set</a></dt><dd><p>An <b>attribute set</b> is defined as a set of <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declarations in the same <a title="package" class="termref" href="#dt-package">package</a> that share the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p></dd><dt><a href="#dt-attribute-set-invocation">attribute set invocation</a></dt><dd><p>An <b>attribute set invocation</b> is a pseudo-instruction corresponding to a single EQName appearing within an <code>[xsl:]use-attribute-sets</code> attribute; the effect of the pseudo-instruction is to cause the referenced <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> to be evaluated.</p></dd><dt><a href="#dt-attribute-value-template">attribute value template</a></dt><dd><p>In an attribute that is designated as an <b>attribute value template</b>, such as an attribute of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, an <a title="expression" class="termref" href="#dt-expression">expression</a> can be used by surrounding the expression with curly brackets (<code>{}</code>), following the general rules for <a title="value template" class="termref" href="#dt-value-template">value templates</a></p></dd><dt><a href="#dt-backwards-compatible-behavior">backwards compatible behavior</a></dt><dd><p>An element is processed with <b>backwards compatible behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is less than <span>4.0</span>.</p></dd><dt><a href="#dt-base-output-uri">base output URI</a></dt><dd><p> The <b>base output URI</b> is a URI to be used as the base URI when resolving a relative URI reference allocated to a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>. If the transformation generates more than one final result tree, then typically each one will be allocated a URI relative to this base URI.</p></dd><dt><a href="#dt-basic-xslt-processor">basic XSLT processor</a></dt><dd><p>A <b>basic XSLT processor</b> is an XSLT processor that implements all the mandatory requirements of this specification with the exception of constructs explicitly associated with an optional feature.</p></dd><dt><a href="#dt-character-map">character map</a></dt><dd><p>A <b>character map</b> allows a specific character appearing in a text or attribute node in the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> to be substituted by a specified string of characters during serialization.</p></dd><dt><a href="#dt-circularity">circularity</a></dt><dd><p>A <b>circularity</b> is said to exist if a construct such as a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, or a <a title="key" class="termref" href="#dt-key">key</a>, cannot be evaluated without reference to its own value. For example, if the <a title="expression" class="termref" href="#dt-expression">expression</a> or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> specifying the value of a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a><var>X</var> references a global variable <var>Y</var>, then the value for <var>Y</var><span class="verb">must</span> be computed before the value of <var>X</var>. A circularity exists if it is impossible to do this for all global variable definitions.</p></dd><dt><a href="#dt-coercion-rules">coercion rules</a></dt><dd><p> The term <b>coercion rules</b> means the coercion rules defined in <a href="#xpath-40">[XPath 4.0]</a>, applied unless otherwise specified with XPath 1.0 compatibility mode set to <code>false</code>.</p></dd><dt><a href="#dt-collation">collation</a></dt><dd><p>Facilities in XSLT 3.0 and XPath 3.0 that require strings to be ordered rely on the concept of a named <b>collation</b>. A collation is a set of rules that determine whether two strings are equal, and if not, which of them is to be sorted before the other.</p></dd><dt><a href="#dt-combined-merge-key-value">combined merge key value</a></dt><dd><p> The ordered collection of <a title="merge key value" class="termref" href="#dt-merge-key-value">merge key values</a> computed for one item in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequence</a> (one for each <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> within the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>) is referred to as a <b>combined merge key value</b>.</p></dd><dt><a href="#dt-compatible">compatible</a></dt><dd><p>The signatures of two <a title="component" class="termref" href="#dt-component">components</a> are <b>compatible</b> if they present the same interface to the user of the component. The additional rules depend on the kind of component.</p></dd><dt><a href="#dt-component">component</a></dt><dd><p>The term <b>component</b> is used to refer to any of the following: a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, a <a title="named template" class="termref" href="#dt-named-template">named template</a>, a <a title="mode" class="termref" href="#dt-mode">mode</a>, an <a title="accumulator function" class="termref" href="#dt-accumulator-function">accumulator</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, a <a title="key" class="termref" href="#dt-key">key</a>, <a title="global variable" class="termref" href="#dt-global-variable">global variable</a>, or a <a title="mode" class="termref" href="#dt-mode">mode</a>.</p></dd><dt><a href="#dt-containing-package">containing package</a></dt><dd><p>A component declaration results in multiple components, one in the package in which the declaration appears, and potentially one in each package that uses the declaring package, directly or indirectly, subject to the visibility of the component. Each of these multiple components has the same <a title="declaring package" class="termref" href="#dt-declaring-package">declaring package</a>, but each has a different <b>containing package</b>. For the original component, the declaring package and the containing package are the same; for a copy of a component made as a result of an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration, the declaring package will be the original package, and the containing package will be the package in which the <a href="#element-use-package"><code>xsl:use-package</code></a> declaration appears.</p></dd><dt><a href="#dt-context-item">context item</a></dt><dd><p>The <b>context item</b> is the item currently being processed. An item (see <a href="#xpath-datamodel-40">[XDM 4.0]</a>) is either an atomic item (such as an integer, date, or string), a node, or a function item. It changes whenever instructions such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-for-each"><code>xsl:for-each</code></a> are used to process a sequence of items; each item in such a sequence becomes the context item while that item is being processed.</p></dd><dt><a href="#dt-context-node">context node</a></dt><dd><p>If the <a title="context item" class="termref" href="#dt-context-item">context item</a> is a node (as distinct from an atomic item such as an integer), then it is also referred to as the <b>context node</b>. The context node is not an independent variable, it changes whenever the context item changes. When the context item is an atomic item or a function item, there is no context node.</p></dd><dt><a href="#dt-context-position">context position</a></dt><dd><p>The <b>context position</b> is the position of the context item within the sequence of items currently being processed. It changes whenever the context item changes. When an instruction such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or <a href="#element-for-each"><code>xsl:for-each</code></a> is used to process a sequence of items, the first item in the sequence is processed with a context position of 1, the second item with a context position of 2, and so on.</p></dd><dt><a href="#dt-context-size">context size</a></dt><dd><p>The <b>context size</b> is the number of items in the sequence of items currently being processed. It changes whenever instructions such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-for-each"><code>xsl:for-each</code></a> are used to process a sequence of items; during the processing of each one of those items, the context size is set to the count of the number of items in the sequence (or equivalently, the position of the last item in the sequence).</p></dd><dt><a href="#dt-current-captured-groups">current captured groups</a></dt><dd><p>While the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> instruction is active, a set of <b>current captured groups</b> is available, corresponding to the capturing subexpressions of the regular expression.</p></dd><dt><a href="#dt-current-group">current group</a></dt><dd><p>The <b>current group</b> is the <a title="group" class="termref" href="#dt-group">group</a> itself, as a sequence of items</p></dd><dt><a href="#dt-current-grouping-key">current grouping key</a></dt><dd><p>The <b>current grouping key</b> is a single atomic item, or in the case of a composite key, a sequence of atomic items, containing the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> of the items in the <a title="current group" class="termref" href="#dt-current-group">current group</a>.</p></dd><dt><a href="#dt-current-merge-group">current merge group</a></dt><dd><p>The <b>current merge group</b> is a map. During evaluation of an <a href="#element-merge"><code>xsl:merge</code></a> instruction, as each group of items with equal <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">combined merge key values</a> is processed, the current merge group is set to a map whose keys are the names of the various merge sources, and whose associated values are the items from each merge source having the relevant composite merge key value.</p></dd><dt><a href="#dt-current-merge-key">current merge key</a></dt><dd><p>The <b>current merge key</b> is a an array, whose members are sequences of atomic items. There is one member in the array for each <a href="#element-merge-key"><code>xsl:merge-key</code></a> element in the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>. During evaluation of an <a href="#element-merge"><code>xsl:merge</code></a> instruction, as each group of items with equal <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">combined merge key values</a> is processed, the current merge key is set to the combined merge key value that these items have in common.</p></dd><dt><a href="#dt-current-mode">current mode</a></dt><dd><p>At any point in the processing of a stylesheet, there is a <b>current mode</b>. When the transformation is initiated, the current mode is the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>, as described in <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>. Whenever an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction is evaluated, the current mode becomes the mode selected by this instruction.</p></dd><dt><a href="#dt-current-output-uri">current output URI</a></dt><dd><p>The <b>current output URI</b> is the URI associated with the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a> that is currently being written.</p></dd><dt><a href="#dt-current-template-rule">current template rule</a></dt><dd><p>At any point in the processing of a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, there may be a <b>current template rule</b>. Whenever a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is chosen as a result of evaluating <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a>, the template rule becomes the current template rule for the evaluation of the rule’s sequence constructor.</p></dd><dt><a href="#dt-decimal-format">decimal format</a></dt><dd><p>All the <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations in a package that share the same name are grouped into a named <b>decimal format</b>; those that have no name are grouped into a single unnamed decimal format.</p></dd><dt><a href="#dt-declaration">declaration</a></dt><dd><p>Top-level elements fall into two categories: declarations, and user-defined data elements. Top-level elements whose names are in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> are <b>declarations</b>. Top-level elements in any other namespace are <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> (see <a href="#user-defined-top-level"><i>3.6.4 User-defined Data Elements</i></a>)</p></dd><dt><a href="#dt-declaration-order">declaration order</a></dt><dd><p>The <a title="declaration" class="termref" href="#dt-declaration">declarations</a> within a <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet level</a> have a total ordering known as <b>declaration order</b>. The order of declarations within a stylesheet level is the same as the document order that would result if each stylesheet module were inserted textually in place of the <a href="#element-include"><code>xsl:include</code></a> element that references it.</p></dd><dt><a href="#dt-declaring-package">declaring package</a></dt><dd><p>The <b>declaring package</b> of a <a title="component" class="termref" href="#dt-component">component</a> is the package that contains the declaration (or, in the case of <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> and <a href="#element-key"><code>xsl:key</code></a>, multiple declarations) of the component.</p></dd><dt><a href="#dt-default-collation">default collation</a></dt><dd><p>In this specification the term <b>default collation</b> means the collation that is used by XPath operators such as <code>eq</code> and <code>lt</code> appearing in XPath expressions within the stylesheet.</p></dd><dt><a href="#dt-default-mode">default mode</a></dt><dd><p>The <code>[xsl:]default-mode</code> attribute defines the <b>default mode</b>, which is used as the default value for the <a title="mode" class="termref" href="#dt-mode">mode</a> attribute of all <a href="#element-template"><code>xsl:template</code></a> and <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> elements within its scope.</p></dd><dt><a href="#dt-default-priority">default priority</a></dt><dd><p>If no <code>priority</code> attribute is specified on an <a href="#element-template"><code>xsl:template</code></a> element, a <b>default priority</b> is computed, based on the syntactic form of the <a title="pattern" class="termref" href="#dt-pattern">pattern</a> supplied in the <code>match</code> attribute.</p></dd><dt><a href="#dt-defining-element">defining element</a></dt><dd><p>A string in the form of a lexical QName may occur as the value of an attribute node in a stylesheet module, or within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> contained in an attribute or text node within a stylesheet module, or as the result of evaluating an XPath expression contained in such a node. The element containing this attribute or text node is referred to as the <b>defining element</b> of the lexical QName.</p></dd><dt><a href="#dt-deprecated">deprecated</a></dt><dd><p>Some constructs defined in this specification are described as being <b>deprecated</b>. The use of this term implies that stylesheet authors <span class="verb">should not</span> use the construct, and that the construct may be removed in a later version of this specification.</p></dd><dt><a href="#dt-disqualifying-element">disqualifying element</a></dt><dd><p>The <b>disqualifying elements</b> are <a href="#element-map"><code>xsl:map</code></a>, <a href="#element-map-entry"><code>xsl:map-entry</code></a>, <a href="#element-array"><code>xsl:array</code></a>, <a href="#element-array-member"><code>xsl:array-member</code></a>, <a href="#element-record"><code>xsl:record</code></a>, and <a href="#element-select"><code>xsl:select</code></a>. If a sequence constructor includes one of these elements, then construction of the implicit document node does not take place.</p></dd><dt><a href="#dt-dynamic-error">dynamic error</a></dt><dd><p>An error that is not capable of detection until a source document is being transformed is referred to as a <b>dynamic error</b>.</p></dd><dt><a href="#dt-eclipsed">eclipsed</a></dt><dd><p>An <a href="#element-function"><code>xsl:function</code></a> declaration <var>F</var> is said to be <b>eclipsed</b> if the containing package includes an <a href="#element-function"><code>xsl:function</code></a> declaration <var>G</var> such that <var>F</var> and <var>G</var> have the same name, <var>F</var> has lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than <var>G</var>, and the <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> of <var>G</var> includes the totality of the arity range of <var>F</var>.</p></dd><dt><a href="#dt-effective-value">effective value</a></dt><dd><p>The <b>effective value</b> of an attribute or text node in the stylesheet is the value after any required expansion or normalization.</p></dd><dt><a href="#dt-effective-version">effective version</a></dt><dd><p>The <b>effective version</b> of an element in a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> or <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> is the decimal value of the <code>[xsl:]version</code> attribute (see <a href="#standard-attributes"><i>3.3 Standard Attributes</i></a>) on that element or on the innermost ancestor element that has such an attribute, <span>subject to special rules for the <a href="#element-output"><code>xsl:output</code></a> and <a href="#element-fallback"><code>xsl:fallback</code></a> elements.</span></p></dd><dt><a href="#dt-embedded-stylesheet-module">embedded stylesheet module</a></dt><dd><p><span style="display: none;" class="delete_version">A stylesheet module whose outermost element is the child of a non-XSLT element in a host document is referred to as an <b>embedded stylesheet module</b>. See <a href="#embedded"><i>3.11 Embedded Stylesheet Modules</i></a>.</span><span style="display: none;" class="add_version">A stylesheet module whose outermost element is the child of a non-XSLT element in a host document is referred to as an <b>embedded stylesheet module</b>.</span><span class="modify_version">A stylesheet module whose outermost element is the child of a non-XSLT element in a host document is referred to as an <b>embedded stylesheet module</b>.<span class="deltaxml-old" style="background:#FF5555"> See </span><a href="#embedded"><i><span class="deltaxml-old" style="background:#FF5555">3.11 Embedded Stylesheet Modules</span></i></a><span class="deltaxml-old" style="background:#FF5555">.</span></span></p></dd><dt><a href="#dt-enclosing-mode">enclosing mode</a></dt><dd><p>A mode declared by an <a href="#element-mode"><code>xsl:mode</code></a> declaration that has one or more contained <a href="#element-template"><code>xsl:template</code></a> declarations is referred to as an <b>enclosing mode</b>.</p></dd><dt><a href="#dt-eqname">EQName</a></dt><dd><p>An <b>EQName</b> is a string representing an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> where the string, after removing leading and trailing whitespace, is in the form defined by the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup> production in the XPath specification.</p></dd><dt><a href="#dt-expanded-qname">expanded QName</a></dt><dd><p>An <b>expanded QName</b> is a value in the value space of the <code>xs:QName</code> datatype as defined in the XDM data model (see <a href="#xpath-datamodel-40">[XDM 4.0]</a>): that is, a triple containing namespace prefix (optional), namespace URI (optional), and local name. Two expanded QNames are equal if the namespace URIs are the same (or both absent) and the local names are the same. The prefix plays no part in the comparison, but is used only if the expanded QName needs to be converted back to a string.</p></dd><dt><a href="#dt-explicit-default">explicit default</a></dt><dd><p>An <b>explicit default</b> for a parameter is indicated by the presence of either a <code>select</code> attribute or a non-empty sequence constructor.</p></dd><dt><a href="#dt-explicitly-mandatory">explicitly mandatory</a></dt><dd><p>A parameter is <b>explicitly mandatory</b> if it is a <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a><span>with no <code>required</code> attribute</span>, or if the <code>required</code> attribute is present and has the value <code>yes</code>.</p></dd><dt><a href="#dt-expression">expression</a></dt><dd><p>Within this specification, the term <b>XPath expression</b>, or simply <b>expression</b>, means a string that matches the production <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP</small></sup> defined in <a href="#xpath-40">[XPath 4.0]</a>.</p></dd><dt><a href="#dt-extension-attribute">extension attribute</a></dt><dd><p>An <b>extension attribute</b> is an attribute appearing on an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>, where the name of the attribute is in a non-null namespace other than the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>.</p></dd><dt><a href="#dt-extension-function">extension function</a></dt><dd><p>An <b>extension function</b> is a named function introduced to the static or dynamic context by mechanisms outside the scope of this specification.</p></dd><dt><a href="#dt-extension-instruction">extension instruction</a></dt><dd><p>An <b>extension instruction</b> is an element within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that is in a namespace (not the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>) designated as an extension namespace.</p></dd><dt><a href="#dt-extension-namespace">extension namespace</a></dt><dd><p>The <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> mechanism allows namespaces to be designated as <b>extension namespaces</b>. When a namespace is designated as an extension namespace and an element with a name from that namespace occurs in a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, then the element is treated as an <a title="instruction" class="termref" href="#dt-instruction">instruction</a> rather than as a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>.</p></dd><dt><a href="#dt-final-output-state">final output state</a></dt><dd><p>The first of the two <a title="output state" class="termref" href="#dt-output-state">output states</a> is called <b>final output</b> state. This state applies when instructions are writing to a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>.</p></dd><dt><a href="#dt-final-result-tree">final result tree</a></dt><dd><p>A <b>final result tree</b> is a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> that forms part of the output of a transformation: specifically, a tree built by post-processing the items in the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or in a <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>. Once created, the contents of a final result tree are not accessible within the stylesheet itself.</p></dd><dt><a href="#dt-fixed-namespace-bindings">fixed namespace bindings</a></dt><dd><p> The <b>fixed namespace bindings</b> for a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> are established using the <code>fixed-namespaces</code> attribute on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a> element enclosing the stylesheet module.</p></dd><dt><a href="#dt-focus">focus</a></dt><dd><p>When a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is evaluated, the <a title="processor" class="termref" href="#dt-processor">processor</a> keeps track of which items are being processed by means of a set of implicit variables referred to collectively as the <b>focus</b>.</p></dd><dt><a href="#dt-forwards-compatible-behavior">forwards compatible behavior</a></dt><dd><p>An element is processed with <b>forwards compatible behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is greater than <span>4.0</span>.</p></dd><dt><a href="#dt-function-definition">function definition</a></dt><dd><p>The term <b>function definition</b> is defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#static_context">2.2.1 Static Context</a>. It is the definition of a function that can be called statically from within an XPath expression: in the case of XSLT it typically means either a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, or a built-in function such as those defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a></p></dd><dt><a href="#dt-function-parameter">function parameter</a></dt><dd><p> An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an <a href="#element-function"><code>xsl:function</code></a> element, before any non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter is known as a <b>function parameter</b>. A function parameter is a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a> with the additional property that its value can be set when the function is called, using a function call in an XPath <a title="expression" class="termref" href="#dt-expression">expression</a>.</p></dd><dt><a href="#dt-global-context-item">global context item</a></dt><dd><p>An item that is the <b>global context item</b> for the transformation acts as the <a title="context item" class="termref" href="#dt-context-item">context item</a> when evaluating the <code>select</code> expression or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a><span>whose declaration is</span> within the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>, as described in <a href="#focus"><i>5.3.3.1 Maintaining Position: the Focus</i></a>. The global context item may also be available in a <a title="named template" class="termref" href="#dt-named-template">named template</a> when the stylesheet is invoked as described in <a href="#invoking-initial-template"><i>2.3.4 Call-Template Invocation</i></a></p></dd><dt><a href="#dt-global-variable">global variable</a></dt><dd><p>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a><a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> declares a <b>global variable</b> that is visible everywhere except within any region where it is <a title="shadows" class="termref" href="#dt-shadows">shadowed</a> by another variable binding.</p></dd><dt><a href="#dt-gnode-pattern">GNode pattern</a></dt><dd><p>An <b>GNode pattern</b> uses a subset of the syntax for path expressions, and is defined to match a GNode if the corresponding path expression would select the GNode.</p></dd><dt><a href="#dt-group">group</a></dt><dd><p>The <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction allocates the items in an input sequence into <b>groups</b> of items (that is, it establishes a collection of sequences) based either on common values of a grouping key, or on a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that the initial or final item in a group must match.</p></dd><dt><a href="#dt-grouping-key">grouping key</a></dt><dd><p>If the <code>group-by</code> or <code>group-adjacent</code> attributes is present, then for each item in the <a title="population" class="termref" href="#dt-population">population</a> a set of <b>grouping keys</b> is calculated, as follows: the expression contained in the <code>group-by</code> or <code>group-adjacent</code> attribute is evaluated; the result is atomized; and any <code>xs:untypedAtomic</code> items are cast to <code>xs:string</code>. If <code>composite="yes"</code> is specified, there is a single grouping key whose value is the resulting sequence; otherwise, there is a set of grouping keys, consisting of the distinct atomic items present in the result sequence.</p></dd><dt><a href="#dt-high-priority-package-location">high priority package location</a></dt><dd><p>A <code>xsl:package-location</code> without the attribute <code>is-priority</code>, or with <code>is-priority</code> set to <code>true</code> is a <b>high priority package location</b>.</p></dd><dt><a href="#dt-homonymous">homonymous</a></dt><dd><p>Two <a title="component" class="termref" href="#dt-component">components</a> are said to be <b>homonymous</b> if they have the same <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a>.</p></dd><dt><a href="#dt-identical-types">identical (types)</a></dt><dd><p>Types <var>S</var> and <var>T</var> are considered <b>identical</b> for the purpose of these rules if and only if <code>subtype(S, T)</code> and <code>subtype(T, S)</code> both hold, where the subtype relation is defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-seqtype-subtype">3.3.1 Subtypes of Sequence Types</a>.</p></dd><dt><a href="#dt-immediate-result">immediate result</a></dt><dd><p>The result of evaluating a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is the sequence of items formed by concatenating the results of evaluating each of the nodes in the sequence constructor, retaining order. This is referred to as the <b>immediate result</b> of the sequence constructor.</p></dd><dt><a href="#dt-implementation">implementation</a></dt><dd><p>A specific product that performs the functions of an <a title="processor" class="termref" href="#dt-processor">XSLT processor</a> is referred to as an <b>implementation</b>.</p></dd><dt><a href="#dt-implementation-defined">implementation-defined</a></dt><dd><p>In this specification, the term <b>implementation-defined</b> refers to a feature where the implementation is allowed some flexibility, and where the choices made by the implementation <span class="verb">must</span> be described in documentation that accompanies any conformance claim.</p></dd><dt><a href="#dt-implementation-dependent">implementation-dependent</a></dt><dd><p>The term <b>implementation-dependent</b> refers to a feature where the behavior <span class="verb">may</span> vary from one implementation to another, and where the vendor is not expected to provide a full specification of the behavior.</p></dd><dt><a href="#dt-implicit-default">implicit default</a></dt><dd><p>If a parameter that is not <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a> has no <a title="explicit default" class="termref" href="#dt-explicit-default">explicit default</a> value, then it has an <b>implicit default</b> value, which is the empty sequence if there is an <code>as</code> attribute, or a zero-length string if not.</p></dd><dt><a href="#dt-implicitly-mandatory">implicitly mandatory</a></dt><dd><p>If a parameter has an <a title="implicit default" class="termref" href="#dt-implicit-default">implicit default</a> value which cannot be converted to the <a title="required type" class="termref" href="#dt-required-type">required type</a> (that is, if it has an <code>as</code> attribute which does not permit the empty sequence), then the parameter is <b>implicitly mandatory</b>.</p></dd><dt><a href="#dt-import-precedence">import precedence</a></dt><dd><p>A <a title="declaration" class="termref" href="#dt-declaration">declaration</a><var>D</var> in the stylesheet is defined to have lower <b>import precedence</b> than another declaration <var>E</var> if the stylesheet level containing <var>D</var> would be visited before the stylesheet level containing <var>E</var> in a post-order traversal of the import tree (that is, a traversal of the import tree in which a stylesheet level is visited after its children). Two declarations within the same stylesheet level have the same import precedence.</p></dd><dt><a href="#dt-import-tree">import tree</a></dt><dd><p>The <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet levels</a> making up a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> are treated as forming an <b>import tree</b>. In the import tree, each stylesheet level has one child for each <a href="#element-import"><code>xsl:import</code></a> declaration that it contains.</p></dd><dt><a href="#dt-initial-function">initial function</a></dt><dd><p>A stylesheet may be evaluated by calling a named <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, referred to as the <b>initial function</b>.</p></dd><dt><a href="#dt-initial-item">initial item</a></dt><dd><p>For each <a title="group" class="termref" href="#dt-group">group</a>, the item within the group that is first in <a title="population order" class="termref" href="#dt-population-order">population order</a> is known as the <b>initial item</b> of the group.</p></dd><dt><a href="#dt-initial-match-selection">initial match selection</a></dt><dd><p>A stylesheet may be evaluated by supplying a value to be processed, together with an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>. The value (which can be any sequence of items) is referred to as the <b>initial match selection</b>. The processing then corresponds to the effect of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p></dd><dt><a href="#dt-initial-mode">initial mode</a></dt><dd><p>The <b>initial mode</b> is the <a title="mode" class="termref" href="#dt-mode">mode</a> used to select <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> for processing items in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> when apply-templates invocation is used to initiate a transformation.</p></dd><dt><a href="#dt-initial-named-template">initial named template</a></dt><dd><p>A stylesheet may be evaluated by selecting a named template to be evaluated; this is referred to as the <b>initial named template</b>.</p></dd><dt><a href="#dt-initial-sequence">initial sequence</a></dt><dd><p>The sequence to be sorted is referred to as the <b>initial sequence</b>.</p></dd><dt><a href="#dt-initial-setting">initial setting</a></dt><dd><p>The <b>initial setting</b> of a component of the dynamic context is used when evaluating <a title="global variable" class="termref" href="#dt-global-variable">global variables</a> and <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, when evaluating the <code>use</code> and <code>match</code> attributes of <a href="#element-key"><code>xsl:key</code></a>, and when evaluating the <code>initial-value</code> of <a href="#element-accumulator"><code>xsl:accumulator</code></a> and the <code>select</code> expressions or contained sequence constructors of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a></p></dd><dt><a href="#dt-in-scope-schema-component">in-scope schema component</a></dt><dd><p>The <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> that may be referenced by name in a <a title="package" class="termref" href="#dt-package">package</a> are referred to as the <b>in-scope schema components</b>.</p></dd><dt><a href="#dt-instruction">instruction</a></dt><dd><p>An <b>instruction</b> is either an <a title="XSLT instruction" class="termref" href="#dt-xslt-instruction">XSLT instruction</a> or an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>.</p></dd><dt><a href="#dt-invocation-construct">invocation construct</a></dt><dd><p>The following constructs are classified as <b>invocation constructs</b>: the instructions <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, and <a href="#element-next-match"><code>xsl:next-match</code></a>; XPath function calls that bind to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>; XPath dynamic function calls; the functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a>; the <code>[xsl:]use-attribute-sets</code> attribute. These all have the characteristic that they can cause evaluation of constructs that are not lexically contained within the calling construct.</p></dd><dt><a href="#dt-key">key</a></dt><dd><p>A <b>key</b> is defined as a set of <a href="#element-key"><code>xsl:key</code></a> declarations in the same <a title="package" class="termref" href="#dt-package">package</a> that share the same name.</p></dd><dt><a href="#dt-key-specifier">key specifier</a></dt><dd><p>The expression in the <code>use</code> attribute and the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> within an <a href="#element-key"><code>xsl:key</code></a> declaration are referred to collectively as the <b>key specifier</b>. The key specifier determines the values that may be used to find a node using this <a title="key" class="termref" href="#dt-key">key</a>.</p></dd><dt><a href="#dt-lexical-qname">lexical QName</a></dt><dd><p>A <b>lexical QName</b> is a string representing an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> where the string, after removing leading and trailing whitespace, is within the lexical space of the <code>xs:QName</code> datatype as defined in XML Schema (see <a href="#xmlschema-2">[XML Schema Part 2]</a>): that is, a local name optionally preceded by a namespace prefix and a colon.</p></dd><dt><a href="#dt-library-package">library package</a></dt><dd><p>Every <a title="package" class="termref" href="#dt-package">package</a> within a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, other than the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>, is referred to as a <b>library package</b>.</p></dd><dt><a href="#dt-literal-namespace-uri">literal namespace URI</a></dt><dd><p>A namespace URI in the stylesheet tree that is being used to specify a namespace URI in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> is called a <b>literal namespace URI</b>.</p></dd><dt><a href="#dt-literal-result-element">literal result element</a></dt><dd><p>In a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, an element in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that does not belong to the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> and that is not an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> (see <a href="#extension-instruction"><i>24.3 Extension Instructions</i></a>) is classified as a <b>literal result element</b>.</p></dd><dt><a href="#dt-local-variable">local variable</a></dt><dd><p>As well as being allowed as a <a title="declaration" class="termref" href="#dt-declaration">declaration</a>, the <a href="#element-variable"><code>xsl:variable</code></a> element is also allowed in <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructors</a>. Such a variable is known as a <b>local variable</b>.</p></dd><dt><a href="#dt-low-priority-package-location">low priority package location</a></dt><dd><p>A <code>xsl:package-location</code> with <code>is-priority</code> set to <code>false</code> is a <b>low priority package location</b>.</p></dd><dt><a href="#dt-merge-activation">merge activation</a></dt><dd><p>A <b>merge activation</b> is a single evaluation of the sequence constructor contained within the <a href="#element-merge-action"><code>xsl:merge-action</code></a> element, which occurs once for each distinct <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">combined merge key value</a>.</p></dd><dt><a href="#dt-merge-input-sequence">merge input sequence</a></dt><dd><p>A <b>merge input sequence</b> is an arbitrary <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-sequence">sequence</a><sup><small>DM</small></sup> of items which is already sorted according to the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a> for the corresponding <a title="merge source definition" class="termref" href="#dt-merge-source-definition">merge source definition</a>.</p></dd><dt><a href="#dt-merge-key-component">merge key component</a></dt><dd><p>A <b>merge key component</b> specifies one component of a <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>; it corresponds to a single <a href="#element-merge-key"><code>xsl:merge-key</code></a> element in the stylesheet.</p></dd><dt><a href="#dt-merge-key-specification">merge key specification</a></dt><dd><p>A <b>merge key specification</b> consists of one or more adjacent <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements which together define how the <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequences</a> selected by a <a title="merge source definition" class="termref" href="#dt-merge-source-definition">merge source definition</a> are sorted. Each <a href="#element-merge-key"><code>xsl:merge-key</code></a> element defines one <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a>.</p></dd><dt><a href="#dt-merge-key-value">merge key value</a></dt><dd><p> For each item in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequence</a>, a value is computed for each <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> within the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>. The value computed for an item by using the <var>N</var>th <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> is referred to as the <var>N</var>th <b>merge key value</b> of that item.</p></dd><dt><a href="#dt-merge-source-definition">merge source definition</a></dt><dd><p>A <b>merge source definition</b> is the definition of one kind of input to the merge operation. It selects zero or more <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequences</a>, and it includes a <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a> to define how the <a title="merge key value" class="termref" href="#dt-merge-key-value">merge key values</a> are computed for each such merge input sequence.</p></dd><dt><a href="#dt-mode">mode</a></dt><dd><p> A <b>mode</b> is a set of template rules; when the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects a set of items for processing, it identifies the rules to be used for processing those items by nominating a mode, explicitly or implicitly.</p></dd><dt><a href="#dt-mode-definition">mode definition</a></dt><dd><p>All the <a href="#element-mode"><code>xsl:mode</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> that share the same name are grouped into a named <b>mode definition</b>; those that have no name are grouped into a single unnamed mode definition.</p></dd><dt><a href="#dt-named-template">named template</a></dt><dd><p>Templates can be invoked by name. An <a href="#element-template"><code>xsl:template</code></a> element with a <code>name</code> attribute defines a <b>named template</b>.</p></dd><dt><a href="#dt-namespace-fixup">namespace fixup</a></dt><dd><p>The rules for the individual XSLT instructions that construct a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> (see <a href="#creating-new-nodes"><i>11 Creating Nodes</i></a>) prescribe some of the situations in which namespace nodes are written to the tree. These rules, however, are not sufficient to ensure that the prescribed constraints are always satisfied. The XSLT processor <span class="verb">must</span> therefore add additional namespace nodes to satisfy these constraints. This process is referred to as <b>namespace fixup</b>.</p></dd><dt><a href="#dt-native-namespace-bindings">native namespace bindings</a></dt><dd><p> The <b>native namespace bindings</b> for any element in an XSLT <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> are the prefix-uri mappings defined by the namespace nodes of that element, according to the rules in <a href="#xpath-datamodel-40">[XDM 4.0]</a>.</p></dd><dt><a href="#dt-non-contextual-function-call">non-contextual function call</a></dt><dd><p>The term <b>non-contextual function call</b> is used to refer to function calls that do not pass the dynamic context to the called function. This includes all calls on <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> and all <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamic-function-call">dynamic function calls</a><sup><small>XP</small></sup>, (that is calls to function items). It excludes calls to some functions in the namespace <code>http://www.w3.org/2005/xpath-functions</code>, in particular those that explicitly depend on the context, such as the <a href="#func-current-group"><code>current-group</code></a> and <a href="#func-regex-group"><code>regex-group</code></a> functions. It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether, and under what circumstances, calls to <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> are non-contextual.</p></dd><dt><a href="#dt-non-schema-aware-processor">non-schema-aware processor</a></dt><dd><p>A <b>non-schema-aware processor</b> is a processor that does not claim conformance with the schema-aware conformance feature. Such a processor <span class="verb">must</span> handle constructs associated with schema-aware processing as described in this section.</p></dd><dt><a href="#dt-first-appearance">order of first appearance</a></dt><dd><p>There is a total ordering among <a title="group" class="termref" href="#dt-group">groups</a> referred to as the <b>order of first appearance</b>. A group <var>G</var> is defined to precede a group <var>H</var> in order of first appearance if the <a title="initial item" class="termref" href="#dt-initial-item">initial item</a> of <var>G</var> precedes the initial item of <var>H</var> in population order. If two groups <var>G</var> and <var>H</var> have the same initial item (because the item is in both groups) then <var>G</var> precedes <var>H</var> if the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> of <var>G</var> precedes the grouping key of <var>H</var> in the sequence that results from evaluating the <code>group-by</code> expression of this initial item.</p></dd><dt><a href="#dt-output-definition">output definition</a></dt><dd><p>All the <a href="#element-output"><code>xsl:output</code></a> declarations within a <a title="package" class="termref" href="#dt-package">package</a> that share the same name are grouped into a named <b>output definition</b>; those that have no name are grouped into a single unnamed output definition.</p></dd><dt><a href="#dt-output-state">output state</a></dt><dd><p>Each instruction in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is evaluated in one of two possible <b>output states</b>: <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a> or <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>.</p></dd><dt><a href="#dt-override">override</a></dt><dd><p>A component in a using package may <b>override</b> a component in a used package, provided that the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the component in the used package is either <code>abstract</code> or <code>public</code>. The overriding declaration is written as a child of the <a href="#element-override"><code>xsl:override</code></a> element, which in turn appears as a child of <a href="#element-use-package"><code>xsl:use-package</code></a>.</p></dd><dt><a href="#dt-package">package</a></dt><dd><p>An explicit <b>package</b> is represented by an <a href="#element-package"><code>xsl:package</code></a> element, which will generally be the outermost element of an XML document. When the <a href="#element-package"><code>xsl:package</code></a> element is not used explicitly, the entire stylesheet comprises a single implicit package.</p></dd><dt><a href="#dt-package-manifest">package manifest</a></dt><dd><p>The content of the <a href="#element-package"><code>xsl:package</code></a> element is referred to as the <b>package manifest</b></p></dd><dt><a href="#dt-parameter">parameter</a></dt><dd><p>The <a href="#element-param"><code>xsl:param</code></a> element declares a <b>parameter</b>, which may be a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a>, a <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a>, a <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a>, or an <a href="#element-iterate"><code>xsl:iterate</code></a> parameter. A parameter is a <a title="variable" class="termref" href="#dt-variable">variable</a> with the additional property that its value can be set by the caller.</p></dd><dt><a href="#dt-pattern">pattern</a></dt><dd><p>A <b>pattern</b> specifies a set of conditions on an item. An item that satisfies the conditions matches the pattern; an item that does not satisfy the conditions does not match the pattern.</p></dd><dt><a href="#dt-picture-string">picture string</a></dt><dd><p>The <b>picture string</b> is the string supplied as the second argument of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-number"><code>format-number</code></a> function.</p></dd><dt><a href="#dt-place-marker">place marker</a></dt><dd><p>The <a href="#element-number"><code>xsl:number</code></a> instruction performs two tasks: firstly, determining a <b>place marker</b> (this is a sequence of integers, to allow for hierarchic numbering schemes such as <code>1.12.2</code> or <code>3(c)ii</code>), and secondly, formatting the place marker for output as a text node in the result sequence.</p></dd><dt><a href="#dt-population">population</a></dt><dd><p>The sequence of items to be grouped, which is referred to as the <b>population</b>, is determined by evaluating the XPath <a title="expression" class="termref" href="#dt-expression">expression</a> contained in the <code>select</code> attribute.</p></dd><dt><a href="#dt-population-order">population order</a></dt><dd><p>The population is treated as a sequence; the order of items in this sequence is referred to as <b>population order</b>.</p></dd><dt><a href="#dt-portion">portion</a></dt><dd><p>The integer literals and the optional <code>NamePart</code> within the version number are referred to as the <b>portions</b> of the version number.</p></dd><dt><a href="#dt-predicate-pattern">predicate pattern</a></dt><dd><p>A <b>predicate pattern</b> is written as <code>.</code> (dot) followed by zero or more predicates in square brackets, and it matches any item for which each of the predicates evaluates to <code>true</code>.</p></dd><dt><a href="#dt-principal-result">principal result</a></dt><dd><p>A <b>principal result</b>: this can be any sequence of items (as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>).</p></dd><dt><a href="#dt-principal-stylesheet-module">principal stylesheet module</a></dt><dd><p>Within a <a title="package" class="termref" href="#dt-package">package</a>, one <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> functions as the <b>principal stylesheet module</b>. The complete package is assembled by finding the stylesheet modules referenced directly or indirectly from the principal stylesheet module using <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a> elements: see <a href="#include"><i>3.10.2 Stylesheet Inclusion</i></a> and <a href="#import"><i>3.10.3 Stylesheet Import</i></a>.</p></dd><dt><a href="#dt-priority">priority</a></dt><dd><p>The <b>priority</b> of a template rule is specified by the <code>priority</code> attribute on the <a href="#element-template"><code>xsl:template</code></a> declaration. If no priority is specified explicitly for a template rule, its <a title="default priority" class="termref" href="#dt-default-priority">default priority</a> is used, as defined in <a href="#default-priority"><i>6.3.3 Default Priority for Patterns</i></a>.</p></dd><dt><a href="#dt-optimal-package-location">priority package location</a></dt><dd><p>The first package location whose value of <code>href</code>, when resolved as described in <a href="#uri-references"><i>5.8 URI References</i></a>, allows the system to find the specified resource, and its entry if the resource is an archive, is the <b>optimal package location</b>.</p></dd><dt><a href="#dt-processing-order">processing order</a></dt><dd><p>There is another total ordering among groups referred to as <b>processing order</b>. If group <var>R</var> precedes group <var>S</var> in processing order, then in the result sequence returned by the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction the items generated by processing group <var>R</var> will precede the items generated by processing group <var>S</var>.</p></dd><dt><a href="#dt-processor">processor</a></dt><dd><p>The software responsible for transforming source trees into result trees using an XSLT stylesheet is referred to as the <b>processor</b>. This is sometimes expanded to <em>XSLT processor</em> to avoid any confusion with other processors, for example an XML processor.</p></dd><dt><a href="#dt-raw-result">raw result</a></dt><dd><p>The result of invoking the selected component, after any required conversion to the declared result type of the component, is referred to as the <b>raw result</b>.</p></dd><dt><a href="#dt-reference-binding">reference binding</a></dt><dd><p>The process of identifying the <a title="component" class="termref" href="#dt-component">component</a> to which a <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic reference</a> applies (possibly chosen from several <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> alternatives) is called <b>reference binding</b>.</p></dd><dt><a href="#dt-required-type">required type</a></dt><dd><p>The context within a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> where an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> appears may specify the <b>required type</b> of the expression. The required type indicates the type of the value that the expression is expected to return.</p></dd><dt><a href="#dt-reserved-namespace">reserved namespace</a></dt><dd><p>The XSLT namespace, together with certain other namespaces recognized by an XSLT processor, are classified as <b>reserved namespaces</b> and <span class="verb">must</span> be used only as specified in this and related specifications.</p></dd><dt><a href="#dt-result-tree">result tree</a></dt><dd><p>The term <b>result tree</b> is used to refer to any <a title="tree" class="termref" href="#dt-tree">tree</a> constructed by <a title="instruction" class="termref" href="#dt-instruction">instructions</a> in the stylesheet. A result tree is either a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> or a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a>.</p></dd><dt><a href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a></dt><dd><p>A <b>schema-aware XSLT processor</b> is an XSLT processor that implements the mandatory requirements of this specification connected with the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration, the <code>[xsl:]validation</code> and <code>[xsl:]type attributes</code>, and the ability to handle input documents whose nodes have type annotations other than <code>xs:untyped</code> and <code>xs:untypedAtomic</code>. The mandatory requirements of this specification are taken to include the mandatory requirements of XPath 4.0, as described in <a href="#xpath-40">[XPath 4.0]</a>. A requirement is mandatory unless the specification includes wording (such as the use of the words <span class="verb">should</span> or <span class="verb">may</span>) that clearly indicates that it is optional.</p></dd><dt><a href="#dt-schema-component">schema component</a></dt><dd><p>Type definitions and element and attribute declarations are referred to collectively as <b>schema components</b>.</p></dd><dt><a href="#dt-schema-instance-namespace">schema instance namespace</a></dt><dd><p>The <b>schema instance namespace</b><code>http://www.w3.org/2001/XMLSchema-instance</code>, <span>with conventional prefix <code>xsi</code></span>, is used as defined in <a href="#xmlschema-1">[XML Schema Part 1]</a></p></dd><dt><a href="#dt-schema-namespace">schema namespace</a></dt><dd><p>The <b>schema namespace</b><code>http://www.w3.org/2001/XMLSchema</code>, <span>with conventional prefix <code>xs</code></span>, is used as defined in <a href="#xmlschema-1">[XML Schema Part 1]</a></p></dd><dt><a href="#dt-secondary-result">secondary result</a></dt><dd><p>Zero or more <b>secondary results</b>: each secondary result can be any sequence of items (as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>).</p></dd><dt><a href="#dt-sequence-constructor">sequence constructor</a></dt><dd><p>A <b>sequence constructor</b> is a sequence of zero or more sibling nodes in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that can be evaluated to return a sequence of nodes, atomic items, and function items. The way that the resulting sequence is used depends on the containing instruction.</p></dd><dt><a href="#dt-sequence-type">SequenceType</a></dt><dd><p>A <b>SequenceType</b> constrains the type and number of items in a sequence. The term is used both to denote the concept, and to refer to the syntactic form in which sequence types are expressed in the XPath grammar: specifically <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup> in <a href="#xpath-40">[XPath 4.0]</a>.</p></dd><dt><a href="#dt-serialization">serialization</a></dt><dd><p>A frequent requirement is to output a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> as an XML document (or in other formats such as HTML). This process is referred to as <b>serialization</b>.</p></dd><dt><a href="#dt-serialization-error">serialization error</a></dt><dd><p>If a transformation has successfully produced a <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>, it is still possible that errors may occur in serializing that result . For example, it may be impossible to serialize the result using the encoding selected by the user. Such an error is referred to as a <b>serialization error</b>.</p></dd><dt><a href="#dt-serialization-feature">serialization feature</a></dt><dd><p>A processor that claims conformance with the <b>serialization feature</b><span class="verb">must</span> support the conversion of a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> to a sequence of octets following the rules defined in <a href="#serialization"><i>26 Serialization</i></a>.</p></dd><dt><a href="#dt-shadows">shadows</a></dt><dd><p>Within a region of the stylesheet where a binding <var>B</var>1 is visible, <var>B<sub>1</sub></var> shadows another binding <var>B<sub>2</sub></var> having the same name as <var>B<sub>1</sub></var> if <var>B<sub>1</sub></var> occurs at a point where <var>B<sub>2</sub></var> is visible.</p></dd><dt><a href="#dt-simplified-stylesheet-module">simplified stylesheet</a></dt><dd><p>A <b>simplified stylesheet</b>, which is a subtree rooted at a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, as described in <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>. This is first converted to a <a title="standard stylesheet module" class="termref" href="#dt-standard-stylesheet-module">standard stylesheet module</a> by wrapping it in an xsl:stylesheet element using the transformation described in <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>.</p></dd><dt><a href="#dt-singleton-focus">singleton focus</a></dt><dd><p>A <b>singleton focus</b> based on an item <var>J</var> has the <a title="context item" class="termref" href="#dt-context-item">context item</a> (and therefore the <a title="context node" class="termref" href="#dt-context-node">context node</a>, if <var>J</var> is a node) set to <var>J</var>, and the <a title="context position" class="termref" href="#dt-context-position">context position</a> and <a title="context size" class="termref" href="#dt-context-size">context size</a> both set to 1 (one).</p></dd><dt><a href="#dt-snapshot">snapshot</a></dt><dd><p>A <b>snapshot</b> of a node <var>N</var> is a deep copy of <var>N</var>, as produced by the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction with <code>copy-namespaces</code> set to <code>yes</code>, <code>copy-accumulators</code> set to <code>yes</code>, and <code>validation</code> set to <code>preserve</code>, with the additional property that for every ancestor of <var>N</var>, the copy also has a corresponding ancestor whose name, node-kind, and base URI are the same as the corresponding ancestor of <var>N</var>, and that has copies of the attributes, namespaces and accumulator values of the corresponding ancestor of <var>N</var>. But the ancestor has a type annotation of <code>xs:anyType</code>, has the properties <code>nilled</code>, <code>is-id</code>, and <code>is-idref</code> set to <code>false</code>, and has no children other than the child that is a copy of <var>N</var> or one of its ancestors.</p></dd><dt><a href="#dt-sorted-sequence">sorted sequence</a></dt><dd><p>The sequence after sorting as defined by the <a href="#element-sort"><code>xsl:sort</code></a> elements is referred to as the <b>sorted sequence</b>.</p></dd><dt><a href="#dt-sort-key-component">sort key component</a></dt><dd><p>Within a <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a>, each <a href="#element-sort"><code>xsl:sort</code></a> element defines one <b>sort key component</b>.</p></dd><dt><a href="#dt-sort-key-specification">sort key specification</a></dt><dd><p>A <b>sort key specification</b> is a sequence of one or more adjacent <a href="#element-sort"><code>xsl:sort</code></a> elements which together define rules for sorting the items in an input sequence to form a sorted sequence.</p></dd><dt><a href="#dt-sort-key-value">sort key value</a></dt><dd><p> For each item in the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a>, a value is computed for each <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a> within the <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a>. The value computed for an item by using the <var>N</var>th sort key component is referred to as the <var>N</var>th <b>sort key value</b> of that item.</p></dd><dt><a href="#dt-source-tree">source tree</a></dt><dd><p>The term <b>source tree</b> means any tree provided as input to the transformation. This includes the document containing the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> if any, documents containing nodes present in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, documents containing nodes supplied as the values of <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, documents obtained from the results of functions such as <a href="#func-document"><code>document</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a>, and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a>, documents read using the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction, and documents returned by extension functions or extension instructions. In the context of a particular XSLT instruction, the term <b>source tree</b> means any tree provided as input to that instruction; this may be a source tree of the transformation as a whole, or it may be a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> produced during the course of the transformation.</p></dd><dt><a href="#dt-stable">stable</a></dt><dd><p>A <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a> is said to be <b>stable</b> if its first <a href="#element-sort"><code>xsl:sort</code></a> element has no <code>stable</code> attribute, or has a <code>stable</code> attribute whose <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is <code>yes</code>.</p></dd><dt><a href="#dt-standard-attributes">standard attributes</a></dt><dd><p>There are a number of <b>standard attributes</b> that may appear on any <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>: specifically <code>default-collation</code>, <code>default-mode</code>, <code>default-validation</code>, <code>exclude-result-prefixes</code>, <code>expand-text</code>, <code>extension-element-prefixes</code>, <code>schema-role</code>, <code>use-when</code>, <code>version</code>, and <code>xpath-default-namespace</code>.</p></dd><dt><a href="#dt-standard-error-namespace">standard error namespace</a></dt><dd><p>The <b>standard error namespace</b><code>http://www.w3.org/2005/xqt-errors</code>, <span>with conventional prefix <code>err</code></span>, is used for error codes defined in this specification and related specifications. It is also used for the names of certain predefined variables accessible within the scope of an <a href="#element-catch"><code>xsl:catch</code></a> element.</p></dd><dt><a href="#dt-standard-function-namespace">standard function namespace</a></dt><dd><p>The <b>standard function namespace</b><code>http://www.w3.org/2005/xpath-functions</code>, <span>with conventional prefix <code>fn</code></span>, is used for functions in the function library defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> and for standard functions defined in this specification.</p></dd><dt><a href="#dt-standard-stylesheet-module">standard stylesheet module</a></dt><dd><p>A <b>standard stylesheet module</b>, which is a subtree rooted at an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element.</p></dd><dt><a href="#dt-static-error">static error</a></dt><dd><p>An error that can be detected by examining a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> before execution starts (that is, before the source document and values of stylesheet parameters are available) is referred to as a <b>static error</b>.</p></dd><dt><a href="#dt-static-expression">static expression</a></dt><dd><p>A <b>static expression</b> is an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> whose value must be computed during static analysis of the stylesheet.</p></dd><dt><a href="#dt-static-parameter">static parameter</a></dt><dd><p>A <a title="static variable" class="termref" href="#dt-static-variable">static variable</a> declared using an <a href="#element-param"><code>xsl:param</code></a> element is referred to as a <b>static parameter</b>.</p></dd><dt><a href="#dt-static-variable">static variable</a></dt><dd><p>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a><a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> having the attribute <code>static="yes"</code> declares a <b>static variable</b>: that is, a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> whose value is known during static analysis of the stylesheet.</p></dd><dt><a href="#dt-streamable-mode">streamable mode</a></dt><dd><p>A <b>streamable mode</b> is a <a title="mode" class="termref" href="#dt-mode">mode</a> that is declared in an <a href="#element-mode"><code>xsl:mode</code></a> declaration with the attribute <code>streamable="yes"</code>.</p></dd><dt><a href="#dt-streamed-document">streamed document</a></dt><dd><p>A <b>streamed document</b> is a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> that is processed using streaming, that is, without constructing a complete tree of nodes in memory.</p></dd><dt><a href="#dt-streamed-node">streamed node</a></dt><dd><p>A <b>streamed node</b> is a node in a <a title="streamed document" class="termref" href="#dt-streamed-document">streamed document</a>.</p></dd><dt><a href="#dt-streaming">streaming</a></dt><dd><p>The term <b>streaming</b> refers to a manner of processing in which XML documents (such as source and result documents) are not represented by a complete tree of nodes occupying memory proportional to document size, but instead are processed “on the fly” as a sequence of events, similar in concept to the stream of events notified by an XML parser to represent markup in lexical XML.</p></dd><dt><a href="#dt-streaming-feature">streaming feature</a></dt><dd><p>A processor that claims conformance with the <b>streaming feature</b><span class="verb">must</span> use streamed processing in cases where (a) streaming is requested (for example by using the attribute <code>streamable="yes"</code> on <a href="#element-mode"><code>xsl:mode</code></a>, or on the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction) and (b) the constructs in question are <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-guaranteed-streamable">guaranteed-streamable</a><sup><small>SG</small></sup> according to this specification.</p></dd><dt><a href="#dt-string-value">string value</a></dt><dd><p>The term <b>string value</b> is defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-string-value">7.6.12 string-value Accessor</a>. Every node has a <a title="string value" class="termref" href="#dt-string-value">string value</a>. For example, the <a title="string value" class="termref" href="#dt-string-value">string value</a> of an element is the concatenation of the <a title="string value" class="termref" href="#dt-string-value">string values</a> of all its descendant text nodes.</p></dd><dt><a href="#dt-stylesheet">stylesheet</a></dt><dd><p>A <b>stylesheet</b> consists of one or more packages: specifically, one <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> and zero or more <a title="library package" class="termref" href="#dt-library-package">library packages</a>.</p></dd><dt><a href="#dt-stylesheet-function">stylesheet function</a></dt><dd><p>An <a href="#element-function"><code>xsl:function</code></a> declaration declares the name, parameters, and implementation of a family of <b>stylesheet functions</b> that can be called from any XPath <a title="expression" class="termref" href="#dt-expression">expression</a> within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (subject to visibility rules).</p></dd><dt><a href="#dt-stylesheet-level">stylesheet level</a></dt><dd><p>A <b>stylesheet level</b> is a collection of <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> connected using <a href="#element-include"><code>xsl:include</code></a> declarations: specifically, two stylesheet modules <var>A</var> and <var>B</var> are part of the same stylesheet level if one of them includes the other by means of an <a href="#element-include"><code>xsl:include</code></a> declaration, or if there is a third stylesheet module <var>C</var> that is in the same stylesheet level as both <var>A</var> and <var>B</var>.</p></dd><dt><a href="#dt-stylesheet-module">stylesheet module</a></dt><dd><p>A <a title="package" class="termref" href="#dt-package">package</a> consists of one or more <b>stylesheet modules</b>, each one forming all or part of an XML document.</p></dd><dt><a href="#dt-stylesheet-parameter">stylesheet parameter</a></dt><dd><p>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a><a href="#element-param"><code>xsl:param</code></a> element declares a <b>stylesheet parameter</b>. A stylesheet parameter is a global variable with the additional property that its value can be supplied by the caller when a transformation is initiated.</p></dd><dt><a href="#dt-supplied-value">supplied value</a></dt><dd><p>The value of the variable is computed using the <a title="expression" class="termref" href="#dt-expression">expression</a> given in the <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, as described in <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>. This value is referred to as the <b>supplied value</b> of the variable.</p></dd><dt><a href="#dt-symbolic-identifier">symbolic identifier</a></dt><dd><p>The <b>symbolic identifier</b> of a <a title="component" class="termref" href="#dt-component">component</a> is a composite name used to identify the component uniquely within a package. The symbolic identifier comprises the kind of component (stylesheet function, named template, accumulator, attribute set, global variable, key, or mode), the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the component (namespace URI plus local name), and in the case of stylesheet functions, <span>the upper bound of the <a title="arity range" class="termref" href="#dt-arity-range">arity range</a></span>.</p></dd><dt><a href="#dt-symbolic-reference">symbolic reference</a></dt><dd><p>The <a title="declaration" class="termref" href="#dt-declaration">declaration</a> of a component includes constructs that can be interpreted as references to other <a title="component" class="termref" href="#dt-component">components</a> by means of their <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifiers</a>. These constructs are generically referred to as <b>symbolic references</b>. Examples of constructs that give rise to symbolic references are the <code>name</code> attribute of <a href="#element-call-template"><code>xsl:call-template</code></a>; the <code>[xsl:]use-attribute-sets</code> attribute of <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, and <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>; the explicit or implicit <code>mode</code> attribute of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>; XPath variable references referring to global variables; XPath static function calls (including partial function applications) referring to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>; and named function references (example: <code>my:f#1</code>) referring to stylesheet functions. </p></dd><dt><a href="#dt-tail-position">tail position</a></dt><dd><p>An <a title="instruction" class="termref" href="#dt-instruction">instruction</a><var>J</var> is in a <b>tail position</b> within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a><var>SC</var> if it satisfies one of the following conditions:</p><ul><li><p><var>J</var> is the last instruction in <var>SC</var>, ignoring any <a href="#element-fallback"><code>xsl:fallback</code></a> instructions.</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-if"><code>xsl:if</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch of an <a href="#element-choose"><code>xsl:choose</code></a><span>or <a href="#element-switch"><code>xsl:switch</code></a></span> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-try"><code>xsl:try</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var> (that is, it is immediately followed by an <a href="#element-catch"><code>xsl:catch</code></a> element, ignoring any <a href="#element-fallback"><code>xsl:fallback</code></a> elements).</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-catch"><code>xsl:catch</code></a> element within an <a href="#element-try"><code>xsl:try</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p></li></ul></dd><dt><a href="#dt-target-expression">target expression</a></dt><dd><p>The string that results from evaluating the expression in the <code>xpath</code> attribute is referred to as the <b>target expression</b>.</p></dd><dt><a href="#dt-target-namespace-uri">target namespace URI</a></dt><dd><p>The namespace URI that is to be used in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> as a substitute for a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> is called the <b>target namespace URI</b>.</p></dd><dt><a href="#dt-template">template</a></dt><dd><p>An <a href="#element-template"><code>xsl:template</code></a> declaration defines a <b>template</b>, which contains a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>; this sequence constructor is evaluated to determine the result of the template. A template can serve either as a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>, invoked by matching items against a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, or as a <a title="named template" class="termref" href="#dt-named-template">named template</a>, invoked explicitly by name. It is also possible for the same template to serve in both capacities.</p></dd><dt><a href="#dt-template-parameter">template parameter</a></dt><dd><p> An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an <a href="#element-template"><code>xsl:template</code></a> element, before any non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter is known as a <b>template parameter</b>. A template parameter is a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a> with the additional property that its value can be set when the template is called, using any of the instructions <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a>.</p></dd><dt><a href="#dt-template-rule">template rule</a></dt><dd><p>A stylesheet contains a set of <b>template rules</b> (see <a href="#rules"><i>6 Template Rules</i></a>). A template rule has three parts: a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that is matched against selected items (often but not necessarily nodes), a (possibly empty) set of <a title="template parameter" class="termref" href="#dt-template-parameter">template parameters</a>, and a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that is evaluated to produce a sequence of items.</p></dd><dt><a href="#dt-temporary-output-state">temporary output state</a></dt><dd><p>The second of the two <a title="output state" class="termref" href="#dt-output-state">output states</a> is called <b>temporary output</b> state. This state applies when instructions are writing to a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> or any other non-final destination.</p></dd><dt><a href="#dt-temporary-tree">temporary tree</a></dt><dd><p>The term <b>temporary tree</b> means any tree that is neither a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> nor a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>.</p></dd><dt><a href="#dt-text-value-template">text value template</a></dt><dd><p>In a text node that is designated as a <b>text value template</b>, <a title="expression" class="termref" href="#dt-expression">expressions</a> can be used by surrounding each expression with curly brackets (<code>{}</code>).</p></dd><dt><a href="#dt-top-level">top-level</a></dt><dd><p>An element occurring as a child of an <a href="#element-package"><code>xsl:package</code></a>, <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-override"><code>xsl:override</code></a> element is called a <b>top-level</b> element.</p></dd><dt><a href="#dt-top-level-package">top-level package</a></dt><dd><p>For a given transformation, one <a title="package" class="termref" href="#dt-package">package</a> functions as the <b>top-level package</b>. The complete <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is assembled by finding the packages referenced directly or indirectly from the top-level package using <a href="#element-use-package"><code>xsl:use-package</code></a> declarations: see <a href="#package-dependencies"><i>3.4.2 Dependencies between Packages</i></a>.</p></dd><dt><a href="#dt-traversal">traversal</a></dt><dd><p>A <b>traversal</b> of a tree is a sequence of <a title="traversal-event" class="termref" href="#dt-traversal-event">traversal events</a>.</p></dd><dt><a href="#dt-traversal-event">traversal-event</a></dt><dd><p>a <b>traversal event</b> (shortened to <b>event</b> in this section) is a pair comprising a phase (start or end) and a node.</p></dd><dt><a href="#dt-tree">tree</a></dt><dd><p>The term <b>tree</b> is used (as in <a href="#xpath-datamodel-40">[XDM 4.0]</a>) to refer to the aggregate consisting of a parentless node together with all its descendant nodes, plus all their attributes and namespaces.</p></dd><dt><a href="#dt-tunnel-parameter">tunnel parameter</a></dt><dd><p>A parameter passed to a template may be defined as a <b>tunnel parameter</b>. Tunnel parameters have the property that they are automatically passed on by the called template to any further templates that it calls, and so on recursively.</p></dd><dt><a href="#dt-type-annotation">type annotation</a></dt><dd><p>The term <b>type annotation</b> is used in this specification to refer to the value returned by the <code>dm:type-name</code> accessor of a node: see <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-type-name">7.6.13 type-name Accessor</a>.</p></dd><dt><a href="#dt-typed-value">typed value</a></dt><dd><p>The term <b>typed value</b> is defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-typed-value">7.6.14 typed-value Accessor</a>. Every node, other than an element whose type annotation identifies it as having element-only content, has a <a title="string value" class="termref" href="#dt-string-value">typed value</a>. For example, the <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> of an attribute of type <code>xs:IDREFS</code> is a sequence of zero or more <code>xs:IDREF</code> values.</p></dd><dt><a href="#dt-type-error">type error</a></dt><dd><p>Certain errors are classified as <b>type errors</b>. A type error occurs when the value supplied as input to an operation is of the wrong type for that operation, for example when an integer is supplied to an operation that expects a node.</p></dd><dt><a href="#dt-type-pattern">type pattern</a></dt><dd><p>A <b>type pattern</b> is written as <code>~T</code> (where <var>T</var> is an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup>) followed by zero or more predicates in square brackets, and it matches any item of type <var>T</var> for which each of the predicates evaluates to <code>true</code>.</p></dd><dt><a href="#dt-unnamed-mode">unnamed mode</a></dt><dd><p>The <b>unnamed mode</b> is the default mode used when no <code>mode</code> attribute is specified on an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction or <a href="#element-template"><code>xsl:template</code></a> declaration, unless a different <a title="default mode" class="termref" href="#dt-default-mode">default mode</a> has been specified using the <code>[xsl:]default-mode</code> attribute of a containing element.</p></dd><dt><a href="#dt-uri-reference">URI Reference</a></dt><dd><p>Within this specification, the term <b>URI Reference</b>, unless otherwise stated, refers to a string in the lexical space of the <code>xs:anyURI</code> datatype as defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>.</p></dd><dt><a href="#dt-use">use</a></dt><dd><p>If a package <var>Q</var> contains an <a href="#element-use-package"><code>xsl:use-package</code></a> element that references package <var>P</var>, then package <var>Q</var> is said to <b>use</b> package <var>P</var>. In this relationship package <var>Q</var> is referred to as the <b>using</b> package, package <var>P</var> as the <b>used</b> package.</p></dd><dt><a href="#dt-data-element">user-defined data element</a></dt><dd><p>In addition to <a title="declaration" class="termref" href="#dt-declaration">declarations</a>, the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element may contain among its children any element not from the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, provided that the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the element has a non-null namespace URI. Such elements are referred to as <b>user-defined data elements</b>.</p></dd><dt><a href="#dt-vacuous">vacuous</a></dt><dd><p>An item is <b>vacuous</b> if it is one of the following: a zero-length text node; a document node with no children; an atomic item which, on casting to <code>xs:string</code>, produces a zero-length string; or an array which on flattening using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-flatten"><code>array:flatten</code></a> function produces either an empty sequence or a sequence consisting entirely of <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items.</p></dd><dt><a href="#dt-value">value</a></dt><dd><p>A variable is a binding between a name and a value. The <b>value</b> of a variable is any sequence (of nodes, atomic items, and/or function items), as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>.</p></dd><dt><a href="#dt-value-template">value template</a></dt><dd><p>Collectively, attribute value templates and text value templates are referred to as <b>value templates</b>.</p></dd><dt><a href="#dt-variable">variable</a></dt><dd><p>The <a href="#element-variable"><code>xsl:variable</code></a> element declares a <b>variable</b>, which may be a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> or a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a>.</p></dd><dt><a href="#dt-variable-binding-element">variable-binding element</a></dt><dd><p>The two elements <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> are referred to as <b>variable-binding elements</b>.</p></dd><dt><a href="#dt-visibility">visibility</a></dt><dd><p>The <b>visibility</b> of a <a title="component" class="termref" href="#dt-component">component</a> is one of: <code>private</code>, <code>public</code>, <code>abstract</code>, <code>final</code>, or <code>hidden</code>.</p></dd><dt><a href="#dt-whitespace-text-node">whitespace text node</a></dt><dd><p>A <b>whitespace text node</b> is a text node whose content consists entirely of whitespace characters (that is, <span class="unicode-codepoint">U+0009</span> (<span class="unicode-name">TAB</span>) , <span class="unicode-codepoint">U+000A</span> (<span class="unicode-name">NEWLINE</span>) , <span class="unicode-codepoint">U+000D</span> (<span class="unicode-name">CARRIAGE RETURN</span>) , or <span class="unicode-codepoint">U+0020</span> (<span class="unicode-name">SPACE</span>) ).</p></dd><dt><a href="#xml-namespace">XML namespace</a></dt><dd><p>The <b>XML namespace</b>, defined in <a href="#xml-names">[Namespaces in XML]</a> as <code>http://www.w3.org/XML/1998/namespace</code>, is used for attributes such as <code>xml:lang</code>, <code>xml:space</code>, and <code>xml:id</code>.</p></dd><dt><a href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a></dt><dd><p>The term <b>XPath 1.0 compatibility mode</b> is defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#static_context">2.2.1 Static Context</a>. This is a setting in the static context of an XPath expression; it has two values, <code>true</code> and <code>false</code>. When the value is set to <code>true</code>, the semantics of function calls and certain other operations are adjusted to give a greater degree of backwards compatibility between XPath <span>4.0</span> and XPath 1.0.</p></dd><dt><a href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a></dt><dd><p>An element in the stylesheet is processed with <b>XSLT 1.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 1.0.</p></dd><dt><a href="#dt-1.0-compatibility-feature">XSLT 1.0 compatibility feature</a></dt><dd><p>A processor that claims conformance with the <b>XSLT 1.0 compatibility feature</b><span class="verb">must</span> support the processing of stylesheet instructions and XPath expressions with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, as defined in <a href="#backwards"><i>3.8 Backwards Compatible Processing</i></a>.</p></dd><dt><a href="#dt-xslt-20-behavior">XSLT 2.0 behavior</a></dt><dd><p>An element is processed with <b>XSLT 2.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 2.0.</p></dd><dt><a href="#dt-xslt-30-behavior">XSLT 3.0 behavior</a></dt><dd><p>An element is processed with <b>XSLT 3.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 3.0.</p></dd><dt><a href="#dt-xslt-element">XSLT element</a></dt><dd><p>An <b>XSLT element</b> is an element in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> whose syntax and semantics are defined in this specification.</p></dd><dt><a href="#dt-xslt-instruction">XSLT instruction</a></dt><dd><p>An <b>XSLT instruction</b> is an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a> whose syntax summary in this specification contains the annotation <code>&lt;!-- category: instruction --&gt;</code>.</p></dd><dt><a href="#dt-xslt-namespace">XSLT namespace</a></dt><dd><p>The <b>XSLT namespace</b> has the URI <code>http://www.w3.org/1999/XSL/Transform</code>. It is used to identify elements, attributes, and other names that have a special meaning defined in this specification.</p></dd></dl></div><div class="_diffs div1"><h2><a id="implementation-defined-features"></a>F <a href="#implementation-defined-features" style="text-decoration: none">Checklist of Implementation-Defined Features</a> (Non-Normative)</h2><p>This appendix provides a summary of XSLT language features whose effect is explicitly <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The conformance rules (see <a href="#conformance"><i>27 Conformance</i></a>) require vendors to provide documentation that explains how these choices have been exercised.</p><p>The implementation-defined features are grouped into categories for convenience.</p><div class="_diffs div2"><h3><a id="imp-def-ext"></a>F.2 <a href="#imp-def-ext" style="text-decoration: none">Vendor and User Extensions</a></h3><p>This category covers extensions and extensibility: mechanisms for providing vendor or user extensions to the language without sacrificing interoperability.</p><p>In general terms, it is implementation-defined:</p><ul><li><p>whether and under what circumstances the implementation recognizes any extension functions, extension instructions, extension attributes, user-defined data elements, additional types, additional serialization methods or serialization parameters, or additional collations, and if so, what effect they have. </p></li><li><p>whether, how, and under what circumstances the implementation allows users to define extension functions, extension instructions, extension attributes, user-defined data elements, additional types, additional serialization methods or serialization parameters, or additional collations. If it does allow users to do so, it must follow the rules given elsewhere in this specification. </p></li><li><p>what information is available to such extensions (for example, whether they have access to the static and dynamic context.) </p></li><li><p>where such extensions are allowed, the extent to which the processor enforces their correct behavior (for example, checking that strings returned by extension functions contain only valid XML characters) </p></li></ul><p>More specifically:</p><ol><li><p>The mechanisms for creating new <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a> and <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> are implementation-defined. It is not <span class="verb">required</span> that implementations provide any such mechanism. (See <a href="#extensibility"><i>2.9 Extensibility</i></a>)</p></li><li><p>The set of namespaces that are specially recognized by the implementation (for example, for user-defined data elements, and <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a>) is implementation-defined. (See <a href="#user-defined-top-level"><i>3.6.4 User-defined Data Elements</i></a>)</p></li><li><p>The effect of user-defined data elements whose name is in a namespace recognized by the implementation is implementation-defined. (See <a href="#user-defined-top-level"><i>3.6.4 User-defined Data Elements</i></a>)</p></li><li><p>An implementation may define mechanisms, above and beyond <a href="#element-import-schema"><code>xsl:import-schema</code></a>, that allow <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> such as type definitions to be made available within a stylesheet. (See <a href="#built-in-types"><span style="display: none;" class="delete_version"><i>3.13 Built-in Types</i></span><span style="display: none;" class="add_version"><i>3.12 Built-in Types</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">3.13</span><span class="deltaxml-new" style="background:#90EE90">3.12</span> Built-in Types</i></span></a>)</p></li><li><p>The set of extension functions available in the static context for the target expression of <a href="#element-evaluate"><code>xsl:evaluate</code></a> is implementation-defined. (See <a href="#evaluate-static-context"><i>10.5.1 Static context for the target expression</i></a>)</p></li><li><p>If the <code>data-type</code> attribute of the <a href="#element-sort"><code>xsl:sort</code></a> element has a value other than <code>text</code> or <code>number</code>, the effect is implementation-defined. (See <a href="#comparing-sort-keys"><i>13.1.2 Comparing Sort Key Values</i></a>)</p></li><li><p>The effect of an extension function returning a string containing characters that are not permitted in XML is implementation-defined. (See <a href="#calling-extension-functions"><i>24.2.2 Calling Extension Functions</i></a>)</p></li><li><p>The way in which external objects are represented in the type system is implementation-defined. (See <a href="#external-objects"><i>24.2.3 External Objects</i></a>)</p></li></ol></div></div><div class="_diffs div1"><h2><a id="changes-since-3.0"></a>I <a href="#changes-since-3.0" style="text-decoration: none">Changes since XSLT 3.0</a> (Non-Normative)</h2><div class="_diffs div2"><h3><a id="xslt-changes-since-3.0"></a>I.1 <a href="#xslt-changes-since-3.0" style="text-decoration: none">Changes in this specification</a></h3><ol><li><p>If a section of this specification has been updated since version 3.0, an overview of the changes is provided, along with links to navigate to the next or previous change.</p><p>See <a href="#whats-new-in-xslt4"><b>1.2 What’s New in XSLT 4.0?</b></a></p></li><li><p>Sections with significant changes are marked with a ✭ symbol in the table of contents.</p><p>See <a href="#whats-new-in-xslt4"><b>1.2 What’s New in XSLT 4.0?</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/751 1386">751 1386&nbsp;</a></p><p> The result type of a mode can be declared using an <code>as</code> attribute. The result type of all template rules in this mode must be consistent with this, as must the values returned by any built-in template rules for the mode. </p><p>See <a href="#mode-result-type"><b>6.7.5 Declaring the Result Type of a Mode</b></a></p></li><li><p> The <a href="#element-for-each"><code>xsl:for-each</code></a> and <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instructions acquire an attribute <code>separator</code> that can be used to insert content between adjacent items. [This change was in the editor's draft adopted as a baseline when the WG commenced work.] </p><p>See <a href="#for-each"><b>7.1 The xsl:for-each instruction</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2015 2296">2015 2296&nbsp;</a></p><p> A variable-binding with no <code>as</code> or <code>select</code> attribute no longer attempts to create an implicit document node if the sequence constructor contains certain instructions (such as <a href="#element-map"><code>xsl:map</code></a>, <a href="#element-array"><code>xsl:array</code></a>, <a href="#element-record"><code>xsl:record</code></a>, and <a href="#element-select"><code>xsl:select</code></a>). </p><p>See <a href="#variable-values"><b>9.3 Values of Variables and Parameters</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2200 2236">2200 2236&nbsp;</a></p><p> Stylesheet functions may now be in no namespace, and may be invoked without use of a namespace prefix, provided they are private to a package. </p><p>See <a href="#xsl-function-name"><b>10.3.1 Function Name and Arity</b></a></p></li><li><p> Functions that accept a lexical QName as an argument, such as <a href="#func-key"><code>key</code></a>, <a href="#func-function-available"><code>function-available</code></a>, <a href="#func-element-available"><code>element-available</code></a>, <a href="#func-type-available"><code>type-available</code></a>, <a href="#func-system-property"><code>system-property</code></a>, <a href="#func-accumulator-before"><code>accumulator-before</code></a>, and <a href="#func-accumulator-after"><code>accumulator-after</code></a>, now have the option of supplying an <code>xs:QName</code> value instead. [This change was in the editor's draft accepted by the WG as its baseline when it started work.] </p><p>See <a href="#add-func"><b>20 Additional Functions</b></a></p></li><li><p> Functions that accept a lexical QName as an argument, such as <a href="#func-key"><code>key</code></a>, <a href="#func-function-available"><code>function-available</code></a>, <a href="#func-element-available"><code>element-available</code></a>, <a href="#func-type-available"><code>type-available</code></a>, <a href="#func-system-property"><code>system-property</code></a>, <a href="#func-accumulator-before"><code>accumulator-before</code></a>, and <a href="#func-accumulator-after"><code>accumulator-after</code></a>, now have the option of supplying an <code>xs:QName</code> value instead. [This change was in the editor's draft accepted by the WG as its baseline when it started work.] </p><p>See <a href="#extension"><b>24 Extensibility and Fallback</b></a></p></li><li><p>New in 4.0</p><p>See <a href="#func-character-map"><b>26.4.1 fn:character-map</b></a></p></li><li><p> The <a href="#element-for-each"><code>xsl:for-each</code></a> and <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instructions acquire an attribute <code>separator</code> that can be used to insert content between adjacent items. [This change was in the editor's draft adopted as a baseline when the WG commenced work.] </p><p>See <a href="#applying-templates"><b>6.4 Applying Template Rules</b></a></p></li><li><p> It is possible to invoke a named template using an extension instruction, specifically, an element whose name matches the name of the named template. </p><p>See <a href="#invoking-templates-with-extension-instructions"><b>10.1.3 Invoking Named Templates using Extension Instructions</b></a></p><p>See <a href="#extension-instruction"><b>24.3 Extension Instructions</b></a></p></li><li><p> A new attribute <code>xsl:map/@duplicates</code> is available, allowing control over how duplicate keys are handled by the <a href="#element-map"><code>xsl:map</code></a> instruction. </p><p>See <a href="#duplicate-keys"><b>21.1.2 Handling of duplicate keys</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1497 1546">1497 1546&nbsp;</a></p><p> A new serialization parameter <code>json-lines</code> is available to enable output as one JSON value per line. </p><p>See <a href="#creating-result-trees"><b>25.1 Creating Secondary Results</b></a></p><p>See <a href="#id-xsl-output-declaration"><b>26.1 The xsl:output declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/159">159&nbsp;</a></p><p>Parameters on functions declared using <a href="#element-function"><code>xsl:function</code></a> can now be defined as optional, with a default value supplied.</p><p>See <a href="#default-values-of-parameters"><b>9.2.2 Default Values of Parameters</b></a></p><p>See <a href="#stylesheet-functions"><b>10.3 Stylesheet Functions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/237">237&nbsp;</a></p><p> The <a href="#element-if"><code>xsl:if</code></a> instruction now allows <code>then</code> and <code>else</code> attributes. </p><p>See <a href="#xsl-if"><b>8.1 Conditional Processing with xsl:if</b></a></p><p> In <a href="#element-choose"><code>xsl:choose</code></a>, the <a href="#element-when"><code>xsl:when</code></a> and <code>xsl:otherwise</code> elements can take a <code>select</code> attribute in place of a sequence constructor. </p><p>See <a href="#xsl-choose"><b>8.2 Conditional Processing with xsl:choose</b></a></p><p> A new <a href="#element-switch"><code>xsl:switch</code></a> instruction is introduced. </p><p>See <a href="#xsl-switch"><b>8.3 Conditional Processing with xsl:switch</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/326">326&nbsp;</a></p><p> The higher-order-function feature no longer exists; higher-order functions are now a core part of XSLT, no longer an optional extra. </p><p>See <a href="#conformance"><b>27 Conformance</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/353">353&nbsp;</a></p><p> A new attribute, <code>main-module</code>, is added to the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element. The attribute is provided for the benefit of development tools such as syntax-directed editors to provide information about all the components (variables, functions, etc) visible within a stylesheet module. </p><p>See <a href="#stylesheet-element"><b>3.6 Stylesheet Element</b></a></p><p> A new element <a href="#element-note"><code>xsl:note</code></a> is available for documentation and similar purposes: it can appear anywhere in the stylesheet and is ignored by the XSLT processor. </p><p>See <a href="#xsl-note-elements"><span style="display: none;" class="delete_version"><b>3.12.2 The xsl:note element</b></span><span style="display: none;" class="add_version"><b>3.11.2 The xsl:note element</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">3.12.2</span><span class="deltaxml-new" style="background:#90EE90">3.11.2</span> The xsl:note element</b></span></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/401">401&nbsp;</a></p><p> Patterns (especially those used in template rules) can now be defined by reference to item types, so any item type can be used as a match pattern. For example <code>match="~record(longitude, latitude, *)"</code> matches any map that includes the key values <code>"longitude"</code> and <code>"latitude"</code>. </p><p>See <a href="#type-patterns"><b>6.3.2.2 Type Patterns</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/406">406&nbsp;</a></p><p> The new instruction <a href="#element-array"><code>xsl:array</code></a> is introduced to allow construction of arrays. </p><p>See <a href="#array-construction"><b>22.1 Array Construction</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/470">470&nbsp;</a></p><p> The <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a> element may have a <code>fixed-namespaces</code> attribute making it easier to have the same namespace declarations in force throughout a stylesheet. </p><p>See <a href="#fixed-namespaces"><b>3.6.1 The fixed-namespaces Attribute</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/489">489&nbsp;</a></p><p> The <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> and <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> elements within <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> may now take a <code>select</code> attribute in place of a contained sequence constructor. </p><p>See <a href="#analyze-string"><b>17.1 The xsl:analyze-string Instruction</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/534">534&nbsp;</a></p><p> A new serialization parameter <code>escape-solidus</code> is provided to control whether the character <code>/</code> is escaped as <code>\/</code> by the JSON serialization method. </p><p>See <a href="#creating-result-trees"><b>25.1 Creating Secondary Results</b></a></p><p>See <a href="#id-xsl-output-declaration"><b>26.1 The xsl:output declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/542">542&nbsp;</a></p><p> A mode (called an enclosing mode) can be defined in which all the relevant template rules are children of the <code>xsl:mode</code> element. This is intended to allow a stylesheet design in which it is easier to determine which rules might apply to a given <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> call. </p><p>See <a href="#enclosing-modes"><b>6.7.6 Enclosing Modes</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/599">599&nbsp;</a></p><p> Simplified stylesheets no longer require an <code>xsl:version</code> attribute (which means they might not need a declaration of the XSLT namespace). Unless otherwise specified, a 4.0 simplified stylesheet defaults <code>expand-text</code> to <code>true</code>. </p><p>See <a href="#simplified-stylesheet"><b>3.7 Simplified Stylesheet Modules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/635">635&nbsp;</a></p><p> The rules concerning the compatibility of schemas imported by different packages have been clarified. It is now explicitly stated that instructions that trigger validation must use the imported schema of the package in which validation is invoked. This differs from the current practice of some XSLT 3.0 processors, which may use (for example) a schema formed from the union of the imported schemas in all packages. </p><p>See <a href="#import-schema"><span style="display: none;" class="delete_version"><b>3.14 Importing Schema Components</b></span><span style="display: none;" class="add_version"><b>3.13 Importing Schema Components</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">3.14</span><span class="deltaxml-new" style="background:#90EE90">3.13</span> Importing Schema Components</b></span></a></p><p>See <a href="#validation"><b>25.4 Validation</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/717">717&nbsp;</a></p><p> Capturing accumulators have been added; when streaming with a capturing accumulator, the <a href="#func-accumulator-after"><code>accumulator-after</code></a> has full access to a snapshot of the matched element node. </p><p>See <a href="#capturing-accumulators"><b>19.9 Capturing Accumulators</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/718">718&nbsp;</a></p><p> To allow recursive-descent transformation on a tree of maps and arrays, a new set of built-in templates rules <code>shallow-copy-all</code> is introduced. </p><p>See <a href="#built-in-rule"><b>6.8 Built-in Template Rules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/740">740&nbsp;</a></p><p> A new attribute <code>xsl:for-each-group/@split-when</code> is available to give applications more complete control over how a sequence is partitioned </p><p>See <a href="#grouping"><b>14 Grouping</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/751">751&nbsp;</a></p><p> The <a href="#element-mode"><code>xsl:mode</code></a> declaration acquires an attribute <code>as="sequence-type"</code> which declares the return type of all template rules in that mode. </p><p>See <a href="#declaring-modes"><b>6.7.1 Declaring Modes</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1181">1181&nbsp;</a></p><p> The <code>[xsl:]xpath-default-namespace</code> attribute can be set to the value <code>##any</code>, which causes unprefixed element names to match in any namespace or none. </p><p>See <a href="#unprefixed-qnames"><b>5.1.2 Unprefixed Lexical QNames in Expressions and Patterns</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1250">1250&nbsp;</a></p><p> The strings used in the formatted number to represent a decimal separator, grouping separator, exponent separator, percent sign, per mille sign, or minus sign, are no longer constrained to be single characters. </p><p>See <a href="#defining-decimal-format"><b>5.5 Defining a Decimal Format</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1254">1254&nbsp;</a></p><p> The rules concerning the interpretation of <code>xsi:schemaLocation</code> and <code>xsi:noNamespaceSchemaLocation</code> attributes have been tightened up. </p><p>See <a href="#validation"><b>25.4 Validation</b></a></p><p>See <a href="#validation"><b>25.4 Validation</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1306">1306&nbsp;</a></p><p> An <code>as</code> attribute is available on the <a href="#element-sequence"><code>xsl:sequence</code></a> instruction. </p><p>See <a href="#constructing-sequences"><b>10.4.1 The xsl:sequence Instruction</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1361">1361&nbsp;</a></p><p> The term <b>atomic value</b> has been replaced by <b>atomic item</b>. </p><p>See <a href="#terminology"><b>2.1 Terminology</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1378">1378&nbsp;</a></p><p> A function call at the outermost level can now be named using any valid <code>EQName</code> (for example <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>fn:doc</code></a>) provided it binds to one of the permitted functions <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>fn:doc</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-id"><code>fn:id</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-element-with-id"><code>fn:element-with-id</code></a>, <a href="#func-key"><code>fn:key</code></a>, or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-root"><code>fn:root</code></a>. If two functions are called, for example <code>doc('a.xml')/id('abc')</code>, it is no longer necessary to put the second call in parentheses. </p><p>See <a href="#node-patterns"><b>6.3.2.3 GNode Patterns</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1442">1442&nbsp;</a></p><p> Default priorities are added for new forms of <code>ElementTest</code> and <code>AttributeTest</code>, for example <code>element(p:*)</code> and <code>element(a|b)</code>. </p><p>See <a href="#default-priority"><b>6.3.3 Default Priority for Patterns</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1454">1454&nbsp;</a></p><p> Duplicate <a href="#element-include"><code>xsl:include</code></a> declarations within a stylesheet level are now ignored, preventing spurious errors caused by the presence of duplicate named components. </p><p>See <a href="#include"><b>3.10.2 Stylesheet Inclusion</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1505">1505&nbsp;</a></p><p> New variables <code>err:stack-trace</code>, <code>err:additional</code>, and <code>err:map</code> are available within an <a href="#element-catch"><code>xsl:catch</code></a> clause. </p><p>See <a href="#try-catch"><b>8.4 Try/Catch</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1530">1530&nbsp;</a></p><p> The contents of a character map declared using <a href="#element-character-map"><code>xsl:character-map</code></a> are now available dynamically via a new <a href="#func-character-map"><code>character-map</code></a> function. </p><p>See <a href="#character-map-function"><b>26.4 The character-map function</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1544">1544&nbsp;</a></p><p> It is no longer an intrinsic error for a global variable to refer to itself; this is now permitted, for example in cases where the value of the global variable is a recursive inline function. Cases where self-reference would not make sense are covered by the existing rules on circularities: see <a href="#circularity"><i>9.11 Circular Definitions</i></a>. </p><p>See <a href="#global-variables"><b>9.5 Global Variables and Parameters</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1549">1549&nbsp;</a></p><p> The input to the serializer can be defined using the <code>select</code> attribute of <a href="#element-result-document"><code>xsl:result-document</code></a> as an alternative to using a sequence constructor. </p><p>See <a href="#creating-result-trees"><b>25.1 Creating Secondary Results</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1560">1560&nbsp;</a></p><p> The default value for the <code>indent</code> parameter is now defined to be <code>no</code> for all output methods other than <code>html</code> and <code>xhtml</code>. </p><p>See <a href="#id-default-serialization-parameters"><b>26.2 Serialization parameters</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1617">1617&nbsp;</a></p><p> Named item types can be declared using the new <a href="#element-item-type"><code>xsl:item-type</code></a> element. This is designed to avoid repeating lengthy type definitions (for example function types) every time they are used. </p><p>See <a href="#named-item-types"><b>5.4.1 Named Item Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1622">1622&nbsp;</a></p><p>The rules for equality comparison have changed to bring keys into line with maps.</p><p>See <a href="#func-key"><b>20.2.2 fn:key</b></a></p><p>New in 4.0.</p><p>See <a href="#func-map-for-key"><b>20.2.3 fn:map-for-key</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1674">1674&nbsp;</a></p><p> Composite sort keys are allowed in <a href="#element-sort"><code>xsl:sort</code></a>. </p><p>See <a href="#comparing-sort-keys"><b>13.1.2 Comparing Sort Key Values</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1689">1689&nbsp;</a></p><p> Composite merge keys are now allowed. </p><p>See <a href="#merging"><b>15 Merging</b></a></p><p>New in 4.0</p><p>See <a href="#func-current-merge-key-array"><b>15.5.2 fn:current-merge-key-array</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1694">1694&nbsp;</a></p><p> The <a href="#element-map"><code>xsl:map</code></a> instruction allows a <code>select</code> attribute as an alternative to the contained sequence constructor. </p><p>See <a href="#map-instructions"><b>21.1 Map Instructions</b></a></p><p> The <a href="#element-map-entry"><code>xsl:map-entry</code></a> instruction, in common with other instructions, now raises error XTSE3185 (rather than XTSE3280) if both a <code>select</code> attribute and a sequence constructor are present. </p><p>See <a href="#map-instructions"><b>21.1 Map Instructions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1703">1703&nbsp;</a></p><p> Ordered maps are introduced. </p><p>See <a href="#map-instructions"><b>21.1 Map Instructions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1708">1708&nbsp;</a></p><p> Named record types are introduced. </p><p>See <a href="#named-record-types"><b>5.4.2 Named Record Types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1772">1772&nbsp;</a></p><p> The default priority for a template rule using a union pattern has changed. This change may cause incompatible behavior. </p><p>See <a href="#default-priority"><b>6.3.3 Default Priority for Patterns</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1819">1819&nbsp;</a></p><p> Different parts of a stylesheet may now use different imported schemas. </p><p>See <a href="#stylesheets-and-schemas"><b>2.10 Stylesheets and XML Schemas</b></a></p><p> The standard attribute <code>[xsl:]schema-role</code> is introduced, to allow different parts of a stylesheet to use different schemas. </p><p>See <a href="#standard-attributes"><b>3.3 Standard Attributes</b></a></p><p> Different parts of a stylesheet may now use different imported schemas. </p><p>See <a href="#import-schema"><span style="display: none;" class="delete_version"><b>3.14 Importing Schema Components</b></span><span style="display: none;" class="add_version"><b>3.13 Importing Schema Components</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">3.14</span><span class="deltaxml-new" style="background:#90EE90">3.13</span> Importing Schema Components</b></span></a></p><p> A stylesheet can import multiple schemas with different schema role names. </p><p>See <a href="#multiple-schemas"><span style="display: none;" class="delete_version"><b>3.14.1 Multiple Schemas</b></span><span style="display: none;" class="add_version"><b>3.13.1 Multiple Schemas</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">3.14.1</span><span class="deltaxml-new" style="background:#90EE90">3.13.1</span> Multiple Schemas</b></span></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1856">1856&nbsp;</a></p><p> The rules for <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> have been adjusted to allow for new capabilities in regular expressions, such as zero-width assertions. </p><p>See <a href="#analyze-string"><b>17.1 The xsl:analyze-string Instruction</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1858">1858&nbsp;</a></p><p> The <a href="#element-record"><code>xsl:record</code></a> instruction is introduced to make construction of record maps simpler. </p><p>See <a href="#record-instructions"><b>21.1.1 Record Instruction</b></a></p><p> Attribute <code>xsl:record/@xsl:duplicates</code> is added to control duplicate keys handling in the <a href="#element-record"><code>xsl:record</code></a> instruction. </p><p>See <a href="#duplicate-keys"><b>21.1.2 Handling of duplicate keys</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1875">1875&nbsp;</a></p><p> The <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> and <a href="#element-next-match"><code>xsl:next-match</code></a> instructions automatically pass supplied parameters to the overridden template rule. </p><p>See <a href="#apply-imports"><b>6.9 Overriding Template Rules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1888">1888&nbsp;</a></p><p>A new XSLT element, <code>xsl:package-location</code> is provide to indicate to the processor where the required package is to be found.</p><p>See <a href="#package-locations"><b>3.4.3 Locating Packages</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1929">1929&nbsp;</a></p><p> The <a href="#element-mode"><code>xsl:mode</code></a> declaration acquires an attribute <code>copy-namespaces</code> which determines whether or not the built-in template rule copies unused namespace bindings. </p><p>See <a href="#declaring-modes"><b>6.7.1 Declaring Modes</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2006">2006&nbsp;</a></p><p>A new function <code>fn:apply-templates</code> is introduced.</p><p>See <a href="#apply-templates-function"><b>6.7.3 The apply-templates Function</b></a></p><p>New in 4.0</p><p>See <a href="#func-apply-templates"><b>6.7.3.1 fn:apply-templates</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2008">2008&nbsp;</a></p><p> The <a href="#element-select"><code>xsl:select</code></a> instruction is new in 4.0. </p><p>See <a href="#select-instruction"><b>10.4.2 The xsl:select Instruction</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2030">2030&nbsp;</a></p><p> In order to reduce duplication between the XSLT and XQuery specifications, description of the validation process has been moved to the <em>Functions and Operators</em> specification. </p><p>See <a href="#validation"><b>25.4 Validation</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2123">2123&nbsp;</a></p><p> A new attribute <code>xsl:for-each-group/@merge-when</code> is available to give applications control to create groups based on clustering, overlap, and networks. </p><p>See <a href="#grouping"><b>14 Grouping</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2200">2200&nbsp;</a></p><p>User-defined functions can now have names that are in no namespace. An unprefixed name appearing in a function call is resolved to a no-namespace function with matching local name in preference to a function in the standard <code>fn</code> namespace.</p><p>See <a href="#stylesheet-functions"><b>10.3 Stylesheet Functions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2213">2213&nbsp;</a></p><p> A new attribute <code>trusted=yes|no</code> is added to <a href="#element-evaluate"><code>xsl:evaluate</code></a> to indicate whether the XPath expression to be evaluated is trusted to access external resources. The default value is <code>no</code>, which may cause backwards incompatibility. Dynamic evaluation using <a href="#element-evaluate"><code>xsl:evaluate</code></a> is no longer an optional feature of the XSLT language. </p><p>See <a href="#dynamic-xpath"><b>10.5 Dynamic XPath Evaluation</b></a></p><p> The dynamic evaluation feature no longer exists; processor are now required to support the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction. </p><p>See <a href="#conformance"><b>27 Conformance</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2218">2218&nbsp;</a></p><p> Numeric values of type <code>xs:decimal</code> are compared as decimals, without first converting to <code>xs:double</code>. </p><p>See <a href="#comparing-sort-keys"><b>13.1.2 Comparing Sort Key Values</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2251">2251&nbsp;</a></p><p> The <a href="#element-text"><code>xsl:text</code></a> instruction can now have a <code>select</code> attribute, and it can take a sequence constructor as its content. The only remaining distinction between the <a href="#element-text"><code>xsl:text</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a> instructions is that whitespace text node children of <a href="#element-text"><code>xsl:text</code></a> are treated as significant, rather than being stripped during stylesheet preprocessing. </p><p>See <a href="#creating-text-nodes"><b>11.4 Creating Text Nodes</b></a></p><p>The rules for <a href="#element-text"><code>xsl:text</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a> are integrated, allowing <a href="#element-text"><code>xsl:text</code></a> to be used to construct all text nodes, whether the content is fixed or variable.</p><p>See <a href="#xsl-text"><b>11.4.2 The xsl:text and xsl:value-of instructions</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2259">2259&nbsp;</a></p><p> A new serialization parameter <code>canonical</code> is available to give control over serialization of XML, XHTML, and JSON. </p><p>See <a href="#creating-result-trees"><b>25.1 Creating Secondary Results</b></a></p><p>See <a href="#id-xsl-output-declaration"><b>26.1 The xsl:output declaration</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2274">2274&nbsp;</a></p><p></p><p>XSLT-specific components of the dynamic context can now be retained in the captured context of a function item, in the same way as XPath-defined components of the dynamic context.</p><p></p><p>See <a href="#additional-dynamic-context"><b>5.3.4 Additional Dynamic Context Components used by XSLT</b></a></p><p>In XSLT 4.0, the function item <code>current-group#0</code> retains the value of the current group within its captured context.</p><p>See <a href="#func-current-group"><b>14.2.1 fn:current-group</b></a></p><p>In XSLT 4.0, the function item <code>current-grouping-key#0</code> retains the value of the current grouping key within its captured context.</p><p>See <a href="#func-current-grouping-key"><b>14.2.2 fn:current-grouping-key</b></a></p><p>In XSLT 4.0, the function item <code>current-merge-group</code> retains the value of the current merge-key within its captured context.</p><p>See <a href="#func-current-merge-group"><b>15.5.1 fn:current-merge-group</b></a></p><p>In XSLT 4.0, the function item <code>current-merge-key#0</code> retains the value of the current group within its captured context.</p><p>See <a href="#func-current-merge-key"><b>15.5.3 fn:current-merge-key</b></a></p><p>In XSLT 4.0, the function item <code>regex-group#1</code> retains the value of the current captured substrings within its captured context.</p><p>See <a href="#func-regex-group"><b>17.2.2 fn:regex-group</b></a></p><p>In XSLT 4.0, the function item <code>current#0</code> retains the value of the current item within its captured context.</p><p>See <a href="#func-current"><b>20.5.1 fn:current</b></a></p><p>In XSLT 4.0, the function item <code>current-output-uri#0</code> retains the value of the current output URI within its captured context.</p><p>See <a href="#func-current-output-uri"><b>25.3.1 fn:current-output-uri</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2283">2283&nbsp;</a></p><p>The conformance requirements for extension attributes have been relaxed: the requirement to maintain strict conformance to the specification in the presence of extension attributes is now a <span class="verb">should</span> rather than a <span class="verb">must</span>, and extension attributes are allowed to modify the form of serialized output without limitation.</p><p>See <a href="#extension-attributes"><b>24.1 Extension Attributes</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2301">2301&nbsp;</a></p><p>The attribute <code>cdata</code> is added to <a href="#element-text"><code>xsl:text</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a> to request serialization of a text node as a CDATA section.</p><p>See <a href="#xsl-text"><b>11.4.2 The xsl:text and xsl:value-of instructions</b></a></p><p>See <a href="#generating-cdata"><b>11.4.3 Generating CDATA Sections</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2323">2323&nbsp;</a></p><p> The outermost element of a simplified stylesheet need no longer be a literal result element, it can now be any instruction (including <a href="#element-result-document"><code>xsl:result-document</code></a>). This allows a simplified stylesheet to produce JSON output as well as XML or HTML. </p><p>See <a href="#simplified-stylesheet"><b>3.7 Simplified Stylesheet Modules</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2736">2736&nbsp;</a></p><p></p><p>The <code>xsl:mode/@typed</code> attribute has been clarified and expanded to provide better control over the handling of items other than XNodes.</p><p></p><p>See <a href="#xsl-mode-typed"><b>6.7.4 Declaring the Type of Values Processed by a Mode</b></a></p></li></ol></div></div></div><p role="navigation" id="back-to-top"><a href="#title"><abbr title="Back to top">↑</abbr></a></p><script src="js/toc.js"></script><script src="/js/scroll.js"></script></body></html>