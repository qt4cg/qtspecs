<!DOCTYPE HTML><html xmlns="http://www.w3.org/1999/xhtml" lang="EN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>XPath and XQuery Functions and Operators 4.0 </title><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link rel="stylesheet" type="text/css" href="css/w3c-base.css"><link rel="stylesheet" href="css/qtspecs.css"><link rel="stylesheet" href="css/xpath-functions-40.css"><script src="js/fo-datalist.js"></script><style type="text/css">
          body { margin-top: 50px }
          a.button { background: #DDD; border: 2px outset black; padding: 2px; margin: 2px; font-family: sans-serif; font-size: small;}
          a.button:hover { cursor:pointer; }
          a.button:active { border-style: inset; }
        </style><link rel="stylesheet" href="/css/autodiff.css"></head><body class="toc-inline"><div style="position:fixed; clear:both; top:0px" id="_autodiff_buttons"><p><a class="button" onclick="view('old')">
              View Old
            </a><a class="button" onclick="view('new')">
              View New
            </a><a class="button" onclick="view('both')">
              View Both
            </a><a class="button" onclick="view('only')">
              View Only
            </a><a class="button" onclick="scroll_to('prev')">
              Previous
            </a><a class="button" onclick="scroll_to('next')">
              Next
            </a><span id="__autodiff__"></span></p><p>This draft contains only sections that have differences from the version that it modified.</p></div><div class="head"><p><a href="https://www.w3.org/"><img src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C" alt="W3C" height="48" width="72"></a></p><h1><a id="title"></a>XPath and XQuery Functions and Operators 4.0 </h1><h2><a id="w3c-doctype"></a>W3C Editor's Draft 2&nbsp;February&nbsp;2026</h2><dl><dt>This version:</dt><dd><a href="https://qt4cg.org/specifications/xpath-functions-40/">https://qt4cg.org/specifications/xpath-functions-40/</a></dd><dt>Latest version of XPath and XQuery Functions and Operators 4.0:</dt><dd><a href="https://qt4cg.org/specifications/xpath-functions-40/">https://qt4cg.org/specifications/xpath-functions-40/</a></dd><dt>Most recent Recommendation of XPath and XQuery Functions and Operators:</dt><dd><a href="https://www.w3.org/TR/2017/REC-xpath-functions-31-20170321/">https://www.w3.org/TR/2017/REC-xpath-functions-31-20170321/</a></dd><dt>Editor:</dt><dd>Michael Kay, Saxonica <a href="http://www.saxonica.com/">&lt;http://www.saxonica.com/&gt;</a></dd></dl><p>This document is also available in these non-normative formats: <a href="xpath-functions-40.xml">Specification in XML format</a> and&nbsp;<a href="function-catalog.xml">XML function catalog</a>.</p><p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;©&nbsp;2000&nbsp;<a href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="https://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="https://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="https://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p><hr></div><div><h2><a id="abstract"></a>Abstract</h2><p>This document defines constructor functions, operators, and functions on the datatypes defined in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> and the datatypes defined in <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>. It also defines functions and operators on nodes and node sequences as defined in the <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>. These functions and operators are defined for use in <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a> and <a href="#xquery-40">[XQuery 4.0: An XML Query Language]</a> and <a href="#xslt-40">[XSL Transformations (XSLT) Version 4.0]</a> and other related XML standards. The signatures and summaries of functions defined in this document are available at: <a href="http://www.w3.org/2005/xpath-functions/">http://www.w3.org/2005/xpath-functions/</a>.</p><p>A summary of changes since version 3.1 is provided at <a href="#changelog"><b>H Changes since 3.1</b></a>.</p></div><div><h2><a id="status"></a>Status of this Document</h2><p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document.</em></p><p>This document is a working draft developed and maintained by a W3C Community Group, the <a href="https://www.w3.org/community/xslt-40/">XQuery and XSLT Extensions Community Group</a> unofficially known as QT4CG (where "QT" denotes Query and Transformation). This draft is work in progress and should not be considered either stable or complete. Standard W3C copyright and patent conditions apply.</p><p>The community group welcomes comments on the specification. Comments are best submitted as issues on the group's <a href="https://github.com/qt4cg/qtspecs/issues">GitHub repository</a>.</p><p id="at-risk">As the Community Group moves towards publishing dated, stable drafts, some features that the group thinks may likely be removed or substantially changed are marked “at risk” in their changes section. In this draft:</p><ul><li><a href="#func-array-members">array:members</a></li><li><a href="#func-array-of-members">array:of-members</a></li></ul><p>The community group maintains two extensive test suites, one oriented to XQuery and XPath, the other to XSLT. These can be found at <a href="https://github.com/qt4cg/qt4tests">qt4tests</a> and <a href="https://github.com/qt4cg/xslt40-test">xslt40-test</a> respectively. New tests, or suggestions for correcting existing tests, are welcome. The test suites include extensive metadata describing the conditions for applicability of each test case as well as the expected results. They do not include any test drivers for executing the tests: each implementation is expected to provide its own test driver.</p><div class="dedication" id="dedication"><h3>Dedication</h3><p>The publications of this community group <a href="../xquery-40/xpath-40.html#dedication">are dedicated</a> to our co-chair, Michael Sperberg-McQueen&nbsp;(1954–2024).</p></div></div><hr><div class="body"><div class="_diffs div1"><h2><a id="sequence-functions"></a>2 <a href="#sequence-functions" style="text-decoration: none">Processing sequences</a></h2><p>A <code>sequence</code> is an ordered collection of zero or more <code>items</code>. An <code>item</code> is a node, an atomic item, or a function, such as a map or an array. The terms <code>sequence</code> and <code>item</code> are defined formally in <a href="#xquery-40">[XQuery 4.0: An XML Query Language]</a> and <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a>. </p><div class="_diffs div2"><h3><a id="basic-hofs"></a>2.5 <a href="#basic-hofs" style="text-decoration: none">Basic higher-order functions</a></h3><p>The following functions take function items as an argument.</p><table class="index"><thead><tr><th>Function</th><th>Meaning</th></tr></thead><tbody><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-apply"><code>fn:apply</code></a></td><td>Makes a dynamic call on a function with an argument list supplied in the form of an array.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-do-until"><code>fn:do-until</code></a></td><td>Processes a supplied value repeatedly, continuing when some condition is false, and returning the value that satisfies the condition.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-every"><code>fn:every</code></a></td><td>Returns <code>true</code> if every item in the input sequence matches a supplied predicate.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-filter"><code>fn:filter</code></a></td><td>Returns those items from the sequence <code>$input</code> for which the supplied function <code>$predicate</code> returns <code>true</code>.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-fold-left"><code>fn:fold-left</code></a></td><td>Processes the supplied sequence from left to right, applying the supplied function repeatedly to each item in turn, together with an accumulated result value.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-fold-right"><code>fn:fold-right</code></a></td><td>Processes the supplied sequence from right to left, applying the supplied function repeatedly to each item in turn, together with an accumulated result value.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-for-each"><code>fn:for-each</code></a></td><td>Applies the function item <code>$action</code> to every item from the sequence <var>$input</var> in turn, returning the concatenation of the resulting sequences in order.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-for-each-pair"><code>fn:for-each-pair</code></a></td><td>Applies the function item <code>$action</code> to successive pairs of items taken one from <code>$input1</code> and one from <code>$input2</code>, returning the concatenation of the resulting sequences in order.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-highest"><code>fn:highest</code></a></td><td>Returns a value that is greater than or equal to every other value appearing in the input sequence.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-index-where"><code>fn:index-where</code></a></td><td>Returns the positions in an input sequence of items that match a supplied predicate.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-lowest"><code>fn:lowest</code></a></td><td>Returns those items from a supplied sequence that have the lowest value of a sort key, where the sort key can be computed using a caller-supplied function.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-partial-apply"><code>fn:partial-apply</code></a></td><td>Performs partial application of a function item by binding values to selected arguments.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-partition"><code>fn:partition</code></a></td><td>Partitions a sequence of items into a sequence of non-empty arrays containing the same items, starting a new partition when a supplied condition is true.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-scan-left"><code>fn:scan-left</code></a></td><td>Produces the sequence of successive partial results from the evaluation of <a href="#func-fold-left"><code>fn:fold-left</code></a> with the same arguments.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-scan-right"><code>fn:scan-right</code></a></td><td>Produces the sequence of successive partial results from the evaluation of <a href="#func-fold-right"><code>fn:fold-right</code></a> with the same arguments.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-some"><code>fn:some</code></a></td><td>Returns <code>true</code> if at least one item in the input sequence matches a supplied predicate.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-sort"><code>fn:sort</code></a></td><td>Sorts a supplied sequence, based on the value of a sort key supplied as a function.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-sort-by"><code>fn:sort-by</code></a></td><td>Sorts a supplied sequence, based on the value of a number of sort keys supplied as functions.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-sort-with"><code>fn:sort-with</code></a></td><td>Sorts a supplied sequence, according to the order induced by the supplied comparator functions.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-subsequence-where"><code>fn:subsequence-where</code></a></td><td>Returns a contiguous sequence of items from <code>$input</code>, with the start and end points located by applying predicates.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-take-while"><code>fn:take-while</code></a></td><td>Returns items from the input sequence prior to the first one that fails to match a supplied predicate.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-transitive-closure"><code>fn:transitive-closure</code></a></td><td>Returns all the GNodes reachable from a given start GNode by applying a supplied function repeatedly.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-while-do"><code>fn:while-do</code></a></td><td>Processes a supplied value repeatedly, continuing while some condition remains true, and returning the first value that does not satisfy the condition.</td></tr></tbody></table><p>With all these functions, if the caller-supplied function fails with a dynamic error, this error is propagated as an error from the higher-order function itself.</p><div class="_diffs div3"><h4><a id="func-highest"></a>2.5.9 <a href="#func-highest" style="text-decoration: none">fn:highest</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#func-index-where">next</a> | <a href="#func-for-each-pair">previous</a>)</p><ol><li><p>New in 4.0<i>&nbsp;&nbsp;[&nbsp;&nbsp;20 September 2022]</i></p></li></ol></div><dl><dt class="label">Summary</dt><dd><p>Returns a value that is greater than or equal to every other value appearing in the input sequence.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">fn:highest</code>(</td></tr><tr class="arg"><td><code>$input</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>item()*</code></code>,</td><td></td></tr><tr class="arg"><td><code>$collation</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:string?</code></code></td><td><code class="assign">:=&nbsp;</code><code>fn:default-collation()</code>,</td></tr><tr class="arg"><td><code>$key</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>(fn(item()) as xs:anyAtomicType*)?</code></code></td><td><code class="assign">:=&nbsp;</code><code>fn:data#1</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>item()*</code></code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-dependent" class="termref" href="#dt-context-dependent">context-dependent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. It depends on collations. </p></dd><dt class="label">Rules</dt><dd><p><span class="deltaxml-old" style="background:#FF5555">Any item in </span><code><span class="deltaxml-old" style="background:#FF5555">$values</span></code><span class="deltaxml-old" style="background:#FF5555"> that is an instance of </span><code><span class="deltaxml-old" style="background:#FF5555">xs:untypedAtomic</span></code><span class="deltaxml-old" style="background:#FF5555"> is first cast to </span><code><span class="deltaxml-old" style="background:#FF5555">xs:double</span></code><span class="deltaxml-old" style="background:#FF5555">. The resulting sequence is referred to as the converted sequence.</span></p><p><span class="deltaxml-old" style="background:#FF5555">All pairs of values in the converted sequence must be mutually comparable. Two values </span><var><span class="deltaxml-old" style="background:#FF5555">A</span></var><span class="deltaxml-old" style="background:#FF5555"> and </span><var><span class="deltaxml-old" style="background:#FF5555">B</span></var><span class="deltaxml-old" style="background:#FF5555"> are mutually comparable if </span><code><span class="deltaxml-old" style="background:#FF5555">fn:compare(</span><var><span class="deltaxml-old" style="background:#FF5555">A</span></var><span class="deltaxml-old" style="background:#FF5555">, </span><var><span class="deltaxml-old" style="background:#FF5555">B</span></var><span class="deltaxml-old" style="background:#FF5555">)</span></code><span class="deltaxml-old" style="background:#FF5555"> raises no error.</span></p><p><span class="deltaxml-old" style="background:#FF5555">If the converted sequence is empty, the function returns the empty sequence.</span></p><p><span class="deltaxml-old" style="background:#FF5555">If the converted sequence contains the value </span><code><span class="deltaxml-old" style="background:#FF5555">NaN</span></code><span class="deltaxml-old" style="background:#FF5555">, the value </span><code><span class="deltaxml-old" style="background:#FF5555">NaN</span></code><span class="deltaxml-old" style="background:#FF5555"> is returned </span><span><span class="deltaxml-old" style="background:#FF5555">(as an </span><code><span class="deltaxml-old" style="background:#FF5555">xs:float</span></code><span class="deltaxml-old" style="background:#FF5555"> or </span><code><span class="deltaxml-old" style="background:#FF5555">xs:double</span></code><span class="deltaxml-old" style="background:#FF5555"> as appropriate)</span></span><span class="deltaxml-old" style="background:#FF5555">.</span></p><p><span class="deltaxml-old" style="background:#FF5555">Two items </span><var><span class="deltaxml-old" style="background:#FF5555">A</span></var><span class="deltaxml-old" style="background:#FF5555"> and </span><var><span class="deltaxml-old" style="background:#FF5555">B</span></var><span class="deltaxml-old" style="background:#FF5555"> from the converted sequence are compared by calling </span><code><span class="deltaxml-old" style="background:#FF5555">fn:compare(</span><var><span class="deltaxml-old" style="background:#FF5555">A</span></var><span class="deltaxml-old" style="background:#FF5555">, </span><var><span class="deltaxml-old" style="background:#FF5555">B</span></var><span class="deltaxml-old" style="background:#FF5555">, $collation)</span></code><span class="deltaxml-old" style="background:#FF5555">, where </span><code><span class="deltaxml-old" style="background:#FF5555">$collation</span></code><span class="deltaxml-old" style="background:#FF5555"> is determined by the rules in </span><a href="#choosing-a-collation"><b><span class="deltaxml-old" style="background:#FF5555">5.3.7 Choosing a collation</span></b></a><span class="deltaxml-old" style="background:#FF5555">:</span></p><p><span class="deltaxml-old" style="background:#FF5555">The result of the function is a value from the converted sequence that is greater than or equal to every other value under the above rules. If there is more than one such value, then it is </span><a title="implementation-dependent" class="termref" href="#implementation-dependent"><span class="deltaxml-old" style="background:#FF5555">implementation-dependent</span></a><span class="deltaxml-old" style="background:#FF5555"> which of them is returned.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The second argument, </span><code><span class="deltaxml-new" style="background:#90EE90">$collation</span></code><span class="deltaxml-new" style="background:#90EE90">, defaults to </span><code><span class="deltaxml-new" style="background:#90EE90">()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Supplying an empty sequence as </span><code><span class="deltaxml-new" style="background:#90EE90">$collation</span></code><span class="deltaxml-new" style="background:#90EE90"> is equivalent to supplying </span><code><span class="deltaxml-new" style="background:#90EE90">fn:default-collation()</span></code><span class="deltaxml-new" style="background:#90EE90">. For more information on collations see </span><a href="#choosing-a-collation"><b><span class="deltaxml-new" style="background:#90EE90">5.3.7 Choosing a collation</span></b></a><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The third argument, </span><code><span class="deltaxml-new" style="background:#90EE90">$key</span></code><span class="deltaxml-new" style="background:#90EE90">, defaults to the function </span><code><span class="deltaxml-new" style="background:#90EE90">data#1</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Let </span><code><span class="deltaxml-new" style="background:#90EE90">$modified-key</span></code><span class="deltaxml-new" style="background:#90EE90"> be the function:</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">fn($item) {
  $key($item) =&gt; data() ! (
    if (. instance of xs:untypedAtomic) then xs:double(.) else .
  )
}</span></pre></div><p><span class="deltaxml-new" style="background:#90EE90">That is, the supplied function for computing key values is wrapped in a function that converts any </span><code><span class="deltaxml-new" style="background:#90EE90">xs:untypedAtomic</span></code><span class="deltaxml-new" style="background:#90EE90"> values in its result to </span><code><span class="deltaxml-new" style="background:#90EE90">xs:double</span></code><span class="deltaxml-new" style="background:#90EE90">. This makes the function consistent with the behavior of </span><a href="#func-min"><code><span class="deltaxml-new" style="background:#90EE90">fn:min</span></code></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a href="#func-max"><code><span class="deltaxml-new" style="background:#90EE90">fn:max</span></code></a><span class="deltaxml-new" style="background:#90EE90">, but inconsistent with </span><a href="#func-sort"><code><span class="deltaxml-new" style="background:#90EE90">fn:sort</span></code></a><span class="deltaxml-new" style="background:#90EE90">, which treats untyped values as strings.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The result of the function is obtained as follows:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">If the input is an empty sequence, the result is an empty sequence.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The input sequence is sorted, by applying the function </span><code><span class="deltaxml-new" style="background:#90EE90">fn:sort($input, $collation, $modified-key)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Let </span><var><span class="deltaxml-new" style="background:#90EE90">$C</span></var><span class="deltaxml-new" style="background:#90EE90"> be the selected collation, or the default collation where applicable.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Let </span><var><span class="deltaxml-new" style="background:#90EE90">$B</span></var><span class="deltaxml-new" style="background:#90EE90"> be the last item in the sorted sequence.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The function returns those items </span><var><span class="deltaxml-new" style="background:#90EE90">$A</span></var><span class="deltaxml-new" style="background:#90EE90"> from the input sequence that are </span><a title="contextually equal" class="termref" href="#dt-contextually-equal"><span class="deltaxml-new" style="background:#90EE90">contextually equal</span></a><span class="deltaxml-new" style="background:#90EE90"> to </span><code><span class="deltaxml-new" style="background:#90EE90">$B</span></code><span class="deltaxml-new" style="background:#90EE90">, retaining their order. </span></p></li></ul></dd><dt class="label">Error Conditions</dt><dd><p>If the set of computed keys contains <code>xs:untypedAtomic</code> values that are not castable to <code>xs:double</code> then the operation will fail with a dynamic error ([<a href="https://www.w3.org/TR/xpath-functions/#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>]<sup><small>FO</small></sup>). </p><p>If the set of computed keys contains values that are not comparable using the <code>lt</code> operator then the sort operation will fail with a type error ([<a href="https://www.w3.org/TR/xpath20/#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]<sup><small>XP</small></sup>). </p></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><thead><tr><th>Variables</th></tr></thead><tbody><tr><td colspan="2"><div class="exampleInner"><pre xml:space="preserve">let $e := &lt;a x="10" y="5" z="2"/&gt;</pre></div></td></tr></tbody></table><table class="medium"><tbody><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><p><code>highest($e/@*) ! name()</code></p></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><p><code>"x"</code></p><p><em>(By default, untyped values are compared as numbers.)</em></p></td></tr><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><p><code>highest($e/@*, (), string#1) ! name()</code></p></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><p><code>"y"</code></p><p><em>(Here, the attribute values are compared as strings.)</em></p></td></tr><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><p><code>highest(("red", "green", "blue"), (), string-length#1)</code></p></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><p><code>"green"</code></p></td></tr><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small">highest(
  ("red", "green", "blue"),
  key := {
    "red"  : xs:hexBinary('FF0000'),
    "green": xs:hexBinary('008000'),
    "blue" : xs:hexBinary('0000FF')
  }
)</pre></div></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">"red"</pre></div></td></tr><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small">highest(
  ("red", "orange", "yellow", "green", "blue", "indigo", "violet"),
  key := string-length#1
)</pre></div></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">"orange", "yellow", "indigo", "violet"</pre></div></td></tr><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><p><code>highest(1 to 25, (), fn { . idiv 10 })</code></p></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><p><code>20, 21, 22, 23, 24, 25</code></p></td></tr><tr><td colspan="2"><p>To find employees having the highest salary: </p></td></tr><tr><td colspan="2"><div class="exampleInner"><pre xml:space="preserve">highest($employees, (), fn { xs:decimal(salary) })</pre></div></td></tr></tbody></table></div></dd></dl></div></div></div></div><div class="back"></div><script src="js/toc.js"></script><script src="/js/scroll.js"></script></body></html>