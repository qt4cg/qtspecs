<!DOCTYPE HTML><html xmlns="http://www.w3.org/1999/xhtml" lang="EN"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>XPath and XQuery Functions and Operators 4.0 </title><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link rel="stylesheet" type="text/css" href="css/w3c-base.css"><link rel="stylesheet" href="css/qtspecs.css"><link rel="stylesheet" href="css/xpath-functions-40.css"><script src="js/fo-datalist.js"></script><style type="text/css">
          body { margin-top: 50px }
          a.button { background: #DDD; border: 2px outset black; padding: 2px; margin: 2px; font-family: sans-serif; font-size: small;}
          a.button:hover { cursor:pointer; }
          a.button:active { border-style: inset; }
        </style><link rel="stylesheet" href="/css/autodiff.css"></head><body class="toc-inline"><div style="position:fixed; clear:both; top:0px" id="_autodiff_buttons"><p><a class="button" onclick="view('old')">
              View Old
            </a><a class="button" onclick="view('new')">
              View New
            </a><a class="button" onclick="view('both')">
              View Both
            </a><a class="button" onclick="view('only')">
              View Only
            </a><a class="button" onclick="scroll_to('prev')">
              Previous
            </a><a class="button" onclick="scroll_to('next')">
              Next
            </a><span id="__autodiff__"></span></p><p>This draft contains only sections that have differences from the version that it modified.</p></div><div class="head"><p><a href="https://www.w3.org/"><img src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C" alt="W3C" height="48" width="72"></a></p><h1><a id="title"></a>XPath and XQuery Functions and Operators 4.0 </h1><h2><a id="w3c-doctype"></a>W3C Editor's Draft 2&nbsp;February&nbsp;2026</h2><dl><dt>This version:</dt><dd><a href="https://qt4cg.org/specifications/xpath-functions-40/">https://qt4cg.org/specifications/xpath-functions-40/</a></dd><dt>Latest version of XPath and XQuery Functions and Operators 4.0:</dt><dd><a href="https://qt4cg.org/specifications/xpath-functions-40/">https://qt4cg.org/specifications/xpath-functions-40/</a></dd><dt>Most recent Recommendation of XPath and XQuery Functions and Operators:</dt><dd><a href="https://www.w3.org/TR/2017/REC-xpath-functions-31-20170321/">https://www.w3.org/TR/2017/REC-xpath-functions-31-20170321/</a></dd><dt>Editor:</dt><dd>Michael Kay, Saxonica <a href="http://www.saxonica.com/">&lt;http://www.saxonica.com/&gt;</a></dd></dl><p>This document is also available in these non-normative formats: <a href="xpath-functions-40.xml">Specification in XML format</a> and&nbsp;<a href="function-catalog.xml">XML function catalog</a>.</p><p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;©&nbsp;2000&nbsp;<a href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="https://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="https://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="https://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p><hr></div><div><h2><a id="abstract"></a>Abstract</h2><p>This document defines constructor functions, operators, and functions on the datatypes defined in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> and the datatypes defined in <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>. It also defines functions and operators on nodes and node sequences as defined in the <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>. These functions and operators are defined for use in <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a> and <a href="#xquery-40">[XQuery 4.0: An XML Query Language]</a> and <a href="#xslt-40">[XSL Transformations (XSLT) Version 4.0]</a> and other related XML standards. The signatures and summaries of functions defined in this document are available at: <a href="http://www.w3.org/2005/xpath-functions/">http://www.w3.org/2005/xpath-functions/</a>.</p><p>A summary of changes since version 3.1 is provided at <a href="#changelog"><b>H Changes since 3.1</b></a>.</p></div><div><h2><a id="status"></a>Status of this Document</h2><p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document.</em></p><p>This document is a working draft developed and maintained by a W3C Community Group, the <a href="https://www.w3.org/community/xslt-40/">XQuery and XSLT Extensions Community Group</a> unofficially known as QT4CG (where "QT" denotes Query and Transformation). This draft is work in progress and should not be considered either stable or complete. Standard W3C copyright and patent conditions apply.</p><p>The community group welcomes comments on the specification. Comments are best submitted as issues on the group's <a href="https://github.com/qt4cg/qtspecs/issues">GitHub repository</a>.</p><p id="at-risk">As the Community Group moves towards publishing dated, stable drafts, some features that the group thinks may likely be removed or substantially changed are marked “at risk” in their changes section. In this draft:</p><ul><li><a href="#func-array-members">array:members</a></li><li><a href="#func-array-of-members">array:of-members</a></li></ul><p>The community group maintains two extensive test suites, one oriented to XQuery and XPath, the other to XSLT. These can be found at <a href="https://github.com/qt4cg/qt4tests">qt4tests</a> and <a href="https://github.com/qt4cg/xslt40-test">xslt40-test</a> respectively. New tests, or suggestions for correcting existing tests, are welcome. The test suites include extensive metadata describing the conditions for applicability of each test case as well as the expected results. They do not include any test drivers for executing the tests: each implementation is expected to provide its own test driver.</p><div class="dedication" id="dedication"><h3>Dedication</h3><p>The publications of this community group <a href="../xquery-40/xpath-40.html#dedication">are dedicated</a> to our co-chair, Michael Sperberg-McQueen&nbsp;(1954–2024).</p></div></div><hr><div class="body"><div class="_diffs div1"><h2><a id="intro"></a>1 <a href="#intro" style="text-decoration: none">Introduction</a></h2><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#conformance">next</a>)</p><ol><li><p>If a section of this specification has been updated since version 3.1, an overview of the changes is provided, along with links to navigate to the next or previous change.</p></li><li><p>Sections with significant changes are marked with a ✭ symbol in the table of contents. New functions are indicated by ✚.</p></li></ol></div><p>The purpose of this document is to define functions and operators for inclusion in XPath 4.0, XQuery 4.0, and XSLT 4.0. The exact syntax used to call these functions and operators is specified in <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a>, <a href="#xquery-40">[XQuery 4.0: An XML Query Language]</a> and <a href="#xslt-40">[XSL Transformations (XSLT) Version 4.0]</a>. </p><p>This document defines three classes of functions:</p><ul><li><p>General purpose functions, available for direct use in user-written queries, stylesheets, and XPath expressions, whose arguments and results are values defined by the <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>.</p></li><li><p>Constructor functions, used for creating instances of a datatype from values of (in general) a different datatype. These functions are also available for general use; they are named after the datatype that they return, and they always take a single argument.</p></li><li><p>Functions that specify the semantics of operators defined in <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a> and <a href="#xquery-40">[XQuery 4.0: An XML Query Language]</a>. These exist for specification purposes only, and are not intended for direct calling from user-written code.</p></li></ul><p><a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> defines a number of primitive and derived datatypes, collectively known as built-in datatypes. This document defines functions and operations on these datatypes as well as the other types (for example, nodes and sequences of nodes) defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types"> 2.7 Schema Information </a><sup><small>DM31</small></sup> of the <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>. These functions and operations are available for use in <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a>, <a href="#xquery-40">[XQuery 4.0: An XML Query Language]</a> and any other host language that chooses to reference them. In particular, they may be referenced in future versions of XSLT and related XML standards. </p><p><a href="#xmlschema11-2">[XSD 1.1 Part 2]</a> adds to the datatypes defined in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a>. It introduces a new derived type <code>xs:dateTimeStamp</code>, and it incorporates as built-in types the two types <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code> which were previously XDM additions to the type system. In addition, XSD 1.1 clarifies and updates many aspects of the definitions of the existing datatypes: for example, it extends the value space of <code>xs:double</code> to allow both positive and negative zero, and extends the lexical space to allow <code>+INF</code>; it modifies the value space of <code>xs:Name</code> to permit additional Unicode characters; it allows year zero and disallows leap seconds in <code>xs:dateTime</code> values; and it allows any character string to appear as the value of an <code>xs:anyURI</code> item. Implementations of this specification <span class="verb">may</span> support either XSD 1.0 or XSD 1.1 or both.</p><p>In some cases, this specification references XSD for the semantics of operations such as the effect of matching using regular expressions, or conversion of atomic items to strings. In most such cases there is no intended technical difference between the XSD 1.0 and XSD 1.1 specifications, but the 1.1 version often provides clearer explanations and sometimes also corrects technical errors. In such cases this specification often chooses to reference the XSD 1.1 specification. This should not be taken as implying that it is necessary to invoke an XSD 1.1 processor.</p><p>References to specific sections of some of the above documents are indicated by cross-document links in this document. Each such link consists of a pointer to a specific section followed a superscript specifying the linked document. The superscripts have the following meanings: XQ <a href="#xquery-40">[XQuery 4.0: An XML Query Language]</a>, XT <a href="#xslt-40">[XSL Transformations (XSLT) Version 4.0]</a>, XP <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a>, and DM <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>.</p><div class="_diffs div2"><h3><a id="namespace-prefixes"></a>1.3 <a href="#namespace-prefixes" style="text-decoration: none">Namespaces and prefixes</a></h3><p>The functions and operators defined in this document are contained in one of several namespaces (see <a href="#xml-names">[Namespaces in XML]</a>) and referenced using an <code>xs:QName</code>.</p><p>This document uses conventional prefixes to refer to these namespaces. User-written applications can choose a different prefix to refer to the namespace, so long as it is bound to the correct URI. The host language may also define a default namespace for function calls, in which case function names in that namespace need not be prefixed at all. In many cases the default namespace will be <code>http://www.w3.org/2005/xpath-functions</code>, allowing a call on the <a href="#func-name"><code>fn:name</code></a> function (for example) to be written as <code>name()</code> rather than <code>fn:name()</code>; in this document, however, all example function calls are explicitly prefixed.</p><p>The URIs of the namespaces and the conventional prefixes associated with them are:</p><ul><li><p><code>http://www.w3.org/2001/XMLSchema</code> for constructors — associated with <code>xs</code>. </p><p><span style="display: none;" class="delete_version">The section <a href="#constructor-functions"><span class="delete_version"><b>22 Constructor functions</b></span><span class="modify_version"><b>22 Constructor functions</b></span></a> defines constructor functions for the built-in datatypes defined in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> and in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types"> 2.7 Schema Information </a><sup><small>DM31</small></sup> of <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>. These datatypes and the corresponding constructor functions are in the XML Schema namespace, <code>http://www.w3.org/2001/XMLSchema</code>, and are named in this document using the <code>xs</code> prefix. </span><span style="display: none;" class="add_version">The section <a href="#constructor-functions"><span class="add_version"><b>23 Constructor functions</b></span><span class="modify_version"><b>23 Constructor functions</b></span></a> defines constructor functions for the built-in datatypes defined in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> and in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types"> 2.7 Schema Information </a><sup><small>DM31</small></sup> of <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>. These datatypes and the corresponding constructor functions are in the XML Schema namespace, <code>http://www.w3.org/2001/XMLSchema</code>, and are named in this document using the <code>xs</code> prefix. </span><span class="modify_version">The section <a href="#constructor-functions"><span style="display: none;" class="delete_version"><b>22 Constructor functions</b></span><span style="display: none;" class="add_version"><b>23 Constructor functions</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22</span><span class="deltaxml-new" style="background:#90EE90">23</span> Constructor functions</b></span></a> defines constructor functions for the built-in datatypes defined in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> and in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types"> 2.7 Schema Information </a><sup><small>DM31</small></sup> of <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>. These datatypes and the corresponding constructor functions are in the XML Schema namespace, <code>http://www.w3.org/2001/XMLSchema</code>, and are named in this document using the <code>xs</code> prefix. </span></p></li><li><p><code>http://www.w3.org/2005/xpath-functions</code> for functions — associated with <code>fn</code>. </p><p>The namespace prefix used in this document for most functions that are available to users is <code>fn</code>.</p></li><li><p><code>http://www.w3.org/2005/xpath-functions/math</code> for functions — associated with <code>math</code>. </p><p>This namespace is used for some mathematical functions. The namespace prefix used in this document for these functions is <code>math</code>. These functions are available to users in exactly the same way as those in the <code>fn</code> namespace.</p></li><li><p><code>http://www.w3.org/2005/xpath-functions/map</code> for functions — associated with <code>map</code>. </p><p>This namespace is used for some functions that manipulate maps (see <a href="#map-functions"><b>14.4 Functions that operate on maps</b></a>). The namespace prefix used in this document for these functions is <code>map</code>. These functions are available to users in exactly the same way as those in the <code>fn</code> namespace.</p></li><li><p><code>http://www.w3.org/2005/xpath-functions/array</code> for functions — associated with <code>array</code>. </p><p>This namespace is used for some functions that manipulate maps (see <a href="#array-functions"><b>15.2 Functions that operate on arrays</b></a>). The namespace prefix used in this document for these functions is <code>array</code>. These functions are available to users in exactly the same way as those in the <code>fn</code> namespace.</p></li><li class="add_version" style="display: none;"><p><code>http://www.w3.org/2005/xpath-functions/generators</code> for functions — associated with <code>generators</code>. </p><p>This namespace is used for some functions that manipulate generators (see <a href="#generator-functions"><b>18.4 Functions on generators</b></a>). The namespace prefix used in this document for these functions is <code>gn</code>. These functions are available to users in exactly the same way as those in the <code>fn</code> namespace.</p></li><li class="modify_version"><p><code><span class="deltaxml-new" style="background:#90EE90">http://www.w3.org/2005/xpath-functions/generators</span></code><span class="deltaxml-new" style="background:#90EE90"> for functions — associated with </span><code><span class="deltaxml-new" style="background:#90EE90">generators</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">This namespace is used for some functions that manipulate generators (see </span><a href="#generator-functions"><b><span class="deltaxml-new" style="background:#90EE90">18.4 Functions on generators</span></b></a><span class="deltaxml-new" style="background:#90EE90">). The namespace prefix used in this document for these functions is </span><code><span class="deltaxml-new" style="background:#90EE90">gn</span></code><span class="deltaxml-new" style="background:#90EE90">. These functions are available to users in exactly the same way as those in the </span><code><span class="deltaxml-new" style="background:#90EE90">fn</span></code><span class="deltaxml-new" style="background:#90EE90"> namespace.</span></p></li><li><p><code>http://www.w3.org/2005/xqt-errors</code> — associated with <code>err</code>. </p><p>There are no functions in this namespace; it is used for error codes.</p><p>This document uses the prefix <code>err</code> to represent the namespace URI <code>http://www.w3.org/2005/xqt-errors</code>, which is the namespace for all XPath and XQuery error codes and messages. This namespace prefix is not predeclared and its use in this document is not normative.</p></li><li><p><code>http://www.w3.org/2010/xslt-xquery-serialization</code> — associated with <code>output</code>. </p><p>There are no functions in this namespace: it is used for serialization parameters, as described in <a href="#xslt-xquery-serialization-31">[XSLT and XQuery Serialization 3.1]</a></p></li><li><p> Functions defined with the <code>op</code> prefix are described here to underpin the definitions of the operators in <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a>, <a href="#xquery-40">[XQuery 4.0: An XML Query Language]</a> and <a href="#xslt-40">[XSL Transformations (XSLT) Version 4.0]</a>. These functions are not available directly to users, and there is no requirement that implementations should actually provide these functions. For this reason, no namespace is associated with the <code>op</code> prefix. For example, multiplication is generally associated with the <code>*</code> operator, but it is described as a function in this document:</p><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">op:numeric-multiply</code>(</td></tr><tr class="arg"><td><code>$arg1</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:numeric</code></code>,</td><td></td></tr><tr class="arg"><td><code>$arg2</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:numeric</code></code></td><td></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:numeric</code></code></td></tr></tbody></table></div><p>Sometimes there is a need to use an operator as a function. To meet this requirement, the function <a href="#func-op"><code>fn:op</code></a> takes any simple binary operator as its argument, and returns a corresponding function. So for example <code>fn:for-each-pair($seq1, $seq2, op("+"))</code> performs a pairwise addition of the values in two input sequences.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The above namespace URIs are not expected to change from one version of this document to another. The contents of these namespaces may be extended to allow additional functions (and errors, and serialization parameters) to be defined.</p></div></div></div><div class="_diffs div1"><h2><a id="numeric-functions"></a>4 <a href="#numeric-functions" style="text-decoration: none">Processing numerics</a></h2><p>This section specifies arithmetic operators on the numeric datatypes defined in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a>.</p><div class="_diffs div2"><h3><a id="numeric-types"></a>4.1 <a href="#numeric-types" style="text-decoration: none">Numeric types</a></h3><p>The operators described in this section are defined on the following atomic types.</p><div class="type-hierarchy-figure"><div class="hier"><ul class="type-hierarchy type-colors"><li class="primitive special root"><ul><li class="primitive"><p class="item"><span>decimal</span></p><ul><li class="built-in-atomic"><p class="first"><span>integer</span></p></li></ul></li><li class="primitive"><p class="item"><span>double</span></p></li><li class="primitive"><p class="item"><span>float</span></p></li></ul></li></ul></div><div class="legend"><p>Legend:</p><ul class="type-hierarchy type-colors"><li><p class="root"><span>Supertype</span></p><ul><li><p><span>subtype</span></p></li></ul></li></ul><ul class="type-legend type-colors"><li class="built-in-atomic"><p><span>Built-in atomic types</span></p></li></ul></div></div><p>They also apply to types derived by restriction from the above types. </p><p>The type <code>xs:numeric</code> is defined as a union type whose member types are (in order) <code>xs:double</code>, <code>xs:float</code>, and <code>xs:decimal</code>. This type is implicitly imported into the static context, so it can also be used in defining the signature of user-written functions. Apart from the fact that it is implicitly imported, it behaves exactly like a user-defined type with the same definition. This means, for example:</p><ul><li><p>If the expected type of a function parameter is given as <code>xs:numeric</code>, the actual value supplied can be an instance of any of these three types, or any type derived from these three by restriction (this includes the built-in type <code>xs:integer</code>, which is derived from <code>xs:decimal</code>).</p></li><li><p><span style="display: none;" class="delete_version">If the expected type of a function parameter is given as <code>xs:numeric</code>, and the actual value supplied is <code>xs:untypedAtomic</code> (or a node whose atomized value is <code>xs:untypedAtomic</code>), then it will be cast to the union type <code>xs:numeric</code> using the rules in <a href="#casting-to-union"><span class="delete_version"><b>23.3.7 Casting to union types</b></span><span class="modify_version"><b>23.3.7 Casting to union types</b></span></a>. Because the lexical space of <code>xs:double</code> subsumes the lexical space of the other member types, and <code>xs:double</code> is listed first, the effect is that if the untyped atomic item is in the lexical space of <code>xs:double</code>, it will be converted to an <code>xs:double</code>, and if not, a dynamic error occurs.</span><span style="display: none;" class="add_version">If the expected type of a function parameter is given as <code>xs:numeric</code>, and the actual value supplied is <code>xs:untypedAtomic</code> (or a node whose atomized value is <code>xs:untypedAtomic</code>), then it will be cast to the union type <code>xs:numeric</code> using the rules in <a href="#casting-to-union"><span class="add_version"><b>24.3.7 Casting to union types</b></span><span class="modify_version"><b>24.3.7 Casting to union types</b></span></a>. Because the lexical space of <code>xs:double</code> subsumes the lexical space of the other member types, and <code>xs:double</code> is listed first, the effect is that if the untyped atomic item is in the lexical space of <code>xs:double</code>, it will be converted to an <code>xs:double</code>, and if not, a dynamic error occurs.</span><span class="modify_version">If the expected type of a function parameter is given as <code>xs:numeric</code>, and the actual value supplied is <code>xs:untypedAtomic</code> (or a node whose atomized value is <code>xs:untypedAtomic</code>), then it will be cast to the union type <code>xs:numeric</code> using the rules in <a href="#casting-to-union"><span style="display: none;" class="delete_version"><b>23.3.7 Casting to union types</b></span><span style="display: none;" class="add_version"><b>24.3.7 Casting to union types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.7</span><span class="deltaxml-new" style="background:#90EE90">24.3.7</span> Casting to union types</b></span></a>. Because the lexical space of <code>xs:double</code> subsumes the lexical space of the other member types, and <code>xs:double</code> is listed first, the effect is that if the untyped atomic item is in the lexical space of <code>xs:double</code>, it will be converted to an <code>xs:double</code>, and if not, a dynamic error occurs.</span></p></li><li><p>When the return type of a function is given as <code>xs:numeric</code>, the actual value returned will be an instance of one of the three member types (and perhaps also of types derived from these by restriction). The rules for the particular function will specify how the type of the result depends on the values supplied as arguments. In many cases, for the functions in this specification, the result is defined to be the same type as the first argument.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p> This specification uses <a href="#ieee754-2019">[IEEE 754-2019]</a> arithmetic for <code>xs:float</code> and <code>xs:double</code> values. One consequence of this is that some operations result in the value <code>NaN</code> (not a number), which has the unusual property that it is not equal to itself. Another consequence is that some operations return the value negative zero. This differs from <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a>, which defines <code>NaN</code> as being equal to itself and defines only a single zero in the value space. The text accompanying several functions defines behavior for both positive and negative zero inputs and outputs in the interest of alignment with <a href="#ieee754-2019">[IEEE 754-2019]</a>. A conformant implementation must respect these semantics. In consequence, the expression <code>-0.0e0</code> (which is actually a unary minus operator applied to an <code>xs:double</code> value) will always return negative zero: see <a href="#func-numeric-unary-minus"><b>4.2.8 op:numeric-unary-minus</b></a>. As a concession to implementations that rely on implementations of XSD 1.0, however, when casting from string to double the lexical form <code>-0</code><span class="verb">may</span> be converted to positive zero, though negative zero is <span class="verb">recommended</span>. </p><p>XML Schema 1.1 introduces support for positive and negative zero as distinct values, and also uses the <a href="#ieee754-2019">[IEEE 754-2019]</a> semantics for comparisons involving <code>NaN</code>.</p></div></div><div class="_diffs div2"><h3><a id="parsing-numbers"></a>4.5 <a href="#parsing-numbers" style="text-decoration: none">Parsing numbers</a></h3><p><span style="display: none;" class="delete_version">It is possible to convert strings to values of type <code>xs:integer</code>, <code>xs:float</code>, <code>xs:decimal</code>, or <code>xs:double</code> using the constructor functions described in <a href="#constructor-functions"><span class="delete_version"><b>22 Constructor functions</b></span><span class="modify_version"><b>22 Constructor functions</b></span></a> or using <code>cast</code> expressions as described in <a href="#casting"><span class="delete_version"><b>23 Casting</b></span><span class="modify_version"><b>23 Casting</b></span></a>.</span><span style="display: none;" class="add_version">It is possible to convert strings to values of type <code>xs:integer</code>, <code>xs:float</code>, <code>xs:decimal</code>, or <code>xs:double</code> using the constructor functions described in <a href="#constructor-functions"><span class="add_version"><b>23 Constructor functions</b></span><span class="modify_version"><b>23 Constructor functions</b></span></a> or using <code>cast</code> expressions as described in <a href="#casting"><span class="add_version"><b>24 Casting</b></span><span class="modify_version"><b>24 Casting</b></span></a>.</span><span class="modify_version">It is possible to convert strings to values of type <code>xs:integer</code>, <code>xs:float</code>, <code>xs:decimal</code>, or <code>xs:double</code> using the constructor functions described in <a href="#constructor-functions"><span style="display: none;" class="delete_version"><b>22 Constructor functions</b></span><span style="display: none;" class="add_version"><b>23 Constructor functions</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22</span><span class="deltaxml-new" style="background:#90EE90">23</span> Constructor functions</b></span></a> or using <code>cast</code> expressions as described in <a href="#casting"><span style="display: none;" class="delete_version"><b>23 Casting</b></span><span style="display: none;" class="add_version"><b>24 Casting</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23</span><span class="deltaxml-new" style="background:#90EE90">24</span> Casting</b></span></a>.</span></p><p>In addition the <a href="#func-number"><code>fn:number</code></a> function is available to convert strings to values of type <code>xs:double</code>. It differs from the <code>xs:double</code> constructor function in that any value outside the lexical space of the <code>xs:double</code> datatype is converted to the <code>xs:double</code> value <code>NaN</code>.</p><table class="index"><thead><tr><th>Function</th><th>Meaning</th></tr></thead><tbody><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-number"><code>fn:number</code></a></td><td>Returns the value indicated by <code>$value</code> or, if <code>$value</code> is not specified, the context value after atomization, converted to an <code>xs:double</code>. </td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-parse-integer"><code>fn:parse-integer</code></a></td><td>Converts a string to an integer, recognizing any radix in the range 2 to 36.</td></tr></tbody></table><div class="_diffs div3"><h4><a id="func-number"></a>4.5.1 <a href="#func-number" style="text-decoration: none">fn:number</a></h4><dl><dt class="label">Summary</dt><dd><p>Returns the value indicated by <code>$value</code> or, if <code>$value</code> is not specified, the context value after atomization, converted to an <code>xs:double</code>. </p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">fn:number</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:double</code></code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>The zero-argument form of this function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-dependent" class="termref" href="#dt-context-dependent">context-dependent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-dependent">focus-dependent</a>. </p><p>The one-argument form of this function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-independent" class="termref" href="#dt-context-independent">context-independent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. </p></dd><dt class="label">Rules</dt><dd><p>Calling the zero-argument version of the function is defined to give the same result as calling the single-argument version with the context value (<code>.</code>). That is, <code>fn:number()</code> is equivalent to <code>fn:number(.)</code>, as defined by the rules that follow.</p><p>If <code>$value</code> is the empty sequence or if <code>$value</code> cannot be converted to an <code>xs:double</code>, the <code>xs:double</code> value <code>NaN</code> is returned. </p><p><span style="display: none;" class="delete_version">Otherwise, <code>$value</code> is converted to an <code>xs:double</code> following the rules of <a href="#casting-to-double"><span class="delete_version"><b>23.1.3.2 Casting to xs:double</b></span><span class="modify_version"><b>23.1.3.2 Casting to xs:double</b></span></a>. If the conversion to <code>xs:double</code> fails, the <code>xs:double</code> value <code>NaN</code> is returned.</span><span style="display: none;" class="add_version">Otherwise, <code>$value</code> is converted to an <code>xs:double</code> following the rules of <a href="#casting-to-double"><span class="add_version"><b>24.1.3.2 Casting to xs:double</b></span><span class="modify_version"><b>24.1.3.2 Casting to xs:double</b></span></a>. If the conversion to <code>xs:double</code> fails, the <code>xs:double</code> value <code>NaN</code> is returned.</span><span class="modify_version">Otherwise, <code>$value</code> is converted to an <code>xs:double</code> following the rules of <a href="#casting-to-double"><span style="display: none;" class="delete_version"><b>23.1.3.2 Casting to xs:double</b></span><span style="display: none;" class="add_version"><b>24.1.3.2 Casting to xs:double</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.1.3.2</span><span class="deltaxml-new" style="background:#90EE90">24.1.3.2</span> Casting to xs:double</b></span></a>. If the conversion to <code>xs:double</code> fails, the <code>xs:double</code> value <code>NaN</code> is returned.</span></p></dd><dt class="label">Error Conditions</dt><dd><p>A type error is raised [<a href="https://www.w3.org/TR/xpath20/#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>]<sup><small>XP</small></sup> if <code>$value</code> is omitted and the context value is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM</small></sup>.</p><p>As a consequence of the rules given above, a type error is raised [<a href="https://www.w3.org/TR/xpath20/#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]<sup><small>XP</small></sup> if the context value cannot be atomized, or if the result of atomizing the context value is a sequence containing more than one atomic item.</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>XSD 1.1 allows the string <code>+INF</code> as a representation of positive infinity; XSD 1.0 does not. It is <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a> whether XSD 1.1 is supported.</p><p>Generally <a href="#func-number"><code>fn:number</code></a> returns <code>NaN</code> rather than raising a dynamic error if the argument cannot be converted to <code>xs:double</code>. However, a type error is raised in the usual way if the supplied argument cannot be atomized or if the result of atomization does not match the required argument type.</p></div></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><thead><tr><th>Variables</th></tr></thead><tbody><tr><td colspan="2"><div class="exampleInner"><pre xml:space="preserve">let $e := &lt;e price="12.1" discount="NONE"/&gt;</pre></div></td></tr></tbody></table><table class="medium"><thead><tr><th>Expression</th><th>Result</th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>number(12)</code></pre></div></td><td style="vertical-align:top"><p><code>1.2e1</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>number('12')</code></pre></div></td><td style="vertical-align:top"><p><code>1.2e1</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>number('INF')</code></pre></div></td><td style="vertical-align:top"><p><code>xs:double('INF')</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>number('NaN')</code></pre></div></td><td style="vertical-align:top"><p><code>xs:double('NaN')</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>number('non-numeric')</code></pre></div></td><td style="vertical-align:top"><p><code>xs:double('NaN')</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>number($e/@price)</code></pre></div></td><td style="vertical-align:top"><p><code>1.21e1</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>number($e/@discount)</code></pre></div></td><td style="vertical-align:top"><p><code>xs:double('NaN')</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>number($e/@misspelt)</code></pre></div></td><td style="vertical-align:top"><p><code>xs:double('NaN')</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>("10", "11", "12") ! number()</code></pre></div></td><td style="vertical-align:top"><p><code>1.0e1, 1.1e1, 1.2e1</code></p></td></tr></tbody></table></div></dd></dl></div></div></div><div class="_diffs div1"><h2><a id="node-functions"></a>12 <a href="#node-functions" style="text-decoration: none">Processing nodes</a></h2><div class="_diffs div2"><h3><a id="accessors"></a>12.1 <a href="#accessors" style="text-decoration: none">Accessors</a></h3><p>Accessors and their semantics are described in <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>. Some of these accessors are exposed to the user through the functions described below.</p><p>Each of these functions has an arity-zero signature which is equivalent to the arity-one form, with the context value supplied as the implicit first argument. In addition, each of the arity-one functions accepts an empty sequence as the argument, in which case it generally delivers an empty sequence as the result: the exception is <a href="#func-string"><code>fn:string</code></a>, which delivers a zero-length string.</p><table class="data"><thead><tr><th>Function</th><th>Accessor</th><th>Accepts</th><th>Returns</th></tr></thead><tbody><tr><td><a href="#func-node-name"><code>fn:node-name</code></a></td><td><code>node-name</code></td><td>node (optional)</td><td><code>xs:QName</code> (optional) </td></tr><tr><td><a href="#func-nilled"><code>fn:nilled</code></a></td><td><code>nilled</code></td><td>node (optional)</td><td><code>xs:boolean</code> (optional) </td></tr><tr><td><a href="#func-string"><code>fn:string</code></a></td><td><code>string-value</code></td><td>item (optional)</td><td><code>xs:string</code></td></tr><tr><td><a href="#func-data"><code>fn:data</code></a></td><td><code>typed-value</code></td><td>zero or more items</td><td>a sequence of atomic items</td></tr><tr><td><a href="#func-base-uri"><code>fn:base-uri</code></a></td><td><code>base-uri</code></td><td>node (optional)</td><td><code>xs:anyURI</code> (optional) </td></tr><tr><td><a href="#func-document-uri"><code>fn:document-uri</code></a></td><td><code>document-uri</code></td><td>node (optional)</td><td><code>xs:anyURI</code> (optional) </td></tr></tbody></table><table class="index"><thead><tr><th>Function</th><th>Meaning</th></tr></thead><tbody><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-base-uri"><code>fn:base-uri</code></a></td><td>Returns the base URI of a node.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-document-uri"><code>fn:document-uri</code></a></td><td>Returns the URI of a resource where a document can be found, if available.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-nilled"><code>fn:nilled</code></a></td><td>Returns <code>true</code> for an element that is <b>nilled</b>.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-node-name"><code>fn:node-name</code></a></td><td>Returns the name of a node, as an <code>xs:QName</code>.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-string"><code>fn:string</code></a></td><td>Returns the value of <code>$value</code> represented as an <code>xs:string</code>.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-data"><code>fn:data</code></a></td><td>Returns the result of atomizing a sequence. This process flattens arrays, and replaces nodes by their typed values.</td></tr></tbody></table><div class="_diffs div3"><h4><a id="func-string"></a>12.1.5 <a href="#func-string" style="text-decoration: none">fn:string</a></h4><dl><dt class="label">Summary</dt><dd><p>Returns the value of <code>$value</code> represented as an <code>xs:string</code>.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">fn:string</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>item()?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:string</code></code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>The zero-argument form of this function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-dependent" class="termref" href="#dt-context-dependent">context-dependent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-dependent">focus-dependent</a>. </p><p>The one-argument form of this function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-independent" class="termref" href="#dt-context-independent">context-independent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. </p></dd><dt class="label">Rules</dt><dd><p>In the zero-argument version of the function, <code>$value</code> defaults to the context value. That is, calling <code>fn:string()</code> is equivalent to calling <code>fn:string(.)</code>.</p><p>If <code>$value</code> is the empty sequence, the function returns the zero-length string.</p><p>If <code>$value</code> is an <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-XNode">XNode</a><sup><small>DM</small></sup>, the function returns the string value of the node, as obtained using the <code>dm:string-value</code> accessor defined in <a href="#xpath-datamodel-31">[XQuery and XPath Data Model (XDM) 3.1]</a> (see <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a> section <a href="../xpath-datamodel-40/#dm-string-value">7.6.12 string-value Accessor</a>).</p><p>If <code>$value</code> is a <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-JNode">JNode</a><sup><small>DM</small></sup>, the function returns the result of <code>string(jnode-content($value))</code>. This will fail in the case where <code>jnode-content($value)</code> is a map or an array.</p><p><span style="display: none;" class="delete_version">If <code>$value</code> is an atomic item, the function returns the result of the expression <code>$value cast as xs:string</code> (see <a href="#casting"><span class="delete_version"><b>23 Casting</b></span><span class="modify_version"><b>23 Casting</b></span></a>).</span><span style="display: none;" class="add_version">If <code>$value</code> is an atomic item, the function returns the result of the expression <code>$value cast as xs:string</code> (see <a href="#casting"><span class="add_version"><b>24 Casting</b></span><span class="modify_version"><b>24 Casting</b></span></a>).</span><span class="modify_version">If <code>$value</code> is an atomic item, the function returns the result of the expression <code>$value cast as xs:string</code> (see <a href="#casting"><span style="display: none;" class="delete_version"><b>23 Casting</b></span><span style="display: none;" class="add_version"><b>24 Casting</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23</span><span class="deltaxml-new" style="background:#90EE90">24</span> Casting</b></span></a>).</span></p><p>In all other cases, a dynamic error occurs (see below).</p></dd><dt class="label">Error Conditions</dt><dd><p>The following errors may be raised when <code>$value</code> is omitted:</p><ul><li><p>If the context value is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM</small></sup>, type error [<a href="https://www.w3.org/TR/xpath20/#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>]<sup><small>XP</small></sup>.</p></li><li><p>If the context value is not an instance of the sequence type <code>item()?</code>, type error [<a href="https://www.w3.org/TR/xpath20/#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]<sup><small>XP</small></sup>.</p></li></ul><p>A type error is raised [<a href="#ERRFOTY0014" title="err:FOTY0014">err:FOTY0014</a>] if <code>$value</code> is a function item (this includes maps and arrays).</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>Every node has a string value, even an element with element-only content (which has no typed value). Moreover, casting an atomic item to a string always succeeds. Functions, maps, and arrays have no string value, so these satisfy the type signature but cause failure. Applying the <a href="#func-string"><code>string</code></a> function to a JNode succeeds if the JNode wraps a simple value such as a string, number, or boolean, or if it wraps an XNode, but it fails in the case where the JNode wraps a map or an array.</p></div></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><thead><tr><th>Variables</th></tr></thead><tbody><tr><td colspan="2"><div class="exampleInner"><pre xml:space="preserve">let $para := &lt;para&gt;There lived a &lt;term author="Tolkien"&gt;hobbit&lt;/term&gt;.&lt;/para&gt;</pre></div></td></tr></tbody></table><table class="medium"><thead><tr><th>Expression</th><th>Result</th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>string(23)</code></pre></div></td><td style="vertical-align:top"><p><code>"23"</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>string(false())</code></pre></div></td><td style="vertical-align:top"><p><code>"false"</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>string("Paris")</code></pre></div></td><td style="vertical-align:top"><p><code>"Paris"</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>string((1, 2, 3))</code></pre></div></td><td style="vertical-align:top"><p>Raises error XPTY0004.</p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>string([ [ 1, 2 ], [ 3, 4 ] ])</code></pre></div></td><td style="vertical-align:top"><p>Raises error FOTY0014.</p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>string(abs#1)</code></pre></div></td><td style="vertical-align:top"><p>Raises error FOTY0014.</p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>string({"x": [10, 20, 30]} / x / *[3])</code></pre></div></td><td style="vertical-align:top"><p><code>"30"</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>string($para)</code></pre></div></td><td style="vertical-align:top"><p><code>"There lived a hobbit."</code></p></td></tr></tbody></table></div></dd></dl></div></div></div><div class="_diffs div1"><h2><a id="lazy-evaluation"></a><span class="deltaxml-new" style="background:#90EE90">18 </span><a href="#lazy-evaluation" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">Deferred evaluation</span></a></h2><p><span class="deltaxml-new" style="background:#90EE90">Deferred-evaluation is achieved in a user-controlled way, using the system-defined </span><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code><span class="deltaxml-new" style="background:#90EE90"> record.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Deferred-evaluation is particularly useful when solving any problem, where data sources of unknown or unpredictable size must be handled, and only one or a few values from these are needed at any time during the processing. </span></p><div class="_diffs div2"><h3><a id="generator-use-cases"></a><span class="deltaxml-new" style="background:#90EE90">18.1 </span><a href="#generator-use-cases" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">Major use-cases</span></a></h3><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">f:generator</span></code><span class="deltaxml-new" style="background:#90EE90"> record is a tool for solutions needed for the following use-cases: </span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">Processing a huge data-source whose values may not all be needed. A generator produces only the next value from the data-source and only on demand basis.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Handling a data-source providing unknown or infinite number of values. When requested for the next value of the data-source the generator always produces it, if the data-source still contains any values. It is the responsibility of the caller to issue only the necessary number of requests for the really needed next values.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">What is achieved in these two cases: </span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">A (next) value is produced only on request. No time is spent on producing all values of the collection.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">A (next) value is produced only on request. No memory is consumed to store all values of the collection.</span></p></li></ul><p></p></div><div class="_diffs div2"><h3><a id="generator-definitions"></a><span class="deltaxml-new" style="background:#90EE90">18.2 </span><a href="#generator-definitions" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">Definitions</span></a></h3><p><span class="deltaxml-new" style="background:#90EE90">The following terms are defined:</span></p><div class="example"><ul><li><p><span class="termdef"><a id="gr-collection-data-source"></a><span class="deltaxml-new" style="background:#90EE90">[Definition] An </span><span><b><span class="deltaxml-new" style="background:#90EE90">XPath collection</span></b></span><span class="deltaxml-new" style="background:#90EE90"> or just </span><span><b><span class="deltaxml-new" style="background:#90EE90">collection</span></b></span><span class="deltaxml-new" style="background:#90EE90"> has nothing to do with the </span><code><span class="deltaxml-new" style="background:#90EE90">f:collection</span></code><span class="deltaxml-new" style="background:#90EE90"> function. An </span><span><b><span class="deltaxml-new" style="background:#90EE90">XPath collection</span></b></span><span class="deltaxml-new" style="background:#90EE90"> can be a sequence, an array or a map. </span></span></p></li><li><p><span class="termdef"><a id="gr-value"></a><span class="deltaxml-new" style="background:#90EE90">[Definition] Generator </span><span><b><span class="deltaxml-new" style="background:#90EE90">value</span></b></span><span class="deltaxml-new" style="background:#90EE90"> - a "value" produced by a call to the generator method </span><code><span class="deltaxml-new" style="background:#90EE90">get-current</span></code><span class="deltaxml-new" style="background:#90EE90"> can be either an individual XPath </span><code><span class="deltaxml-new" style="background:#90EE90">item()</span></code><span class="deltaxml-new" style="background:#90EE90"> or an XPath sequence. </span></span></p></li><li><p><span class="termdef"><a id="gr-instance"></a><span class="deltaxml-new" style="background:#90EE90">[Definition] Generator </span><span><b><span class="deltaxml-new" style="background:#90EE90">instance</span></b></span><span class="deltaxml-new" style="background:#90EE90"> - a given instance of the </span><code><span class="deltaxml-new" style="background:#90EE90">f:generator</span></code><span class="deltaxml-new" style="background:#90EE90"> record or the result produced by a chain of one or more applications of the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code><span class="deltaxml-new" style="background:#90EE90"> method starting from a given </span><code><span class="deltaxml-new" style="background:#90EE90">f:generator</span></code><span class="deltaxml-new" style="background:#90EE90"> instance. </span></span></p></li><li><p><span class="termdef"><a id="gr-next-value"></a><span class="deltaxml-new" style="background:#90EE90">[Definition] The term </span><span><b><span class="deltaxml-new" style="background:#90EE90">the next value of a generator</span></b></span><span class="deltaxml-new" style="background:#90EE90"> denotes the value returned from the </span><code><span class="deltaxml-new" style="background:#90EE90">get-current()</span></code><span class="deltaxml-new" style="background:#90EE90"> method applied on the generator-instance produced by the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> method, if the </span><code><span class="deltaxml-new" style="background:#90EE90">end-reached</span></code><span class="deltaxml-new" style="background:#90EE90"> field of this next generator-instance is </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90">. This is also the next value in the generator's </span><span><b><span class="deltaxml-new" style="background:#90EE90">yield</span></b></span><span class="deltaxml-new" style="background:#90EE90"> - see below. </span></span></p></li><li><p></p><span class="termdef"><a id="gr-contents"></a><span class="deltaxml-new" style="background:#90EE90">[Definition] The term </span><span><b><span class="deltaxml-new" style="background:#90EE90">yield</span></b><span class="deltaxml-new" style="background:#90EE90"> (of a generator)</span></span><span class="deltaxml-new" style="background:#90EE90"> denotes the consecutive values returned from calling the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> and then the </span><code><span class="deltaxml-new" style="background:#90EE90">get-current</span></code><span class="deltaxml-new" style="background:#90EE90"> method starting from the current generator instance, and on each generator instance thus produced, by applying the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> method and then the </span><code><span class="deltaxml-new" style="background:#90EE90">get-current</span></code><span class="deltaxml-new" style="background:#90EE90"> method until </span><code><span class="deltaxml-new" style="background:#90EE90">move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> produces a generator instance whose </span><code><span class="deltaxml-new" style="background:#90EE90">end-reached</span></code><span class="deltaxml-new" style="background:#90EE90"> field is </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">. </span><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">Thus, if the consecutive generator instances produced by continuously applying the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> method on each of them, starting from the initialized </span><code><span class="deltaxml-new" style="background:#90EE90">$G1</span></code><span class="deltaxml-new" style="background:#90EE90"> generator is:</span></p><p><code><span class="deltaxml-new" style="background:#90EE90">$G2, $G3, ... , $Gn, ...</span></code><span class="deltaxml-new" style="background:#90EE90">, then the yield of the generator $G1 is exactly these consecutive generator values:</span></p><p><code><span class="deltaxml-new" style="background:#90EE90">$G1 =?&gt; get-current(), $G2 =?&gt; get-current(), ..., $Gn =?&gt; get-current(), ... </span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the sequence of the generator instances thus produced is finite (for the final produced generator </span><code><span class="deltaxml-new" style="background:#90EE90">$Gm</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$Gm?end-reached eq true()</span></code><span class="deltaxml-new" style="background:#90EE90">, then the yield is:</span></p><p><code><span class="deltaxml-new" style="background:#90EE90">$G1 =?&gt; get-current(), $G2 =?&gt; get-current(), ..., $Gm-1 =?&gt; get-current()</span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the </span><code><span class="deltaxml-new" style="background:#90EE90">$G1</span></code><span class="deltaxml-new" style="background:#90EE90"> generator is not initialized (</span><code><span class="deltaxml-new" style="background:#90EE90">$G1?initialized eq false())</span></code><span class="deltaxml-new" style="background:#90EE90">, then the yield of this generator is the same as the yield of the (first initialized in the chain) </span><code><span class="deltaxml-new" style="background:#90EE90">$G2</span></code><span class="deltaxml-new" style="background:#90EE90"> generator:</span></p><p><code><span class="deltaxml-new" style="background:#90EE90">$G2 =?&gt; get-current(), $G3 =?&gt; get-current(), ..., $Gn =?&gt; get-current(), ... </span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The yield is empty, if </span><code><span class="deltaxml-new" style="background:#90EE90">$G1?end-reached eq true</span></code><span class="deltaxml-new" style="background:#90EE90"> and the yield is infinite if neither </span><code><span class="deltaxml-new" style="background:#90EE90">$G1?end-reached eq true()</span></code><span class="deltaxml-new" style="background:#90EE90"> nor any of the consecutive applications of </span><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code><span class="deltaxml-new" style="background:#90EE90"> produces a generator </span><code><span class="deltaxml-new" style="background:#90EE90">$Gx</span></code><span class="deltaxml-new" style="background:#90EE90">, such that </span><code><span class="deltaxml-new" style="background:#90EE90">$Gx?end-reached eq true()</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ol></div></span><p></p></li><li><p></p><span class="termdef"><a id="gr-empty-generator"></a><span class="deltaxml-new" style="background:#90EE90">[Definition] A generator is </span><span><b><span class="deltaxml-new" style="background:#90EE90">empty</span></b></span><span class="deltaxml-new" style="background:#90EE90"> if and only if its field </span><code><span class="deltaxml-new" style="background:#90EE90">end-reached</span></code><span class="deltaxml-new" style="background:#90EE90"> has the effective boolean value </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">. An </span><span><b><span class="deltaxml-new" style="background:#90EE90">empty generator-instance</span></b></span><span class="deltaxml-new" style="background:#90EE90"> reached in the chain produced by successive evaluations of the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code><span class="deltaxml-new" style="background:#90EE90"> method signifies that the yield of a starting generator-instance has been fully traversed. It has the following properties: </span><ol class="enumar"><li><p><code><span class="deltaxml-new" style="background:#90EE90">get-current</span></code><span class="deltaxml-new" style="background:#90EE90">'s evaluation raises an error.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code><span class="deltaxml-new" style="background:#90EE90">'s evaluation raises an error.</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Empty generators may arise in two ways:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">Produced by the function </span><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Termination of a chain of generator instances - the final value of repeated application of the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code><span class="deltaxml-new" style="background:#90EE90"> method is an empty generator instance.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Generators with infinite yield never reach an empty-generator instance in this process.</span></p></li></ol></div></span><p></p></li></ul></div><p><span class="deltaxml-new" style="background:#90EE90">The fields of the </span><code><span class="deltaxml-new" style="background:#90EE90">f:generator</span></code><span class="deltaxml-new" style="background:#90EE90"> record, including its methods are defined in the next sections.</span></p></div><div class="_diffs div2"><h3><a id="generator"></a><span class="deltaxml-new" style="background:#90EE90">18.3 </span><a href="#generator" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">Record fn:generator</span></a></h3><p><span class="deltaxml-new" style="background:#90EE90">This record type is used as a tool for implementing deferred evaluation upon collections of values. The user has to maintain the four record fields, provided below. The generator type is extensible thus the user can add any additional fields as appropriate. Fields of </span><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code><span class="deltaxml-new" style="background:#90EE90"> :</span></p><table class="fos-options"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Name</span></th><th><span class="deltaxml-new" style="background:#90EE90">Meaning</span></th></tr></thead><tbody><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">initialized</span></code></p></td><td class="fos-thin"><p><span class="deltaxml-new" style="background:#90EE90">If the value of </span><code><span class="deltaxml-new" style="background:#90EE90">initialized</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90"> calling </span><code><span class="deltaxml-new" style="background:#90EE90">$generator =?&gt; get-current()</span></code><span class="deltaxml-new" style="background:#90EE90"> raises error [</span><a href="#ERRFOGR0001" title="err:FOGR0001"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0001</span></a><span class="deltaxml-new" style="background:#90EE90">]. When a </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> is initially created, sometimes it makes sense to perform additional, initializing actions on it, before it becomes possible to extract its current value. In such case, in order to get the first value of the yield, the caller must call </span><code><span class="deltaxml-new" style="background:#90EE90">$generator =?&gt; move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> and the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code><span class="deltaxml-new" style="background:#90EE90"> method should produce a new generator, whose </span><code><span class="deltaxml-new" style="background:#90EE90">initialized</span></code><span class="deltaxml-new" style="background:#90EE90"> field is </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p><ul><li><p><b><span class="deltaxml-new" style="background:#90EE90">Type: </span></b><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code></p></li></ul></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">end-reached</span></code></p></td><td class="fos-thin"><p><span class="deltaxml-new" style="background:#90EE90">Indicates whether or not the yield of the generator is empty. If after a call to </span><code><span class="deltaxml-new" style="background:#90EE90">move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> the value of the returned generator's </span><code><span class="deltaxml-new" style="background:#90EE90">end-reached</span></code><span class="deltaxml-new" style="background:#90EE90"> field is </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> then further calling </span><code><span class="deltaxml-new" style="background:#90EE90">move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> or </span><code><span class="deltaxml-new" style="background:#90EE90">get-current()</span></code><span class="deltaxml-new" style="background:#90EE90"> on this generator raises error [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">]. </span></p><ul><li><p><b><span class="deltaxml-new" style="background:#90EE90">Type: </span></b><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code></p></li></ul></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">get-current</span></code></p></td><td class="fos-thin"><p><span class="deltaxml-new" style="background:#90EE90">This function produces the current value of the generator after the last call to </span><code><span class="deltaxml-new" style="background:#90EE90">move-next()</span></code><span class="deltaxml-new" style="background:#90EE90">, if this last call didn't return a generator whose </span><code><span class="deltaxml-new" style="background:#90EE90">end-reached</span></code><span class="deltaxml-new" style="background:#90EE90"> value was </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">. </span><code><span class="deltaxml-new" style="background:#90EE90">get-current()</span></code><span class="deltaxml-new" style="background:#90EE90"> must only be called if the value of </span><code><span class="deltaxml-new" style="background:#90EE90">initialized</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> and the value of </span><code><span class="deltaxml-new" style="background:#90EE90">end-reached</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90">, otherwise an error, respectively [</span><a href="#ERRFOGR0001" title="err:FOGR0001"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0001</span></a><span class="deltaxml-new" style="background:#90EE90">] or [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">], is raised. </span></p><ul><li><p><b><span class="deltaxml-new" style="background:#90EE90">Type: </span></b><code><span class="deltaxml-new" style="background:#90EE90">fn($this as f:generator) as item()*</span></code></p></li></ul></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code></p></td><td class="fos-thin"><p><span class="deltaxml-new" style="background:#90EE90">This function, when called on a generator-instance whose </span><code><span class="deltaxml-new" style="background:#90EE90">end-reached</span></code><span class="deltaxml-new" style="background:#90EE90"> value is </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90">, produces the next generator-instance, whose </span><code><span class="deltaxml-new" style="background:#90EE90">end-reached</span></code><span class="deltaxml-new" style="background:#90EE90"> field could be </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">, however if after the call this field of the produced generator-instance is still </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90">, then calling </span><code><span class="deltaxml-new" style="background:#90EE90">get-current()</span></code><span class="deltaxml-new" style="background:#90EE90">) on this resulting generator-instance produces the "next value" of the generator. </span></p><ul><li><p><b><span class="deltaxml-new" style="background:#90EE90">Type: </span></b><code><span class="deltaxml-new" style="background:#90EE90">fn($this as f:generator) as f:generator</span></code></p></li></ul></td></tr><tr><td><p><code><span class="deltaxml-new" style="background:#90EE90">*</span></code></p></td><td><p><span class="deltaxml-new" style="background:#90EE90">The record type is extensible (it may contain additional fields beyond those listed).</span></p></td></tr></tbody></table></div><div class="_diffs div2"><h3><a id="generator-functions"></a><span class="deltaxml-new" style="background:#90EE90">18.4 </span><a href="#generator-functions" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">Functions on generators</span></a></h3><p><span class="deltaxml-new" style="background:#90EE90">The functions defined in this section use a conventional namespace prefix "gn", which is assumed to be bound to the namespace URI http://www.w3.org/2005/xpath-functions/generator. They are listed under the following categories, based on the type of the function result:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Functions returning a specific value: an </span><code><span class="deltaxml-new" style="background:#90EE90">item()</span></code><span class="deltaxml-new" style="background:#90EE90"> or a sequence.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Functions that produce another generator from existing generators.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Functions that produce a generator from data by a data-provider.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Functions that produce an XPath collection from the yield of a generator.</span></p></li></ul><p><span class="deltaxml-new" style="background:#90EE90">These functions do not evaluate eagerly the yield of any of their generator-operands. A value from a yield is produced only if explicitly requested by evaluating the methods </span><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">get-current</span></code><span class="deltaxml-new" style="background:#90EE90">. At no point in the computation it is necessary to have all values of a yield available. In most cases a function would only need one or a few values from a yield. No unnecessary computation of a value from a yield is done and no memory is used to hold such unnecessary value at any point in the computation. This is why the evaluation of the functions defined here is referred to as "Deferred Evaluation". </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Most of the examples in this section depend on the definition of the following variables:</span></p><div class="example"><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf := f:generator(initialized := true(), end-reached := false(), 
                              get-current := fn($this as f:generator){$this?last +1},
                              move-next := fn($this as f:generator)
                              {
                                if(not($this?initialized))
                                  then map:put($this, "initialized", true())
                                  else map:put($this, "last", $this?last + 1)
                              }
                             ) =&gt; map:put("last", 1),
    $genN := $gen2ToInf =&gt; map:put("last", 0),
    $gen0toInf := $gen2ToInf =&gt; map:put("last", -1),
    $double := fn($n) {2*$n},
    $sum2 := fn($m, $n) {$m + $n},
    $product := fn($m, $n) {$m * $n},
    $factorial := fn($n) {fold-left(1 to $n, 1, $product)}</span></pre></div></div><p><span class="deltaxml-new" style="background:#90EE90"> The examples use three generators with infinite yields: </span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf</span></code><span class="deltaxml-new" style="background:#90EE90"> with yield - all integers in the interval from 2 to Infinity ([2, ∞])</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$genN</span></code><span class="deltaxml-new" style="background:#90EE90"> with yield - the sequence of all natural numbers: all integers in [1, ∞]</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$gen0toInf </span></code><span class="deltaxml-new" style="background:#90EE90"> with yield - the sequence of all non-negative numbers: all integers in [0, ∞]</span></p></li></ul><p></p><p><span class="deltaxml-new" style="background:#90EE90">And four functions: </span></p><ul><li><p><code><span class="deltaxml-new" style="background:#90EE90">$double</span></code><span class="deltaxml-new" style="background:#90EE90"> returns its argument, multiplied by </span><code><span class="deltaxml-new" style="background:#90EE90">2</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$sum2</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the sum of its two arguments.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$product</span></code><span class="deltaxml-new" style="background:#90EE90"> returns the product of its two arguments.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">$factorial</span></code><span class="deltaxml-new" style="background:#90EE90"> given a non-negative argument </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90"> returns its factorial </span><code><span class="deltaxml-new" style="background:#90EE90">($n)!</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li></ul><p></p></div><div class="_diffs div3"><h4><a id="generator-functions-getting-value"></a><span class="deltaxml-new" style="background:#90EE90">18.4.1 </span><a href="#generator-functions-getting-value" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">Functions returning a specific value</span></a></h4><p><span class="deltaxml-new" style="background:#90EE90">This group of functions returns a single value computed from the yield of a supplied generator. Each function inspects the yield only as far as necessary to obtain that value.</span></p><table class="index"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Function</span></th><th><span class="deltaxml-new" style="background:#90EE90">Meaning</span></th></tr></thead><tbody><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:at</span></code></td><td><span class="deltaxml-new" style="background:#90EE90"> Returns the </span><code><span class="deltaxml-new" style="background:#90EE90">$k</span></code><span class="deltaxml-new" style="background:#90EE90">-th value from the yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:contains</span></code></td><td><span class="deltaxml-new" style="background:#90EE90"> Returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> if the </span><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code><span class="deltaxml-new" style="background:#90EE90"> is contained in the yield of the generator, and </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90"> otherwise. The comparisons are done using </span><a href="#func-deep-equal"><code><span class="deltaxml-new" style="background:#90EE90">fn:deep-equal</span></code></a><span class="deltaxml-new" style="background:#90EE90">. </span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:first-where</span></code></td><td><span class="deltaxml-new" style="background:#90EE90"> Returns the first </span><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code><span class="deltaxml-new" style="background:#90EE90"> in the yield of the generator for which </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate($value)</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">. If the generator's yield doesn't contain any such item, error [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised. </span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:fold-left</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Processes consecutively the values of the yield of the supplied generator, applying the supplied function repeatedly to each value in turn, together with an accumulated result value.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:fold-right</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Processes consecutively from right to left the values of the yield of the supplied generator, applying the supplied function repeatedly to each value in turn, together with an accumulated result value.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:fold-lazy</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Produces the same result as gn:fold-right on the entire yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> with the operation specified by </span><code><span class="deltaxml-new" style="background:#90EE90">$action</span></code><span class="deltaxml-new" style="background:#90EE90"> but also performs short-circuiting if detected by the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$short-circuit-detector</span></code><span class="deltaxml-new" style="background:#90EE90"> function.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:head</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Produces the first value contained in the yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:some</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> if and only if the generator is initialized and its yield contains at least one value.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:some-where</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> if the generator is initialized and its yield contains any value upon which evaluating the supplied predicate returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">. Otherwise, </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90"> is returned.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:value</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Produces the value contained in this generator-instance.</span></td></tr></tbody></table><div class="_diffs div4"><h5><a id="generator-at"></a><span class="deltaxml-new" style="background:#90EE90">18.4.1.1 </span><a href="#generator-at" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:at</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> Returns the </span><code><span class="deltaxml-new" style="background:#90EE90">$k</span></code><span class="deltaxml-new" style="background:#90EE90">-th value from the yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:at</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$k</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> If </span><code><span class="deltaxml-new" style="background:#90EE90">$k</span></code><span class="deltaxml-new" style="background:#90EE90"> is greater than the number of items contained in the generator's yield, error [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">gn:subrange($generator, $k, $k) =?&gt; get-current()</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:at(1)</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">2</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:at(5)</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">6</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; take(5) =&gt; gn:at(6)</span></code></pre></div></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">Raises error FOGR0002.</span></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-contains"></a><span class="deltaxml-new" style="background:#90EE90">18.4.1.2 </span><a href="#generator-contains" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:contains</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> Returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> if the </span><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code><span class="deltaxml-new" style="background:#90EE90"> is contained in the yield of the generator, and </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90"> otherwise. The comparisons are done using </span><a href="#func-deep-equal"><code><span class="deltaxml-new" style="background:#90EE90">fn:deep-equal</span></code></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:contains</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> The comparisons are done using </span><a href="#func-deep-equal"><code><span class="deltaxml-new" style="background:#90EE90">fn:deep-equal</span></code></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">let $gen := if(not($gen?initialized)) then  $gen =?&gt; move-next()
              else $gen
 return
  if($gen?end-reached) then false()
   else
     let $current := $gen =?&gt; get-current()
       return
          if(deep-equal($current, $value)) then true()
            else gn:contains($gen =?&gt; move-next(), $value)</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$genN =&gt; gn:take(10) =&gt; gn:contains(3)</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$genN =&gt; gn:take(10) =&gt; gn:contains(20)</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$genN =&gt; gn:take(10) =&gt; gn:contains(0)</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$genN =&gt; gn:take(10) =&gt; gn:contains(11)</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$genN =&gt; gn:contains(15)</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-first-where"></a><span class="deltaxml-new" style="background:#90EE90">18.4.1.3 </span><a href="#generator-first-where" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:first-where</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> Returns the first </span><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code><span class="deltaxml-new" style="background:#90EE90"> in the yield of the generator for which </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate($value)</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">. If the generator's yield doesn't contain any such item, error [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:first-where</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn(item()*) as xs:boolean</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> The </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code><span class="deltaxml-new" style="background:#90EE90"> function is applied consecutively on every value in the yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> until it returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">. This value is then returned as the result. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$gen =&gt; gn:skip-while(fn($x as item()*){not($pred($x))}) =&gt; gn:head()</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:first-where(fn($n){$n gt 10})</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">11</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:chunk(10)  
           =&gt;  gn:first-where(
                    fn($arr as array(*))
                    {$arr(1) le 33 and $arr(10) ge 33})</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[32,33,34,35,36,37,38,39,40,41]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-fold-left"></a><span class="deltaxml-new" style="background:#90EE90">18.4.1.4 </span><a href="#generator-fold-left" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:fold-left</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Processes consecutively the values of the yield of the supplied generator, applying the supplied function repeatedly to each value in turn, together with an accumulated result value.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:fold-left</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$init</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$action</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn(item()*, item()*) as item()*) as item()*</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Let the yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> contains </span><code><span class="deltaxml-new" style="background:#90EE90">N</span></code><span class="deltaxml-new" style="background:#90EE90"> values. Let us denote these </span><code><span class="deltaxml-new" style="background:#90EE90">N</span></code><span class="deltaxml-new" style="background:#90EE90"> values as </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, ..., </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">N</span></sub></var><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> If </span><code><span class="deltaxml-new" style="background:#90EE90">N eq 0</span></code><span class="deltaxml-new" style="background:#90EE90"> the function returns </span><code><span class="deltaxml-new" style="background:#90EE90">$init</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> If </span><code><span class="deltaxml-new" style="background:#90EE90">N gt 0</span></code><span class="deltaxml-new" style="background:#90EE90"> the function calls </span><code><span class="deltaxml-new" style="background:#90EE90">$action($init, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> returning a value </span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> If the yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> contains a second value, the function then calls </span><code><span class="deltaxml-new" style="background:#90EE90">$action(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> returning a value </span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></var><span class="deltaxml-new" style="background:#90EE90">. To process the </span><var><span class="deltaxml-new" style="background:#90EE90">k</span><sub><span class="deltaxml-new" style="background:#90EE90">th</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> value it calls </span><code><span class="deltaxml-new" style="background:#90EE90">$action(</span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">k-1</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">k</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">This continues in the same way until the end of the yield of the</span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">; the final result is the result of the last call on </span><code><span class="deltaxml-new" style="background:#90EE90">$action</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The function delivers the same result as the following XQuery implementation.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">declare function gn:fold-left($generator, 
                              $init as item()*,  
                              $action as fn(item()*, item()*) as item()*) as item()*
{
  if($generator?end-reached) then $init
    else gn:fold-left(gn:tail($generator), 
                      $action($init, $gen =?&gt; get-current()), 
                      $action)		
}</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(5) =&gt; gn:fold-left(0, fn($x, $y){$x + $y})</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">20</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() 
    =&gt; gn:fold-left(54321, fn($x, $y){$x + $y})</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">54321</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen0toInf 
    =&gt; gn:for-each(fn($n){(2 * $n + 1) 
                          div $factorial(2*xs:decimal($n)})
    =&gt; gn:take(8) 
    =&gt; gn:fold-left(0, fn($x, $y){$x + $y})</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">2.718281828458229747</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-fold-right"></a><span class="deltaxml-new" style="background:#90EE90">18.4.1.5 </span><a href="#generator-fold-right" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:fold-right</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Processes consecutively from right to left the values of the yield of the supplied generator, applying the supplied function repeatedly to each value in turn, together with an accumulated result value.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:fold-right</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$init</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$action</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn(item()*, item()*) as item()*) as item()*</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Let the yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> contains </span><code><span class="deltaxml-new" style="background:#90EE90">n</span></code><span class="deltaxml-new" style="background:#90EE90"> values. Let us denote these </span><code><span class="deltaxml-new" style="background:#90EE90">n</span></code><span class="deltaxml-new" style="background:#90EE90"> values as </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, ..., </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90"> If </span><code><span class="deltaxml-new" style="background:#90EE90">n eq 0</span></code><span class="deltaxml-new" style="background:#90EE90"> the function returns </span><code><span class="deltaxml-new" style="background:#90EE90">$init</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> If </span><code><span class="deltaxml-new" style="background:#90EE90">n gt 0</span></code><span class="deltaxml-new" style="background:#90EE90"> the function calls </span><code><span class="deltaxml-new" style="background:#90EE90">$action(</span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, $init)</span></code><span class="deltaxml-new" style="background:#90EE90"> returning a value </span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n-1</span></sub></var><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90"> If the yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> contains a previous value, the function then calls </span><code><span class="deltaxml-new" style="background:#90EE90">$action(</span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">n-1</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n-1</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> returning a value </span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">n-2</span></sub></var><span class="deltaxml-new" style="background:#90EE90">. To process the </span><var><span class="deltaxml-new" style="background:#90EE90">k</span><sub><span class="deltaxml-new" style="background:#90EE90">th</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> value it calls </span><code><span class="deltaxml-new" style="background:#90EE90">$action(</span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">k</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">k-1</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">This continues in the same way until the starting value of the yield of the</span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> is reached; the final result is the result of the last call on </span><code><span class="deltaxml-new" style="background:#90EE90">$action</span></code><span class="deltaxml-new" style="background:#90EE90">, that is </span><var><span class="deltaxml-new" style="background:#90EE90">A</span><sub><span class="deltaxml-new" style="background:#90EE90">0</span></sub></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The function delivers the same result as the following XQuery implementation.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">declare function gn:fold-right($generator, 
                              $init as item()*,  
                              $action as fn(item()*, item()*) as item()*) as item()*
{
  if($generator?end-reached) then $init
    else $action(gn:head($generator), 
	             gn:fold-right(gn:tail($generator), $init, $action))		
}</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(5) =&gt; gn:fold-right(0, fn($x, $y){$x + $y})</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">20</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator()
    =&gt; gn:fold-right(12345, fn($x, $y){$x + $y})</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">12345</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-fold-lazy"></a><span class="deltaxml-new" style="background:#90EE90">18.4.1.6 </span><a href="#generator-fold-lazy" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:fold-lazy</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Produces the same result as gn:fold-right on the entire yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> with the operation specified by </span><code><span class="deltaxml-new" style="background:#90EE90">$action</span></code><span class="deltaxml-new" style="background:#90EE90"> but also performs short-circuiting if detected by the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$short-circuit-detector</span></code><span class="deltaxml-new" style="background:#90EE90"> function.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:fold-lazy</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$init</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$action</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn(item()*, item()*) as item()*) as item()*</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$short-circuit-detector</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn(*) as item()*</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> doesn't contain any value, </span><code><span class="deltaxml-new" style="background:#90EE90">$init</span></code><span class="deltaxml-new" style="background:#90EE90"> is returned.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, the same processing as done with gn:fold-right is performed, but on each step of the traversal of the yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> the function </span><code><span class="deltaxml-new" style="background:#90EE90">$short-circuit-detector</span></code><span class="deltaxml-new" style="background:#90EE90"> is called, passing to it two arguments: the current value of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">'s yield and the value of </span><code><span class="deltaxml-new" style="background:#90EE90">$init</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><p><span class="deltaxml-new" style="background:#90EE90">The result of applying </span><code><span class="deltaxml-new" style="background:#90EE90">$short-circuit-detector</span></code><span class="deltaxml-new" style="background:#90EE90"> on these two arguments is a function. If the arity of the returned function is </span><code><span class="deltaxml-new" style="background:#90EE90">0</span></code><span class="deltaxml-new" style="background:#90EE90">, this means that short-circuiting has been detected. In this case the folding process ends and the result of applying this 0-arity function is returned. For example, if </span><code><span class="deltaxml-new" style="background:#90EE90">$action</span></code><span class="deltaxml-new" style="background:#90EE90"> is multiplication, a suitable </span><code><span class="deltaxml-new" style="background:#90EE90">$short-circuit-detector</span></code><span class="deltaxml-new" style="background:#90EE90"> function returns </span><code><span class="deltaxml-new" style="background:#90EE90">fn() {0}</span></code><span class="deltaxml-new" style="background:#90EE90"> if one of the two arguments passed to it is </span><code><span class="deltaxml-new" style="background:#90EE90">0</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Detecting the possibility of a short-circuiting makes it possible to fold the contents of an infinite-yield generator - for example computing the product of the infinite sequence of integers in [-3, ∞].</span></p></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The function delivers the same result as the following XQuery implementation.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">declare function gn:fold-lazy($generator as f:generator, 
                              $init as item()*, 
                              $action as fn(*), 
                              $short-circuit-detector as function(*)) as item()*
{
  if($generator?end-reached) then $init
  else
   let $current := $generator =?&gt; get-current()
     return
       if(function-arity($short-circuit-detector($current, $init)) eq 0)
         then $short-circuit-detector($current, $init)()
         else $action($current, gn:fold-lazy($generator =?&gt; move-next(), 
					     $init, 
					     $action, 
					     $short-circuit-detector))
}</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">let $multShortCircuitProvider := fn($x, $y)
        {
          if($x eq 0) then fn(){0}
            else fn($z) {$x * $z}
        },
        $gen-5ToInf := $gen2ToInf =&gt; gn:for-each(fn($n){$n -7})
     return
     (
       $gen2ToInf =&gt; gn:take(5) 
                  =&gt; gn:fold-lazy(1, $product, $multShortCircuitProvider),
				  
       $gen-5ToInf =&gt; gn:fold-lazy(1, $product, $multShortCircuitProvider)</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">(720, 0)</span></code></p><p><em><span class="deltaxml-new" style="background:#90EE90">(An infinite product in the 2nd expression is successfully evaluated.)</span></em></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-head"></a><span class="deltaxml-new" style="background:#90EE90">18.4.1.7 </span><a href="#generator-head" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:head</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Produces the first value contained in the yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:head</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the generator's yield doesn't contain any value, error [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">gn:take($generator, 1) =?&gt; get-current()</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:head()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">2</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:tail() =&gt; gn:head()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">3</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:head()</span></code></pre></div></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">Raises error FOGR0002.</span></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-some"></a><span class="deltaxml-new" style="background:#90EE90">18.4.1.8 </span><a href="#generator-some" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:some</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> if and only if the generator is initialized and its yield contains at least one value.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:some</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function produces </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> if the generator is initialized (</span><code><span class="deltaxml-new" style="background:#90EE90">$generator?initialized eq true()</span></code><span class="deltaxml-new" style="background:#90EE90">) and its yield contains values (</span><code><span class="deltaxml-new" style="background:#90EE90">$generator?end-reached eq false()</span></code><span class="deltaxml-new" style="background:#90EE90">).</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, the function returns </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$generator?initialized and not($generator?end-reached)</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:some()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:some()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-some-where"></a><span class="deltaxml-new" style="background:#90EE90">18.4.1.9 </span><a href="#generator-some-where" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:some-where</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> if the generator is initialized and its yield contains any value upon which evaluating the supplied predicate returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">. Otherwise, </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90"> is returned.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:some-where</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">function(item()*) as xs:boolean</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function produces </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> if the generator is initialized (</span><code><span class="deltaxml-new" style="background:#90EE90">$generator?initialized eq true()</span></code><span class="deltaxml-new" style="background:#90EE90">) and when filtered with the given predicate, the yield of the produced generator contains values:</span></p><p><code><span class="deltaxml-new" style="background:#90EE90">$generator =&gt; gn:filter($predicate) =&gt; gn:some()</span></code><span class="deltaxml-new" style="background:#90EE90"> .</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, the function returns </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">gn:some(gn:filter($generator, $predicate))</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(5) =&gt; gn:some-where(fn($n){$n ge 7})</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(5) =&gt; gn:some-where(fn($n){$n ge 6})</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:some-where(fn($n){$n ge 100})</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-value"></a><span class="deltaxml-new" style="background:#90EE90">18.4.1.10 </span><a href="#generator-value" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:value</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Produces the value contained in this generator-instance.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:value</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the generator's yield doesn't contain any value, error [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise returns the value obtained from the current generator-instance (</span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">)</span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This function is a synonym for the generator method </span><code><span class="deltaxml-new" style="background:#90EE90">get-current</span></code><span class="deltaxml-new" style="background:#90EE90">. The goal is to free the end user from the nuisance of having to enter additional parentheses within an expression due to the different precedence of the </span><code><span class="deltaxml-new" style="background:#90EE90">=?&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">=&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> operators. Thus, instead of having to write: </span></p><p><code><span class="deltaxml-new" style="background:#90EE90">($myGenerator =&gt; gn:take(5)) =?&gt; get-current()</span></code><span class="deltaxml-new" style="background:#90EE90">, one simply writes: </span></p><p><code><span class="deltaxml-new" style="background:#90EE90">$myGenerator =&gt; gn:take(5) =&gt; gn:value()</span></code></p></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$generator =?&gt; get-current()</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:value()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">2</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(3) =&gt; gn:skip(2) =&gt; gn:value(),</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">4</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:value()</span></code></pre></div></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">Raises error FOGR0002.</span></p></td></tr></tbody></table></div></dd></dl></div></div><div class="_diffs div3"><h4><a id="generator-functions-producing-generators"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2 </span><a href="#generator-functions-producing-generators" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">Functions that produce another generator from existing generators</span></a></h4><p><span class="deltaxml-new" style="background:#90EE90">Each of the functions in this section takes a generator as its first argument, and returns a generator. This allows chaining of function calls to produce complex transformations of the yields of the generators that are supplied as arguments. Only the starting instance of the result-generator is produced, and only the instances of the intermediate-result-generators that are required to compute this starting instance are produced. </span></p><table class="index"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Function</span></th><th><span class="deltaxml-new" style="background:#90EE90">Meaning</span></th></tr></thead><tbody><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:append</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Creates from a given </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> a new one whose yield is the yield of the original generator with the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code><span class="deltaxml-new" style="background:#90EE90"> appended to it.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:chunk</span></code></td><td><span class="deltaxml-new" style="background:#90EE90"> Returns a new generator each of whose yield values is a "chunk" of consecutive values of the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> held in an array of size </span><code><span class="deltaxml-new" style="background:#90EE90">$size</span></code><span class="deltaxml-new" style="background:#90EE90">, with the possible exception that the size of the array containing the last "chunk" could be smaller. </span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:concat</span></code></td><td><span class="deltaxml-new" style="background:#90EE90"> Returns a new generator whose yield consists of the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> followed by the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator2</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:distinct</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield contains only the distinct values from the original generator, in their original order.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:filter</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield contains exactly those values from the yield of the original generator, upon which the supplied predicate returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">, in their original order.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:for-each</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Produces a new generator, in the yield of which each value is the result of applying the function item </span><code><span class="deltaxml-new" style="background:#90EE90">$action</span></code><span class="deltaxml-new" style="background:#90EE90"> on the corresponding value of the yield of the original </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">, in their original order.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:for-each-pair</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Produces a new generator, in the yield of which each value is the result of applying the function item </span><code><span class="deltaxml-new" style="background:#90EE90">$action</span></code><span class="deltaxml-new" style="background:#90EE90"> on the corresponding values of the yields of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator1</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">$generator2</span></code><span class="deltaxml-new" style="background:#90EE90">, in their original order.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:insert-at</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a generator whose yield contains the first </span><code><span class="deltaxml-new" style="background:#90EE90">$position - 1</span></code><span class="deltaxml-new" style="background:#90EE90"> values of the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">, followed by the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code><span class="deltaxml-new" style="background:#90EE90">, followed by all the values of the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> starting from position </span><code><span class="deltaxml-new" style="background:#90EE90">$position</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:next</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Produces the next state/generator-instance obtained from the current generator-instance </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:prepend</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a generator, whose yield is the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code><span class="deltaxml-new" style="background:#90EE90"> followed by the values of the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:remove-at</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a generator, whose yield is the result of removing the </span><code><span class="deltaxml-new" style="background:#90EE90">$position</span></code><span class="deltaxml-new" style="background:#90EE90">th value from the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> . </span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:remove-where</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a generator whose yield is the result of removing from the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> all values upon which the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:replace</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a generator, whose yield is the result of replacing in the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> the first value upon which the application of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> with the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$replacement</span></code><span class="deltaxml-new" style="background:#90EE90"> . </span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:reverse</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a generator, the values of whose yield are the ones in the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> but in reverse order. </span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:scan-left</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a generator whose yield contains the partial results of the evaluation of the </span><code><span class="deltaxml-new" style="background:#90EE90">gn:fold-left</span></code><span class="deltaxml-new" style="background:#90EE90"> function with the same arguments.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:scan-right</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a generator whose yield contains the partial results of the evaluation of the </span><code><span class="deltaxml-new" style="background:#90EE90">gn:fold-right</span></code><span class="deltaxml-new" style="background:#90EE90"> function with the same arguments.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:skip</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a generator whose yield contains only the values of the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> after the </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90">th one and in their original order.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:skip-strict</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a generator whose yield contains the values of the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> after the </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90">th one. If the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> contains less than </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90"> values, and the supplied argument </span><code><span class="deltaxml-new" style="background:#90EE90">$raise-error-on-empty</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> then [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised. </span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:skip-while</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield contains all the values from the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">, having removed the longest leading segment of values on which the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:subrange</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield contains the values from the yield of the original </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">, from position </span><code><span class="deltaxml-new" style="background:#90EE90">$start</span></code><span class="deltaxml-new" style="background:#90EE90"> to position </span><code><span class="deltaxml-new" style="background:#90EE90">$end</span></code><span class="deltaxml-new" style="background:#90EE90">in their original order.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:tail</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield contains all the values but the first from the yield of the original </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> or raises [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">] if the supplied generator's yield is empty.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:take</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield is the leading segment with length </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90"> from the yield of the original </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> or raises [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">] if the supplied generator's yield is empty and </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90"> is greater than </span><code><span class="deltaxml-new" style="background:#90EE90">0</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:take-while</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield contains the longest leading segment from the yield of the original </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> on all values of which the provided function </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:zip</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a new generator the </span><code><span class="deltaxml-new" style="background:#90EE90">k</span></code><span class="deltaxml-new" style="background:#90EE90">th value of whose yield is an array having two members: the </span><code><span class="deltaxml-new" style="background:#90EE90">k</span></code><span class="deltaxml-new" style="background:#90EE90">th value of the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator1</span></code><span class="deltaxml-new" style="background:#90EE90"> and the </span><code><span class="deltaxml-new" style="background:#90EE90">k</span></code><span class="deltaxml-new" style="background:#90EE90">th value of the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator2</span></code><span class="deltaxml-new" style="background:#90EE90">, where </span><code><span class="deltaxml-new" style="background:#90EE90">k</span></code><span class="deltaxml-new" style="background:#90EE90">does not exceed the smaller of the lengths of the yields of the two generators. </span></td></tr></tbody></table><div class="_diffs div4"><h5><a id="generator-append"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.1 </span><a href="#generator-append" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:append</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Creates from a given </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> a new one whose yield is the yield of the original generator with the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code><span class="deltaxml-new" style="background:#90EE90"> appended to it.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:append</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A new generator </span><var><span class="deltaxml-new" style="background:#90EE90">Gen</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> is created, whose yield has a single value: </span><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The function returns the result of applying </span><code><span class="deltaxml-new" style="background:#90EE90">gn:concat</span></code><span class="deltaxml-new" style="background:#90EE90"> on the original </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> and the generator </span><var><span class="deltaxml-new" style="background:#90EE90">Gen</span><sub><span class="deltaxml-new" style="background:#90EE90">2</span></sub></var><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">let $gen := if(not($generator?initialized)) then $generator =?&gt; move-next()
              else $generator,
    $genSingle := $gen =&gt; map:put("get-current", fn($this as f:generator){$value})
                       =&gt; map:put("move-next", fn($this as f:generator)
                                                 {gn:empty-generator()})
                       =&gt; map:put("end-reached", false())
 return
   gn:concat($gen, $genSingle)</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:append(101) instance of f:generator</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:append(101) =&gt; gn:value()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">2</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(5) =&gt; gn:append(101) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,3,4,5,6,101]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:append(101) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[101]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-chunk"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.2 </span><a href="#generator-chunk" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:chunk</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> Returns a new generator each of whose yield values is a "chunk" of consecutive values of the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> held in an array of size </span><code><span class="deltaxml-new" style="background:#90EE90">$size</span></code><span class="deltaxml-new" style="background:#90EE90">, with the possible exception that the size of the array containing the last "chunk" could be smaller. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:chunk</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$size</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the generator's yield doesn't contain any value, an empty generator (with empty yield) is returned.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise returns a new generator: </span><var><span class="deltaxml-new" style="background:#90EE90">G</span><sub><span class="deltaxml-new" style="background:#90EE90">next</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, whose current-value is:</span></p><p><code><span class="deltaxml-new" style="background:#90EE90">$generator =&gt; gn:take($size) =&gt; gn:to-array()</span></code><span class="deltaxml-new" style="background:#90EE90">, and upon which the function </span><code><span class="deltaxml-new" style="background:#90EE90">gn:next(</span><var><span class="deltaxml-new" style="background:#90EE90">G</span><sub><span class="deltaxml-new" style="background:#90EE90">next</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)</span></code><span class="deltaxml-new" style="background:#90EE90"> produces the same generator as:</span></p><p><code><span class="deltaxml-new" style="background:#90EE90">$generator =&gt; gn:skip($size) =&gt; gn:chunk($size)</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">let $gen := if(not($generator?initialized)) then $generator =?&gt; move-next()
                else $generator
   return
     if($gen?end-reached) then gn:empty-generator()
     else
       let $thisChunk := gn:to-array(gn:take($gen, $size)),
           $cutGen := gn:skip($gen, $size),
           $resultGen := $gen =&gt; map:put("get-current", fn($this as f:generator){$thisChunk})
                              =&gt; map:put("move-next",   
                                         fn($this as f:generator){gn:chunk($cutGen, $size)})
        return $resultGen</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:chunk(20) =&gt; gn:some()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:chunk(10) =&gt; gn:value()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,3,4,5,6,7,8,9,10,11]</span></code></p><p><em><span class="deltaxml-new" style="background:#90EE90">(The first from an infinite number of chunks).</span></em></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:chunk(10) =&gt; gn:next() =&gt; gn:value()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[12,13,14,15,16,17,18,19,20,21]</span></code></p><p><em><span class="deltaxml-new" style="background:#90EE90">(The second from an infinite number of chunks).</span></em></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) 
            =&gt; gn:chunk(4) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[[2,3,4,5],[6,7,8,9],[10,11]]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) =&gt; gn:chunk(4) 
            =&gt; gn:for-each(fn($arr)
                      {array:size($arr)}) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[4,4,2]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-concat"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.3 </span><a href="#generator-concat" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:concat</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> Returns a new generator whose yield consists of the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> followed by the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator2</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:concat</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator2</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function produces a new generator whose yield consists of the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> followed by the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator2</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Thus, if the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> contains </span><code><span class="deltaxml-new" style="background:#90EE90">$M</span></code><span class="deltaxml-new" style="background:#90EE90"> values, and the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator2</span></code><span class="deltaxml-new" style="background:#90EE90"> contains </span><code><span class="deltaxml-new" style="background:#90EE90">$N</span></code><span class="deltaxml-new" style="background:#90EE90"> values.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The yield of the generator returned by the function: </span><code><span class="deltaxml-new" style="background:#90EE90">$result-generator</span></code><span class="deltaxml-new" style="background:#90EE90"> contains </span><code><span class="deltaxml-new" style="background:#90EE90">$M + $N</span></code><span class="deltaxml-new" style="background:#90EE90"> values, and:</span></p><p><code><span class="deltaxml-new" style="background:#90EE90">$result-generator =&gt; gn:take($M)</span></code><span class="deltaxml-new" style="background:#90EE90"> is a generator that has the same yield as </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">, and:</span></p><p><code><span class="deltaxml-new" style="background:#90EE90">$result-generator =&gt; gn:skip($M)</span></code><span class="deltaxml-new" style="background:#90EE90"> is a generator that has the same yield as </span><code><span class="deltaxml-new" style="background:#90EE90">$generator2</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">let $gen := if(not($generator?initialized)) then $generator =?&gt; move-next()
			else $generator,
    $gen2 := if(not($generator2?initialized)) then $gen2 =?&gt; move-next()
             else $generator2,
    $resultGen := if($gen?end-reached) then $gen2
                    else if($gen2?end-reached) then $gen
                         else
                           $gen  =&gt; map:put("move-next", 
                                            fn($this as f:generator)
                                              {
                                               let $nextGen := $gen =?&gt; move-next()
                                                return 
                                                  gn:concat($nextGen, $gen2)
                                              }
                                           )                                   
 return 
   $resultGen</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:subrange(10, 15) 
            =&gt; gn:concat($gen2ToInf =&gt; gn:subrange(1, 9)) 
            =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">[11,12,13,14,15,16,
 2,3,4,5,6,7,8,9,10]</span></pre></div></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() 
            =&gt; gn:concat(gn:empty-generator()) 
            =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() 
            =&gt; gn:concat($gen2ToInf =&gt; gn:take(1)) 
            =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(1) 
            =&gt; gn:concat(gn:empty-generator()) 
            =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:concat($gen2ToInf) =&gt; gn:value()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-distinct"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.4 </span><a href="#generator-distinct" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:distinct</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield contains only the distinct values from the original generator, in their original order.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:distinct</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> contains no values, that is: </span><code><span class="deltaxml-new" style="background:#90EE90">$generator =&gt; gn:some()</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90">, then </span><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator()</span></code><span class="deltaxml-new" style="background:#90EE90"> is returned. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, a generator is returned, the first value (</span><code><span class="deltaxml-new" style="background:#90EE90">$v1</span></code><span class="deltaxml-new" style="background:#90EE90">) of whose yield is the same as the first value of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">, and the remaining values are the distinct values of the yield of the generator </span><code><span class="deltaxml-new" style="background:#90EE90">$generator =&gt; gn:filter(fn($x){not(deep-equal($v1, $x))})</span></code></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">let $gen := if(not($generator?initialized)) then $generator =?&gt; move-next()
              else $generator
 return
   if($gen?end-reached) then $gen
   else
     let $priorValue := $gen =?&gt; get-current()
       return
         $gen =&gt; map:put("move-next", 
                         fn($this as f:generator)
                         {gn:distinct(gn:remove-where(gn:tail($gen), 
                                      fn($x){deep-equal($priorValue, $x)}
                                      ))})</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">gn:make-generator-from-sequence((1, 3, 1, 2, 1, 5, 3, 2))  
            =&gt; gn:distinct() =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[1,3,2,5]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf  
            =&gt; gn:for-each(fn($n){$n idiv 10}) 
            =&gt; gn:take(50) =&gt; gn:distinct() =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[0,1,2,3,4,5]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf  
            =&gt; gn:for-each(fn($n){$n idiv 10}) 
            =&gt; gn:take(100) =&gt; gn:distinct() =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">[0,1,2,3,4,5,
6,7,8,9,10]</span></pre></div></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf  
            =&gt; gn:for-each(fn($n){$n idiv 10}) 
            =&gt; gn:distinct() =&gt; gn:take(12) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">[0,1,2,3,4,5,
6,7,8,9,10,11]</span></pre></div><p><em><span class="deltaxml-new" style="background:#90EE90">(The first 12 distinct numbers from an infinite sequence.)</span></em></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:distinct() =&gt; gn:to-array() </span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-filter"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.5 </span><a href="#generator-filter" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:filter</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield contains exactly those values from the yield of the original generator, upon which the supplied predicate returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">, in their original order.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:filter</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn(item()*) as xs:boolean</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the supplied generator's yield is empty, this same generator is returned.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If none of the values of the supplied generator's yield satisfies the </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code><span class="deltaxml-new" style="background:#90EE90">, a generator with empty yield is returned.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise returns the concatenation of: a generator whose yield contains exactly one value - the first satisfying the predicate value (</span><code><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var></code><span class="deltaxml-new" style="background:#90EE90">), and the second generator to be concatenated: the result of filtering with the same </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code><span class="deltaxml-new" style="background:#90EE90"> the generator whose yield has the same values as the original generator, but with all values preceding and including </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">1</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> - removed.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The function delivers the same result as the following XQuery implementation.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">declare function gn:filter($generator as f:generator, 
                           $predicate as function(item()*) as xs:boolean) 
                    as f:generator
{
 if($generator?initialized and $generator?end-reached) 
  then gn:empty-generator()
  else
    let $getNextGoodGen := function($gen as map(*), 
                                    $pred as function(item()*) as xs:boolean)
       {
          if($gen?end-reached) then gn:empty-generator()
          else
            let $mapResult := 
                  while-do(
                           $gen,
                           function($x) { not($x?end-reached) 
                                         and not($pred($x =?&gt; get-current()))},
                           function($x) { $x =?&gt; move-next() }
                           )   
            return 
              if($mapResult?end-reached) then gn:empty-generator()
               else $mapResult                  
       },
       
       $gen := if($generator?initialized) then $generator 
                 else $generator =?&gt; move-next(),
       $nextGoodGen := $getNextGoodGen($gen, $pred)
    return
      if($nextGoodGen?end-reached) then gn:empty-generator()
      else
        $nextGoodGen  
	   =&gt; map:put("inputGen", $nextGoodGen)
	   =&gt; map:put("move-next", 
		      fn($this as f:generator) 
		      {
		        let $nextGoodGen := $getNextGoodGen($this?inputGen =?&gt; move-next(), 
		                                            $pred)
		         return
		           if($nextGoodGen?end-reached) then gn:empty-generator()
		             else
		               $nextGoodGen =&gt; map:put("move-next",   
						       fn($this as f:generator) 
							{gn:filter($nextGoodGen 
							             =?&gt; move-next(), $pred)})
					    =&gt; map:put("inputGen", $nextGoodGen)
		      }
			  )
  }</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:filter(fn($n){$n mod 2 eq 1}) =&gt; gn:value()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">3</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:filter(fn($n){$n mod 2 eq 1}) 
          =&gt; gn:next() =&gt; gn:value()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">5</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">
$gen2ToInf =&gt; gn:filter(fn($n){$n mod 2 eq 1}) 
               =&gt; gn:take(7) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">[3,5,7,9,
11, 13,15]</span></pre></div><p><em><span class="deltaxml-new" style="background:#90EE90">(The first 7 values of a filtered infinite generator.)</span></em></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">
$gen2ToInf =&gt; gn:take(10) =&gt; gn:filter(fn($n){$n gt 12}) 
                 =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">
gn:empty-generator() =&gt; gn:filter(fn($n){$n eq $n}) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-for-each"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.6 </span><a href="#generator-for-each" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:for-each</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Produces a new generator, in the yield of which each value is the result of applying the function item </span><code><span class="deltaxml-new" style="background:#90EE90">$action</span></code><span class="deltaxml-new" style="background:#90EE90"> on the corresponding value of the yield of the original </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">, in their original order.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:for-each</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$action</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn(item()*) as item()*</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> has no values, then a generator, whose yield has no values, is returned.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise a generator is returned, whose current value is </span><code><span class="deltaxml-new" style="background:#90EE90">$generator =&gt; gn:value() =&gt; $action()</span></code><span class="deltaxml-new" style="background:#90EE90">, and whose </span><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code><span class="deltaxml-new" style="background:#90EE90"> method produces </span><code><span class="deltaxml-new" style="background:#90EE90">$generator =&gt; gn:skip(1) =&gt; gn:for-each($action)</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">let $gen := if(not($generator?initialized)) then $generator =?&gt; move-next()
			else $generator        
return
 if($gen?end-reached) then gn:empty-generator()
  else
   let $current := $fun($gen =?&gt; get-current()),
       $newResultGen := map:put($gen, 
                                "get-current",
                                fn($this as f:generator){$current}),
       $nextGen := $gen =?&gt; move-next()
    return
	  if($nextGen?end-reached) then $newResultGen
	   else
	     let $newResultGen2 :=  map:put($newResultGen, "move-next",   
	                                    fn($this as f:generator) 
	                                    {gn:for-each($nextGen, $action)}) 
		   return
		     $newResultGen2</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:subrange(1, 5) =&gt; gn:for-each($double) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[4,6,8,10,12]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:for-each($double) =&gt; gn:take(5) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[4,6,8,10,12]</span></code></p><p><em><span class="deltaxml-new" style="background:#90EE90">(</span><code><span class="deltaxml-new" style="background:#90EE90">gn:for-each</span></code><span class="deltaxml-new" style="background:#90EE90"> on an infinite generator).</span></em></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:for-each($double) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-for-each-pair"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.7 </span><a href="#generator-for-each-pair" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:for-each-pair</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Produces a new generator, in the yield of which each value is the result of applying the function item </span><code><span class="deltaxml-new" style="background:#90EE90">$action</span></code><span class="deltaxml-new" style="background:#90EE90"> on the corresponding values of the yields of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator1</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">$generator2</span></code><span class="deltaxml-new" style="background:#90EE90">, in their original order.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:for-each-pair</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator1</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator2</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$action</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn(item()*, item()*) as item()*</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If one or both provided generators has an empty yield (yield that contains no values), then the result is a generator that has an empty yield. Otherwise:</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator1</span></code><span class="deltaxml-new" style="background:#90EE90"> is: </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">11</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">12</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, ..., </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">1n</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, and the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator2</span></code><span class="deltaxml-new" style="background:#90EE90"> is: </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">21</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">22</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, ..., </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">2m</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span></p><p><span class="deltaxml-new" style="background:#90EE90">then the result is a generator with yield that contains </span><code><span class="deltaxml-new" style="background:#90EE90">k = min(m, n)</span></code><span class="deltaxml-new" style="background:#90EE90"> values:</span></p><p><code><span class="deltaxml-new" style="background:#90EE90">$action(</span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">11</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">21</span></sub></var><span class="deltaxml-new" style="background:#90EE90">), $action(</span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">12</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">22</span></sub></var><span class="deltaxml-new" style="background:#90EE90">), ..., $action(</span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">1k</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, </span><var><span class="deltaxml-new" style="background:#90EE90">V</span><sub><span class="deltaxml-new" style="background:#90EE90">2k</span></sub></var><span class="deltaxml-new" style="background:#90EE90">)))</span></code></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">let $gen := if(not($generator1?initialized)) then $generator1 =?&gt; move-next()
            else $generator1,
    $gen2 := if(not($generator2?initialized)) then $generator2 =?&gt; move-next()
             else $generator2
return
  if($gen?end-reached or $gen2?end-reached) then gn:empty-generator() 
   else  
	 let $current := $fun($gen =?&gt; get-current(), $gen2 =?&gt; get-current()),
	     $newResultGen := map:put($gen, "get-current", 
	                              fn($this as f:generator){$current}),
	     $nextGen1 := $gen =?&gt; move-next(),
	     $nextGen2 := $gen2 =?&gt; move-next()
	  return
	    if($nextGen1?end-reached or $nextGen2?end-reached) then $newResultGen
	     else
	      let $newResultGen2 := map:put($newResultGen, "move-next",
                                            fn($this as f:generator)
                                            {gn:for-each-pair($nextGen1, $nextGen2, $action)})
	          return
	            $newResultGen2</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:subrange(1, 5) 
               =&gt; gn:for-each-pair($gen2ToInf =&gt; gn:subrange(6, 10), $sum2) 
               =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[9,11,13,15,17]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:for-each-pair($gen2ToInf, $sum2) 
               =&gt; gn:take(5) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[4,6,8,10,12]</span></code></p><p><em><span class="deltaxml-new" style="background:#90EE90">(</span><code><span class="deltaxml-new" style="background:#90EE90">gn:for-each-pair</span></code><span class="deltaxml-new" style="background:#90EE90"> applied on two infinite generators).</span></em></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() 
               =&gt; gn:for-each-pair($gen2ToInf =&gt; gn:subrange(6, 10), $sum2) 
               =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-insert-at"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.8 </span><a href="#generator-insert-at" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:insert-at</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a generator whose yield contains the first </span><code><span class="deltaxml-new" style="background:#90EE90">$position - 1</span></code><span class="deltaxml-new" style="background:#90EE90"> values of the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">, followed by the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code><span class="deltaxml-new" style="background:#90EE90">, followed by all the values of the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> starting from position </span><code><span class="deltaxml-new" style="background:#90EE90">$position</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:insert-at</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$position</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> contains less that </span><code><span class="deltaxml-new" style="background:#90EE90">$position - 1</span></code><span class="deltaxml-new" style="background:#90EE90"> values, error [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$position</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">1</span></code><span class="deltaxml-new" style="background:#90EE90"> then the function returns a generator whose yield is that of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">, prepended by the provided </span><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, the function returns a generator in whose yield the values at position from 1 to </span><code><span class="deltaxml-new" style="background:#90EE90">$position - 1</span></code><span class="deltaxml-new" style="background:#90EE90"> are the values from the yield of the original </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> at the same positions, the value at position </span><code><span class="deltaxml-new" style="background:#90EE90">$position</span></code><span class="deltaxml-new" style="background:#90EE90"> in the returned generator's yield is the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code><span class="deltaxml-new" style="background:#90EE90">, and the values in this yield after position </span><code><span class="deltaxml-new" style="background:#90EE90">$position</span></code><span class="deltaxml-new" style="background:#90EE90"> are the same as the remaining values in the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">'s yield starting at position </span><code><span class="deltaxml-new" style="background:#90EE90">$position</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">let $genTail := gn:skip-strict($generator, $position - 1, true())
 return
   if($position gt 1)
     then $generator =&gt; gn:take($position -1) =&gt; gn:append($value) =&gt; gn:concat($genTail)
     else $genTail =&gt; prepend($value)</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:insert-at(3, "XYZ") 
               =&gt; gn:take(10) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,3,"XYZ",4,5,6,7,8,9,10]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) 
               =&gt; gn:insert-at(1, "ABC") =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">["ABC",2,3,4,5,6,7,8,9,10,11]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) 
               =&gt; gn:insert-at(11, "PQR") 
               =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,3,4,5,6,7,8,9,10,11,"PQR"]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) 
               =&gt; gn:insert-at(12, "GHI") 
               =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">Raises error FOGR0002.</span></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-next"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.9 </span><a href="#generator-next" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:next</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Produces the next state/generator-instance obtained from the current generator-instance </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:next</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the generator's yield doesn't contain any value, error [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise returns the next state/generator-instance obtained from the current generator-instance </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">This function is a synonym for the generator method </span><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code><span class="deltaxml-new" style="background:#90EE90">. The goal is to free the end user from the nuisance of having to enter additional parentheses within an expression due to the different precedence of the </span><code><span class="deltaxml-new" style="background:#90EE90">=?&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">=&gt;</span></code><span class="deltaxml-new" style="background:#90EE90"> operators. Thus, instead of having to write: </span></p><p><code><span class="deltaxml-new" style="background:#90EE90">($myGenerator =&gt; gn:take(5)) =?&gt; move-next() =&gt; gn:head()</span></code><span class="deltaxml-new" style="background:#90EE90">, one simply writes: </span></p><p><code><span class="deltaxml-new" style="background:#90EE90">$myGenerator =&gt; gn:take(5) =&gt; gn:next() =&gt; gn:head()</span></code></p></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">$generator =?&gt; move-next()</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:next()  instance of f:generator</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:next()  =&gt; gn:head()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">3</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:next()  =&gt; gn:next()  =&gt; gn:head()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">4</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:next()</span></code></pre></div></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">Raises error FOGR0002.</span></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-prepend"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.10 </span><a href="#generator-prepend" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:prepend</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a generator, whose yield is the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code><span class="deltaxml-new" style="background:#90EE90"> followed by the values of the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:prepend</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A generator </span><var><span class="deltaxml-new" style="background:#90EE90">G</span><sub><span class="deltaxml-new" style="background:#90EE90">0</span></sub></var><span class="deltaxml-new" style="background:#90EE90">, whose yield contains a single value: </span><code><span class="deltaxml-new" style="background:#90EE90">$value</span></code><span class="deltaxml-new" style="background:#90EE90"> is constructed.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Then the result of the concatenation of </span><var><span class="deltaxml-new" style="background:#90EE90">G</span><sub><span class="deltaxml-new" style="background:#90EE90">0</span></sub></var><span class="deltaxml-new" style="background:#90EE90"> and the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> is returned.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">let $gen := if(not($generator?initialized)) then $generator =?&gt; move-next()
            else $generator,
    $genSingle := gn:empty-generator() =&gt; gn:append($value)
 return
    gn:concat($genSingle, $gen)</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:subrange(1, 5) 
            =&gt; gn:prepend(101) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[101,2,3,4,5,6]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:prepend(999) 
            =&gt; gn:take(5) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[999,2,3,4,5]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:prepend(777) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[777]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-remove-at"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.11 </span><a href="#generator-remove-at" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:remove-at</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a generator, whose yield is the result of removing the </span><code><span class="deltaxml-new" style="background:#90EE90">$position</span></code><span class="deltaxml-new" style="background:#90EE90">th value from the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> . </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:remove-at</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$position</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">$position</span></code><span class="deltaxml-new" style="background:#90EE90"> is greater than the number of values in the yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">, error FOGR0002 is raised.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, returns the concatenation of two generators: one whose yield contains the first </span><code><span class="deltaxml-new" style="background:#90EE90">$position -1</span></code><span class="deltaxml-new" style="background:#90EE90"> values from the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">, and the second: whose yield contains all values at positions greater than </span><code><span class="deltaxml-new" style="background:#90EE90">$position</span></code><span class="deltaxml-new" style="background:#90EE90"> from the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">let $genTail := gn:skip-strict($generator, $position, true())
  return
	if($position gt 1)
	  then gn:concat(gn:take($generator, $position - 1), $genTail)
	  else $genTail</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) 
            =&gt; gn:remove-at(3) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,3,5,6,7,8,9,10,11]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) 
            =&gt; gn:remove-at(1) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[3,4,5,6,7,8,9,10,11]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) 
            =&gt; gn:remove-at(10) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,3,4,5,6,7,8,9,10]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:remove-at(3) 
            =&gt; gn:take(10) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,3,5,6,7,8,9,10,11,12]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) 
            =&gt; gn:remove-at(11) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">Raises error FOGR0002.</span></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-remove-where"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.12 </span><a href="#generator-remove-where" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:remove-where</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a generator whose yield is the result of removing from the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> all values upon which the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:remove-where</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">function(item()*) as xs:boolean</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> is empty, then this same generator is returned.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise a generator is returned whose yield is the result of filtering the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> with a function that returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> exactly when the provided </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">let $gen := if(not($generator?initialized)) then $generator =?&gt; move-next()
             else $generator
  return
    gn:filter($gen, fn($x){not($predicate($x))})</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:remove-where(fn($x){$x mod 3 eq 0}) 
            =&gt; gn:take(10) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,4,5,7,8,10,11,13,14,16]</span></code></p><p><em><span class="deltaxml-new" style="background:#90EE90">(Removed all matching values from an infinite generator).</span></em></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:remove-where(fn($x){$x mod 3 eq 0})
                      =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-replace"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.13 </span><a href="#generator-replace" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:replace</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a generator, whose yield is the result of replacing in the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> the first value upon which the application of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> with the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$replacement</span></code><span class="deltaxml-new" style="background:#90EE90"> . </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:replace</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">function(item()*) as xs:boolean</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$replacement</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the yield of the provided </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> is empty, then </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> is returned.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If there is no value in the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">'s yield, upon which the application of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">, then the function returns the original </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, if the result of applying the </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code><span class="deltaxml-new" style="background:#90EE90"> on the first value of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">'s yield is </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">, then the function returns a generator the first value in whose yield is </span><code><span class="deltaxml-new" style="background:#90EE90">$replacement</span></code><span class="deltaxml-new" style="background:#90EE90">, and whose </span><code><span class="deltaxml-new" style="background:#90EE90">move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> method produces a generator having the same yield as </span><code><span class="deltaxml-new" style="background:#90EE90">$generator =?&gt; move-next()</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">If the result of applying the </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code><span class="deltaxml-new" style="background:#90EE90"> on the first value of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">'s yield is </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90">, then the function returns a generator whose </span><code><span class="deltaxml-new" style="background:#90EE90">get-current()</span></code><span class="deltaxml-new" style="background:#90EE90"> method is the same as that of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">, and whose </span><code><span class="deltaxml-new" style="background:#90EE90">move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> method returns the result of </span><code><span class="deltaxml-new" style="background:#90EE90">gn:replace</span></code><span class="deltaxml-new" style="background:#90EE90"> on the generator returned by </span><code><span class="deltaxml-new" style="background:#90EE90">$generator =?&gt; move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> . </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">if($generator?end-reached) then $generator
   else
    let $current := $generator =?&gt; get-current()
     return
       if($predicate($current))
         then let $nextGen := $generator =?&gt; move-next()
               return
                 $generator =&gt; map:put("get-current", fn($this as f:generator) {$replacement})
                            =&gt; map:put("move-next", fn($this as f:generator) { $nextGen })
         else (: $current is not the match for replacement :)
           let $nextGen := $generator =?&gt; move-next()
            return  
              $generator =&gt; map:put("move-next", 
                                    fn($this as f:generator)
                                    {
                                      let $intendedReplace := 
                                             function($z) 
                                             {$z =&gt; gn:replace($funIsMatching, $replacement)}
                                       return
                                         if($nextGen?end-reached) then $nextGen
                                            else $intendedReplace($nextGen)
                                    }
                                   )</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:replace(fn($x)
                         {$x gt 4}, "Replacement")  
            =&gt; gn:take(10) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,3,4,"Replacement",6,7,8,9,10,11]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) 
            =&gt; gn:replace(fn($x){$x lt 3},
                          "Replacement") 
            =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">["Replacement",3,4,5,6,7,8,9,10,11]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) 
            =&gt; gn:replace(fn($x){$x gt 10},
                          "Replacement") 
            =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,3,4,5,6,7,8,9,10,"Replacement"]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) 
            =&gt; gn:replace(fn($x){$x gt 11},
                          "Replacement") 
            =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,3,4,5,6,7,8,9,10,11]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) 
            =&gt; gn:replace(fn($x){$x lt 2},
                          "Replacement") 
            =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,3,4,5,6,7,8,9,10,11]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) 
            =&gt; gn:replace(fn($x){$x gt 4},
                          "Replacement") 
            =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,3,4,"Replacement",6,7,8,9,10,11]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() 
            =&gt; gn:replace(fn($x){$x eq $x},
                          "Replacement") 
            =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-reverse"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.14 </span><a href="#generator-reverse" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:reverse</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a generator, the values of whose yield are the ones in the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> but in reverse order. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:reverse</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the yield of the provided </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> is empty, then </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> is returned.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise a generator is returned, whose yield is the result of appending the current value of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> to the reversed yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator =&gt; gn:tail()</span></code><span class="deltaxml-new" style="background:#90EE90"> .</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">if($generator?end-reached) then gn:empty-generator()
  else
   let $current := $generator =?&gt; get-current()
    return
      gn:append(gn:reverse(gn:tail($generator)), $current)</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:reverse() 
            =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:append(2)  
            =&gt; gn:reverse() =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) 
            =&gt; gn:reverse() =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[11,10,9,8,7,6,5,4,3,2]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-scan-left"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.15 </span><a href="#generator-scan-left" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:scan-left</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a generator whose yield contains the partial results of the evaluation of the </span><code><span class="deltaxml-new" style="background:#90EE90">gn:fold-left</span></code><span class="deltaxml-new" style="background:#90EE90"> function with the same arguments.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:scan-left</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$init</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$action</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn(item()*, item()*) as item()*) as item()*</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> is empty, returns a generator whose yield contains a single value: the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$init</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise computes a partial result </span><code><span class="deltaxml-new" style="background:#90EE90">$partial-result</span></code><span class="deltaxml-new" style="background:#90EE90"> equal to </span><code><span class="deltaxml-new" style="background:#90EE90">$action($init, $generator =?&gt; get-current())</span></code><span class="deltaxml-new" style="background:#90EE90">, and a </span><code><span class="deltaxml-new" style="background:#90EE90">$next-generator</span></code><span class="deltaxml-new" style="background:#90EE90">, that is equal to </span><code><span class="deltaxml-new" style="background:#90EE90">$generator =?&gt; move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> and returns a generator, the first value of whose yield is </span><code><span class="deltaxml-new" style="background:#90EE90">$init</span></code><span class="deltaxml-new" style="background:#90EE90">, and the remaining values are the yield of the generator: </span><code><span class="deltaxml-new" style="background:#90EE90">gn:scan-left($next-generator, $partial-result, $action)</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The function delivers the same result as the following XQuery implementation.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">declare function gn:scan-left($generator as f:generator, $init as item()*, $action as fn(*)) 
           as f:generator
{
  let $resultGen := gn:empty-generator() 
                         =&gt; map:put("end-reached", false())
                         =&gt; map:put("get-current",   fn($this as f:generator){$init})
   return
     if($generator?end-reached) 
       then $resultGen =&gt; map:put("move-next", fn($this as f:generator)
                                               {gn:empty-generator()})
       else
         let $resultGen := $resultGen =&gt; map:put("get-current", 
                                                 fn($this as f:generator){$init}),
             $partialFoldResult := $action($init, $generator =?&gt; get-current())
           return
             let $nextGen := $generator =?&gt; move-next()
              return
                $resultGen =&gt; map:put("move-next", fn($this as f:generator)
                                      { 
                                          gn:scan-left($nextGen, $partialFoldResult, $action)
                                       }
                                      )            
}</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() 
         =&gt; gn:scan-left(0, fn($x, $y){$x + $y}) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[0]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(5)  
         =&gt; gn:scan-left(0, fn($x, $y){$x + $y}) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[0,2,5,9,14,20]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen0toInf 
   =&gt; gn:for-each(fn($n)
                  {(2*$n + 1) div $factorial(2*xs:decimal($n))}) 
   =&gt; gn:take(8) 
   =&gt; gn:scan-left(0, fn($x, $y){$x + $y}) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">[0,1,2.5,
 2.708333333333333333,
 2.718055555555555555,
 2.718278769841269841,
 2.718281801146384479,
 2.718281828286168563,
 2.718281828458229747]</span></pre></div><p><em><span class="deltaxml-new" style="background:#90EE90">(Infinite series summation: the partial sums from its first 8 steps.)</span></em></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-scan-right"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.16 </span><a href="#generator-scan-right" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:scan-right</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a generator whose yield contains the partial results of the evaluation of the </span><code><span class="deltaxml-new" style="background:#90EE90">gn:fold-right</span></code><span class="deltaxml-new" style="background:#90EE90"> function with the same arguments.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:scan-right</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$init</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$action</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn(item()*, item()*) as item()*) as item()*</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> is empty, returns a generator whose yield contains a single value: the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$init</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise returns the reversed yield of </span><code><span class="deltaxml-new" style="background:#90EE90">gn:scan-left(gn:reverse($generator), $init, $action)</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">gn:reverse(gn:scan-left(gn:reverse($gen), $init, $action))</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() 
       =&gt; gn:scan-right(0, fn($x, $y){$x + $y}) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[0]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$genN =&gt; gn:take(10) 
       =&gt; gn:scan-right(0, fn($x, $y){$x + $y}) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">[55,54,52,49,45,
 40,34,27,19,10,0]</span></pre></div></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-skip"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.17 </span><a href="#generator-skip" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:skip</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a generator whose yield contains only the values of the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> after the </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90">th one and in their original order.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:skip</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">xs:nonNegativeInteger</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">0</span></code><span class="deltaxml-new" style="background:#90EE90">, the function returns the same supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90"> is greater than the number of values of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">, the function returns an empty generator.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise the function returns the result of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator =&gt; gn:next() =&gt; gn:skip($n -1)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">gn:skip-strict($gen, $n, false())</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:skip(7) instance of f:generator</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(3) =&gt; gn:skip(2) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[4]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) =&gt; gn:skip(10) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) =&gt; gn:skip(11) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) =&gt; gn:skip(9) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[11]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-skip-strict"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.18 </span><a href="#generator-skip-strict" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:skip-strict</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a generator whose yield contains the values of the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> after the </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90">th one. If the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> contains less than </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90"> values, and the supplied argument </span><code><span class="deltaxml-new" style="background:#90EE90">$raise-error-on-empty</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> then [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:skip-strict</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">xs:nonNegativeInteger</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$raise-error-on-empty</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">0</span></code><span class="deltaxml-new" style="background:#90EE90">, the function returns the same supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90"> is greater than the number of values of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">, and the supplied argument </span><code><span class="deltaxml-new" style="background:#90EE90">$raise-error-on-empty</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90"> then [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">] is raised, otherwise (</span><code><span class="deltaxml-new" style="background:#90EE90">$raise-error-on-empty</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90">) the function returns an empty generator.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise the function returns the result of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator =&gt; gn:next() =&gt; gn:skip-strict($n -1, $raise-error-on-empty)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The function delivers the same result as the following XQuery implementation.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">declare function gn:skip-strict($gen as f:generator, 
                                $n as xs:nonNegativeInteger, 
                                $issueErrorOnEmpty as xs:boolean) as f:generator
{
  if($n eq 0) then $generator
    else if($generator?end-reached) 
           then if($issueErrorOnEmpty)
                 then error((), "Input Generator too-short") 
                 else gn:empty-generator()
    else 
      let $gen := if(not($generator?initialized)) then $generator =?&gt; move-next()
                   else $generator
        return
          if(not($gen?end-reached)) 
            then gn:skip-strict($gen =?&gt; move-next(), $n -1, $issueErrorOnEmpty)
            else gn:empty-generator()    
};</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:skip-strict(7, true()) instance of f:generator</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(3) =&gt; gn:skip-strict(2, true()) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[4]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) =&gt; gn:skip-strict(10, true()) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) =&gt; gn:skip-strict(11, false()) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) =&gt; gn:skip-strict(11, true()) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">Raises error FOGR0002.</span></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-skip-while"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.19 </span><a href="#generator-skip-while" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:skip-while</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield contains all the values from the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">, having removed the longest leading segment of values on which the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:skip-while</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn(item()*) as xs:boolean</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> is empty the function returns the same </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate($generator =&gt; gn:value())</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90">, the function returns the same </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise the function returns </span><code><span class="deltaxml-new" style="background:#90EE90">gn:skip-while($generator =?&gt; move-next(), $predicate)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The function delivers the same result as the following XQuery implementation.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">declare function gn:skip-while($generator as f:generator, 
                               $predicate as function(item()*) as xs:boolean) 
           as f:generator
{
  let $gen := if(not($generator?initialized)) then $generator =?&gt; move-next()
                else $generator
   return
     if($gen?end-reached) then gn:empty-generator()
      else
        let $current := $gen =?&gt; get-current()
         return
           if(not($predicate($current))) then $gen
            else gn:skip-while($gen =?&gt; move-next(), $pred)  
}</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:skip-while(fn($n){$n lt 11}) 
            =&gt; gn:take(5) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[11,12,13,14,15]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:skip-while(fn($n){$n lt 2})
            =&gt; gn:take(5) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,3,4,5,6]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() 
            =&gt; gn:skip-while(fn($n){$n lt 100}) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-subrange"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.20 </span><a href="#generator-subrange" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:subrange</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield contains the values from the yield of the original </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">, from position </span><code><span class="deltaxml-new" style="background:#90EE90">$start</span></code><span class="deltaxml-new" style="background:#90EE90"> to position </span><code><span class="deltaxml-new" style="background:#90EE90">$end</span></code><span class="deltaxml-new" style="background:#90EE90">in their original order.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:subrange</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$start</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$end</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">xs:positiveInteger</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">$start</span></code><span class="deltaxml-new" style="background:#90EE90"> is greater than the number of values in the yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> then the function returns an empty generator.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">$start</span></code><span class="deltaxml-new" style="background:#90EE90"> is greater than </span><code><span class="deltaxml-new" style="background:#90EE90">$end</span></code><span class="deltaxml-new" style="background:#90EE90"> then the function returns an empty generator.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, if the number of values in the yield of the supplied</span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">$gen-size</span></code><span class="deltaxml-new" style="background:#90EE90">, the function produces a generator, whose yield starts with the </span><code><span class="deltaxml-new" style="background:#90EE90">$start</span></code><span class="deltaxml-new" style="background:#90EE90">th value in the yield of the supplied</span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> and ends with the </span><code><span class="deltaxml-new" style="background:#90EE90">min($gen-size, $end - $start + 1)</span></code><span class="deltaxml-new" style="background:#90EE90">th value of this yield. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">gn:take(gn:skip($generator, $start - 1), $end - $start + 1)</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:subrange(4, 6) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[5,6,7]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) =&gt; gn:subrange(3, 13) 
            =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[4,5,6,7,8,9,10,11]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:subrange(1, 1) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) =&gt; gn:subrange(5, 3) 
            =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-tail"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.21 </span><a href="#generator-tail" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:tail</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield contains all the values but the first from the yield of the original </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> or raises [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">] if the supplied generator's yield is empty.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:tail</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> is empty, the function raises [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">].</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise the function returns a new generator, having as yield the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> with the first value skipped.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">gn:skip-strict($generator, 1, true())</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:tail() =&gt; gn:head()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">3</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:subrange(4, 6) =&gt; gn:tail() 
            =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[6, 7]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:tail() =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">Raises error FOGR0002.</span></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-take"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.22 </span><a href="#generator-take" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:take</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield is the leading segment with length </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90"> from the yield of the original </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> or raises [</span><a href="#ERRFOGR0002" title="err:FOGR0002"><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002</span></a><span class="deltaxml-new" style="background:#90EE90">] if the supplied generator's yield is empty and </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90"> is greater than </span><code><span class="deltaxml-new" style="background:#90EE90">0</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:take</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">xs:nonNegativeInteger</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If </span><code><span class="deltaxml-new" style="background:#90EE90">$n eq 0</span></code><span class="deltaxml-new" style="background:#90EE90"> the function returns an empty generator.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> is empty the function returns an empty generator.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> contains less than </span><code><span class="deltaxml-new" style="background:#90EE90">$n</span></code><span class="deltaxml-new" style="background:#90EE90"> values, the function returns </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise the function returns a generator, whose yield's only value is the first value of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">'s yield, concatenated with </span><code><span class="deltaxml-new" style="background:#90EE90">$generator =&gt; gn:next() =&gt; gn:take($n - 1)</span></code><span class="deltaxml-new" style="background:#90EE90"> .</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The function delivers the same result as the following XQuery implementation.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">declare function gn:take($generator as f:generator, $n as xs:integer) as f:generator
{
  let $gen := if(not($generator?initialized)) then $generator =?&gt; move-next()
                else $generator
   return
     if($gen?end-reached or $n le 0) then gn:empty-generator()
      else
        let $current := $gen =?&gt; get-current(),
            $newResultGen := map:put($gen, "get-current", fn($this as f:generator){$current}),
            $nextGen := $gen =?&gt; move-next()
         return
           if($nextGen?end-reached) then $newResultGen
             else
              let
               $newResultGen2 :=  map:put($newResultGen, 
                                          "move-next", 
                                          fn($this as f:generator) 
                                          {gn:take($nextGen, $n -1)}) 
                 return
                   $newResultGen2  
}</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(5) instance of f:generator</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(3) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,3,4]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(100000000) 
            =&gt; gn:value()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">2</span></code></p><p><em><span class="deltaxml-new" style="background:#90EE90">(Take 100 million numbers and then get the first of these - fast, with no delay.)</span></em></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:take(5) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-take-while"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.23 </span><a href="#generator-take-while" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:take-while</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield contains the longest leading segment from the yield of the original </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> on all values of which the provided function </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code><span class="deltaxml-new" style="background:#90EE90"> returns </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:take-while</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn(item()*) as xs:boolean</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> is empty the function returns an empty generator.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the the application of the </span><code><span class="deltaxml-new" style="background:#90EE90">$predicate</span></code><span class="deltaxml-new" style="background:#90EE90"> on the first value of the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90"> the function returns an empty generator.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise the function returns a generator whose yield id the concatenation of the first value of the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> with </span><code><span class="deltaxml-new" style="background:#90EE90">$generator =&gt; gn:next() =&gt; gn:take-while($predicate)</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The function delivers the same result as the following XQuery implementation.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">declare function gn:take-while($generator as f:generator, 
                               $predicate as function(item()*) as xs:boolean) 
                    as f:generator
{
  let $gen := if(not($generator?initialized)) then $generator =?&gt; move-next()
                else $generator
   return
     if($gen?end-reached) then gn:empty-generator()
      else      
        let $current := $gen =?&gt; get-current()
          return
            if(not($predicate($current))) then gn:empty-generator()
            else
              let $newResultGen := map:put($gen, "get-current", 
                                           fn($this as f:generator){$current}),
                  $nextGen := $gen =?&gt; move-next()
               return
                  if($nextGen?end-reached) then $newResultGen
                  else
                    let $newResultGen2 :=  map:put($newResultGen, "move-next", 
                                                   fn($this as f:generator)
                                                   {gn:take-while($nextGen, $pred)}) 
                     return $newResultGen2    
}</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take-while(fn($n){$n lt 11}) 
            =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,3,4,5,6,7,8,9,10]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take-while(fn($n){$n lt 2}) 
            =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() 
            =&gt; gn:take-while(fn($n){$n lt 2}) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf 
            =&gt; gn:take-while(fn($n){$n lt 100000000}) =&gt; gn:value()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">2</span></code></p><p><em><span class="deltaxml-new" style="background:#90EE90">(Take all numbers less than 100 million and then get the first of these - fast, with no delay.)</span></em></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-zip"></a><span class="deltaxml-new" style="background:#90EE90">18.4.2.24 </span><a href="#generator-zip" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:zip</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a new generator the </span><code><span class="deltaxml-new" style="background:#90EE90">k</span></code><span class="deltaxml-new" style="background:#90EE90">th value of whose yield is an array having two members: the </span><code><span class="deltaxml-new" style="background:#90EE90">k</span></code><span class="deltaxml-new" style="background:#90EE90">th value of the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator1</span></code><span class="deltaxml-new" style="background:#90EE90"> and the </span><code><span class="deltaxml-new" style="background:#90EE90">k</span></code><span class="deltaxml-new" style="background:#90EE90">th value of the yield of </span><code><span class="deltaxml-new" style="background:#90EE90">$generator2</span></code><span class="deltaxml-new" style="background:#90EE90">, where </span><code><span class="deltaxml-new" style="background:#90EE90">k</span></code><span class="deltaxml-new" style="background:#90EE90">does not exceed the smaller of the lengths of the yields of the two generators. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:zip</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator1</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code><span class="deltaxml-new" style="background:#90EE90">,</span></td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator2</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If any of the yields of the two provided generators: </span><code><span class="deltaxml-new" style="background:#90EE90">$generator1</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">$generator2</span></code><span class="deltaxml-new" style="background:#90EE90"> is empty, the function returns an empty generator.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise the function returns the result of:</span></p><p><code><span class="deltaxml-new" style="background:#90EE90">gn:for-each-pair($generator1, $generator2, fn($x1, $x2){[$x1, $x2]})</span></code><span class="deltaxml-new" style="background:#90EE90"> .</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">gn:for-each-pair($generator1, $generator2, fn($x1, $x2){[$x1, $x2]})</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">gn:zip($gen2ToInf =&gt; gn:subrange(1, 5),
        $gen2ToInf =&gt; gn:subrange(6, 10)) 
        =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[[2,7],[3,8],[4,9],[5,10],[6,11]]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:zip($gen2ToInf,
        $gen2ToInf =&gt; gn:skip(5)) 
        =&gt; gn:take(10) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16]]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:zip(gn:empty-generator(),
        $gen2ToInf =&gt; gn:subrange(6, 10)) 
        =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr></tbody></table></div></dd></dl></div></div><div class="_diffs div3"><h4><a id="generator-functions-producing-generators-from-providers"></a><span class="deltaxml-new" style="background:#90EE90">18.4.3 </span><a href="#generator-functions-producing-generators-from-providers" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">Functions that produce a generator from a data provider</span></a></h4><p><span class="deltaxml-new" style="background:#90EE90">The functions in this section construct generators whose yield is supplied by an </span><span><b><span class="deltaxml-new" style="background:#90EE90">external provider function</span></b></span><span class="deltaxml-new" style="background:#90EE90">. Providers allow generators to expose yields that are too large to fit into memory, must be computed incrementally, or require access to external systems (such as files, databases, or web services).</span></p><p><span class="deltaxml-new" style="background:#90EE90">A provider function is responsible for producing, on each invocation, both:</span></p><ol class="enumar"><li><p><span><b><span class="deltaxml-new" style="background:#90EE90">state-data</span></b></span><span class="deltaxml-new" style="background:#90EE90"> - an array with information required for the provider to compute its next result, and</span></p></li><li><p><span><b><span class="deltaxml-new" style="background:#90EE90">result-data</span></b></span><span class="deltaxml-new" style="background:#90EE90"> - an array either containing a single yield-value or empty, signaling that the data for producing the yield has been exhausted.</span></p></li></ol><p><span class="deltaxml-new" style="background:#90EE90">The generator returned by these functions behaves identically to any other generator: values are not computed eagerly but are obtained only as result of evaluating the method </span><code><span class="deltaxml-new" style="background:#90EE90">move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> followed by the evaluation of the method </span><code><span class="deltaxml-new" style="background:#90EE90">get-current()</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><table class="index"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Function</span></th><th><span class="deltaxml-new" style="background:#90EE90">Meaning</span></th></tr></thead><tbody><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield does not contain any values.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:make-generator</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a generator, the values of whose yield are obtained by consecutive calls to a supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$provider</span></code><span class="deltaxml-new" style="background:#90EE90"> function.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:make-generator-from-array</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a generator, the values of whose yield are the values of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code><span class="deltaxml-new" style="background:#90EE90"> array.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:make-generator-from-sequence</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a generator, the values of whose yield are the values of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code><span class="deltaxml-new" style="background:#90EE90"> sequence.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:make-generator-from-map</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a generator, whose yield is the sequence of all single map entries of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code><span class="deltaxml-new" style="background:#90EE90"> map.</span></td></tr></tbody></table><div class="_diffs div4"><h5><a id="generator-empty-generator"></a><span class="deltaxml-new" style="background:#90EE90">18.4.3.1 </span><a href="#generator-empty-generator" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield does not contain any values.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name return-type"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator</span></code><span class="deltaxml-new" style="background:#90EE90">()</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a new generator whose yield does not contain any values.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">initialized</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">end-reached</span></code><span class="deltaxml-new" style="background:#90EE90"> fields of the result are both set to </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">f:generator(initialized := true(), end-reached := true(),
            get-current := fn($this as f:generator)
                           {error(QName('http://www.w3.org/2005/xqt-errors', 'err:FOGR0002'),
                            "get-current() called on an empty-generator")},
            move-next := fn($this as f:generator)
                           {error(QName('http://www.w3.org/2005/xqt-errors', 'err:FOGR0002'),
                            "move-next() called on an empty-generator")},
            )</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:to-array() =&gt; array:empty()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-make-generator"></a><span class="deltaxml-new" style="background:#90EE90">18.4.3.2 </span><a href="#generator-make-generator" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:make-generator</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a generator, the values of whose yield are obtained by consecutive calls to a supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$provider</span></code><span class="deltaxml-new" style="background:#90EE90"> function.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:make-generator</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$provider</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">function(array(*)) as array(*)</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">$provider</span></code><span class="deltaxml-new" style="background:#90EE90"> function is called to get the first value of the yield of the result-generator. It accepts as argument an array, that contains data, referred to as "state-data" here, necessary to identify and return its next result. On the first call to the </span><code><span class="deltaxml-new" style="background:#90EE90">$provider</span></code><span class="deltaxml-new" style="background:#90EE90">, an empty array is passed as the state-data.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><code><span class="deltaxml-new" style="background:#90EE90">$provider</span></code><span class="deltaxml-new" style="background:#90EE90"> returns an array with two members. The first member is the state-data to be passed to it on the next call. The second member is an array, containing the current value of the result-generator. </span></p><p><span class="deltaxml-new" style="background:#90EE90">To signal that there are no more yield-values to be returned the </span><code><span class="deltaxml-new" style="background:#90EE90">$provider</span></code><span class="deltaxml-new" style="background:#90EE90"> returns an empty array as its result's second member. When this happens no more calls to the </span><code><span class="deltaxml-new" style="background:#90EE90">$provider</span></code><span class="deltaxml-new" style="background:#90EE90"> are made and the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code><span class="deltaxml-new" style="background:#90EE90"> method of the current result-generator-instance is set to return an empty generator. </span></p><p><span class="deltaxml-new" style="background:#90EE90">If the </span><code><span class="deltaxml-new" style="background:#90EE90">$provider</span></code><span class="deltaxml-new" style="background:#90EE90"> returns a non-empty array as its result's second member, the value of the single member of this non-empty array is set to be returned by the </span><code><span class="deltaxml-new" style="background:#90EE90">get-current</span></code><span class="deltaxml-new" style="background:#90EE90"> method of the current result-generator instance and the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code><span class="deltaxml-new" style="background:#90EE90"> method of the current result-generator instance is specified in such a way that, when it is called, it would itself call the </span><code><span class="deltaxml-new" style="background:#90EE90">$provider</span></code><span class="deltaxml-new" style="background:#90EE90"> with the latest returned state-data and based on the return of that call would construct correctly the next result-generator instance. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">let $gen := if(not($generator?initialized)) then $generator =?&gt; move-next()
              else $generator,
    $providerResult := $provider([]),
    $nextProviderState := $providerResult(1),
    $nextDataItemHolder := $providerResult(2)
 return
    let $nextGen := if(array:empty($nextDataItemHolder)) 
                      then gn:empty-generator()  
                      else gn:empty-generator()
                      =&gt; map:put("providerState", $nextProviderState)
                      =&gt; map:put("current", $nextDataItemHolder(1))
                      =&gt; map:put("end-reached", false())
                      =&gt; map:put("get-current", fn($this as f:generator) {$this?current})
                      =&gt; map:put("move-next",  
                                 fn($this as f:generator) 
                                 {
                                  let $nextProviderResult := $provider($this?providerState),
                                      $nextDataItemHolder := $nextProviderResult(2)
                                    return
                                      if(array:empty($nextDataItemHolder)) 
                                        then gn:empty-generator()
                                        else
                                          $this =&gt; map:put("current", $nextDataItemHolder(1))
                                                =&gt; map:put("providerState", 
                                                           $nextProviderResult(1))
                                 }
                                )
                             
    return $nextGen</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">
gn:make-generator(fn($state as array(*))
                 {
                  let $numGenerated := if(array:empty($state)) then 0
                                       else $state[1]
                   return
                      if($numGenerated le 9) 
                      then [ [$numGenerated + 1], [$numGenerated + 1] ]
                      else [[-1], []]
                 } 
                 ) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">[1,2,3,4,5,6,
7,8,9,10]</span></pre></div></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">
gn:make-generator(fn($state as array(*))
                {
                  let $numGenerated := if(array:empty($state)) then 0
                                       else $state[1]
                    return
                      [ [$numGenerated + 1], [$numGenerated + 1] ]
                } 
                 ) =&gt; gn:value()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">1</span></code></p><p><em><span class="deltaxml-new" style="background:#90EE90">(Make a generator from an infinite provider, then get its first value - immediately , with no delay.)</span></em></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">
gn:make-generator(fn($state as array(*))
                {
                  let $numGenerated := if(array:empty($state)) then 0
                                       else $state[1]
                    return
                      [ [$numGenerated + 1], [$numGenerated + 1] ]
                } 
                 ) =&gt; gn:subrange(10, 15) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[10,11,12,13,14,15]</span></code></p><p><em><span class="deltaxml-new" style="background:#90EE90">(Get a subrange of values from a generator created with an infinite provider - immediately , with no delay.)</span></em></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-make-generator-from-array"></a><span class="deltaxml-new" style="background:#90EE90">18.4.3.3 </span><a href="#generator-make-generator-from-array" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:make-generator-from-array</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a generator, the values of whose yield are the values of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code><span class="deltaxml-new" style="background:#90EE90"> array.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:make-generator-from-array</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">array(*)</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The function uses a provider function, whose state-data is the last-processed array index, and whose result is the new state-data and the </span><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code><span class="deltaxml-new" style="background:#90EE90"> array's value at the next index.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code><span class="deltaxml-new" style="background:#90EE90"> array is empty, the function returns an empty generator.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, it calls </span><code><span class="deltaxml-new" style="background:#90EE90">gn:make-generator</span></code><span class="deltaxml-new" style="background:#90EE90">, passing to it the so constructed provider-function, and returns the result of this call.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">let $size := array:size($input),
      $arrayProvider := fn($state as array(xs:integer?))
                        {
                          let $ind := if(array:empty($state))
                                      then 0
                                      else $state(1),
                              $newState := if($ind +1 gt $size) then []   
                                             else [$ind +1],
                              $newResult := if($ind +1 gt $size) then []
                                              else [$input($ind + 1)]
                           return [$newState, $newResult]
                        }
   return gn:make-generator($arrayProvider)</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">
gn:make-generator-from-array([1, 4, 9, 16, 25]) 
           instance of f:generator</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">
gn:make-generator-from-array([1, 4, 9, 16, 25]) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[1,4,9,16,25]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">
gn:make-generator-from-array([]) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-make-generator-from-sequence"></a><span class="deltaxml-new" style="background:#90EE90">18.4.3.4 </span><a href="#generator-make-generator-from-sequence" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:make-generator-from-sequence</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a generator, the values of whose yield are the values of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code><span class="deltaxml-new" style="background:#90EE90"> sequence.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:make-generator-from-sequence</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The function uses a provider function, whose state-data is the last-processed sequence position, and whose result is the new state-data and the value of the </span><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code><span class="deltaxml-new" style="background:#90EE90"> sequence at the next position.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code><span class="deltaxml-new" style="background:#90EE90"> sequence is empty, the function returns an empty generator.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, it calls </span><code><span class="deltaxml-new" style="background:#90EE90">gn:make-generator</span></code><span class="deltaxml-new" style="background:#90EE90">, passing to it the so constructed provider-function, and returns the result of this call.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">let $size := count($input), 
    $seqProvider := fn($state as array(xs:integer?))
                      {
                          let $ind := if(array:empty($state))
                                      then 0
                                      else $state(1),
                              $newState := if($ind +1 gt $size) then []   
                                             else [$ind +1],
                              $newResult := if($ind +1 gt $size) then []
                                              else [$input[$ind + 1]] 
                           return [$newState, $newResult]                  
                       }
   return gn:make-generator($seqProvider)</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">
gn:make-generator-from-sequence((1, 8, 27, 64, 125)) 
      instance of f:generator</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">
gn:make-generator-from-sequence(()) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">
gn:make-generator-from-sequence((1, 8, 27, 64, 125)) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[1,8,27,64,125]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-make-generator-from-map"></a><span class="deltaxml-new" style="background:#90EE90">18.4.3.5 </span><a href="#generator-make-generator-from-map" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:make-generator-from-map</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a generator, whose yield is the sequence of all single map entries of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code><span class="deltaxml-new" style="background:#90EE90"> map.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:make-generator-from-map</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">map(*)</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The function uses a provider function, whose state-data is the position of the last-processed map key, and whose result is the new state-data and the single-entry of the </span><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code><span class="deltaxml-new" style="background:#90EE90"> map for the next key of the map.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$input</span></code><span class="deltaxml-new" style="background:#90EE90"> map is empty, the function returns an empty generator.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, it calls </span><code><span class="deltaxml-new" style="background:#90EE90">gn:make-generator</span></code><span class="deltaxml-new" style="background:#90EE90">, passing to it the so constructed provider-function, and returns the result of this call.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">let $keys := map:keys($inputMap),
    $size := map:size($inputMap),
    $mapProvider := fn($state as array(xs:integer?))
    {	
	let $ind := if(array:empty($state))
                   then 0
                   else $state(1),
	    $newState := if($ind +1 gt $size) then []   
                         else [$ind +1],
	    $newResult := if($ind +1 gt $size) then []
                          else
                           let $key := $keys[$ind + 1]
                            return
                              [map:entry($key, $inputMap($key))]
        return [$newState, $newResult]                                      
     }                        
 return gn:make-generator($mapProvider)</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">
let $myMap := {"John": 22, "Ann": 28, "Peter": 31}
 return 
   gn:make-generator-from-map($myMap) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">[{"John":22},
{"Ann":28},
{"Peter":31}]</span></pre></div></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">
 let $myMap := {"John": 22, "Ann": 28, "Peter": 31},
     $genMap := gn:make-generator-from-map($myMap)
  return
     $genMap =&gt; gn:to-map()</span></code></pre></div></td><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">{"John":22,
"Ann":28,
"Peter":31}</span></pre></div></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">
let $myMap := {}
 return 
   gn:make-generator-from-map($myMap) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">
let $myMap := {}
 return 
   gn:make-generator-from-map($myMap) =&gt; gn:to-map()()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">{}</span></code></p></td></tr></tbody></table></div></dd></dl></div></div><div class="_diffs div3"><h4><a id="generator-functions-producing-xpath-collections-from-generators"></a><span class="deltaxml-new" style="background:#90EE90">18.4.4 </span><a href="#generator-functions-producing-xpath-collections-from-generators" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">Functions that produce an XPath collection from a generator</span></a></h4><p><span class="deltaxml-new" style="background:#90EE90">Generators can be used to construct standard XPath collections: arrays, maps, and sequences.</span></p><table class="index"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Function</span></th><th><span class="deltaxml-new" style="background:#90EE90">Meaning</span></th></tr></thead><tbody><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:to-array</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns an array, whose members are the values of the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:to-map</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a map, whose single entries (key-value pairs) are obtained from the values of the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></td></tr><tr><td style="white-space:nowrap; vertical-align:top"><code><span class="deltaxml-new" style="background:#90EE90">gn:to-sequence</span></code></td><td><span class="deltaxml-new" style="background:#90EE90">Returns a sequence, whose items are obtained from the values of the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></td></tr></tbody></table><div class="_diffs div4"><h5><a id="generator-to-array"></a><span class="deltaxml-new" style="background:#90EE90">18.4.4.1 </span><a href="#generator-to-array" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:to-array</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns an array, whose members are the values of the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:to-array</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">array(*)</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> has an empty yield, or is not initialized, the function returns an emprty array.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise, starting from an empty array-result, the function appends to it every value contained in the yield of the </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> until there are no more values in the yield. Then, this array-result is returned.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve" class="small"><span class="deltaxml-new" style="background:#90EE90">while-do( [$generator, []],
	  function( $in-out-args) 
	  { $in-out-args(1)?initialized and not($in-out-args(1)?end-reached) },
	  function($in-out-args) 
	           { array{$in-out-args(1) =?&gt; move-next(), 
	             array:append($in-out-args(2), $in-out-args(1) =?&gt; get-current())
	           }
	   }
) (2)</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">
gn:empty-generator() =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[]</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">
$gen2ToInf =&gt; gn:take(3) 
           =&gt; gn:to-array() instance of array(*)</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">
 $gen2ToInf =&gt; gn:take(3) =&gt; gn:to-array()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">[2,3,4]</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-to-map"></a><span class="deltaxml-new" style="background:#90EE90">18.4.4.2 </span><a href="#generator-to-map" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:to-map</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a map, whose single entries (key-value pairs) are obtained from the values of the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:to-map</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">map(*)</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">If the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> has an empty yield the function returns an empty map.</span></p><p><span class="deltaxml-new" style="background:#90EE90">If the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> contains a value that is not a map-entry, an error is raised. </span></p><p><span class="deltaxml-new" style="background:#90EE90">Otherwise the function returns a map all single-map-entries of which are the values of the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">map:merge($generator =&gt; gn:to-sequence())</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:to-map()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">{}</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">let $myMap := {}
  return 
    gn:make-generator-from-map($myMap) =&gt; gn:to-map()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">{}</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">let $myMap := {"John": 22, "Ann": 28, "Peter": 31},
    $genMap := gn:make-generator-from-map($myMap)
  return
    $genMap =&gt; gn:to-map()</span></code></pre></div></td><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">{"John":22,"Ann":28,
"Peter":31}</span></pre></div></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) =&gt; gn:to-map()</span></code></pre></div></td><td style="vertical-align:top"><p><span class="deltaxml-new" style="background:#90EE90">Raises error FORG0006.</span></p><p><em><span class="deltaxml-new" style="background:#90EE90">(Because the values are not map-entries.)</span></em></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:take(10) =&gt; gn:chunk(2) 
            =&gt; gn:for-each(fn($chunk)
                          {map:entry($chunk(1), $chunk(2))})
            =&gt;   gn:to-map()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">{2:3,4:5,6:7,8:9,10:11}</span></code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div4"><h5><a id="generator-to-sequence"></a><span class="deltaxml-new" style="background:#90EE90">18.4.4.3 </span><a href="#generator-to-sequence" style="text-decoration: none"><span class="deltaxml-new" style="background:#90EE90">gn:to-sequence</span></a></h5><dl><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Summary</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">Returns a sequence, whose items are obtained from the values of the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Signature</span></dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">gn:to-sequence</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">as&nbsp;</span></code><code class="type"><code><span class="deltaxml-new" style="background:#90EE90">fn:generator</span></code></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code><code><span class="deltaxml-new" style="background:#90EE90">item(*)</span></code></code></td></tr></tbody></table></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Properties</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function is </span><a title="deterministic" class="termref" href="#dt-deterministic"><span class="deltaxml-new" style="background:#90EE90">deterministic</span></a><span class="deltaxml-new" style="background:#90EE90">, </span><a title="context-independent" class="termref" href="#dt-context-independent"><span class="deltaxml-new" style="background:#90EE90">context-independent</span></a><span class="deltaxml-new" style="background:#90EE90">, and </span><a title="focus-dependent" class="termref" href="#dt-focus-independent"><span class="deltaxml-new" style="background:#90EE90">focus-independent</span></a><span class="deltaxml-new" style="background:#90EE90">. </span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Rules</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">This function obtains and outputs every value of the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code></p><p><span class="deltaxml-new" style="background:#90EE90">An empty sequence is returned if the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> has an empty yield.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Any value from the yield of the supplied </span><code><span class="deltaxml-new" style="background:#90EE90">$generator</span></code><span class="deltaxml-new" style="background:#90EE90"> that is an empty sequence, is not represented in the result returned by the function.</span></p></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Formal Equivalent</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">The effect of the function is equivalent to the result of the following XPath expression.</span></p><div class="exampleInner"><pre xml:space="preserve"><span class="deltaxml-new" style="background:#90EE90">gn:to-array($generator) =&gt; array:items()</span></pre></div></dd><dt class="label"><span class="deltaxml-new" style="background:#90EE90">Examples</span></dt><dd><div class="example"><table class="medium"><thead><tr><th><span class="deltaxml-new" style="background:#90EE90">Expression</span></th><th><span class="deltaxml-new" style="background:#90EE90">Result</span></th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator() =&gt; gn:to-sequence()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">()</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">$gen2ToInf =&gt; gn:filter(fn($n){$n mod 2 eq 1}) 
            =&gt; gn:take(10) =&gt; gn:to-sequence()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">(3,5,7,9,11,13,15,17,19,21)</span></code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code><span class="deltaxml-new" style="background:#90EE90">gn:make-generator-from-array([(),1,(),2,(),3]) 
            =&gt; gn:to-sequence()</span></code></pre></div></td><td style="vertical-align:top"><p><code><span class="deltaxml-new" style="background:#90EE90">(1, 2, 3)</span></code></p><p><em><span class="deltaxml-new" style="background:#90EE90">(Every value that is an empty sequence is not present in the result.)</span></em></p></td></tr></tbody></table></div></dd></dl></div></div></div></div><div class="_diffs div1"><h2><a id="dynamic-loading"></a><span class="deltaxml-old" style="background:#FF5555">18</span><span class="deltaxml-new" style="background:#90EE90">19</span> <a href="#dynamic-loading" style="text-decoration: none">Dynamic evaluation</a></h2><p>The following functions allow dynamic loading and evaluation of XQuery queries, XSLT stylesheets, and XPath binary operators.</p><table class="index"><thead><tr><th>Function</th><th>Meaning</th></tr></thead><tbody><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-load-xquery-module"><code>fn:load-xquery-module</code></a></td><td>Provides access to the public functions and global variables of a dynamically loaded XQuery library module.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-transform"><code>fn:transform</code></a></td><td>Invokes a transformation using a dynamically loaded XSLT stylesheet.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-op"><code>fn:op</code></a></td><td>Returns a function whose effect is to apply a supplied binary operator to two arguments.</td></tr></tbody></table><div class="_diffs div2"><h3><a id="load-xquery-module-record"></a><span class="deltaxml-old" style="background:#FF5555">18.1</span><span class="deltaxml-new" style="background:#90EE90">19.1</span> <a href="#load-xquery-module-record" style="text-decoration: none">Record fn:load-xquery-module-record</a></h3><p>This record type is used to hold the result of the <a href="#func-load-xquery-module"><code>fn:load-xquery-module</code></a> function.</p><table class="fos-options"><thead><tr><th>Name</th><th>Meaning</th></tr></thead><tbody><tr><td><p><code>variables</code></p></td><td class="fos-thin"><p>This map (<var>V</var> ) contains one entry for each public global variable declared in the library module. The key of the entry is the name of the variable, as an <code>xs:QName</code> value; the associated value is the value of the variable.</p><ul><li><p><b>Type: </b><code>map(xs:QName, item()*)</code></p></li></ul></td></tr><tr><td><p><code>functions</code></p></td><td class="fos-thin"><p>This map (<var>F</var> ) contains one entry for each distinct QName <var>Q</var> that represents the name of a public and non-external function declared in the library module. The key of the entry is <var>Q</var>, as an <code>xs:QName</code> value; the associated value is a map <var>A</var>. This map (<var>A</var>) contains one entry for each arity <var>N</var> within the arity range of any of the function declarations with the given name; its key is <var>N</var>, as an <code>xs:integer</code> value, and its associated value is a function item obtained as if by evaluating a named function reference <code>Q#N</code>, using the static and dynamic context of the call on <a href="#func-load-xquery-module"><code>fn:load-xquery-module</code></a>. The function item can be invoked using the rules for dynamic function invocation.</p><ul><li><p><b>Type: </b><code>map(xs:QName, map(xs:integer, function(*)))</code></p></li></ul></td></tr></tbody></table></div><div class="_diffs div2"><h3><a id="func-load-xquery-module"></a><span class="deltaxml-old" style="background:#FF5555">18.2</span><span class="deltaxml-new" style="background:#90EE90">19.2</span> <a href="#func-load-xquery-module" style="text-decoration: none">fn:load-xquery-module</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#func-op">next</a> | <a href="#func-invisible-xml">previous</a>)</p><ol><li><p>It has been clarified that loading a module has no effect on the static or dynamic context of the caller.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/725">725</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/727">727</a>&nbsp;10 October 2023]</i></p></li><li><p>The return type is now specified more precisely.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/883">883</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1072">1072</a>&nbsp;19 March 2024]</i></p></li><li><p>A new option is provided to allow the content of the loaded module to be supplied as a string.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1329">1329</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1333">1333</a>&nbsp;22 July 2024]</i></p></li></ol></div><dl><dt class="label">Summary</dt><dd><p>Provides access to the public functions and global variables of a dynamically loaded XQuery library module.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">fn:load-xquery-module</code>(</td></tr><tr class="arg"><td><code>$module-uri</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:string</code></code>,</td><td></td></tr><tr class="arg"><td><code>$options</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>map(*)?</code></code></td><td><code class="assign">:=&nbsp;</code><code>{}</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code class="return-type-ref"><a href="#load-xquery-module-record">load-xquery-module-record</a></code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-dependent" class="termref" href="#dt-context-dependent">context-dependent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-dependent">focus-dependent</a>. </p></dd><dt class="label">Rules</dt><dd><p>The function loads an implementation-defined set of modules having the target namespace <code>$module-uri</code>.</p><p>If the second argument is omitted or an empty sequence, the result is the same as calling the two-argument form with an empty map as the value of the <code>$options</code> argument.</p><p>The <code>$options</code> argument can be used to control the way in which the function operates. The <a title="option parameter conventions" class="termref" href="#option-parameter-conventions">option parameter conventions</a> apply.</p><p>If the query module is retrieved as an external resource, this is subject to the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-trusted">trust level</a><sup><small>XP</small></sup> of the calling code. In addition, the ability of the loaded query module to access additional resources is subject to the value of the supplied <code>trusted</code> option.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Versions of XQuery prior to 4.0 do not define any constraints on access to external resources. Many XQuery implementations, however, provide such mechanisms. An implementation of <code>fn:load-xquery-module</code> that allows execution of an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-untrusted">untrusted</a><sup><small>XP</small></sup> query <span class="verb">must</span> ensure that the ability of that query to access resources is appropriately restricted, regardless of the version of XQuery in use.</p></div><div><div class="record"><table class="record" border="0"><tbody><tr><td colspan="2"><code>record(</code></td></tr><tr class="arg"><td><code class="opt">xquery-version?</code></td><td><code class="as">as&nbsp;</code><code>xs:decimal</code>,</td></tr><tr class="arg"><td><code class="opt">trusted?</code></td><td><code class="as">as&nbsp;</code><code>xs:boolean</code>,</td></tr><tr class="arg"><td><code class="opt">location-hints?</code></td><td><code class="as">as&nbsp;</code><code>xs:string*</code>,</td></tr><tr class="arg"><td><code class="opt">content?</code></td><td><code class="as">as&nbsp;</code><code>xs:string?</code>,</td></tr><tr class="arg"><td><code class="opt">context-item?</code></td><td><code class="as">as&nbsp;</code><code>item()?</code>,</td></tr><tr class="arg"><td><code class="opt">variables?</code></td><td><code class="as">as&nbsp;</code><code>map(xs:QName, item()*)</code>,</td></tr><tr class="arg"><td><code class="opt">vendor-options?</code></td><td><code class="as">as&nbsp;</code><code>map(xs:QName, item()*)</code></td></tr><tr><td colspan="2"><code>)</code></td></tr></tbody></table></div></div><table class="fos-options"><thead><tr><th>Key</th><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td><p><code>xquery-version?</code></p></td><td class="fos-thin" colspan="2">The minimum level of the XQuery language that the processor must support. <ul><li><p><b>Type: </b><code>xs:decimal</code></p></li><li><p><b>Default: </b>The version given in the prolog of the library module; or <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a> if this is absent.</p></li></ul></td></tr><tr><td rowspan="3"><p><code>trusted?</code></p></td><td class="fos-thick" colspan="2">Indicates whether the returned query module is trusted to access external resources. This applies both to resources statically referenced in the query module (such as imported schemas and imported library modules), and to resources accessed dynamically by invoking functions in the retrieved module, for example by use of the <a href="#func-doc"><code>fn:doc</code></a> function. <ul><li><p><b>Type: </b><code>xs:boolean</code></p></li><li><p><b>Default: </b><code>false()</code></p></li></ul></td></tr><tr><td class="fos-thin"><code>true</code></td><td>The loaded query has the same level of trust as the caller, and may therefore access all external resources available to the caller. </td></tr><tr><td class="fos-thick"><code>false</code></td><td>The functions and variables in the returned XQuery module are <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-untrusted">untrusted</a><sup><small>XP</small></sup>, and are therefore unable to access external resources unless these have been made explicitly available by a trusted caller. </td></tr><tr><td><p><code>location-hints?</code></p></td><td class="fos-thin" colspan="2">A sequence of URIs (in the form of <code>xs:string</code> values) which may be used or ignored in an <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a> way. <ul><li><p><b>Type: </b><code>xs:string*</code></p></li><li><p><b>Default: </b><code>Empty sequence</code></p></li></ul></td></tr><tr><td><p><code>content?</code></p></td><td class="fos-thin" colspan="2">The content of the query module as a string. When this option is used, the <code>location-hints</code> option is ignored. The static base URI of the dynamically loaded module is the same as the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-executable-base-uri">executable base URI</a><sup><small>XP</small></sup> of the caller. <ul><li><p><b>Type: </b><code>xs:string?</code></p></li><li><p><b>Default: </b><code>Empty sequence</code></p></li></ul></td></tr><tr><td><p><code>context-item?</code></p></td><td class="fos-thin" colspan="2">The item to be used as the initial context item when evaluating global variables in the library module. Supplying an empty sequence is equivalent to omitting the entry from the map, and indicates the absence of a context item. If the library module specifies a required type for the context item, then the supplied value <span class="verb">must</span> conform to this type, without conversion. <ul><li><p><b>Type: </b><code>item()?</code></p></li><li><p><b>Default: </b><code>Absent</code></p></li></ul></td></tr><tr><td><p><code>variables?</code></p></td><td class="fos-thin" colspan="2">Values for external variables defined in the library module. Values <span class="verb">must</span> be supplied for external variables that have no default value, and <span class="verb">may</span> be supplied for external variables that do have a default value. The supplied value <span class="verb">must</span> conform to the required type of the variable, without conversion. The map contains one entry for each external variable: the key is the variable’s name, and the associated value is the variable’s value. The <a title="option parameter conventions" class="termref" href="#option-parameter-conventions">option parameter conventions</a> do not apply to this contained map. <ul><li><p><b>Type: </b><code>map(xs:QName, item()*)</code></p></li><li><p><b>Default: </b><code>An empty map</code></p></li></ul></td></tr><tr><td><p><code>vendor-options?</code></p></td><td class="fos-thin" colspan="2">Values for vendor-defined configuration options for the XQuery processor used to process the request. The key is the name of an option, expressed as a QName: the namespace URI of the QName <span class="verb">should</span> be a URI controlled by the vendor of the XQuery processor. The meaning of the associated value is <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a>. Implementations <span class="verb">should</span> ignore options whose names are in an unrecognized namespace. The <a title="option parameter conventions" class="termref" href="#option-parameter-conventions">option parameter conventions</a> do not apply to this contained map. <ul><li><p><b>Type: </b><code>map(xs:QName, item()*)</code></p></li><li><p><b>Default: </b><code>An empty map</code></p></li></ul></td></tr></tbody></table><p><span style="display: none;" class="delete_version">The result of the function is a map <var>R</var> with two entries, as defined in <a href="#load-xquery-module-record"><span class="delete_version"><b>18.1 Record fn:load-xquery-module-record</b></span><span class="modify_version"><b>18.1 Record fn:load-xquery-module-record</b></span></a>.</span><span style="display: none;" class="add_version">The result of the function is a map <var>R</var> with two entries, as defined in <a href="#load-xquery-module-record"><span class="add_version"><b>19.1 Record fn:load-xquery-module-record</b></span><span class="modify_version"><b>19.1 Record fn:load-xquery-module-record</b></span></a>.</span><span class="modify_version">The result of the function is a map <var>R</var> with two entries, as defined in <a href="#load-xquery-module-record"><span style="display: none;" class="delete_version"><b>18.1 Record fn:load-xquery-module-record</b></span><span style="display: none;" class="add_version"><b>19.1 Record fn:load-xquery-module-record</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">18.1</span><span class="deltaxml-new" style="background:#90EE90">19.1</span> Record fn:load-xquery-module-record</b></span></a>.</span></p><p>The static and dynamic context of the library module are established according to the rules in <a href="https://www.w3.org/TR/xquery-31/#id-xq-context-components"> C Context Components </a><sup><small>XQ31</small></sup>.</p><p>It is <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a> whether constructs in the library module are evaluated in the same <a title="execution scope" class="termref" href="#execution-scope">execution scope</a> as the calling module.</p><p>The library module that is loaded may import other modules using an <code>import module</code> declaration. The result of <a href="#func-load-xquery-module"><code>fn:load-xquery-module</code></a> does not include global variables or functions declared in such a transitively imported module. However, the <code>options</code> map supplied in the function call <span class="verb">may</span> (and if no default is defined, <span class="verb">must</span>) supply values for external variables declared in transitively loaded library modules.</p><p>The library module that is loaded may import schema declarations using an <code>import schema</code> declaration. It is <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a> whether schema components in the in-scope schema definitions of the calling module are automatically added to the in-scope schema definitions of the dynamically loaded module. The in-scope schema definitions of the calling and called modules must be consistent, according to the rules defined in <a href="https://www.w3.org/TR/xquery-31/#id-consistency-constraints"> 2.2.5 Consistency Constraints </a><sup><small>XQ31</small></sup>.</p><p>Where nodes are passed to or from the dynamically loaded module, for example as an argument or result of a function, they <span class="verb">should</span> if possible retain their node identity, their base URI, their type annotations, and their relationships to all other nodes in the containing tree (including ancestors and siblings). If this is not possible, for example because the only way of passing nodes to the chosen XQuery implementation is by serializing and re-parsing, then a node <span class="verb">may</span> be passed in the form of a deep copy, which may lose information about the identity of the node, about its ancestors and siblings, about its base URI, about its type annotations, and about its relationships to other nodes passed across the interface.</p></dd><dt class="label">Error Conditions</dt><dd><p>If <code>$module-uri</code> is a zero length string, a dynamic error is raised [<a href="#ERRFOQM0001" title="err:FOQM0001">err:FOQM0001</a>].</p><p>If the implementation is not able to find a library module with the specified target namespace, an error is raised [<a href="#ERRFOQM0002" title="err:FOQM0002">err:FOQM0002</a>].</p><p>If a static error (including a statically detected type error) is encountered when processing the library module, a dynamic error is raised [<a href="#ERRFOQM0003" title="err:FOQM0003">err:FOQM0003</a>].</p><p>If a value is supplied for the initial context item or for an external variable and the value does not conform to the required type declared in the dynamically loaded module, a dynamic error is raised [<a href="#ERRFOQM0005" title="err:FOQM0005">err:FOQM0005</a>].</p><p>If no suitable XQuery processor is available, a dynamic error is raised [<a href="#ERRFOQM0006" title="err:FOQM0006">err:FOQM0006</a>]. This includes (but is not limited to) the following cases:</p><ol class="enumar"><li><p>No XQuery processor is available;</p></li><li><p>Use of the function has been disabled;</p></li><li><p>No XQuery processor supporting the requested version of XQuery is available;</p></li><li><p>No XQuery processor supporting the optional Module Feature is available.</p></li></ol><p>If a dynamic error (including a dynamically detected type error) is encountered when processing the module (for example, when evaluating its global variables), the dynamic error is returned <em>as is</em>.</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>If a function declaration <var>F</var> in the loaded module declares (say) four parameters of which one is optional, its arity range will be from 3 to 4, so the result will include two function items corresponding to <code>F#3</code> and <code>F#4</code>. In the lower-arity function item, <code>F#3</code>, the fourth parameter will take its default value. If the expression that initializes the default value is context sensitive, the static and dynamic context for its evaluation are the static and dynamic contexts of the <a href="#func-load-xquery-module"><code>fn:load-xquery-module</code></a> function call itself. </p><p>As with all other functions in this specification, conformance requirements depend on the host language. For example, a host language might specify that provision of this function is optional, or that it is excluded entirely, or that implementations are required to support XQuery modules using a specified version of XQuery.</p><p>Even where support for this function is mandatory, it is <span class="verb">recommended</span> for security reasons that implementations should provide a user option to disable its use, or to disable aspects of its functionality.</p><p>The <code>load-xquery-module</code> function does not modify the static or dynamic context. Functions and variables from the loaded module become available within the result returned by the function, but they are not added to the static or dynamic context of the caller. This means, for example, that <code>function-lookup</code> will not locate functions from the loaded module.</p></div></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><tbody><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small">let $expr := "2 + 2"
let $module := `
  xquery version "4.0"; 
  module namespace dyn="http://example.com/dyn";
  declare %public variable $dyn:value := { $expr };
`
let $exec := load-xquery-module(
  "http://example.com/dyn",
  { 'content':$module }
)
let $variables := $exec?variables
return $variables( #Q{http://example.com/dyn}value )</pre></div></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">4</pre></div></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div2"><h3><a id="func-transform"></a><span class="deltaxml-old" style="background:#FF5555">18.3</span><span class="deltaxml-new" style="background:#90EE90">19.3</span> <a href="#func-transform" style="text-decoration: none">fn:transform</a></h3><dl><dt class="label">Summary</dt><dd><p>Invokes a transformation using a dynamically loaded XSLT stylesheet.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">fn:transform</code>(</td></tr><tr class="arg"><td><code>$options</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>map(*)</code></code></td><td></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>map(*)</code></code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="nondeterministic" class="termref" href="#dt-nondeterministic">nondeterministic</a>, <a title="context-dependent" class="termref" href="#dt-context-dependent">context-dependent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. </p></dd><dt class="label">Rules</dt><dd><p>This function loads an XSLT stylesheet and invokes it to perform a transformation.</p><p>The inputs to the transformation are supplied in the form of a map. The <a title="option parameter conventions" class="termref" href="#option-parameter-conventions">option parameter conventions</a> apply to this map; they do not apply to any nested map unless otherwise specified.</p><p>The function first identifies the <b>requested XSLT version</b>, as follows:</p><ul><li><p>If the <code>xslt-version</code> option is present, the requested XSLT version is the value of that option. </p></li><li><p>Otherwise, the requested XSLT version is the value of the <code>[xsl:]version</code> attribute of the outermost element in the supplied stylesheet or package.</p></li></ul><p>The function then attempts to locate an XSLT processor that implements the requested XSLT version.</p><ul><li><p>If a processor that implements the requested XSLT version is available, then it is used. </p></li><li><p>Otherwise, if a processor that implements a version later than the requested version is available, then it is used. </p></li><li><p>Otherwise, the function fails indicating that no suitable XSLT processor is available.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The phrase <em>locate an XSLT processor</em> includes the possibility of locating a software product and configuring it to act as an XSLT processor that implements the requested XSLT version.</p></div><p>If more than one XSLT processor is available under the above rules, then the one that is chosen may be selected according to the availability of requested features: see below.</p><p>Once an XSLT processor has been selected that implements a given version of XSLT, the processor follows the rules of that version of the XSLT specification. This includes any decision to operate in backwards or forwards compatibility mode. For example, if an XSLT 2.0 processor is selected, and the stylesheet specifies <code>version="1.0"</code>, then the processor will operate in backwards compatibility mode; if the same processor is selected and the stylesheet specifies <code>version="3.0"</code>, the processor will operate in forwards compatibility mode.</p><p>If the stylesheet to be executed is retrieved as an external resource, this is subject to the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-trusted">trust level</a><sup><small>XP</small></sup> of the calling code. In addition, the ability of the loaded stylesheet to access additional resources is subject to the value of the supplied <code>trusted</code> option.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Versions of XSLT prior to 4.0 do not define any constraints on access to external resources. Many XSLT implementations, however, provide such mechanisms. An implementation of <code>fn:transform</code> that allows an XSLT processor to execute an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-untrusted">untrusted</a><sup><small>XP</small></sup> stylesheet <span class="verb">must</span> ensure that the ability of that stylesheet to access resources is appropriately restricted, regardless of the version of XSLT.</p></div><p>The combinations of options that are relevant to each version of XSLT, other than <code>xslt-version</code> itself, are listed below. This is followed by a table giving the meaning of each option.</p><ol class="enumar"><li><p>For invocation of an XSLT 1.0 processor (see <a href="#xslt10">[XSL Transformations (XSLT) Version 1.0]</a>), the supplied options must include all of the following <span>(if anything else is present, it is ignored)</span>:</p><ol class="enumla"><li><p>The stylesheet, provided by supplying exactly one of the following:</p><blockquote><p><code>stylesheet-location</code><br><code>stylesheet-node</code><br><code>stylesheet-text</code></p></blockquote></li><li><p>The source tree, provided as the value of the <code>source-node</code> option.</p></li><li><p>Zero or more of the following additional options:</p><blockquote><p><code>stylesheet-base-uri</code><br><code>stylesheet-params</code> (defaults to an empty map)<br><code>initial-mode</code> (defaults to the stylesheet’s default mode)<br><code>delivery-format</code> (defaults to <code>document</code>)<br><code>serialization-params</code> (defaults to an empty map)<br><code>enable-messages</code> (default is implementation-defined)<br><code>requested-properties</code> (default is an empty map)<br><code>trusted</code> (default is <code>false</code>)<br><code>vendor-options</code> (defaults to an empty map)<br><code>cache</code> (default is implementation-defined)</p></blockquote></li></ol></li><li><p>For invocation of an XSLT 2.0 processor (see <a href="#xslt20">[XSL Transformations (XSLT) Version 2.0]</a>), the supplied options must include all of the following <span>(if anything else is present, it is ignored)</span>:</p><ol class="enumla"><li><p>The stylesheet, provided by supplying exactly one of the following:</p><blockquote><p><code>stylesheet-location</code><br><code>stylesheet-node</code><br><code>stylesheet-text</code></p></blockquote></li><li><p>Invocation details, as exactly one of the following:</p><ol class="enumlr"><li><p>For apply-templates invocation, all of the following:</p><p><code>source-node</code></p><p>Optionally, <code>initial-mode</code> (defaults to the stylesheet’s default mode)</p></li><li><p>For call-template invocation, all of the following:</p><p><code>initial-template</code></p><p>Optionally, <code>source-node</code></p></li></ol></li><li><p>Zero or more of the following additional options:</p><blockquote><p><code>stylesheet-base-uri</code><br><code>stylesheet-params</code> (defaults to an empty map)<br><code>base-output-uri</code> (defaults to absent)<br><code>delivery-format</code> (defaults to <code>document</code>)<br><code>serialization-params</code> (defaults to an empty map)<br><code>enable-messages</code> (default is implementation-defined)<br><code>enable-trace</code> (default is implementation-defined)<br><code>requested-properties</code> (default is an empty map)<br><code>trusted</code> (default is <code>false</code>)<br><code>vendor-options</code> (defaults to an empty map)<br><code>cache</code> (default is implementation-defined)</p></blockquote></li></ol></li><li><p>For invocation of an XSLT 3.0 or XSLT 4.0 processor (see <a href="#xslt-40">[XSL Transformations (XSLT) Version 4.0]</a>), the supplied options must include all of the following <span>(if anything else is present, it is ignored)</span>:</p><ol class="enumla"><li><p>The stylesheet, provided either by supplying exactly one of the following:</p><blockquote><p><code>stylesheet-location</code><br><code>stylesheet-node</code><br><code>stylesheet-text</code></p></blockquote><p>Or by supplying exactly one of the following:</p><blockquote><p><code>package-location</code><br><code>package-node</code><br><code>package-text</code><br><code>package-name</code> plus optionally <code>package-version</code></p></blockquote></li><li><p>Invocation details, as exactly one of the following combinations:</p><ol class="enumlr"><li><p>For apply-templates invocation, all of the following:</p><p>Exactly one of <code>source-node</code>, <code>source-location</code>, or <code>initial-match-selection</code></p><p>Optionally, <code>initial-mode</code></p><p>Optionally, <code>template-params</code></p><p>Optionally, <code>tunnel-params</code></p></li><li><p>For call-template invocation using an explicit template name, all of the following:</p><p><code>initial-template</code></p><p>Optionally, <code>template-params</code></p><p>Optionally, <code>tunnel-params</code></p><p>Optionally, <code>source-node</code></p></li><li><p>For call-template invocation using the defaulted template name <code>xsl:initial-template</code>, all of the following:</p><p>Optionally, <code>template-params</code></p><p>Optionally, <code>tunnel-params</code></p><div class="note"><p class="prefix"><b>Note:</b></p><p>If the <code>source-node</code> or <code>source-location</code>option is present and <code>initial-template</code> is absent, then apply-templates invocation will be used. To use call-template invocation on the template named <code>xsl:initial-template</code> while also supplying a context item for use when evaluating global variables, either (a) supply the context item using the <code>global-context-item</code> option, or (b) supply <code>source-node</code>, and set the <code>initial-template</code> option explicitly to the QName <code>xsl:initial-template</code></p></div></li><li><p>For call-function invocation, all of the following:</p><p><code>initial-function</code></p><p><code>function-params</code></p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The invocation method can be determined as the first of the following which applies:</p><ul><li><p>If <code>initial-function</code> is present, then call-function invocation.</p></li><li><p>If <code>initial-template</code> is present, then call-template invocation.</p></li><li><p>If <code>source-node</code> or <code>source-location</code> or <code>initial-match-selection</code> is present, then apply-templates invocation.</p></li><li><p>Otherwise, <code>call-template</code> invocation using the default entry point <code>xsl:initial-template</code>.</p></li></ul></div></li><li><p>Zero or more of the following additional options:</p><blockquote><p><code>stylesheet-base-uri</code><br><code>static-params</code> (defaults to an empty map)<br><code>stylesheet-params</code> (defaults to an empty map)<br><code>global-context-item</code> (defaults to absent)<br><code>base-output-uri</code> (defaults to absent)<br><code>delivery-format</code><br><code>serialization-params</code> (defaults to an empty map)<br><code>enable-assertions</code> (default is <code>false</code>)<br><code>enable-messages</code> (default is implementation-defined)<br><code>enable-trace</code> (default is implementation-defined)<br><code>requested-properties</code> (default is an empty map)<br><code>trusted</code> (default is <code>false</code>)<br><code>vendor-options</code> (defaults to an empty map)<br><code>cache</code> (default is implementation-defined)</p></blockquote></li></ol></li></ol><p>The meanings of each option are defined in the table below.</p><div><div class="record"><table class="record" border="0"><tbody><tr><td colspan="2"><code>record(</code></td></tr><tr class="arg"><td><code class="opt">base-output-uri?</code></td><td><code class="as">as&nbsp;</code><code>xs:string</code>,</td></tr><tr class="arg"><td><code class="opt">cache?</code></td><td><code class="as">as&nbsp;</code><code>xs:boolean</code>,</td></tr><tr class="arg"><td><code class="opt">delivery-format?</code></td><td><code class="as">as&nbsp;</code><code>xs:string</code>,</td></tr><tr class="arg"><td><code class="opt">enable-assertions?</code></td><td><code class="as">as&nbsp;</code><code>xs:boolean</code>,</td></tr><tr class="arg"><td><code class="opt">enable-messages?</code></td><td><code class="as">as&nbsp;</code><code>xs:boolean</code>,</td></tr><tr class="arg"><td><code class="opt">enable-trace?</code></td><td><code class="as">as&nbsp;</code><code>xs:boolean</code>,</td></tr><tr class="arg"><td><code class="opt">function-params?</code></td><td><code class="as">as&nbsp;</code><code>array(item()*)</code>,</td></tr><tr class="arg"><td><code class="opt">global-context-item?</code></td><td><code class="as">as&nbsp;</code><code>item()</code>,</td></tr><tr class="arg"><td><code class="opt">initial-function?</code></td><td><code class="as">as&nbsp;</code><code>xs:QName</code>,</td></tr><tr class="arg"><td><code class="opt">initial-match-selection?</code></td><td><code class="as">as&nbsp;</code><code>item()*</code>,</td></tr><tr class="arg"><td><code class="opt">initial-mode?</code></td><td><code class="as">as&nbsp;</code><code>xs:QName</code>,</td></tr><tr class="arg"><td><code class="opt">initial-template?</code></td><td><code class="as">as&nbsp;</code><code>xs:QName</code>,</td></tr><tr class="arg"><td><code class="opt">package-name?</code></td><td><code class="as">as&nbsp;</code><code>xs:string</code>,</td></tr><tr class="arg"><td><code class="opt">package-location?</code></td><td><code class="as">as&nbsp;</code><code>xs:string</code>,</td></tr><tr class="arg"><td><code class="opt">package-node?</code></td><td><code class="as">as&nbsp;</code><code>node()</code>,</td></tr><tr class="arg"><td><code class="opt">package-text?</code></td><td><code class="as">as&nbsp;</code><code>xs:string</code>,</td></tr><tr class="arg"><td><code class="opt">package-version?</code></td><td><code class="as">as&nbsp;</code><code>xs:string</code>,</td></tr><tr class="arg"><td><code class="opt">post-process?</code></td><td><code class="as">as&nbsp;</code><code>fn(xs:string, item()*) as item()*</code>,</td></tr><tr class="arg"><td><code class="opt">requested-properties?</code></td><td><code class="as">as&nbsp;</code><code>map(xs:QName, xs:anyAtomicType)</code>,</td></tr><tr class="arg"><td><code class="opt">serialization-params?</code></td><td><code class="as">as&nbsp;</code><code>map(xs:anyAtomicType, item()*)</code>,</td></tr><tr class="arg"><td><code class="opt">source-location?</code></td><td><code class="as">as&nbsp;</code><code>node()</code>,</td></tr><tr class="arg"><td><code class="opt">source-node?</code></td><td><code class="as">as&nbsp;</code><code>node()</code>,</td></tr><tr class="arg"><td><code class="opt">static-params?</code></td><td><code class="as">as&nbsp;</code><code>map(xs:QName, item()*)</code>,</td></tr><tr class="arg"><td><code class="opt">stylesheet-base-uri?</code></td><td><code class="as">as&nbsp;</code><code>xs:string</code>,</td></tr><tr class="arg"><td><code class="opt">stylesheet-location?</code></td><td><code class="as">as&nbsp;</code><code>xs:string</code>,</td></tr><tr class="arg"><td><code class="opt">stylesheet-node?</code></td><td><code class="as">as&nbsp;</code><code>node()</code>,</td></tr><tr class="arg"><td><code class="opt">stylesheet-params?</code></td><td><code class="as">as&nbsp;</code><code>map(xs:QName, item()*)</code>,</td></tr><tr class="arg"><td><code class="opt">stylesheet-text?</code></td><td><code class="as">as&nbsp;</code><code>xs:string</code>,</td></tr><tr class="arg"><td><code class="opt">template-params?</code></td><td><code class="as">as&nbsp;</code><code>map(xs:QName, item()*)</code>,</td></tr><tr class="arg"><td><code class="opt">tunnel-params?</code></td><td><code class="as">as&nbsp;</code><code>map(xs:QName, item()*)</code>,</td></tr><tr class="arg"><td><code class="opt">trusted?</code></td><td><code class="as">as&nbsp;</code><code>xs:boolean</code>,</td></tr><tr class="arg"><td><code class="opt">vendor-options?</code></td><td><code class="as">as&nbsp;</code><code>{ xs:QName, item()* }</code>,</td></tr><tr class="arg"><td><code class="opt">xslt-version?</code></td><td><code class="as">as&nbsp;</code><code>xs:decimal</code></td></tr><tr><td colspan="2"><code>)</code></td></tr></tbody></table></div></div><table class="fos-options"><thead><tr><th>Key</th><th>Applies to</th><th>Value</th><th>Meaning</th></tr></thead><tbody><tr><td><p><code>base-output-uri?</code></p></td><td>1.0, 2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">The URI of the principal result document; also used as the base URI for resolving relative URIs of secondary result documents. If the value is a relative reference, it is resolved against the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-executable-base-uri">executable base URI</a><sup><small>XP</small></sup> of the <code>fn:transform</code> function call. <ul><li><p><b>Type: </b><code>xs:string</code></p></li><li><p><b>Default: </b>The effect of not supplying a base output URI is defined by the XSLT specification; the implementation <span class="verb">may</span> supply a default, for example the current working directory. If the <code>fn:transform</code> function is called from XSLT, then the <span class="verb">recommended</span> default is the current output URI of the calling transformation.</p></li></ul></td></tr><tr><td><p><code>cache?</code></p></td><td>1.0, 2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">This option has no effect on the result of the transformation but may affect efficiency. The value <code>true</code> indicates an expectation that the same stylesheet is likely to be used for more than one transformation; the value <code>false</code> indicates an expectation that the stylesheet will be used once only. <ul><li><p><b>Type: </b><code>xs:boolean</code></p></li><li><p><b>Default: </b><code>true</code></p></li></ul></td></tr><tr><td rowspan="5"><p><code>delivery-format?</code></p></td><td rowspan="5">1.0, 2.0, 3.0, 4.0</td><td class="fos-thick" colspan="2">The manner in which the transformation results should be delivered. Applies both to the principal result document and to secondary result documents created using <code>xsl:result-document</code>. <ul><li><p><b>Type: </b><code>xs:string</code></p></li><li><p><b>Default: </b><code>document</code></p><p>If the relevant <code>xsl:output</code> or <code>xsl:result-document</code> element specifies <code>build-tree="no"</code> (applies to XSLT 3.0 only), then the default is <code>raw</code>.</p></li></ul></td></tr><tr><td class="fos-thin"><code>document</code></td><td>The result is delivered as a document node.</td></tr><tr><td class="fos-thin"><code>serialized</code></td><td>The result is delivered as a string, representing the results of serialization. Note that (as with the <a href="#func-serialize"><code>fn:serialize</code></a> function) the final encoding stage of serialization (which turns a sequence of characters into a sequence of octets) is either skipped, or reversed by decoding the octet stream back into a character stream.</td></tr><tr><td class="fos-thin"><code>raw</code></td><td>The result of the initial template or function is returned as an arbitrary XDM value (after conversion to the declared type, but without wrapping in a document node, and without serialization): when this option is chosen, the returned map contains the raw result.</td></tr><tr><td class="fos-thick"><code>file</code></td><td>The serialized result is written to persistent storage. This means that the <code>fn:transform</code> function has side-effects and becomes nondeterministic, so the option should be used with care, and the precise behavior may be <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a>. When this option is used, the URIs used for the <code>base-output-uri</code> and the URIs of any secondary result documents must be writable locations.</td></tr><tr><td><p><code>enable-assertions?</code></p></td><td>3.0, 4.0</td><td class="fos-thin" colspan="2">Indicates whether any <code>xsl:assert</code> instructions in the stylesheet are to be evaluated. <ul><li><p><b>Type: </b><code>xs:boolean</code></p></li><li><p><b>Default: </b><code>false</code></p></li></ul></td></tr><tr><td><p><code>enable-messages?</code></p></td><td>1.0, 2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">Indicates whether any <code>xsl:message</code> instructions in the stylesheet are to be evaluated. The destination and formatting of any such messages is <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a>. <ul><li><p><b>Type: </b><code>xs:boolean</code></p></li><li><p><b>Default: </b><a title="implementation-defined" class="termref" href="#implementation-defined">Implementation-defined</a>.</p></li></ul></td></tr><tr><td><p><code>enable-trace?</code></p></td><td>2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">Indicates whether any <a href="#func-trace"><code>fn:trace</code></a> functions in the stylesheet are to generate diagnostic messages. The destination and formatting of any such messages is implementation-defined. <ul><li><p><b>Type: </b><code>xs:boolean</code></p></li><li><p><b>Default: </b><a title="implementation-defined" class="termref" href="#implementation-defined">Implementation-defined</a>.</p></li></ul></td></tr><tr><td><p><code>function-params?</code></p></td><td>3.0, 4.0</td><td class="fos-thin" colspan="2">An array of values to be used as the arguments to the initial function call. The value is converted to the required type of the declared parameter using the function conversion rules. <ul><li><p><b>Type: </b><code>array(item()*)</code></p></li><li><p><b>Default: </b><code>Empty array</code></p></li></ul></td></tr><tr><td><p><code>global-context-item?</code></p></td><td>3.0, 4.0</td><td class="fos-thin" colspan="2">The value of the global context item, as defined in XSLT 3.0 <ul><li><p><b>Type: </b><code>item()</code></p></li><li><p><b>Default: </b>The value of <code>source-node</code>, if supplied</p></li></ul></td></tr><tr><td><p><code>initial-function?</code></p></td><td>3.0, 4.0</td><td class="fos-thin" colspan="2">The name of the initial function to be called for call-function invocation. The arity of the function is inferred from the length of <code>function-params</code>. <ul><li><p><b>Type: </b><code>xs:QName</code></p></li><li><p><b>Default: </b>n/a</p></li></ul></td></tr><tr><td><p><code>initial-match-selection?</code></p></td><td>3.0, 4.0</td><td class="fos-thin" colspan="2">The value of the initial match selection, as defined in XSLT 3.0 <ul><li><p><b>Type: </b><code>item()*</code></p></li><li><p><b>Default: </b>The value of <code>source-node</code></p></li></ul></td></tr><tr><td><p><code>initial-mode?</code></p></td><td>1.0, 2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">The name of the initial processing mode. <ul><li><p><b>Type: </b><code>xs:QName</code></p></li><li><p><b>Default: </b>none</p></li></ul></td></tr><tr><td><p><code>initial-template?</code></p></td><td>2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">The name of a named template in the stylesheet to act as the initial entry point. <ul><li><p><b>Type: </b><code>xs:QName</code></p></li><li><p><b>Default: </b><code>xsl:initial-template</code></p></li></ul></td></tr><tr><td><p><code>package-name?</code></p></td><td>3.0, 4.0</td><td class="fos-thin" colspan="2">The name of the top-level stylesheet package to be invoked (an absolute URI) <ul><li><p><b>Type: </b><code>xs:string</code></p></li><li><p><b>Default: </b>n/a</p></li></ul></td></tr><tr><td><p><code>package-location?</code></p></td><td>3.0, 4.0</td><td class="fos-thin" colspan="2">The location of the top-level stylesheet package, as a relative or absolute URI <ul><li><p><b>Type: </b><code>xs:string</code></p></li><li><p><b>Default: </b>n/a</p></li></ul></td></tr><tr><td><p><code>package-node?</code></p></td><td>3.0, 4.0</td><td class="fos-thin" colspan="2">A document or element node containing the top-level stylesheet package <ul><li><p><b>Type: </b><code>node()</code></p></li><li><p><b>Default: </b>n/a</p></li></ul></td></tr><tr><td><p><code>package-text?</code></p></td><td>3.0, 4.0</td><td class="fos-thin" colspan="2">The top-level stylesheet package in the form of unparsed lexical XML. <ul><li><p><b>Type: </b><code>xs:string</code></p></li><li><p><b>Default: </b>n/a</p></li></ul></td></tr><tr><td><p><code>package-version?</code></p></td><td>3.0, 4.0</td><td class="fos-thin" colspan="2">The version of the top-level stylesheet package to be invoked. <ul><li><p><b>Type: </b><code>xs:string</code></p></li><li><p><b>Default: </b><code>"*" (any version)</code></p></li></ul></td></tr><tr><td><p><code>post-process?</code></p></td><td>1.0, 2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">A function that is used to post-process each result document of the transformation (both the principal result and secondary results), in whatever form it would otherwise be delivered (document, serialized, or raw). The first argument of the function is the key used to identify the result in the map return by the <a href="#func-transform"><code>fn:transform</code></a> function (for example, this will be the supplied base output URI in the case of the principal result, or the string “output” if no base output URI was supplied). The second argument is the actual value. The value that is returned in the result of the <a href="#func-transform"><code>fn:transform</code></a> function is the result of applying this post-processing. <div class="note"><p class="prefix"><b>Note:</b></p><p>If the implementation provides a way of writing or invoking functions with side-effects, this post-processing function might be used to save a copy of the result document to persistent storage. For example, if the implementation provides access to the EXPath File library <a href="#expath">[EXPath]</a>, then a serialized document might be written to filestore by calling the <code>file:write</code> function. Similar mechanisms might be used to issue an HTTP POST request that posts the result to an HTTP server, or to send the document to an email recipient. The semantics of calling functions with side-effects are entirely <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a>.</p><p>If the primary purpose of the post-processing function is achieved by means of such side-effects, and if the actual results are not needed by the caller of the <a href="#func-transform"><code>fn:transform</code></a> function, then it does not matter what the post-processing function actually returns (it could be an empty sequence, for example).</p><p>Calls to <a href="#func-transform"><code>fn:transform</code></a> can potentially have side-effects even in the absence of the post-processing option, because the XSLT specification allows a stylesheet to invoke extension functions that have side-effects. The semantics in this case are <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a>.</p></div><ul><li><p><b>Type: </b><code>fn(xs:string, item()*) as item()*</code></p></li><li><p><b>Default: </b><code>fn($a, $b) { $b }</code></p></li></ul></td></tr><tr><td><p><code>requested-properties?</code></p></td><td>1.0, 2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">The keys in the map are QNames that could legitimately be supplied in a call to the XSLT <code>system-property</code> function; the values in the map are the requested settings of the corresponding property. The boolean values <code>true</code> and <code>false</code> are equivalent to the string values <code>yes</code> and <code>no</code>. As a special case, setting a value for <code>xsl:version</code> has no effect, because of the potential for conflict with other options. For example: <ul><li><p>Setting <code>xsl:product-name</code> to a particular value requests a particular XSLT software product.</p></li><li><p>Setting <code>xsl:product-version</code> requests a specific version of that product.</p></li><li><p>Setting <code>xsl:is-schema-aware</code> to <code>true</code> requests a schema-aware processor.</p></li><li><p>Setting <code>xsl:xsd-version</code> to <code>"1.1"</code> requests a processor that supports XML Schema version 1.1.</p></li></ul> Setting a boolean property such as <code>xsl:supports-dynamic-evaluation</code> to <code>false</code> is interpreted as an explicit request for a processor in which the value of the property is <code>false</code>. The effect if the requests cannot be precisely met is implementation-defined. In some cases it may be appropriate to ignore the request or to provide an alternative (for example, a later version of the product than the one requested); in other cases it may be more appropriate to raise an error [<a href="#ERRFOXT0001" title="err:FOXT0001">err:FOXT0001</a>] indicating that no suitable XSLT processor is available. <ul><li><p><b>Type: </b><code>map(xs:QName, xs:anyAtomicType)</code></p></li><li><p><b>Default: </b><code>Empty map</code></p></li></ul></td></tr><tr><td><p><code>serialization-params?</code></p></td><td>1.0, 2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">Serialization parameters for the principal result document. The supplied map follows the same rules that apply to a map supplied as the second argument of <a href="#func-serialize"><code>fn:serialize</code></a>. <ul><li><p>When a parameter is supplied, the corresponding value overrides or augments the value specified in the unnamed <code>xsl:output</code> declaration (or its default), following the same rules as when one <code>xsl:output</code> declaration overrides another with lower import precedence.</p></li><li><p>When a parameter is supplied and the corresponding value is an empty sequence (for example, <code>{ "standalone": () }</code>), any value specified in the unnamed <code>xsl:output</code> declaration is overridden by the default value. </p></li><li><p>When a parameter is not supplied in <code>serialization-params</code> (that is, when the key is absent) the value that applies is the value appearing in the unnamed <code>xsl:output</code> declaration, or its default. </p></li></ul><ul><li><p><b>Type: </b><code>map(xs:anyAtomicType, item()*)</code></p></li><li><p><b>Default: </b><code>Empty map</code></p></li></ul></td></tr><tr><td><p><code>source-location?</code></p></td><td>1.0, 2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">When <code>source-location</code> is supplied then it is expected to be an absolute or relative URI identifying an unparsed XML document. If relative, it is resolved against the static base URI of the <code>fn:transform</code> function call. The document at this location is parsed, and the document node acts as the <code>initial-match-selection</code>, that is, stylesheet execution starts by applying templates to this node. If the initial mode is streamable and a streaming XSLT 3.0 or XSLT 4.0 processor is used, then the supplied document is processed in streaming mode. <ul><li><p><b>Type: </b><code>node()</code></p></li><li><p><b>Default: </b><code>n/a</code></p></li></ul></td></tr><tr><td><p><code>source-node?</code></p></td><td>1.0, 2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">When <code>source-node</code> is supplied then the <code>global-context-item</code> (the context item for evaluating global variables) is the root of the tree containing the supplied node. In addition, for apply-templates invocation, the <code>source-node</code> acts as the <code>initial-match-selection</code>, that is, stylesheet execution starts by applying templates to this node. <ul><li><p><b>Type: </b><code>node()</code></p></li><li><p><b>Default: </b>n/a</p></li></ul></td></tr><tr><td><p><code>static-params?</code></p></td><td>3.0, 4.0</td><td class="fos-thin" colspan="2">The values of static parameters defined in the stylesheet; the keys are the names of the parameters, and the associated values are their values. The value is converted to the required type of the declared parameter using the coercion rules. <ul><li><p><b>Type: </b><code>map(xs:QName, item()*)</code></p></li><li><p><b>Default: </b><code>Empty map</code></p></li></ul></td></tr><tr><td><p><code>stylesheet-base-uri?</code></p></td><td>1.0, 2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">A string intended to be used as the static base URI of the principal stylesheet module. This value <span class="verb">must</span> be used if no other static base URI is available. If the supplied stylesheet already has a base URI (which will generally be the case if the stylesheet is supplied using <code>stylesheet-node</code> or <code>stylesheet-location</code>) then it is <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a> whether this parameter has any effect. If the value is a relative reference, it is resolved against the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-executable-base-uri">executable base URI</a><sup><small>XP</small></sup> of the <code>fn:transform</code> function call. <ul><li><p><b>Type: </b><code>xs:string</code></p></li><li><p><b>Default: </b>n/a</p></li></ul></td></tr><tr><td><p><code>stylesheet-location?</code></p></td><td>1.0, 2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">URI that can be used to locate the principal stylesheet module. If relative, it is resolved against the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-executable-base-uri">executable base URI</a><sup><small>XP</small></sup> of the <code>fn:transform</code> function call. The value also acts as the default for stylesheet-base-uri. <ul><li><p><b>Type: </b><code>xs:string</code></p></li><li><p><b>Default: </b>n/a</p></li></ul></td></tr><tr><td><p><code>stylesheet-node?</code></p></td><td>1.0, 2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">Root of the tree containing the principal stylesheet module, as a document or element node. The base URI of the node acts as the default for stylesheet-base-uri. <ul><li><p><b>Type: </b><code>node()</code></p></li><li><p><b>Default: </b>n/a</p></li></ul></td></tr><tr><td><p><code>stylesheet-params?</code></p></td><td>1.0, 2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">A map holding values to be supplied for stylesheet parameters. The keys are the parameter names; the values are the corresponding parameter values. The values are converted if necessary to the required type using the coercion rules. The default is an empty map. <ul><li><p><b>Type: </b><code>map(xs:QName, item()*)</code></p></li><li><p><b>Default: </b><code>Empty map</code></p></li></ul></td></tr><tr><td><p><code>stylesheet-text?</code></p></td><td>1.0, 2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">The principal stylesheet module in the form of unparsed lexical XML. <ul><li><p><b>Type: </b><code>xs:string</code></p></li><li><p><b>Default: </b>n/a</p></li></ul></td></tr><tr><td><p><code>template-params?</code></p></td><td>3.0, 4.0</td><td class="fos-thin" colspan="2">The values of non-tunnel parameters to be supplied to the initial template, used with both apply-templates and call-template invocation. Each value is converted to the required type of the declared parameter using the coercion rules. <ul><li><p><b>Type: </b><code>map(xs:QName, item()*)</code></p></li><li><p><b>Default: </b>none</p></li></ul></td></tr><tr><td><p><code>tunnel-params?</code></p></td><td>3.0, 4.0</td><td class="fos-thin" colspan="2">The values of tunnel parameters to be supplied to the initial template, used with both apply-templates and call-template invocation. Each value is converted to the required type of the declared parameter using the coercion rules. <ul><li><p><b>Type: </b><code>map(xs:QName, item()*)</code></p></li><li><p><b>Default: </b><code>Empty map</code></p></li></ul></td></tr><tr><td rowspan="3"><p><code>trusted?</code></p></td><td rowspan="3"></td><td class="fos-thick" colspan="2">Indicates whether the target stylesheet is trusted to access external resources. This applies both to resources statically referenced by the stylesheet (for example using <code>xsl:include</code>, <code>xsl:import</code>, <code>xsl:use-package</code>, or <code>xsl:import-schema</code>), and to resources accessed dynamically by executing the retrieved stylesheet, for example by use of the <a href="#func-doc"><code>fn:doc</code></a> or <a href="#func-unparsed-text"><code>unparsed-text</code></a> function. <ul><li><p><b>Type: </b><code>xs:boolean</code></p></li><li><p><b>Default: </b><code>false()</code></p></li></ul></td></tr><tr><td class="fos-thin"><code>true</code></td><td>The loaded stylesheet has the same level of trust as the caller, and may therefore access all external resources available to the caller. </td></tr><tr><td class="fos-thick"><code>false</code></td><td>The loaded stylesheet is <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-untrusted">untrusted</a><sup><small>XP</small></sup>, and is therefore unable to access external resources unless these have been made explicitly available by a trusted caller. </td></tr><tr><td><p><code>vendor-options?</code></p></td><td>1.0, 2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">Values for vendor-defined configuration options for the XSLT processor used to process the request. The key is the name of an option, expressed as a QName: the namespace URI of the QName <span class="verb">should</span> be a URI controlled by the vendor of the XSLT processor. The meaning of the associated value is <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a>. Implementations <span class="verb">should</span> ignore options whose names are in an unrecognized namespace. Default is an empty map. <ul><li><p><b>Type: </b><code>{ xs:QName, item()* }</code></p></li><li><p><b>Default: </b><code>Empty map</code></p></li></ul></td></tr><tr><td><p><code>xslt-version?</code></p></td><td>1.0, 2.0, 3.0, 4.0</td><td class="fos-thin" colspan="2">The minimum level of the XSLT language that the processor must support. <ul><li><p><b>Type: </b><code>xs:decimal</code></p></li><li><p><b>Default: </b>The <code>[xsl:]version</code> attribute at the outermost level of the stylesheet.</p></li></ul></td></tr></tbody></table><p>The result of the transformation is returned as a map. There is one entry in the map for the principal result document, and one for each secondary result document. The key is a URI in the form of an <code>xs:string</code> value. The key for the principal result document is the base output URI if specified, or the string <code>"output"</code> otherwise. The key for secondary result documents is the URI of the document, as an absolute URI. The associated value in each entry depends on the requested delivery format. If the delivery format is <code>document</code>, the value is a document node. If the delivery format is <code>serialized</code>, the value is a string containing the serialized result. </p><p>Where nodes are passed to or from the transformation, for example as the value of a stylesheet parameter or the result of a function, they <span class="verb">should</span> if possible retain their node identity, their base URI, their type annotations, and their relationships to all other nodes in the containing tree (including ancestors and siblings). If this is not possible, for example because the only way of passing nodes to the chosen XSLT implementation is by serializing and re-parsing, then a node <span class="verb">may</span> be passed in the form of a deep copy, which may lose information about the identity of the node, about its ancestors and siblings, about its base URI, about its type annotation, and about its relationships to other nodes passed across the interface.</p><p>It is <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a> whether the XSLT transformation is executed within the same <a title="execution scope" class="termref" href="#execution-scope">execution scope</a> as the calling code.</p><p>The function is <a title="nondeterministic" class="termref" href="#dt-nondeterministic">nondeterministic</a> in that it is <a title="implementation-dependent" class="termref" href="#implementation-dependent">implementation-dependent</a> whether running the function twice against the same inputs produces identical results. The results of two invocations may differ in the identity of any returned nodes; they may also differ in other respects, for example because the value of <a href="#func-current-dateTime"><code>fn:current-dateTime</code></a> is different for the two invocations, or because the contents of external documents accessed using <a href="#func-doc"><code>fn:doc</code></a> or <code>xsl:source-document</code> change between one invocation and the next.</p></dd><dt class="label">Error Conditions</dt><dd><p>A dynamic error is raised [<a href="#ERRFOXT0001" title="err:FOXT0001">err:FOXT0001</a>] if the transformation cannot be invoked because no suitable XSLT processor is available. This includes (but is not limited to) the following cases:</p><ol class="enumar"><li><p>No XSLT processor is available;</p></li><li><p>No XSLT processor supporting the requested version of XSLT is available;</p></li><li><p>The XSLT processor API does not support some requested feature (for example, the ability to supply tunnel parameters externally);</p></li></ol><p>A dynamic error is raised [<a href="#ERRFOXT0002" title="err:FOXT0002">err:FOXT0002</a>] if an error is detected in the supplied parameters (for example if two mutually exclusive parameters are supplied).</p><p>If a static or dynamic error is reported by the XSLT processor, this function fails with a dynamic error, retaining the XSLT error code.</p><p>A dynamic error is raised [<a href="#ERRFOXT0003" title="err:FOXT0003">err:FOXT0003</a>] if the XSLT transformation invoked by a call on <a href="#func-transform"><code>fn:transform</code></a> fails with a static or dynamic error, and no more specific error code is available. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>XSLT 1.0 does not define any error codes, so this is the likely outcome with an XSLT 1.0 processor. XSLT 2.0 and 3.0 do define error codes, but some APIs do not expose them. If multiple errors are signaled by the transformation (which is most likely to happen with static errors) then the error code should where possible be that of one of these errors, chosen arbitrarily; the processor may make details of additional errors available to the application in an <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a> way.</p></div><p>A dynamic error is raised [<a href="#ERRFOXT0004" title="err:FOXT0004">err:FOXT0004</a>] if the use of this function (or of selected options) has been externally disabled, for example for security reasons.</p><p>A dynamic error is raised [<a href="#ERRFOXT0006" title="err:FOXT0006">err:FOXT0006</a>] if the transformation produces output containing characters available only in XML 1.1, and the calling processor cannot handle such characters.</p><p>Recursive use of the <a href="#func-transform"><code>fn:transform</code></a> function may lead to catastrophic failures such as non-termination or stack overflow. No error code is assigned to such conditions, since they cannot necessarily be detected by the processor.</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>As with all other functions in this specification, conformance requirements depend on the host language. For example, a host language might specify that provision of this function is optional, or that it is excluded entirely, or that implementations are required to support a particular set of values for the <code>xslt-version</code> parameter.</p><p>Even where support for this function is mandatory, it is <span class="verb">recommended</span> for security reasons that implementations should provide a user option to disable its use, or to disable aspects of its functionality such as the ability to write to persistent resources.</p></div></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><tbody><tr><td colspan="2"><p>The following example loads a stylesheet from the location <code>render.xsl</code>, applies it to a document loaded from <code>test.xml</code>, and uses an XPath expression to examine the result:</p></td></tr><tr><td colspan="2"><div class="exampleInner"><pre xml:space="preserve" class="small">let $result := transform({
  "stylesheet-location": "render.xsl",
  "source-node": doc('test.xml')
})
return $result?output//body</pre></div></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div2"><h3><a id="func-op"></a><span class="deltaxml-old" style="background:#FF5555">18.4</span><span class="deltaxml-new" style="background:#90EE90">19.4</span> <a href="#func-op" style="text-decoration: none">fn:op</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#functions-on-types">next</a> | <a href="#func-load-xquery-module">previous</a>)</p><ol><li><p>New in 4.0<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/83">83</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/173">173</a>&nbsp;11 October 2022]</i></p></li></ol></div><dl><dt class="label">Summary</dt><dd><p>Returns a function whose effect is to apply a supplied binary operator to two arguments.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">fn:op</code>(</td></tr><tr class="arg"><td><code>$operator</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:string</code></code></td><td></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>fn(item()*, item()*) as item()*</code></code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-independent" class="termref" href="#dt-context-independent">context-independent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. </p></dd><dt class="label">Rules</dt><dd><p>The supplied operator must be one of:</p><p><code>","</code>, <code>"and"</code>, <code>"or"</code>, <code>"+"</code>, <code>"-"</code>, <code>"*"</code>, <code>"div"</code>, <code>"idiv"</code>, <code>"mod"</code>, <code>"="</code>, <code>"&lt;"</code>, <code>"&lt;="</code>, <code>"&gt;"</code>, <code>"&gt;="</code>, <code>"!="</code>, <code>"eq"</code>, <code>"lt"</code>, <code>"le"</code>, <code>"gt"</code>, <code>"ge"</code>, <code>"ne"</code>, <code>"&lt;&lt;"</code>, <code>"&gt;&gt;"</code>, <code>"precedes"</code>, <code>"follows"</code>, <code>"precedes-or-is"</code>, <code>"follows-or-is"</code>, <code>"is"</code>, <code>"is-not"</code>, <code>"||"</code>, <code>"|"</code>, <code>"union"</code>, <code>"except"</code>, <code>"intersect"</code>, <code>"to"</code>, <code>"otherwise"</code>.</p><p>The result of calling <code>fn:op("⊙")</code>, where <code>⊙</code> is one of the above operators, is the function represented by the XPath expression:</p><p><code>fn($x, $y) { $x ⊙ $y }</code></p><p>For example, <code>op("+")</code> returns <code>fn($x, $y) { $x + $y }</code>.</p></dd><dt class="label">Error Conditions</dt><dd><p>A type error is raised [<a href="https://www.w3.org/TR/xpath20/#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]<sup><small>XP</small></sup> if the supplied argument is not one of the supported operators. </p></dd><dt class="label">Notes</dt><dd><div class="note"><p>The function is useful in contexts where an arity-2 callback function needs to be supplied, and a standard operator meets the requirement.</p><p>For example, the XSLT <code>xsl:map</code> instruction has an <code>on-duplicates</code> attribute that expects such a function. Specifying <code>on-duplicates="op(',')"</code> is equivalent to specifying <code>on-duplicates="fn($x, $y) { $x, $y }</code></p><p>The function is also useful in cases where the choice of operator to apply is made dynamically.</p><p>Some operators (such as <code>and</code>, <code>or</code>, and <code>otherwise</code>) have custom error handling semantics, with the effect that evaluating one of the operands cannot cause an error unless the other operand has a particular value (see <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-guarded-expressions">2.5.5 Guarded Expressions</a>). Although implementations are free to make optimizations, it should be assumed that a function call such as <code>op('and')(X, Y)</code> will have the normal semantics of a dynamic function call, where the arguments are evaluated in any order, and a failure evaluating any argument may cause the function call as a whole to fail.</p></div></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><thead><tr><th>Expression</th><th>Result</th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>for-each-pair(21 to 25, 1 to 5, op("+"))</code></pre></div></td><td style="vertical-align:top"><p><code>22, 24, 26, 28, 30</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>for-each-pair(21 to 25, 1 to 5, op("-"))</code></pre></div></td><td style="vertical-align:top"><p><code>20, 20, 20, 20, 20</code></p></td></tr></tbody></table></div></dd></dl></div></div><div class="_diffs div1"><h2><a id="functions-on-types"></a><span class="deltaxml-old" style="background:#FF5555">19</span><span class="deltaxml-new" style="background:#90EE90">20</span> <a href="#functions-on-types" style="text-decoration: none">Processing types</a></h2><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#func-schema-type">next</a> | <a href="#func-op">previous</a>)</p><ol><li><p> New functions are provided to obtain information about built-in types and types defined in an imported schema. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/148">148</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1523">1523</a>&nbsp;5 November 2024]</i></p></li></ol></div><p>The functions in this section deliver information about schema types (including simple types and complex types). These may represent built-in types (such as <code>xs:dateTime</code>), user-defined types found in the static context (typically because they appear in an imported schema), or types used as type annotations on schema-validated nodes.</p><p>For more information on schema types, see <a href="#schema-type-hierarchy"><b>1.8.2 Schema Type Hierarchy</b></a>. The properties of a schema type are described in terms of the properties of a Simple Type Definition or Complex Type Definition component as described in <a href="https://www.w3.org/TR/xmlschema11-1/#Simple_Type_Definition_details"> 3.16.1 The Simple Type Definition Schema Component </a><sup><small>XS11-1</small></sup> and <a href="https://www.w3.org/TR/xmlschema11-1/#Complex_Type_Definition_details"> 3.4.1 The Complex Type Definition Schema Component </a><sup><small>XS11-1</small></sup> respectively. Not all properties are exposed.</p><p>The structured representation of a schema type is described in <a href="#schema-type-record"><span style="display: none;" class="delete_version"><b>19.1.1 Record fn:schema-type-record</b></span><span style="display: none;" class="add_version"><b>20.1.1 Record fn:schema-type-record</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">19.1.1</span><span class="deltaxml-new" style="background:#90EE90">20.1.1</span> Record fn:schema-type-record</b></span></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Simple properties of a schema type that can be expressed as strings or booleans are represented in this record structure directly as atomic field values, while complex properties whose values are themselves types (for example, <code>base-type</code> and <code>primitive-type</code>) are represented as functions. This is done partly to make it easier for implementations to compute complex properties on demand rather than in advance, and partly to ensure that the overall structure is always acyclic. For example, the primitive type of <code>xs:decimal</code> is itself <code>xs:decimal</code>, and if this were represented as a field value without a guarding function, serialization of the map using the JSON output method would not terminate.</p></div><div class="_diffs div2"><h3><a id="functions-returning-type-information"></a><span class="deltaxml-old" style="background:#FF5555">19.1</span><span class="deltaxml-new" style="background:#90EE90">20.1</span> <a href="#functions-returning-type-information" style="text-decoration: none">Functions returning type information</a></h3><table class="index"><thead><tr><th>Function</th><th>Meaning</th></tr></thead><tbody><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-schema-type"><code>fn:schema-type</code></a></td><td>Returns a record containing information about a named schema type in the static context.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-type-of"><code>fn:type-of</code></a></td><td>Returns information about the type of a value, as a string.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-atomic-type-annotation"><code>fn:atomic-type-annotation</code></a></td><td>Returns a record containing information about the type annotation of an atomic value.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-node-type-annotation"><code>fn:node-type-annotation</code></a></td><td>Returns a record containing information about the type annotation of an element or attribute node.</td></tr></tbody></table><div class="_diffs div3"><h4><a id="schema-type-record"></a><span class="deltaxml-old" style="background:#FF5555">19.1.1</span><span class="deltaxml-new" style="background:#90EE90">20.1.1</span> <a href="#schema-type-record" style="text-decoration: none">Record fn:schema-type-record</a></h4><p>This record type represents the properties of a simple or complex type in a schema.</p><table class="fos-options"><thead><tr><th>Name</th><th>Meaning</th></tr></thead><tbody><tr><td><p><code>name</code></p></td><td class="fos-thin"><p>The name of the type. Empty in the case of an anonymous type. Corresponds to <a href="https://www.w3.org/TR/xmlschema11-1/#ctd-name">{name}<sup><small>XS11-1</small></sup></a> and <a href="https://www.w3.org/TR/xmlschema11-1/#ctd-target_namespace">{target namespace}<sup><small>XS11-1</small></sup></a> in the XSD component model for simple and complex type components.</p><ul><li><p><b>Type: </b><code>xs:QName?</code></p></li></ul></td></tr><tr><td><p><code>is-simple</code></p></td><td class="fos-thin"><p>True for a simple type, false for a complex type.</p><ul><li><p><b>Type: </b><code>xs:boolean</code></p></li></ul></td></tr><tr><td><p><code>base-type</code></p></td><td class="fos-thin"><p>Function item returning the base type (the type from which this type is derived by restriction or extension). The function is always present, and returns an empty sequence in the case of the type <code>xs:anyType</code>. Corresponds to the <a href="https://www.w3.org/TR/xmlschema11-1/#ctd-base_type_definition">{base type definition}<sup><small>XS11-1</small></sup></a> property in the XSD component model.</p><ul><li><p><b>Type: </b><code>fn() as schema-type-record?</code></p></li></ul></td></tr><tr><td><p><code>primitive-type?</code></p></td><td class="fos-thin"><p>For an atomic type, a function item returning the primitive type from which this type is ultimately derived. Corresponds to the <a href="https://www.w3.org/TR/xmlschema11-1/#std-primitive_type_definition">{primitive type definition}<sup><small>XS11-1</small></sup></a> in the XSD component model for simple types. Absent if the type is non atomic, or if it is the simple type <code>xs:anyAtomicType</code>. If this is a primitive type, the function item is idempotent.</p><ul><li><p><b>Type: </b><code>fn() as schema-type-record</code></p></li></ul></td></tr><tr><td><p><code>variety?</code></p></td><td class="fos-thin"><p>For a simple type, one of <code>"atomic"</code>, <code>"list"</code>, or <code>"union"</code>, corresponding to the <a href="https://www.w3.org/TR/xmlschema11-1/#std-variety">{variety}<sup><small>XS11-1</small></sup></a> of the simple type in the XSD component model. For a complex type, one of <code>"empty"</code>, <code>"simple"</code>, <code>"element-only"</code>, or <code>"mixed"</code>, corresponding to the <a href="https://www.w3.org/TR/xmlschema11-1/#ctd-content_type">{content type}<sup><small>XS11-1</small></sup></a>.<a href="https://www.w3.org/TR/xmlschema11-1/#ct-variety">{variety}<sup><small>XS11-1</small></sup></a> of the complex type in the XSD component model. The value is absent in cases where the <a href="https://www.w3.org/TR/xmlschema11-1/#std-variety">{variety}<sup><small>XS11-1</small></sup></a> in the XSD component model is absent, for example for the type <code>xs:anySimpleType</code>.</p><ul><li><p><b>Type: </b><code>enum("atomic", "list", "union", "empty", "simple", "element-only", "mixed")</code></p></li></ul></td></tr><tr><td><p><code>members?</code></p></td><td class="fos-thin"><p>For a simple type with variety <code>"union"</code>, a function that returns a sequence of records representing the member types of the union, in order, corresponding to the <a href="https://www.w3.org/TR/xmlschema11-1/#std-member_type_definitions">{member type definitions}<sup><small>XS11-1</small></sup></a> property in the XSD component model. For a simple type with variety <code>"list"</code>, a function that returns a record representing the item type of the list type, corresponding to the <a href="https://www.w3.org/TR/xmlschema11-1/#std-item_type_definition">{item type definition}<sup><small>XS11-1</small></sup></a> property in the XSD component model. In all other cases, absent.</p><ul><li><p><b>Type: </b><code>fn() as schema-type-record*</code></p></li></ul></td></tr><tr><td><p><code>simple-content-type?</code></p></td><td class="fos-thin"><p>For a complex type with variety <code>"simple"</code> (that is, a complex type with simple content), a function that returns a record representing the relevant simple type, corresponding to the <a href="https://www.w3.org/TR/xmlschema11-1/#ctd-content_type">{content type}<sup><small>XS11-1</small></sup></a>.<a href="https://www.w3.org/TR/xmlschema11-1/#ct-simple_type_definition">{simple type definition}<sup><small>XS11-1</small></sup></a> property in the XSD complex type component. In all other cases, absent.</p><ul><li><p><b>Type: </b><code>fn() as schema-type-record</code></p></li></ul></td></tr><tr><td><p><code>matches?</code></p></td><td class="fos-thin"><p>For a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-generalized-atomic-type">generalized atomic type</a><sup><small>XP</small></sup>, a function item that can be called to establish whether the supplied atomic item is an instance of this type. In all other cases, absent.</p><ul><li><p><b>Type: </b><code>fn(xs:anyAtomicType) as xs:boolean</code></p></li></ul></td></tr><tr><td><p><code>constructor?</code></p></td><td class="fos-thin"><p><span style="display: none;" class="delete_version">For a simple type, a function item that can be used to construct instances of this type. In the case of a named type that is present in the dynamic context, the result is the same function as returned by <a href="#func-function-lookup"><code>fn:function-lookup</code></a> applied to the type name (with arity one). For details see <a href="#constructor-functions-for-xsd-types"><span class="delete_version"><b>22.1 Constructor functions for XML Schema built-in atomic types</b></span><span class="modify_version"><b>22.1 Constructor functions for XML Schema built-in atomic types</b></span></a> and <a href="#constructor-functions-for-user-defined-types"><span class="delete_version"><b>22.5 Constructor functions for user-defined atomic and union types</b></span><span class="modify_version"><b>22.5 Constructor functions for user-defined atomic and union types</b></span></a>. Constructor function items are also available for anonymous types, and for types that might not be present in the dynamic context. The field is absent for complex types and for the abstract types <code>xs:anyAtomicType</code>, <code>xs:anySimpleType</code>, and <code>xs:NOTATION</code>. It is also absent for all <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-namespace-sensitive">namespace-sensitive</a><sup><small>XP</small></sup> types. </span><span style="display: none;" class="add_version">For a simple type, a function item that can be used to construct instances of this type. In the case of a named type that is present in the dynamic context, the result is the same function as returned by <a href="#func-function-lookup"><code>fn:function-lookup</code></a> applied to the type name (with arity one). For details see <a href="#constructor-functions-for-xsd-types"><span class="add_version"><b>23.1 Constructor functions for XML Schema built-in atomic types</b></span><span class="modify_version"><b>23.1 Constructor functions for XML Schema built-in atomic types</b></span></a> and <a href="#constructor-functions-for-user-defined-types"><span class="add_version"><b>23.5 Constructor functions for user-defined atomic and union types</b></span><span class="modify_version"><b>23.5 Constructor functions for user-defined atomic and union types</b></span></a>. Constructor function items are also available for anonymous types, and for types that might not be present in the dynamic context. The field is absent for complex types and for the abstract types <code>xs:anyAtomicType</code>, <code>xs:anySimpleType</code>, and <code>xs:NOTATION</code>. It is also absent for all <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-namespace-sensitive">namespace-sensitive</a><sup><small>XP</small></sup> types. </span><span class="modify_version">For a simple type, a function item that can be used to construct instances of this type. In the case of a named type that is present in the dynamic context, the result is the same function as returned by <a href="#func-function-lookup"><code>fn:function-lookup</code></a> applied to the type name (with arity one). For details see <a href="#constructor-functions-for-xsd-types"><span style="display: none;" class="delete_version"><b>22.1 Constructor functions for XML Schema built-in atomic types</b></span><span style="display: none;" class="add_version"><b>23.1 Constructor functions for XML Schema built-in atomic types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22.1</span><span class="deltaxml-new" style="background:#90EE90">23.1</span> Constructor functions for XML Schema built-in atomic types</b></span></a> and <a href="#constructor-functions-for-user-defined-types"><span style="display: none;" class="delete_version"><b>22.5 Constructor functions for user-defined atomic and union types</b></span><span style="display: none;" class="add_version"><b>23.5 Constructor functions for user-defined atomic and union types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22.5</span><span class="deltaxml-new" style="background:#90EE90">23.5</span> Constructor functions for user-defined atomic and union types</b></span></a>. Constructor function items are also available for anonymous types, and for types that might not be present in the dynamic context. The field is absent for complex types and for the abstract types <code>xs:anyAtomicType</code>, <code>xs:anySimpleType</code>, and <code>xs:NOTATION</code>. It is also absent for all <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-namespace-sensitive">namespace-sensitive</a><sup><small>XP</small></sup> types. </span></p><ul><li><p><b>Type: </b><code>fn(xs:anyAtomicType?) as xs:anyAtomicType*</code></p></li></ul></td></tr><tr><td><p><code>*</code></p></td><td><p>The record type is extensible (it may contain additional fields beyond those listed).</p></td></tr></tbody></table></div><div class="_diffs div3"><h4><a id="func-schema-type"></a><span class="deltaxml-old" style="background:#FF5555">19.1.2</span><span class="deltaxml-new" style="background:#90EE90">20.1.2</span> <a href="#func-schema-type" style="text-decoration: none">fn:schema-type</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#func-type-of">next</a> | <a href="#functions-on-types">previous</a>)</p><ol><li><p>New in 4.0<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/148">148</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1523">1523</a>&nbsp;22 October 2024]</i></p></li></ol></div><dl><dt class="label">Summary</dt><dd><p>Returns a record containing information about a named schema type in the static context.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">fn:schema-type</code>(</td></tr><tr class="arg"><td><code>$name</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:QName</code></code></td><td></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code class="return-type-ref"><a href="#schema-type-record">schema-type-record</a>?</code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-dependent" class="termref" href="#dt-context-dependent">context-dependent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. </p></dd><dt class="label">Rules</dt><dd><p>If the static context (specifically, the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-is-types">in-scope schema types</a><sup><small>XP</small></sup>) includes a schema type whose name matches <code>$name</code>, the function returns a <a href="#schema-type-record">schema-type-record</a> containing information about that schema type. If not, it returns an empty sequence.</p></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><tbody><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><p><code>schema-type( #xs:integer ) ? name</code></p></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><p><code>#xs:integer</code></p></td></tr><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><p><code>schema-type( #xs:long ) ? primitive-type() ? name</code></p></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><p><code>#xs:decimal</code></p></td></tr><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><p><code>schema-type( #xs:positiveInteger ) ? base-type() ? name</code></p></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><p><code>#xs:nonNegativeInteger</code></p></td></tr><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><p><code>schema-type( #xs:integer ) ? matches(23)</code></p></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><p><code>true()</code></p></td></tr><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><p><code>schema-type( #xs:numeric ) ? variety</code></p></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><p><code>"union"</code></p></td></tr><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><p><code>schema-type( #xs:numeric ) ? members() ? name</code></p></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><p><code>#xs:double, #xs:float, #xs:decimal</code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div3"><h4><a id="func-type-of"></a><span class="deltaxml-old" style="background:#FF5555">19.1.3</span><span class="deltaxml-new" style="background:#90EE90">20.1.3</span> <a href="#func-type-of" style="text-decoration: none">fn:type-of</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#func-atomic-type-annotation">next</a> | <a href="#func-schema-type">previous</a>)</p><ol><li><p>New in 4.0<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1550">1550</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1570">1570</a>&nbsp;12 November 2024]</i></p></li></ol></div><dl><dt class="label">Summary</dt><dd><p>Returns information about the type of a value, as a string.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">fn:type-of</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>item()*</code></code></td><td></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:string</code></code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-independent" class="termref" href="#dt-context-independent">context-independent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. </p></dd><dt class="label">Rules</dt><dd><p>The function returns a string, whose lexical form will always match the grammar of <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#SequenceType">SequenceType</a><sup><small>XP</small></sup>, representing a sequence type that matches <code>$value</code>.</p><p>If <code>$value</code> is the empty sequence, the function returns the string <code>"empty-sequence()"</code>.</p><p>Otherwise, the returned string is the concatenation of:</p><ol class="enumar"><li><p>A string representing the distinct item types that are present in <code>$value</code>, formed as follows:</p><ol class="enumla"><li><p>For each item in <code>$value</code>, construct a string representing its item type as described below.</p></li><li><p>Eliminate duplicate strings from this list by applying the <a href="#func-distinct-values"><code>fn:distinct-values</code></a> function, forming a sequence of strings <var>$ss</var>.</p></li><li><p>If <var>$ss</var> contains only one string, use that string.</p></li><li><p>Otherwise, return the result of the expression <code>`({ fn:string-join(<var>$ss</var>, "|") })`</code>.</p></li></ol></li><li><p>An occurrence indicator: absent if <code>$value</code> contains exactly one item, or <code>"+"</code> if it contains more than one item.</p></li></ol><p>The string representing the type of an individual item <var>J</var> is constructed as follows:</p><ol class="enumar"><li><p>If <var>J</var> is an <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-XNode">XNode</a><sup><small>DM</small></sup>, the result is one of the following strings, determined by the node kind of the node (see <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a> section <a href="../xpath-datamodel-40/#dm-node-kind">7.6.9 node-kind Accessor</a>):</p><blockquote><p><code>"document-node()"</code><br><code>"element()"</code><br><code>"attribute()"</code><br><code>"text()"</code><br><code>"processing-instruction()"</code><br><code>"comment()"</code><br><code>"namespace-node()"</code></p></blockquote></li><li><p>If <var>J</var> is a <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-JNode">JNode</a><sup><small>DM</small></sup>, the result is in the form <code>jnode(<var>T</var>)</code>, where <var>T</var> is the result of applying the <a href="#func-type-of"><code>type-of</code></a> function to the <b>·content·</b> property of <var>J</var>.</p></li><li><p>If <var>J</var> is an atomic item, the result is a string chosen as follows:</p><ol class="enumla"><li><p>Let <var>T</var> be the type denoted by the type annotation of <var>J</var>.</p></li><li><p>If <var>T</var> is an anonymous type, set <var>T</var> to the base type of <var>T</var>, and repeat until a type is reached that is not anonymous.</p></li><li><p>If the name of <var>T</var> is in the namespace <code>http://www.w3.org/2001/XMLSchema</code>, return the string <code>"xs:<var>local</var>"</code> where <var>local</var> is the local part of the name of <var>T</var>.</p></li><li><p>Otherwise, return the name of <var>T</var> in the form of a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#URIQualifiedName">URIQualifiedName</a><sup><small>XP</small></sup> (that is, <code>"Q{<var>uri</var>}<var>local</var>"</code>, or <code>"Q{}<var>local</var>"</code> if the name is in no namespace).</p></li></ol></li><li><p>If <var>J</var> is a function item:</p><ol class="enumla"><li><p>If <var>J</var> is an array, return <code>"array(*)"</code>.</p></li><li><p>If <var>J</var> is a map, return <code>"map(*)"</code>.</p></li><li><p>Otherwise, return <code>"function(*)"</code>.</p></li></ol></li></ol></dd><dt class="label">Error Conditions</dt><dd><p>If the <code>$value</code> argument is omitted and the context value is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM</small></sup>, the function raises type error [<a href="https://www.w3.org/TR/xpath20/#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>]<sup><small>XP</small></sup>.</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>In general, an item matches more than one type, and there are cases where there is no single matching type that is more specific than all the others. This is especially true with functions, maps, and arrays. This function therefore selects one of the types that matches the item, which is not necessarily the most specific type.</p><p>This function should not be used as a substitute for an <code>instance of</code> test. The precise type annotation of the result of an expression is not always predictable, because processors are free to deliver a more specific type than is mandated by the specification. For example, if <code>$n</code> is of type <code>xs:positiveInteger</code>, then the result of <code>abs($n)</code> is guaranteed to be an instance of <code>xs:integer</code>, but an implementation might reasonably return the supplied value unchanged: that is, a value whose actual type annotation is <code>xs:positiveInteger</code>. Similarly the type annotation of the value returned by <code>position()</code> might be <code>xs:long</code> rather than <code>xs:integer</code>.</p><p>Implementations <span class="verb">should</span>, however, refrain from exposing types that are purely internal. For example, an implementation might have an optimized internal representation for strings consisting entirely of ASCII characters, or for single-character strings; if this is the case then the type annotation returned by this function should be a user-visible supertype such as <code>xs:string</code>.</p></div></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><thead><tr><th>Variables</th></tr></thead><tbody><tr><td colspan="2"><div class="exampleInner"><pre xml:space="preserve" class="small">let $e := &lt;doc&gt;
  &lt;p id="alpha" xml:id="beta"&gt;One&lt;/p&gt;
  &lt;p id="gamma" xmlns="http://example.com/ns"&gt;Two&lt;/p&gt;
  &lt;ex:p id="delta" xmlns:ex="http://example.com/ns"&gt;Three&lt;/ex:p&gt;
  &lt;?pi 3.14159?&gt;
&lt;/doc&gt;</pre></div></td></tr></tbody></table><table class="medium"><thead><tr><th>Expression</th><th>Result</th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>type-of($e//*[@id = 'alpha'])</code></pre></div></td><td style="vertical-align:top"><p><code>"element()"</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>type-of($e//*)</code></pre></div></td><td style="vertical-align:top"><p><code>"element()+"</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>type-of($e//@id[. = 'gamma'])</code></pre></div></td><td style="vertical-align:top"><p><code>"attribute()"</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>type-of($e//node()[. = '3.14159'])</code></pre></div></td><td style="vertical-align:top"><p><code>"processing-instruction()"</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>type-of($e//no-such-node)</code></pre></div></td><td style="vertical-align:top"><p><code>"empty-sequence()"</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>type-of($e/child::node())</code></pre></div></td><td style="vertical-align:top"><p><code>"(element()|processing-instruction())+"</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>type-of(1)</code></pre></div></td><td style="vertical-align:top"><p><code>"xs:integer"</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>type-of(1 to 5)</code></pre></div></td><td style="vertical-align:top"><p><code>"xs:integer+"</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>type-of((1, 1.2, 2))</code></pre></div></td><td style="vertical-align:top"><p><code>"(xs:integer|xs:decimal)+"</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>type-of([ 1, 2, 3 ])</code></pre></div></td><td style="vertical-align:top"><p><code>"array(*)"</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>type-of({ 'a': 1 })</code></pre></div></td><td style="vertical-align:top"><p><code>"map(*)"</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>type-of(type-of#1)</code></pre></div></td><td style="vertical-align:top"><p><code>"function(*)"</code></p></td></tr><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>type-of(jtree([]))</code></pre></div></td><td style="vertical-align:top"><p><code>"jnode(array(*))"</code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div3"><h4><a id="func-atomic-type-annotation"></a><span class="deltaxml-old" style="background:#FF5555">19.1.4</span><span class="deltaxml-new" style="background:#90EE90">20.1.4</span> <a href="#func-atomic-type-annotation" style="text-decoration: none">fn:atomic-type-annotation</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#func-node-type-annotation">next</a> | <a href="#func-type-of">previous</a>)</p><ol><li><p>New in 4.0<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/148">148</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1523">1523</a>&nbsp;22 October 2024]</i></p></li></ol></div><dl><dt class="label">Summary</dt><dd><p>Returns a record containing information about the type annotation of an atomic value.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">fn:atomic-type-annotation</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType</code></code></td><td></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code class="return-type-ref"><a href="#schema-type-record">schema-type-record</a></code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-independent" class="termref" href="#dt-context-independent">context-independent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. </p></dd><dt class="label">Rules</dt><dd><p>Given an atomic value, the function returns a <a href="#schema-type-record">schema-type-record</a> containing information about the atomic type represented by its <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-type-annotation">type annotation</a><sup><small>DM</small></sup>.</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>The result will always have <code>?is-simple = true()</code> and <code>?variety = "atomic"</code>. In a non-schema-aware environment the type will always be a built-in atomic type in the <code>xs</code> namespace: see <a href="#atomic-type-hierarchy"><b>1.8.3 Atomic Type Hierarchy</b></a>. Where a schema is in use, however, the result may be an atomic type defined in the schema, which may be an anonymous type.</p><p>Note that under the function coercion rules, it is possible to supply a node as the argument, which will then be atomized. In simple cases the type annotation on the atomized value will be the same as the type annotation on the node. But this is not always true: for example the type annotation on the node might be a complex type with simple content, while the type annotation on its atomized value is the corresponding simple content type. To get the type annotation on the node, use the function <a href="#func-node-type-annotation"><code>fn:node-type-annotation</code></a>.</p><p>This function should not be used as a substitute for an <code>instance of</code> test. The precise type annotation of the result of an expression is not always predictable, because processors are free to deliver a more specific type than is mandated by the specification. For example, if <code>$n</code> is of type <code>xs:positiveInteger</code>, then the result of <code>abs($n)</code> is guaranteed to be an instance of <code>xs:integer</code>, but an implementation might reasonably return the supplied value unchanged: that is, a value whose actual type annotation is <code>xs:positiveInteger</code>. Similarly the type annotation of the value returned by <code>position()</code> might be <code>xs:long</code> rather than <code>xs:integer</code>.</p><p>Implementations <span class="verb">should</span>, however, refrain from exposing types that are purely internal. For example, an implementation might have an optimized internal representation for strings consisting entirely of ASCII characters, or for single-character strings; if this is the case then the type annotation returned by this function should be a user-visible supertype such as <code>xs:string</code>.</p></div></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><tbody><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">atomic-type-annotation(23) ? name</pre></div></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">#xs:integer</pre></div></td></tr><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">let $x := 23, $y := 93.7 
return atomic-type-annotation($x) ? matches($y)</pre></div></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">false()</pre></div></td></tr><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">atomic-type-annotation(xs:numeric('23.2')) ? name</pre></div></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">#xs:double</pre></div></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div3"><h4><a id="func-node-type-annotation"></a><span class="deltaxml-old" style="background:#FF5555">19.1.5</span><span class="deltaxml-new" style="background:#90EE90">20.1.5</span> <a href="#func-node-type-annotation" style="text-decoration: none">fn:node-type-annotation</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#func-error">next</a> | <a href="#func-atomic-type-annotation">previous</a>)</p><ol><li><p>New in 4.0<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/148">148</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1523">1523</a>&nbsp;22 October 2024]</i></p></li></ol></div><dl><dt class="label">Summary</dt><dd><p>Returns a record containing information about the type annotation of an element or attribute node.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">fn:node-type-annotation</code>(</td></tr><tr class="arg"><td><code>$node</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>(element() | attribute())</code></code></td><td></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code class="return-type-ref"><a href="#schema-type-record">schema-type-record</a></code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-independent" class="termref" href="#dt-context-independent">context-independent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. </p></dd><dt class="label">Rules</dt><dd><p>Given an element or attribute node, the function returns a <a href="#schema-type-record">schema-type-record</a> containing information about the schema type represented by its <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-type-annotation">type annotation</a><sup><small>DM</small></sup>.</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>For an element that has not been schema-validated, the type annotation is always <code>xs:untyped</code>.</p><p>For an attribute that has not been schema-validated, the type annotation is always <code>xs:untypedAtomic</code>.</p><p>The type annotation of an attribute node is always a simple type; the type annotation of an element node may be simple or complex.</p></div></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><tbody><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">let $e := parse-xml("&lt;e/&gt;")/*
return node-type-annotation($e) ? name</pre></div></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">#xs:untyped</pre></div></td></tr><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">let $a := parse-xml("&lt;e a='3'/&gt;")//@a
return node-type-annotation($a) ? name</pre></div></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">#xs:untypedAtomic</pre></div></td></tr><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">let $x := json-to-xml('[23, 24]', { 'validate': true() })
return node-type-annotation($x/*) ? name</pre></div></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">#fn:arrayType</pre></div></td></tr><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve" class="small">let $x := json-to-xml('[23, 24]', { 'validate': true() })
let $n23 := $x//fn:number[. = 23]                  
let $type := node-type-annotation($n23)
return ($type ? name, 
        $type ? base-type() ? name, 
        $type ? base-type() ? base-type() ? name)</pre></div></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">#fn:numberType, 
#fn:finiteNumberType, 
#xs:double</pre></div></td></tr></tbody></table></div></dd></dl></div></div></div><div class="_diffs div1"><h2><a id="context"></a><span class="deltaxml-old" style="background:#FF5555">20</span><span class="deltaxml-new" style="background:#90EE90">21</span> <a href="#context" style="text-decoration: none">Accessing the context</a></h2><p>The following functions are defined to obtain information from the static or dynamic context.</p><table class="index"><thead><tr><th>Function</th><th>Meaning</th></tr></thead><tbody><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-current-date"><code>fn:current-date</code></a></td><td>Returns the current date.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-current-dateTime"><code>fn:current-dateTime</code></a></td><td>Returns the current date and time (with timezone).</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-current-time"><code>fn:current-time</code></a></td><td>Returns the current time.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-default-collation"><code>fn:default-collation</code></a></td><td>Returns the value of the default collation property from the <span>dynamic</span> context. </td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-default-language"><code>fn:default-language</code></a></td><td>Returns the value of the default language property from the dynamic context. </td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-implicit-timezone"><code>fn:implicit-timezone</code></a></td><td>Returns the value of the implicit timezone property from the dynamic context. </td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-last"><code>fn:last</code></a></td><td>Returns the context size from the dynamic context.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-position"><code>fn:position</code></a></td><td>Returns the context position from the dynamic context.</td></tr><tr><td style="white-space:nowrap; vertical-align:top"><a href="#func-static-base-uri"><code>fn:static-base-uri</code></a></td><td>This function returns the value of the <b>executable base URI</b> property from the dynamic context.</td></tr></tbody></table><div class="_diffs div2"><h3><a id="func-current-date"></a><span class="deltaxml-old" style="background:#FF5555">20.1</span><span class="deltaxml-new" style="background:#90EE90">21.1</span> <a href="#func-current-date" style="text-decoration: none">fn:current-date</a></h3><dl><dt class="label">Summary</dt><dd><p>Returns the current date.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name return-type"><td colspan="3"><code class="function">fn:current-date</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:date</code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-dependent" class="termref" href="#dt-context-dependent">context-dependent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. It depends on implicit timezone. </p></dd><dt class="label">Rules</dt><dd><p>Returns <code>xs:date(fn:current-dateTime())</code>. This is an <code>xs:date</code> (with timezone) that is current at some time during the evaluation of a query or transformation in which <a href="#func-current-date"><code>fn:current-date</code></a> is executed.</p><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>. The precise instant during the query or transformation represented by the value of <a href="#func-current-date"><code>fn:current-date</code></a> is <a title="implementation-dependent" class="termref" href="#implementation-dependent">implementation-dependent</a>.</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>The returned date will always have an associated timezone, which will always be the same as the implicit timezone in the dynamic context</p></div></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><tbody><tr><td colspan="2"><p><code>current-date()</code> returns an <code>xs:date</code> corresponding to the current date. For example, a call of <code>current-date()</code> might return <code>2004-05-12+01:00</code>. </p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div2"><h3><a id="func-current-dateTime"></a><span class="deltaxml-old" style="background:#FF5555">20.2</span><span class="deltaxml-new" style="background:#90EE90">21.2</span> <a href="#func-current-dateTime" style="text-decoration: none">fn:current-dateTime</a></h3><dl><dt class="label">Summary</dt><dd><p>Returns the current date and time (with timezone).</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name return-type"><td colspan="3"><code class="function">fn:current-dateTime</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:dateTimeStamp</code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-dependent" class="termref" href="#dt-context-dependent">context-dependent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. It depends on implicit timezone. </p></dd><dt class="label">Rules</dt><dd><p>Returns the current dateTime (with timezone) from the dynamic context. (See <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-xp-evaluation-context-components">B.2 Dynamic Context Components</a>.) This is an <code>xs:dateTime</code> that is current at some time during the evaluation of a query or transformation in which <a href="#func-current-dateTime"><code>fn:current-dateTime</code></a> is executed.</p><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>. The precise instant during the query or transformation represented by the value of <code>fn:current-dateTime()</code> is <a title="implementation-dependent" class="termref" href="#implementation-dependent">implementation-dependent</a>.</p><p>If the implementation supports data types from XSD 1.1 then the returned value will be an instance of <code>xs:dateTimeStamp</code>. Otherwise, the only guarantees are that it will be an instance of <code>xs:dateTime</code> and will have a timezone component.</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>The returned <code>xs:dateTime</code> will always have an associated timezone, which will always be the same as the implicit timezone in the dynamic context</p></div></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><tbody><tr><td colspan="2"><p><code>current-dateTime()</code> returns an <code>xs:dateTimeStamp</code> corresponding to the current date and time. For example, a call of <code>current-dateTime()</code> might return <code>2004-05-12T18:17:15.125Z</code> corresponding to the current time on May 12, 2004 in timezone <code>Z</code>. </p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div2"><h3><a id="func-current-time"></a><span class="deltaxml-old" style="background:#FF5555">20.3</span><span class="deltaxml-new" style="background:#90EE90">21.3</span> <a href="#func-current-time" style="text-decoration: none">fn:current-time</a></h3><dl><dt class="label">Summary</dt><dd><p>Returns the current time.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name return-type"><td colspan="3"><code class="function">fn:current-time</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:time</code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-dependent" class="termref" href="#dt-context-dependent">context-dependent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. It depends on implicit timezone. </p></dd><dt class="label">Rules</dt><dd><p>Returns <code>xs:time(fn:current-dateTime())</code>. This is an <code>xs:time</code> (with timezone) that is current at some time during the evaluation of a query or transformation in which <a href="#func-current-time"><code>fn:current-time</code></a> is executed.</p><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>. The precise instant during the query or transformation represented by the value of <code>fn:current-time()</code> is <a title="implementation-dependent" class="termref" href="#implementation-dependent">implementation-dependent</a>.</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>The returned time will always have an associated timezone, which will always be the same as the implicit timezone in the dynamic context</p></div></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><tbody><tr><td colspan="2"><p><code>current-time()</code> returns an <code>xs:time</code> corresponding to the current time. For example, a call of <code>current-time()</code> might return <code>23:17:00.000-05:00</code>. </p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div2"><h3><a id="func-default-collation"></a><span class="deltaxml-old" style="background:#FF5555">20.4</span><span class="deltaxml-new" style="background:#90EE90">21.4</span> <a href="#func-default-collation" style="text-decoration: none">fn:default-collation</a></h3><dl><dt class="label">Summary</dt><dd><p>Returns the value of the default collation property from the <span>dynamic</span> context. </p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name return-type"><td colspan="3"><code class="function">fn:default-collation</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:string</code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-dependent" class="termref" href="#dt-context-dependent">context-dependent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. It depends on collations. </p></dd><dt class="label">Rules</dt><dd><p>Returns the value of the default collation property from the <span>dynamic</span> context context. Components of the dynamic context are described in <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a> section <a href="../xquery-40/xpath-40.html#eval_context">2.2.2 Dynamic Context</a>.</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>The default collation property can never be absent. If it is not explicitly defined, a system defined default can be invoked. If this is not provided, the Unicode codepoint collation (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>) is used. </p><p>In most cases, the default collation is known statically, and a call on this function can therefore be pre-evaluated during static analysis. The only notable exception is when a call on <code>default-collation()</code> is used to define the default value of a parameter to a user-defined function. In this case it is interpreted as a reference to the default collation in the context of the relevant function call, which may differ from the default collation of the function definition.</p></div></dd></dl></div><div class="_diffs div2"><h3><a id="func-default-language"></a><span class="deltaxml-old" style="background:#FF5555">20.5</span><span class="deltaxml-new" style="background:#90EE90">21.5</span> <a href="#func-default-language" style="text-decoration: none">fn:default-language</a></h3><dl><dt class="label">Summary</dt><dd><p>Returns the value of the default language property from the dynamic context. </p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name return-type"><td colspan="3"><code class="function">fn:default-language</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:language</code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-dependent" class="termref" href="#dt-context-dependent">context-dependent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. It depends on default language. </p></dd><dt class="label">Rules</dt><dd><p>Returns the value of the default language property from the dynamic context. Components of the dynamic context are described in <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a> section <a href="../xquery-40/xpath-40.html#eval_context">2.2.2 Dynamic Context</a>.</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>The default language property can never be absent. The functions <a href="#func-format-integer"><code>fn:format-integer</code></a>, <a href="#func-format-date"><code>fn:format-date</code></a>, <a href="#func-format-time"><code>fn:format-time</code></a>, and <a href="#func-format-dateTime"><code>fn:format-dateTime</code></a> are defined to use the default language if no explicit language is supplied. The default language may play a role in selection of a default collation, but this is not a requirement.</p></div></dd></dl></div><div class="_diffs div2"><h3><a id="func-implicit-timezone"></a><span class="deltaxml-old" style="background:#FF5555">20.6</span><span class="deltaxml-new" style="background:#90EE90">21.6</span> <a href="#func-implicit-timezone" style="text-decoration: none">fn:implicit-timezone</a></h3><dl><dt class="label">Summary</dt><dd><p>Returns the value of the implicit timezone property from the dynamic context. </p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name return-type"><td colspan="3"><code class="function">fn:implicit-timezone</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:dayTimeDuration</code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-dependent" class="termref" href="#dt-context-dependent">context-dependent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. It depends on implicit timezone. </p></dd><dt class="label">Rules</dt><dd><p>Returns the value of the implicit timezone property from the dynamic context. Components of the dynamic context are described in <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-xp-evaluation-context-components">B.2 Dynamic Context Components</a>.</p></dd></dl></div><div class="_diffs div2"><h3><a id="func-last"></a><span class="deltaxml-old" style="background:#FF5555">20.7</span><span class="deltaxml-new" style="background:#90EE90">21.7</span> <a href="#func-last" style="text-decoration: none">fn:last</a></h3><dl><dt class="label">Summary</dt><dd><p>Returns the context size from the dynamic context.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name return-type"><td colspan="3"><code class="function">fn:last</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:integer</code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-dependent" class="termref" href="#dt-context-dependent">context-dependent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-dependent">focus-dependent</a>. </p></dd><dt class="label">Rules</dt><dd><p>Returns the context size from the dynamic context. (See <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-xp-evaluation-context-components">B.2 Dynamic Context Components</a>.)</p></dd><dt class="label">Error Conditions</dt><dd><p>A type error is raised [<a href="https://www.w3.org/TR/xpath20/#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>]<sup><small>XP</small></sup> if the context <span>size</span> is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM</small></sup>.</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>Under most circumstances, the context size is absent only if the context value is absent. However, XSLT 3.0 with streaming defines situations in which the context value and context position are known, but the context size is unknown.</p></div></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><thead><tr><th>Expression</th><th>Result</th></tr></thead><tbody><tr><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve"><code>(1 to 20)[last() - 1]</code></pre></div></td><td style="vertical-align:top"><p><code>19</code></p></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div2"><h3><a id="func-position"></a><span class="deltaxml-old" style="background:#FF5555">20.8</span><span class="deltaxml-new" style="background:#90EE90">21.8</span> <a href="#func-position" style="text-decoration: none">fn:position</a></h3><dl><dt class="label">Summary</dt><dd><p>Returns the context position from the dynamic context.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name return-type"><td colspan="3"><code class="function">fn:position</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:integer</code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-dependent" class="termref" href="#dt-context-dependent">context-dependent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-dependent">focus-dependent</a>. </p></dd><dt class="label">Rules</dt><dd><p>Returns the context position from the dynamic context. (See <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-xp-evaluation-context-components">B.2 Dynamic Context Components</a>.)</p></dd><dt class="label">Error Conditions</dt><dd><p>A type error is raised [<a href="https://www.w3.org/TR/xpath20/#ERRXPDY0002" title="err:XPDY0002">err:XPDY0002</a>]<sup><small>XP</small></sup> if the context value is <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-absent">absent</a><sup><small>DM</small></sup>.</p></dd></dl></div><div class="_diffs div2"><h3><a id="func-static-base-uri"></a><span class="deltaxml-old" style="background:#FF5555">20.9</span><span class="deltaxml-new" style="background:#90EE90">21.9</span> <a href="#func-static-base-uri" style="text-decoration: none">fn:static-base-uri</a></h3><dl><dt class="label">Summary</dt><dd><p>This function returns the value of the <b>executable base URI</b> property from the dynamic context.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name return-type"><td colspan="3"><code class="function">fn:static-base-uri</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:anyURI?</code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-dependent" class="termref" href="#dt-context-dependent">context-dependent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. It depends on executable base URI. </p></dd><dt class="label">Rules</dt><dd><p>The function (despite its name) returns the value of the <b>executable base URI</b> property from the dynamic context. If the property is absent, the empty sequence is returned.</p><p>Components of the dynamic context are described in <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a> section <a href="../xquery-40/xpath-40.html#eval_context">2.2.2 Dynamic Context</a> .</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>The executable base URI will in many cases be the same as the static base URI in the static context. However, XQuery and XSLT give an implementation freedom to use different base URIs during the static analysis phase and the dynamic evaluation phase, that is, for retrieval of compile-time and run-time resources respectively. This is appropriate when the implementation allows the output of static analysis (a “compiled” query or stylesheet) to be deployed for execution to a different location from the one where static analysis took place. In this situation, the <a href="#func-static-base-uri"><code>fn:static-base-uri</code></a> function should return a URI suitable for locating resources needed during dynamic evaluation.</p><p>If a call on the <a href="#func-static-base-uri"><code>fn:static-base-uri</code></a> function appears within the expression used to define the value of an optional parameter to a user-defined function, then the value supplied to the function (if the argument is omitted) will be the executable base URI from the dynamic context of the function caller. This allows such a function to resolve relative URIs supplied in other parameters to the same function.</p></div></dd></dl></div></div><div class="_diffs div1"><h2><a id="errors-and-diagnostics"></a><span class="deltaxml-old" style="background:#FF5555">21</span><span class="deltaxml-new" style="background:#90EE90">22</span> <a href="#errors-and-diagnostics" style="text-decoration: none">Errors and diagnostics</a></h2><div class="_diffs div2"><h3><a id="errors"></a><span class="deltaxml-old" style="background:#FF5555">21.1</span><span class="deltaxml-new" style="background:#90EE90">22.1</span> <a href="#errors" style="text-decoration: none">Raising errors</a></h3><p>In this document, as well as in <a href="#xquery-40">[XQuery 4.0: An XML Query Language]</a> and <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a>, the phrase “an error is raised” is used. Raising an error is equivalent to calling the <a href="#func-error"><code>fn:error</code></a> function defined in this section with the provided error code. Except where otherwise specified, errors defined in this specification are dynamic errors. Some errors, however, are classified as type errors. Type errors are typically used where the presence of the error can be inferred from knowledge of the type of the actual arguments to a function, for example with a call such as <code>fn:string(fn:abs#1)</code>. Host languages may allow type errors to be reported statically if they are discovered during static analysis.</p><p> When function specifications indicate that an error is to be raised, the notation “[<em>error code</em> ]” is used to specify an error code. Each error defined in this document is identified by an <code>xs:QName</code> that is in the <code>http://www.w3.org/2005/xqt-errors</code> namespace, represented in this document by the <code>err</code> prefix. It is this <code>xs:QName</code> that is actually passed as an argument to the <a href="#func-error"><code>fn:error</code></a> function. Calling this function raises an error. For a more detailed treatment of error handing, see <a href="https://www.w3.org/TR/xpath-31/#id-handling-dynamic"> 2.3.3 Handling Dynamic Errors </a><sup><small>XP31</small></sup>.</p><p>The <a href="#func-error"><code>fn:error</code></a> function is a general function that may be called as above but may also be called from <a href="#xquery-40">[XQuery 4.0: An XML Query Language]</a> or <a href="#xpath-40">[XML Path Language (XPath) 4.0]</a> applications with, for example, an <code>xs:QName</code> argument. </p><div class="_diffs div3"><h4><a id="func-error"></a><span class="deltaxml-old" style="background:#FF5555">21.1.1</span><span class="deltaxml-new" style="background:#90EE90">22.1.1</span> <a href="#func-error" style="text-decoration: none">fn:error</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#func-trace">next</a> | <a href="#func-node-type-annotation">previous</a>)</p><ol><li><p>All three arguments are now optional, and each argument can be set to an empty sequence. Previously if <code>$description</code> was supplied, it could not be empty.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/895">895</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/901">901</a>&nbsp;16 December 2023]</i></p></li></ol></div><dl><dt class="label">Summary</dt><dd><p>Calling the <a href="#func-error"><code>fn:error</code></a> function raises an application-defined error.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">fn:error</code>(</td></tr><tr class="arg"><td><code>$code</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:QName?</code></code></td><td><code class="assign">:=&nbsp;</code><code>()</code>,</td></tr><tr class="arg"><td><code>$description</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:string?</code></code></td><td><code class="assign">:=&nbsp;</code><code>()</code>,</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>item()*</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>item()*</code></code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="nondeterministic" class="termref" href="#dt-nondeterministic">nondeterministic</a>, <a title="context-independent" class="termref" href="#dt-context-independent">context-independent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. </p></dd><dt class="label">Rules</dt><dd><p>This function never returns a value. Instead it always raises an error. The effect of the error is identical to the effect of dynamic errors raised implicitly, for example when an incorrect argument is supplied to a function.</p><p>The parameters to the <a href="#func-error"><code>fn:error</code></a> function supply information that is associated with the error condition and that is made available to a caller that asks for information about the error. The error may be caught either by the host language (using a try/catch construct in XSLT or XQuery, for example), or by the calling application or external processing environment. The way in which error information is returned to the external processing environment is <a title="implementation-dependent" class="termref" href="#implementation-dependent">implementation-dependent</a>.</p><p>There are three pieces of information that may be associated with an error.</p><ul><li><p>The <code>$code</code> is an error code that distinguishes this error from others. It is an <code>xs:QName</code>; the namespace URI conventionally identifies the component, subsystem, or authority responsible for defining the meaning of the error code, while the local part identifies the specific error condition. The namespace URI <code>http://www.w3.org/2005/xqt-errors</code> is used for errors defined in this specification; other namespace URIs may be used for errors defined by the application.</p><p>If the external processing environment expects the error code to be returned as a URI or a string rather than as an <code>xs:QName</code>, then an error code with namespace URI <code>NS</code> and local part <code>LP</code> will be returned in the form <code>NS#LP</code>. The namespace URI part of the error code should therefore not include a fragment identifier.</p><p>If no value is supplied for the <code>$code</code> argument, <span>or if the value supplied is an empty sequence,</span> the effective value of the error code is <code>fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')</code>.</p></li><li><p>The <code>$description</code> is a natural-language description of the error condition.</p><p>If no value is supplied for the <code>$description</code> argument, <span>or if the value supplied is an empty sequence,</span> then the effective value of the description is <a title="implementation-dependent" class="termref" href="#implementation-dependent">implementation-dependent</a>.</p></li><li><p>The <code>$value</code> is an arbitrary value used to convey additional information about the error, and may be used in any way the application chooses.</p><p>If no value is supplied for the <code>$value</code> argument <span>or if the value supplied is an empty sequence</span>, then the effective value of the error object is <a title="implementation-dependent" class="termref" href="#implementation-dependent">implementation-dependent</a>.</p></li></ul></dd><dt class="label">Error Conditions</dt><dd><p>This function always raises a dynamic error. By default, it raises [<a href="#ERRFOER0000" title="err:FOER0000">err:FOER0000</a>]</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>The value of the <code>$description</code> parameter may need to be localized.</p><p>Since the function never returns a value, the declared return type of <code>item()*</code> is a convenient fiction. It is relevant insofar as a function item such as <code>error#1</code> may (as a consequence of function coercion) be supplied in contexts where a function with a more specific return type is required.</p><p>Any QName may be used as an error code; there are no reserved names or namespaces. The error is always classified as a dynamic error, even if the error code used is one that is normally used for static errors or type errors.</p></div></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><tbody><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><p><code>error()</code></p></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><p>Raises error FOER0000.</p><p><em>(This returns the URI <code>http://www.w3.org/2005/xqt-errors#FOER0000</code> (or the corresponding <code>xs:QName</code>) to the external processing environment, unless the error is caught using a try/catch construct in the host language.)</em></p></td></tr><tr class="testdiv"><th style="vertical-align:top">Expression:</th><td style="vertical-align:top"><div class="exampleInner"><pre xml:space="preserve">error(
  QName('http://www.example.com/HR', 'myerr:toohighsal'),
  'Salary is too high'
)</pre></div></td></tr><tr><th style="vertical-align:top">Result:</th><td style="vertical-align:top"><p>Raises error myerr:toohighsal.</p><p><em>(This returns <code>http://www.example.com/HR#toohighsal</code> and the <code>xs:string</code><code>"Salary is too high"</code> (or the corresponding <code>xs:QName</code>) to the external processing environment, unless the error is caught using a try/catch construct in the host language.)</em></p></td></tr></tbody></table></div></dd></dl></div></div><div class="_diffs div2"><h3><a id="diagnostics"></a><span class="deltaxml-old" style="background:#FF5555">21.2</span><span class="deltaxml-new" style="background:#90EE90">22.2</span> <a href="#diagnostics" style="text-decoration: none">Diagnostic tracing</a></h3><div class="_diffs div3"><h4><a id="func-trace"></a><span class="deltaxml-old" style="background:#FF5555">21.2.1</span><span class="deltaxml-new" style="background:#90EE90">22.2.1</span> <a href="#func-trace" style="text-decoration: none">fn:trace</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#func-message">next</a> | <a href="#func-error">previous</a>)</p><ol><li><p>The <code>$label</code> argument can now be set to an empty sequence. Previously if <code>$label</code> was supplied, it could not be empty.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/895">895</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/901">901</a>&nbsp;16 December 2023]</i></p></li></ol></div><dl><dt class="label">Summary</dt><dd><p>Provides an execution trace intended to be used in debugging queries.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">fn:trace</code>(</td></tr><tr class="arg"><td><code>$input</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>item()*</code></code>,</td><td></td></tr><tr class="arg"><td><code>$label</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:string?</code></code></td><td><code class="assign">:=&nbsp;</code><code>()</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>item()*</code></code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-independent" class="termref" href="#dt-context-independent">context-independent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. </p></dd><dt class="label">Rules</dt><dd><p>The function returns <code>$input</code>, unchanged.</p><p>In addition, the values of <code>$input</code>, typically serialized and converted to an <code>xs:string</code>, and <code>$label</code> (if supplied <span>and non-empty</span>) <span class="verb">may</span> be output to an <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a> destination.</p><p>Any serialization of the implementation’s trace output <span class="verb">must not</span> raise an error. This can be achieved (for example) by using a serialization method that can handle arbitrary input, such as the adaptive output method (see <a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#adaptive-output"> 10 Adaptive Output Method </a><sup><small>SER31</small></sup>).</p><p>The format of the trace output and its order are <a title="implementation-dependent" class="termref" href="#implementation-dependent">implementation-dependent</a>. Therefore, the order in which the output appears is not predictable. This also means that if dynamic errors occur (whether or not they are caught using try/catch), it may be unpredictable whether any output is reported before the error occurs.</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>If the trace information is unrelated to a specific value, <a href="#func-message"><code>fn:message</code></a> can be used instead.</p></div></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><tbody><tr><td colspan="2"><p>Consider a situation in which a user wants to investigate the actual value passed to a function. Assume that in a particular execution, <code>$v</code> is an <code>xs:decimal</code> with value <code>124.84</code>. Writing <code>fn:trace($v, 'the value of $v is:')</code> will return <code>$v</code>. The processor <span class="verb">may</span> output <code>"124.84"</code> and <code>"the value of $v is:"</code> to an <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a> destination.</p></td></tr><tr><td colspan="2"><p>The following two XPath expressions are identical, but only the second provides trace feedback to the user: </p></td></tr><tr><td colspan="2"><ul><li><p><code>//book[xs:decimal(@price) gt 100]</code></p></li><li><p><code>//book[xs:decimal(@price) gt 100] =&gt; trace('books more expensive than €100:')</code></p></li></ul></td></tr></tbody></table></div></dd></dl></div><div class="_diffs div3"><h4><a id="func-message"></a><span class="deltaxml-old" style="background:#FF5555">21.2.2</span><span class="deltaxml-new" style="background:#90EE90">22.2.2</span> <a href="#func-message" style="text-decoration: none">fn:message</a></h4><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#constructor-functions">next</a> | <a href="#func-trace">previous</a>)</p><ol><li><p>New in 4.0<i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/574">574</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/651">651</a>&nbsp;PRs <a href="https://github.com/qt4cg/qtspecs/pull/629">629</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/pull/803">803</a>&nbsp;7 November 2023]</i></p></li></ol></div><dl><dt class="label">Summary</dt><dd><p>Outputs trace information and discards the result.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">fn:message</code>(</td></tr><tr class="arg"><td><code>$input</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>item()*</code></code>,</td><td></td></tr><tr class="arg"><td><code>$label</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:string?</code></code></td><td><code class="assign">:=&nbsp;</code><code>()</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>empty-sequence()</code></code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a>, <a title="context-independent" class="termref" href="#dt-context-independent">context-independent</a>, and <a title="focus-dependent" class="termref" href="#dt-focus-independent">focus-independent</a>. </p></dd><dt class="label">Rules</dt><dd><p>Similar to <a href="#func-trace"><code>fn:trace</code></a>, the values of <code>$input</code>, typically serialized and converted to an <code>xs:string</code>, and <code>$label</code> (if supplied and non-empty) <span class="verb">may</span> be output to an <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a> destination.</p><p>In contrast to <a href="#func-trace"><code>fn:trace</code></a>, the function returns an empty sequence.</p><p>Any serialization of the implementation’s log output <span class="verb">must not</span> raise an error. This can e.g. be achieved by using a serialization method that can handle arbitrary input, such as the <a href="https://www.w3.org/TR/xslt-xquery-serialization-31/#adaptive-output"> 10 Adaptive Output Method </a><sup><small>SER31</small></sup>.</p><p>The format of the log output and its order are <a title="implementation-dependent" class="termref" href="#implementation-dependent">implementation-dependent</a>. Therefore, the order in which the output appears is not predictable. This also means that if dynamic errors occur (whether or not they are caught using try/catch), it may be unpredictable whether any output is logged before the error occurs.</p></dd><dt class="label">Notes</dt><dd><div class="note"><p>The function can be used for debugging. It can also be helpful in productive environments, e.g. to store dynamic input and evaluations to log files.</p></div></dd><dt class="label">Examples</dt><dd><div class="example"><table class="medium"><tbody><tr><td colspan="2"><p>The following two XPath expressions are identical, but only the second logs any feedback: </p></td></tr><tr><td colspan="2"><ul><li><p><code>//book[xs:decimal(@price) lt 1000]</code></p></li><li><p><code>//book[if (xs:decimal(@price) lt 1000) then true() else message(@price, @title || ' is unexpectedly expensive: ')]</code></p></li></ul></td></tr></tbody></table></div></dd></dl></div></div></div><div class="_diffs div1"><h2><a id="constructor-functions"></a><span class="deltaxml-old" style="background:#FF5555">22</span><span class="deltaxml-new" style="background:#90EE90">23</span> <a href="#constructor-functions" style="text-decoration: none">Constructor functions</a></h2><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-constructors-for-record-tests">next</a> | <a href="#func-message">previous</a>)</p><ol><li><p> Constructor functions now have a zero-arity form; the first argument defaults to the context item. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/658">658</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/662">662</a>&nbsp;29 August 2023]</i></p></li></ol></div><p> Constructor functions are used to convert a supplied value to a given type, and the name of the function is the same as the name of the target type. This section describes constructor functions corresponding to the following types:</p><ul><li><p>Simple types (atomic types, union types, and list types as defined in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a>), which are present in the static context either because they appear in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-is-types">in-scope schema types</a><sup><small>XP</small></sup> or because they appear as <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-named-item-type">named item types</a><sup><small>XP</small></sup>. </p><p>These constructor functions always take a single argument.</p></li><li><p>Record types defined as <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-named-item-type">named item types</a><sup><small>XP</small></sup>.</p><p>These take one argument for each named field of the record type. Constructor functions for record types are defined in <a href="#id-constructors-for-record-tests"><span style="display: none;" class="delete_version"><b>22.6 Constructor functions for named record types</b></span><span style="display: none;" class="add_version"><b>23.6 Constructor functions for named record types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22.6</span><span class="deltaxml-new" style="background:#90EE90">23.6</span> Constructor functions for named record types</b></span></a>. </p></li></ul><p> Constructor functions are defined for all user-defined named simple types, and for most built-in atomic, list, and union types. The only named simple types that have no constructor function are those that have no instances other than instances of their derived types: specifically, <code>xs:anySimpleType</code>, <code>xs:anyAtomicType</code>, and <code>xs:NOTATION</code>. </p><div class="_diffs div2"><h3><a id="constructor-functions-for-xsd-types"></a><span class="deltaxml-old" style="background:#FF5555">22.1</span><span class="deltaxml-new" style="background:#90EE90">23.1</span> <a href="#constructor-functions-for-xsd-types" style="text-decoration: none">Constructor functions for XML Schema built-in atomic types</a></h3><p>Every built-in atomic type that is defined in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a>, except <code>xs:anyAtomicType</code> and <code>xs:NOTATION</code>, has an associated constructor function. The type <code>xs:untypedAtomic</code>, defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types"> 2.7 Schema Information </a><sup><small>DM31</small></sup> and the two derived types <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code> defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types"> 2.7 Schema Information </a><sup><small>DM31</small></sup> also have associated constructor functions. Implementations <span class="verb">may</span> additionally provide a constructor functions for the new datatype <code>xs:dateTimeStamp</code> introduced in <a href="#xmlschema11-2">[XSD 1.1 Part 2]</a>.</p><p><span style="display: none;" class="delete_version"> A constructor function is not defined for <code>xs:anyAtomicType</code> as there are no atomic items with type annotation <code>xs:anyAtomicType</code> at runtime, although this can be a statically inferred type. A constructor function is not defined for <code>xs:NOTATION</code> since it is defined as an abstract type in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a>. If the static context (See <a href="https://www.w3.org/TR/xpath-31/#static_context"> 2.1.1 Static Context </a><sup><small>XP31</small></sup>) contains a type derived from <code>xs:NOTATION</code> then a constructor function is defined for it. See <a href="#constructor-functions-for-user-defined-types"><span class="delete_version"><b>22.5 Constructor functions for user-defined atomic and union types</b></span><span class="modify_version"><b>22.5 Constructor functions for user-defined atomic and union types</b></span></a>. </span><span style="display: none;" class="add_version"> A constructor function is not defined for <code>xs:anyAtomicType</code> as there are no atomic items with type annotation <code>xs:anyAtomicType</code> at runtime, although this can be a statically inferred type. A constructor function is not defined for <code>xs:NOTATION</code> since it is defined as an abstract type in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a>. If the static context (See <a href="https://www.w3.org/TR/xpath-31/#static_context"> 2.1.1 Static Context </a><sup><small>XP31</small></sup>) contains a type derived from <code>xs:NOTATION</code> then a constructor function is defined for it. See <a href="#constructor-functions-for-user-defined-types"><span class="add_version"><b>23.5 Constructor functions for user-defined atomic and union types</b></span><span class="modify_version"><b>23.5 Constructor functions for user-defined atomic and union types</b></span></a>. </span><span class="modify_version"> A constructor function is not defined for <code>xs:anyAtomicType</code> as there are no atomic items with type annotation <code>xs:anyAtomicType</code> at runtime, although this can be a statically inferred type. A constructor function is not defined for <code>xs:NOTATION</code> since it is defined as an abstract type in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a>. If the static context (See <a href="https://www.w3.org/TR/xpath-31/#static_context"> 2.1.1 Static Context </a><sup><small>XP31</small></sup>) contains a type derived from <code>xs:NOTATION</code> then a constructor function is defined for it. See <a href="#constructor-functions-for-user-defined-types"><span style="display: none;" class="delete_version"><b>22.5 Constructor functions for user-defined atomic and union types</b></span><span style="display: none;" class="add_version"><b>23.5 Constructor functions for user-defined atomic and union types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22.5</span><span class="deltaxml-new" style="background:#90EE90">23.5</span> Constructor functions for user-defined atomic and union types</b></span></a>. </span></p><p> The form of the constructor function for an atomic type <em>eg:TYPE</em> is:</p><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">eg:TYPE</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>eg:TYPE</code>?</code></td></tr></tbody></table></div><p>If <code>$arg</code> is the empty sequence, the empty sequence is returned. For example, the signature of the constructor function corresponding to the <code>xs:unsignedInt</code> type defined in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> is:</p><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:unsignedInt</code>(</td></tr><tr class="arg"><td><code>$arg</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:unsignedInt</code>?</code></td></tr></tbody></table></div><p>Calling the constructor function <code>xs:unsignedInt(12)</code> returns the <code> xs:unsignedInt</code> value 12. Another call of that constructor function that returns the same <code>xs:unsignedInt</code> value is <code>xs:unsignedInt("12")</code>. The same result would also be returned if the constructor function were to be called with a node that had a typed value equal to the <code>xs:unsignedInt</code> 12. The standard features described in <a href="https://www.w3.org/TR/xpath-31/#id-atomization"> 2.4.2 Atomization </a><sup><small>XP31</small></sup> would atomize the node to extract its typed value and then call the constructor with that value. If the value passed to a constructor is not in the lexical space of the datatype to be constructed, and cannot be converted to a value in the value space of the datatype under the rules in this specification, then an dynamic error is raised [<a href="#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>].</p><p><span style="display: none;" class="delete_version">The semantics of the constructor function <code>xs:TYPE(arg)</code> are identical to the semantics of <code>arg</code> cast as <code>xs:TYPE?</code> . See <a href="#casting"><span class="delete_version"><b>23 Casting</b></span><span class="modify_version"><b>23 Casting</b></span></a>.</span><span style="display: none;" class="add_version">The semantics of the constructor function <code>xs:TYPE(arg)</code> are identical to the semantics of <code>arg</code> cast as <code>xs:TYPE?</code> . See <a href="#casting"><span class="add_version"><b>24 Casting</b></span><span class="modify_version"><b>24 Casting</b></span></a>.</span><span class="modify_version">The semantics of the constructor function <code>xs:TYPE(arg)</code> are identical to the semantics of <code>arg</code> cast as <code>xs:TYPE?</code> . See <a href="#casting"><span style="display: none;" class="delete_version"><b>23 Casting</b></span><span style="display: none;" class="add_version"><b>24 Casting</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23</span><span class="deltaxml-new" style="background:#90EE90">24</span> Casting</b></span></a>.</span></p><p>If the argument to a constructor function is a literal, the result of the function <span class="verb">may</span> be evaluated statically; if an error is found during such evaluation, it may be reported as a static error. </p><p><span style="display: none;" class="delete_version">Special rules apply to constructor functions for <code>xs:QName</code> and types derived from <code>xs:QName</code> and <code>xs:NOTATION</code>. See <a href="#constructor-qname-notation"><span class="delete_version"><b>22.2 Constructor functions for xs:QName and xs:NOTATION</b></span><span class="modify_version"><b>22.2 Constructor functions for xs:QName and xs:NOTATION</b></span></a>. </span><span style="display: none;" class="add_version">Special rules apply to constructor functions for <code>xs:QName</code> and types derived from <code>xs:QName</code> and <code>xs:NOTATION</code>. See <a href="#constructor-qname-notation"><span class="add_version"><b>23.2 Constructor functions for xs:QName and xs:NOTATION</b></span><span class="modify_version"><b>23.2 Constructor functions for xs:QName and xs:NOTATION</b></span></a>. </span><span class="modify_version">Special rules apply to constructor functions for <code>xs:QName</code> and types derived from <code>xs:QName</code> and <code>xs:NOTATION</code>. See <a href="#constructor-qname-notation"><span style="display: none;" class="delete_version"><b>22.2 Constructor functions for xs:QName and xs:NOTATION</b></span><span style="display: none;" class="add_version"><b>23.2 Constructor functions for xs:QName and xs:NOTATION</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22.2</span><span class="deltaxml-new" style="background:#90EE90">23.2</span> Constructor functions for xs:QName and xs:NOTATION</b></span></a>. </span></p><p>The argument is optional, and defaults to the context value (which will be atomized if necessary).</p><p>The following constructor functions for the built-in atomic types are supported:</p><ul><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:string</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:string</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:boolean</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:boolean</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:decimal</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:decimal</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:float</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:float</code>?</code></td></tr></tbody></table></div><p>Implementations <span class="verb">should</span> return negative zero for <code>xs:float("-0.0E0")</code>. But because <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> does not distinguish between the values positive zero and negative zero, implementations <span class="verb">may</span> return positive zero in this case.</p></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:double</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:double</code>?</code></td></tr></tbody></table></div><p>Implementations <span class="verb">should</span> return negative zero for <code>xs:double("-0.0E0")</code>. But because <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> does not distinguish between the values positive zero and negative zero, implementations <span class="verb">may</span> return positive zero in this case.</p></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:duration</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:duration</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:dateTime</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:dateTime</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:time</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:time</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:date</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:date</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:gYearMonth</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:gYearMonth</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:gYear</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:gYear</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:gMonthDay</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:gMonthDay</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:gDay</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:gDay</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:gMonth</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:gMonth</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:hexBinary</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:hexBinary</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:base64Binary</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:base64Binary</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:anyURI</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:anyURI</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:QName</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:QName</code>?</code></td></tr></tbody></table></div><p> See <a href="#constructor-qname-notation"><span style="display: none;" class="delete_version"><b>22.2 Constructor functions for xs:QName and xs:NOTATION</b></span><span style="display: none;" class="add_version"><b>23.2 Constructor functions for xs:QName and xs:NOTATION</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22.2</span><span class="deltaxml-new" style="background:#90EE90">23.2</span> Constructor functions for xs:QName and xs:NOTATION</b></span></a> for special rules.</p></li></ul><ul><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:normalizedString</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:normalizedString</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:token</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:token</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:language</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:language</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:NMTOKEN</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:NMTOKEN</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:Name</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:Name</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:NCName</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:NCName</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:ID</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:ID</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:IDREF</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:IDREF</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:ENTITY</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:ENTITY</code>?</code></td></tr></tbody></table></div><p><span style="display: none;" class="delete_version">See <a href="#casting-to-ENTITY"><span class="delete_version"><b>23.1.10 Casting to xs:ENTITY</b></span><span class="modify_version"><b>23.1.10 Casting to xs:ENTITY</b></span></a> for rules related to constructing values of type <code>xs:ENTITY</code> and types derived from it.</span><span style="display: none;" class="add_version">See <a href="#casting-to-ENTITY"><span class="add_version"><b>24.1.10 Casting to xs:ENTITY</b></span><span class="modify_version"><b>24.1.10 Casting to xs:ENTITY</b></span></a> for rules related to constructing values of type <code>xs:ENTITY</code> and types derived from it.</span><span class="modify_version">See <a href="#casting-to-ENTITY"><span style="display: none;" class="delete_version"><b>23.1.10 Casting to xs:ENTITY</b></span><span style="display: none;" class="add_version"><b>24.1.10 Casting to xs:ENTITY</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.1.10</span><span class="deltaxml-new" style="background:#90EE90">24.1.10</span> Casting to xs:ENTITY</b></span></a> for rules related to constructing values of type <code>xs:ENTITY</code> and types derived from it.</span></p></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:integer</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:integer</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:nonPositiveInteger</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:nonPositiveInteger</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:negativeInteger</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:negativeInteger</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:long</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:long</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:int</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:int</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:short</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:short</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:byte</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:byte</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:nonNegativeInteger</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:nonNegativeInteger</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:unsignedLong</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:unsignedLong</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:unsignedInt</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:unsignedInt</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:unsignedShort</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:unsignedShort</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:unsignedByte</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:unsignedByte</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:positiveInteger</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:positiveInteger</code>?</code></td></tr></tbody></table></div></li></ul><ul><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:yearMonthDuration</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:yearMonthDuration</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:dayTimeDuration</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:dayTimeDuration</code>?</code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:untypedAtomic</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:untypedAtomic</code>?</code></td></tr></tbody></table></div></li></ul><ul><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:dateTimeStamp</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:dateTimeStamp</code>?</code></td></tr></tbody></table></div><p><em>Available only if the implementation supports XSD 1.1.</em></p></li></ul></div><div class="_diffs div2"><h3><a id="constructor-qname-notation"></a><span class="deltaxml-old" style="background:#FF5555">22.2</span><span class="deltaxml-new" style="background:#90EE90">23.2</span> <a href="#constructor-qname-notation" style="text-decoration: none">Constructor functions for xs:QName and xs:NOTATION</a></h3><p>Special rules apply to constructor functions for the types <code>xs:QName</code> and <code>xs:NOTATION</code>, for two reasons:</p><ul><li><p> Values cannot belong directly to the type <code>xs:NOTATION</code>, only to its subtypes. </p></li><li><p> The lexical representation of these types uses namespace prefixes, whose meaning is context-dependent.</p></li></ul><p> These constraints result in the following rules:</p><ol class="enumar"><li><p> There is no constructor function for <code>xs:NOTATION</code>. Constructors are defined, however, for <code>xs:QName</code>, for types derived or constructed from <code>xs:QName</code>, and for types derived or constructed from <code>xs:NOTATION</code>. </p></li><li><p>When converting from an <code>xs:string</code>, the prefix within the lexical <code>xs:QName</code> supplied as the argument is resolved to a namespace URI using the statically known namespaces from the static context. If the lexical <code>xs:QName</code> has no prefix, the namespace URI of the resulting expanded-QName is the default namespace for elements and types, taken from the static context. Components of the static context are defined in <a href="https://www.w3.org/TR/xpath-31/#static_context"> 2.1.1 Static Context </a><sup><small>XP31</small></sup>. A dynamic error is raised [<a href="#ERRFONS0004" title="err:FONS0004">err:FONS0004</a>] if the prefix is not bound in the static context. As described in <a href="https://www.w3.org/TR/xpath-datamodel-31/#terminology"> 2.1 Terminology </a><sup><small>DM31</small></sup>, the supplied prefix is retained as part of the expanded-QName value.</p></li></ol><p>When a constructor function for a namespace-sensitive type is used as a literal function item or in a partial function application (for example, <code>xs:QName#1</code> or <code>xs:QName(?)</code>) the namespace bindings that are relevant are those from the static context of the literal function item or partial function application. When a constructor function for a namespace-sensitive type is obtained by means of the <a href="#func-function-lookup"><code>fn:function-lookup</code></a> function, the relevant namespace bindings are those from the static context of the call on <a href="#func-function-lookup"><code>fn:function-lookup</code></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>When the supplied argument to the <code>xs:QName</code> constructor function is a node, the node is atomized in the usual way, and if the result is <code>xs:untypedAtomic</code> it is then converted as if a string had been supplied. The effect might not be what is desired. For example, given the attribute <code>xsi:type="my:type"</code>, the expression <code>xs:QName(@xsi:type)</code> might fail on the grounds that the prefix <code>my</code> is undeclared. This is because the namespace bindings are taken from the static context (that is, from the query or stylesheet), and not from the source document containing the <code>@xsi:type</code> attribute. The solution to this problem is to use the function call <code>resolve-QName(@xsi:type, .)</code> instead.</p></div></div><div class="_diffs div2"><h3><a id="constructor-functions-for-xsd-list-types"></a><span class="deltaxml-old" style="background:#FF5555">22.3</span><span class="deltaxml-new" style="background:#90EE90">23.3</span> <a href="#constructor-functions-for-xsd-list-types" style="text-decoration: none">Constructor functions for XML Schema built-in list types</a></h3><p>Each of the three built-in list types defined in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a>, namely <code>xs:NMTOKENS</code>, <code>xs:ENTITIES</code>, and <code>xs:IDREFS</code>, has an associated constructor function.</p><p>The function signatures are as follows:</p><ul><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:NMTOKENS</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:string?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:NMTOKEN*</code></code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:ENTITIES</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:string?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:ENTITY*</code></code></td></tr></tbody></table></div></li><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:IDREFS</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:string?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:IDREF*</code></code></td></tr></tbody></table></div></li></ul><p>The semantics are equivalent to casting to the corresponding types from <code>xs:string</code>.</p><p>All three of these types have the facet <code>minLength = 1</code> meaning that there must always be at least one item in the list. The return type, however, allows for the fact that when the argument to the function is an empty sequence, the result is an empty sequence.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In the case of atomic types, it is possible to use an expression such as <code>xs:date(@date-of-birth)</code> to convert an attribute value to an instance of <code>xs:date</code>, knowing that this will work both in the case where the attribute is already annotated as <code>xs:date</code>, and also in the case where it is <code>xs:untypedAtomic</code>. This approach does not work with list types, because it is not permitted to use a value of type <code>xs:NMTOKEN*</code> as input to the constructor function <code>xs:NMTOKENS</code>. Instead, it is necessary to use conditional logic that performs the conversion only in the case where the input is untyped: <code>if (@x instance of attribute(*, xs:untypedAtomic)) then xs:NMTOKENS(@x) else data(@x)</code></p></div></div><div class="_diffs div2"><h3><a id="constructor-functions-for-xsd-union-types"></a><span class="deltaxml-old" style="background:#FF5555">22.4</span><span class="deltaxml-new" style="background:#90EE90">23.4</span> <a href="#constructor-functions-for-xsd-union-types" style="text-decoration: none">Constructor functions for XML Schema built-in union types</a></h3><p>There is a constructor function for the union type <code>xs:numeric</code> defined in <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>. The function signature is:</p><ul><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:numeric</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:numeric?</code></code></td></tr></tbody></table></div></li></ul><p>The semantics are determined by the rules in <a href="#casting-to-union"><span style="display: none;" class="delete_version"><b>23.3.7 Casting to union types</b></span><span style="display: none;" class="add_version"><b>24.3.7 Casting to union types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.7</span><span class="deltaxml-new" style="background:#90EE90">24.3.7</span> Casting to union types</b></span></a>. These rules have the effect that: </p><ol class="enumar"><li><p>If the argument is an instance of <code>xs:double</code>, <code>xs:float</code>, or <code>xs:decimal</code>, then the result is an instance of the same primitive type, with the same value;</p></li><li><p>If the argument is an instance of <code>xs:boolean</code>, the result is the <code>xs:double</code> value <code>0.0e0</code> or <code>1.0e0</code>;</p></li><li><p>If the argument is an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>, then:</p><ol class="enumla"><li><p>If the value is in the lexical space of <code>xs:double</code>, the result will be the corresponding <code>xs:double</code> value;</p></li><li><p>Otherwise, a dynamic error [<a href="#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>] occurs;</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The result will never be an instance of <code>xs:float</code>, <code>xs:decimal</code>, or <code>xs:integer</code>. This is because <code>xs:double</code> appears first in the list of member types of <code>xs:numeric</code>, and its lexical space subsumes the lexical space of the other numeric types. Thus, unlike XPath numeric literals, the result does not depend on the lexical form of the supplied value. The reason for this design choice is to retain compatibility with the function conversion rules: functions such as <a href="#func-abs"><code>fn:abs</code></a> and <a href="#func-round"><code>fn:round</code></a> are declared to expect an instance of <code>xs:numeric</code> as their first or only argument, and compatibility with the function conversion rules defined in earlier versions of these specifications demands that when an untyped atomic item (or untyped node) is supplied as the argument, it is converted to an <code>xs:double</code> value even if its lexical form is that (say) of an integer.</p></div></li><li><p>In all other cases, a dynamic error [<a href="#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>] occurs.</p></li></ol><p>In the case of an implementation that supports XSD 1.1, there is a constructor function associated with the built-in union type <code>xs:error</code>.</p><p>The function signature is as follows:</p><ul><li><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">xs:error</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType?</code></code></td><td><code class="assign">:=&nbsp;</code><code>.</code></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>xs:error?</code></code></td></tr></tbody></table></div></li></ul><p>The semantics are equivalent to casting to the corresponding union type (see <a href="#casting-to-union"><span style="display: none;" class="delete_version"><b>23.3.7 Casting to union types</b></span><span style="display: none;" class="add_version"><b>24.3.7 Casting to union types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.7</span><span class="deltaxml-new" style="background:#90EE90">24.3.7</span> Casting to union types</b></span></a>).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Because <code>xs:error</code> has no member types, and therefore has an empty value space, casting will always fail with a dynamic error except in the case where the supplied argument is an empty sequence, in which case the result is also an empty sequence.</p></div></div><div class="_diffs div2"><h3><a id="constructor-functions-for-user-defined-types"></a><span class="deltaxml-old" style="background:#FF5555">22.5</span><span class="deltaxml-new" style="background:#90EE90">23.5</span> <a href="#constructor-functions-for-user-defined-types" style="text-decoration: none">Constructor functions for user-defined atomic and union types</a></h3><p>For every <span>named</span> user-defined simple type in the static context (See <a href="https://www.w3.org/TR/xpath-31/#static_context"> 2.1.1 Static Context </a><sup><small>XP31</small></sup>), there is a constructor function whose name is the same as the name of the type.</p><p><span style="display: none;" class="delete_version">For named atomic types, the rules are the same as the rules for constructing built-in derived atomic types defined in <a href="#constructor-functions-for-xsd-types"><span class="delete_version"><b>22.1 Constructor functions for XML Schema built-in atomic types</b></span><span class="modify_version"><b>22.1 Constructor functions for XML Schema built-in atomic types</b></span></a>. For a named atomic type <code>T</code>, the signature of the function takes the form <code>T($value as xs:anyAtomicType? := .) as T?</code>, and the semantics are the same as casting to derived types: see <a href="#casting-to-derived-types"><span class="delete_version"><b>23.3.1 Casting to derived types</b></span><span class="modify_version"><b>23.3.1 Casting to derived types</b></span></a>..</span><span style="display: none;" class="add_version">For named atomic types, the rules are the same as the rules for constructing built-in derived atomic types defined in <a href="#constructor-functions-for-xsd-types"><span class="add_version"><b>23.1 Constructor functions for XML Schema built-in atomic types</b></span><span class="modify_version"><b>23.1 Constructor functions for XML Schema built-in atomic types</b></span></a>. For a named atomic type <code>T</code>, the signature of the function takes the form <code>T($value as xs:anyAtomicType? := .) as T?</code>, and the semantics are the same as casting to derived types: see <a href="#casting-to-derived-types"><span class="add_version"><b>24.3.1 Casting to derived types</b></span><span class="modify_version"><b>24.3.1 Casting to derived types</b></span></a>..</span><span class="modify_version">For named atomic types, the rules are the same as the rules for constructing built-in derived atomic types defined in <a href="#constructor-functions-for-xsd-types"><span style="display: none;" class="delete_version"><b>22.1 Constructor functions for XML Schema built-in atomic types</b></span><span style="display: none;" class="add_version"><b>23.1 Constructor functions for XML Schema built-in atomic types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22.1</span><span class="deltaxml-new" style="background:#90EE90">23.1</span> Constructor functions for XML Schema built-in atomic types</b></span></a>. For a named atomic type <code>T</code>, the signature of the function takes the form <code>T($value as xs:anyAtomicType? := .) as T?</code>, and the semantics are the same as casting to derived types: see <a href="#casting-to-derived-types"><span style="display: none;" class="delete_version"><b>23.3.1 Casting to derived types</b></span><span style="display: none;" class="add_version"><b>24.3.1 Casting to derived types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.1</span><span class="deltaxml-new" style="background:#90EE90">24.3.1</span> Casting to derived types</b></span></a>..</span></p><p><span style="display: none;" class="delete_version">For named union types, the rules follow the same principles as the rules for constructing built-in union types defined in <a href="#constructor-functions-for-xsd-union-types"><span class="delete_version"><b>22.4 Constructor functions for XML Schema built-in union types</b></span><span class="modify_version"><b>22.4 Constructor functions for XML Schema built-in union types</b></span></a>. For a named union type <code>U</code>, the signature of the function takes the form <code>U($value as xs:anyAtomicType? := .) as U?</code>, and the semantics are the same as casting to union types: see <a href="#casting-to-union"><span class="delete_version"><b>23.3.7 Casting to union types</b></span><span class="modify_version"><b>23.3.7 Casting to union types</b></span></a>.</span><span style="display: none;" class="add_version">For named union types, the rules follow the same principles as the rules for constructing built-in union types defined in <a href="#constructor-functions-for-xsd-union-types"><span class="add_version"><b>23.4 Constructor functions for XML Schema built-in union types</b></span><span class="modify_version"><b>23.4 Constructor functions for XML Schema built-in union types</b></span></a>. For a named union type <code>U</code>, the signature of the function takes the form <code>U($value as xs:anyAtomicType? := .) as U?</code>, and the semantics are the same as casting to union types: see <a href="#casting-to-union"><span class="add_version"><b>24.3.7 Casting to union types</b></span><span class="modify_version"><b>24.3.7 Casting to union types</b></span></a>.</span><span class="modify_version">For named union types, the rules follow the same principles as the rules for constructing built-in union types defined in <a href="#constructor-functions-for-xsd-union-types"><span style="display: none;" class="delete_version"><b>22.4 Constructor functions for XML Schema built-in union types</b></span><span style="display: none;" class="add_version"><b>23.4 Constructor functions for XML Schema built-in union types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22.4</span><span class="deltaxml-new" style="background:#90EE90">23.4</span> Constructor functions for XML Schema built-in union types</b></span></a>. For a named union type <code>U</code>, the signature of the function takes the form <code>U($value as xs:anyAtomicType? := .) as U?</code>, and the semantics are the same as casting to union types: see <a href="#casting-to-union"><span style="display: none;" class="delete_version"><b>23.3.7 Casting to union types</b></span><span style="display: none;" class="add_version"><b>24.3.7 Casting to union types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.7</span><span class="deltaxml-new" style="background:#90EE90">24.3.7</span> Casting to union types</b></span></a>.</span></p><p><span style="display: none;" class="delete_version">For named list types, the rules follow the same principles as the rules for constructing built-in list types defined in <a href="#constructor-functions-for-xsd-list-types"><span class="delete_version"><b>22.3 Constructor functions for XML Schema built-in list types</b></span><span class="modify_version"><b>22.3 Constructor functions for XML Schema built-in list types</b></span></a>. For a named list type <code>L</code>, where the item type of <code>L</code> is <code>I</code>, the signature of the function takes the form <code>L($value as xs:string? := .) as I*</code>, and the semantics are the same as casting to list types: see <a href="#casting-to-list"><span class="delete_version"><b>23.3.8 Casting to list types</b></span><span class="modify_version"><b>23.3.8 Casting to list types</b></span></a>.</span><span style="display: none;" class="add_version">For named list types, the rules follow the same principles as the rules for constructing built-in list types defined in <a href="#constructor-functions-for-xsd-list-types"><span class="add_version"><b>23.3 Constructor functions for XML Schema built-in list types</b></span><span class="modify_version"><b>23.3 Constructor functions for XML Schema built-in list types</b></span></a>. For a named list type <code>L</code>, where the item type of <code>L</code> is <code>I</code>, the signature of the function takes the form <code>L($value as xs:string? := .) as I*</code>, and the semantics are the same as casting to list types: see <a href="#casting-to-list"><span class="add_version"><b>24.3.8 Casting to list types</b></span><span class="modify_version"><b>24.3.8 Casting to list types</b></span></a>.</span><span class="modify_version">For named list types, the rules follow the same principles as the rules for constructing built-in list types defined in <a href="#constructor-functions-for-xsd-list-types"><span style="display: none;" class="delete_version"><b>22.3 Constructor functions for XML Schema built-in list types</b></span><span style="display: none;" class="add_version"><b>23.3 Constructor functions for XML Schema built-in list types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22.3</span><span class="deltaxml-new" style="background:#90EE90">23.3</span> Constructor functions for XML Schema built-in list types</b></span></a>. For a named list type <code>L</code>, where the item type of <code>L</code> is <code>I</code>, the signature of the function takes the form <code>L($value as xs:string? := .) as I*</code>, and the semantics are the same as casting to list types: see <a href="#casting-to-list"><span style="display: none;" class="delete_version"><b>23.3.8 Casting to list types</b></span><span style="display: none;" class="add_version"><b>24.3.8 Casting to list types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.8</span><span class="deltaxml-new" style="background:#90EE90">24.3.8</span> Casting to list types</b></span></a>.</span></p><p>Constructor functions are available both for named types defined in an imported schema (that is, named simple types in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-is-types">in-scope schema types</a><sup><small>XP</small></sup>), and for types defined by means of <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-named-item-type">named item types</a><sup><small>XP</small></sup>. Specifically, named enumeration types follow the same rules as schema types derived by restricting <code>xs:string</code>, and named local union types follow the same rules as union types defined in a schema.</p><p><span style="display: none;" class="delete_version">Special rules apply to constructor functions for namespace-sensitive types, that is, atomic types derived from <code>xs:QName</code> and <code>xs:NOTATION</code>, list types that have a namespace-sensitive item type, and union types that have a namespace-sensitive member type. See <a href="#constructor-qname-notation"><span class="delete_version"><b>22.2 Constructor functions for xs:QName and xs:NOTATION</b></span><span class="modify_version"><b>22.2 Constructor functions for xs:QName and xs:NOTATION</b></span></a>.</span><span style="display: none;" class="add_version">Special rules apply to constructor functions for namespace-sensitive types, that is, atomic types derived from <code>xs:QName</code> and <code>xs:NOTATION</code>, list types that have a namespace-sensitive item type, and union types that have a namespace-sensitive member type. See <a href="#constructor-qname-notation"><span class="add_version"><b>23.2 Constructor functions for xs:QName and xs:NOTATION</b></span><span class="modify_version"><b>23.2 Constructor functions for xs:QName and xs:NOTATION</b></span></a>.</span><span class="modify_version">Special rules apply to constructor functions for namespace-sensitive types, that is, atomic types derived from <code>xs:QName</code> and <code>xs:NOTATION</code>, list types that have a namespace-sensitive item type, and union types that have a namespace-sensitive member type. See <a href="#constructor-qname-notation"><span style="display: none;" class="delete_version"><b>22.2 Constructor functions for xs:QName and xs:NOTATION</b></span><span style="display: none;" class="add_version"><b>23.2 Constructor functions for xs:QName and xs:NOTATION</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22.2</span><span class="deltaxml-new" style="background:#90EE90">23.2</span> Constructor functions for xs:QName and xs:NOTATION</b></span></a>.</span></p><div class="example"><div class="exampleHeader"><a id="d5e83694"></a><a id="d5e89511"></a>Example: Using a Constructor Function for a User-Defined Atomic Type</div><p>Consider a situation where the static context contains an atomic type called <code>hatSize</code> defined in a schema whose target namespace is bound to the prefix <code>eg</code>. In such a case the following constructor function is available to users:</p><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function">eg:hatSize</code>(</td></tr><tr class="arg"><td><code>$value</code></td><td><code class="as">as&nbsp;</code><code class="type"><code>xs:anyAtomicType</code></code></td><td></td></tr><tr class="return-type"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code><code>my:hatSize</code>?</code></td></tr></tbody></table></div><p>The resulting function may be used in an expression such as <code>eg:hatSize("10½")</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p> To construct an instance of a user-defined type that is not in a namespace, it is possible to use an <code>EQName</code> (for example <code>Q{}hatsize(17)</code>). Alternatives are to use a cast expression (<code>17 cast as hatsize</code>) or (if the host language allows it) to undeclare the default function namespace. </p></div></div><div class="_diffs div2"><h3><a id="id-constructors-for-record-tests"></a><span class="deltaxml-old" style="background:#FF5555">22.6</span><span class="deltaxml-new" style="background:#90EE90">23.6</span> <a href="#id-constructors-for-record-tests" style="text-decoration: none">Constructor functions for named record types</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#casting-from-primitive-to-primitive">next</a> | <a href="#constructor-functions">previous</a>)</p><ol><li><p> Constructor functions for named record types have been introduced. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/617">617</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/953">953</a>&nbsp;20 February 2024]</i></p></li></ol></div><p>Both XQuery 4.0 and XSLT 4.0 provide syntax to declare named record types; such a declaration implicitly adds a constructor function for values of that type to the (See <a href="https://www.w3.org/TR/xpath-31/#static_context"> 2.1.1 Static Context </a><sup><small>XP31</small></sup>).</p><p>For example, if there is a named item type with the XQuery definition:</p><div class="exampleInner"><pre xml:space="preserve">declare record my:location (
  latitude  as xs:double,
  longitude as xs:double
)</pre></div><p>then there will be a function definition equivalent to:</p><div class="exampleInner"><pre xml:space="preserve" class="small">declare function my:location (
  $latitude  as xs:double,
  $longitude as xs:double
) as my:location {
  { 'latitude': $latitude, 'longitude': $longitude }
}</pre></div><p>Equivalently using XSLT syntax, if there is a named item type with the XSLT definition:</p><div class="exampleInner"><pre xml:space="preserve">&lt;xsl:record name="my:location"
  as="record(latitude as xs:double, longitude as xs:double)"/&gt;</pre></div><p>then there will be a function definition equivalent to:</p><div class="exampleInner"><pre xml:space="preserve" class="small">&lt;xsl:function name="my:location" as="my:location"&gt;
  &lt;xsl:param name="latitude" as="xs:double"/&gt;
  &lt;xsl:param name="longitude" as="xs:double"/&gt;
  &lt;xsl:map&gt;
    &lt;xsl:map-entry key="'latitude'" select="$latitude"/&gt;
    &lt;xsl:map-entry key="'longitude'" select="$longitude"/&gt;
  &lt;/xsl:map&gt;
&lt;/xsl:function&gt;</pre></div><p>The rules defining the relationship of the function definition to the record type are given for XQuery 4.0 in <a href="#xquery-40">[XQuery 4.0: An XML Query Language]</a> section <a href="../xquery-40/xquery-40.html#named-records-as-functions">5.20.2 Constructor Functions for Named Record Types</a>.</p><table class="ednote" caption="Editorial note"><tbody><tr><td style="text-align: left; vertical-align:top; width: 50%;"><b>Editorial note</b></td><td style="text-align: right; vertical-align:top; width: 50%;">&nbsp;</td></tr><tr style="text-align: left; vertical-align: top;"><td colspan="2">TODO: Add cross-reference to XSLT here. Anticipates resolution of issue #1485. </td></tr></tbody></table></div></div><div class="_diffs div1"><h2><a id="casting"></a><span class="deltaxml-old" style="background:#FF5555">23</span><span class="deltaxml-new" style="background:#90EE90">24</span> <a href="#casting" style="text-decoration: none">Casting</a></h2><p> Constructor functions and cast expressions accept an expression and return a value of a given type. They both convert a source value <var>SV</var>, of a source type, <var>ST</var> to a target value <var>TV</var>, of the given target type <var>TT</var>.</p><p><span style="display: none;" class="delete_version">Constructor functions and cast expressions have identical semantics but different syntax. The name of the constructor function is the same as the name of the built-in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> datatype or the datatype defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types"> 2.7 Schema Information </a><sup><small>DM31</small></sup> of <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a> (see <a href="#constructor-functions-for-xsd-types"><span class="delete_version"><b>22.1 Constructor functions for XML Schema built-in atomic types</b></span><span class="modify_version"><b>22.1 Constructor functions for XML Schema built-in atomic types</b></span></a>) or the user-derived datatype (see <a href="#constructor-functions-for-user-defined-types"><span class="delete_version"><b>22.5 Constructor functions for user-defined atomic and union types</b></span><span class="modify_version"><b>22.5 Constructor functions for user-defined atomic and union types</b></span></a>) that is the target for the conversion, and the semantics are exactly the same as for a cast expression; for example, <code>xs:date("2003-01-01")</code> means exactly the same as <code>"2003-01-01"</code> cast as <code>xs:date?</code>.</span><span style="display: none;" class="add_version">Constructor functions and cast expressions have identical semantics but different syntax. The name of the constructor function is the same as the name of the built-in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> datatype or the datatype defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types"> 2.7 Schema Information </a><sup><small>DM31</small></sup> of <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a> (see <a href="#constructor-functions-for-xsd-types"><span class="add_version"><b>23.1 Constructor functions for XML Schema built-in atomic types</b></span><span class="modify_version"><b>23.1 Constructor functions for XML Schema built-in atomic types</b></span></a>) or the user-derived datatype (see <a href="#constructor-functions-for-user-defined-types"><span class="add_version"><b>23.5 Constructor functions for user-defined atomic and union types</b></span><span class="modify_version"><b>23.5 Constructor functions for user-defined atomic and union types</b></span></a>) that is the target for the conversion, and the semantics are exactly the same as for a cast expression; for example, <code>xs:date("2003-01-01")</code> means exactly the same as <code>"2003-01-01"</code> cast as <code>xs:date?</code>.</span><span class="modify_version">Constructor functions and cast expressions have identical semantics but different syntax. The name of the constructor function is the same as the name of the built-in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> datatype or the datatype defined in <a href="https://www.w3.org/TR/xpath-datamodel-31/#types"> 2.7 Schema Information </a><sup><small>DM31</small></sup> of <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a> (see <a href="#constructor-functions-for-xsd-types"><span style="display: none;" class="delete_version"><b>22.1 Constructor functions for XML Schema built-in atomic types</b></span><span style="display: none;" class="add_version"><b>23.1 Constructor functions for XML Schema built-in atomic types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22.1</span><span class="deltaxml-new" style="background:#90EE90">23.1</span> Constructor functions for XML Schema built-in atomic types</b></span></a>) or the user-derived datatype (see <a href="#constructor-functions-for-user-defined-types"><span style="display: none;" class="delete_version"><b>22.5 Constructor functions for user-defined atomic and union types</b></span><span style="display: none;" class="add_version"><b>23.5 Constructor functions for user-defined atomic and union types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22.5</span><span class="deltaxml-new" style="background:#90EE90">23.5</span> Constructor functions for user-defined atomic and union types</b></span></a>) that is the target for the conversion, and the semantics are exactly the same as for a cast expression; for example, <code>xs:date("2003-01-01")</code> means exactly the same as <code>"2003-01-01"</code> cast as <code>xs:date?</code>.</span></p><p>The cast expression takes a type name to indicate the target type of the conversion. See <a href="https://www.w3.org/TR/xpath-31/#id-cast"> 3.14.2 Cast </a><sup><small>XP31</small></sup>. If the type name allows the empty sequence and the expression to be cast is the empty sequence, the empty sequence is returned. If the type name does not allow the empty sequence and the expression to be cast is the empty sequence, a type error is raised [<a href="https://www.w3.org/TR/xpath20/#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]<sup><small>XP</small></sup>.</p><p>Where the argument to a cast is a literal, the result of the function <span class="verb">may</span> be evaluated statically; if an error is encountered during such evaluation, it <span class="verb">may</span> be reported as a static error. </p><p><span style="display: none;" class="delete_version">The general rules for casting from primitive types to primitive types are defined in <a href="#casting-from-primitive-to-primitive"><span class="delete_version"><b>23.1 Casting from primitive types to primitive types</b></span><span class="modify_version"><b>23.1 Casting from primitive types to primitive types</b></span></a>, and subsections describe the rules for specific target types. The general rules for casting from <code>xs:string</code> (and <code>xs:untypedAtomic</code>) follow in <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. Casting to non-primitive types, including atomic types derived by restriction, union types, and list types, is described in <a href="#casting-non-primitive-types"><span class="delete_version"><b>23.3 Casting involving non-primitive types</b></span><span class="modify_version"><b>23.3 Casting involving non-primitive types</b></span></a>. Casting from derived types is defined in <a href="#casting-from-derived-to-parent"><span class="delete_version"><b>23.3.4 Casting from derived types to parent types</b></span><span class="modify_version"><b>23.3.4 Casting from derived types to parent types</b></span></a>, <a href="#casting-within-branch"><span class="delete_version"><b>23.3.5 Casting within a branch of the type hierarchy</b></span><span class="modify_version"><b>23.3.5 Casting within a branch of the type hierarchy</b></span></a> and <a href="#casting-across-hierarchy"><span class="delete_version"><b>23.3.6 Casting across the type hierarchy</b></span><span class="modify_version"><b>23.3.6 Casting across the type hierarchy</b></span></a>.</span><span style="display: none;" class="add_version">The general rules for casting from primitive types to primitive types are defined in <a href="#casting-from-primitive-to-primitive"><span class="add_version"><b>24.1 Casting from primitive types to primitive types</b></span><span class="modify_version"><b>24.1 Casting from primitive types to primitive types</b></span></a>, and subsections describe the rules for specific target types. The general rules for casting from <code>xs:string</code> (and <code>xs:untypedAtomic</code>) follow in <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. Casting to non-primitive types, including atomic types derived by restriction, union types, and list types, is described in <a href="#casting-non-primitive-types"><span class="add_version"><b>24.3 Casting involving non-primitive types</b></span><span class="modify_version"><b>24.3 Casting involving non-primitive types</b></span></a>. Casting from derived types is defined in <a href="#casting-from-derived-to-parent"><span class="add_version"><b>24.3.4 Casting from derived types to parent types</b></span><span class="modify_version"><b>24.3.4 Casting from derived types to parent types</b></span></a>, <a href="#casting-within-branch"><span class="add_version"><b>24.3.5 Casting within a branch of the type hierarchy</b></span><span class="modify_version"><b>24.3.5 Casting within a branch of the type hierarchy</b></span></a> and <a href="#casting-across-hierarchy"><span class="add_version"><b>24.3.6 Casting across the type hierarchy</b></span><span class="modify_version"><b>24.3.6 Casting across the type hierarchy</b></span></a>.</span><span class="modify_version">The general rules for casting from primitive types to primitive types are defined in <a href="#casting-from-primitive-to-primitive"><span style="display: none;" class="delete_version"><b>23.1 Casting from primitive types to primitive types</b></span><span style="display: none;" class="add_version"><b>24.1 Casting from primitive types to primitive types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.1</span><span class="deltaxml-new" style="background:#90EE90">24.1</span> Casting from primitive types to primitive types</b></span></a>, and subsections describe the rules for specific target types. The general rules for casting from <code>xs:string</code> (and <code>xs:untypedAtomic</code>) follow in <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>. Casting to non-primitive types, including atomic types derived by restriction, union types, and list types, is described in <a href="#casting-non-primitive-types"><span style="display: none;" class="delete_version"><b>23.3 Casting involving non-primitive types</b></span><span style="display: none;" class="add_version"><b>24.3 Casting involving non-primitive types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3</span><span class="deltaxml-new" style="background:#90EE90">24.3</span> Casting involving non-primitive types</b></span></a>. Casting from derived types is defined in <a href="#casting-from-derived-to-parent"><span style="display: none;" class="delete_version"><b>23.3.4 Casting from derived types to parent types</b></span><span style="display: none;" class="add_version"><b>24.3.4 Casting from derived types to parent types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.4</span><span class="deltaxml-new" style="background:#90EE90">24.3.4</span> Casting from derived types to parent types</b></span></a>, <a href="#casting-within-branch"><span style="display: none;" class="delete_version"><b>23.3.5 Casting within a branch of the type hierarchy</b></span><span style="display: none;" class="add_version"><b>24.3.5 Casting within a branch of the type hierarchy</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.5</span><span class="deltaxml-new" style="background:#90EE90">24.3.5</span> Casting within a branch of the type hierarchy</b></span></a> and <a href="#casting-across-hierarchy"><span style="display: none;" class="delete_version"><b>23.3.6 Casting across the type hierarchy</b></span><span style="display: none;" class="add_version"><b>24.3.6 Casting across the type hierarchy</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.6</span><span class="deltaxml-new" style="background:#90EE90">24.3.6</span> Casting across the type hierarchy</b></span></a>.</span></p><p>Casting is not supported to or from <code>xs:anySimpleType</code>. Casting to <code>xs:anySimpleType</code> is not permitted and raises a static error: [<a href="https://www.w3.org/TR/xpath20/#ERRXPST0080" title="err:XPST0080">err:XPST0080</a>]<sup><small>XP</small></sup>.</p><p>Similarly, casting is not supported to or from <code>xs:anyAtomicType</code> and will raise a static error: [<a href="https://www.w3.org/TR/xpath20/#ERRXPST0080" title="err:XPST0080">err:XPST0080</a>]<sup><small>XP</small></sup>. There are no atomic items with the type annotation <code>xs:anyAtomicType</code>, although this can be a statically inferred type.</p><div class="_diffs div2"><h3><a id="casting-from-primitive-to-primitive"></a><span class="deltaxml-old" style="background:#FF5555">23.1</span><span class="deltaxml-new" style="background:#90EE90">24.1</span> <a href="#casting-from-primitive-to-primitive" style="text-decoration: none">Casting from primitive types to primitive types</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#casting-date-time-to-string">next</a> | <a href="#id-constructors-for-record-tests">previous</a>)</p><ol><li><p> This section now uses the term <b>primitive type</b> strictly to refer to the 20 atomic types that are not derived by restriction from another atomic type: that is, the 19 primitive atomic types defined in XSD, plus <code>xs:untypedAtomic</code>. The three types <code>xs:integer</code>, <code>xs:dayTimeDuration</code>, and <code>xs:yearMonthDuration</code>, which have custom casting rules but are not strictly-speaking primitive, are now handled in other subsections. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1401">1401</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1409">1409</a>]</i></p></li></ol></div><p>This section defines casting between <a title="primitive type" class="termref" href="#dt-primitive-type">primitive types</a> (specifically, the 19 primitive types defined in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> plus <code>xs:untypedAtomic</code>. The type conversions that are supported between primitive atomic types are indicated in the table below; casts between other (non-primitive) types are defined in terms of these primitives.</p><p>Where the target type <var>TT</var> is a primitive type, the result <var>TV</var> will always be an instance of <var>TT</var>. The result <span class="verb">may</span> also be an instance of a type derived from <var>TT</var>: for example casting an <code>xs:NCName</code><var>SV</var> to <code>xs:string</code><span class="verb">may</span> return <var>SV</var> unchanged, with its original type annotation.</p><p>In this table, there is a row for each <a title="primitive type" class="termref" href="#dt-primitive-type">primitive type</a> acting as the source of the conversion and there is a column for each <a title="primitive type" class="termref" href="#dt-primitive-type">primitive type</a> acting as the target of the conversion. The intersections of rows and columns contain one of three characters:</p><ul><li><p><code>Y</code> indicates that a conversion from values of the type to which the row applies to the type to which the column applies is supported;</p></li><li><p><code>N</code> indicates that there are no supported conversions from values of the type to which the row applies to the type to which the column applies;</p></li><li><p><code>M</code> indicates that a conversion from values of the type to which the row applies to the type to which the column applies may succeed for some values in the value space and fail for others.</p></li></ul><p><span style="display: none;" class="delete_version">There is no row or column for <code>xs:untypedAtomic</code> because the casting rules are exactly the same as for <code>xs:string</code>. When casting from <code>xs:string</code> or <code>xs:untypedAtomic</code> the semantics in <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a> apply, regardless of target type. </span><span style="display: none;" class="add_version">There is no row or column for <code>xs:untypedAtomic</code> because the casting rules are exactly the same as for <code>xs:string</code>. When casting from <code>xs:string</code> or <code>xs:untypedAtomic</code> the semantics in <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a> apply, regardless of target type. </span><span class="modify_version">There is no row or column for <code>xs:untypedAtomic</code> because the casting rules are exactly the same as for <code>xs:string</code>. When casting from <code>xs:string</code> or <code>xs:untypedAtomic</code> the semantics in <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a> apply, regardless of target type. </span></p><p><a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> defines <code>xs:NOTATION</code> as an abstract type. Thus, casting to <code>xs:NOTATION</code> from any other type including <code>xs:NOTATION</code> is not permitted and raises a static error [<a href="https://www.w3.org/TR/xpath20/#ERRXPST0080" title="err:XPST0080">err:XPST0080</a>]<sup><small>XP</small></sup>. However, casting from one subtype of <code>xs:NOTATION</code> to another subtype of <code>xs:NOTATION</code> is permitted.</p><p>Casting is not supported to or from <code>xs:anySimpleType</code>. Thus, there is no row or column for this type in the table below. For any node that has not been validated or has been validated as <code>xs:anySimpleType</code>, the typed value of the node is an atomic item of type <code>xs:untypedAtomic</code>. There are no atomic items with the type annotation <code>xs:anySimpleType</code> at runtime. Casting to <code>xs:anySimpleType</code> is not permitted and raises a static error: [<a href="https://www.w3.org/TR/xpath20/#ERRXPST0080" title="err:XPST0080">err:XPST0080</a>]<sup><small>XP</small></sup>.</p><p>Similarly, casting is not supported to or from <code>xs:anyAtomicType</code> and will raise a static error: [<a href="https://www.w3.org/TR/xpath20/#ERRXPST0080" title="err:XPST0080">err:XPST0080</a>]<sup><small>XP</small></sup>. There are no atomic items with the type annotation <code>xs:anyAtomicType</code> at runtime, although this can be a statically inferred type.</p><p>If casting is attempted from an <em>ST</em> to a <em>TT</em> for which casting is not supported, as defined in the table below, a type error is raised [<a href="https://www.w3.org/TR/xpath20/#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]<sup><small>XP</small></sup>.</p><p>In the following table, the columns and rows are identified by short codes that identify simple types as follows:</p><blockquote><p>aURI = xs:anyURI<br>b64 = xs:base64Binary<br>bool = xs:boolean<br>dat = xs:date<br>gDay = xs:gDay<br>dbl = xs:double<br>dec = xs:decimal<br>dT = xs:dateTime<br>dur = xs:duration<br>flt = xs:float<br>hxB = xs:hexBinary<br>gMD = xs:gMonthDay<br>gMon = xs:gMonth<br>NOT = xs:NOTATION<br>QN = xs:QName<br>str = xs:string<br>tim = xs:time<br>gYM = xs:gYearMonth<br>gYr = xs:gYear</p></blockquote><p>In the following table, the notation “S\T” indicates that the source (“S”) of the conversion is indicated in the column below the notation and that the target (“T”) is indicated in the row to the right of the notation.</p><table class="casting" style="border:1px solid; padding:1px"><thead><tr><th><span class="cancast" title="S\T">S\T</span></th><th><span class="cancast" title="string">str</span></th><th><span class="cancast" title="float">flt</span></th><th><span class="cancast" title="double">dbl</span></th><th><span class="cancast" title="decimal">dec</span></th><th><span class="cancast" title="duration">dur</span></th><th><span class="cancast" title="dateTime">dT</span></th><th><span class="cancast" title="time">tim</span></th><th><span class="cancast" title="date">dat</span></th><th><span class="cancast" title="gYearMonth">gYM</span></th><th><span class="cancast" title="gYear">gYr</span></th><th><span class="cancast" title="gMonthDay">gMD</span></th><th><span class="cancast" title="gDay">gDay</span></th><th><span class="cancast" title="gMonth">gMon</span></th><th><span class="cancast" title="boolean">bool</span></th><th><span class="cancast" title="base64Binary">b64</span></th><th><span class="cancast" title="hexBinary">hxB</span></th><th><span class="cancast" title="anyURI">aURI</span></th><th><span class="cancast" title="QName">QN</span></th><th><span class="cancast" title="NOTATION">NOT</span></th></tr></thead><tbody><tr><th><span class="cancast" title="string">str</span></th><td class="castY"><span class="cancast" title="Cast string to string? Yes">Y</span></td><td class="castM"><span class="cancast" title="Cast string to float? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to double? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to decimal? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to duration? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to dateTime? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to time? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to date? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to gYearMonth? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to gYear? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to gMonthDay? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to gDay? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to gMonth? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to boolean? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to base64Binary? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to hexBinary? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to anyURI? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to QName? Maybe">M</span></td><td class="castM"><span class="cancast" title="Cast string to NOTATION? Maybe">M</span></td></tr><tr><th><span class="cancast" title="float">flt</span></th><td class="castY"><span class="cancast" title="Cast float to string? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast float to float? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast float to double? Yes">Y</span></td><td class="castM"><span class="cancast" title="Cast float to decimal? Maybe">M</span></td><td class="castN"><span class="cancast" title="Cast float to duration? No">N</span></td><td class="castN"><span class="cancast" title="Cast float to dateTime? No">N</span></td><td class="castN"><span class="cancast" title="Cast float to time? No">N</span></td><td class="castN"><span class="cancast" title="Cast float to date? No">N</span></td><td class="castN"><span class="cancast" title="Cast float to gYearMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast float to gYear? No">N</span></td><td class="castN"><span class="cancast" title="Cast float to gMonthDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast float to gDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast float to gMonth? No">N</span></td><td class="castY"><span class="cancast" title="Cast float to boolean? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast float to base64Binary? No">N</span></td><td class="castN"><span class="cancast" title="Cast float to hexBinary? No">N</span></td><td class="castN"><span class="cancast" title="Cast float to anyURI? No">N</span></td><td class="castN"><span class="cancast" title="Cast float to QName? No">N</span></td><td class="castN"><span class="cancast" title="Cast float to NOTATION? No">N</span></td></tr><tr><th><span class="cancast" title="double">dbl</span></th><td class="castY"><span class="cancast" title="Cast double to string? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast double to float? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast double to double? Yes">Y</span></td><td class="castM"><span class="cancast" title="Cast double to decimal? Maybe">M</span></td><td class="castN"><span class="cancast" title="Cast double to duration? No">N</span></td><td class="castN"><span class="cancast" title="Cast double to dateTime? No">N</span></td><td class="castN"><span class="cancast" title="Cast double to time? No">N</span></td><td class="castN"><span class="cancast" title="Cast double to date? No">N</span></td><td class="castN"><span class="cancast" title="Cast double to gYearMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast double to gYear? No">N</span></td><td class="castN"><span class="cancast" title="Cast double to gMonthDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast double to gDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast double to gMonth? No">N</span></td><td class="castY"><span class="cancast" title="Cast double to boolean? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast double to base64Binary? No">N</span></td><td class="castN"><span class="cancast" title="Cast double to hexBinary? No">N</span></td><td class="castN"><span class="cancast" title="Cast double to anyURI? No">N</span></td><td class="castN"><span class="cancast" title="Cast double to QName? No">N</span></td><td class="castN"><span class="cancast" title="Cast double to NOTATION? No">N</span></td></tr><tr><th><span class="cancast" title="decimal">dec</span></th><td class="castY"><span class="cancast" title="Cast decimal to string? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast decimal to float? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast decimal to double? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast decimal to decimal? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast decimal to duration? No">N</span></td><td class="castN"><span class="cancast" title="Cast decimal to dateTime? No">N</span></td><td class="castN"><span class="cancast" title="Cast decimal to time? No">N</span></td><td class="castN"><span class="cancast" title="Cast decimal to date? No">N</span></td><td class="castN"><span class="cancast" title="Cast decimal to gYearMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast decimal to gYear? No">N</span></td><td class="castN"><span class="cancast" title="Cast decimal to gMonthDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast decimal to gDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast decimal to gMonth? No">N</span></td><td class="castY"><span class="cancast" title="Cast decimal to boolean? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast decimal to base64Binary? No">N</span></td><td class="castN"><span class="cancast" title="Cast decimal to hexBinary? No">N</span></td><td class="castN"><span class="cancast" title="Cast decimal to anyURI? No">N</span></td><td class="castN"><span class="cancast" title="Cast decimal to QName? No">N</span></td><td class="castN"><span class="cancast" title="Cast decimal to NOTATION? No">N</span></td></tr><tr><th><span class="cancast" title="duration">dur</span></th><td class="castY"><span class="cancast" title="Cast duration to string? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast duration to float? No">N</span></td><td class="castN"><span class="cancast" title="Cast duration to double? No">N</span></td><td class="castN"><span class="cancast" title="Cast duration to decimal? No">N</span></td><td class="castY"><span class="cancast" title="Cast duration to duration? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast duration to dateTime? No">N</span></td><td class="castN"><span class="cancast" title="Cast duration to time? No">N</span></td><td class="castN"><span class="cancast" title="Cast duration to date? No">N</span></td><td class="castN"><span class="cancast" title="Cast duration to gYearMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast duration to gYear? No">N</span></td><td class="castN"><span class="cancast" title="Cast duration to gMonthDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast duration to gDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast duration to gMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast duration to boolean? No">N</span></td><td class="castN"><span class="cancast" title="Cast duration to base64Binary? No">N</span></td><td class="castN"><span class="cancast" title="Cast duration to hexBinary? No">N</span></td><td class="castN"><span class="cancast" title="Cast duration to anyURI? No">N</span></td><td class="castN"><span class="cancast" title="Cast duration to QName? No">N</span></td><td class="castN"><span class="cancast" title="Cast duration to NOTATION? No">N</span></td></tr><tr><th><span class="cancast" title="dateTime">dT</span></th><td class="castY"><span class="cancast" title="Cast dateTime to string? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast dateTime to float? No">N</span></td><td class="castN"><span class="cancast" title="Cast dateTime to double? No">N</span></td><td class="castN"><span class="cancast" title="Cast dateTime to decimal? No">N</span></td><td class="castN"><span class="cancast" title="Cast dateTime to duration? No">N</span></td><td class="castY"><span class="cancast" title="Cast dateTime to dateTime? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast dateTime to time? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast dateTime to date? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast dateTime to gYearMonth? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast dateTime to gYear? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast dateTime to gMonthDay? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast dateTime to gDay? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast dateTime to gMonth? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast dateTime to boolean? No">N</span></td><td class="castN"><span class="cancast" title="Cast dateTime to base64Binary? No">N</span></td><td class="castN"><span class="cancast" title="Cast dateTime to hexBinary? No">N</span></td><td class="castN"><span class="cancast" title="Cast dateTime to anyURI? No">N</span></td><td class="castN"><span class="cancast" title="Cast dateTime to QName? No">N</span></td><td class="castN"><span class="cancast" title="Cast dateTime to NOTATION? No">N</span></td></tr><tr><th><span class="cancast" title="time">tim</span></th><td class="castY"><span class="cancast" title="Cast time to string? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast time to float? No">N</span></td><td class="castN"><span class="cancast" title="Cast time to double? No">N</span></td><td class="castN"><span class="cancast" title="Cast time to decimal? No">N</span></td><td class="castN"><span class="cancast" title="Cast time to duration? No">N</span></td><td class="castN"><span class="cancast" title="Cast time to dateTime? No">N</span></td><td class="castY"><span class="cancast" title="Cast time to time? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast time to date? No">N</span></td><td class="castN"><span class="cancast" title="Cast time to gYearMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast time to gYear? No">N</span></td><td class="castN"><span class="cancast" title="Cast time to gMonthDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast time to gDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast time to gMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast time to boolean? No">N</span></td><td class="castN"><span class="cancast" title="Cast time to base64Binary? No">N</span></td><td class="castN"><span class="cancast" title="Cast time to hexBinary? No">N</span></td><td class="castN"><span class="cancast" title="Cast time to anyURI? No">N</span></td><td class="castN"><span class="cancast" title="Cast time to QName? No">N</span></td><td class="castN"><span class="cancast" title="Cast time to NOTATION? No">N</span></td></tr><tr><th><span class="cancast" title="date">dat</span></th><td class="castY"><span class="cancast" title="Cast date to string? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast date to float? No">N</span></td><td class="castN"><span class="cancast" title="Cast date to double? No">N</span></td><td class="castN"><span class="cancast" title="Cast date to decimal? No">N</span></td><td class="castN"><span class="cancast" title="Cast date to duration? No">N</span></td><td class="castY"><span class="cancast" title="Cast date to dateTime? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast date to time? No">N</span></td><td class="castY"><span class="cancast" title="Cast date to date? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast date to gYearMonth? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast date to gYear? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast date to gMonthDay? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast date to gDay? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast date to gMonth? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast date to boolean? No">N</span></td><td class="castN"><span class="cancast" title="Cast date to base64Binary? No">N</span></td><td class="castN"><span class="cancast" title="Cast date to hexBinary? No">N</span></td><td class="castN"><span class="cancast" title="Cast date to anyURI? No">N</span></td><td class="castN"><span class="cancast" title="Cast date to QName? No">N</span></td><td class="castN"><span class="cancast" title="Cast date to NOTATION? No">N</span></td></tr><tr><th><span class="cancast" title="gYearMonth">gYM</span></th><td class="castY"><span class="cancast" title="Cast gYearMonth to string? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to float? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to double? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to decimal? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to duration? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to dateTime? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to time? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to date? No">N</span></td><td class="castY"><span class="cancast" title="Cast gYearMonth to gYearMonth? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to gYear? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to gMonthDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to gDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to gMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to boolean? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to base64Binary? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to hexBinary? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to anyURI? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to QName? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYearMonth to NOTATION? No">N</span></td></tr><tr><th><span class="cancast" title="gYear">gYr</span></th><td class="castY"><span class="cancast" title="Cast gYear to string? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast gYear to float? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYear to double? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYear to decimal? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYear to duration? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYear to dateTime? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYear to time? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYear to date? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYear to gYearMonth? No">N</span></td><td class="castY"><span class="cancast" title="Cast gYear to gYear? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast gYear to gMonthDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYear to gDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYear to gMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYear to boolean? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYear to base64Binary? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYear to hexBinary? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYear to anyURI? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYear to QName? No">N</span></td><td class="castN"><span class="cancast" title="Cast gYear to NOTATION? No">N</span></td></tr><tr><th><span class="cancast" title="gMonthDay">gMD</span></th><td class="castY"><span class="cancast" title="Cast gMonthDay to string? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to float? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to double? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to decimal? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to duration? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to dateTime? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to time? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to date? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to gYearMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to gYear? No">N</span></td><td class="castY"><span class="cancast" title="Cast gMonthDay to gMonthDay? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to gDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to gMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to boolean? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to base64Binary? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to hexBinary? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to anyURI? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to QName? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonthDay to NOTATION? No">N</span></td></tr><tr><th><span class="cancast" title="gDay">gDay</span></th><td class="castY"><span class="cancast" title="Cast gDay to string? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast gDay to float? No">N</span></td><td class="castN"><span class="cancast" title="Cast gDay to double? No">N</span></td><td class="castN"><span class="cancast" title="Cast gDay to decimal? No">N</span></td><td class="castN"><span class="cancast" title="Cast gDay to duration? No">N</span></td><td class="castN"><span class="cancast" title="Cast gDay to dateTime? No">N</span></td><td class="castN"><span class="cancast" title="Cast gDay to time? No">N</span></td><td class="castN"><span class="cancast" title="Cast gDay to date? No">N</span></td><td class="castN"><span class="cancast" title="Cast gDay to gYearMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast gDay to gYear? No">N</span></td><td class="castN"><span class="cancast" title="Cast gDay to gMonthDay? No">N</span></td><td class="castY"><span class="cancast" title="Cast gDay to gDay? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast gDay to gMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast gDay to boolean? No">N</span></td><td class="castN"><span class="cancast" title="Cast gDay to base64Binary? No">N</span></td><td class="castN"><span class="cancast" title="Cast gDay to hexBinary? No">N</span></td><td class="castN"><span class="cancast" title="Cast gDay to anyURI? No">N</span></td><td class="castN"><span class="cancast" title="Cast gDay to QName? No">N</span></td><td class="castN"><span class="cancast" title="Cast gDay to NOTATION? No">N</span></td></tr><tr><th><span class="cancast" title="gMonth">gMon</span></th><td class="castY"><span class="cancast" title="Cast gMonth to string? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast gMonth to float? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonth to double? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonth to decimal? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonth to duration? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonth to dateTime? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonth to time? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonth to date? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonth to gYearMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonth to gYear? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonth to gMonthDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonth to gDay? No">N</span></td><td class="castY"><span class="cancast" title="Cast gMonth to gMonth? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast gMonth to boolean? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonth to base64Binary? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonth to hexBinary? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonth to anyURI? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonth to QName? No">N</span></td><td class="castN"><span class="cancast" title="Cast gMonth to NOTATION? No">N</span></td></tr><tr><th><span class="cancast" title="boolean">bool</span></th><td class="castY"><span class="cancast" title="Cast boolean to string? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast boolean to float? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast boolean to double? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast boolean to decimal? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast boolean to duration? No">N</span></td><td class="castN"><span class="cancast" title="Cast boolean to dateTime? No">N</span></td><td class="castN"><span class="cancast" title="Cast boolean to time? No">N</span></td><td class="castN"><span class="cancast" title="Cast boolean to date? No">N</span></td><td class="castN"><span class="cancast" title="Cast boolean to gYearMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast boolean to gYear? No">N</span></td><td class="castN"><span class="cancast" title="Cast boolean to gMonthDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast boolean to gDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast boolean to gMonth? No">N</span></td><td class="castY"><span class="cancast" title="Cast boolean to boolean? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast boolean to base64Binary? No">N</span></td><td class="castN"><span class="cancast" title="Cast boolean to hexBinary? No">N</span></td><td class="castN"><span class="cancast" title="Cast boolean to anyURI? No">N</span></td><td class="castN"><span class="cancast" title="Cast boolean to QName? No">N</span></td><td class="castN"><span class="cancast" title="Cast boolean to NOTATION? No">N</span></td></tr><tr><th><span class="cancast" title="base64Binary">b64</span></th><td class="castY"><span class="cancast" title="Cast base64Binary to string? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast base64Binary to float? No">N</span></td><td class="castN"><span class="cancast" title="Cast base64Binary to double? No">N</span></td><td class="castN"><span class="cancast" title="Cast base64Binary to decimal? No">N</span></td><td class="castN"><span class="cancast" title="Cast base64Binary to duration? No">N</span></td><td class="castN"><span class="cancast" title="Cast base64Binary to dateTime? No">N</span></td><td class="castN"><span class="cancast" title="Cast base64Binary to time? No">N</span></td><td class="castN"><span class="cancast" title="Cast base64Binary to date? No">N</span></td><td class="castN"><span class="cancast" title="Cast base64Binary to gYearMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast base64Binary to gYear? No">N</span></td><td class="castN"><span class="cancast" title="Cast base64Binary to gMonthDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast base64Binary to gDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast base64Binary to gMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast base64Binary to boolean? No">N</span></td><td class="castY"><span class="cancast" title="Cast base64Binary to base64Binary? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast base64Binary to hexBinary? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast base64Binary to anyURI? No">N</span></td><td class="castN"><span class="cancast" title="Cast base64Binary to QName? No">N</span></td><td class="castN"><span class="cancast" title="Cast base64Binary to NOTATION? No">N</span></td></tr><tr><th><span class="cancast" title="hexBinary">hxB</span></th><td class="castY"><span class="cancast" title="Cast hexBinary to string? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast hexBinary to float? No">N</span></td><td class="castN"><span class="cancast" title="Cast hexBinary to double? No">N</span></td><td class="castN"><span class="cancast" title="Cast hexBinary to decimal? No">N</span></td><td class="castN"><span class="cancast" title="Cast hexBinary to duration? No">N</span></td><td class="castN"><span class="cancast" title="Cast hexBinary to dateTime? No">N</span></td><td class="castN"><span class="cancast" title="Cast hexBinary to time? No">N</span></td><td class="castN"><span class="cancast" title="Cast hexBinary to date? No">N</span></td><td class="castN"><span class="cancast" title="Cast hexBinary to gYearMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast hexBinary to gYear? No">N</span></td><td class="castN"><span class="cancast" title="Cast hexBinary to gMonthDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast hexBinary to gDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast hexBinary to gMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast hexBinary to boolean? No">N</span></td><td class="castY"><span class="cancast" title="Cast hexBinary to base64Binary? Yes">Y</span></td><td class="castY"><span class="cancast" title="Cast hexBinary to hexBinary? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast hexBinary to anyURI? No">N</span></td><td class="castN"><span class="cancast" title="Cast hexBinary to QName? No">N</span></td><td class="castN"><span class="cancast" title="Cast hexBinary to NOTATION? No">N</span></td></tr><tr><th><span class="cancast" title="anyURI">aURI</span></th><td class="castY"><span class="cancast" title="Cast anyURI to string? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast anyURI to float? No">N</span></td><td class="castN"><span class="cancast" title="Cast anyURI to double? No">N</span></td><td class="castN"><span class="cancast" title="Cast anyURI to decimal? No">N</span></td><td class="castN"><span class="cancast" title="Cast anyURI to duration? No">N</span></td><td class="castN"><span class="cancast" title="Cast anyURI to dateTime? No">N</span></td><td class="castN"><span class="cancast" title="Cast anyURI to time? No">N</span></td><td class="castN"><span class="cancast" title="Cast anyURI to date? No">N</span></td><td class="castN"><span class="cancast" title="Cast anyURI to gYearMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast anyURI to gYear? No">N</span></td><td class="castN"><span class="cancast" title="Cast anyURI to gMonthDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast anyURI to gDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast anyURI to gMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast anyURI to boolean? No">N</span></td><td class="castN"><span class="cancast" title="Cast anyURI to base64Binary? No">N</span></td><td class="castN"><span class="cancast" title="Cast anyURI to hexBinary? No">N</span></td><td class="castY"><span class="cancast" title="Cast anyURI to anyURI? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast anyURI to QName? No">N</span></td><td class="castN"><span class="cancast" title="Cast anyURI to NOTATION? No">N</span></td></tr><tr><th><span class="cancast" title="QName">QN</span></th><td class="castY"><span class="cancast" title="Cast QName to string? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast QName to float? No">N</span></td><td class="castN"><span class="cancast" title="Cast QName to double? No">N</span></td><td class="castN"><span class="cancast" title="Cast QName to decimal? No">N</span></td><td class="castN"><span class="cancast" title="Cast QName to duration? No">N</span></td><td class="castN"><span class="cancast" title="Cast QName to dateTime? No">N</span></td><td class="castN"><span class="cancast" title="Cast QName to time? No">N</span></td><td class="castN"><span class="cancast" title="Cast QName to date? No">N</span></td><td class="castN"><span class="cancast" title="Cast QName to gYearMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast QName to gYear? No">N</span></td><td class="castN"><span class="cancast" title="Cast QName to gMonthDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast QName to gDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast QName to gMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast QName to boolean? No">N</span></td><td class="castN"><span class="cancast" title="Cast QName to base64Binary? No">N</span></td><td class="castN"><span class="cancast" title="Cast QName to hexBinary? No">N</span></td><td class="castN"><span class="cancast" title="Cast QName to anyURI? No">N</span></td><td class="castY"><span class="cancast" title="Cast QName to QName? Yes">Y</span></td><td class="castM"><span class="cancast" title="Cast QName to NOTATION? Maybe">M</span></td></tr><tr><th><span class="cancast" title="NOTATION">NOT</span></th><td class="castY"><span class="cancast" title="Cast NOTATION to string? Yes">Y</span></td><td class="castN"><span class="cancast" title="Cast NOTATION to float? No">N</span></td><td class="castN"><span class="cancast" title="Cast NOTATION to double? No">N</span></td><td class="castN"><span class="cancast" title="Cast NOTATION to decimal? No">N</span></td><td class="castN"><span class="cancast" title="Cast NOTATION to duration? No">N</span></td><td class="castN"><span class="cancast" title="Cast NOTATION to dateTime? No">N</span></td><td class="castN"><span class="cancast" title="Cast NOTATION to time? No">N</span></td><td class="castN"><span class="cancast" title="Cast NOTATION to date? No">N</span></td><td class="castN"><span class="cancast" title="Cast NOTATION to gYearMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast NOTATION to gYear? No">N</span></td><td class="castN"><span class="cancast" title="Cast NOTATION to gMonthDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast NOTATION to gDay? No">N</span></td><td class="castN"><span class="cancast" title="Cast NOTATION to gMonth? No">N</span></td><td class="castN"><span class="cancast" title="Cast NOTATION to boolean? No">N</span></td><td class="castN"><span class="cancast" title="Cast NOTATION to base64Binary? No">N</span></td><td class="castN"><span class="cancast" title="Cast NOTATION to hexBinary? No">N</span></td><td class="castN"><span class="cancast" title="Cast NOTATION to anyURI? No">N</span></td><td class="castY"><span class="cancast" title="Cast NOTATION to QName? Yes">Y</span></td><td class="castM"><span class="cancast" title="Cast NOTATION to NOTATION? Maybe">M</span></td></tr></tbody></table><div class="_diffs div3"><h4><a id="casting-to-untypedAtomic"></a><span class="deltaxml-old" style="background:#FF5555">23.1.1</span><span class="deltaxml-new" style="background:#90EE90">24.1.1</span> <a href="#casting-to-untypedAtomic" style="text-decoration: none">Casting to <code>xs:untypedAtomic</code></a></h4><p>Any atomic item <var>SV</var> can be cast to <code>xs:untypedAtomic</code>.</p><p><span style="display: none;" class="delete_version">The effect is the same as casting to <code>xs:string</code> (see <a href="#casting-to-string"><span class="delete_version"><b>23.1.2 Casting to xs:string</b></span><span class="modify_version"><b>23.1.2 Casting to xs:string</b></span></a>) and then returning the <code>xs:untypedAtomic</code> value comprising the same sequence of characters.</span><span style="display: none;" class="add_version">The effect is the same as casting to <code>xs:string</code> (see <a href="#casting-to-string"><span class="add_version"><b>24.1.2 Casting to xs:string</b></span><span class="modify_version"><b>24.1.2 Casting to xs:string</b></span></a>) and then returning the <code>xs:untypedAtomic</code> value comprising the same sequence of characters.</span><span class="modify_version">The effect is the same as casting to <code>xs:string</code> (see <a href="#casting-to-string"><span style="display: none;" class="delete_version"><b>23.1.2 Casting to xs:string</b></span><span style="display: none;" class="add_version"><b>24.1.2 Casting to xs:string</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.1.2</span><span class="deltaxml-new" style="background:#90EE90">24.1.2</span> Casting to xs:string</b></span></a>) and then returning the <code>xs:untypedAtomic</code> value comprising the same sequence of characters.</span></p></div><div class="_diffs div3"><h4><a id="casting-to-string"></a><span class="deltaxml-old" style="background:#FF5555">23.1.2</span><span class="deltaxml-new" style="background:#90EE90">24.1.2</span> <a href="#casting-to-string" style="text-decoration: none">Casting to <code>xs:string</code></a></h4><p>Any atomic item <var>SV</var> can be cast to <code>xs:string</code>.</p><p>The resulting <code>xs:string</code> value <var>TV</var> depends on the source type <var>ST</var> as follows.</p><ul><li><p>If <var>SV</var> is an instance of <code>xs:string</code>, <var>TV</var> is an instance of <code>xs:string</code> comprising the same sequence of characters as <var>SV</var>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The implementation is free to return <var>SV</var> unchanged, including its original type annotation.</p></div></li><li><p>If <var>SV</var> is an instance of <code>xs:anyURI</code>, the result <var>TV</var> is an instance of <code>xs:string</code> comprising the same sequence of characters as <var>SV</var>, but with a type annotation of <code>xs:anyURI</code>. No escaping of special characters takes place.</p></li><li><p>If <var>SV</var> is an instance of <code>xs:QName</code> or <code>xs:NOTATION</code>:</p><ul><li><p>if the qualified name has a prefix, then <var>TV</var> is the concatenation of the prefix of <var>SV</var>, a single colon (:), and the local name of <var>SV</var>.</p></li><li><p>otherwise <var>TV</var> is the local name of <var>SV</var>.</p></li></ul></li><li><p><span style="display: none;" class="delete_version">If <var>SV</var> is an instance of <code>xs:numeric</code>, the rules in <a href="#casting-numeric-to-string"><span class="delete_version"><b>23.1.2.1 Casting numeric values to xs:string</b></span><span class="modify_version"><b>23.1.2.1 Casting numeric values to xs:string</b></span></a> apply.</span><span style="display: none;" class="add_version">If <var>SV</var> is an instance of <code>xs:numeric</code>, the rules in <a href="#casting-numeric-to-string"><span class="add_version"><b>24.1.2.1 Casting numeric values to xs:string</b></span><span class="modify_version"><b>24.1.2.1 Casting numeric values to xs:string</b></span></a> apply.</span><span class="modify_version">If <var>SV</var> is an instance of <code>xs:numeric</code>, the rules in <a href="#casting-numeric-to-string"><span style="display: none;" class="delete_version"><b>23.1.2.1 Casting numeric values to xs:string</b></span><span style="display: none;" class="add_version"><b>24.1.2.1 Casting numeric values to xs:string</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.1.2.1</span><span class="deltaxml-new" style="background:#90EE90">24.1.2.1</span> Casting numeric values to xs:string</b></span></a> apply.</span></p></li><li><p><span style="display: none;" class="delete_version">If <var>SV</var> is an instance of <code>xs:dateTime</code>, <code>xs:date</code> or <code>xs:time</code>, the rules in <a href="#casting-date-time-to-string"><span class="delete_version"><b>23.1.2.2 Casting date/time values to xs:string</b></span><span class="modify_version"><b>23.1.2.2 Casting date/time values to xs:string</b></span></a> apply. </span><span style="display: none;" class="add_version">If <var>SV</var> is an instance of <code>xs:dateTime</code>, <code>xs:date</code> or <code>xs:time</code>, the rules in <a href="#casting-date-time-to-string"><span class="add_version"><b>24.1.2.2 Casting date/time values to xs:string</b></span><span class="modify_version"><b>24.1.2.2 Casting date/time values to xs:string</b></span></a> apply. </span><span class="modify_version">If <var>SV</var> is an instance of <code>xs:dateTime</code>, <code>xs:date</code> or <code>xs:time</code>, the rules in <a href="#casting-date-time-to-string"><span style="display: none;" class="delete_version"><b>23.1.2.2 Casting date/time values to xs:string</b></span><span style="display: none;" class="add_version"><b>24.1.2.2 Casting date/time values to xs:string</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.1.2.2</span><span class="deltaxml-new" style="background:#90EE90">24.1.2.2</span> Casting date/time values to xs:string</b></span></a> apply. </span></p></li><li><p><span style="display: none;" class="delete_version">If <var>ST</var> is <code>xs:duration</code>, or any subtype thereof including <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code>, then the rules in <a href="#casting-duration-to-string"><span class="delete_version"><b>23.1.2.3 Casting xs:duration values to xs:string</b></span><span class="modify_version"><b>23.1.2.3 Casting xs:duration values to xs:string</b></span></a> apply.</span><span style="display: none;" class="add_version">If <var>ST</var> is <code>xs:duration</code>, or any subtype thereof including <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code>, then the rules in <a href="#casting-duration-to-string"><span class="add_version"><b>24.1.2.3 Casting xs:duration values to xs:string</b></span><span class="modify_version"><b>24.1.2.3 Casting xs:duration values to xs:string</b></span></a> apply.</span><span class="modify_version">If <var>ST</var> is <code>xs:duration</code>, or any subtype thereof including <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code>, then the rules in <a href="#casting-duration-to-string"><span style="display: none;" class="delete_version"><b>23.1.2.3 Casting xs:duration values to xs:string</b></span><span style="display: none;" class="add_version"><b>24.1.2.3 Casting xs:duration values to xs:string</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.1.2.3</span><span class="deltaxml-new" style="background:#90EE90">24.1.2.3</span> Casting xs:duration values to xs:string</b></span></a> apply.</span></p></li><li><p>In all other cases, <var>TV</var> is the <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> canonical representation of <var>SV</var>. For datatypes that do not have a canonical representation defined an <a title="implementation-dependent" class="termref" href="#implementation-dependent">implementation-dependent</a> canonical representation may be used.</p></li></ul><p>To cast as <code>xs:untypedAtomic</code> the value is cast as <code>xs:string</code>, as described above, and the type annotation changed to <code>xs:untypedAtomic</code>.</p><div class="_diffs div4"><h5><a id="casting-numeric-to-string"></a><span class="deltaxml-old" style="background:#FF5555">23.1.2.1</span><span class="deltaxml-new" style="background:#90EE90">24.1.2.1</span> <a href="#casting-numeric-to-string" style="text-decoration: none">Casting numeric values to <code>xs:string</code></a></h5><p>The following rules apply when the source type <var>ST</var> is <code>xs:decimal</code>, <code>xs:double</code>, or <code>xs:float</code>, or any subtype of these including <code>xs:integer</code>.</p><ol class="enumar"><li><p>If <var>SV</var> is an instance of <code>xs:decimal</code>, then the canonical representation of <var>SV</var> is returned, as defined in <a href="#xmlschema11-2">[XSD 1.1 Part 2]</a>. Specifically, see <a href="https://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/datatypes.html#f-decimalCanmap">decimalCanonicalMap</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Unlike previous versions of this specification, no special rule is given for the case where <var>SV</var> is an instance of <code>xs:integer</code>. This is because the general rule for <code>xs:decimal</code> gives the same result. The result in this case will be a sequence of decimal digits in the range <span class="unicode-codepoint">U+0030</span> (<span class="unicode-name">DIGIT ZERO</span>, <code>0</code>) to <span class="unicode-codepoint">U+0039</span> (<span class="unicode-name">DIGIT NINE</span>, <code>9</code>) , optionally preceded by a minus sign, with no leading zeroes. For example: <code>42</code>, <code>-1</code>, <code>0</code>, or <code>1000000000</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>An <code>xs:decimal</code> that is equal to an integer is converted to a string as if it were first cast to an <code>xs:integer</code>. Specifically, there will be no decimal point and no fractional part.</p><p>If the value is not equal to an integer, then there will be a decimal point and a fractional part, which will be a sequence of decimal digits with no trailing zeroes. For example: <code>42.3</code>, <code>-1.5</code>, or <code>0.00001</code>.</p></div></li><li><p> If <var>SV</var> is an instance of <code>xs:float</code> or <code>xs:double</code>, then:</p><ol class="enumla"><li><p><span style="display: none;" class="delete_version"><var>TV</var> will be an <code>xs:string</code> in the lexical space of <code>xs:double</code> or <code>xs:float</code> that when converted to an <code>xs:double</code> or <code>xs:float</code> under the rules of <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a> produces a value that is equal to <var>SV</var>, or is <code>NaN</code> if <var>SV</var> is <code>NaN</code>. In addition, <var>TV</var> must satisfy the constraints in the following sub-bullets. </span><span style="display: none;" class="add_version"><var>TV</var> will be an <code>xs:string</code> in the lexical space of <code>xs:double</code> or <code>xs:float</code> that when converted to an <code>xs:double</code> or <code>xs:float</code> under the rules of <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a> produces a value that is equal to <var>SV</var>, or is <code>NaN</code> if <var>SV</var> is <code>NaN</code>. In addition, <var>TV</var> must satisfy the constraints in the following sub-bullets. </span><span class="modify_version"><var>TV</var> will be an <code>xs:string</code> in the lexical space of <code>xs:double</code> or <code>xs:float</code> that when converted to an <code>xs:double</code> or <code>xs:float</code> under the rules of <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a> produces a value that is equal to <var>SV</var>, or is <code>NaN</code> if <var>SV</var> is <code>NaN</code>. In addition, <var>TV</var> must satisfy the constraints in the following sub-bullets. </span></p><ol class="enumlr"><li><p>If <var>SV</var> has an absolute value that is greater than or equal to 0.000001 (one millionth) and less than 1000000 (one million), then the value is converted to an <code>xs:decimal</code> and the resulting <code>xs:decimal</code> is converted to an <code>xs:string</code> according to the rules above, as though using an implementation of <code>xs:decimal</code> that imposes no limits on the <code>totalDigits</code> or <code>fractionDigits</code> facets.</p></li><li><p>If <var>SV</var> has the value positive or negative zero, <var>TV</var> is <code>"0"</code> or <code>"-0"</code> respectively.</p></li><li><p>If <var>SV</var> is positive or negative infinity, <var>TV</var> is the string <code>"INF"</code> or <code>"-INF"</code> respectively. </p></li><li><p>In other cases, the result consists of a mantissa, which has the lexical form of an <code>xs:decimal</code>, followed by the letter "E", followed by an exponent which has the lexical form of an <code>xs:integer</code>. Leading zeroes and "+" signs are prohibited in the exponent. For the mantissa, there must be a decimal point, and there must be exactly one digit before the decimal point, which must be non-zero. The "+" sign is prohibited. There must be at least one digit after the decimal point. Apart from this mandatory digit, trailing zero digits are prohibited. </p></li></ol></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The above rules allow more than one representation of the same value. For example, the <code>xs:float</code> value whose exact decimal representation is 1.26743223E15 might be represented by any of the strings <code>"1.26743223E15"</code>, <code>"1.26743222E15"</code> or <code>"1.26743224E15"</code> (inter alia). It is implementation-dependent which of these representations is chosen.</p></div></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The string representations of numeric values are backwards compatible with XPath 1.0 except for the special values positive and negative infinity, negative zero and values outside the range <code>1.0e-6</code> to <code>1.0e+6</code>.</p></div></div><div class="_diffs div4"><h5><a id="casting-date-time-to-string"></a><span class="deltaxml-old" style="background:#FF5555">23.1.2.2</span><span class="deltaxml-new" style="background:#90EE90">24.1.2.2</span> <a href="#casting-date-time-to-string" style="text-decoration: none">Casting date/time values to <code>xs:string</code></a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#casting-duration-to-string">next</a> | <a href="#casting-from-primitive-to-primitive">previous</a>)</p><ol><li><p> The rules for conversion of dates and times to strings are now defined entirely in terms of XSD 1.1 canonical mappings, since these deliver exactly the same result as the XPath 3.1 rules. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1401">1401</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1409">1409</a>]</i></p></li></ol></div><p>If <var>SV</var> is an instance of <code>xs:dateTime</code>, <code>xs:date</code>, <code>xs:time</code>, <code>xs:gYear</code>, <code>xs:gYearMonth</code>, <code>xs:gMonth</code>, <code>xs:gMonthDay</code>, or <code>xs:gDay</code>, then <var>TV</var> is the canonical representation of <var>SV</var> as defined in <a href="#xmlschema11-2">[XSD 1.1 Part 2]</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The result <var>TV</var> includes the original timezone if a timezone is present.</p><p>All these data types contain different combinations of the components year, month, day, hour, minute, second, and timezone; all the components relevant to the data type (with the exception of the timezone) are output, and the results are concatenated together with suitable punctuation. Specifically:</p><ol class="enumar"><li><p>The <code>year</code> component is represented as a <code>xs:string</code> of four digits, or more if needed. A leading minus sign is present for BCE years.</p></li><li><p>The <code>month</code>, <code>day</code>, <code>hour</code> and <code>minute</code> components are represented as two digits (with a leading zero if needed). For example, February is represented as <code>02</code>.</p><p>The hours component will never be <code>"24"</code>: midnight is always represented as <code>"00:00:00"</code>.</p></li><li><p>The <code>second</code> component is output using as a two-digit integer if it is a whole number (for example, <code>30</code>, <code>05</code>, or <code>00</code>), or if it is fractional, as two digits followed by a decimal point followed by as many digits as are necessary, with no trailing zeroes (for example <code>30.5</code> or <code>00.001</code>). </p></li><li><p><span style="display: none;" class="delete_version">The timezone component, if present, is cast to <code>xs:string</code> by applying the function <code>eg:convertTZtoString</code> given in <a href="#casting-to-datetimes"><span class="delete_version"><b>23.1.5 Casting to date and time types</b></span><span class="modify_version"><b>23.1.5 Casting to date and time types</b></span></a>. Examples are <code>Z</code>, <code>+01:00</code>, <code>-05:00</code>, or <code>+05:30</code>.</span><span style="display: none;" class="add_version">The timezone component, if present, is cast to <code>xs:string</code> by applying the function <code>eg:convertTZtoString</code> given in <a href="#casting-to-datetimes"><span class="add_version"><b>24.1.5 Casting to date and time types</b></span><span class="modify_version"><b>24.1.5 Casting to date and time types</b></span></a>. Examples are <code>Z</code>, <code>+01:00</code>, <code>-05:00</code>, or <code>+05:30</code>.</span><span class="modify_version">The timezone component, if present, is cast to <code>xs:string</code> by applying the function <code>eg:convertTZtoString</code> given in <a href="#casting-to-datetimes"><span style="display: none;" class="delete_version"><b>23.1.5 Casting to date and time types</b></span><span style="display: none;" class="add_version"><b>24.1.5 Casting to date and time types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.1.5</span><span class="deltaxml-new" style="background:#90EE90">24.1.5</span> Casting to date and time types</b></span></a>. Examples are <code>Z</code>, <code>+01:00</code>, <code>-05:00</code>, or <code>+05:30</code>.</span></p></li></ol><p>. </p></div></div><div class="_diffs div4"><h5><a id="casting-duration-to-string"></a><span class="deltaxml-old" style="background:#FF5555">23.1.2.3</span><span class="deltaxml-new" style="background:#90EE90">24.1.2.3</span> <a href="#casting-duration-to-string" style="text-decoration: none">Casting <code>xs:duration</code> values to <code>xs:string</code></a></h5><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#casting-from-strings">next</a> | <a href="#casting-date-time-to-string">previous</a>)</p><ol><li><p> The rules for conversion of durations to strings are now defined entirely in terms of XSD 1.1 canonical mappings, since the XSD 1.1 rules deliver exactly the same result as the XPath 3.1 rules. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1401">1401</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1409">1409</a>]</i></p></li></ol></div><p>If <var>SV</var> is an instance of <code>xs:duration</code> (including its subtypes <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code>), then <var>TV</var> is the canonical representation of <var>SV</var> as defined in <a href="#xmlschema11-2">[XSD 1.1 Part 2]</a>. Specifically, see <a href="https://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/datatypes.html#f-durationCanMap">durationCanonicalMap</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The rules have the effect of normalizing the value so that the number of months is always less than 12, the number of hours less than 24, and the number of minutes and seconds less than 60. Zero-valued components are omitted. Fractional seconds follow the same rules as <code>xs:decimal</code>. For example, the duration <code>P15MT30H</code> is represented as <code>P1Y3M1DT6H</code>. A zero-length duration is output as <code>PT0S</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>At the time of writing, the published XSD 1.1 recommendation contains cut-and-paste errors in the definition of the <code>dayTimeDuration</code> canonical mapping. The binding of variable <var>s</var> should be to <var>dt</var>'s <code>·seconds·</code> (not <code>·months·</code>) component, and the return expression given as <code>sgn &amp; 'P' &amp; ·duYearMonthCanonicalFragmentMap·(|s|)</code> should read <code>sgn &amp; 'P' &amp; ·duDayTimeCanonicalFragmentMap·(|s|)</code></p><p>In reading these XSD formulations, be aware that <code>a &amp; b</code> represents string concatenation, while <code>|s|</code> computes the absolute value of a number.</p></div></div></div><div class="_diffs div3"><h4><a id="casting-to-numerics"></a><span class="deltaxml-old" style="background:#FF5555">23.1.3</span><span class="deltaxml-new" style="background:#90EE90">24.1.3</span> <a href="#casting-to-numerics" style="text-decoration: none">Casting to numeric types</a></h4><p><span style="display: none;" class="delete_version">This section defines the rules for casting to the primitive numeric types <code>xs:float</code>, <code>xs:double</code>, and <code>xs:decimal</code>. Rules for casting to the derived type <code>xs:integer</code> are given in <a href="#casting-to-integer"><span class="delete_version"><b>23.3.2 Casting to xs:integer</b></span><span class="modify_version"><b>23.3.2 Casting to xs:integer</b></span></a>.</span><span style="display: none;" class="add_version">This section defines the rules for casting to the primitive numeric types <code>xs:float</code>, <code>xs:double</code>, and <code>xs:decimal</code>. Rules for casting to the derived type <code>xs:integer</code> are given in <a href="#casting-to-integer"><span class="add_version"><b>24.3.2 Casting to xs:integer</b></span><span class="modify_version"><b>24.3.2 Casting to xs:integer</b></span></a>.</span><span class="modify_version">This section defines the rules for casting to the primitive numeric types <code>xs:float</code>, <code>xs:double</code>, and <code>xs:decimal</code>. Rules for casting to the derived type <code>xs:integer</code> are given in <a href="#casting-to-integer"><span style="display: none;" class="delete_version"><b>23.3.2 Casting to xs:integer</b></span><span style="display: none;" class="add_version"><b>24.3.2 Casting to xs:integer</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.2</span><span class="deltaxml-new" style="background:#90EE90">24.3.2</span> Casting to xs:integer</b></span></a>.</span></p><div class="_diffs div4"><h5><a id="casting-to-float"></a><span class="deltaxml-old" style="background:#FF5555">23.1.3.1</span><span class="deltaxml-new" style="background:#90EE90">24.1.3.1</span> <a href="#casting-to-float" style="text-decoration: none">Casting to xs:float</a></h5><p>When a value of any simple type is cast as <code>xs:float</code>, the <code>xs:float</code><var>TV</var> is derived from the <var>ST</var> and the <var>SV</var> as follows:</p><ul><li><p>If <var>ST</var> is <code>xs:float</code>, then <var>TV</var> is <var>SV</var> and the conversion is complete.</p></li><li><p>If <var>ST</var> is <code>xs:double</code>, then <var>TV</var> is obtained as follows: </p><ul><li><p>if <var>SV</var> is the <code>xs:double</code> value <code>INF</code>, <code>-INF</code>, <code>NaN</code>, positive zero, or negative zero, then <var>TV</var> is the <code>xs:float</code> value <code>INF</code>, <code>-INF</code>, <code>NaN</code>, positive zero, or negative zero respectively.</p></li><li><p>otherwise, <var>SV</var> can be expressed in the form <code>m × 2^e</code> where the mantissa <code>m</code> and exponent <code>e</code> are signed <code>xs:integer</code>s whose value range is defined in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a>, and the following rules apply:</p><ul><li><p>if <code>m</code> (the mantissa of <var>SV</var>) is outside the permitted range for the mantissa of an <code>xs:float</code> value <code>(-2^24-1 to +2^24-1)</code>, then it is divided by <code>2^N</code> where <code>N</code> is the lowest positive <code>xs:integer</code> that brings the result of the division within the permitted range, and the exponent <code>e</code> is increased by <code>N</code>. This is integer division (in effect, the binary value of the mantissa is truncated on the right). Let <code>M</code> be the mantissa and <code>E</code> the exponent after this adjustment.</p></li><li><p>if <code>E</code> exceeds <code>104</code> (the maximum exponent value in the value space of <code>xs:float</code>) then <var>TV</var> is the <code>xs:float</code> value <code>INF</code> or <code>-INF</code> depending on the sign of <code>M</code>.</p></li><li><p>if <code>E</code> is less than <code>-149</code> (the minimum exponent value in the value space of <code>xs:float</code>) then <var>TV</var> is the <code>xs:float</code> value positive or negative zero depending on the sign of <code>M</code></p></li><li><p>otherwise, <var>TV</var> is the <code>xs:float</code> value <code>M × 2^E</code>.</p></li></ul></li></ul></li><li><p>If <var>ST</var> is <code>xs:decimal</code>, or <code>xs:integer</code>, then <var>TV</var> is <code>xs:float(</code><var>SV</var><code> cast as xs:string)</code> and the conversion is complete.</p></li><li><p>If <var>ST</var> is <code>xs:boolean</code>, <var>SV</var> is converted to <code>1.0E0</code> if <var>SV</var> is <code>true</code> and to <code>0.0E0</code> if <var>SV</var> is <code>false</code> and the conversion is complete.</p></li><li><p><span style="display: none;" class="delete_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. </span><span style="display: none;" class="add_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. </span><span class="modify_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>. </span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>XSD 1.1 adds the value <code>+INF</code> to the lexical space, as an alternative to <code>INF</code>. XSD 1.1 also adds negative zero to the value space.</p></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>Implementations <span class="verb">should</span> return negative zero for <code>xs:float("-0.0E0")</code>. But because <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> does not distinguish between the values positive zero and negative zero. Implementations <span class="verb">may</span> return positive zero in this case.</p></div></div><div class="_diffs div4"><h5><a id="casting-to-double"></a><span class="deltaxml-old" style="background:#FF5555">23.1.3.2</span><span class="deltaxml-new" style="background:#90EE90">24.1.3.2</span> <a href="#casting-to-double" style="text-decoration: none">Casting to xs:double</a></h5><p>When a value of any simple type is cast as <code>xs:double</code>, the <code>xs:double</code> value <var>TV</var> is derived from the <var>ST</var> and the <var>SV</var> as follows:</p><ul><li><p>If <var>ST</var> is <code>xs:double</code>, then <var>TV</var> is <var>SV</var> and the conversion is complete.</p></li><li><p>If <var>ST</var> is <code>xs:float</code> or a type derived from <code>xs:float</code>, then <var>TV</var> is obtained as follows:</p><ul><li><p>if <var>SV</var> is the <code>xs:float</code> value <code>INF</code>, <code>-INF</code>, <code>NaN</code>, positive zero, or negative zero, then <var>TV</var> is the <code>xs:double</code> value <code>INF</code>, <code>-INF</code>, <code>NaN</code>, positive zero, or negative zero respectively. </p></li><li><p>otherwise, <var>SV</var> can be expressed in the form <code>m × 2^e</code> where the mantissa <code>m</code> and exponent <code>e</code> are signed <code>xs:integer</code> values whose value range is defined in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a>, and <var>TV</var> is the <code>xs:double</code> value <code>m × 2^e</code>. </p></li></ul></li><li><p>If <var>ST</var> is <code>xs:decimal</code> or <code>xs:integer</code>, then <var>TV</var> is <code>xs:double(</code><var>SV</var><code> cast as xs:string)</code> and the conversion is complete.</p></li><li><p>If <var>ST</var> is <code>xs:boolean</code>, <var>SV</var> is converted to <code>1.0E0</code> if <var>SV</var> is <code>true</code> and to <code>0.0E0</code> if <var>SV</var> is <code>false</code> and the conversion is complete.</p></li><li><p><span style="display: none;" class="delete_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span style="display: none;" class="add_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span class="modify_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>XSD 1.1 adds the value <code>+INF</code> to the lexical space, as an alternative to <code>INF</code>. XSD 1.1 also adds negative zero to the value space.</p></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>Implementations <span class="verb">should</span> return negative zero for <code>xs:double("-0.0E0")</code>. But because <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> does not distinguish between the values positive zero and negative zero. Implementations <span class="verb">may</span> return positive zero in this case.</p></div></div><div class="_diffs div4"><h5><a id="casting-to-decimal"></a><span class="deltaxml-old" style="background:#FF5555">23.1.3.3</span><span class="deltaxml-new" style="background:#90EE90">24.1.3.3</span> <a href="#casting-to-decimal" style="text-decoration: none">Casting to xs:decimal</a></h5><p><span style="display: none;" class="delete_version">This section defines the rules for casting to the primitive type <code>xs:decimal</code>. The rules are also invoked implicitly as part of the process of converting to types derived from <code>xs:decimal</code>. There are special rules, however, if the target type <var>TT</var> is <code>xs:integer</code>, or a type derived from <code>xs:integer</code>: those rules are given in <a href="#casting-to-integer"><span class="delete_version"><b>23.3.2 Casting to xs:integer</b></span><span class="modify_version"><b>23.3.2 Casting to xs:integer</b></span></a>.</span><span style="display: none;" class="add_version">This section defines the rules for casting to the primitive type <code>xs:decimal</code>. The rules are also invoked implicitly as part of the process of converting to types derived from <code>xs:decimal</code>. There are special rules, however, if the target type <var>TT</var> is <code>xs:integer</code>, or a type derived from <code>xs:integer</code>: those rules are given in <a href="#casting-to-integer"><span class="add_version"><b>24.3.2 Casting to xs:integer</b></span><span class="modify_version"><b>24.3.2 Casting to xs:integer</b></span></a>.</span><span class="modify_version">This section defines the rules for casting to the primitive type <code>xs:decimal</code>. The rules are also invoked implicitly as part of the process of converting to types derived from <code>xs:decimal</code>. There are special rules, however, if the target type <var>TT</var> is <code>xs:integer</code>, or a type derived from <code>xs:integer</code>: those rules are given in <a href="#casting-to-integer"><span style="display: none;" class="delete_version"><b>23.3.2 Casting to xs:integer</b></span><span style="display: none;" class="add_version"><b>24.3.2 Casting to xs:integer</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.2</span><span class="deltaxml-new" style="background:#90EE90">24.3.2</span> Casting to xs:integer</b></span></a>.</span></p><p>When the target type <var>TT</var> is <code>xs:decimal</code>, the resulting <code>xs:decimal</code> value <var>TV</var> is derived from <var>ST</var> and <var>SV</var> as follows: </p><ul><li><p>If <var>ST</var> is <code>xs:decimal</code> or a subtype thereof (including <code>xs:integer</code>), then the result <var>TV</var> has the same <a title="datum" class="termref" href="#dt-datum">datum</a> as <var>SV</var>. The type annotation <span class="verb">may</span> be <code>xs:decimal</code> or any subtype of <code>xs:decimal</code> for which this is a valid instance, including the original type <code>ST</code>.</p></li><li><p>If <var>ST</var> is <code>xs:float</code> or <code>xs:double</code>, then <var>TV</var> is the <code>xs:decimal</code> value, within the set of <code>xs:decimal</code> values that the implementation is capable of representing, that is numerically closest to <var>SV</var>. If two values are equally close, then the one that is closest to zero is chosen. If <var>SV</var> is too large to be accommodated as an <code>xs:decimal</code>, (see <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> for <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a> limits on numeric values) a dynamic error is raised [<a href="#ERRFOCA0001" title="err:FOCA0001">err:FOCA0001</a>]. If <var>SV</var> is one of the special <code>xs:float</code> or <code>xs:double</code> values <code>NaN</code>, <code>INF</code>, or <code>-INF</code>, a dynamic error is raised [<a href="#ERRFOCA0002" title="err:FOCA0002">err:FOCA0002</a>].</p></li><li><p>If <var>ST</var> is <code>xs:boolean</code>, the result <var>TV</var> is <code>1.0</code> if <var>SV</var> is <code>1</code> or <code>true</code> and to <code>0.0</code> if <var>SV</var> is <code>0</code> or <code>false</code>. The type annotation of the result may be any subtype of <code>xs:decimal</code> whose value space includes the integer values <code>0</code> and <code>1</code>.</p></li><li><p><span style="display: none;" class="delete_version">If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span style="display: none;" class="add_version">If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span class="modify_version">If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>.</span></p></li></ul></div></div><div class="_diffs div3"><h4><a id="casting-to-durations"></a><span class="deltaxml-old" style="background:#FF5555">23.1.4</span><span class="deltaxml-new" style="background:#90EE90">24.1.4</span> <a href="#casting-to-durations" style="text-decoration: none">Casting to duration types</a></h4><p><span style="display: none;" class="delete_version">This section defines the rules for casting to the primitive duration type <code>xs:duration</code>. Rules for casting to the derived types <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code> are given in <a href="#casting-to-duration-subtypes"><span class="delete_version"><b>23.3.3 Casting to xs:yearMonthDuration and xs:dayTimeDuration</b></span><span class="modify_version"><b>23.3.3 Casting to xs:yearMonthDuration and xs:dayTimeDuration</b></span></a>.</span><span style="display: none;" class="add_version">This section defines the rules for casting to the primitive duration type <code>xs:duration</code>. Rules for casting to the derived types <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code> are given in <a href="#casting-to-duration-subtypes"><span class="add_version"><b>24.3.3 Casting to xs:yearMonthDuration and xs:dayTimeDuration</b></span><span class="modify_version"><b>24.3.3 Casting to xs:yearMonthDuration and xs:dayTimeDuration</b></span></a>.</span><span class="modify_version">This section defines the rules for casting to the primitive duration type <code>xs:duration</code>. Rules for casting to the derived types <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code> are given in <a href="#casting-to-duration-subtypes"><span style="display: none;" class="delete_version"><b>23.3.3 Casting to xs:yearMonthDuration and xs:dayTimeDuration</b></span><span style="display: none;" class="add_version"><b>24.3.3 Casting to xs:yearMonthDuration and xs:dayTimeDuration</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.3</span><span class="deltaxml-new" style="background:#90EE90">24.3.3</span> Casting to xs:yearMonthDuration and xs:dayTimeDuration</b></span></a>.</span></p><ul><li><p>If the source value <var>SV</var> is an instance of <code>xs:duration</code> (including instances of subtypes such as <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code>, then the datum of the result <var>TV</var> is the same as the datum of <var>SV</var>, and the type annotation is <code>xs:duration</code> or any subtype thereof that includes this datum in its value space (in particular, it <span class="verb">may</span> be the same as the type annotation of <var>SV</var>).</p></li><li><p><span style="display: none;" class="delete_version">If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span style="display: none;" class="add_version">If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span class="modify_version">If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>.</span></p></li></ul></div><div class="_diffs div3"><h4><a id="casting-to-datetimes"></a><span class="deltaxml-old" style="background:#FF5555">23.1.5</span><span class="deltaxml-new" style="background:#90EE90">24.1.5</span> <a href="#casting-to-datetimes" style="text-decoration: none">Casting to date and time types</a></h4><p>In several situations, casting to date and time types requires the extraction of a component from <var>SV</var> or from the result of <a href="#func-current-dateTime"><code>fn:current-dateTime</code></a> and converting it to an <code>xs:string</code>. These conversions must follow certain rules. For example, converting an <code>xs:integer</code> year value requires converting to an <code>xs:string</code> with four or more characters, preceded by a minus sign if the value is negative.</p><p>This document defines four functions to perform these conversions. These functions are for illustrative purposes only and make no recommendations as to style or efficiency. References to these functions from the following text are not normative.</p><p>The arguments to these functions come from functions defined in this document. Thus, the functions below assume that they are correct and do no range checking on them.</p><div class="exampleInner"><pre xml:space="preserve" class="small">declare function eg:convertYearToString($year as xs:integer) as xs:string {
  let $plusMinus := if ($year &gt;= 0) then "" else "-"
  let $yearString := abs($year) cast as xs:string
  let $length := string-length($yearString)
  return if ($length = 1) then concat($plusMinus, "000", $yearString)
         else if ($length = 2) then concat($plusMinus, "00", $yearString)
         else if ($length = 3) then concat($plusMinus, "0", $yearString)
         else concat($plusMinus, $yearString)
};</pre></div><div class="exampleInner"><pre xml:space="preserve" class="small">declare function eg:convertTo2CharString($value as xs:integer) as xs:string {
  let $string := $value cast as xs:string
  return if (string-length($string) = 1) then concat("0", $string)
         else $string
};</pre></div><div class="exampleInner"><pre xml:space="preserve" class="small">declare function eg:convertSecondsToString($seconds as xs:decimal) as xs:string {
  let $string := $seconds cast as xs:string
  let $intLength := string-length(($seconds cast as xs:integer) cast as xs:string)
  return if ($intLength = 1) then concat("0", $string)
         else $string
};</pre></div><div class="exampleInner"><pre xml:space="preserve" class="small">declare function eg:convertTZtoString($tz as xs:dayTimeDuration?) as xs:string {
  if (empty($tz)) then ""
  else if ($tz eq xs:dayTimeDuration('PT0S')) then "Z"
  else let $tzh := hours-from-duration($tz)
       let $tzm := minutes-from-duration($tz)
       let $plusMinus := if ($tzh &gt;= 0) then "+" else "-"
       let $tzhString := eg:convertTo2CharString(abs($tzh))
       let $tzmString := eg:convertTo2CharString(abs($tzm))
       return concat($plusMinus, $tzhString, ":", $tzmString)
};</pre></div><p>Conversion from <a title="primitive type" class="termref" href="#dt-primitive-type">primitive types</a> to date and time types follows the rules below.</p><ol class="enumar"><li><p>When a value of any primitive type is cast as <code>xs:dateTime</code>, the <code>xs:dateTime</code> value <var>TV</var> is derived from <var>ST</var> and <var>SV</var> as follows:</p><ul><li><p>If <var>ST</var> is <code>xs:dateTime</code>, then <var>TV</var> is <var>SV</var>. </p></li><li><p>If <var>ST</var> is <code>xs:date</code>, then let <em>SYR</em> be <code>eg:convertYearToString( year-from-date(</code><var>SV</var><code>))</code>, let <em>SMO</em> be <code>eg:convertTo2CharString( month-from-date(</code><var>SV</var><code>))</code>, let <em>SDA</em> be <code>eg:convertTo2CharString( day-from-date(</code><var>SV</var><code>))</code> and let <em>STZ</em> be <code>eg:convertTZtoString( timezone-from-date(</code><var>SV</var><code>))</code>; <var>TV</var> is <code>xs:dateTime( concat(</code><em>SYR</em><code>, '-', </code><em>SMO</em><code>, '-', </code><em>SDA</em><code>, 'T00:00:00 '</code>, <em>STZ</em><code>) )</code>. </p></li><li><p><span style="display: none;" class="delete_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span style="display: none;" class="add_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span class="modify_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>.</span></p></li></ul></li><li><p>When a value of any primitive type is cast as <code>xs:time</code>, the <code>xs:time</code> value <var>TV</var> is derived from <var>ST</var> and <var>SV</var> as follows:</p><ul><li><p>If <var>ST</var> is <code>xs:time</code>, then <var>TV</var> is <var>SV</var>. </p></li><li><p>If <var>ST</var> is <code>xs:dateTime</code>, then <var>TV</var> is <code>xs:time( concat( eg:convertTo2CharString( hours-from-dateTime(</code><var>SV</var><code>)), ':', eg:convertTo2CharString( minutes-from-dateTime(</code><var>SV</var><code>)), ':', eg:convertSecondsToString( seconds-from-dateTime(</code><var>SV</var><code>)), eg:convertTZtoString( timezone-from-dateTime(</code><var>SV</var><code>)) ))</code>. </p></li><li><p><span style="display: none;" class="delete_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. </span><span style="display: none;" class="add_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. </span><span class="modify_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>. </span></p></li></ul></li><li><p>When a value of any primitive type is cast as <code>xs:date</code>, the <code>xs:date</code> value <var>TV</var> is derived from <var>ST</var> and <var>SV</var> as follows:</p><ul><li><p>If <var>ST</var> is <code>xs:date</code>, then <var>TV</var> is <var>SV</var>. </p></li><li><p>If <var>ST</var> is <code>xs:dateTime</code>, then let <em>SYR</em> be <code>eg:convertYearToString( year-from-dateTime(</code><var>SV</var><code>))</code>, let <em>SMO</em> be <code>eg:convertTo2CharString( month-from-dateTime(</code><var>SV</var><code>))</code>, let <em>SDA</em> be <code>eg:convertTo2CharString( day-from-dateTime(</code><var>SV</var><code>))</code> and let <em>STZ</em> be <code>eg:convertTZtoString(timezone-from-dateTime(</code><var>SV</var><code>))</code>; <var>TV</var> is <code>xs:date( concat(</code><em>SYR</em><code>, '-', </code><em>SMO</em><code>, '-', </code><em>SDA</em>, <em>STZ</em><code>) )</code>. </p></li><li><p><span style="display: none;" class="delete_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. </span><span style="display: none;" class="add_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. </span><span class="modify_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>. </span></p></li></ul></li><li><p>When a value of any primitive type is cast as <code>xs:gYearMonth</code>, the <code>xs:gYearMonth</code> value <var>TV</var> is derived from <var>ST</var> and <var>SV</var> as follows:</p><ul><li><p>If <var>ST</var> is <code>xs:gYearMonth</code>, then <var>TV</var> is <var>SV</var>. </p></li><li><p>If <var>ST</var> is <code>xs:dateTime</code>, then let <em>SYR</em> be <code>eg:convertYearToString( year-from-dateTime(</code><var>SV</var><code>))</code>, let <em>SMO</em> be <code>eg:convertTo2CharString( month-from-dateTime(</code><var>SV</var><code>))</code> and let <em>STZ</em> be <code>eg:convertTZtoString( timezone-from-dateTime(</code><var>SV</var><code>))</code>; <var>TV</var> is <code>xs:gYearMonth( concat(</code><em>SYR</em><code>, '-', </code><em>SMO</em>, <em>STZ</em><code>) )</code>. </p></li><li><p>If <var>ST</var> is <code>xs:date</code>, then let <em>SYR</em> be <code>eg:convertYearToString( year-from-date(</code><var>SV</var><code>))</code>, let <em>SMO</em> be <code>eg:convertTo2CharString( month-from-date(</code><var>SV</var><code>))</code> and let <em>STZ</em> be <code>eg:convertTZtoString( timezone-from-date(</code><var>SV</var><code>))</code>; <var>TV</var> is <code>xs:gYearMonth( concat(</code><em>SYR</em><code>, '-', </code><em>SMO</em>, <em>STZ</em><code>) )</code>. </p></li><li><p><span style="display: none;" class="delete_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. </span><span style="display: none;" class="add_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. </span><span class="modify_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>. </span></p></li></ul></li><li><p>When a value of any primitive type is cast as <code>xs:gYear</code>, the <code>xs:gYear</code> value <var>TV</var> is derived from <var>ST</var> and <var>SV</var> as follows:</p><ul><li><p>If <var>ST</var> is <code>xs:gYear</code>, then <var>TV</var> is <var>SV</var>. </p></li><li><p>If <var>ST</var> is <code>xs:dateTime</code>, let <em>SYR</em> be <code>eg:convertYearToString( year-from-dateTime(</code><var>SV</var><code>))</code> and let <em>STZ</em> be <code>eg:convertTZtoString( timezone-from-dateTime(</code><var>SV</var><code>))</code>; <var>TV</var> is <code>xs:gYear(concat(</code><em>SYR</em>, <em>STZ</em><code>))</code>. </p></li><li><p>If <var>ST</var> is <code>xs:date</code>, let <em>SYR</em> be <code>eg:convertYearToString( year-from-date(</code><var>SV</var><code>))</code>; and let <em>STZ</em> be <code>eg:convertTZtoString( timezone-from-date(</code><var>SV</var><code>))</code>; <var>TV</var> is <code>xs:gYear(concat(</code><em>SYR</em>, <em>STZ</em><code>))</code>. </p></li><li><p><span style="display: none;" class="delete_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. </span><span style="display: none;" class="add_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. </span><span class="modify_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>. </span></p></li></ul></li><li><p>When a value of any primitive type is cast as <code>xs:gMonthDay</code>, the <code>xs:gMonthDay</code> value <var>TV</var> is derived from <var>ST</var> and <var>SV</var> as follows:</p><ul><li><p>If <var>ST</var> is <code>xs:gMonthDay</code>, then <var>TV</var> is <var>SV</var>. </p></li><li><p>If <var>ST</var> is <code>xs:dateTime</code>, then let <em>SMO</em> be <code>eg:convertTo2CharString( month-from-dateTime(</code><var>SV</var><code>))</code>, let <em>SDA</em> be <code>eg:convertTo2CharString( day-from-dateTime(</code><var>SV</var><code>))</code> and let <em>STZ</em> be <code>eg:convertTZtoString( timezone-from-dateTime(</code><var>SV</var><code>))</code>; <var>TV</var> is <code>xs:gYearMonth( concat(</code><code> '--', </code><em>SMO</em><code> '-', </code><em>SDA</em>, <em>STZ</em><code>) )</code>. </p></li><li><p>If <var>ST</var> is <code>xs:date</code>, then let <em>SMO</em> be <code>eg:convertTo2CharString( month-from-date(</code><var>SV</var><code>))</code>, let <em>SDA</em> be <code>eg:convertTo2CharString( day-from-date(</code><var>SV</var><code>))</code> and let <em>STZ</em> be <code>eg:convertTZtoString( timezone-from-date(</code><var>SV</var><code>))</code>; <var>TV</var> is <code>xs:gYearMonth( concat(</code><code> '--', </code><em>SMO</em><code>, '-', </code><em>SDA</em>, <em>STZ</em><code>) )</code>. </p></li><li><p><span style="display: none;" class="delete_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span style="display: none;" class="add_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span class="modify_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>.</span></p></li></ul></li><li><p>When a value of any primitive type is cast as <code>xs:gDay</code>, the <code>xs:gDay</code> value <var>TV</var> is derived from <var>ST</var> and <var>SV</var> as follows:</p><ul><li><p>If <var>ST</var> is <code>xs:gDay</code>, then <var>TV</var> is <var>SV</var>. </p></li><li><p>If <var>ST</var> is <code>xs:dateTime</code>, then let <em>SDA</em> be <code>eg:convertTo2CharString( day-from-dateTime(</code><var>SV</var><code>))</code> and let <em>STZ</em> be <code>eg:convertTZtoString( timezone-from-dateTime(</code><var>SV</var><code>))</code>; <var>TV</var> is <code>xs:gDay( concat( '---'</code>, <em>SDA</em>, <em>STZ</em><code>))</code>. </p></li><li><p>If <var>ST</var> is <code>xs:date</code>, then let <em>SDA</em> be <code>eg:convertTo2CharString( day-from-date(</code><var>SV</var><code>))</code> and let <em>STZ</em> be <code>eg:convertTZtoString( timezone-from-date(</code><var>SV</var><code>))</code>; <var>TV</var> is <code>xs:gDay( concat( '---'</code>, <em>SDA</em>, <em>STZ</em><code>))</code>. </p></li><li><p><span style="display: none;" class="delete_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. </span><span style="display: none;" class="add_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. </span><span class="modify_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>. </span></p></li></ul></li><li><p>When a value of any primitive type is cast as <code>xs:gMonth</code>, the <code>xs:gMonth</code> value <var>TV</var> is derived from <var>ST</var> and <var>SV</var> as follows:</p><ul><li><p>If <var>ST</var> is <code>xs:gMonth</code>, then <var>TV</var> is <var>SV</var>. </p></li><li><p>If <var>ST</var> is <code>xs:dateTime</code>, then let <em>SMO</em> be <code>eg:convertTo2CharString( month-from-dateTime(</code><var>SV</var><code>))</code> and let <em>STZ</em> be <code>eg:convertTZtoString( timezone-from-dateTime(</code><var>SV</var><code>))</code>; <var>TV</var> is <code>xs:gMonth( concat( '--' </code>, <em>SMO</em>, <em>STZ</em><code>))</code>. </p></li><li><p>If <var>ST</var> is <code>xs:date</code>, then let <em>SMO</em> be <code>eg:convertTo2CharString( month-from-date(</code><var>SV</var><code>))</code> and let <em>STZ</em> be <code>eg:convertTZtoString( timezone-from-date(</code><var>SV</var><code>))</code>; <var>TV</var> is <code>xs:gMonth( concat( '--'</code>, <em>SMO</em>, <em>STZ</em><code>))</code>. </p></li><li><p><span style="display: none;" class="delete_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span style="display: none;" class="add_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span class="modify_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>.</span></p></li></ul></li></ol></div><div class="_diffs div3"><h4><a id="casting-boolean"></a><span class="deltaxml-old" style="background:#FF5555">23.1.6</span><span class="deltaxml-new" style="background:#90EE90">24.1.6</span> <a href="#casting-boolean" style="text-decoration: none">Casting to <code>xs:boolean</code></a></h4><p>When the target type <var>TT</var> is <code>xs:boolean</code>, the resulting <code>xs:boolean</code> value <var>TV</var> is derived from the source value <var>SV</var> as follows:</p><ul><li><p>If <var>SV</var> is an instance of <code>xs:boolean</code>, then <var>TV</var> is <var>SV</var>.</p></li><li><p>If <var>SV</var> is an instance of <code>xs:numeric</code> and <var>SV</var> is <code>0</code>, <code>+0</code>, <code>-0</code>, <code>0.0</code>, <code>0.0E0</code> or <code>NaN</code>, then <var>TV</var> is <code>false</code>. </p></li><li><p>If <var>ST</var> is is an instance of <code>xs:numeric</code> and <var>SV</var> is not one of the above values, then <var>TV</var> is <code>true</code>. </p></li><li><p><span style="display: none;" class="delete_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. </span><span style="display: none;" class="add_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. </span><span class="modify_version"> If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code>, see <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>. </span></p></li></ul></div><div class="_diffs div3"><h4><a id="casting-to-binary"></a><span class="deltaxml-old" style="background:#FF5555">23.1.7</span><span class="deltaxml-new" style="background:#90EE90">24.1.7</span> <a href="#casting-to-binary" style="text-decoration: none">Casting to <code>xs:base64Binary</code> and <code>xs:hexBinary</code></a></h4><p>Values of type <code>xs:base64Binary</code> can be cast as <code>xs:hexBinary</code> and vice versa, since the two types have the same value space. Casting to <code>xs:base64Binary</code> and <code>xs:hexBinary</code> is also supported from the same type and from <code>xs:untypedAtomic</code>, <code>xs:string</code> and subtypes of <code>xs:string</code> using <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> semantics.</p></div><div class="_diffs div3"><h4><a id="casting-to-anyuri"></a><span class="deltaxml-old" style="background:#FF5555">23.1.8</span><span class="deltaxml-new" style="background:#90EE90">24.1.8</span> <a href="#casting-to-anyuri" style="text-decoration: none">Casting to xs:anyURI</a></h4><p>Casting to <code>xs:anyURI</code> is supported only from the same type, <code>xs:untypedAtomic</code> or <code>xs:string</code>.</p><p>When a value of any <a title="primitive type" class="termref" href="#dt-primitive-type">primitive type</a> is cast as <code>xs:anyURI</code>, the <code>xs:anyURI</code> value <var>TV</var> is derived from the <var>ST</var> and <var>SV</var> as follows:</p><ul><li><p><span style="display: none;" class="delete_version">If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code> see <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. </span><span style="display: none;" class="add_version">If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code> see <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. </span><span class="modify_version">If <var>ST</var> is <code>xs:untypedAtomic</code> or <code>xs:string</code> see <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>. </span></p></li></ul></div><div class="_diffs div3"><h4><a id="casting-to-qname-and-notation"></a><span class="deltaxml-old" style="background:#FF5555">23.1.9</span><span class="deltaxml-new" style="background:#90EE90">24.1.9</span> <a href="#casting-to-qname-and-notation" style="text-decoration: none">Casting to xs:QName and xs:NOTATION</a></h4><p><span style="display: none;" class="delete_version">Casting from <code>xs:string</code> or <code>xs:untypedAtomic</code> to <code>xs:QName</code> or <code>xs:NOTATION</code> is described in <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span style="display: none;" class="add_version">Casting from <code>xs:string</code> or <code>xs:untypedAtomic</code> to <code>xs:QName</code> or <code>xs:NOTATION</code> is described in <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span class="modify_version">Casting from <code>xs:string</code> or <code>xs:untypedAtomic</code> to <code>xs:QName</code> or <code>xs:NOTATION</code> is described in <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>.</span></p><p>It is also possible to cast from <code>xs:NOTATION</code> to <code>xs:QName</code>, or from <code>xs:QName</code> to any type derived by restriction from <code>xs:NOTATION</code>. (Casting to <code>xs:NOTATION</code> itself is not allowed, because <code>xs:NOTATION</code> is an abstract type.) The resulting <code>xs:QName</code> or <code>xs:NOTATION</code> has the same prefix, local name, and namespace URI parts as the supplied value.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>See <a href="#constructor-qname-notation"><span style="display: none;" class="delete_version"><b>22.2 Constructor functions for xs:QName and xs:NOTATION</b></span><span style="display: none;" class="add_version"><b>23.2 Constructor functions for xs:QName and xs:NOTATION</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22.2</span><span class="deltaxml-new" style="background:#90EE90">23.2</span> Constructor functions for xs:QName and xs:NOTATION</b></span></a> for a discussion of how the combination of atomization and casting might not produce the desired effect.</p></div></div><div class="_diffs div3"><h4><a id="casting-to-ENTITY"></a><span class="deltaxml-old" style="background:#FF5555">23.1.10</span><span class="deltaxml-new" style="background:#90EE90">24.1.10</span> <a href="#casting-to-ENTITY" style="text-decoration: none">Casting to xs:ENTITY</a></h4><p><a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> says that “The value space of ENTITY is the set of all strings that match the NCName production ... and have been declared as an unparsed entity in a document type definition.” However, <a href="#xslt-40">[XSL Transformations (XSLT) Version 4.0]</a> and <a href="#xquery-40">[XQuery 4.0: An XML Query Language]</a> do not check that constructed values of type <code>xs:ENTITY</code> match declared unparsed entities. Thus, this rule is relaxed in this specification and, in casting to <code>xs:ENTITY</code> and types derived from it, no check is made that the values correspond to declared unparsed entities. </p></div></div><div class="_diffs div2"><h3><a id="casting-from-strings"></a><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> <a href="#casting-from-strings" style="text-decoration: none">Casting from xs:string and xs:untypedAtomic</a></h3><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#id-built-in-named-record-types">next</a> | <a href="#casting-duration-to-string">previous</a>)</p><ol><li><p> When casting from a string to a duration or time or dateTime, it is now specified that when there are more digits in the fractional seconds than the implementation is able to retain, excess digits are truncated. Rounding upwards (which could affect the number of minutes or hours in the value) is not permitted. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1089">1089</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1090">1090</a>&nbsp;19 March 2024]</i></p></li></ol></div><p>This section applies when the supplied value <var>SV</var> is an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>, including types derived from these by restriction. If the value is <code>xs:untypedAtomic</code>, it is treated in exactly the same way as a string containing the same sequence of characters.</p><p>The supplied string is mapped to a typed value of the target type as defined in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a>. Whitespace normalization is applied as indicated by the <code>whiteSpace</code> facet for the datatype. The resulting whitespace-normalized string must be a valid lexical form for the datatype. The semantics of casting follow the rules of XML Schema validation. For example, <code>"13" cast as xs:unsignedInt</code> returns the <code>xs:unsignedInt</code> typed value <code>13</code>. This could also be written <code>xs:unsignedInt("13")</code>.</p><p>The target type can be any simple type other than an abstract type. Specifically, it can be a type whose variety is atomic, union, or list. In each case the effect of casting to the target type is the same as constructing an element with the supplied value as its content, validating the element using the target type as the governing type, and atomizing the element to obtain its typed value.</p><p>When the target type is a derived type that is restricted by a pattern facet, the lexical form is first checked against the pattern before further casting is attempted (See <a href="#casting-to-derived-types"><span style="display: none;" class="delete_version"><b>23.3.1 Casting to derived types</b></span><span style="display: none;" class="add_version"><b>24.3.1 Casting to derived types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.1</span><span class="deltaxml-new" style="background:#90EE90">24.3.1</span> Casting to derived types</b></span></a>). If the lexical form does not conform to the pattern, a dynamic error [<a href="#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>] is raised.</p><p>For example, consider a user-defined type <code>my:boolean</code> which is derived by restriction from <code>xs:boolean</code> and specifies the pattern facet <code>value="0|1"</code>. The expression <code>"true" cast as my:boolean</code> would fail with a dynamic error [<a href="#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>].</p><p>Facets other than <code>pattern</code> are checked <em>after</em> the conversion. For example if there is a user-defined datatype called <code>my:height</code> defined as a restriction of <code>xs:integer</code> with the facet <code>&lt;maxInclusive value="84"/&gt;</code>, then the expression <code>"100" cast as my:height</code> would fail with a dynamic error [<a href="#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>].</p><p>Casting to the types <code>xs:NOTATION</code>, <code>xs:anySimpleType</code>, or <code>xs:anyAtomicType</code> is not permitted because these types are abstract (they have no immediate instances).</p><p><span style="display: none;" class="delete_version">Special rules apply when casting to namespace-sensitive types. The types <code>xs:QName</code> and <code>xs:NOTATION</code> are namespace-sensitive. Any type derived by restriction from a namespace-sensitive type is itself namespace-sensitive, as is any union type having a namespace-sensitive type among its members, and any list type having a namespace-sensitive type as its item type. For details, see <a href="#constructor-qname-notation"><span class="delete_version"><b>22.2 Constructor functions for xs:QName and xs:NOTATION</b></span><span class="modify_version"><b>22.2 Constructor functions for xs:QName and xs:NOTATION</b></span></a>.</span><span style="display: none;" class="add_version">Special rules apply when casting to namespace-sensitive types. The types <code>xs:QName</code> and <code>xs:NOTATION</code> are namespace-sensitive. Any type derived by restriction from a namespace-sensitive type is itself namespace-sensitive, as is any union type having a namespace-sensitive type among its members, and any list type having a namespace-sensitive type as its item type. For details, see <a href="#constructor-qname-notation"><span class="add_version"><b>23.2 Constructor functions for xs:QName and xs:NOTATION</b></span><span class="modify_version"><b>23.2 Constructor functions for xs:QName and xs:NOTATION</b></span></a>.</span><span class="modify_version">Special rules apply when casting to namespace-sensitive types. The types <code>xs:QName</code> and <code>xs:NOTATION</code> are namespace-sensitive. Any type derived by restriction from a namespace-sensitive type is itself namespace-sensitive, as is any union type having a namespace-sensitive type among its members, and any list type having a namespace-sensitive type as its item type. For details, see <a href="#constructor-qname-notation"><span style="display: none;" class="delete_version"><b>22.2 Constructor functions for xs:QName and xs:NOTATION</b></span><span style="display: none;" class="add_version"><b>23.2 Constructor functions for xs:QName and xs:NOTATION</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22.2</span><span class="deltaxml-new" style="background:#90EE90">23.2</span> Constructor functions for xs:QName and xs:NOTATION</b></span></a>.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>Since version 3.0 of this specification, casting has been allowed between <code>xs:QName</code> and <code>xs:NOTATION</code> in either direction; this was not permitted in previous Recommendations. Version 3.0 also removed the rule that only a string literal (rather than a dynamic string) may be cast to an <code>xs:QName</code></p></div><p>When casting to a numeric type:</p><ul><li><p>If the value is too large or too small to be accurately represented by the implementation, it is handled as an overflow or underflow as defined in <a href="#op.numeric"><b>4.2 Arithmetic operators on numeric values</b></a>.</p></li><li><p>If the target type is <code>xs:float</code> or <code>xs:double</code>, the string <code>-0</code> (and equivalents such as <code>-0.0</code> or <code>-000</code>) <span class="verb">should</span> be converted to the value negative zero. However, if the implementation is reliant on an implementation of XML Schema 1.0 in which negative zero is not part of the value space for these types, these lexical forms <span class="verb">may</span> be converted to positive zero.</p></li></ul><p> In casting to <code>xs:decimal</code> or to a type derived from <code>xs:decimal</code>, if the value is not too large or too small but nevertheless cannot be represented accurately with the number of decimal digits available to the implementation, the implementation may round to the nearest representable value or may raise a dynamic error [<a href="#ERRFOCA0006" title="err:FOCA0006">err:FOCA0006</a>]. The choice of rounding algorithm and the choice between rounding and error behavior is <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a>. </p><p>When casting to <code>xs:duration</code>, <code>xs:dateTime</code>, or <code>xs:time</code>, if the seconds component has more fractional digits than are supported by the implementation, excess digits <span class="verb">must</span> be truncated. This rule ensures that components other than the seconds component are unaffected: for example <code>xs:dateTime('2023-12-31T23:59:59.999999999')</code> is guaranteed to deliver an <code>xs:dateTime</code> value whose year component is 2023 rather than 2024.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Implementations are required to support millisecond precision or greater.</p></div><p>In casting to <code>xs:date</code>, <code>xs:dateTime</code>, <code>xs:gYear</code>, or <code>xs:gYearMonth</code> (or types derived from these), if the value is too large or too small to be represented by the implementation, a dynamic error [<a href="#ERRFODT0001" title="err:FODT0001">err:FODT0001</a>] is raised.</p><p>In casting to a duration value, if the value is too large or too small to be represented by the implementation, a dynamic error [<a href="#ERRFODT0002" title="err:FODT0002">err:FODT0002</a>] is raised.</p><p> For <code>xs:anyURI</code>, the extent to which an implementation validates the lexical form of <code>xs:anyURI</code> is <a title="implementation-dependent" class="termref" href="#implementation-dependent">implementation-dependent</a>.</p><p>If the cast fails for any other reason, a dynamic error [<a href="#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>] is raised.</p></div><div class="_diffs div2"><h3><a id="casting-non-primitive-types"></a><span class="deltaxml-old" style="background:#FF5555">23.3</span><span class="deltaxml-new" style="background:#90EE90">24.3</span> <a href="#casting-non-primitive-types" style="text-decoration: none">Casting involving non-primitive types</a></h3><p><span style="display: none;" class="delete_version">Casting from <code>xs:string</code> and <code>xs:untypedAtomic</code> to any other type (primitive or non-primitive) has been described in <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. This section defines how other casts to non-primitive types operate, including casting to types derived by restriction, to union types, and to list types.</span><span style="display: none;" class="add_version">Casting from <code>xs:string</code> and <code>xs:untypedAtomic</code> to any other type (primitive or non-primitive) has been described in <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>. This section defines how other casts to non-primitive types operate, including casting to types derived by restriction, to union types, and to list types.</span><span class="modify_version">Casting from <code>xs:string</code> and <code>xs:untypedAtomic</code> to any other type (primitive or non-primitive) has been described in <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>. This section defines how other casts to non-primitive types operate, including casting to types derived by restriction, to union types, and to list types.</span></p><div class="_diffs div3"><h4><a id="casting-to-derived-types"></a><span class="deltaxml-old" style="background:#FF5555">23.3.1</span><span class="deltaxml-new" style="background:#90EE90">24.3.1</span> <a href="#casting-to-derived-types" style="text-decoration: none">Casting to derived types</a></h4><p>Casting a value to a derived type can be separated into a number of cases. In these rules:</p><ul><li><p>The types <code>xs:integer</code>, <code>xs:yearMonthDuration</code>, and <code>xs:dayTimeDuration</code> are treated as quasi-primitive types (alongside the 20 truly <a title="primitive type" class="termref" href="#dt-primitive-type">primitive types</a>).</p></li><li><p>For any atomic type <var>T</var>, let <var>P(T)</var> denote the most specific primitive or quasi-primitive type such that <code>itemType-subtype(T, P(T))</code> is <code>true</code>.</p></li></ul><p>The rules are then:</p><ol class="enumar"><li><p>When the source type <var>ST</var> is the same type as the target type <var>TT</var>: this case always succeeds, returning the source value <var>SV</var> unchanged.</p></li><li><p><span style="display: none;" class="delete_version">When <code>itemType-subtype(ST, TT)</code> is <code>true</code>: see <a href="#casting-from-derived-to-parent"><span class="delete_version"><b>23.3.4 Casting from derived types to parent types</b></span><span class="modify_version"><b>23.3.4 Casting from derived types to parent types</b></span></a>. </span><span style="display: none;" class="add_version">When <code>itemType-subtype(ST, TT)</code> is <code>true</code>: see <a href="#casting-from-derived-to-parent"><span class="add_version"><b>24.3.4 Casting from derived types to parent types</b></span><span class="modify_version"><b>24.3.4 Casting from derived types to parent types</b></span></a>. </span><span class="modify_version">When <code>itemType-subtype(ST, TT)</code> is <code>true</code>: see <a href="#casting-from-derived-to-parent"><span style="display: none;" class="delete_version"><b>23.3.4 Casting from derived types to parent types</b></span><span style="display: none;" class="add_version"><b>24.3.4 Casting from derived types to parent types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.4</span><span class="deltaxml-new" style="background:#90EE90">24.3.4</span> Casting from derived types to parent types</b></span></a>. </span></p></li><li><p><span style="display: none;" class="delete_version">When <var>TT</var> is the quasi-primitive type <code>xs:integer</code> and <code>SV</code> is an instance of <code>xs:numeric</code>: see <a href="#casting-to-integer"><span class="delete_version"><b>23.3.2 Casting to xs:integer</b></span><span class="modify_version"><b>23.3.2 Casting to xs:integer</b></span></a>.</span><span style="display: none;" class="add_version">When <var>TT</var> is the quasi-primitive type <code>xs:integer</code> and <code>SV</code> is an instance of <code>xs:numeric</code>: see <a href="#casting-to-integer"><span class="add_version"><b>24.3.2 Casting to xs:integer</b></span><span class="modify_version"><b>24.3.2 Casting to xs:integer</b></span></a>.</span><span class="modify_version">When <var>TT</var> is the quasi-primitive type <code>xs:integer</code> and <code>SV</code> is an instance of <code>xs:numeric</code>: see <a href="#casting-to-integer"><span style="display: none;" class="delete_version"><b>23.3.2 Casting to xs:integer</b></span><span style="display: none;" class="add_version"><b>24.3.2 Casting to xs:integer</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.2</span><span class="deltaxml-new" style="background:#90EE90">24.3.2</span> Casting to xs:integer</b></span></a>.</span></p></li><li><p><span style="display: none;" class="delete_version">When <var>TT</var> is the quasi-primitive type <code>xs:yearMonthDuration</code> or <code>xs:dayTimeDuration</code> and <code>SV</code> is an instance of <code>xs:duration</code>: see <a href="#casting-to-duration-subtypes"><span class="delete_version"><b>23.3.3 Casting to xs:yearMonthDuration and xs:dayTimeDuration</b></span><span class="modify_version"><b>23.3.3 Casting to xs:yearMonthDuration and xs:dayTimeDuration</b></span></a>.</span><span style="display: none;" class="add_version">When <var>TT</var> is the quasi-primitive type <code>xs:yearMonthDuration</code> or <code>xs:dayTimeDuration</code> and <code>SV</code> is an instance of <code>xs:duration</code>: see <a href="#casting-to-duration-subtypes"><span class="add_version"><b>24.3.3 Casting to xs:yearMonthDuration and xs:dayTimeDuration</b></span><span class="modify_version"><b>24.3.3 Casting to xs:yearMonthDuration and xs:dayTimeDuration</b></span></a>.</span><span class="modify_version">When <var>TT</var> is the quasi-primitive type <code>xs:yearMonthDuration</code> or <code>xs:dayTimeDuration</code> and <code>SV</code> is an instance of <code>xs:duration</code>: see <a href="#casting-to-duration-subtypes"><span style="display: none;" class="delete_version"><b>23.3.3 Casting to xs:yearMonthDuration and xs:dayTimeDuration</b></span><span style="display: none;" class="add_version"><b>24.3.3 Casting to xs:yearMonthDuration and xs:dayTimeDuration</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.3</span><span class="deltaxml-new" style="background:#90EE90">24.3.3</span> Casting to xs:yearMonthDuration and xs:dayTimeDuration</b></span></a>.</span></p></li><li><p><span style="display: none;" class="delete_version">When <var>P(ST)</var> is the same type as <var>P(TT)</var>: see <a href="#casting-within-branch"><span class="delete_version"><b>23.3.5 Casting within a branch of the type hierarchy</b></span><span class="modify_version"><b>23.3.5 Casting within a branch of the type hierarchy</b></span></a>.</span><span style="display: none;" class="add_version">When <var>P(ST)</var> is the same type as <var>P(TT)</var>: see <a href="#casting-within-branch"><span class="add_version"><b>24.3.5 Casting within a branch of the type hierarchy</b></span><span class="modify_version"><b>24.3.5 Casting within a branch of the type hierarchy</b></span></a>.</span><span class="modify_version">When <var>P(ST)</var> is the same type as <var>P(TT)</var>: see <a href="#casting-within-branch"><span style="display: none;" class="delete_version"><b>23.3.5 Casting within a branch of the type hierarchy</b></span><span style="display: none;" class="add_version"><b>24.3.5 Casting within a branch of the type hierarchy</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.5</span><span class="deltaxml-new" style="background:#90EE90">24.3.5</span> Casting within a branch of the type hierarchy</b></span></a>.</span></p></li><li><p><span style="display: none;" class="delete_version">Otherwise (<var>P(ST)</var> is not the same type as <var>P(TT)</var>): see <a href="#casting-across-hierarchy"><span class="delete_version"><b>23.3.6 Casting across the type hierarchy</b></span><span class="modify_version"><b>23.3.6 Casting across the type hierarchy</b></span></a>.</span><span style="display: none;" class="add_version">Otherwise (<var>P(ST)</var> is not the same type as <var>P(TT)</var>): see <a href="#casting-across-hierarchy"><span class="add_version"><b>24.3.6 Casting across the type hierarchy</b></span><span class="modify_version"><b>24.3.6 Casting across the type hierarchy</b></span></a>.</span><span class="modify_version">Otherwise (<var>P(ST)</var> is not the same type as <var>P(TT)</var>): see <a href="#casting-across-hierarchy"><span style="display: none;" class="delete_version"><b>23.3.6 Casting across the type hierarchy</b></span><span style="display: none;" class="add_version"><b>24.3.6 Casting across the type hierarchy</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.6</span><span class="deltaxml-new" style="background:#90EE90">24.3.6</span> Casting across the type hierarchy</b></span></a>.</span></p></li></ol></div><div class="_diffs div3"><h4><a id="casting-to-integer"></a><span class="deltaxml-old" style="background:#FF5555">23.3.2</span><span class="deltaxml-new" style="background:#90EE90">24.3.2</span> <a href="#casting-to-integer" style="text-decoration: none">Casting to xs:integer</a></h4><p>When an atomic item <code>SV</code> is cast as <code>xs:integer</code>, the resulting <code>xs:integer</code> value <var>TV</var> is obtained as follows:</p><ul><li><p>If <var>ST</var> is <code>xs:decimal</code>, <code>xs:float</code> or <code>xs:double</code>, then <var>TV</var> is <var>SV</var> with the fractional part discarded and the value converted to <code>xs:integer</code>. Thus, casting <code>3.1456</code> returns <code>3</code> while <code>-17.89</code> returns <code>-17</code>. Casting <code>3.124E1</code> returns <code>31</code>. If <var>SV</var> is too large to be accommodated as an integer, (see <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a> for <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a> limits on numeric values) a dynamic error is raised [<a href="#ERRFOCA0003" title="err:FOCA0003">err:FOCA0003</a>]. If <var>SV</var> is one of the special <code>xs:float</code> or <code>xs:double</code> values <code>NaN</code>, <code>INF</code>, or <code>-INF</code>, a dynamic error is raised [<a href="#ERRFOCA0002" title="err:FOCA0002">err:FOCA0002</a>].</p></li><li><p>In all other cases, the general rules of <a href="#casting-to-derived-types"><span style="display: none;" class="delete_version"><b>23.3.1 Casting to derived types</b></span><span style="display: none;" class="add_version"><b>24.3.1 Casting to derived types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.1</span><span class="deltaxml-new" style="background:#90EE90">24.3.1</span> Casting to derived types</b></span></a> apply.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">When casting to a subtype of <code>xs:integer</code> (for example, <code>xs:long</code>), the rules in <a href="#casting-to-derived-types"><span class="delete_version"><b>23.3.1 Casting to derived types</b></span><span class="modify_version"><b>23.3.1 Casting to derived types</b></span></a> apply. Note, however, that these rules treat <code>xs:integer</code> as a quasi-primitive type.</span><span style="display: none;" class="add_version">When casting to a subtype of <code>xs:integer</code> (for example, <code>xs:long</code>), the rules in <a href="#casting-to-derived-types"><span class="add_version"><b>24.3.1 Casting to derived types</b></span><span class="modify_version"><b>24.3.1 Casting to derived types</b></span></a> apply. Note, however, that these rules treat <code>xs:integer</code> as a quasi-primitive type.</span><span class="modify_version">When casting to a subtype of <code>xs:integer</code> (for example, <code>xs:long</code>), the rules in <a href="#casting-to-derived-types"><span style="display: none;" class="delete_version"><b>23.3.1 Casting to derived types</b></span><span style="display: none;" class="add_version"><b>24.3.1 Casting to derived types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.1</span><span class="deltaxml-new" style="background:#90EE90">24.3.1</span> Casting to derived types</b></span></a> apply. Note, however, that these rules treat <code>xs:integer</code> as a quasi-primitive type.</span></p></div></div><div class="_diffs div3"><h4><a id="casting-to-duration-subtypes"></a><span class="deltaxml-old" style="background:#FF5555">23.3.3</span><span class="deltaxml-new" style="background:#90EE90">24.3.3</span> <a href="#casting-to-duration-subtypes" style="text-decoration: none">Casting to <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code></a></h4><p>When the source value <var>SV</var> is an instance of <code>xs:duration</code> (including any subtype of <code>xs:duration</code>), then:</p><ul><li><p>If the target type <var>TT</var> is <code>xs:yearMonthDuration</code>, the result is an instance of <code>xs:yearMonthDuration</code> whose <code>months</code> component is equal to the <code>months</code> component of <var>SV</var>. The <code>seconds</code> component of <var>SV</var> is ignored.</p></li><li><p>If the target type <var>TT</var> is <code>xs:dayTimeDuration</code>, the result is an instance of <code>xs:dayTimeDuration</code> whose <code>seconds</code> component is equal to the <code>seconds</code> component of <var>SV</var>. The <code>months</code> component of <var>SV</var> is ignored.</p></li></ul><p>In all other cases, the general rules of <a href="#casting-to-derived-types"><span style="display: none;" class="delete_version"><b>23.3.1 Casting to derived types</b></span><span style="display: none;" class="add_version"><b>24.3.1 Casting to derived types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.1</span><span class="deltaxml-new" style="background:#90EE90">24.3.1</span> Casting to derived types</b></span></a> apply.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In general, casting to <code>xs:yearMonthDuration</code> or <code>xs:dayTimeDuration</code> loses information.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p><span style="display: none;" class="delete_version">When casting to a subtype of <code>xs:dayTimeDuration</code> or <code>xs:yearMonthDuration</code>, the rules in <a href="#casting-to-derived-types"><span class="delete_version"><b>23.3.1 Casting to derived types</b></span><span class="modify_version"><b>23.3.1 Casting to derived types</b></span></a> apply. Note, however, that these rules treat <code>xs:dayTimeDuration</code> and <code>xs:yearMonthDuration</code> as quasi-primitive types.</span><span style="display: none;" class="add_version">When casting to a subtype of <code>xs:dayTimeDuration</code> or <code>xs:yearMonthDuration</code>, the rules in <a href="#casting-to-derived-types"><span class="add_version"><b>24.3.1 Casting to derived types</b></span><span class="modify_version"><b>24.3.1 Casting to derived types</b></span></a> apply. Note, however, that these rules treat <code>xs:dayTimeDuration</code> and <code>xs:yearMonthDuration</code> as quasi-primitive types.</span><span class="modify_version">When casting to a subtype of <code>xs:dayTimeDuration</code> or <code>xs:yearMonthDuration</code>, the rules in <a href="#casting-to-derived-types"><span style="display: none;" class="delete_version"><b>23.3.1 Casting to derived types</b></span><span style="display: none;" class="add_version"><b>24.3.1 Casting to derived types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.1</span><span class="deltaxml-new" style="background:#90EE90">24.3.1</span> Casting to derived types</b></span></a> apply. Note, however, that these rules treat <code>xs:dayTimeDuration</code> and <code>xs:yearMonthDuration</code> as quasi-primitive types.</span></p></div></div><div class="_diffs div3"><h4><a id="casting-from-derived-to-parent"></a><span class="deltaxml-old" style="background:#FF5555">23.3.4</span><span class="deltaxml-new" style="background:#90EE90">24.3.4</span> <a href="#casting-from-derived-to-parent" style="text-decoration: none">Casting from derived types to parent types</a></h4><p> It is always possible to cast an atomic item <var>A</var> to a type <var>T</var> if the relation <code>A instance of T</code> is true, provided that <var>T</var> is not an abstract type. </p><p>For example, it is possible to cast an <code>xs:unsignedShort</code> to an <code>xs:unsignedInt</code>, to an <code>xs:integer</code>, to an <code>xs:decimal</code>, or to a union type whose member types are <code>xs:integer</code> and <code>xs:double</code>.</p><p>Since the value space of the original type is a subset of the value space of the target type, such a cast is always successful.</p><p>For the expression <code>A instance of T</code> to be true, <var>T</var> must be either an atomic type, or a union type that has no constraining facets. It cannot be a list type, nor a union type derived by restriction from another union type, nor a union type that has a list type among its member types.</p><p>The result will have the same value as the original, but will have a new type annotation:</p><ul><li><p>If <var>T</var> is an atomic type, then the type annotation of the result is <code>T</code>. </p></li><li><p>If <var>T</var> is a union type, then the type of the result is an atomic type <code>M</code> such that <var>M</var> is one of the atomic types in the transitive membership of the union type <var>T</var> and <code>A instance of M</code> is true; if there is more than one type <var>M</var> that satisfies these conditions (which could happen, for example, if <var>T</var> is the union of two overlapping types such as <code>xs:int</code> and <code>xs:positiveInteger</code>) then the first one is used, taking the member types in the order in which they appear within the definition of the union type.</p></li></ul></div><div class="_diffs div3"><h4><a id="casting-within-branch"></a><span class="deltaxml-old" style="background:#FF5555">23.3.5</span><span class="deltaxml-new" style="background:#90EE90">24.3.5</span> <a href="#casting-within-branch" style="text-decoration: none">Casting within a branch of the type hierarchy</a></h4><p>It is possible to cast an <var>SV</var> to a <var>TT</var> if the type of the <var>SV</var> and the <var>TT</var> type are both derived by restriction (directly or indirectly) from the same <a title="primitive type" class="termref" href="#dt-primitive-type">primitive type</a>, provided that the supplied value conforms to the constraints implied by the facets of the target type. This includes the case where the target type is derived from the type of the supplied value, as well as the case where the type of the supplied value is derived from the target type. For example, an instance of <code>xs:byte</code> can be cast as <code>xs:unsignedShort</code>, provided the value is not negative. </p><p>If the value does not conform to the facets defined for the target type, then a dynamic error is raised [<a href="#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>]. See <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a>. In the case of the pattern facet (which applies to the lexical space rather than the value space), the pattern is tested against the canonical representation of the value, as defined for the source type (or the result of casting the value to an <code>xs:string</code>, in the case of types that have no canonical representation defined for them).</p><p>Note that this will cause casts to fail if the pattern excludes the canonical lexical representation of the source type. For example, if the type <code>my:distance</code> is defined as a restriction of <code>xs:decimal</code> with a pattern that requires two digits after the decimal point, casting of an <code>xs:integer</code> to <code>my:distance</code> will always fail, because the canonical representation of an <code>xs:integer</code> does not conform to this pattern.</p><p><span style="display: none;" class="delete_version">In some cases, casting from a parent type to a derived type requires special rules. See <a href="#casting-to-durations"><span class="delete_version"><b>23.1.4 Casting to duration types</b></span><span class="modify_version"><b>23.1.4 Casting to duration types</b></span></a> for rules regarding casting to <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code>. See <a href="#casting-to-ENTITY"><span class="delete_version"><b>23.1.10 Casting to xs:ENTITY</b></span><span class="modify_version"><b>23.1.10 Casting to xs:ENTITY</b></span></a>, below, for casting to <code>xs:ENTITY</code> and types derived from it.</span><span style="display: none;" class="add_version">In some cases, casting from a parent type to a derived type requires special rules. See <a href="#casting-to-durations"><span class="add_version"><b>24.1.4 Casting to duration types</b></span><span class="modify_version"><b>24.1.4 Casting to duration types</b></span></a> for rules regarding casting to <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code>. See <a href="#casting-to-ENTITY"><span class="add_version"><b>24.1.10 Casting to xs:ENTITY</b></span><span class="modify_version"><b>24.1.10 Casting to xs:ENTITY</b></span></a>, below, for casting to <code>xs:ENTITY</code> and types derived from it.</span><span class="modify_version">In some cases, casting from a parent type to a derived type requires special rules. See <a href="#casting-to-durations"><span style="display: none;" class="delete_version"><b>23.1.4 Casting to duration types</b></span><span style="display: none;" class="add_version"><b>24.1.4 Casting to duration types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.1.4</span><span class="deltaxml-new" style="background:#90EE90">24.1.4</span> Casting to duration types</b></span></a> for rules regarding casting to <code>xs:yearMonthDuration</code> and <code>xs:dayTimeDuration</code>. See <a href="#casting-to-ENTITY"><span style="display: none;" class="delete_version"><b>23.1.10 Casting to xs:ENTITY</b></span><span style="display: none;" class="add_version"><b>24.1.10 Casting to xs:ENTITY</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.1.10</span><span class="deltaxml-new" style="background:#90EE90">24.1.10</span> Casting to xs:ENTITY</b></span></a>, below, for casting to <code>xs:ENTITY</code> and types derived from it.</span></p></div><div class="_diffs div3"><h4><a id="casting-across-hierarchy"></a><span class="deltaxml-old" style="background:#FF5555">23.3.6</span><span class="deltaxml-new" style="background:#90EE90">24.3.6</span> <a href="#casting-across-hierarchy" style="text-decoration: none">Casting across the type hierarchy</a></h4><p>When the <var>ST</var> and the <var>TT</var> are derived, directly or indirectly, from different <a title="primitive type" class="termref" href="#dt-primitive-type">primitive types</a>, this is called casting across the type hierarchy. Casting across the type hierarchy is logically equivalent to three separate steps performed in order. Errors can occur in either of the latter two steps.</p><ol class="enumar"><li><p><span style="display: none;" class="delete_version">Cast the <var>SV</var>, up the hierarchy, to the <a title="primitive type" class="termref" href="#dt-primitive-type">primitive type</a> of the source, as described in <a href="#casting-from-derived-to-parent"><span class="delete_version"><b>23.3.4 Casting from derived types to parent types</b></span><span class="modify_version"><b>23.3.4 Casting from derived types to parent types</b></span></a>.</span><span style="display: none;" class="add_version">Cast the <var>SV</var>, up the hierarchy, to the <a title="primitive type" class="termref" href="#dt-primitive-type">primitive type</a> of the source, as described in <a href="#casting-from-derived-to-parent"><span class="add_version"><b>24.3.4 Casting from derived types to parent types</b></span><span class="modify_version"><b>24.3.4 Casting from derived types to parent types</b></span></a>.</span><span class="modify_version">Cast the <var>SV</var>, up the hierarchy, to the <a title="primitive type" class="termref" href="#dt-primitive-type">primitive type</a> of the source, as described in <a href="#casting-from-derived-to-parent"><span style="display: none;" class="delete_version"><b>23.3.4 Casting from derived types to parent types</b></span><span style="display: none;" class="add_version"><b>24.3.4 Casting from derived types to parent types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.4</span><span class="deltaxml-new" style="background:#90EE90">24.3.4</span> Casting from derived types to parent types</b></span></a>.</span></p><ol class="enumla"><li><p> If <var>SV</var> is an instance of <code>xs:string</code> or <code>xs:untypedAtomic</code>, check its value against the pattern facet of <var>TT</var>, and raise a dynamic error [<a href="#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>] if the check fails.</p></li></ol></li><li><p><span style="display: none;" class="delete_version">Let <var>P(TT)</var> be the most specific primitive or quasi-primitive type of which <var>TT</var> is a subtype, as described in <a href="#casting-to-derived-types"><span class="delete_version"><b>23.3.1 Casting to derived types</b></span><span class="modify_version"><b>23.3.1 Casting to derived types</b></span></a>.</span><span style="display: none;" class="add_version">Let <var>P(TT)</var> be the most specific primitive or quasi-primitive type of which <var>TT</var> is a subtype, as described in <a href="#casting-to-derived-types"><span class="add_version"><b>24.3.1 Casting to derived types</b></span><span class="modify_version"><b>24.3.1 Casting to derived types</b></span></a>.</span><span class="modify_version">Let <var>P(TT)</var> be the most specific primitive or quasi-primitive type of which <var>TT</var> is a subtype, as described in <a href="#casting-to-derived-types"><span style="display: none;" class="delete_version"><b>23.3.1 Casting to derived types</b></span><span style="display: none;" class="add_version"><b>24.3.1 Casting to derived types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.1</span><span class="deltaxml-new" style="background:#90EE90">24.3.1</span> Casting to derived types</b></span></a>.</span></p><p><span style="display: none;" class="delete_version">Cast the value to <var>P(TT)</var>, as described in <a href="#casting-from-primitive-to-primitive"><span class="delete_version"><b>23.1 Casting from primitive types to primitive types</b></span><span class="modify_version"><b>23.1 Casting from primitive types to primitive types</b></span></a> if <var>P(TT)</var> is primitive, or as described in <a href="#casting-to-derived-types"><span class="delete_version"><b>23.3.1 Casting to derived types</b></span><span class="modify_version"><b>23.3.1 Casting to derived types</b></span></a> if <var>P(TT)</var> is quasi-primitive.</span><span style="display: none;" class="add_version">Cast the value to <var>P(TT)</var>, as described in <a href="#casting-from-primitive-to-primitive"><span class="add_version"><b>24.1 Casting from primitive types to primitive types</b></span><span class="modify_version"><b>24.1 Casting from primitive types to primitive types</b></span></a> if <var>P(TT)</var> is primitive, or as described in <a href="#casting-to-derived-types"><span class="add_version"><b>24.3.1 Casting to derived types</b></span><span class="modify_version"><b>24.3.1 Casting to derived types</b></span></a> if <var>P(TT)</var> is quasi-primitive.</span><span class="modify_version">Cast the value to <var>P(TT)</var>, as described in <a href="#casting-from-primitive-to-primitive"><span style="display: none;" class="delete_version"><b>23.1 Casting from primitive types to primitive types</b></span><span style="display: none;" class="add_version"><b>24.1 Casting from primitive types to primitive types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.1</span><span class="deltaxml-new" style="background:#90EE90">24.1</span> Casting from primitive types to primitive types</b></span></a> if <var>P(TT)</var> is primitive, or as described in <a href="#casting-to-derived-types"><span style="display: none;" class="delete_version"><b>23.3.1 Casting to derived types</b></span><span style="display: none;" class="add_version"><b>24.3.1 Casting to derived types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.1</span><span class="deltaxml-new" style="background:#90EE90">24.3.1</span> Casting to derived types</b></span></a> if <var>P(TT)</var> is quasi-primitive.</span></p><p>If <var>TT</var> is derived from <code>xs:NOTATION</code>, assume for the purposes of this rule that casting to <code>xs:NOTATION</code> succeeds.</p></li><li><p><span style="display: none;" class="delete_version">Cast the value down to the target type <var>TT</var>, as described in <a href="#casting-within-branch"><span class="delete_version"><b>23.3.5 Casting within a branch of the type hierarchy</b></span><span class="modify_version"><b>23.3.5 Casting within a branch of the type hierarchy</b></span></a></span><span style="display: none;" class="add_version">Cast the value down to the target type <var>TT</var>, as described in <a href="#casting-within-branch"><span class="add_version"><b>24.3.5 Casting within a branch of the type hierarchy</b></span><span class="modify_version"><b>24.3.5 Casting within a branch of the type hierarchy</b></span></a></span><span class="modify_version">Cast the value down to the target type <var>TT</var>, as described in <a href="#casting-within-branch"><span style="display: none;" class="delete_version"><b>23.3.5 Casting within a branch of the type hierarchy</b></span><span style="display: none;" class="add_version"><b>24.3.5 Casting within a branch of the type hierarchy</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.5</span><span class="deltaxml-new" style="background:#90EE90">24.3.5</span> Casting within a branch of the type hierarchy</b></span></a></span></p></li></ol></div><div class="_diffs div3"><h4><a id="casting-to-union"></a><span class="deltaxml-old" style="background:#FF5555">23.3.7</span><span class="deltaxml-new" style="background:#90EE90">24.3.7</span> <a href="#casting-to-union" style="text-decoration: none">Casting to union types</a></h4><p>If the target type of a cast expression (or a constructor function) is a type with variety union, the supplied value must be one of the following:</p><ol class="enumar"><li><p><span style="display: none;" class="delete_version">A value of type <code>xs:string</code> or <code>xs:untypedAtomic</code>. This case follows the general rules for casting from strings, and has already been described in <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span style="display: none;" class="add_version">A value of type <code>xs:string</code> or <code>xs:untypedAtomic</code>. This case follows the general rules for casting from strings, and has already been described in <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span class="modify_version">A value of type <code>xs:string</code> or <code>xs:untypedAtomic</code>. This case follows the general rules for casting from strings, and has already been described in <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>.</span></p><p>If the union type has a pattern facet, the pattern is tested against the supplied value after whitespace normalization, using the <code>whiteSpace</code> normalization rules of the member datatype against which validation succeeds.</p></li><li><p>A value that is an instance of one of the atomic types in the transitive membership of the union type, and of the union type itself. This case has already been described in <a href="#casting-from-derived-to-parent"><span style="display: none;" class="delete_version"><b>23.3.4 Casting from derived types to parent types</b></span><span style="display: none;" class="add_version"><b>24.3.4 Casting from derived types to parent types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.3.4</span><span class="deltaxml-new" style="background:#90EE90">24.3.4</span> Casting from derived types to parent types</b></span></a></p><p>This situation only applies when the value is an instance of the union type, which means it will never apply when the union is derived by facet-based restriction from another union type.</p></li><li><p>A value that is castable to one or more of the atomic types in the transitive membership of the union type (in the sense that the <code>castable as</code> operator returns <code>true</code>).</p><p>In this case the supplied value is cast to each atomic type in the transitive membership of the union type in turn (in the order in which the member types appear in the declaration) until one of these casts is successful; if none of them is successful, a dynamic error occurs [<a href="#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>]. If the union type has constraining facets then the resulting value must satisfy these facets, otherwise a dynamic error occurs [<a href="#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>].</p><p>If the union type has a pattern facet, the pattern is tested against the canonical representation of the result value.</p><p><span style="display: none;" class="delete_version">Only the atomic types in the transitive membership of the union type are considered. The union type may have list types in its transitive membership, but (unless the supplied value is of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, in which case the rules in <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a> apply), any list types in the membership are effectively ignored.</span><span style="display: none;" class="add_version">Only the atomic types in the transitive membership of the union type are considered. The union type may have list types in its transitive membership, but (unless the supplied value is of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, in which case the rules in <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a> apply), any list types in the membership are effectively ignored.</span><span class="modify_version">Only the atomic types in the transitive membership of the union type are considered. The union type may have list types in its transitive membership, but (unless the supplied value is of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, in which case the rules in <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a> apply), any list types in the membership are effectively ignored.</span></p></li></ol><p>If more than one of these conditions applies, then the casting is done according to the rules for the first condition that applies.</p><p>If none of these conditions applies, the cast fails with a dynamic error [<a href="#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>].</p><p>Example: consider a type <var>U</var> whose member types are <code>xs:integer</code> and <code>xs:date</code>.</p><ul><li><p>The expression <code>"123" cast as U</code> returns the <code>xs:integer</code> value <code>123</code>.</p></li><li><p>The expression <code>current-date() cast as U</code> returns the current date as an instance of <code>xs:date</code>.</p></li><li><p>The expression <code>23.1 cast as U</code> returns the <code>xs:integer</code> value <code>23</code>.</p></li></ul><p>Example: consider a type <var>V</var> whose member types are <code>xs:short</code> and <code>xs:negativeInteger</code>.</p><ul><li><p>The expression <code>"-123" cast as V</code> returns the <code>xs:short</code> value <code>-123</code>.</p></li><li><p>The expression <code>"-100000" cast as V</code> returns the <code>xs:negativeInteger</code> value <code>-100000</code>.</p></li><li><p>The expression <code>93.7 cast as V</code> returns the <code>xs:short</code> value <code>93</code>.</p></li><li><p>The expression <code>"93.7" cast as V</code> raises a dynamic error [<a href="#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>] on the grounds that the string <code>"93.7"</code> is not in the lexical space of the union type.</p></li></ul><p>Example: consider a type <var>W</var> that is derived from the above type <var>V</var> by restriction, with a pattern facet of <code>-?\d\d</code>.</p><ul><li><p>The expression <code>"12" cast as V</code> returns the <code>xs:short</code> value <code>12</code>.</p></li><li><p>The expression <code>"123" cast as V</code> raises an dynamic error [<a href="#ERRFORG0001" title="err:FORG0001">err:FORG0001</a>] on the grounds that the string <code>"123"</code> does not match the pattern facet.</p></li></ul></div><div class="_diffs div3"><h4><a id="casting-to-list"></a><span class="deltaxml-old" style="background:#FF5555">23.3.8</span><span class="deltaxml-new" style="background:#90EE90">24.3.8</span> <a href="#casting-to-list" style="text-decoration: none">Casting to list types</a></h4><p><span style="display: none;" class="delete_version">If the target type of a cast expression (or a constructor function) is a type with variety <code>list</code>, the supplied value must be of type <code>xs:string</code> or <code>xs:untypedAtomic</code>. The rules follow the general principle for all casts from <code>xs:string</code> outlined in <a href="#casting-from-strings"><span class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span style="display: none;" class="add_version">If the target type of a cast expression (or a constructor function) is a type with variety <code>list</code>, the supplied value must be of type <code>xs:string</code> or <code>xs:untypedAtomic</code>. The rules follow the general principle for all casts from <code>xs:string</code> outlined in <a href="#casting-from-strings"><span class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span></a>.</span><span class="modify_version">If the target type of a cast expression (or a constructor function) is a type with variety <code>list</code>, the supplied value must be of type <code>xs:string</code> or <code>xs:untypedAtomic</code>. The rules follow the general principle for all casts from <code>xs:string</code> outlined in <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a>.</span></p><p>If the supplied value is not of type <code>xs:string</code> or <code>xs:untypedAtomic</code>, a type error is raised [<a href="https://www.w3.org/TR/xpath20/#ERRXPTY0004" title="err:XPTY0004">err:XPTY0004</a>]<sup><small>XP</small></sup>.</p><p>The semantics of the operation are consistent with validation: that is, the effect of casting a string <var>S</var> to a list type <var>L</var> is the same as constructing an element or attribute node whose string value is <var>S</var>, validating it using <var>L</var> as the governing type, and atomizing the resulting node. The result will always be either failure, or a sequence of zero or more atomic items each of which is an instance of the item type of <var>L</var> (or if the item type of <var>L</var> is a union type, an instance of one of the atomic types in its transitive membership).</p><p>If the item type of the list type is namespace-sensitive, then the namespace bindings in the static context will be used to resolve any namespace prefix, in the same way as when the target type is <code>xs:QName</code>.</p><p>If the list type has a <code>pattern</code> facet, the pattern must match the supplied value after collapsing whitespace (an operation equivalent to the use of the <a href="#func-normalize-space"><code>fn:normalize-space</code></a> function).</p><p>For example, the expression <code>cast "A B C D" as xs:NMTOKENS</code> produces a sequence of four <code>xs:NMTOKEN</code> values, <code>("A", "B", "C", "D")</code>.</p><p>For example, given a user-defined type <code>my:coordinates</code> defined as a list of <code>xs:integer</code> with the facet <code>&lt;xs:length value="2"/&gt;</code>, the expression <code>my:coordinates("2 -1")</code> will return a sequence of two xs:integer values <code>(2, -1)</code>, while the expression <code>my:coordinates("1 2 3")</code> will result in a dynamic error because the length of the list does not conform to the <code>length</code> facet. The expression <code>my:coordinates("1.0 3.0")</code> will also fail because the strings <code>1.0</code> and <code>3.0</code> are not in the lexical space of <code>xs:integer</code>.</p></div></div></div></div><div class="back"><div class="_diffs div1"><h2><a id="error-summary"></a>B <a href="#error-summary" style="text-decoration: none">Error codes</a></h2><p>The error text provided with these errors is non-normative.</p><dl><dt><a id="ERRFOAP0001"></a>err:FOAP0001, Wrong number of arguments.</dt><dd><p>Raised when <a href="#func-apply"><code>fn:apply</code></a> is called and the arity of the supplied function is not the same as the number of members in the supplied array.</p></dd><dt><a id="ERRFOAR0001"></a>err:FOAR0001, Division by zero.</dt><dd><p>This error is raised whenever an attempt is made to divide by zero.</p></dd><dt><a id="ERRFOAR0002"></a>err:FOAR0002, Numeric operation overflow/underflow.</dt><dd><p>This error is raised whenever numeric operations result in an overflow or underflow.</p></dd><dt><a id="ERRFOAY0001"></a>err:FOAY0001, Array index out of bounds.</dt><dd><p>This error is raised when an integer used to select a member of an array is outside the range of values for that array.</p></dd><dt><a id="ERRFOAY0002"></a>err:FOAY0002, Negative array length.</dt><dd><p>This error is raised when the <code>$length</code> argument to <a href="#func-array-subarray"><code>array:subarray</code></a> is negative.</p></dd><dt><a id="ERRFOCA0001"></a>err:FOCA0001, Input value too large for decimal.</dt><dd><p>Raised when casting to <code>xs:decimal</code> if the supplied value exceeds the implementation-defined limits for the datatype.</p></dd><dt><a id="ERRFOCA0002"></a>err:FOCA0002, Invalid lexical value.</dt><dd><p>Raised by <a href="#func-resolve-QName"><code>fn:resolve-QName</code></a> and <a href="#func-QName"><code>fn:QName</code></a> when a supplied value does not have the lexical form of a QName or URI respectively; and when casting to decimal, if the supplied value is <code>NaN</code> or Infinity.</p></dd><dt><a id="ERRFOCA0003"></a>err:FOCA0003, Input value too large for integer.</dt><dd><p>Raised when casting to <code>xs:integer</code> if the supplied value exceeds the implementation-defined limits for the datatype.</p></dd><dt><a id="ERRFOCA0005"></a>err:FOCA0005, NaN supplied as float/double value.</dt><dd><p>Raised when multiplying or dividing a duration by a number, if the number supplied is <code>NaN</code>.</p></dd><dt><a id="ERRFOCA0006"></a>err:FOCA0006, String to be cast to decimal has too many digits of precision.</dt><dd><p>Raised when casting a string to <code>xs:decimal</code> if the string has more digits of precision than the implementation can represent (the implementation also has the option of rounding).</p></dd><dt><a id="ERRFOCH0001"></a>err:FOCH0001, Codepoint not valid.</dt><dd><p>Raised by <a href="#func-codepoints-to-string"><code>fn:codepoints-to-string</code></a> if the input contains an integer that is not the codepoint of a <a title="permitted character" class="termref" href="#dt-permitted-character">permitted character</a>.</p></dd><dt><a id="ERRFOCH0002"></a>err:FOCH0002, Unsupported collation.</dt><dd><p>Raised by any function that uses a collation if the requested collation is not recognized.</p></dd><dt><a id="ERRFOCH0003"></a>err:FOCH0003, Unsupported normalization form.</dt><dd><p>Raised by <a href="#func-normalize-unicode"><code>fn:normalize-unicode</code></a> if the requested normalization form is not supported by the implementation.</p></dd><dt><a id="ERRFOCH0004"></a>err:FOCH0004, Collation does not support collation units.</dt><dd><p>Raised by functions such as <a href="#func-contains"><code>fn:contains</code></a> if the requested collation does not operate on a character-by-character basis.</p></dd><dt><a id="ERRFOCH0005"></a>err:FOCH0005, Unrecognized or invalid character name.</dt><dd><p>Raised by <a href="#func-char"><code>fn:char</code></a> if the supplied character name is not recognized, or if it represents a codepoint that is not a <a title="permitted character" class="termref" href="#dt-permitted-character">permitted character</a>.</p></dd><dt><a id="ERRFOCV0001"></a>err:FOCV0001, CSV field quoting error.</dt><dd><p>Raised when parsing CSV input if a syntax error in the input CSV is found.</p></dd><dt><a id="ERRFOCV0002"></a>err:FOCV0002, Invalid CSV delimiter error.</dt><dd><p>Raised when parsing CSV input if the <code>field-separator</code>, <code>record-separator</code>, or <code>quote-character</code> option is set to an invalid value.</p></dd><dt><a id="ERRFOCV0003"></a>err:FOCV0003, Duplicate CSV delimiter error.</dt><dd><p>Raised when parsing CSV input if the same delimiter character is assigned to more than one role.</p></dd><dt><a id="ERRFOCV0004"></a>err:FOCV0004, Argument supplied is not a known column name.</dt><dd><p>Raised by the function from the <code>get</code> entry of <code>csv-columns-record</code>, if its <code>$key</code> argument is an <code>xs:string</code> and is not one of the known column names.</p></dd><dt><a id="ERRFODC0001"></a>err:FODC0001, No context document.</dt><dd><p>Raised by <a href="#func-id"><code>fn:id</code></a>, <a href="#func-idref"><code>fn:idref</code></a>, and <a href="#func-element-with-id"><code>fn:element-with-id</code></a> if the node that identifies the tree to be searched is a node in a tree whose root is not a document node.</p></dd><dt><a id="ERRFODC0002"></a>err:FODC0002, Error retrieving resource.</dt><dd><p>Raised by <a href="#func-doc"><code>fn:doc</code></a>, <a href="#func-collection"><code>fn:collection</code></a>, and <a href="#func-uri-collection"><code>fn:uri-collection</code></a> to indicate that either the supplied URI cannot be dereferenced to obtain a resource, or the resource that is returned is not parseable as XML.</p></dd><dt><a id="ERRFODC0003"></a>err:FODC0003, Function not defined as deterministic.</dt><dd><p>Raised by <a href="#func-doc"><code>fn:doc</code></a>, <a href="#func-collection"><code>fn:collection</code></a>, and <a href="#func-uri-collection"><code>fn:uri-collection</code></a> to indicate that it is not possible to return a result that is guaranteed deterministic.</p></dd><dt><a id="ERRFODC0004"></a>err:FODC0004, Invalid collection URI.</dt><dd><p>Raised by <a href="#func-collection"><code>fn:collection</code></a> and <a href="#func-uri-collection"><code>fn:uri-collection</code></a> if the argument is not a valid <code>xs:anyURI</code>.</p></dd><dt><a id="ERRFODC0005"></a>err:FODC0005, Invalid URI reference.</dt><dd><p>Raised (optionally) by <a href="#func-doc"><code>fn:doc</code></a> if the argument is not a valid <code>xs:anyURI</code>.</p></dd><dt><a id="ERRFODC0006"></a>err:FODC0006, String passed to fn:parse-xml is not a well-formed XML document.</dt><dd><p>Raised by <a href="#func-parse-xml"><code>fn:parse-xml</code></a> if the supplied string is not a well-formed and namespace-well-formed XML document; or if DTD validation is requested and the document is not valid against its DTD.</p></dd><dt><a id="ERRFODC0007"></a>err:FODC0007, String passed to fn:parse-xml is not a DTD-valid XML document.</dt><dd><p>Raised by <a href="#func-parse-xml"><code>fn:parse-xml</code></a> if DTD validation is requested and the supplied string has no DTD or is not valid against the DTD.</p></dd><dt><a id="ERRFODC0008"></a>err:FODC0008, Invalid value for the xsd-validation option of fn:parse-xml.</dt><dd><p>Raised when the <code>xsd-validation</code> option to <a href="#func-parse-xml"><code>fn:parse-xml</code></a> is supplied, and the value is not one of the permitted values; for example if the option <code>type Q{U}NNN</code> is used, and <code>Q{U}NNN</code> does not identify a type in the static context.</p></dd><dt><a id="ERRFODC0009"></a>err:FODC0009, Processor is not schema-aware.</dt><dd><p>Raised when the <code>xsd-validation</code> option to <a href="#func-parse-xml"><code>fn:parse-xml</code></a> is set to a value other than <code>skip</code>, if the processor is not schema-aware.</p></dd><dt><a id="ERRFODC0010"></a>err:FODC0010, The processor does not support serialization.</dt><dd><p>Raised when <a href="#func-serialize"><code>fn:serialize</code></a> is called and the processor does not support serialization, in cases where the host language makes serialization an optional feature.</p></dd><dt><a id="ERRFODC0011"></a>err:FODC0011, String passed to fn:parse-html is not a well-formed HTML document.</dt><dd><p>Raised by <a href="#func-parse-html"><code>fn:parse-html</code></a> if the supplied string is not a well-formed HTML document.</p></dd><dt><a id="ERRFODC0013"></a>err:FODC0013, No validating XML parser available.</dt><dd><p>Raised when the <code>dtd-validation</code> option to <a href="#func-parse-xml"><code>fn:parse-xml</code></a> is set, if no validating XML parser is available. Note: it is <span class="verb">recommended</span> that all processors should support the <code>dtd-validation</code> option, but there may be environments (such as web browsers) where this is not practically feasible.</p></dd><dt><a id="ERRFODC0014"></a>err:FODC0014, String passed to fn:parse-xml is not a schema-valid XML document.</dt><dd><p>Raised by <a href="#func-parse-xml"><code>fn:parse-xml</code></a> if XSD validation is requested and the XML document represented by the supplied string is not valid against the relevant XSD schema.</p></dd><dt><a id="ERRFODC0015"></a>err:FODC0015, Unable to compile schema for fn:xsd-validator.</dt><dd><p>Raised by <a href="#func-xsd-validator"><code>fn:xsd-validator</code></a> if it is not possible to assemble a valid and consistent schema.</p></dd><dt><a id="ERRFODF1280"></a>err:FODF1280, Invalid decimal format name.</dt><dd><p>This error is raised if the decimal format name supplied to <a href="#func-format-number"><code>fn:format-number</code></a> is not a valid QName, or if the prefix in the QName is undeclared, or if there is no decimal format in the static context with a matching name.</p></dd><dt><a id="ERRFODF1290"></a>err:FODF1290, Invalid decimal format property.</dt><dd><p>This error is raised if a decimal format value supplied to <a href="#func-format-number"><code>fn:format-number</code></a> is not valid for the associated property, or if the properties of the decimal format resulting from a supplied map do not have distinct values.</p></dd><dt><a id="ERRFODF1310"></a>err:FODF1310, Invalid decimal format picture string.</dt><dd><p>This error is raised if the picture string supplied to <a href="#func-format-number"><code>fn:format-number</code></a> or <a href="#func-format-integer"><code>fn:format-integer</code></a> has invalid syntax.</p></dd><dt><a id="ERRFODT0001"></a>err:FODT0001, Overflow/underflow in date/time operation.</dt><dd><p>Raised when casting to date/time datatypes, or performing arithmetic with date/time values, if arithmetic overflow or underflow occurs.</p></dd><dt><a id="ERRFODT0002"></a>err:FODT0002, Overflow/underflow in duration operation.</dt><dd><p>Raised when casting to duration datatypes, or performing arithmetic with duration values, if arithmetic overflow or underflow occurs.</p></dd><dt><a id="ERRFODT0003"></a>err:FODT0003, Invalid timezone value.</dt><dd><p>Raised by <code>adjust-date-to-timezone</code> and related functions if the supplied timezone is invalid.</p></dd><dt><a id="ERRFODT0004"></a>err:FODT0004, No timezone data available</dt><dd><p>Raised by <code>civil-timezone</code> if no timezone data is available for the given date/time and place.</p></dd><dt><a id="ERRFOER0000"></a>err:FOER0000, Unidentified error.</dt><dd><p>Error code used by <a href="#func-error"><code>fn:error</code></a> when no other error code is provided.</p></dd><dt><a id="ERRFOFD1340"></a>err:FOFD1340, Invalid date/time formatting parameters.</dt><dd><p>This error is raised if the picture string or calendar supplied to <a href="#func-format-date"><code>fn:format-date</code></a>, <a href="#func-format-time"><code>fn:format-time</code></a>, or <a href="#func-format-dateTime"><code>fn:format-dateTime</code></a> has invalid syntax.</p></dd><dt><a id="ERRFOFD1350"></a>err:FOFD1350, Invalid date/time formatting component.</dt><dd><p>This error is raised if the picture string supplied to <a href="#func-format-date"><code>fn:format-date</code></a> selects a component that is not present in a date, or if the picture string supplied to <a href="#func-format-time"><code>fn:format-time</code></a> selects a component that is not present in a time.</p></dd><dt><a id="ERRFOGR0001"></a><span class="deltaxml-new" style="background:#90EE90">err:FOGR0001, Attempt to access the value of a generator that is not initialized.</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A dynamic error is raised if the code attempts to access the current value of a generator whose </span><code><span class="deltaxml-new" style="background:#90EE90">initialized</span></code><span class="deltaxml-new" style="background:#90EE90"> field is </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRFOGR0002"></a><span class="deltaxml-new" style="background:#90EE90">err:FOGR0002, Attempt to access a value beyond the end of a generator.</span></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A dynamic error is raised if the code attempts to access the current value or move to the next state of a generator whose </span><code><span class="deltaxml-new" style="background:#90EE90">end-reached</span></code><span class="deltaxml-new" style="background:#90EE90"> field is </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></dd><dt><a id="ERRFOHA0001"></a>err:FOHA0001, Invalid algorithm.</dt><dd><p>Raised by <a href="#func-hash"><code>fn:hash</code></a> if the effective value of the supplied algorithm is not one of the values supported by the implementation.</p></dd><dt><a id="ERRFOJS0001"></a>err:FOJS0001, JSON syntax error.</dt><dd><p>Raised by functions such as <a href="#func-json-doc"><code>fn:json-doc</code></a>, <a href="#func-parse-json"><code>fn:parse-json</code></a> or <a href="#func-json-to-xml"><code>fn:json-to-xml</code></a> if the string supplied as input does not conform to the JSON grammar (optionally with implementation-defined extensions).</p></dd><dt><a id="ERRFOJS0003"></a>err:FOJS0003, JSON duplicate keys.</dt><dd><p>Raised by functions such as <a href="#func-map-merge"><code>map:merge</code></a>, <a href="#func-json-doc"><code>fn:json-doc</code></a>, <a href="#func-parse-json"><code>fn:parse-json</code></a> or <a href="#func-json-to-xml"><code>fn:json-to-xml</code></a> if the input contains duplicate keys, when the chosen policy is to reject duplicates.</p></dd><dt><a id="ERRFOJS0004"></a>err:FOJS0004, JSON: not schema-aware.</dt><dd><p>Raised by <a href="#func-json-to-xml"><code>fn:json-to-xml</code></a> if validation is requested when the processor does not support schema validation or typed nodes.</p></dd><dt><a id="ERRFOJS0005"></a>err:FOJS0005, Invalid options.</dt><dd><p>Raised by functions such as <a href="#func-map-merge"><code>map:merge</code></a>, <a href="#func-parse-json"><code>fn:parse-json</code></a>, and <a href="#func-xml-to-json"><code>fn:xml-to-json</code></a> if the <code>$options</code> map contains an invalid entry.</p></dd><dt><a id="ERRFOJS0006"></a>err:FOJS0006, Invalid XML representation of JSON.</dt><dd><p>Raised by <a href="#func-xml-to-json"><code>fn:xml-to-json</code></a> if the XML input does not conform to the rules for the XML representation of JSON.</p></dd><dt><a id="ERRFOJS0007"></a>err:FOJS0007, Bad JSON escape sequence.</dt><dd><p>Raised by <a href="#func-xml-to-json"><code>fn:xml-to-json</code></a> if the XML input uses the attribute <code>escaped="true"</code> or <code>escaped-key="true"</code>, and the corresponding string or key contains an invalid JSON escape sequence.</p></dd><dt><a id="ERRFOJS0008"></a>err:FOJS0008, Cannot convert element to map.</dt><dd><p>Raised by <a href="#func-element-to-map"><code>fn:element-to-map</code></a> if the layout selected for converting elements of a given name is unsuitable for an element node with that name, or if the conversion plan explicitly defines the processing of a particular element as an error.</p></dd><dt><a id="ERRFONS0004"></a>err:FONS0004, No namespace found for prefix.</dt><dd><p>Raised by <a href="#func-resolve-QName"><code>fn:resolve-QName</code></a> and analogous functions if a supplied QName has a prefix that has no binding to a namespace.</p></dd><dt><a id="ERRFONS0005"></a>err:FONS0005, Base-uri not defined in the static context.</dt><dd><p>Raised by <a href="#func-resolve-uri"><code>fn:resolve-uri</code></a> if no base URI is available for resolving a relative URI.</p></dd><dt><a id="ERRFOPA0001"></a>err:FOPA0001, Origin node is not an ancestor of the target node.</dt><dd><p>Raised by <a href="#func-path"><code>fn:path</code></a> if the node supplied in the <code>origin</code> option is not an ancestor of the <code>$node</code> whose relative path is required.</p></dd><dt><a id="ERRFOQM0001"></a>err:FOQM0001, Module URI is a zero-length string.</dt><dd><p>Raised by <a href="#func-load-xquery-module"><code>fn:load-xquery-module</code></a> if the supplied module URI is zero-length.</p></dd><dt><a id="ERRFOQM0002"></a>err:FOQM0002, Module URI not found.</dt><dd><p>Raised by <a href="#func-load-xquery-module"><code>fn:load-xquery-module</code></a> if no module can be found with the supplied module URI.</p></dd><dt><a id="ERRFOQM0003"></a>err:FOQM0003, Static error in dynamically loaded XQuery module.</dt><dd><p>Raised by <a href="#func-load-xquery-module"><code>fn:load-xquery-module</code></a> if a static error (including a statically detected type error) is encountered when processing the library module.</p></dd><dt><a id="ERRFOQM0005"></a>err:FOQM0005, Parameter for dynamically loaded XQuery module has incorrect type.</dt><dd><p>Raised by <a href="#func-load-xquery-module"><code>fn:load-xquery-module</code></a> if a value is supplied for the initial context item or for an external variable, and the value does not conform to the required type declared in the dynamically loaded module.</p></dd><dt><a id="ERRFOQM0006"></a>err:FOQM0006, No suitable XQuery processor available.</dt><dd><p>Raised by <a href="#func-load-xquery-module"><code>fn:load-xquery-module</code></a> if no XQuery processor is available supporting the requested XQuery version (or if none is available at all).</p></dd><dt><a id="ERRFORG0001"></a>err:FORG0001, Invalid value for cast/constructor.</dt><dd><p>A general-purpose error raised when casting, if a cast between two datatypes is allowed in principle, but the supplied value cannot be converted: for example when attempting to cast the string <code>"nine"</code> to an integer.</p></dd><dt><a id="ERRFORG0002"></a>err:FORG0002, Invalid argument to fn:resolve-uri.</dt><dd><p>Raised when either argument to <a href="#func-resolve-uri"><code>fn:resolve-uri</code></a> is not a valid URI/IRI.</p></dd><dt><a id="ERRFORG0003"></a>err:FORG0003, fn:zero-or-one called with a sequence containing more than one item.</dt><dd><p>Raised by <a href="#func-zero-or-one"><code>fn:zero-or-one</code></a> if the supplied value contains more than one item.</p></dd><dt><a id="ERRFORG0004"></a>err:FORG0004, fn:one-or-more called with a sequence containing no items.</dt><dd><p>Raised by <a href="#func-one-or-more"><code>fn:one-or-more</code></a> if the supplied value is an empty sequence.</p></dd><dt><a id="ERRFORG0005"></a>err:FORG0005, fn:exactly-one called with a sequence containing zero or more than one item.</dt><dd><p>Raised by <a href="#func-exactly-one"><code>fn:exactly-one</code></a> if the supplied value is not a singleton sequence.</p></dd><dt><a id="ERRFORG0006"></a>err:FORG0006, Invalid argument type.</dt><dd><p>Raised by functions such as <a href="#func-max"><code>fn:max</code></a>, <a href="#func-min"><code>fn:min</code></a>, <a href="#func-avg"><code>fn:avg</code></a>, <a href="#func-sum"><code>fn:sum</code></a> if the supplied sequence contains values inappropriate to this function.</p></dd><dt><a id="ERRFORG0008"></a>err:FORG0008, The two arguments to fn:dateTime have inconsistent timezones.</dt><dd><p>Raised by <a href="#func-dateTime"><code>fn:dateTime</code></a> if the two arguments both have timezones and the timezones are different.</p></dd><dt><a id="ERRFORG0009"></a>err:FORG0009, Error in resolving a relative URI against a base URI in fn:resolve-uri.</dt><dd><p>A catch-all error for <a href="#func-resolve-uri"><code>fn:resolve-uri</code></a>, recognizing that the implementation can choose between a variety of algorithms and that some of these may fail for a variety of reasons.</p></dd><dt><a id="ERRFORG0010"></a>err:FORG0010, Invalid date/time.</dt><dd><p>Raised when the input to <a href="#func-parse-ietf-date"><code>fn:parse-ietf-date</code></a> does not match the prescribed grammar, or when it represents an invalid date/time such as 31 February.</p></dd><dt><a id="ERRFORG0011"></a>err:FORG0011, Invalid radix.</dt><dd><p>Raised when the radix supplied to <a href="#func-parse-integer"><code>fn:parse-integer</code></a> is not in the range 2 to 36.</p></dd><dt><a id="ERRFORG0012"></a>err:FORG0012, Invalid digits.</dt><dd><p>Raised when the digits in the string supplied to <a href="#func-parse-integer"><code>fn:parse-integer</code></a> are not in the range appropriate to the chosen radix.</p></dd><dt><a id="ERRFORX0001"></a>err:FORX0001, Invalid regular expression flags.</dt><dd><p>Raised by regular expression functions such as <a href="#func-matches"><code>fn:matches</code></a> and <a href="#func-replace"><code>fn:replace</code></a> if the regular expression flags contain a character other than <code>i</code>, <code>m</code>, <code>q</code>, <code>s</code>, or <code>x</code>.</p></dd><dt><a id="ERRFORX0002"></a>err:FORX0002, Invalid regular expression.</dt><dd><p>Raised by regular expression functions such as <a href="#func-matches"><code>fn:matches</code></a> and <a href="#func-replace"><code>fn:replace</code></a> if the regular expression is syntactically invalid.</p></dd><dt><a id="ERRFORX0004"></a>err:FORX0004, Invalid replacement string.</dt><dd><p>Raised by <a href="#func-replace"><code>fn:replace</code></a> to report errors in the replacement string.</p></dd><dt><a id="ERRFORX0005"></a>err:FORX0005, Incompatible arguments for fn:replace.</dt><dd><p>Raised by <a href="#func-replace"><code>fn:replace</code></a> if both the <code>$replacement</code> and <code>$action</code> arguments are supplied.</p></dd><dt><a id="ERRFOTY0012"></a>err:FOTY0012, Argument to fn:data contains a node that does not have a typed value.</dt><dd><p>Raised by <a href="#func-data"><code>fn:data</code></a>, or by implicit atomization, if applied to a node with no typed value, the main example being an element validated against a complex type that defines it to have element-only content.</p></dd><dt><a id="ERRFOTY0013"></a>err:FOTY0013, The argument to fn:data contains a function item.</dt><dd><p>Raised by <a href="#func-data"><code>fn:data</code></a>, or by implicit atomization, if the sequence to be atomized contains a function item other than an array.</p></dd><dt><a id="ERRFOTY0014"></a>err:FOTY0014, The argument to fn:string is a function item.</dt><dd><p>Raised by <a href="#func-string"><code>fn:string</code></a>, or by implicit string conversion, if the input sequence contains a function item.</p></dd><dt><a id="ERRFOUR0001"></a>err:FOUR0001, Invalid IPv6/IPvFuture authority</dt><dd><p>A dynamic error is raised if the authority component of a URI contains an open square bracket but no corresponding close square bracket.</p></dd><dt><a id="ERRFOUT1170"></a>err:FOUT1170, Invalid URI reference.</dt><dd><p>Raised by <a href="#func-unparsed-text"><code>fn:unparsed-text</code></a> or <a href="#func-unparsed-text-lines"><code>fn:unparsed-text-lines</code></a> if the <code>$source</code> argument contains a fragment identifier, or if it cannot be resolved to an absolute URI (for example, because the base-URI property in the static context is absent), or if it cannot be used to retrieve the string representation of a resource.</p></dd><dt><a id="ERRFOUT1190"></a>err:FOUT1190, Cannot decode external resource.</dt><dd><p>Raised by <a href="#func-unparsed-text"><code>fn:unparsed-text</code></a> or <a href="#func-unparsed-text-lines"><code>fn:unparsed-text-lines</code></a> if the <code>$encoding</code> argument is not a valid encoding name, if the processor does not support the specified encoding, if the string representation of the retrieved resource contains octets that cannot be decoded into Unicode <a title="character" class="termref" href="#character">characters</a> using the specified encoding, or if the resulting characters are not <a title="permitted character" class="termref" href="#dt-permitted-character">permitted characters</a>.</p></dd><dt><a id="ERRFOUT1200"></a>err:FOUT1200, Cannot infer encoding of external resource.</dt><dd><p>Raised by <a href="#func-unparsed-text"><code>fn:unparsed-text</code></a> or <a href="#func-unparsed-text-lines"><code>fn:unparsed-text-lines</code></a> if the <code>$encoding</code> argument is absent and the processor cannot infer the encoding using external information and the encoding is not UTF-8.</p></dd><dt><a id="ERRFOXT0001"></a>err:FOXT0001, No suitable XSLT processor available</dt><dd><p>A dynamic error is raised if no XSLT processor suitable for evaluating a call on <a href="#func-transform"><code>fn:transform</code></a> is available.</p></dd><dt><a id="ERRFOXT0002"></a>err:FOXT0002, Invalid parameters to XSLT transformation</dt><dd><p>A dynamic error is raised if the parameters supplied to <a href="#func-transform"><code>fn:transform</code></a> are invalid, for example if two mutually exclusive parameters are supplied. If a suitable XSLT error code is available (for example in the case where the requested <code>initial-template</code> does not exist in the stylesheet), that error code should be used in preference.</p></dd><dt><a id="ERRFOXT0003"></a>err:FOXT0003, XSLT transformation failed</dt><dd><p>A dynamic error is raised if an XSLT transformation invoked using <a href="#func-transform"><code>fn:transform</code></a> fails with a static or dynamic error. The XSLT error code is used if available; this error code provides a fallback when no XSLT error code is returned, for example because the processor is an XSLT 1.0 processor.</p></dd><dt><a id="ERRFOXT0004"></a>err:FOXT0004, XSLT transformation has been disabled</dt><dd><p>A dynamic error is raised if the <a href="#func-transform"><code>fn:transform</code></a> function is invoked when XSLT transformation (or a specific transformation option) has been disabled for security or other reasons.</p></dd><dt><a id="ERRFOXT0006"></a>err:FOXT0006, XSLT output contains non-accepted characters</dt><dd><p>A dynamic error is raised if the result of the <a href="#func-transform"><code>fn:transform</code></a> function contains characters available only in XML 1.1 and the calling processor cannot handle such characters.</p></dd></dl></div><div class="_diffs div1"><h2><a id="id-built-in-named-record-types"></a>C <a href="#id-built-in-named-record-types" style="text-decoration: none">Built-in named record types</a></h2><div class="changes"><p class="changesHeading"> Changes in 4.0 (<a href="#schemata">next</a> | <a href="#casting-from-strings">previous</a>)</p><ol><li><p> Named record types used in the signatures of built-in functions are now available as standard in the static context. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/835">835</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1991">1991</a>&nbsp;11 May 2025]</i></p></li></ol></div><p>This appendix lists the named record types that are used in function signatures in this function library, and that are available in the static context of every application.</p><p>These definitions are all in the standard function namespace <code>http://www.w3.org/2005/xpath-functions</code>, which is normally bound to the prefix <code>fn</code>. Because this will not usually be the default namespace for types, the names will usually be written with the prefix <code>fn</code>.</p><ul><li class="add_version" style="display: none;"><p>Record <a href="#generator">generator</a></p></li><li class="modify_version"><p><span class="deltaxml-new" style="background:#90EE90">Record </span><a href="#generator"><span class="deltaxml-new" style="background:#90EE90">generator</span></a></p></li><li><p>Record <a href="#load-xquery-module-record">load-xquery-module-record</a></p></li><li><p>Record <a href="#parsed-csv-structure-record">parsed-csv-structure-record</a></p></li><li><p>Record <a href="#random-number-generator-record">random-number-generator-record</a></p></li><li><p>Record <a href="#schema-type-record">schema-type-record</a></p></li><li><p>Record <a href="#uri-structure-record">uri-structure-record</a></p></li></ul></div><div class="_diffs div1"><h2><a id="glossary"></a>E <a href="#glossary" style="text-decoration: none">Glossary</a> (Non-Normative)</h2><dl><dt><a href="#dt-atomic-item">atomic item</a></dt><dd><p>An <b>atomic item</b> is a pair (<var>T</var>, <var>D</var>) where <var>T</var> (the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>) is an atomic type, and <var>D</var> (the <a title="datum" class="termref" href="#dt-datum">datum</a>) is a point in the value space of <var>T</var>.</p></dd><dt><a href="#dt-capturing-subexpression">capturing subexpression</a></dt><dd><p>A left parenthesis is recognized as a capturing left parenthesis provided it is not immediately followed by <code>?</code> or <code>*</code> (see below), is not within a character group (square brackets), and is not escaped with a backslash. The sub-expression enclosed by a capturing left parenthesis and its matching right parenthesis is referred to as a <b>capturing subexpression</b>.</p></dd><dt><a href="#character">character</a></dt><dd><p>A <b>character</b> is an instance of the <a href="https://www.w3.org/TR/REC-xml/#NT-Char">Char</a><sup><small>XML</small></sup> production of <a href="#xml">[Extensible Markup Language (XML) 1.0 (Fifth Edition)]</a>.</p></dd><dt><a href="#dt-character-position">character position</a></dt><dd><p>A string of length <var>N</var> has <var>N+1</var><b>character positions</b>: one immediately before each character in the string, and one after the last character. In interfaces where character positions are exposed, they are numbered from 1 to <var>N+1</var>.</p></dd><dt><a href="#codepoint">codepoint</a></dt><dd><p>A <b>codepoint</b> is an integer assigned to a <a title="character" class="termref" href="#character">character</a> by the Unicode consortium, or reserved for future assignment to a character.</p></dd><dt><a href="#dt-collation">collation</a></dt><dd><p> A <b>collation</b> is an algorithm that determines, for any two given strings <var>S<sub>1</sub></var> and <var>S<sub>2</sub></var>, whether <var>S<sub>1</sub></var> is less than, equal to, or greater than <var>S<sub>2</sub></var>. In this specification, a collation is identified by an absolute URI.</p></dd><dt><a href="#dt-collation-unit">collation unit</a></dt><dd><p>The term <b>collation unit</b> as used in this specification is equivalent to the term <b>collation element</b> used in <a href="#UNICODE-TR10">[UTS #10]</a>.</p></dd><dt><a href="#dt-context-dependent">context-dependent</a></dt><dd><p>A <span><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-function-definition">function definition</a><sup><small>XP</small></sup></span> may have the property of being <b>context-dependent</b>: the result of such a function depends on the values of properties in the static and dynamic evaluation context <span>of the caller</span> as well as on the actual supplied arguments (if any). A function definition may be context-dependent for some arities in its arity range, and context-independent for others: for example <a href="#func-name"><code>fn:name#0</code></a> is context-dependent while <a href="#func-name"><code>fn:name#1</code></a> is context-independent.</p></dd><dt><a href="#dt-context-independent">context-independent</a></dt><dd><p>A <span><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-function-definition">function definition</a><sup><small>XP</small></sup></span> that is not <a title="context-dependent" class="termref" href="#dt-context-dependent">context-dependent</a> is called <b>context-independent</b>.</p></dd><dt><a href="#dt-contextually-equal">contextually equal</a></dt><dd><p>Two atomic items <var>A</var> and <var>B</var> are said to be <b>contextually equal</b> if the function call <code>fn:compare(<var>A</var>, <var>B</var>)</code> returns zero when evaluated with a specified or context-determined collation and implicit timezone.</p></dd><dt><a href="#dt-csv">CSV</a></dt><dd><p> The term <b>comma separated values</b> or <b>CSV</b> refers to a wide variety of plain-text tabular data formats with fields and records separated by standard character delimiters (often, but not invariably, commas).</p></dd><dt><a href="#dt-date-formatting-function">date formatting function</a></dt><dd><p>The three functions <a href="#func-format-dateTime"><code>fn:format-dateTime</code></a>, <a href="#func-format-date"><code>fn:format-date</code></a>, and <a href="#func-format-time"><code>fn:format-time</code></a> are referred to collectively as the <b>date formatting functions</b>.</p></dd><dt><a href="#dt-datum">datum</a></dt><dd><p>The <b>datum</b> of an <a title="atomic item" class="termref" href="#dt-atomic-item">atomic item</a> is a point in the value space of its type, which is also a point in the value space of the primitive type from which that type is derived.</p></dd><dt><a href="#dt-deterministic">deterministic</a></dt><dd><p>A function that is guaranteed to produce <a title="identical" class="termref" href="#dt-identical">identical</a> results from repeated calls within a single <a title="execution scope" class="termref" href="#execution-scope">execution scope</a> if the explicit and implicit arguments are identical is referred to as <b>deterministic</b>.</p></dd><dt><a href="#dt-decimal-digit-family">digit family</a></dt><dd><p>The <b>decimal digit family</b> of a decimal format is the sequence of ten digits with consecutive Unicode <a title="codepoint" class="termref" href="#codepoint">codepoints</a> starting with the character that is the value of the <a href="https://www.w3.org/TR/xpath-31/#id-static-decimal-format-zero-digit">zero-digit</a><sup><small>XP31</small></sup> property.</p></dd><dt><a href="#dt-disjoint-matching-segments">disjoint matching segments</a></dt><dd><p>The <b>disjoint matching segments</b> obtained by applying a regular expression <var>R</var> to a string <var>S</var> in the presence of a set of flags <var>F</var> are the <a title="segment" class="termref" href="#dt-segment">segments</a> of <var>S</var> that match <var>R</var> (using flags <var>F</var>), after elimination of overlapping segments.</p></dd><dt><a href="#dt-end-position">end position</a></dt><dd><p>The <b>end position</b> of a segment is the start position of the segment plus its length.</p></dd><dt><a href="#execution-scope">execution scope</a></dt><dd><p>An <b>execution scope</b> is a sequence of calls to the function library during which certain aspects of the state are required to remain invariant. For example, two calls to <a href="#func-current-dateTime"><code>fn:current-dateTime</code></a> within the same execution scope will return the same result. The execution scope is defined by the host language that invokes the function library.</p></dd><dt><a href="#expanded-name">expanded-QName</a></dt><dd><p> An <b>expanded-QName</b> is a value in the value space of the <code>xs:QName</code> datatype as defined in the XDM data model (see <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>): that is, a triple containing namespace prefix (optional), namespace URI (optional), and local name. Two expanded QNames are equal if the namespace URIs are the same (or both absent) and the local names are the same. The prefix plays no part in the comparison, but is used only if the expanded QName needs to be converted back to a string.</p></dd><dt><a href="#dt-focus-dependent">focus-dependent</a></dt><dd><p>A function is <b>focus-dependent</b> if its result depends on the <a href="https://www.w3.org/TR/xpath-31/#dt-focus">focus</a><sup><small>XP31</small></sup> (that is, the context item, position, or size) <span>of the caller</span>.</p></dd><dt><a href="#dt-focus-independent">focus-dependent</a></dt><dd><p>A function that is not <a title="focus-dependent" class="termref" href="#dt-focus-dependent">focus-dependent</a> is called <b>focus-independent</b>.</p></dd><dt><a href="#gr-collection-data-source"><span class="deltaxml-new" style="background:#90EE90">generator-collection-data-source</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> An </span><span><b><span class="deltaxml-new" style="background:#90EE90">XPath collection</span></b></span><span class="deltaxml-new" style="background:#90EE90"> or just </span><span><b><span class="deltaxml-new" style="background:#90EE90">collection</span></b></span><span class="deltaxml-new" style="background:#90EE90"> has nothing to do with the </span><code><span class="deltaxml-new" style="background:#90EE90">f:collection</span></code><span class="deltaxml-new" style="background:#90EE90"> function. An </span><span><b><span class="deltaxml-new" style="background:#90EE90">XPath collection</span></b></span><span class="deltaxml-new" style="background:#90EE90"> can be a sequence, an array or a map. </span></p></dd><dt><a href="#gr-empty-generator"><span class="deltaxml-new" style="background:#90EE90">generator-empty</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> A generator is </span><span><b><span class="deltaxml-new" style="background:#90EE90">empty</span></b></span><span class="deltaxml-new" style="background:#90EE90"> if and only if its field </span><code><span class="deltaxml-new" style="background:#90EE90">end-reached</span></code><span class="deltaxml-new" style="background:#90EE90"> has the effective boolean value </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">. An </span><span><b><span class="deltaxml-new" style="background:#90EE90">empty generator-instance</span></b></span><span class="deltaxml-new" style="background:#90EE90"> reached in the chain produced by successive evaluations of the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code><span class="deltaxml-new" style="background:#90EE90"> method signifies that the yield of a starting generator-instance has been fully traversed. It has the following properties: </span></p><ol class="enumar"><li><p><code><span class="deltaxml-new" style="background:#90EE90">get-current</span></code><span class="deltaxml-new" style="background:#90EE90">'s evaluation raises an error.</span></p></li><li><p><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code><span class="deltaxml-new" style="background:#90EE90">'s evaluation raises an error.</span></p></li></ol><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><p><span class="deltaxml-new" style="background:#90EE90">Empty generators may arise in two ways:</span></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">Produced by the function </span><code><span class="deltaxml-new" style="background:#90EE90">gn:empty-generator</span></code><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Termination of a chain of generator instances - the final value of repeated application of the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code><span class="deltaxml-new" style="background:#90EE90"> method is an empty generator instance.</span></p><p><span class="deltaxml-new" style="background:#90EE90">Generators with infinite yield never reach an empty-generator instance in this process.</span></p></li></ol></div><p></p></dd><dt><a href="#gr-instance"><span class="deltaxml-new" style="background:#90EE90">generator-instance</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> Generator </span><span><b><span class="deltaxml-new" style="background:#90EE90">instance</span></b></span><span class="deltaxml-new" style="background:#90EE90"> - a given instance of the </span><code><span class="deltaxml-new" style="background:#90EE90">f:generator</span></code><span class="deltaxml-new" style="background:#90EE90"> record or the result produced by a chain of one or more applications of the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code><span class="deltaxml-new" style="background:#90EE90"> method starting from a given </span><code><span class="deltaxml-new" style="background:#90EE90">f:generator</span></code><span class="deltaxml-new" style="background:#90EE90"> instance. </span></p></dd><dt><a href="#gr-next-value"><span class="deltaxml-new" style="background:#90EE90">generator-next-value</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> The term </span><span><b><span class="deltaxml-new" style="background:#90EE90">the next value of a generator</span></b></span><span class="deltaxml-new" style="background:#90EE90"> denotes the value returned from the </span><code><span class="deltaxml-new" style="background:#90EE90">get-current()</span></code><span class="deltaxml-new" style="background:#90EE90"> method applied on the generator-instance produced by the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> method, if the </span><code><span class="deltaxml-new" style="background:#90EE90">end-reached</span></code><span class="deltaxml-new" style="background:#90EE90"> field of this next generator-instance is </span><code><span class="deltaxml-new" style="background:#90EE90">false()</span></code><span class="deltaxml-new" style="background:#90EE90">. This is also the next value in the generator's </span><span><b><span class="deltaxml-new" style="background:#90EE90">yield</span></b></span><span class="deltaxml-new" style="background:#90EE90"> - see below. </span></p></dd><dt><a href="#gr-value"><span class="deltaxml-new" style="background:#90EE90">generator-value</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> Generator </span><span><b><span class="deltaxml-new" style="background:#90EE90">value</span></b></span><span class="deltaxml-new" style="background:#90EE90"> - a "value" produced by a call to the generator method </span><code><span class="deltaxml-new" style="background:#90EE90">get-current</span></code><span class="deltaxml-new" style="background:#90EE90"> can be either an individual XPath </span><code><span class="deltaxml-new" style="background:#90EE90">item()</span></code><span class="deltaxml-new" style="background:#90EE90"> or an XPath sequence. </span></p></dd><dt><a href="#gr-contents"><span class="deltaxml-new" style="background:#90EE90">generator-yield</span></a></dt><dd><p><span class="deltaxml-new" style="background:#90EE90"> The term </span><span><b><span class="deltaxml-new" style="background:#90EE90">yield</span></b><span class="deltaxml-new" style="background:#90EE90"> (of a generator)</span></span><span class="deltaxml-new" style="background:#90EE90"> denotes the consecutive values returned from calling the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> and then the </span><code><span class="deltaxml-new" style="background:#90EE90">get-current</span></code><span class="deltaxml-new" style="background:#90EE90"> method starting from the current generator instance, and on each generator instance thus produced, by applying the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> method and then the </span><code><span class="deltaxml-new" style="background:#90EE90">get-current</span></code><span class="deltaxml-new" style="background:#90EE90"> method until </span><code><span class="deltaxml-new" style="background:#90EE90">move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> produces a generator instance whose </span><code><span class="deltaxml-new" style="background:#90EE90">end-reached</span></code><span class="deltaxml-new" style="background:#90EE90"> field is </span><code><span class="deltaxml-new" style="background:#90EE90">true()</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p><div class="note"><p class="prefix"><b><span class="deltaxml-new" style="background:#90EE90">Note:</span></b></p><ol class="enumar"><li><p><span class="deltaxml-new" style="background:#90EE90">Thus, if the consecutive generator instances produced by continuously applying the </span><code><span class="deltaxml-new" style="background:#90EE90">move-next()</span></code><span class="deltaxml-new" style="background:#90EE90"> method on each of them, starting from the initialized </span><code><span class="deltaxml-new" style="background:#90EE90">$G1</span></code><span class="deltaxml-new" style="background:#90EE90"> generator is:</span></p><p><code><span class="deltaxml-new" style="background:#90EE90">$G2, $G3, ... , $Gn, ...</span></code><span class="deltaxml-new" style="background:#90EE90">, then the yield of the generator $G1 is exactly these consecutive generator values:</span></p><p><code><span class="deltaxml-new" style="background:#90EE90">$G1 =?&gt; get-current(), $G2 =?&gt; get-current(), ..., $Gn =?&gt; get-current(), ... </span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the sequence of the generator instances thus produced is finite (for the final produced generator </span><code><span class="deltaxml-new" style="background:#90EE90">$Gm</span></code><span class="deltaxml-new" style="background:#90EE90">, </span><code><span class="deltaxml-new" style="background:#90EE90">$Gm?end-reached eq true()</span></code><span class="deltaxml-new" style="background:#90EE90">, then the yield is:</span></p><p><code><span class="deltaxml-new" style="background:#90EE90">$G1 =?&gt; get-current(), $G2 =?&gt; get-current(), ..., $Gm-1 =?&gt; get-current()</span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">If the </span><code><span class="deltaxml-new" style="background:#90EE90">$G1</span></code><span class="deltaxml-new" style="background:#90EE90"> generator is not initialized (</span><code><span class="deltaxml-new" style="background:#90EE90">$G1?initialized eq false())</span></code><span class="deltaxml-new" style="background:#90EE90">, then the yield of this generator is the same as the yield of the (first initialized in the chain) </span><code><span class="deltaxml-new" style="background:#90EE90">$G2</span></code><span class="deltaxml-new" style="background:#90EE90"> generator:</span></p><p><code><span class="deltaxml-new" style="background:#90EE90">$G2 =?&gt; get-current(), $G3 =?&gt; get-current(), ..., $Gn =?&gt; get-current(), ... </span></code></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">The yield is empty, if </span><code><span class="deltaxml-new" style="background:#90EE90">$G1?end-reached eq true</span></code><span class="deltaxml-new" style="background:#90EE90"> and the yield is infinite if neither </span><code><span class="deltaxml-new" style="background:#90EE90">$G1?end-reached eq true()</span></code><span class="deltaxml-new" style="background:#90EE90"> nor any of the consecutive applications of </span><code><span class="deltaxml-new" style="background:#90EE90">move-next</span></code><span class="deltaxml-new" style="background:#90EE90"> produces a generator </span><code><span class="deltaxml-new" style="background:#90EE90">$Gx</span></code><span class="deltaxml-new" style="background:#90EE90">, such that </span><code><span class="deltaxml-new" style="background:#90EE90">$Gx?end-reached eq true()</span></code><span class="deltaxml-new" style="background:#90EE90">. </span></p></li></ol></div><p></p></dd><dt><a href="#dt-gregorian">Gregorian</a></dt><dd><p>The eight primitive types <code>xs:dateTime</code>, <code>xs:date</code>, <code>xs:time</code>, <code>xs:gYearMonth</code>, <code>xs:gYear</code>, <code>xs:gMonthDay</code>, <code>xs:gMonth</code>, <code>xs:gDay</code> are referred to collectively as the <b>Gregorian</b> types.</p></dd><dt><a href="#dt-higher-order">higher-order</a></dt><dd><p>Functions that accept functions among their arguments, or that return functions in their result, are described in this specification as <b>higher-order</b> functions.</p></dd><dt><a href="#dt-identical">identical</a></dt><dd><p>Two values <code>$V1</code> and <code>$V2</code> are defined to be <b>identical</b> if they contain the same number of items and the items are pairwise identical. Two items are identical if and only if one of the following conditions applies:</p></dd><dt><a href="#implementation-defined">implementation-defined</a></dt><dd><p>Where behavior is described as <b>implementation-defined</b>, variations between processors are permitted, but a conformant implementation <span class="verb">must</span> document the choices it has made.</p></dd><dt><a href="#implementation-dependent">implementation-dependent</a></dt><dd><p>Where behavior is described as <b>implementation-dependent</b>, variations between processors are permitted, and conformant implementations are not required to document the choices they have made.</p></dd><dt><a href="#dt-map">map</a></dt><dd><p>A <b>map</b> consists of a sequence of entries, also known as key-value pairs. Each entry comprises a key which is an arbitrary atomic item, and an arbitrary sequence called the associated value.</p></dd><dt><a href="#dt-match.collation">match</a></dt><dd><p>The term <b>match</b> is used in the sense of definition DS2 from <a href="#UNICODE-TR10">[UTS #10]</a>.</p></dd><dt><a href="#dt-minimal-match.collation">minimal match</a></dt><dd><p>The term <b>minimal match</b> is used in the sense of definition DS4 from <a href="#UNICODE-TR10">[UTS #10]</a>.</p></dd><dt><a href="#dt-nondeterministic">nondeterministic</a></dt><dd><p>A function that is not <a title="deterministic" class="termref" href="#dt-deterministic">deterministic</a> is referred to as <b>nondeterministic</b>.</p></dd><dt><a href="#dt-nondeterministic-wrt-ordering">nondeterministic with respect to ordering</a></dt><dd><p>Some functions (such as <a href="#func-in-scope-prefixes"><code>fn:in-scope-prefixes</code></a>, <a href="#func-load-xquery-module"><code>fn:load-xquery-module</code></a>, and <a href="#func-unordered"><code>fn:unordered</code></a>) produce result sequences or result maps in an <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a> or <a title="implementation-dependent" class="termref" href="#implementation-dependent">implementation-dependent</a> order. In such cases two calls with the same arguments are not guaranteed to produce the results in the same order. These functions are said to be <b>nondeterministic with respect to ordering</b>.</p></dd><dt><a href="#dt-optional-digit-character">optional digit character</a></dt><dd><p>The <b>optional digit character</b> is the character that is the value of the <a href="https://www.w3.org/TR/xpath-31/#id-static-decimal-format-digit">digit</a><sup><small>XP31</small></sup> property.</p></dd><dt><a href="#option-parameter-conventions">option parameter conventions</a></dt><dd><p>Functions that take an options parameter adopt common conventions on how the options are used. These are referred to as the <b>option parameter conventions</b>. These rules apply only to functions that explicitly refer to them.</p></dd><dt><a href="#dt-permitted-character">permitted character</a></dt><dd><p>A <b>permitted character</b> is one within the repertoire accepted by the implementation.</p></dd><dt><a href="#dt-picture-string">picture string</a></dt><dd><p>The formatting of a number is controlled by a <b>picture string</b>. The picture string is a sequence of <a title="character" class="termref" href="#character">characters</a>, in which the characters assigned to the properties <a href="https://www.w3.org/TR/xpath-31/#id-static-decimal-format-decimal-separator">decimal-separator</a><sup><small>XP31</small></sup> , <a href="https://www.w3.org/TR/xpath-31/#id-static-decimal-format-exponent-separator">exponent-separator</a><sup><small>XP31</small></sup>, <a href="https://www.w3.org/TR/xpath-31/#id-static-decimal-format-grouping-separator">grouping-separator</a><sup><small>XP31</small></sup>, <a href="https://www.w3.org/TR/xpath-31/#id-static-decimal-format-digit">digit</a><sup><small>XP31</small></sup>, and <a href="https://www.w3.org/TR/xpath-31/#id-static-decimal-format-pattern-separator">pattern-separator</a><sup><small>XP31</small></sup> and the members of the <a title="digit family" class="termref" href="#dt-decimal-digit-family">decimal digit family</a>, are classified as active characters, and all other characters (including the values of the properties <a href="https://www.w3.org/TR/xpath-31/#id-static-decimal-format-percent">percent</a><sup><small>XP31</small></sup> and <a href="https://www.w3.org/TR/xpath-31/#id-static-decimal-format-per-mille">per-mille</a><sup><small>XP31</small></sup>) are classified as passive characters.</p></dd><dt><a href="#dt-primitive-type">primitive type</a></dt><dd><p>A <b>primitive type</b> is one of the 19 <b>primitive atomic</b> types defined in <a href="https://www.w3.org/TR/xmlschema-2/#built-in-primitive-datatypes"> 3.2 Primitive datatypes</a><sup><small>XS2</small></sup> of <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a>, or the type <code>xs:untypedAtomic</code> defined in <a href="#xpath-datamodel-40">[XQuery and XPath Data Model (XDM) 4.0]</a>.</p></dd><dt><a href="#dt-same-key">same key</a></dt><dd><p>Within a map, no two entries have the <b>same key</b>. Two atomic items <code>K1</code> and <code>K2</code> are the <b>same key</b> for this purpose if the <span>function call <code>fn:atomic-equal($K1, $K2)</code></span> returns <code>true</code>.</p></dd><dt><a href="#dt-segment">segment</a></dt><dd><p>A <b>segment</b> of a string <var>S</var> is a sequence of zero or more contiguous characters starting at a given <a title="character position" class="termref" href="#dt-character-position">character position</a> within <var>S</var>.</p></dd><dt><a href="#dt-single-entry-map">single-entry map</a></dt><dd><p>A <b>single-entry map</b> is a map containing a single entry.</p></dd><dt><a href="#string">string</a></dt><dd><p>A <b>string</b> is a sequence of zero or more <a title="character" class="termref" href="#character">characters</a>, or equivalently, a value in the value space of the <code>xs:string</code> datatype.</p></dd><dt><a href="#dt-type-annotation">type annotation</a></dt><dd><p>The <b>type annotation</b> of an atomic item is the most specific atomic type that it is an instance of (it is also an instance of every type from which that type is derived).</p></dd><dt><a href="#dt-codepoint-collation">Unicode codepoint collation</a></dt><dd><p>The collation URI <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code> identifies a collation which must be recognized by every implementation: it is referred to as the <b>Unicode codepoint collation</b> (not to be confused with the Unicode collation algorithm).</p></dd><dt><a href="#dt-uri">URI</a></dt><dd><p>Within this specification, the term <b>URI</b> refers to Universal Resource Identifiers as defined in <a href="#rfc3986">[RFC 3986]</a> and extended in <a href="#rfc3987">[RFC 3987]</a> with a new name <b>IRI</b>. The term <b>URI Reference</b>, unless otherwise stated, refers to a string in the lexical space of the <code>xs:anyURI</code> datatype as defined in <a href="#xmlschema-2">[XML Schema Part 2: Datatypes Second Edition]</a>.</p></dd><dt><a href="#dt-variadic">variadic</a></dt><dd><p>The function <a href="#func-concat"><code>fn:concat</code></a> is defined to be variadic: it accepts any number of arguments. No other function has this property.</p></dd></dl></div><div class="_diffs div1"><h2><a id="changelog"></a>H <a href="#changelog" style="text-decoration: none">Changes since 3.1</a> (Non-Normative)</h2><div class="_diffs div2"><h3><a id="changes-summary"></a>H.1 <a href="#changes-summary" style="text-decoration: none">Summary of Changes</a></h3><ol><li><p>If a section of this specification has been updated since version 3.1, an overview of the changes is provided, along with links to navigate to the next or previous change.</p><p>See <a href="#intro"><b>1 Introduction</b></a></p></li><li><p>Sections with significant changes are marked with a ✭ symbol in the table of contents. New functions are indicated by ✚.</p><p>See <a href="#intro"><b>1 Introduction</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1504 2329">1504 2329&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-insert-separator"><b>2.1.7 fn:insert-separator</b></a></p></li><li><p>New in 4.0</p><p>See <a href="#func-replicate"><b>2.1.10 fn:replicate</b></a></p></li><li><p>New in 4.0</p><p>See <a href="#func-slice"><b>2.1.12 fn:slice</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1120 1150">1120 1150&nbsp;</a></p><p>A callback function can be supplied for comparing individual items.</p><p>See <a href="#func-deep-equal"><b>2.2.4 fn:deep-equal</b></a></p></li><li><p>Changed in 4.0 to use transitive equality comparisons for numeric values.</p><p>See <a href="#func-distinct-values"><b>2.2.5 fn:distinct-values</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/614 987">614 987&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-duplicate-values"><b>2.2.6 fn:duplicate-values</b></a></p></li><li><p>New in 4.0. Originally proposed under the name <code>fn:uniform</code></p><p>See <a href="#func-all-equal"><b>2.4.2 fn:all-equal</b></a></p></li><li><p>New in 4.0. Originally proposed under the name <code>fn:unique</code></p><p>See <a href="#func-all-different"><b>2.4.3 fn:all-different</b></a></p></li><li><p>New in 4.0</p><p>See <a href="#func-every"><b>2.5.3 fn:every</b></a></p></li><li><p>New in 4.0</p><p>See <a href="#func-highest"><b>2.5.9 fn:highest</b></a></p></li><li><p>New in 4.0</p><p>See <a href="#func-index-where"><b>2.5.10 fn:index-where</b></a></p></li><li><p>New in 4.0</p><p>See <a href="#func-lowest"><b>2.5.11 fn:lowest</b></a></p></li><li><p>New in 4.0</p><p>See <a href="#func-scan-right"><b>2.5.15 fn:scan-right</b></a></p></li><li><p>New in 4.0</p><p>See <a href="#func-some"><b>2.5.16 fn:some</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/795 2228">795 2228&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-sort-with"><b>2.5.19 fn:sort-with</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/521 761">521 761&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-transitive-closure"><b>2.5.22 fn:transitive-closure</b></a></p></li><li><p>New in 4.0</p><p>See <a href="#func-is-NaN"><b>4.4.5 fn:is-NaN</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1260 1275">1260 1275&nbsp;</a></p><p>A third argument has been added, providing control over the rounding mode.</p><p>See <a href="#func-round"><b>4.4.6 fn:round</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1049 1151">1049 1151&nbsp;</a></p><p>Decimal format parameters can now be supplied directly as a map in the third argument, rather than referencing a format defined in the static context.</p><p>See <a href="#func-format-number"><b>4.7.2 fn:format-number</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1205 1230">1205 1230&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-math-e"><b>4.8.2 math:e</b></a></p><p>See <a href="#func-math-cosh"><b>4.8.8 math:cosh</b></a></p><p>See <a href="#func-math-sinh"><b>4.8.15 math:sinh</b></a></p><p>See <a href="#func-math-tanh"><b>4.8.18 math:tanh</b></a></p></li><li><p>The 3.1 specification suggested that every value in the result range should have the same chance of being chosen. This has been corrected to say that the distribution should be arithmetically uniform (because there are as many <code>xs:double</code> values between 0.01 and 0.1 as there are between 0.1 and 1.0).</p><p>See <a href="#func-random-number-generator"><b>4.9.2 fn:random-number-generator</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/261 306 993">261 306 993&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-char"><b>5.4.1 fn:char</b></a></p></li><li><p>New in 4.0</p><p>See <a href="#func-characters"><b>5.4.2 fn:characters</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/937 995 1190">937 995 1190&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-hash"><b>5.4.13 fn:hash</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/215 415 ">215 415 &nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-parse-uri"><b>7.6.2 fn:parse-uri</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1423 1413">1423 1413&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-build-uri"><b>7.6.3 fn:build-uri</b></a></p></li><li><p>New in 4.0</p><p>See <a href="#func-in-scope-namespaces"><b>12.2.2 fn:in-scope-namespaces</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1620 1886">1620 1886&nbsp;</a></p><p>Options are added to customize the form of the output.</p><p>See <a href="#func-path"><b>12.2.9 fn:path</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1547 1551">1547 1551&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-siblings"><b>12.2.11 fn:siblings</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/969 1134">969 1134&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-map-filter"><b>14.4.6 map:filter</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/478 515">478 515&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-map-keys-where"><b>14.4.12 map:keys-where</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1575 1906">1575 1906&nbsp;</a></p><p> A new function <a href="#func-element-to-map"><code>fn:element-to-map</code></a> is provided for converting XDM trees to maps suitable for serialization as JSON. Unlike the <a href="#func-xml-to-json"><code>fn:xml-to-json</code></a> function retained from 3.1, this can handle arbitrary XML as input. </p><p>See <a href="#xml-to-json-mappings"><b>14.5 Converting elements to maps</b></a></p></li><li><p>New in 4.0</p><p>See <a href="#func-array-empty"><b>15.2.3 array:empty</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/968 1295">968 1295&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-array-index-of"><b>15.2.13 array:index-of</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/476 1087">476 1087&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-array-items"><b>15.2.16 array:items</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/360 476">360 476&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-array-members"><b>15.2.18 array:members</b></a></p><p>See <a href="#func-array-of-members"><b>15.2.19 array:of-members</b></a></p></li><li><p>Supplying an empty sequence as the value of an optional argument is equivalent to omitting the argument.</p><p>See <a href="#func-array-subarray"><b>15.2.29 array:subarray</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1117 1279">1117 1279&nbsp;</a></p><p>The <code>$options</code> parameter has been added.</p><p>See <a href="#func-unparsed-text-lines"><b>17.1.6 fn:unparsed-text-lines</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/259 956">259 956&nbsp;</a></p><p> A new function is available for processing input data in HTML format. </p><p>See <a href="#html-functions"><b>17.3 Functions on HTML Data</b></a></p><p>New in 4.0</p><p>See <a href="#func-parse-html"><b>17.3.2 fn:parse-html</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/975 1058 1246">975 1058 1246&nbsp;</a></p><p>An option is provided to control how JSON numbers should be formatted.</p><p>See <a href="#func-parse-json"><b>17.4.4 fn:parse-json</b></a></p></li><li><p>Additional options are available, as defined by <a href="#func-parse-json"><code>fn:parse-json</code></a>.</p><p>See <a href="#func-json-doc"><b>17.4.5 fn:json-doc</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/533 719 834 1066">533 719 834 1066&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-csv-to-arrays"><b>17.5.4 fn:csv-to-arrays</b></a></p><p>See <a href="#func-parse-csv"><b>17.5.7 fn:parse-csv</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/533 719 834 1066 1605">533 719 834 1066 1605&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-csv-to-xml"><b>17.5.10 fn:csv-to-xml</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/791 1256 1282 1405">791 1256 1282 1405&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-invisible-xml"><b>17.6.1 fn:invisible-xml</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/629 803">629 803&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-message"><span style="display: none;" class="delete_version"><b>21.2.2 fn:message</b></span><span style="display: none;" class="add_version"><b>22.2.2 fn:message</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">21.2.2</span><span class="deltaxml-new" style="background:#90EE90">22.2.2</span> fn:message</b></span></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/533 719 834">533 719 834&nbsp;</a></p><p> New functions are available for processing input data in CSV (comma separated values) format. </p><p>See <a href="#csv-functions"><b>17.5 Functions on CSV Data</b></a></p></li><li><p>Comparison of mixed numeric types (for example <code>xs:double</code> and <code>xs:decimal</code>) now generally converts both values to <code>xs:decimal</code>.</p><p>See <a href="#comp.numeric"><b>4.3 Comparing numeric values</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/289 1901">289 1901&nbsp;</a></p><p>A third argument is added, allowing user control of how absent keys should be handled.</p><p>See <a href="#func-map-get"><b>14.4.9 map:get</b></a></p><p>A third argument is added, allowing user control of how index-out-of-bounds conditions should be handled.</p><p>See <a href="#func-array-get"><b>15.2.11 array:get</b></a></p></li><li><p> A new collation URI is defined for Unicode case-insensitive comparison and ordering. </p><p>See <a href="#unicode-case-insensitive-collation"><b>5.3.5 The Unicode case-insensitive collation</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1727 1740">1727 1740&nbsp;</a></p><p>It is no longer guaranteed that the new key replaces the existing key.</p><p>See <a href="#func-map-put"><b>14.4.14 map:put</b></a></p></li><li><p>The group may remove this function, it is considered <a href="#at-risk">at risk</a>. </p><p>See <a href="#func-array-members"><b>15.2.18 array:members</b></a></p><p>See <a href="#func-array-of-members"><b>15.2.19 array:of-members</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/173">173&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-op"><span style="display: none;" class="delete_version"><b>18.4 fn:op</b></span><span style="display: none;" class="add_version"><b>19.4 fn:op</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">18.4</span><span class="deltaxml-new" style="background:#90EE90">19.4</span> fn:op</b></span></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/203">203&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-map-build"><b>14.4.1 map:build</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/207">207&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-parse-QName"><b>10.1.2 fn:parse-QName</b></a></p><p>See <a href="#func-expanded-QName"><b>10.2.5 fn:expanded-QName</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/222">222&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-contains-subsequence"><b>2.2.3 fn:contains-subsequence</b></a></p><p>See <a href="#func-ends-with-subsequence"><b>2.2.7 fn:ends-with-subsequence</b></a></p><p>See <a href="#func-starts-with-subsequence"><b>2.2.9 fn:starts-with-subsequence</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/250">250&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-foot"><b>2.1.3 fn:foot</b></a></p><p>See <a href="#func-trunk"><b>2.1.15 fn:trunk</b></a></p><p>See <a href="#func-array-build"><b>15.2.2 array:build</b></a></p><p>See <a href="#func-array-foot"><b>15.2.8 array:foot</b></a></p><p>See <a href="#func-array-trunk"><b>15.2.31 array:trunk</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/258">258&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-array-index-where"><b>15.2.14 array:index-where</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/313">313&nbsp;</a></p><p>The second argument can now be a sequence of integers.</p><p>See <a href="#func-remove"><b>2.1.9 fn:remove</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/319">319&nbsp;</a></p><p>New in 4.0. The function replaces the internal <a href="#dt-same-key"><code>op:same-key</code></a> function in 3.1</p><p>See <a href="#func-atomic-equal"><b>2.2.1 fn:atomic-equal</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/326">326&nbsp;</a></p><p>Higher-order functions are no longer an optional feature.</p><p>See <a href="#conformance"><b>1.2 Conformance</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/360">360&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-map-entries"><b>14.4.4 map:entries</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/419">419&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-items-at"><b>2.1.8 fn:items-at</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/434">434&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-parse-integer"><b>4.5.2 fn:parse-integer</b></a></p><p>The function has been extended to allow output in a radix other than 10, for example in hexadecimal.</p><p>See <a href="#func-format-integer"><b>4.6.1 fn:format-integer</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/477">477&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-array-slice"><b>15.2.24 array:slice</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/482">482&nbsp;</a></p><p>Deleted an inaccurate statement concerning the behavior of NaN.</p><p>See <a href="#comp.numeric"><b>4.3 Comparing numeric values</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/507">507&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-partition"><b>2.5.13 fn:partition</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/546">546&nbsp;</a></p><p>It is no longer automatically an error if the input contains a codepoint that is not valid in XML. Instead, the codepoint must be a <a title="permitted character" class="termref" href="#dt-permitted-character">permitted character</a>. The set of permitted characters is <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a>, but it is <span class="verb">recommended</span> that all Unicode characters should be accepted.</p><p>See <a href="#func-codepoints-to-string"><b>5.2.1 fn:codepoints-to-string</b></a></p><p>It is no longer automatically an error if the resource (after decoding) contains a codepoint that is not valid in XML. Instead, the codepoint must be a <a title="permitted character" class="termref" href="#dt-permitted-character">permitted character</a>. The set of permitted characters is <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a>, but it is <span class="verb">recommended</span> that all Unicode characters should be accepted.</p><p>See <a href="#func-unparsed-text"><b>17.1.5 fn:unparsed-text</b></a></p><p> The rules regarding use of non-XML characters in JSON texts have been relaxed. </p><p>See <a href="#json-character-repertoire"><b>17.4.3 JSON character repertoire</b></a></p><p>See <a href="#func-parse-json"><b>17.4.4 fn:parse-json</b></a></p><p>It is no longer automatically an error if the input contains a codepoint that is not valid in XML. Instead, the codepoint must be a <a title="permitted character" class="termref" href="#dt-permitted-character">permitted character</a>. The set of permitted characters is <a title="implementation-defined" class="termref" href="#implementation-defined">implementation-defined</a>, but it is <span class="verb">recommended</span> that all Unicode characters should be accepted.</p><p>See <a href="#func-json-doc"><b>17.4.5 fn:json-doc</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/609">609&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-array-split"><b>15.2.28 array:split</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/631">631&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-decode-from-uri"><b>7.1 fn:decode-from-uri</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/662">662&nbsp;</a></p><p> Constructor functions now have a zero-arity form; the first argument defaults to the context item. </p><p>See <a href="#constructor-functions"><span style="display: none;" class="delete_version"><b>22 Constructor functions</b></span><span style="display: none;" class="add_version"><b>23 Constructor functions</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22</span><span class="deltaxml-new" style="background:#90EE90">23</span> Constructor functions</b></span></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/680">680&nbsp;</a></p><p> The case-insensitive collation is now defined normatively within this specification, rather than by reference to the HTML "living specification", which is subject to change. The collation can now be used for ordering comparisons as well as equality comparisons. </p><p>See <a href="#html-ascii-case-insensitive-collation"><b>5.3.6 The HTML ASCII Case-Insensitive Collation</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/702">702&nbsp;</a></p><p>The function can now take any number of arguments (previously it had to be two or more), and the arguments can be sequences of strings rather than single strings.</p><p>See <a href="#func-concat"><b>5.4.4 fn:concat</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/710">710&nbsp;</a></p><p>Changes the function to return a sequence of key-value pairs rather than a map.</p><p>See <a href="#func-function-annotations"><b>13.5 fn:function-annotations</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/727">727&nbsp;</a></p><p>It has been clarified that loading a module has no effect on the static or dynamic context of the caller.</p><p>See <a href="#func-load-xquery-module"><span style="display: none;" class="delete_version"><b>18.2 fn:load-xquery-module</b></span><span style="display: none;" class="add_version"><b>19.2 fn:load-xquery-module</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">18.2</span><span class="deltaxml-new" style="background:#90EE90">19.2</span> fn:load-xquery-module</b></span></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/828">828&nbsp;</a></p><p>The <code>$predicate</code> callback function accepts an optional position argument.</p><p>See <a href="#func-filter"><b>2.5.4 fn:filter</b></a></p><p>The <code>$action</code> callback function accepts an optional position argument.</p><p>See <a href="#func-for-each"><b>2.5.7 fn:for-each</b></a></p><p>See <a href="#func-for-each-pair"><b>2.5.8 fn:for-each-pair</b></a></p><p>The <code>$predicate</code> callback function now accepts an optional position argument.</p><p>See <a href="#func-array-filter"><b>15.2.4 array:filter</b></a></p><p>The <code>$action</code> callback function now accepts an optional position argument.</p><p>See <a href="#func-array-for-each"><b>15.2.9 array:for-each</b></a></p><p>See <a href="#func-array-for-each-pair"><b>15.2.10 array:for-each-pair</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/881">881&nbsp;</a></p><p>The way that <a href="#func-min"><code>fn:min</code></a> and <a href="#func-max"><code>fn:max</code></a> compare numeric values of different types has changed. The most noticeable effect is that when these functions are applied to a sequence of <code>xs:integer</code> or <code>xs:decimal</code> values, the result is an <code>xs:integer</code> or <code>xs:decimal</code>, rather than the result of converting this to an <code>xs:float</code> or <code>xs:double</code>.</p><p>See <a href="#func-max"><b>2.4.5 fn:max</b></a></p><p>See <a href="#func-min"><b>2.4.6 fn:min</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/901">901&nbsp;</a></p><p>The optional third argument can now be supplied as an empty sequence.</p><p>See <a href="#func-subsequence"><b>2.1.13 fn:subsequence</b></a></p><p>The third argument can now be supplied as an empty sequence.</p><p>See <a href="#func-substring"><b>5.4.6 fn:substring</b></a></p><p>The second argument can now be an empty sequence.</p><p>See <a href="#func-tokenize"><b>6.3.3 fn:tokenize</b></a></p><p>The optional second argument can now be supplied as an empty sequence.</p><p>See <a href="#func-resolve-uri"><b>7.5 fn:resolve-uri</b></a></p><p>The 3rd, 4th, and 5th arguments are now optional; previously the function required either 2 or 5 arguments.</p><p>See <a href="#func-format-dateTime"><b>9.8.1 fn:format-dateTime</b></a></p><p>See <a href="#func-format-date"><b>9.8.2 fn:format-date</b></a></p><p>See <a href="#func-format-time"><b>9.8.3 fn:format-time</b></a></p><p>All three arguments are now optional, and each argument can be set to an empty sequence. Previously if <code>$description</code> was supplied, it could not be empty.</p><p>See <a href="#func-error"><span style="display: none;" class="delete_version"><b>21.1.1 fn:error</b></span><span style="display: none;" class="add_version"><b>22.1.1 fn:error</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">21.1.1</span><span class="deltaxml-new" style="background:#90EE90">22.1.1</span> fn:error</b></span></a></p><p>The <code>$label</code> argument can now be set to an empty sequence. Previously if <code>$label</code> was supplied, it could not be empty.</p><p>See <a href="#func-trace"><span style="display: none;" class="delete_version"><b>21.2.1 fn:trace</b></span><span style="display: none;" class="add_version"><b>22.2.1 fn:trace</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">21.2.1</span><span class="deltaxml-new" style="background:#90EE90">22.2.1</span> fn:trace</b></span></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/905">905&nbsp;</a></p><p>The rule that multiple calls on <a href="#func-doc"><code>fn:doc</code></a> supplying the same absolute URI must return the same document node has been clarified; in particular the rule does not apply if the dynamic context for the two calls requires different processing of the documents (such as schema validation or whitespace stripping).</p><p>See <a href="#func-doc"><b>17.1.1 fn:doc</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/909">909&nbsp;</a></p><p>The function has been expanded in scope to handle comparison of values other than strings.</p><p>See <a href="#func-compare"><b>2.2.2 fn:compare</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/924">924&nbsp;</a></p><p> Rules have been added clarifying that users should not be allowed to change the schema for the <code>fn</code> namespace. </p><p>See <a href="#schemata"><b>D Schemas</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/925">925&nbsp;</a></p><p>The decimal format name can now be supplied as a value of type <code>xs:QName</code>, as an alternative to supplying a lexical QName as an instance of <code>xs:string</code>.</p><p>See <a href="#func-format-number"><b>4.7.2 fn:format-number</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/932">932&nbsp;</a></p><p> The specification now prescribes a minimum precision and range for durations. </p><p>See <a href="#duration-conformance"><b>8.1.2 Limits and precision</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/933">933&nbsp;</a></p><p>When comments and processing instructions are ignored, any text nodes either side of the comment or processing instruction are now merged prior to comparison.</p><p>See <a href="#func-deep-equal"><b>2.2.4 fn:deep-equal</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/940">940&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-subsequence-where"><b>2.5.20 fn:subsequence-where</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/953">953&nbsp;</a></p><p> Constructor functions for named record types have been introduced. </p><p>See <a href="#id-constructors-for-record-tests"><span style="display: none;" class="delete_version"><b>22.6 Constructor functions for named record types</b></span><span style="display: none;" class="add_version"><b>23.6 Constructor functions for named record types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">22.6</span><span class="deltaxml-new" style="background:#90EE90">23.6</span> Constructor functions for named record types</b></span></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/962">962&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-do-until"><b>2.5.2 fn:do-until</b></a></p><p>See <a href="#func-while-do"><b>2.5.23 fn:while-do</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/969">969&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-map-empty"><b>14.4.3 map:empty</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/984">984&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-seconds"><b>8.4.1 fn:seconds</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/987">987&nbsp;</a></p><p>The order of results is now prescribed; it was previously implementation-dependent.</p><p>See <a href="#func-distinct-values"><b>2.2.5 fn:distinct-values</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1022">1022&nbsp;</a></p><p> Regular expressions can include comments (starting and ending with <code>#</code>) if the <code>c</code> flag is set. </p><p>See <a href="#regex-syntax"><b>6.1 Regular expression syntax</b></a></p><p>See <a href="#flags"><b>6.2 Flags</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1028">1028&nbsp;</a></p><p>An option is provided to control how the JSON <code>null</code> value should be handled.</p><p>See <a href="#func-parse-json"><b>17.4.4 fn:parse-json</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1032">1032&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-void"><b>2.1.17 fn:void</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1046">1046&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-take-while"><b>2.5.21 fn:take-while</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1059">1059&nbsp;</a></p><p> Use of an option keyword that is not defined in the specification and is not known to the implementation now results in a dynamic error; previously it was ignored. </p><p>See <a href="#options"><b>1.7 Options</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1068">1068&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-graphemes"><b>5.4.3 fn:graphemes</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1072">1072&nbsp;</a></p><p>The return type is now specified more precisely.</p><p>See <a href="#func-load-xquery-module"><span style="display: none;" class="delete_version"><b>18.2 fn:load-xquery-module</b></span><span style="display: none;" class="add_version"><b>19.2 fn:load-xquery-module</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">18.2</span><span class="deltaxml-new" style="background:#90EE90">19.2</span> fn:load-xquery-module</b></span></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1090">1090&nbsp;</a></p><p> When casting from a string to a duration or time or dateTime, it is now specified that when there are more digits in the fractional seconds than the implementation is able to retain, excess digits are truncated. Rounding upwards (which could affect the number of minutes or hours in the value) is not permitted. </p><p>See <a href="#casting-from-strings"><span style="display: none;" class="delete_version"><b>23.2 Casting from xs:string and xs:untypedAtomic</b></span><span style="display: none;" class="add_version"><b>24.2 Casting from xs:string and xs:untypedAtomic</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.2</span><span class="deltaxml-new" style="background:#90EE90">24.2</span> Casting from xs:string and xs:untypedAtomic</b></span></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1093">1093&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-collation"><b>5.3.9 fn:collation</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1117">1117&nbsp;</a></p><p>The <code>$options</code> parameter has been added.</p><p>See <a href="#func-unparsed-text"><b>17.1.5 fn:unparsed-text</b></a></p><p>See <a href="#func-unparsed-text-available"><b>17.1.7 fn:unparsed-text-available</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1182">1182&nbsp;</a></p><p>The <code>$predicate</code> callback function may return an empty sequence (meaning <code>false</code>).</p><p>See <a href="#func-do-until"><b>2.5.2 fn:do-until</b></a></p><p>See <a href="#func-every"><b>2.5.3 fn:every</b></a></p><p>See <a href="#func-filter"><b>2.5.4 fn:filter</b></a></p><p>See <a href="#func-index-where"><b>2.5.10 fn:index-where</b></a></p><p>See <a href="#func-some"><b>2.5.16 fn:some</b></a></p><p>See <a href="#func-take-while"><b>2.5.21 fn:take-while</b></a></p><p>See <a href="#func-while-do"><b>2.5.23 fn:while-do</b></a></p><p>See <a href="#func-map-filter"><b>14.4.6 map:filter</b></a></p><p>See <a href="#func-map-keys-where"><b>14.4.12 map:keys-where</b></a></p><p>See <a href="#func-array-filter"><b>15.2.4 array:filter</b></a></p><p>See <a href="#func-array-index-where"><b>15.2.14 array:index-where</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1191">1191&nbsp;</a></p><p>The <code>$options</code> parameter has been added, absorbing the <code>$collation</code> parameter.</p><p>See <a href="#func-deep-equal"><b>2.2.4 fn:deep-equal</b></a></p><p>New in 4.0</p><p>See <a href="#func-distinct-ordered-nodes"><b>12.3.1 fn:distinct-ordered-nodes</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1250">1250&nbsp;</a></p><p>For selected properties including <code>percent</code> and <code>exponent-separator</code>, it is now possible to specify a single-character marker to be used in the picture string, together with a multi-character rendition to be used in the formatted output.</p><p>See <a href="#func-format-number"><b>4.7.2 fn:format-number</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1257">1257&nbsp;</a></p><p>The <code>$options</code> parameter has been added.</p><p>See <a href="#func-parse-xml"><b>17.2.1 fn:parse-xml</b></a></p><p>See <a href="#func-parse-xml-fragment"><b>17.2.2 fn:parse-xml-fragment</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1262">1262&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-collation-available"><b>5.3.10 fn:collation-available</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1265">1265&nbsp;</a></p><p>The constraints on the result of the function have been relaxed.</p><p>See <a href="#func-document-uri"><b>12.1.2 fn:document-uri</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1280">1280&nbsp;</a></p><p>As a result of changes to the coercion rules, the number of supplied arguments can be greater than the number required: extra arguments are ignored.</p><p>See <a href="#func-apply"><b>2.5.1 fn:apply</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1288">1288&nbsp;</a></p><p>Additional error conditions have been defined.</p><p>See <a href="#func-parse-xml"><b>17.2.1 fn:parse-xml</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1296">1296&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-scan-left"><b>2.5.14 fn:scan-left</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1333">1333&nbsp;</a></p><p>A new option is provided to allow the content of the loaded module to be supplied as a string.</p><p>See <a href="#func-load-xquery-module"><span style="display: none;" class="delete_version"><b>18.2 fn:load-xquery-module</b></span><span style="display: none;" class="add_version"><b>19.2 fn:load-xquery-module</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">18.2</span><span class="deltaxml-new" style="background:#90EE90">19.2</span> fn:load-xquery-module</b></span></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1353">1353&nbsp;</a></p><p>An option has been added to suppress the escaping of the solidus (forwards slash) character.</p><p>See <a href="#func-xml-to-json"><b>17.4.7 fn:xml-to-json</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1358">1358&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-unix-dateTime"><b>9.3.2 fn:unix-dateTime</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1361">1361&nbsp;</a></p><p> The term <b>atomic value</b> has been replaced by <b>atomic item</b>. </p><p>See <a href="#terminology"><b>1.9 Terminology</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1393">1393&nbsp;</a></p><p>Changes the function to return a sequence of key-value pairs rather than a map.</p><p>See <a href="#func-function-annotations"><b>13.5 fn:function-annotations</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1409">1409&nbsp;</a></p><p> This section now uses the term <b>primitive type</b> strictly to refer to the 20 atomic types that are not derived by restriction from another atomic type: that is, the 19 primitive atomic types defined in XSD, plus <code>xs:untypedAtomic</code>. The three types <code>xs:integer</code>, <code>xs:dayTimeDuration</code>, and <code>xs:yearMonthDuration</code>, which have custom casting rules but are not strictly-speaking primitive, are now handled in other subsections. </p><p>See <a href="#casting-from-primitive-to-primitive"><span style="display: none;" class="delete_version"><b>23.1 Casting from primitive types to primitive types</b></span><span style="display: none;" class="add_version"><b>24.1 Casting from primitive types to primitive types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.1</span><span class="deltaxml-new" style="background:#90EE90">24.1</span> Casting from primitive types to primitive types</b></span></a></p><p> The rules for conversion of dates and times to strings are now defined entirely in terms of XSD 1.1 canonical mappings, since these deliver exactly the same result as the XPath 3.1 rules. </p><p>See <a href="#casting-date-time-to-string"><span style="display: none;" class="delete_version"><b>23.1.2.2 Casting date/time values to xs:string</b></span><span style="display: none;" class="add_version"><b>24.1.2.2 Casting date/time values to xs:string</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.1.2.2</span><span class="deltaxml-new" style="background:#90EE90">24.1.2.2</span> Casting date/time values to xs:string</b></span></a></p><p> The rules for conversion of durations to strings are now defined entirely in terms of XSD 1.1 canonical mappings, since the XSD 1.1 rules deliver exactly the same result as the XPath 3.1 rules. </p><p>See <a href="#casting-duration-to-string"><span style="display: none;" class="delete_version"><b>23.1.2.3 Casting xs:duration values to xs:string</b></span><span style="display: none;" class="add_version"><b>24.1.2.3 Casting xs:duration values to xs:string</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">23.1.2.3</span><span class="deltaxml-new" style="background:#90EE90">24.1.2.3</span> Casting xs:duration values to xs:string</b></span></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1455">1455&nbsp;</a></p><p>Numbers now retain their original lexical form, except for any changes needed to satisfy JSON syntax rules (for example, stripping leading zero digits).</p><p>See <a href="#func-xml-to-json"><b>17.4.7 fn:xml-to-json</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1473">1473&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-identity"><b>2.1.5 fn:identity</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1481">1481&nbsp;</a></p><p>The function has been extended to handle other Gregorian types such as <code>xs:gYearMonth</code>.</p><p>See <a href="#func-year-from-dateTime"><b>9.5.1 fn:year-from-dateTime</b></a></p><p>See <a href="#func-month-from-dateTime"><b>9.5.2 fn:month-from-dateTime</b></a></p><p>The function has been extended to handle other Gregorian types such as <code>xs:gMonthDay</code>.</p><p>See <a href="#func-day-from-dateTime"><b>9.5.3 fn:day-from-dateTime</b></a></p><p>The function has been extended to handle other types including <code>xs:time</code>.</p><p>See <a href="#func-hours-from-dateTime"><b>9.5.4 fn:hours-from-dateTime</b></a></p><p>See <a href="#func-minutes-from-dateTime"><b>9.5.5 fn:minutes-from-dateTime</b></a></p><p>The function has been extended to handle other types such as <code>xs:gYearMonth</code>.</p><p>See <a href="#func-timezone-from-dateTime"><b>9.5.7 fn:timezone-from-dateTime</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1523">1523&nbsp;</a></p><p> New functions are provided to obtain information about built-in types and types defined in an imported schema. </p><p>See <a href="#functions-on-types"><span style="display: none;" class="delete_version"><b>19 Processing types</b></span><span style="display: none;" class="add_version"><b>20 Processing types</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">19</span><span class="deltaxml-new" style="background:#90EE90">20</span> Processing types</b></span></a></p><p>New in 4.0</p><p>See <a href="#func-schema-type"><span style="display: none;" class="delete_version"><b>19.1.2 fn:schema-type</b></span><span style="display: none;" class="add_version"><b>20.1.2 fn:schema-type</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">19.1.2</span><span class="deltaxml-new" style="background:#90EE90">20.1.2</span> fn:schema-type</b></span></a></p><p>See <a href="#func-atomic-type-annotation"><span style="display: none;" class="delete_version"><b>19.1.4 fn:atomic-type-annotation</b></span><span style="display: none;" class="add_version"><b>20.1.4 fn:atomic-type-annotation</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">19.1.4</span><span class="deltaxml-new" style="background:#90EE90">20.1.4</span> fn:atomic-type-annotation</b></span></a></p><p>See <a href="#func-node-type-annotation"><span style="display: none;" class="delete_version"><b>19.1.5 fn:node-type-annotation</b></span><span style="display: none;" class="add_version"><b>20.1.5 fn:node-type-annotation</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">19.1.5</span><span class="deltaxml-new" style="background:#90EE90">20.1.5</span> fn:node-type-annotation</b></span></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1545">1545&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-civil-timezone"><b>9.6.4 fn:civil-timezone</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1565">1565&nbsp;</a></p><p>The default for the <code>escape</code> option has been changed to <code>false</code>. The 3.1 specification gave the default value as <code>true</code>, but this appears to have been an error, since it was inconsistent with examples given in the specification and with tests in the test suite.</p><p>See <a href="#func-parse-json"><b>17.4.4 fn:parse-json</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1570">1570&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-type-of"><span style="display: none;" class="delete_version"><b>19.1.3 fn:type-of</b></span><span style="display: none;" class="add_version"><b>20.1.3 fn:type-of</b></span><span class="modify_version"><b><span class="deltaxml-old" style="background:#FF5555">19.1.3</span><span class="deltaxml-new" style="background:#90EE90">20.1.3</span> fn:type-of</b></span></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1587">1587&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-unparsed-binary"><b>17.1.8 fn:unparsed-binary</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1611">1611&nbsp;</a></p><p>The spec has been corrected to note that the function depends on the implicit timezone.</p><p>See <a href="#func-compare"><b>2.2.2 fn:compare</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1671">1671&nbsp;</a></p><p>New in 4.0.</p><p>See <a href="#func-divide-decimals"><b>4.4.3 fn:divide-decimals</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1687">1687&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-map-items"><b>14.4.10 map:items</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1703">1703&nbsp;</a></p><p>Ordered maps are introduced.</p><p>See <a href="#map-ordering"><b>14.1 Ordering of Maps</b></a></p><p>Enhanced to allow for ordered maps.</p><p>See <a href="#func-map-filter"><b>14.4.6 map:filter</b></a></p><p>See <a href="#func-map-find"><b>14.4.7 map:find</b></a></p><p>See <a href="#func-map-for-each"><b>14.4.8 map:for-each</b></a></p><p>See <a href="#func-map-put"><b>14.4.14 map:put</b></a></p><p>See <a href="#func-map-remove"><b>14.4.15 map:remove</b></a></p><p>The order of entries in maps is retained.</p><p>See <a href="#func-parse-json"><b>17.4.4 fn:parse-json</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1711">1711&nbsp;</a></p><p>It is explicitly stated that the limits for <code>$precision</code> are implementation-defined.</p><p>See <a href="#func-round"><b>4.4.6 fn:round</b></a></p><p>See <a href="#func-round-half-to-even"><b>4.4.7 fn:round-half-to-even</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1727">1727&nbsp;</a></p><p>For consistency with the new function <a href="#func-map-build"><code>map:build</code></a>, the handling of duplicates may now be controlled by supplying a user-defined callback function as an alternative to the fixed values for the earlier <code>duplicates</code> option.</p><p>See <a href="#func-map-merge"><b>14.4.13 map:merge</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1734">1734&nbsp;</a></p><p>In 3.1, given a mixed input sequence such as (1, 3, 4.2e0), the specification was unclear whether it was permitted to add the first two integer items using integer arithmetic, rather than converting all items to doubles before performing any arithmetic. The 4.0 specification is clear that this is permitted; but since the items can be reordered before being added, this is not required.</p><p>See <a href="#func-avg"><b>2.4.4 fn:avg</b></a></p><p>See <a href="#func-sum"><b>2.4.7 fn:sum</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1825">1825&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-partial-apply"><b>2.5.12 fn:partial-apply</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1856">1856&nbsp;</a></p><p> Word boundaries can be matched. Lookahead and lookbehind assertions are supported. Assertions (including <code>^</code> and <code>$</code>) can no longer be followed by a quantifier. </p><p>See <a href="#regex-syntax"><b>6.1 Regular expression syntax</b></a></p><p>The output of the function is extended to allow the represention of captured groups found within lookahead assertions.</p><p>See <a href="#func-analyze-string"><b>6.3.4 fn:analyze-string</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1879">1879&nbsp;</a></p><p>Additional options to control DTD and XInclude processing have been added.</p><p>See <a href="#func-parse-xml"><b>17.2.1 fn:parse-xml</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1897">1897&nbsp;</a></p><p>The <code>$replacement</code> argument can now be a function that computes the replacement strings.</p><p>See <a href="#func-replace"><b>6.3.2 fn:replace</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1906">1906&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-element-to-map-plan"><b>14.5.10 fn:element-to-map-plan</b></a></p><p>New in 4.0.</p><p>See <a href="#func-element-to-map"><b>14.5.11 fn:element-to-map</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1910">1910&nbsp;</a></p><p>An <code>$options</code> parameter is added. Note that the rules for the <code>$options</code> parameter control aspects of processing that were implementation-defined in earlier versions of this specification. An implementation may provide configuration options designed to retain backwards-compatible behavior when no explicit options are supplied.</p><p>See <a href="#func-doc"><b>17.1.1 fn:doc</b></a></p><p>See <a href="#func-doc-available"><b>17.1.2 fn:doc-available</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1913">1913&nbsp;</a></p><p>It is now permitted for the regular expression to match a zero-length string.</p><p>See <a href="#func-replace"><b>6.3.2 fn:replace</b></a></p><p>See <a href="#func-tokenize"><b>6.3.3 fn:tokenize</b></a></p><p>See <a href="#func-analyze-string"><b>6.3.4 fn:analyze-string</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1933">1933&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-xsd-validator"><b>17.2.5 fn:xsd-validator</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1991">1991&nbsp;</a></p><p> Named record types used in the signatures of built-in functions are now available as standard in the static context. </p><p>See <a href="#id-built-in-named-record-types"><b>C Built-in named record types</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2001">2001&nbsp;</a></p><p>New in 4.0.</p><p>See <a href="#func-sort-by"><b>2.5.18 fn:sort-by</b></a></p><p>See <a href="#func-array-sort-by"><b>15.2.26 array:sort-by</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2013">2013&nbsp;</a></p><p>Support for binary input has been added.</p><p>See <a href="#func-parse-xml"><b>17.2.1 fn:parse-xml</b></a></p><p>See <a href="#func-parse-xml-fragment"><b>17.2.2 fn:parse-xml-fragment</b></a></p><p>New in 4.0</p><p>See <a href="#func-html-doc"><b>17.3.3 fn:html-doc</b></a></p><p>See <a href="#func-csv-doc"><b>17.5.8 fn:csv-doc</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2030">2030&nbsp;</a></p><p> This description of the XSD validation process was previously found (with some duplication) in the XQuery and XSLT specifications; those specifications now reference this description. As a side-effects, the descriptions of the process in XQuery and XSLT are better aligned. </p><p>See <a href="#xsd-validation"><b>17.2.4 XSD validation</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2031">2031&nbsp;</a></p><p> Introduced the concept of JNodes. </p><p>See <a href="#processing-jnodes"><b>16 Processing JNodes</b></a></p><p>New in 4.0</p><p>See <a href="#func-jtree"><b>16.1.1 fn:jtree</b></a></p><p>See <a href="#func-jnode-selector"><b>16.1.3 fn:jnode-selector</b></a></p><p>See <a href="#func-jnode-position"><b>16.1.4 fn:jnode-position</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2149">2149&nbsp;</a></p><p>Generalized to work with JNodes as well as XNodes.</p><p>See <a href="#func-has-children"><b>12.2.1 fn:has-children</b></a></p><p>The function is extended to handle JNodes.</p><p>See <a href="#func-path"><b>12.2.9 fn:path</b></a></p><p>Generalized to work with JNodes as well as XNodes.</p><p>See <a href="#func-innermost"><b>12.3.2 fn:innermost</b></a></p><p>See <a href="#func-outermost"><b>12.3.3 fn:outermost</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2168">2168&nbsp;</a></p><p>Atomic items of types <code>xs:hexBinary</code> and <code>xs:base64Binary</code> are now mutually comparable. In rare cases, where an application uses both types and assumes they are distinct, this can represent a backwards incompatibility.</p><p>See <a href="#func-atomic-equal"><b>2.2.1 fn:atomic-equal</b></a></p><p>See <a href="#func-deep-equal"><b>2.2.4 fn:deep-equal</b></a></p><p>See <a href="#func-distinct-values"><b>2.2.5 fn:distinct-values</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2223">2223&nbsp;</a></p><p>An error may now be raised if the base URI is not a valid LEIRI reference.</p><p>See <a href="#func-base-uri"><b>12.1.1 fn:base-uri</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2224">2224&nbsp;</a></p><p>The <code>$action</code> callback function now accepts an optional position argument.</p><p>See <a href="#func-map-filter"><b>14.4.6 map:filter</b></a></p><p>See <a href="#func-map-for-each"><b>14.4.8 map:for-each</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2228">2228&nbsp;</a></p><p>New in 4.0</p><p>See <a href="#func-array-sort-with"><b>15.2.27 array:sort-with</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2249">2249&nbsp;</a></p><p>The specification now describes in more detail how to determine the effective encoding value.</p><p>See <a href="#func-unparsed-text"><b>17.1.5 fn:unparsed-text</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2256">2256&nbsp;</a></p><p>In the interests of consistency, the <a href="#func-index-of"><code>index-of</code></a> function now defines equality to mean <a title="contextually equal" class="termref" href="#dt-contextually-equal">contextually equal</a>. This has the implication that <code>NaN</code> is now considered equal to <code>NaN</code>.</p><p>See <a href="#func-index-of"><b>2.2.8 fn:index-of</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2259">2259&nbsp;</a></p><p>A new parameter <code>canonical</code> is available to give control over serialization of XML, XHTML, and JSON.</p><p>See <a href="#func-serialize"><b>17.2.3 fn:serialize</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2286">2286&nbsp;</a></p><p>The type of <code>$value</code> has been generalized to <code>xs:anyAtomicType?</code>.</p><p>See <a href="#func-string-length"><b>5.4.7 fn:string-length</b></a></p><p>See <a href="#func-normalize-space"><b>5.4.8 fn:normalize-space</b></a></p></li><li><p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2387">2387&nbsp;</a></p><p>It is now recommended that out-of-range <code>xs:double</code> values should translate to positive or negative infinity.</p><p>See <a href="#func-parse-json"><b>17.4.4 fn:parse-json</b></a></p></li></ol></div></div></div><script src="js/toc.js"></script><script src="/js/scroll.js"></script></body></html>